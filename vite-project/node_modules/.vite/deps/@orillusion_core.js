var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../../../../../node_modules/@orillusion/core/dist/orillusion.es.js
var _M = class _M {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    __publicField(this, "r", 0);
    __publicField(this, "g", 0);
    __publicField(this, "b", 0);
    __publicField(this, "a", 0);
    this.setTo(e, t, r, i);
  }
  convertToHDRRGB() {
    return this.r = this.r * Math.pow(2.4, this.a), this.g = this.g * Math.pow(2.4, this.a), this.b = this.b * Math.pow(2.4, this.a), this;
  }
  unSerialized(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }
  hexToRGB(e) {
    return this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  hexToRGBA(e) {
    return this.a = (e >> 24 & 255) / 255, this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
  }
  static random(e = 1) {
    let t = new _M();
    return t.a = e, t.r = e * Math.random(), t.g = e * Math.random(), t.b = e * Math.random(), t;
  }
  static randomRGB(e = 0.5, t = 0.5, r = 0.5, i = 0.5, a = 0.5, o = 0.5) {
    let n = new _M();
    return n.a = 1, n.r = i + e * Math.random(), n.g = a + t * Math.random(), n.b = o + r * Math.random(), n;
  }
  static randomGray(e = 0.5, t = 0.5) {
    let r = Math.random() * t + e, i = new _M();
    return i.a = 1, i.r = r, i.g = r, i.b = r, i;
  }
  setTo(e, t, r, i) {
    this.r = Math.max(e, 0), this.g = Math.max(t, 0), this.b = Math.max(r, 0), this.a = Math.max(i, 0);
  }
  setHex(e) {
    if (typeof e != "string" || _M.NON_HEX_CHARS.test(e) || !_M.VALID_HEX_SIZE.test(e))
      throw new TypeError("Expected a valid hex string");
    e = e.replace(/^#/, "");
    let t = 1;
    e.length === 8 && (t = Number.parseInt(e.slice(6, 8), 16) / 255, e = e.slice(0, 6)), e.length === 4 && (t = Number.parseInt(e.slice(3, 4).repeat(2), 16) / 255, e = e.slice(0, 3)), e.length === 3 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]);
    const r = Number.parseInt(e, 16), i = r >> 16, a = r >> 8 & 255, o = r & 255, n = t;
    this.a = n, this.r = i / 255, this.g = a / 255, this.b = o / 255;
  }
  getHex() {
    let e = (r) => {
      r *= 255;
      let i = r.toString(16);
      return i.length === 1 && (i = "0" + i), i;
    };
    return e(this.r) + e(this.g) + e(this.b) + e(this.a);
  }
  get rgb() {
    return [this.r * 255 >>> 0, this.g * 255 >>> 0, this.b * 255 >>> 0];
  }
  set rgb(e) {
    this.setTo(e[0] / 255, e[1] / 255, e[2] / 255, this.a);
  }
  get rgba() {
    return [this.r * 255 >>> 0, this.g * 255 >>> 0, this.b * 255 >>> 0, this.a * 255 >>> 0];
  }
  set rgba(e) {
    this.setTo(e[0] / 255, e[1] / 255, e[2] / 255, e[3] / 255);
  }
  clone() {
    return new _M().copyFrom(this);
  }
  copyFrom(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }
  copyFromArray(e, t = 255) {
    return this.r = e[0] / t, this.g = e[1] / t, this.b = e[2] / t, this.a = e[3] / t, this;
  }
  copyFromVector(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this.a = e.w, this;
  }
  static hexRGBColor(e, t = null) {
    return t = t || new _M(), t.hexToRGB(e), t;
  }
  static lerp(e, t, r, i) {
    let a = i || new _M();
    return a.r = (r.r - t.r) * e + t.r, a.g = (r.g - t.g) * e + t.g, a.b = (r.b - t.b) * e + t.b, a.a = (r.a - t.a) * e + t.a, i;
  }
};
__publicField(_M, "COLOR_RED", new _M(1, 0, 0, 1));
__publicField(_M, "COLOR_GREEN", new _M(0, 1, 0, 1));
__publicField(_M, "COLOR_BLUE", new _M(0, 0, 1, 1));
__publicField(_M, "COLOR_WHITE", new _M(1, 1, 1, 1));
__publicField(_M, "COLOR_0", new _M());
__publicField(_M, "COLOR_1", new _M());
__publicField(_M, "COLOR_2", new _M());
__publicField(_M, "HEX_CHARACTERS", "a-f\\d");
__publicField(_M, "MATCH_3OR4_HEX", `#?[${_M.HEX_CHARACTERS}]{3}[${_M.HEX_CHARACTERS}]?`);
__publicField(_M, "MATCH_6OR8_HEX", `#?[${_M.HEX_CHARACTERS}]{6}([${_M.HEX_CHARACTERS}]{2})?`);
__publicField(_M, "NON_HEX_CHARS", new RegExp(`[^#${_M.HEX_CHARACTERS}]`, "gi"));
__publicField(_M, "VALID_HEX_SIZE", new RegExp(`^${_M.MATCH_3OR4_HEX}$|^${_M.MATCH_6OR8_HEX}$`, "i"));
__publicField(_M, "PRIMARY", 4149685);
__publicField(_M, "PRIMARYDARK", 3162015);
__publicField(_M, "ACCENT", 16728193);
__publicField(_M, "WHITE", 16777215);
__publicField(_M, "IVORY", 16777200);
__publicField(_M, "LIGHTYELLOW", 16777184);
__publicField(_M, "YELLOW", 16776960);
__publicField(_M, "SNOW", 16775930);
__publicField(_M, "FLORALWHITE", 16775920);
__publicField(_M, "LEMONCHIFFON", 16775885);
__publicField(_M, "CORNSILK", 16775388);
__publicField(_M, "SEASHELL", 16774638);
__publicField(_M, "LAVENDERBLUSH", 16773365);
__publicField(_M, "PAPAYAWHIP", 16773077);
__publicField(_M, "BLANCHEDALMOND", 16772045);
__publicField(_M, "MISTYROSE", 16770273);
__publicField(_M, "BISQUE", 16770244);
__publicField(_M, "MOCCASIN", 16770229);
__publicField(_M, "NAVAJOWHITE", 16768685);
__publicField(_M, "PEACHPUFF", 16767673);
__publicField(_M, "GOLD", 16766720);
__publicField(_M, "PINK", 16761035);
__publicField(_M, "LIGHTPINK", 16758465);
__publicField(_M, "ORANGE", 16753920);
__publicField(_M, "LIGHTSALMON", 16752762);
__publicField(_M, "DARKORANGE", 16747520);
__publicField(_M, "CORAL", 16744272);
__publicField(_M, "HOTPINK", 16738740);
__publicField(_M, "TOMATO", 16737095);
__publicField(_M, "ORANGERED", 16729344);
__publicField(_M, "DEEPPINK", 16716947);
__publicField(_M, "FUCHSIA", 16711935);
__publicField(_M, "MAGENTA", 16711935);
__publicField(_M, "RED", 16711680);
__publicField(_M, "OLDLACE", 16643558);
__publicField(_M, "LIGHTGOLDENRODYELLOW", 16448210);
__publicField(_M, "LINEN", 16445670);
__publicField(_M, "ANTIQUEWHITE", 16444375);
__publicField(_M, "SALMON", 16416882);
__publicField(_M, "GHOSTWHITE", 16316671);
__publicField(_M, "MINTCREAM", 16121850);
__publicField(_M, "WHITESMOKE", 16119285);
__publicField(_M, "BEIGE", 16119260);
__publicField(_M, "WHEAT", 16113331);
__publicField(_M, "SANDYBROWN", 16032864);
__publicField(_M, "AZURE", 15794175);
__publicField(_M, "HONEYDEW", 15794160);
__publicField(_M, "ALICEBLUE", 15792383);
__publicField(_M, "KHAKI", 15787660);
__publicField(_M, "LIGHTCORAL", 15761536);
__publicField(_M, "PALEGOLDENROD", 15657130);
__publicField(_M, "VIOLET", 15631086);
__publicField(_M, "DARKSALMON", 15308410);
__publicField(_M, "LAVENDER", 15132410);
__publicField(_M, "LIGHTCYAN", 14745599);
__publicField(_M, "BURLYWOOD", 14596231);
__publicField(_M, "PLUM", 14524637);
__publicField(_M, "GAINSBORO", 14474460);
__publicField(_M, "CRIMSON", 14423100);
__publicField(_M, "PALEVIOLETRED", 14381203);
__publicField(_M, "GOLDENROD", 14329120);
__publicField(_M, "ORCHID", 14315734);
__publicField(_M, "THISTLE", 14204888);
__publicField(_M, "LIGHTGREY", 13882323);
__publicField(_M, "TAN", 13808780);
__publicField(_M, "CHOCOLATE", 13789470);
__publicField(_M, "PERU", 13468991);
__publicField(_M, "INDIANRED", 13458524);
__publicField(_M, "MEDIUMVIOLETRED", 13047173);
__publicField(_M, "SILVER", 12632256);
__publicField(_M, "DARKKHAKI", 12433259);
__publicField(_M, "ROSYBROWN", 12357519);
__publicField(_M, "MEDIUMORCHID", 12211667);
__publicField(_M, "DARKGOLDENROD", 12092939);
__publicField(_M, "FIREBRICK", 11674146);
__publicField(_M, "POWDERBLUE", 11591910);
__publicField(_M, "LIGHTSTEELBLUE", 11584734);
__publicField(_M, "PALETURQUOISE", 11529966);
__publicField(_M, "GREENYELLOW", 11403055);
__publicField(_M, "LIGHTBLUE", 11393254);
__publicField(_M, "DARKGRAY", 11119017);
__publicField(_M, "BROWN", 10824234);
__publicField(_M, "SIENNA", 10506797);
__publicField(_M, "DARKORCHID", 10040012);
__publicField(_M, "PALEGREEN", 10025880);
__publicField(_M, "DARKVIOLET", 9699539);
__publicField(_M, "MEDIUMPURPLE", 9662683);
__publicField(_M, "LIGHTGREEN", 9498256);
__publicField(_M, "DARKSEAGREEN", 9419919);
__publicField(_M, "SADDLEBROWN", 9127187);
__publicField(_M, "DARKMAGENTA", 9109643);
__publicField(_M, "DARKRED", 9109504);
__publicField(_M, "BLUEVIOLET", 9055202);
__publicField(_M, "LIGHTSKYBLUE", 8900346);
__publicField(_M, "SKYBLUE", 8900331);
__publicField(_M, "GRAY", 8421504);
__publicField(_M, "OLIVE", 8421376);
__publicField(_M, "PURPLE", 8388736);
__publicField(_M, "MAROON", 8388608);
__publicField(_M, "AQUAMARINE", 8388564);
__publicField(_M, "CHARTREUSE", 8388352);
__publicField(_M, "LAWNGREEN", 8190976);
__publicField(_M, "MEDIUMSLATEBLUE", 8087790);
__publicField(_M, "LIGHTSLATEGRAY", 7833753);
__publicField(_M, "SLATEGRAY", 7372944);
__publicField(_M, "OLIVEDRAB", 7048739);
__publicField(_M, "SLATEBLUE", 6970061);
__publicField(_M, "DIMGRAY", 6908265);
__publicField(_M, "MEDIUMAQUAMARINE", 6737322);
__publicField(_M, "CORNFLOWERBLUE", 6591981);
__publicField(_M, "CADETBLUE", 6266528);
__publicField(_M, "DARKOLIVEGREEN", 5597999);
__publicField(_M, "INDIGO", 4915330);
__publicField(_M, "MEDIUMTURQUOISE", 4772300);
__publicField(_M, "DARKSLATEBLUE", 4734347);
__publicField(_M, "STEELBLUE", 4620980);
__publicField(_M, "ROYALBLUE", 4286945);
__publicField(_M, "TURQUOISE", 4251856);
__publicField(_M, "MEDIUMSEAGREEN", 3978097);
__publicField(_M, "LIMEGREEN", 3329330);
__publicField(_M, "DARKSLATEGRAY", 3100495);
__publicField(_M, "SEAGREEN", 3050327);
__publicField(_M, "FORESTGREEN", 2263842);
__publicField(_M, "LIGHTSEAGREEN", 2142890);
__publicField(_M, "DODGERBLUE", 2003199);
__publicField(_M, "MIDNIGHTBLUE", 1644912);
__publicField(_M, "AQUA", 65535);
__publicField(_M, "CYAN", 65535);
__publicField(_M, "SPRINGGREEN", 65407);
__publicField(_M, "LIME", 65280);
__publicField(_M, "MEDIUMSPRINGGREEN", 64154);
__publicField(_M, "DARKTURQUOISE", 52945);
__publicField(_M, "DEEPSKYBLUE", 49151);
__publicField(_M, "DARKCYAN", 35723);
__publicField(_M, "TEAL", 32896);
__publicField(_M, "GREEN", 32768);
__publicField(_M, "DARKGREEN", 25600);
__publicField(_M, "BLUE", 255);
__publicField(_M, "MEDIUMBLUE", 205);
__publicField(_M, "DARKBLUE", 139);
__publicField(_M, "NAVY", 128);
__publicField(_M, "BLACK", 0);
var M = _M;
var ce = class {
  static start(e) {
    this._startTime = performance.now(), this._timeLabel = e;
  }
  static end() {
    console.log(this._timeLabel, performance.now() - this._startTime);
  }
};
__publicField(ce, "time", 0);
__publicField(ce, "frame", 0);
__publicField(ce, "delta", 0);
__publicField(ce, "_startTime", 0);
__publicField(ce, "_timeLabel", "");
var ze = class {
  constructor(e = null, t = null) {
    __publicField(this, "target");
    __publicField(this, "currentTarget");
    __publicField(this, "type");
    __publicField(this, "data");
    __publicField(this, "param");
    __publicField(this, "time", 0);
    __publicField(this, "delay", 0);
    __publicField(this, "mouseCode", 0);
    __publicField(this, "ctrlKey");
    __publicField(this, "altKey");
    __publicField(this, "shiftKey");
    __publicField(this, "targetTouches");
    __publicField(this, "changedTouches");
    __publicField(this, "touches");
    __publicField(this, "_stopImmediatePropagation", false);
    __publicField(this, "view");
    this.type = e, this.data = t;
  }
  stopImmediatePropagation() {
    this._stopImmediatePropagation = true;
  }
  reset() {
    this._stopImmediatePropagation = false;
  }
  get isStopImmediatePropagation() {
    return this._stopImmediatePropagation;
  }
};
var la = class {
  constructor(e = null, t = null, r = null, i = null, a = 0) {
    __publicField(this, "id", 0);
    __publicField(this, "current");
    this.type = e, this.thisObject = t, this.handler = r, this.param = i, this.priority = a;
  }
  equalCurrentListener(e, t, r, i) {
    return this.type == e && this.thisObject == r && this.handler == t && this.param == i;
  }
  dispose() {
    this.handler = null, this.thisObject = null, this.param = null, this.priority = 0;
  }
};
__publicField(la, "event_id_count", 0);
var qt = class {
  constructor() {
    __publicField(this, "listeners", {});
    __publicField(this, "data");
  }
  dispatchEvent(e) {
    var t = this.listeners[e.type];
    if (t != null) {
      t = t.slice();
      for (var r = 0; r < t.length; r++) {
        var i = t[r];
        if (i.handler) {
          try {
            e.param = i.param, e.currentTarget = i, i.thisObject, i.handler.call(i.thisObject, e);
          } catch {
          }
          if (e.isStopImmediatePropagation)
            break;
        }
      }
    }
  }
  destroy() {
    for (var e in this.listeners)
      for (var t = this.listeners[e]; t.length > 0; ) {
        var r = t[0];
        r.handler = null, r.thisObject = null, t.splice(0, 1);
      }
  }
  addEventListener(e, t, r, i = null, a = 0) {
    if (this.listeners[e] == null && (this.listeners[e] = []), !this.hasEventListener(e, t, r)) {
      var o = new la(e, r, t, i, a);
      return o.id = ++la.event_id_count, o.current = this, this.listeners[e].push(o), this.listeners[e].sort(function(n, l) {
        return l.priority - n.priority;
      }), o.id;
    }
    for (let n = 0; n < this.listeners[e].length; n++) {
      let l = this.listeners[e][n];
      if (l.equalCurrentListener(e, t, r, i))
        return l.id;
    }
    return 0;
  }
  removeEventListener(e, t, r) {
    if (this.hasEventListener(e, t, r))
      for (var i = 0; i < this.listeners[e].length; i++) {
        var a = this.listeners[e][i];
        if (a.equalCurrentListener(e, t, r, a.param)) {
          a.handler = null, a.thisObject = null, this.listeners[e].splice(i, 1);
          return;
        }
      }
  }
  removeEventListenerAt(e) {
    for (var t in this.listeners)
      for (var r = 0; r < this.listeners[t].length; r++) {
        var i = this.listeners[t][r];
        if (i.id == e)
          return i.handler = null, i.thisObject = null, this.listeners[t].splice(r, 1), true;
      }
    return false;
  }
  removeAllEventListener(e = null) {
    let t;
    if (e) {
      if (this.listeners[e]) {
        for (var r = 0; r < this.listeners[e].length; r++)
          t = this.listeners[e][r], t.dispose(), this.listeners[e].splice(r, 1);
        delete this.listeners[e];
      }
    } else
      for (let i in this.listeners) {
        for (var r = 0; r < this.listeners[i].length; r++)
          t = this.listeners[i][r], t.dispose(), this.listeners[i].splice(r, 1);
        delete this.listeners[i];
      }
  }
  containEventListener(e) {
    return this.listeners[e] == null ? false : this.listeners[e].length > 0;
  }
  hasEventListener(e, t = null, r = null) {
    if (this.listeners[e] == null)
      return false;
    if (r && t)
      for (var i = 0; i < this.listeners[e].length; i++) {
        var a = this.listeners[e][i];
        if (a.equalCurrentListener(e, t, r, a.param))
          return true;
      }
    return false;
  }
};
var cr = class extends ze {
  constructor() {
    super(...arguments);
    __publicField(this, "keyCode", 0);
  }
};
__publicField(cr, "KEY_DOWN", "onKeyDown");
__publicField(cr, "KEY_UP", "onKeyUp");
var U = class extends ze {
  constructor() {
    super(...arguments);
    __publicField(this, "pointerId");
    __publicField(this, "pointerType");
    __publicField(this, "isPrimary");
    __publicField(this, "pressure");
    __publicField(this, "mouseX");
    __publicField(this, "mouseY");
    __publicField(this, "movementX");
    __publicField(this, "movementY");
    __publicField(this, "deltaX");
    __publicField(this, "deltaY");
    __publicField(this, "deltaZ");
  }
  reset() {
    super.reset(), this.mouseX = 0, this.mouseY = 0, this.movementX = 0, this.movementY = 0, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0;
  }
};
__publicField(U, "PICK_OVER", "onPickOver");
__publicField(U, "PICK_OVER_GUI", "onPickOverGUI");
__publicField(U, "PICK_CLICK", "onPickClick");
__publicField(U, "PICK_CLICK_GUI", "onPickClickGUI");
__publicField(U, "PICK_OUT", "onPickOut");
__publicField(U, "PICK_OUT_GUI", "onPickOutGUI");
__publicField(U, "PICK_MOVE", "onPickMove");
__publicField(U, "PICK_UP", "onPickUp");
__publicField(U, "PICK_UP_GUI", "onPickUpGUI");
__publicField(U, "PICK_DOWN", "onPickDown");
__publicField(U, "PICK_DOWN_GUI", "onPickDownGUI");
__publicField(U, "POINTER_RIGHT_CLICK", "onPointerRightClick");
__publicField(U, "POINTER_MID_UP", "onPointerMidUp");
__publicField(U, "POINTER_MID_DOWN", "onPointerMidDown");
__publicField(U, "POINTER_CLICK", "onPointerClick");
__publicField(U, "POINTER_MOVE", "onPointerMove");
__publicField(U, "POINTER_DOWN", "onPointerDown");
__publicField(U, "POINTER_UP", "onPointerUp");
__publicField(U, "POINTER_OUT", "onPointerOut");
__publicField(U, "POINTER_OVER", "onPointerOver");
__publicField(U, "POINTER_WHEEL", "onPointerWheel");
var _d = class _d {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "w", 1);
    __publicField(this, "index", 0);
    this.set(e, t, r, i), this.index = _d._index++;
  }
  static get ZERO() {
    return new _d(0, 0, 0);
  }
  static get ONE() {
    return new _d(1, 1, 1);
  }
  static get LEFT() {
    return new _d(-1, 0, 0);
  }
  static get RIGHT() {
    return new _d(1, 0, 0);
  }
  static get UP() {
    return new _d(0, 1, 0);
  }
  static get DOWN() {
    return new _d(0, -1, 0);
  }
  static get BACK() {
    return new _d(0, 0, -1);
  }
  static get FORWARD() {
    return new _d(0, 0, 1);
  }
  set a(e) {
    this.w = e;
  }
  set r(e) {
    this.x = e;
  }
  set g(e) {
    this.y = e;
  }
  set b(e) {
    this.z = e;
  }
  get a() {
    return this.w;
  }
  get r() {
    return this.x;
  }
  get g() {
    return this.y;
  }
  get b() {
    return this.z;
  }
  get length() {
    return Math.sqrt(this.lengthSquared);
  }
  get lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  get position() {
    return this;
  }
  static getTowPointbyDir(e, t, r, i, a) {
    a == _d.Z_AXIS ? (t.x = e.y, t.y = -e.x, r.x = -e.y, r.y = e.x, t.scaleBy(i * 0.5), r.scaleBy(i * 0.5)) : a == _d.Y_AXIS && (t.x = e.z, t.z = -e.x, r.x = -e.z, r.z = e.x, t.scaleBy(i * 0.5), r.scaleBy(i * 0.5));
  }
  static pointToLine(e, t, r) {
    let i = 0, a, o, n;
    if (a = _d.distance(e, t), o = _d.distance(e, r), n = _d.distance(t, r), n <= 1e-6 || o <= 1e-6)
      return i = 0, i;
    if (a <= 1e-6 || n * n >= a * a + o * o)
      return i = o, i;
    if (o * o >= a * a + n * n)
      return i = n, i;
    let l = (a + o + n) / 2;
    return i = 2 * Math.sqrt(l * (l - a) * (l - o) * (l - n)) / a, i;
  }
  static dot(e, t) {
    return e.x * t.x + e.y * t.y + e.z * t.z;
  }
  static getPoints(e, t) {
    let r = [];
    for (let i = 0; i < e; i++) {
      const a = new _d(Math.random() * t - t * 0.5, Math.random() * t - t * 0.5, Math.random() * t - t * 0.5);
      r.push(a);
    }
    return r;
  }
  static getPointNumbers(e, t) {
    let r = [];
    for (let i = 0; i < e; i++)
      r.push(Math.random() * t - t * 0.5, Math.random() * t - t * 0.5, Math.random() * t - t * 0.5);
    return r;
  }
  static getAngle(e, t) {
    let r = e.dotProduct(t) / (e.length * t.length);
    return Math.acos(r) * 180 / Math.PI;
  }
  static sqrMagnitude(e) {
    return e.x * e.x + e.y * e.y + e.z * e.z;
  }
  static getZYAngle(e, t) {
    return this.calAngle(e.y, e.z, t.y, t.z);
  }
  static sub(e, t, r = null) {
    return r = r || new _d(), r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r;
  }
  static add(e, t, r = null) {
    return r = r || new _d(), r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r;
  }
  static smoothDamp(e, t, r, i, a, o) {
    return null;
  }
  static distance(e, t) {
    var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z;
    return Math.sqrt(r * r + i * i + a * a);
  }
  static squareDistance(e, t) {
    var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z;
    return r * r + i * i + a * a;
  }
  static distanceXZ(e, t) {
    var r = e.x - t.x, i = 0, a = e.z - t.z;
    return Math.sqrt(r * r + i * i + a * a);
  }
  set(e, t, r, i = 1) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  add(e, t = null) {
    t || (t = new _d());
    var r = this.x, i = this.y, a = this.z, o = this.w, n = e.x, l = e.y, h = e.z, u = e.w;
    return t.setTo(r + n, i + l, a + h, o + u), t;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  distanceToSquared(e) {
    let t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  addXYZW(e, t, r, i, a = null) {
    a || (a = new _d());
    var o = this.x, n = this.y, l = this.z, h = this.w, u = e, c = t, f = r, g = i;
    return a.setTo(o + u, n + c, l + f, h + g), a;
  }
  clone() {
    return new _d(this.x, this.y, this.z, this.w);
  }
  copyFrom(e) {
    var t = this;
    return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;
  }
  decrementBy(e) {
    this.x -= e.x, this.y -= e.y, this.z -= e.z;
  }
  dotProduct(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  equals(e, t = false) {
    return this.x == e.x && this.y == e.y && this.z == e.z && (!t || this.w == e.w);
  }
  incrementBy(e) {
    this.x += e.x, this.y += e.y, this.z += e.z;
  }
  divide(e) {
    return e instanceof _d ? new _d(this.x / e.x, this.y / e.y, this.z / e.z) : (this.x = this.x / e, this.y = this.y / e, this.z = this.z / e, this);
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  normalize(e = 1) {
    let t = this;
    if (this.length != 0) {
      var r = e / this.length;
      return this.x *= r, this.y *= r, this.z *= r, t;
    }
    return t;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, i = this.z, a = e.x, o = e.y, n = e.z, l = e.w, h = l * t + o * i - n * r, u = l * r + n * t - a * i, c = l * i + a * r - o * t, f = -a * t - o * r - n * i;
    return this.x = h * l + f * -a + u * -n - c * -o, this.y = u * l + f * -o + c * -a - h * -n, this.z = c * l + f * -n + h * -o - u * -a, this;
  }
  scaleBy(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  mul(e) {
    let t = new _d();
    return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t;
  }
  scale(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  scaleToRef(e, t) {
    return t || (t = new _d()), t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t;
  }
  setTo(e, t, r, i = 1) {
    this.x = e, this.y = t, this.z = r, this.w = i;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  subtract(e, t = null) {
    return t || (t = new _d()), t.setTo(this.x - e.x, this.y - e.y, this.z - e.z), t;
  }
  multiply(e, t = null) {
    t || (t = new _d());
    var r = this.x, i = this.y, a = this.z, o = e.x, n = e.y, l = e.z;
    return t.setTo(r * o, i * n, a * l), t;
  }
  divided(e, t = null) {
    t || (t = new _d());
    var r = this.x, i = this.y, a = this.z, o = e.x, n = e.y, l = e.z;
    return t.setTo(r / o, i / n, a / l), t;
  }
  div(e, t) {
    t || (t = new _d());
    var r = this.x, i = this.y, a = this.z, o = this.w;
    return t.setTo(r / e, i / e, a / e, o / e), t;
  }
  lerp(e, t, r) {
    var i = e.x, a = e.y, o = e.z, n = e.w, l = t.x, h = t.y, u = t.z, c = t.w;
    this.x = (l - i) * r + i, this.y = (h - a) * r + a, this.z = (u - o) * r + o, this.w = (c - n) * r + n;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  toString() {
    return "<" + this.x + ", " + this.y + ", " + this.z + ">";
  }
  normalizeToWay2D_XY() {
    let e = Math.abs(this.x), t = Math.abs(this.y);
    e > t ? this.x > 0 ? this.copyFrom(_d.RIGHT) : this.copyFrom(_d.LEFT) : this.y > 0 ? this.copyFrom(_d.DOWN) : this.copyFrom(_d.UP);
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  copyToBytes(e) {
    e.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, this.x, true), e.setFloat32(1 * Float32Array.BYTES_PER_ELEMENT, this.y, true), e.setFloat32(2 * Float32Array.BYTES_PER_ELEMENT, this.z, true);
  }
  crossProduct(e, t = null) {
    return t = t || new _d(), t.x = this.y * e.z - this.z * e.y, t.y = this.z * e.x - this.x * e.z, t.z = this.x * e.y - this.y * e.x, t.w = 1, t;
  }
  crossVectors(e, t) {
    return e.crossProduct(t, this), this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  setFromArray(e, t = 0) {
    this.x = e[t], this.y = e[t + 1], this.z = e[t + 2];
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  clampLength(e, t) {
    let r = this.length;
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  static calAngle(e, t, r, i) {
    const a = n(r, i, e, t);
    let o = Math.acos(a) * 180 / Math.PI;
    return r < e && (o = -o), o;
    function n(h, u, c, f) {
      let g = [h - c, u - f];
      return l(g, [0, -1]);
    }
    function l(h, u) {
      let c = h[0] * u[0] + h[1] * u[1], f = Math.sqrt(h[0] * h[0] + h[1] * h[1]) * Math.sqrt(u[0] * u[0] + u[1] * u[1]);
      return c / f;
    }
  }
  static pointInsideTriangle(e, t, r, i) {
    return _d.HELP_0.setTo(e.x, e.z, 0), _d.HELP_1.setTo(t.x, t.z, 0), _d.HELP_2.setTo(r.x, r.z, 0), _d.HELP_3.setTo(i.x, i.z, 0), _d.pointInsideTriangle2d();
  }
  static pointInsideTriangle2d() {
    return _d.productXY(_d.HELP_1, _d.HELP_2, _d.HELP_3) >= 0 ? _d.productXY(_d.HELP_1, _d.HELP_2, _d.HELP_0) >= 0 && _d.productXY(_d.HELP_2, _d.HELP_3, _d.HELP_0) >= 0 && _d.productXY(_d.HELP_3, _d.HELP_1, _d.HELP_0) >= 0 : _d.productXY(_d.HELP_1, _d.HELP_2, _d.HELP_0) <= 0 && _d.productXY(_d.HELP_2, _d.HELP_3, _d.HELP_0) <= 0 && _d.productXY(_d.HELP_3, _d.HELP_1, _d.HELP_0) <= 0;
  }
  static productXY(e, t, r) {
    var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);
    return i > -1e-5 && i < 1e-5 && (i = 0), i;
  }
  static serialize(e) {
    return new _d(e.x, e.y, e.z, e.w);
  }
};
__publicField(_d, "MAX", new _d(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE));
__publicField(_d, "MIN", new _d(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE));
__publicField(_d, "SAFE_MAX", new _d(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER));
__publicField(_d, "SAFE_MIN", new _d(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER));
__publicField(_d, "X_AXIS", new _d(1, 0, 0));
__publicField(_d, "neg_X_AXIS", new _d(-1, 0, 0));
__publicField(_d, "Y_AXIS", new _d(0, 1, 0));
__publicField(_d, "Z_AXIS", new _d(0, 0, 1));
__publicField(_d, "HELP_0", new _d());
__publicField(_d, "HELP_1", new _d());
__publicField(_d, "HELP_2", new _d());
__publicField(_d, "EPSILON", 1e-5);
__publicField(_d, "HELP_3", new _d());
__publicField(_d, "HELP_4", new _d());
__publicField(_d, "HELP_5", new _d());
__publicField(_d, "HELP_6", new _d());
__publicField(_d, "_index", 0);
var d = _d;
var qo = class {
  constructor(e) {
    __publicField(this, "canvasX");
    __publicField(this, "canvasY");
    __publicField(this, "identifier");
    __publicField(this, "clientX");
    __publicField(this, "clientY");
    __publicField(this, "pageX");
    __publicField(this, "pageY");
    __publicField(this, "screenX");
    __publicField(this, "screenY");
    this.canvasX = e.clientX, this.canvasY = e.clientY, this.identifier = e.identifier, this.clientX = e.clientX, this.clientY = e.clientY, this.pageX = e.pageX, this.pageY = e.pageY, this.screenX = e.screenX, this.screenY = e.screenY;
  }
};
var Ko = class extends qt {
  constructor() {
    super(...arguments);
    __publicField(this, "canvasX", 0);
    __publicField(this, "canvasY", 0);
    __publicField(this, "isMouseDown", false);
    __publicField(this, "isRightMouseDown", false);
    __publicField(this, "canvas");
    __publicField(this, "mouseX", 0);
    __publicField(this, "mouseY", 0);
    __publicField(this, "wheelDelta", 0);
    __publicField(this, "mouseOffsetX", 0);
    __publicField(this, "mouseOffsetY", 0);
    __publicField(this, "mouseLastX", 0);
    __publicField(this, "mouseLastY", 0);
    __publicField(this, "_time", 0);
    __publicField(this, "_keyStatus");
    __publicField(this, "_mouseStatus");
    __publicField(this, "_isTouchStart");
    __publicField(this, "_keyEvent3d");
    __publicField(this, "_pointerEvent3D");
    __publicField(this, "_windowsEvent3d");
    __publicField(this, "_gp", false);
    __publicField(this, "_oldPosition1", null);
    __publicField(this, "_oldPosition2", null);
    __publicField(this, "_downTime", 0);
  }
  initCanvas(e) {
    this.canvas = e, e.onpointerdown = (r) => {
      r.button == 0 ? this.mouseStart(r) : r.button == 1 ? this.middleDown(r) : r.button == 2 && this.mouseStart(r);
    }, e.onpointerup = (r) => {
      r.button == 0 ? this.mouseEnd(r) : r.button == 1 ? this.middleUp(r) : r.button == 2 && this.mouseEnd(r);
    }, e.onpointerenter = (r) => {
      this.mouseOver(r);
    }, e.onpointermove = (r) => {
      this.mouseMove(r);
    }, e.onpointercancel = (r) => {
      this.mouseEnd(r);
    }, e.onpointerleave = (r) => {
      this.mouseEnd(r);
    }, e.onpointerout = (r) => {
      this.mouseEnd(r);
    }, e.addEventListener("click", (r) => {
      r.button == 2 ? (this.isRightMouseDown = false, this.rightClick(r)) : r.button == 0 && (this.isMouseDown = false, this.mouseClick(r));
    }, true), e.addEventListener("wheel", (r) => this.mouseWheel(r), { passive: false }), window.addEventListener("keydown", (r) => this.keyDown(r), true), window.addEventListener("keyup", (r) => this.keyUp(r), true), e.oncontextmenu = function() {
      return false;
    };
    let t = this.canvas.getBoundingClientRect();
    this.canvasX = t.left, this.canvasY = t.top, this._keyStatus = {}, this._mouseStatus = {}, this._isTouchStart = false, this._keyEvent3d = new cr(), this._pointerEvent3D = new U(), this._windowsEvent3d = new ze();
  }
  onPinch(e, t, r, i) {
    this._oldPosition1 = new d(e, t), this._oldPosition2 = new d(r, i);
  }
  onSwipe(e, t) {
    this.mouseX = e, this.mouseY = t, this._oldPosition1 = null, this._oldPosition2 = null, this._time = (/* @__PURE__ */ new Date()).getTime();
  }
  GetTargetTouches(e) {
    for (var t = new Array(), r = 0; r < e.length; r++) {
      var i = new qo(e[r]);
      t.push(i);
    }
    return t;
  }
  rightClick(e) {
    this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._pointerEvent3D.mouseX = e.clientX - this.canvasX, this._pointerEvent3D.mouseY = e.clientY - this.canvasY, this._pointerEvent3D.type = U.POINTER_RIGHT_CLICK, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this.dispatchEvent(this._pointerEvent3D);
  }
  middleDown(e) {
    this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._pointerEvent3D.mouseX = e.clientX - this.canvasX, this._pointerEvent3D.mouseY = e.clientY - this.canvasY, this._pointerEvent3D.type = U.POINTER_MID_DOWN, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this.dispatchEvent(this._pointerEvent3D);
  }
  middleUp(e) {
    this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._pointerEvent3D.mouseX = e.clientX - this.canvasX, this._pointerEvent3D.mouseY = e.clientY - this.canvasY, this._pointerEvent3D.type = U.POINTER_MID_UP, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseClick(e) {
    this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._pointerEvent3D.mouseX = e.clientX - this.canvasX, this._pointerEvent3D.mouseY = e.clientY - this.canvasY, this._pointerEvent3D.type = U.POINTER_CLICK, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseEnd(e) {
    this.isMouseDown = false, this.mouseLastX = this.mouseX, this.mouseLastY = this.mouseY, this.mouseX = e.clientX - this.canvasX, this.mouseY = e.clientY - this.canvasY, this.mouseOffsetX = this.mouseX - this.mouseLastX, this.mouseOffsetY = this.mouseY - this.mouseLastY, this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._mouseStatus[this._pointerEvent3D.mouseCode] = false, this._pointerEvent3D.type = U.POINTER_UP, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this._pointerEvent3D.mouseX = this.mouseX, this._pointerEvent3D.mouseY = this.mouseY, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseStart(e) {
    this.isMouseDown = true, this.mouseLastX = this.mouseX, this.mouseLastY = this.mouseY, this.mouseX = e.clientX - this.canvasX, this.mouseY = e.clientY - this.canvasY, this.mouseOffsetX = this.mouseX - this.mouseLastX, this.mouseOffsetY = this.mouseY - this.mouseLastY, this._pointerEvent3D.reset(), this._pointerEvent3D.mouseCode = e.button, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this._pointerEvent3D.mouseX = this.mouseX, this._pointerEvent3D.mouseY = this.mouseY, this._pointerEvent3D.type = U.POINTER_DOWN, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseMove(e) {
    this.mouseLastX = this.mouseX, this.mouseLastY = this.mouseY, this.mouseX = e.clientX - this.canvasX, this.mouseY = e.clientY - this.canvasY, this.mouseOffsetX = this.mouseX - this.mouseLastX, this.mouseOffsetY = this.mouseY - this.mouseLastY, this._pointerEvent3D.reset(), this._pointerEvent3D.type = U.POINTER_MOVE, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this._pointerEvent3D.mouseX = this.mouseX, this._pointerEvent3D.mouseY = this.mouseY, this._pointerEvent3D.movementX = e.movementX, this._pointerEvent3D.movementY = e.movementY, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseOver(e) {
    this.isMouseDown = false, this.mouseLastX = this.mouseX, this.mouseLastY = this.mouseY, this.mouseX = e.clientX - this.canvasX, this.mouseY = e.clientY - this.canvasY, this.mouseOffsetX = this.mouseX - this.mouseLastX, this.mouseOffsetY = this.mouseY - this.mouseLastY, this._pointerEvent3D.reset(), this._pointerEvent3D.type = U.POINTER_OVER, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.pointerId = e.pointerId, this._pointerEvent3D.pointerType = e.pointerType, this._pointerEvent3D.isPrimary = e.isPrimary, this._pointerEvent3D.pressure = e.pressure, this._pointerEvent3D.mouseX = this.mouseX, this._pointerEvent3D.mouseY = this.mouseY, this.dispatchEvent(this._pointerEvent3D);
  }
  mouseWheel(e) {
    e.preventDefault(), this.mouseLastX = this.mouseX, this.mouseLastY = this.mouseY, this.mouseX = e.clientX - this.canvasX, this.mouseY = e.clientY - this.canvasY, this.mouseOffsetX = this.mouseX - this.mouseLastX, this.mouseOffsetY = this.mouseY - this.mouseLastY, "wheelDelta" in e ? (this._pointerEvent3D.delay = e.wheelDelta, this.wheelDelta = e.wheelDelta) : "delta" in e && (this.wheelDelta = e.delta), this._pointerEvent3D.reset(), this._pointerEvent3D.type = U.POINTER_WHEEL, this._pointerEvent3D.ctrlKey = e.ctrlKey, this._pointerEvent3D.altKey = e.altKey, this._pointerEvent3D.shiftKey = e.shiftKey, this._pointerEvent3D.mouseX = this.mouseX, this._pointerEvent3D.mouseY = this.mouseY, this._pointerEvent3D.deltaX = e.deltaX, this._pointerEvent3D.deltaY = e.deltaY, this._pointerEvent3D.deltaZ = e.deltaZ, this.dispatchEvent(this._pointerEvent3D);
  }
  keyDown(e) {
    this._keyEvent3d.reset(), this._keyEvent3d.keyCode = e.keyCode, this._keyEvent3d.ctrlKey = e.ctrlKey, this._keyEvent3d.altKey = e.altKey, this._keyEvent3d.shiftKey = e.shiftKey, this._keyStatus[e.keyCode] || (this._keyStatus[e.keyCode] = true, this._keyEvent3d.type = cr.KEY_DOWN, this.dispatchEvent(this._keyEvent3d));
  }
  keyUp(e) {
    this._keyEvent3d.reset(), this._keyEvent3d.keyCode = e.keyCode, this._keyStatus[e.keyCode] = false, this._keyEvent3d.type = cr.KEY_UP, this.dispatchEvent(this._keyEvent3d);
  }
  GetSlideAngle(e, t) {
    return Math.atan2(t, e) * 180 / Math.PI;
  }
  GetSlideDirection(e, t, r, i) {
    var a = t - i, o = r - e, n = 0;
    if (Math.abs(o) < 2 && Math.abs(a) < 2)
      return n;
    var l = this.GetSlideAngle(o, a);
    return l >= -45 && l < 45 ? n = 4 : l >= 45 && l < 135 ? n = 1 : l >= -135 && l < -45 ? n = 2 : (l >= 135 && l <= 180 || l >= -180 && l < -135) && (n = 3), n;
  }
};
var bf = "0.7.2";
var ct = { clamp_to_edge: "clamp-to-edge", repeat: "repeat", mirror_repeat: "mirror-repeat" };
var Ef = { zero: "zero", one: "one", src: "src", one_minus_src: "one-minus-src", src_alpha: "src-alpha", one_minus_src_alpha: "one-minus-src-alpha", dst: "dst", one_minus_dst: "one-minus-dst", dst_alpha: "dst-alpha", one_minus_dst_alpha: "one-minus-dst-alpha", src_alpha_saturated: "src-alpha-saturated", constant: "constant", one_minus_constant: "one-minus-constant" };
var Bf = { srcFactor: "one", dstFactor: "zero", operation: "add" };
var Tf = { compare: "always", failOp: "keep", depthFailOp: "keep", passOp: "keep" };
var kt = { never: "never", less: "less", equal: "equal", less_equal: "less-equal", greater: "greater", not_equal: "not-equal", greater_equal: "greater-equal", always: "always" };
var nt = { none: "none", front: "front", back: "back" };
var Gt = { nearest: "nearest", linear: "linear" };
var Ai = { point_list: "point-list", line_list: "line-list", line_strip: "line-strip", triangle_list: "triangle-list", triangle_strip: "triangle-strip" };
var N = { r8unorm: "r8unorm", r8snorm: "r8snorm", r8uint: "r8uint", r8sint: "r8sint", r16uint: "r16uint", r16sint: "r16sint", r16float: "r16float", rg8unorm: "rg8unorm", rg8snorm: "rg8snorm", rg8uint: "rg8uint", rg8sint: "rg8sint", r32uint: "r32uint", r32sint: "r32sint", r32float: "r32float", rg16uint: "rg16uint", rg16sint: "rg16sint", rg16float: "rg16float", rgba8unorm: "rgba8unorm", rgba8unorm_srgb: "rgba8unorm-srgb", rgba8snorm: "rgba8snorm", rgba8uint: "rgba8uint", rgba8sint: "rgba8sint", bgra8unorm: "bgra8unorm", bgra8unorm_srgb: "bgra8unorm-srgb", rgb9e5ufloat: "rgb9e5ufloat", rgb10a2unorm: "rgb10a2unorm", rg11b10ufloat: "rg11b10ufloat", rg32uint: "rg32uint", rg32sint: "rg32sint", rg32float: "rg32float", rgba16uint: "rgba16uint", rgba16sint: "rgba16sint", rgba16float: "rgba16float", rgba32uint: "rgba32uint", rgba32sint: "rgba32sint", rgba32float: "rgba32float", stencil8: "stencil8", depth16unorm: "depth16unorm", depth24plus: "depth24plus", depth24plus_stencil8: "depth24plus-stencil8", depth32float: "depth32float", bc1_rgba_unorm: "bc1-rgba-unorm", bc1_rgba_unorm_srgb: "bc1-rgba-unorm-srgb", bc2_rgba_unorm: "bc2-rgba-unorm", bc2_rgba_unorm_srgb: "bc2-rgba-unorm-srgb", bc3_rgba_unorm: "bc3-rgba-unorm", bc3_rgba_unorm_srgb: "bc3-rgba-unorm-srgb", bc4_r_unorm: "bc4-r-unorm", bc4_r_snorm: "bc4-r-snorm", bc5_rg_unorm: "bc5-rg-unorm", bc5_rg_snorm: "bc5-rg-snorm", bc6h_rgb_ufloat: "bc6h-rgb-ufloat", bc6h_rgb_float: "bc6h-rgb-float", bc7_rgba_unorm: "bc7-rgba-unorm", bc7_rgba_unorm_srgb: "bc7-rgba-unorm-srgb", depth24unorm_stencil8: "depth24unorm-stencil8", depth32float_stencil8: "depth32float-stencil8" };
var vi = { uint8x2: "uint8x2", uint8x4: "uint8x4", sint8x2: "sint8x2", sint8x4: "sint8x4", unorm8x2: "unorm8x2", unorm8x4: "unorm8x4", snorm8x2: "snorm8x2", snorm8x4: "snorm8x4", uint16x2: "uint16x2", uint16x4: "uint16x4", sint16x2: "sint16x2", sint16x4: "sint16x4", unorm16x2: "unorm16x2", unorm16x4: "unorm16x4", snorm16x2: "snorm16x2", snorm16x4: "snorm16x4", float16x2: "float16x2", float16x4: "float16x4", float32: "float32", float32x2: "float32x2", float32x3: "float32x3", float32x4: "float32x4", uint32: "uint32", uint32x2: "uint32x2", uint32x3: "uint32x3", uint32x4: "uint32x4", sint32: "sint32", sint32x2: "sint32x2", sint32x3: "sint32x3", sint32x4: "sint32x4" };
var Df = { vertex: "vertex", instance: "instance" };
var br = class extends ze {
};
__publicField(br, "RESIZE", "resize");
var Pf = class extends qt {
  constructor() {
    super(...arguments);
    __publicField(this, "adapter");
    __publicField(this, "device");
    __publicField(this, "context");
    __publicField(this, "aspect");
    __publicField(this, "presentationSize", [0, 0]);
    __publicField(this, "presentationFormat");
    __publicField(this, "canvas");
    __publicField(this, "windowWidth");
    __publicField(this, "windowHeight");
    __publicField(this, "canvasConfig");
    __publicField(this, "super", 1);
    __publicField(this, "_pixelRatio", 1);
    __publicField(this, "_resizeEvent");
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  async init(e) {
    var _a3;
    if (this.canvasConfig = e, e && e.canvas) {
      if (this.canvas = e.canvas, this.canvas === null)
        throw new Error("no Canvas");
      const r = this.canvas.clientWidth, i = this.canvas.clientHeight;
      r != this.canvas.clientWidth && (this.canvas.style.width = r + "px"), i != this.canvas.clientHeight && (this.canvas.style.height = i + "px");
    } else
      this.canvas = document.createElement("canvas"), this.canvas.style.position = "absolute", this.canvas.style.top = "0px", this.canvas.style.left = "0px", this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.zIndex = (e == null ? void 0 : e.zIndex) ? e.zIndex.toString() : "0", document.body.appendChild(this.canvas);
    if (e && e.backgroundImage ? (this.canvas.style.background = `url(${e.backgroundImage})`, this.canvas.style["background-size"] = "cover", this.canvas.style["background-position"] = "center") : this.canvas.style.background = "transparent", this.canvas.style["touch-action"] = "none", this.canvas.style["object-fit"] = "cover", navigator.gpu === void 0)
      throw new Error("Your browser does not support WebGPU!");
    if (this.adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" }), this.adapter == null)
      throw new Error("Your browser does not support WebGPU!");
    if (this.device = await this.adapter.requestDevice({ requiredFeatures: ["bgra8unorm-storage", "depth-clip-control", "depth32float-stencil8", "indirect-first-instance", "rg11b10ufloat-renderable"], requiredLimits: { minUniformBufferOffsetAlignment: 256, maxStorageBufferBindingSize: this.adapter.limits.maxStorageBufferBindingSize } }), this.device == null)
      throw new Error("Your browser does not support WebGPU!");
    return this._pixelRatio = ((_a3 = this.canvasConfig) == null ? void 0 : _a3.devicePixelRatio) || window.devicePixelRatio || 1, this._pixelRatio = Math.min(this._pixelRatio, 2), this.device.label = "device", this.presentationFormat = navigator.gpu.getPreferredCanvasFormat(), this.context = this.canvas.getContext("webgpu"), this.context.configure({ device: this.device, format: this.presentationFormat, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT, alphaMode: "premultiplied", colorSpace: "srgb" }), this._resizeEvent = new br(br.RESIZE, { width: this.windowWidth, height: this.windowHeight }), new ResizeObserver(() => {
      this.updateSize(), Re.destroyTexture();
    }).observe(this.canvas), this.updateSize(), true;
  }
  updateSize() {
    let e = Math.floor(this.canvas.clientWidth * this.pixelRatio * this.super), t = Math.floor(this.canvas.clientHeight * this.pixelRatio * this.super);
    (e != this.windowWidth || t != this.windowHeight) && (this.canvas.width = this.windowWidth = e, this.canvas.height = this.windowHeight = t, this.presentationSize[0] = this.windowWidth, this.presentationSize[1] = this.windowHeight, this.aspect = this.windowWidth / this.windowHeight, this._resizeEvent.data.width = this.windowWidth, this._resizeEvent.data.height = this.windowHeight, this.dispatchEvent(this._resizeEvent));
  }
};
var w = new Pf();
var Fe = class {
};
__publicField(Fe, "colorBufferTex_NAME", "colorBufferTex");
__publicField(Fe, "positionBufferTex_NAME", "positionBufferTex");
__publicField(Fe, "normalBufferTex_NAME", "normalBufferTex");
__publicField(Fe, "materialBufferTex_NAME", "materialBufferTex");
__publicField(Fe, "zBufferTexture_NAME", "zBufferTexture");
__publicField(Fe, "zPreDepthTexture_NAME", "zPreDepthTexture");
__publicField(Fe, "outTex_NAME", "outTex");
var De = ((s) => (s[s.Default = 1] = "Default", s[s.IgnoreDepthPass = 2] = "IgnoreDepthPass", s[s.Sky = 6] = "Sky", s[s.Particle = 10] = "Particle", s[s.SkinnedMesh = 16] = "SkinnedMesh", s[s.MorphTarget = 32] = "MorphTarget", s[s.Terrain = 64] = "Terrain", s[s.UI = 128] = "UI", s))(De || {});
var Et = class {
  static addMask(e, t) {
    return e | t;
  }
  static removeMask(e, t) {
    return e & ~t;
  }
  static hasMask(e, t) {
    return (e & t) == t;
  }
};
function xi(s, e) {
  let t = s.__NonSerialize__;
  t || (t = s.__NonSerialize__ = {}, t.__NonSerialize__ = true), t[e] = true;
}
function ws(s, e) {
  let t;
  for (; s && (s = s.__proto__, s && (t = s.__NonSerialize__), !t); )
    ;
  return t && t[e];
}
function Qt(s, e, t, r, i) {
  let a = s.__EditorInspector__;
  a || (a = s.__EditorInspector__ = /* @__PURE__ */ new Map());
  let o = a.get(s.constructor.name);
  o || (o = /* @__PURE__ */ new Map(), a.set(s.constructor.name, o)), o.set(e, { p1: t, p2: r, p3: i });
}
function Mf(s) {
  let e, t = s, r = [];
  for (; t; ) {
    if (r.indexOf(t.constructor.name) != -1) {
      t = t.__proto__;
      continue;
    }
    r.push(t.constructor.name), t = t.__proto__;
  }
  for (r = r.reverse(), t = s; t && (t = t.__proto__, t && (e = t.__EditorInspector__), !e); )
    ;
  let i = /* @__PURE__ */ new Map();
  if (e)
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      let n = e.get(o);
      n && n.forEach((l, h) => {
        i.set(h, l);
      });
    }
  return i;
}
function _t(s, e, t, r, i) {
  let a = window.__Component__;
  a || (a = window.__Component__ = {}), a[e] = s;
}
function Jo(s) {
  let e = window.__Component__;
  return e[s] ? e[s] : null;
}
function Kt(s, e, t, r, i) {
  let a = window.__shader__;
  a || (a = window.__shader__ = {}), a[e] = s;
}
function Zo(s) {
  let e = window.__shader__;
  return e[s] ? e[s] : null;
}
var Rf = Object.defineProperty;
var Uf = Object.getOwnPropertyDescriptor;
var $o = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Uf(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Rf(e, t, i), i;
};
var _a;
var Is = (_a = class {
  constructor() {
    __publicField(this, "__refection");
    __publicField(this, "__size", 0);
  }
  getValueType() {
    if (!this.__refection) {
      let e = this;
      this.__refection = [];
      for (const t in e)
        if (!ws(this, t)) {
          const r = e[t];
          let i = { name: t, type: r.constructor.name };
          this.__refection.push(i);
        }
    }
    return this.__refection;
  }
  static getValueSize(e) {
    switch (e.constructor.name) {
      case "Boolean":
        return 1 * 4;
      case "Number":
        return 1 * 4;
      case "f32":
        return 1 * 4;
      case "i32":
        return 1 * 4;
      case "u32":
        return 1 * 4;
      case "Float32Array":
        return e.byteLength;
      case "Vector2":
        return 2 * 4;
      case "Vector3":
        return 3 * 4;
      case "Vector4":
        return 4 * 4;
      case "Color":
        return 4 * 4;
      case "Array":
        let r = 0;
        for (let i = 0, a = e.length; i < a; i++)
          r += _a.getValueSize(e[i]);
        return r;
    }
    return 0;
  }
  static Ref(e) {
    return this.Get(e).getValueType();
  }
  static Get(e) {
    let t = _a.__cacheStruct.get(e.prototype);
    return t || (t = new e(), _a.__cacheStruct.set(e.prototype, t)), t;
  }
  static GetSize(e) {
    let t = this.Get(e);
    if (t.__size == 0) {
      for (const r in t)
        if (!ws(t, r)) {
          const i = t[r];
          t.__size += _a.getValueSize(i);
        }
      t.__size > 4 && (t.__size = Math.ceil(t.__size / 4) * 4);
    }
    return t.__size;
  }
}, __publicField(_a, "__cacheStruct", /* @__PURE__ */ new Map()), _a);
$o([xi], Is.prototype, "__refection", 2), $o([xi], Is.prototype, "__size", 2);
var Bt = Is;
var en = class {
  constructor() {
    __publicField(this, "byteOffset");
    __publicField(this, "byteSize");
    __publicField(this, "offset", 0);
    __publicField(this, "dataBytes");
  }
  get x() {
    return this.dataBytes.getFloat32(0 * Float32Array.BYTES_PER_ELEMENT, true);
  }
  set x(e) {
    this.dataBytes.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, e, true);
  }
  get y() {
    return this.dataBytes.getFloat32(1 * Float32Array.BYTES_PER_ELEMENT, true);
  }
  set y(e) {
    this.dataBytes.setFloat32(1 * Float32Array.BYTES_PER_ELEMENT, e, true);
  }
  get z() {
    return this.dataBytes.getFloat32(2 * Float32Array.BYTES_PER_ELEMENT, true);
  }
  set z(e) {
    this.dataBytes.setFloat32(2 * Float32Array.BYTES_PER_ELEMENT, e, true);
  }
  get w() {
    return this.dataBytes.getFloat32(3 * Float32Array.BYTES_PER_ELEMENT, true);
  }
  set w(e) {
    this.dataBytes.setFloat32(3 * Float32Array.BYTES_PER_ELEMENT, e, true);
  }
  setX(e) {
    this.x = e;
  }
  setXY(e, t) {
    this.x = e, this.y = t;
  }
  setXYZ(e, t, r) {
    this.x = e, this.y = t, this.z = r;
  }
  setXYZW(e, t, r, i) {
    this.x = e, this.y = t, this.z = r, this.w = i;
  }
  setVector2Array(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.dataBytes.setFloat32((t * 2 + 0) * Float32Array.BYTES_PER_ELEMENT, r.x, true), this.dataBytes.setFloat32((t * 2 + 1) * Float32Array.BYTES_PER_ELEMENT, r.y, true);
    }
  }
  setVector3Array(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.dataBytes.setFloat32((t * 3 + 0) * Float32Array.BYTES_PER_ELEMENT, r.x, true), this.dataBytes.setFloat32((t * 3 + 1) * Float32Array.BYTES_PER_ELEMENT, r.y, true), this.dataBytes.setFloat32((t * 3 + 2) * Float32Array.BYTES_PER_ELEMENT, r.z, true);
    }
  }
  setVector4Array(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.dataBytes.setFloat32((t * 4 + 0) * Float32Array.BYTES_PER_ELEMENT, r.x, true), this.dataBytes.setFloat32((t * 4 + 1) * Float32Array.BYTES_PER_ELEMENT, r.y, true), this.dataBytes.setFloat32((t * 4 + 2) * Float32Array.BYTES_PER_ELEMENT, r.z, true), this.dataBytes.setFloat32((t * 4 + 3) * Float32Array.BYTES_PER_ELEMENT, r.w, true);
    }
  }
  setColorArray(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.dataBytes.setFloat32((t * 4 + 0) * Float32Array.BYTES_PER_ELEMENT, r.r, true), this.dataBytes.setFloat32((t * 4 + 1) * Float32Array.BYTES_PER_ELEMENT, r.g, true), this.dataBytes.setFloat32((t * 4 + 2) * Float32Array.BYTES_PER_ELEMENT, r.b, true), this.dataBytes.setFloat32((t * 4 + 3) * Float32Array.BYTES_PER_ELEMENT, r.a, true);
    }
  }
  setInt8(e, t = 0) {
    this.dataBytes.setInt8(t * Int8Array.BYTES_PER_ELEMENT, e);
  }
  getInt8(e = 0) {
    return this.dataBytes.getInt8(e * Int8Array.BYTES_PER_ELEMENT);
  }
  setInt16(e, t = 0) {
    this.dataBytes.setInt16(t * Int16Array.BYTES_PER_ELEMENT, e, true);
  }
  getInt16(e = 0) {
    return this.dataBytes.getInt16(e * Int16Array.BYTES_PER_ELEMENT, true);
  }
  setInt32(e, t = 0) {
    this.dataBytes.setInt32(t * Int32Array.BYTES_PER_ELEMENT, e, true);
  }
  getInt32(e = 0) {
    return this.dataBytes.getInt32(e * Int32Array.BYTES_PER_ELEMENT, true);
  }
  setFloat(e, t = 0) {
    this.dataBytes.setFloat32(t * Float32Array.BYTES_PER_ELEMENT, e, true);
  }
  getFloat(e = 0) {
    return this.dataBytes.getFloat32(e * Float32Array.BYTES_PER_ELEMENT, true);
  }
  setUint8(e, t = 0) {
    this.dataBytes.setUint8(t * Uint8Array.BYTES_PER_ELEMENT, e);
  }
  getUint8(e = 0) {
    return this.dataBytes.getUint8(e * Uint8Array.BYTES_PER_ELEMENT);
  }
  setUint16(e, t = 0) {
    this.dataBytes.setUint16(t * Uint16Array.BYTES_PER_ELEMENT, e, true);
  }
  getUint16(e = 0) {
    return this.dataBytes.getUint16(e * Uint16Array.BYTES_PER_ELEMENT, true);
  }
  setUint32(e, t = 0) {
    this.dataBytes.setUint32(t * Uint32Array.BYTES_PER_ELEMENT, e, true);
  }
  getUint32(e = 0) {
    return this.dataBytes.getUint32(e * Uint32Array.BYTES_PER_ELEMENT, true);
  }
  setArray(e, t) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      this.dataBytes.setFloat32((e + r) * Float32Array.BYTES_PER_ELEMENT, i, true);
    }
  }
  setFloat32Array(e, t) {
    new Float32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Float32Array.BYTES_PER_ELEMENT, t.length).set(t);
  }
  setArrayBuffer(e, t) {
    t instanceof Uint8Array ? this.setUint8Array(e, t) : t instanceof Uint16Array ? this.setUint16Array(e, t) : t instanceof Uint32Array ? this.setUint32Array(e, t) : t instanceof Int8Array ? this.setInt8Array(e, t) : t instanceof Int16Array ? this.setInt16Array(e, t) : t instanceof Int32Array ? this.setInt32Array(e, t) : t instanceof Float32Array && this.setFloat32Array(e, t);
  }
  setInt8Array(e, t) {
    new Int8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Int8Array.BYTES_PER_ELEMENT).set(t);
  }
  setInt16Array(e, t) {
    new Int16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Int16Array.BYTES_PER_ELEMENT).set(t);
  }
  setInt32Array(e, t) {
    new Int32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Int32Array.BYTES_PER_ELEMENT).set(t);
  }
  setUint8Array(e, t) {
    new Uint8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Uint8Array.BYTES_PER_ELEMENT).set(t);
  }
  setUint16Array(e, t) {
    new Uint16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Uint16Array.BYTES_PER_ELEMENT).set(t);
  }
  setUint32Array(e, t) {
    new Uint32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + e * Uint32Array.BYTES_PER_ELEMENT).set(t);
  }
  setData(e, t) {
    this.dataBytes.setFloat32(e * Float32Array.BYTES_PER_ELEMENT, t, true);
  }
  setVector2(e, t) {
    this.dataBytes.setFloat32(e * Float32Array.BYTES_PER_ELEMENT, t.x, true), this.dataBytes.setFloat32((e + 1) * Float32Array.BYTES_PER_ELEMENT, t.y, true);
  }
  setVector3(e, t) {
    this.dataBytes.setFloat32(e * Float32Array.BYTES_PER_ELEMENT, t.x, true), this.dataBytes.setFloat32((e + 1) * Float32Array.BYTES_PER_ELEMENT, t.y, true), this.dataBytes.setFloat32((e + 2) * Float32Array.BYTES_PER_ELEMENT, t.z, true);
  }
  setVector4(e, t) {
    this.dataBytes.setFloat32(e * Float32Array.BYTES_PER_ELEMENT, t.x, true), this.dataBytes.setFloat32((e + 1) * Float32Array.BYTES_PER_ELEMENT, t.y, true), this.dataBytes.setFloat32((e + 2) * Float32Array.BYTES_PER_ELEMENT, t.z, true), this.dataBytes.setFloat32((e + 3) * Float32Array.BYTES_PER_ELEMENT, t.w, true);
  }
  setColor(e, t) {
    this.dataBytes.setFloat32(e * Float32Array.BYTES_PER_ELEMENT, t.r, true), this.dataBytes.setFloat32((e + 1) * Float32Array.BYTES_PER_ELEMENT, t.g, true), this.dataBytes.setFloat32((e + 2) * Float32Array.BYTES_PER_ELEMENT, t.b, true), this.dataBytes.setFloat32((e + 3) * Float32Array.BYTES_PER_ELEMENT, t.a, true);
  }
  getData(e) {
    return this.dataBytes.getFloat32(e * Float32Array.BYTES_PER_ELEMENT, true);
  }
  writeFloat(e) {
    this.dataBytes.setFloat32(this.offset, e, true), this.offset += Float32Array.BYTES_PER_ELEMENT;
  }
  writeInt8(e) {
    this.dataBytes.setInt8(this.offset, e), this.offset += Int8Array.BYTES_PER_ELEMENT;
  }
  writeInt16(e) {
    this.dataBytes.setInt16(this.offset, e, true), this.offset += Int16Array.BYTES_PER_ELEMENT;
  }
  writeInt32(e) {
    this.dataBytes.setInt32(this.offset, e, true), this.offset += Int32Array.BYTES_PER_ELEMENT;
  }
  writeUint8(e) {
    this.dataBytes.setUint8(this.offset, e), this.offset += Uint8Array.BYTES_PER_ELEMENT;
  }
  writeUint16(e) {
    this.dataBytes.setUint16(this.offset, e, true), this.offset += Uint16Array.BYTES_PER_ELEMENT;
  }
  writeUint32(e) {
    this.dataBytes.setUint32(this.offset, e, true), this.offset += Uint32Array.BYTES_PER_ELEMENT;
  }
  writeVector2(e) {
    this.writeFloat(e.x), this.writeFloat(e.y);
  }
  writeVector3(e) {
    this.writeFloat(e.x), this.writeFloat(e.y), this.writeFloat(e.z);
  }
  writeVector4(e) {
    this.writeFloat(e.x), this.writeFloat(e.y), this.writeFloat(e.z), this.writeFloat(e.w);
  }
  writeRGBColor(e) {
    this.writeFloat(e.r), this.writeFloat(e.g), this.writeFloat(e.b);
  }
  writeArray(e) {
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.writeFloat(r);
    }
  }
  writeFloat32Array(e) {
    new Float32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeInt8Array(e) {
    new Int8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeInt16Array(e) {
    new Int16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeInt32Array(e) {
    new Int32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeUint8Array(e) {
    new Uint8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeUint16Array(e) {
    new Uint16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  writeUint32Array(e) {
    new Uint32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(e), this.offset += e.byteLength;
  }
  reset() {
    this.offset = 0;
  }
  destroy() {
    this.byteOffset = null, this.byteSize = null, this.offset = null, this.dataBytes = null;
  }
};
var fr = class {
  constructor() {
    __publicField(this, "shareDataBuffer");
    __publicField(this, "_byteOffset", 0);
  }
  allocation(e) {
    this.shareDataBuffer && this.shareDataBuffer.byteLength < e ? this._byteOffset = 0 : this.shareDataBuffer = new ArrayBuffer(e);
  }
  allocation_node(e) {
    if (this._byteOffset + e > this.shareDataBuffer.byteLength)
      return console.error("memory not enough!", this._byteOffset, e, this.shareDataBuffer.byteLength), null;
    let t = new en();
    return t.byteOffset = this._byteOffset, t.byteSize = e, t.dataBytes = new DataView(this.shareDataBuffer, this._byteOffset, t.byteSize), this._byteOffset += t.byteSize, t;
  }
  allocation_memory(e) {
    return this._byteOffset + e.byteSize > this.shareDataBuffer.byteLength ? (console.error("memory not enough!", this._byteOffset, e.byteSize, this.shareDataBuffer.byteLength), null) : (e.byteOffset = this._byteOffset, e.dataBytes = new DataView(this.shareDataBuffer, this._byteOffset, e.byteSize), this._byteOffset += e.byteSize, e);
  }
  reset() {
    this._byteOffset = 0;
  }
  destroy(e) {
    this.shareDataBuffer = null, this._byteOffset = 0;
  }
};
var Jt = class {
  constructor() {
    __publicField(this, "bufferType");
    __publicField(this, "buffer");
    __publicField(this, "memory");
    __publicField(this, "memoryNodes");
    __publicField(this, "seek");
    __publicField(this, "outFloat32Array");
    __publicField(this, "byteSize");
    __publicField(this, "usage");
    __publicField(this, "visibility", GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE);
    __publicField(this, "mapAsyncBuffersOutstanding", 0);
    __publicField(this, "mapAsyncReady");
    __publicField(this, "_readBuffer");
    __publicField(this, "_dataView");
    __publicField(this, "_readFlag", false);
    this.mapAsyncReady = [];
  }
  debug() {
  }
  reset(e = false, t = 0, r) {
    this.seek = 0, this.memory.reset(), e && this.createBuffer(this.usage, t, r);
  }
  setBoolean(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 4), this.memoryNodes.set(e, r)), r.setX(t ? 1 : 0);
  }
  setFloat(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 4), this.memoryNodes.set(e, r)), r.setX(t);
  }
  setInt8(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 1), this.memoryNodes.set(e, r)), r.setInt8(t);
  }
  setInt16(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 2), this.memoryNodes.set(e, r)), r.setInt16(t);
  }
  setInt32(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 4), this.memoryNodes.set(e, r)), r.setInt32(t);
  }
  setUint8(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 1), this.memoryNodes.set(e, r)), r.setUint8(t);
  }
  setUint16(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 2), this.memoryNodes.set(e, r)), r.setUint16(t);
  }
  setUint32(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(1 * 4), this.memoryNodes.set(e, r)), r.setUint32(t);
  }
  setVector2(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(2 * 4), this.memoryNodes.set(e, r)), r.setXY(t.x, t.y);
  }
  setVector3(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(3 * 4), this.memoryNodes.set(e, r)), r.setXYZ(t.x, t.y, t.z);
  }
  setVector4(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(4 * 4), this.memoryNodes.set(e, r)), r.setXYZW(t.x, t.y, t.z, t.w);
  }
  setVector4Array(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(4 * 4 * t.length), this.memoryNodes.set(e, r)), r.setVector4Array(t);
  }
  setColor(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(4 * 4), this.memoryNodes.set(e, r)), r.setXYZW(t.r, t.g, t.b, t.a);
  }
  setColorArray(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(4 * 4 * t.length), this.memoryNodes.set(e, r)), r.setColorArray(t);
  }
  setMatrix(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(16 * 4), this.memoryNodes.set(e, r)), r.setFloat32Array(0, t.rawData);
  }
  setMatrixArray(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(16 * 4 * t.length), this.memoryNodes.set(e, r));
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      r.setFloat32Array(i * 16, a.rawData);
    }
  }
  setArray(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(t.length * 4), this.memoryNodes.set(e, r)), r.setArray(0, t);
  }
  setFloat32Array(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(t.length * 4), this.memoryNodes.set(e, r)), r.setFloat32Array(0, t);
  }
  setInt32Array(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(t.length * 4), this.memoryNodes.set(e, r)), r.setInt32Array(0, t);
  }
  setUint32Array(e, t) {
    let r = this.memoryNodes.get(e);
    r || (r = this.memory.allocation_node(t.length * 4), this.memoryNodes.set(e, r)), r.setUint32Array(0, t);
  }
  setStruct(e, t, r, i) {
    let a = Bt.Ref(e);
    Bt.GetSize(e);
    let o = t, n = this.memoryNodes.get(o);
    n.reset();
    let l = r;
    i && (l = l[i]);
    for (let h = 0; h < a.length; h++) {
      const u = a[h];
      let c = l[u.name];
      this.writeValue(n, u, c);
    }
  }
  writeValue(e, t, r) {
    switch (t.type) {
      case "Boolean":
        e.writeFloat(r);
        break;
      case "Number":
        e.writeFloat(r);
        break;
      case "Float32Array":
        e.writeFloat32Array(r);
        break;
      case "Vector2":
        e.writeVector2(r);
        break;
      case "Vector3":
        e.writeVector3(r);
        break;
      case "Vector4":
        e.writeVector4(r);
        break;
      case "Color":
        e.writeRGBColor(r);
        break;
      case "Array":
        e.writeArray(r);
        break;
    }
  }
  setStructArray(e, t, r) {
    let i = t.length;
    for (let a = 0; a < i; a++) {
      const o = t[a];
      this.setStruct(e, a, o, r);
    }
  }
  clean() {
    this._dataView.fill(0, 0, this._dataView.length);
  }
  apply() {
    w.device.queue.writeBuffer(this.buffer, 0, this.memory.shareDataBuffer);
  }
  mapAsyncWrite(e, t) {
    let r = w.device;
    if (e.length > 0) {
      let i = null;
      for (; this.mapAsyncReady.length && (i = this.mapAsyncReady.shift(), i.usedSize != e.byteLength); )
        i.destroy(), this.mapAsyncBuffersOutstanding--, i = null;
      i || (i = r.createBuffer({ size: e.byteLength, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE, mappedAtCreation: true }), i.usedSize = e.byteLength, this.mapAsyncBuffersOutstanding++, this.mapAsyncBuffersOutstanding > 10 && console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));
      let a = new Float32Array(e.buffer, e.byteOffset, t);
      new Float32Array(i.getMappedRange(0, t * 4)).set(a), i.unmap();
      const n = r.createCommandEncoder();
      n.copyBufferToBuffer(i, 0, this.buffer, 0, t * 4), r.queue.submit([n.finish()]), i.mapAsync(GPUMapMode.WRITE).then(() => this.mapAsyncReady.push(i));
    }
  }
  destroy(e) {
    this.memoryNodes && this.memoryNodes.forEach((t) => {
      t.destroy();
    }), this.bufferType = null, this.seek = null, this.byteSize = null, this.usage = null, this.visibility = null, this.outFloat32Array = null, this.buffer && this.buffer.destroy(), this.buffer = null, this.memory && this.memory.destroy(), this.memory = null, this._readBuffer && this._readBuffer.destroy();
  }
  createBuffer(e, t, r, i) {
    let a = w.device;
    this.buffer && this.destroy(), this.byteSize = t * 4, this.usage = e, this.buffer = a.createBuffer({ label: i, size: this.byteSize, usage: e, mappedAtCreation: false }), this.memory = new fr(), this.memoryNodes = /* @__PURE__ */ new Map(), this._dataView = new Float32Array(this.memory.shareDataBuffer), this.memory.allocation(this.byteSize), r && (this.memory.allocation_node(r.length * 4).setArrayBuffer(0, r), this.apply());
  }
  resizeBuffer(e, t) {
    this.createBuffer(this.usage, e, t);
  }
  createNewBuffer(e, t) {
    let r = w.device, i = t * 4, a = e;
    return this.buffer && this.destroy(), r.createBuffer({ size: i, usage: a, mappedAtCreation: false });
  }
  createBufferByStruct(e, t, r) {
    let i = Bt.GetSize(t), a = i * r, o = w.device;
    this.buffer = o.createBuffer({ label: "StructStorageGPUBuffer", size: a, usage: e, mappedAtCreation: false }), this.memory = new fr(), this.memoryNodes = /* @__PURE__ */ new Map(), this._dataView = new Float32Array(this.memory.shareDataBuffer), this.memory.allocation(a);
    for (let n = 0; n < r; n++) {
      let l = n, h = this.memoryNodes.get(l);
      h || (h = this.memory.allocation_node(i), this.memoryNodes.set(l, h));
    }
  }
  readBuffer() {
    return this.outFloat32Array || (this.outFloat32Array = new Float32Array(this.memory.shareDataBuffer.byteLength / 4)), this._readBuffer || (this._readBuffer = w.device.createBuffer({ size: this.memory.shareDataBuffer.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ, mappedAtCreation: false })), this._readFlag || this.read(), this.outFloat32Array;
  }
  async read() {
    this._readFlag = true;
    let e = w.device.createCommandEncoder();
    e.copyBufferToBuffer(this.buffer, 0, this._readBuffer, 0, this.memory.shareDataBuffer.byteLength), w.device.queue.submit([e.finish()]), await this._readBuffer.mapAsync(GPUMapMode.READ);
    const t = this._readBuffer.getMappedRange();
    this.outFloat32Array.set(new Float32Array(t), 0), this._readBuffer.unmap(), this._readFlag = false;
  }
};
var Tt = ((s) => (s[s.IndicesGPUBuffer = 0] = "IndicesGPUBuffer", s[s.VertexGPUBuffer = 1] = "VertexGPUBuffer", s[s.UniformGPUBuffer = 2] = "UniformGPUBuffer", s[s.StorageGPUBuffer = 3] = "StorageGPUBuffer", s[s.ComputeGPUBuffer = 4] = "ComputeGPUBuffer", s[s.MaterialDataUniformGPUBuffer = 5] = "MaterialDataUniformGPUBuffer", s[s.StructStorageGPUBuffer = 6] = "StructStorageGPUBuffer", s))(Tt || {});
var $ = class extends Jt {
  constructor(e, t = 0, r) {
    super(), this.bufferType = Tt.StorageGPUBuffer, this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | t, e, r, "StorageGPUBuffer");
  }
};
var ft = class extends Jt {
  constructor(e, t) {
    super(), this.bufferType = Tt.UniformGPUBuffer, this.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC, e, t, "UniformGPUBuffer");
  }
  genUniformNodes() {
  }
};
var dt = class {
  static getMorphTargetShaderBinding(e, t) {
    return `
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${t})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${t + 1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${t + 2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`;
  }
  static getMorphTargetCalcVertex() {
    return `
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `;
  }
};
__publicField(dt, "CsMain", `
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);
var gt = function(s = 16, e = 16) {
  var t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), r = [], i;
  if (e = e || t.length, s)
    for (i = 0; i < s; i++)
      r[i] = t[0 | Math.random() * e];
  else {
    var a;
    for (r[8] = r[13] = r[18] = r[23] = "-", r[14] = "4", i = 0; i < 36; i++)
      r[i] || (a = 0 | Math.random() * 16, r[i] = t[i == 19 ? a & 3 | 8 : a]);
  }
  return r.join("");
};
var tn = 1e6;
var bs = function() {
  return tn++, tn;
};
var Lf = function(s, e) {
  let t = 0, r = s.length;
  for (t = 0; t < r; t++)
    if (s[t] == e)
      return true;
  return false;
};
var Of = function(s, e) {
  let t = 0, r = s.length;
  for (t = 0; t < r; t++)
    if (s[t] == e)
      return t;
  return -1;
};
var rn = (...s) => function(...e) {
  s.forEach((t) => t.apply(this, e));
};
var _Q = class _Q {
  constructor(e = 0, t = 0) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    this.x = e, this.y = t;
  }
  static getAngle(e, t) {
    return Math.atan2(t.y - e.y, t.x - e.x);
  }
  static slerp(e, t, r) {
    let i = new _Q(), a = e.dot(t);
    if (a < 0 && (t.x = -t.x, t.y = -t.y, a = -a), a > 0.9995)
      return i.x = e.x + r * (t.x - e.x), i.y = e.y + r * (t.y - e.y), i;
    let o = Math.acos(a), n = Math.sin(o), l = Math.sin((1 - r) * o) / n, h = Math.sin(r * o) / n;
    return i.x = l * e.x + h * t.x, i.y = l * e.y + h * t.y, i;
  }
  static lerp(e, t, r) {
    return _Q.HELP_0.copyFrom(e), _Q.HELP_1.copyFrom(t), _Q.HELP_0.scale(r), _Q.HELP_1.scale(1 - r), new _Q(_Q.HELP_0.x + _Q.HELP_1.x, _Q.HELP_0.y + _Q.HELP_1.y);
  }
  set(e = 0, t = 0) {
    return this.x = e, this.y = t, this;
  }
  distance(e) {
    return Math.sqrt(Math.pow(this.x - e.x, 2) + Math.pow(this.y - e.y, 2));
  }
  add(e, t) {
    return t = t || new _Q(), t.x = this.x + e.x, t.y = this.y + e.y, t;
  }
  sub(e, t) {
    return t = t || new _Q(), t.x = this.x - e.x, t.y = this.y - e.y, t;
  }
  scale(e) {
    return this.x = this.x * e, this.y = this.y * e, this;
  }
  multiply(e, t) {
    return t = t || new _Q(), t.x = this.x * e, t.y = this.y * e, t;
  }
  multiplyScaler(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e, t) {
    return t = t || new _Q(), t.x = this.x / e, t.y = this.y / e, t;
  }
  neg(e) {
    return e || (e = new _Q()), e.x = -e.x, e.y = -e.y, e;
  }
  abs() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  getAngle(e) {
    return Math.atan2(e.y - this.y, e.x - this.x);
  }
  unt(e) {
    e = e || new _Q();
    let t = this.abs();
    return e.x = this.x / t, e.y = this.y / t, e;
  }
  angleTo(e) {
    let t = e.x - this.x, r = e.y - this.y;
    return Math.atan2(r, t);
  }
  equals(e) {
    return Math.abs(this.x - e.x) < 1e-6 && Math.abs(this.y - e.y) < 1e-6;
  }
  pal(e) {
    let t = this.unt(), r = e.unt();
    return t.equals(r) ? 1 : t.equals(r.neg()) ? -1 : 0;
  }
  clone() {
    return new _Q(this.x, this.y);
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  normalize() {
    let e = this.abs();
    return this.x = this.x / e, this.y = this.y / e, this;
  }
  addInPlace(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
};
__publicField(_Q, "HELP_0", new _Q());
__publicField(_Q, "HELP_1", new _Q());
__publicField(_Q, "HELP_2", new _Q());
__publicField(_Q, "ZERO", new _Q(0, 0));
__publicField(_Q, "SAFE_MAX", new _Q(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER));
__publicField(_Q, "SAFE_MIN", new _Q(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER));
var Q = _Q;
var _G = class _G {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "w", 1);
    this.x = e, this.y = t, this.z = r, this.w = i;
  }
  get width() {
    return this.z;
  }
  get height() {
    return this.w;
  }
  static crossVectors(e, t, r) {
    r = r || new _G();
    var i = e.x, a = e.y, o = e.z, n = t.x, l = t.y, h = t.z;
    return r.x = a * h - o * l, r.y = o * n - i * h, r.z = i * l - a * n, r;
  }
  static distance(e, t) {
    let r = e.x - t.x, i = e.y - t.y, a = e.z - t.z, o = e.w - t.w;
    return Math.sqrt(r * r + i * i + a * a + o * o);
  }
  set(e, t, r, i) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  clone() {
    return new _G(this.x, this.y, this.z, this.w);
  }
};
__publicField(_G, "X_AXIS", new _G(1, 0, 0));
__publicField(_G, "Y_AXIS", new _G(0, 1, 0));
__publicField(_G, "Z_AXIS", new _G(0, 0, 1));
__publicField(_G, "HELP_0", new _G());
__publicField(_G, "HELP_1", new _G());
__publicField(_G, "HELP_2", new _G());
__publicField(_G, "EPSILON", 1e-5);
__publicField(_G, "HELP_3", new _G());
__publicField(_G, "HELP_4", new _G());
__publicField(_G, "HELP_5", new _G());
__publicField(_G, "HELP_6", new _G());
__publicField(_G, "ZERO", new _G());
__publicField(_G, "ONE", new _G(1, 1, 1, 1));
__publicField(_G, "LEFT", new _G(-1, 0, 0));
__publicField(_G, "RIGHT", new _G(1, 0, 0));
__publicField(_G, "UP", new _G(0, -1, 0));
__publicField(_G, "DOWN", new _G(0, 1, 0));
__publicField(_G, "BACK", new _G(0, 0, -1));
__publicField(_G, "FORWARD", new _G(0, 0, 1));
var G = _G;
var He = ((s) => (s[s.Number = 0] = "Number", s[s.Vector2 = 1] = "Vector2", s[s.Vector3 = 2] = "Vector3", s[s.Vector4 = 3] = "Vector4", s[s.Color = 4] = "Color", s[s.Float32Array = 5] = "Float32Array", s))(He || {});
var dr = class {
  constructor(e) {
    __publicField(this, "size");
    __publicField(this, "memoryInfo");
    __publicField(this, "bindOnChange");
    __publicField(this, "_data");
    __publicField(this, "_type", He.Number);
    __publicField(this, "_x", 0);
    __publicField(this, "_y", 0);
    __publicField(this, "_z", 0);
    __publicField(this, "_w", 0);
    this.data = e;
  }
  get data() {
    return this._data;
  }
  set data(e) {
    this._data = e, this._type = He.Number, e instanceof Q ? (this.size = 2, this._x = e.x, this._y = e.y, this._type = He.Vector2) : e instanceof d ? (this.size = 3, this._x = e.x, this._y = e.y, this._z = e.z, this._type = He.Vector3) : e instanceof G ? (this.size = 4, this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._type = He.Vector4) : e instanceof M ? (this.size = 4, this._x = e.r, this._y = e.g, this._z = e.b, this._w = e.a, this._type = He.Color) : e instanceof Float32Array ? (this.size = e.length, this._type = He.Float32Array) : (this.size = 1, this._x = e, this._data = e, this._type = He.Number);
  }
  getColor(e) {
    return e ? e.copyFrom(this._data) : e = this._data, e;
  }
  get color() {
    return new M(this._data.r, this._data.g, this._data.b, this._data.a);
  }
  set color(e) {
    (this._x != e.r || this._y != e.g || this._z != e.b || this._w != e.a) && (this._data.r = e.r, this._data.g = e.g, this._data.b = e.b, this._data.a = e.a, this._x = e.r, this._y = e.g, this._z = e.b, this._w = e.a, this.onChange());
  }
  get value() {
    return this._x;
  }
  set value(e) {
    this._x != e && (this._data = e, this._x = e, this.onChange());
  }
  get vector2() {
    return this._data;
  }
  set vector2(e) {
    (this._x != e.x || this._y != e.y) && (this._data.x = e.x, this._data.y = e.y, this._x = e.x, this._y = e.y, this.onChange());
  }
  get vector3() {
    return this._data;
  }
  set vector3(e) {
    (this._x != e.x || this._y != e.y || this._z != e.z) && (this._data.x = e.x, this._data.y = e.y, this._data.z = e.z, this._x = e.x, this._y = e.y, this._z = e.z, this.onChange());
  }
  get vector4() {
    return this._data;
  }
  set vector4(e) {
    (this._x != e.x || this._y != e.y || this._z != e.z || this._w != e.w) && (this._data.x = e.x, this._data.y = e.y, this._data.z = e.z, this._data.w = e.w, this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChange());
  }
  onChange() {
    this.bindOnChange && this.bindOnChange();
  }
  float32Array(e) {
    this._data.set(e), this.onChange();
  }
  update() {
    switch (this._type) {
      case He.Number:
        this.memoryInfo.dataBytes.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, this._data, true);
        break;
      case He.Vector2:
        this.memoryInfo.setVector2(0, this._data);
        break;
      case He.Vector3:
        this.memoryInfo.setVector3(0, this._data);
        break;
      case He.Vector4:
        this.memoryInfo.setVector4(0, this._data);
        break;
      case He.Color:
        this.memoryInfo.setColor(0, this._data);
        break;
      case He.Float32Array:
        this.memoryInfo.setFloat32Array(0, this._data);
        break;
    }
  }
};
var Es = class {
  constructor() {
    __publicField(this, "instanceID");
    __publicField(this, "shaderVariant");
    __publicField(this, "vsEntryPoint", "main");
    __publicField(this, "fsEntryPoint", "main");
    __publicField(this, "bindGroups");
    __publicField(this, "shaderReflection");
    __publicField(this, "defineValue");
    __publicField(this, "constValues");
    __publicField(this, "uniforms");
    __publicField(this, "materialDataUniformBuffer");
    __publicField(this, "_bufferDic");
    __publicField(this, "_shaderChange", true);
    __publicField(this, "_valueChange", false);
    this.instanceID = gt(), this.defineValue = {}, this.constValues = {}, this.uniforms = {}, this._bufferDic = /* @__PURE__ */ new Map();
  }
  noticeShaderChange() {
    this._shaderChange = true;
  }
  noticeValueChange() {
    this._valueChange = true;
  }
  setStorageBuffer(e, t) {
    this._bufferDic.has(e) ? this._bufferDic.set(e, t) : (this._bufferDic.set(e, t), this.noticeBufferChange(e));
  }
  setStructStorageBuffer(e, t) {
    this._bufferDic.has(e) ? (this._bufferDic.set(e, t), this.noticeBufferChange(e)) : this._bufferDic.set(e, t);
  }
  setUniformBuffer(e, t) {
    this._bufferDic.has(e) ? (this._bufferDic.set(e, t), this.noticeBufferChange(e)) : this._bufferDic.set(e, t);
  }
  setDefine(e, t) {
    (this.defineValue[e] == null || this.defineValue[e] != t) && (this.defineValue[e] = t, this.noticeValueChange(), this.noticeShaderChange()), this.defineValue[e] = t;
  }
  hasDefine(e) {
    return this.defineValue[e] != null;
  }
  deleteDefine(e) {
    delete this.defineValue[e], this.noticeShaderChange();
  }
  setUniformFloat(e, t) {
    this.uniforms[e] ? this.uniforms[e].value = t : (this.uniforms[e] = new dr(t), this.noticeValueChange());
  }
  setUniformVector2(e, t) {
    this.uniforms[e] ? this.uniforms[e].vector2 = t : (this.uniforms[e] = new dr(t), this.noticeValueChange());
  }
  setUniformVector3(e, t) {
    this.uniforms[e] ? this.uniforms[e].vector3 = t : this.uniforms[e] = new dr(t);
  }
  setUniformVector4(e, t) {
    this.uniforms[e] ? this.uniforms[e].vector4 = t : this.uniforms[e] = new dr(t);
  }
  setUniformColor(e, t) {
    this.uniforms[e] ? this.uniforms[e].color = t : this.uniforms[e] = new dr(t);
  }
  setUniformArray(e, t) {
    this.uniforms[e] ? this.uniforms[e].float32Array(t) : this.uniforms[e] = new dr(t);
  }
  setUniform(e, t) {
    this.uniforms[e] ? this.uniforms[e].data = t : this.uniforms[e] = new dr(t);
  }
  getUniform(e) {
    return this.uniforms[e].data;
  }
  getUniformFloat(e) {
    return this.uniforms[e].data;
  }
  getUniformVector2(e) {
    return this.uniforms[e].data;
  }
  getUniformVector3(e) {
    return this.uniforms[e].data;
  }
  getUniformVector4(e) {
    return this.uniforms[e].data;
  }
  getUniformColor(e) {
    return this.uniforms[e].color;
  }
  getBuffer(e) {
    return this._bufferDic[e].data;
  }
  noticeBufferChange(e) {
  }
  applyUniform() {
    this.materialDataUniformBuffer && this._valueChange && this.materialDataUniformBuffer.apply();
  }
  destroy(e) {
  }
};
var gr = ((s) => (s[s.u32 = 1] = "u32", s[s.f32 = 1] = "f32", s[s["vec2<f32>"] = 2] = "vec2<f32>", s[s["vec3<f32>"] = 3] = "vec3<f32>", s[s["vec4<f32>"] = 4] = "vec4<f32>", s[s.float32 = 1] = "float32", s[s.float32x2 = 2] = "float32x2", s[s.float32x3 = 3] = "float32x3", s[s.float32x4 = 4] = "float32x4", s))(gr || {});
var an = [null, vi.float32, vi.float32x2, vi.float32x3, vi.float32x4];
var sn = `
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;
var Bs = class {
};
__publicField(Bs, "sky_vs_frag_wgsl", `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(auto) fragUV: vec2<f32>,
      @location(auto) vWorldPos: vec4<f32>,
      @location(auto) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(auto) position: vec3<f32>,
      @location(auto) normal: vec3<f32>,
      @location(auto) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `);
__publicField(Bs, "sky_fs_frag_wgsl", `
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(auto) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(auto) o_Normal: vec4<f32>,
          @location(auto) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `);
var on = `
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 
      
      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`;
var ha = `


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns 1
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth:f32, near:f32, far:f32) -> f32 {
      let Fcoef:f32 = 2.0 / log2(far + 1.0);
      var result:f32 = (log2(max(1e-6, 1.0 + depth)) * Fcoef - 1.0);
      result = (1.0 + result) / 2.0;
      return result * depth;
    }

    fn log2DepthFixPersp(depth:f32, near:f32, far:f32) -> f32 {
      let flogz:f32 = 1.0 + depth;
      let Fcoef_half:f32 = (2.0 / log2(far + 1.0)) * 0.5;
      var result:f32 = log2(flogz) * Fcoef_half;
      result = (1.0 + result) / 2.0;
      return result;
    }


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

`;
var nn = `
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  transformUV1:vec4<f32>,
                  transformUV2:vec4<f32>,

                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,
                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,
                  ao: f32,

                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,
                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,
                  clearcoatColor: vec4<f32>,
                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `;
var ln = `


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`;
var hn = `
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;
var Hr = class {
  static groupBindingAndFunctions(e, t) {
    return `
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${t})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${t + 1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${t + 2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `;
  }
};
var un = `
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${dt.getMorphTargetShaderBinding(3, 0)}
        ${Hr.groupBindingAndFunctions(3, 2)} 
    #else
        #if USE_MORPHTARGETS
            ${dt.getMorphTargetShaderBinding(3, 0)}
        #endif

        #if USE_SKELETON
            ${Hr.groupBindingAndFunctions(3, 0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #else
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(auto) index: f32,
    @location(auto) varying_UV0: vec2<f32>,
    @location(auto) varying_UV1: vec2<f32>,
    @location(auto) varying_ViewPos: vec4<f32>,
    @location(auto) varying_Clip: vec4<f32>,
    @location(auto) varying_WPos: vec4<f32>,
    @location(auto) varying_WNormal: vec3<f32>,
    @location(auto) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(auto) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(auto) varying_Tangent: vec4<f32>,
    #endif
   

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${dt.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${dt.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    #if USE_LOGDEPTH
        clipPosition.z = log2Depth(clipPosition.w, globalUniform.near, globalUniform.far);
    #endif

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`;
var cn = `
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`;
var fn = `
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`;
var dn = `
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`;
var gn = `
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2DepthFixPersp(ORI_VertexVarying.fragPosition.w, globalUniform.near, globalUniform.far);
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


`;
var pn = `
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`;
var mn = `
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`;
var An = `
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;
var Ct = class {
};
__publicField(Ct, "Cascades", 4);
var ua = `

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${Ct.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    empty1: i32,
    empty2: i32,
    empty3: i32,

    frustumPlanes: array<vec4f, 6u>,
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`;
var vn = `
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`;
var Ts = `
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`;
var xn = `
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`;
var _n = `

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`;
var Cn = `
    struct FragmentVarying {
        @location(auto) index: f32,
        @location(auto) fragUV0: vec2<f32>,
        @location(auto) fragUV1: vec2<f32>,
        @location(auto) viewPosition: vec4<f32>,
        @location(auto) fragPosition: vec4<f32>,
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) vWorldNormal: vec3<f32>,
        @location(auto) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(auto) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`;
var Ds = `
    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`;
var Sn = `
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,
    }
`;
var yn = `
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`;
var wn = `
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }
    var<private> shadowStrut: ShadowStruct ;

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        #if USE_SHADOWMAPING
          directShadowMaping(globalUniform.shadowBias);
          pointShadowMapCompare(globalUniform.pointShadowBias);
        #endif
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${Ct.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {

        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }

    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        visibility = 0.0;
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var totalWeight = 0.0;
        var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
        let v = max(NoL, 0.0) ;
        var bias = shadowBias / v;
        for (var y = -1; y <= 1; y++) {
          for (var x = -1; x <= 1; x++) {
            var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
            
            // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
            var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
            if ((shadowPos.z - bias ) < depth) {
              visibility += 1.0 ;
            }
            totalWeight += 1.0;
          }
        }
        visibility /= totalWeight;
        visibility += 0.001;
      }
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              let sampleOffset = offset / (samples * 0.5);
              for (var x: f32 = -offset; x < offset; x += sampleOffset) {
                for (var y: f32 = -offset; y < offset; y += sampleOffset) {
                  for (var z: f32 = -offset; z < offset; z += sampleOffset) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
                shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
            #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    shadowStrut.pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`;
var In = `
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`;
var bn = `
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness ;//pow(roughness,5.0) ;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , alpha);
        let G = GeometrySmith(Context.NoV,Context.NoL, alpha );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return (col.rgb) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        // var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return fragData.EnvColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let NdotV = max(dot(N,V),0.0);
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));

        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);

        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }
`;
var En = `
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;


      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * vec3f(kdLast) * fragData.Albedo.rgb ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
          // ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,1.0,1.0);
      #endif
      
      var color = specColor + indirectResult ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      var retColor = (LinearToGammaSpace(color.rgb));
      retColor += fragData.Emissive.xyz ;
      ORI_FragmentOutput.color = vec4<f32>( retColor.rgb * fragData.Albedo.a ,fragData.Albedo.a) ;
  }

  `;
var Bn = `
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`;
var Tn = `
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`;
var Dn = `
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = gammaToLiner(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        useShadow();

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif


        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`;
var Pn = `
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`;
var Mn = `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`;
var Rn = `
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(auto) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`;
var Un = `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`;
var Ln = `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`;
var On = `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`;
var Ff = `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`;
var Ps = `
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`;
var Fn = `
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`;
var Nn = `
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildYRotateXMat4(radY:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            x,y,z,1.0,
        );
        return yRot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`;
var zn = `
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`;
var kn = `
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt / LUMEN) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              // var shadow = 0.0 ;
              // if(light.castShadow>=0){
              //     #if USE_SHADOWMAPING
              //       shadow = shadowStrut.directShadowVisibility[i32(light.castShadow)] ; 
              //     #endif
              // }

              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `;
var Gn = `
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `;
var Qn = `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        
        UnLit();

        // ORI_FragmentOutput.color = vec4<f32>( 1.0,0.0,0.0,1.0) ;
    }
`;
var Vn = `
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`;
var Hn = `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`;
var Yn = `
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`;
var Xn = `
#include "GlobalUniform"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`;
var Ms = `
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`;
var Wn = `
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${dt.getMorphTargetShaderBinding(2, 1)}
#endif

#if USE_SKELETON
    ${Hr.groupBindingAndFunctions(2, 1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(auto) position: vec3<f32>,
    @location(auto) normal: vec3<f32>,
    @location(auto) uv: vec2<f32>,
    @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${dt.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`;
var jn = `
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @location(auto) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${dt.getMorphTargetShaderBinding(2, 1)}
##endif
 
#if USE_SKELETON
    ${Hr.groupBindingAndFunctions(2, 1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(auto) position: vec3<f32>,
  @location(auto) normal: vec3<f32>,
  @location(auto) uv: vec2<f32>,
  @location(auto) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #else
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #endif
    #else
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            @location(auto) vIndex: f32,
        #else
            @location(auto) vIndex: f32,
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${dt.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${dt.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`;
var qn = `
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`;
var Kn = `
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`;
var Jn = `
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(auto) vID: f32 ,
        @location(auto) vPos: vec3<f32> ,
        @location(auto) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${dt.getMorphTargetShaderBinding(1, 0)}
    #endif

    #if USE_SKELETON
        ${Hr.groupBindingAndFunctions(1, 0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            @location(auto) vIndex: f32,
        #endif
    #elseif USE_SKELETON
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(auto) joints1: vec4<f32>,
            @location(auto) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        @location(auto) vIndex: f32,
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${dt.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`;
var Zn = `
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(auto) vID: f32, @location(auto) vPos:vec3<f32> ,  @location(auto) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`;
var O = class _O {
  static init() {
    _O.register("MathShader", ha), _O.register("FastMathShader", xn), _O.register("MatrixShader", Nn), _O.register("GlobalUniform", ua), _O.register("WorldMatrixUniform", Ts), _O.register("NormalMap_frag", _n), _O.register("LightingFunction_frag", on), _O.register("PhysicMaterialUniform_frag", nn), _O.register("UnLitMaterialUniform_frag", ln), _O.register("VideoUniform_frag", cn), _O.register("InstanceUniform", vn), _O.register("Inline_vert", dn), _O.register("VertexAttributes_vert", un), _O.register("Common_vert", pn), _O.register("Common_frag", gn), _O.register("FragmentVarying", Cn), _O.register("ColorPassFragmentOutput", Ds), _O.register("ClusterLight", zn), _O.register("ShadingInput", Sn), _O.register("IESProfiles_frag", yn), _O.register("ShadowMapping_frag", wn), _O.register("Irradiance_frag", In), _O.register("IrradianceVolumeData_frag", fn), _O.register("BrdfLut_frag", mn), _O.register("EnvMap_frag", An), _O.register("ColorUtil_frag", Ps), _O.register("ColorUtil", Ps), _O.register("BRDF_frag", bn), _O.register("Hair_frag", kn), _O.register("BxDF_frag", En), _O.register("BsDF_frag", Gn), _O.register("UnLit_frag", hn), _O.register("UnLit", Qn), _O.register("Clearcoat_frag", Bn), _O.register("LitShader", Tn), _O.register("PBRLItShader", Dn), _O.register("ClusterDebug_frag", sn), _O.register("BxdfDebug_frag", Pn), _O.register("GenerayRandomDir", Fn), _O.register("Quad_vert_wgsl", Rn), _O.register("Quad_frag_wgsl", Un), _O.register("Quad_depth2d_frag_wgsl", Ln), _O.register("Quad_depthCube_frag_wgsl", On), _O.register("sky_vs_frag_wgsl", Bs.sky_vs_frag_wgsl), _O.register("sky_fs_frag_wgsl", Bs.sky_fs_frag_wgsl), _O.register("LambertShader", Vn), _O.register("QuadGlsl_vs", Hn), _O.register("QuadGlsl_fs", Yn), _O.register("SkyGBuffer_fs", Xn), _O.register("gbuffer_vs", Ms), _O.register("gbuffer_fs", Ms), _O.register("castPointShadowMap_vert", jn), _O.register("shadowCastMap_frag", qn), _O.register("shadowCastMap_vert", Wn), _O.register("directionShadowCastMap_frag", Kn), _O.register("ZPass_shader_vs", Jn), _O.register("ZPass_shader_fs", Zn);
  }
  static register(e, t) {
    _O[e.toLowerCase()] || (_O[e.toLowerCase()] = t);
  }
  static getShader(e) {
    return _O[e.toLowerCase()], _O[e.toLowerCase()];
  }
};
var Dt = class {
  static parse(e, t) {
    return e = this.filterComment(e), e = this.parsePreprocess(new $n(), e, t), e = this.parseAutoBindingForAllGroup(e), e = this.parseAutoLocationBlock(e), e;
  }
  static parseComputeShader(e, t) {
    return e = this.filterComment(e), e = this.parsePreprocess(new $n(), e, t), e = this.parseAutoBindingForAllGroup(e), e;
  }
  static parsePreprocess(e, t, r) {
    let i = t.indexOf("#");
    if (i == -1)
      return t;
    let a = t.substring(0, i), o = t.indexOf(`
`, t.lastIndexOf("#")), n = t.substring(i, o), l = t.substring(o);
    return a + this.parsePreprocessCommand(e, n, r) + l;
  }
  static parseAutoBindingForAllGroup(e) {
    let t = 0, r = "", i = /* @__PURE__ */ new Map();
    for (; t < e.length; ) {
      let a = e.indexOf("@group(", t);
      if (a == -1) {
        r += e.substring(t);
        break;
      }
      let o = e.indexOf(")", a), n = Number.parseInt(e.substring(a + 7, o));
      a = e.indexOf("@binding(", o), o = e.indexOf(")", a);
      let l = e.substring(a + 9, o);
      if (r += e.substring(t, a), l.includes("auto"))
        if (i.has(n)) {
          let h = i.get(n) + 1;
          r += `@binding(${h})`, i.set(n, h);
        } else
          r += "@binding(0)", i.set(n, 0);
      else {
        let h = Number.parseInt(l);
        (!i.has(n) || i.get(n) < h) && i.set(n, h), r += `@binding(${l})`;
      }
      t = o + 1;
    }
    return r;
  }
  static parseAutoBindingForGroupX(e, t) {
    let r = 0, i = "", a = /* @__PURE__ */ new Map();
    for (; r < e.length; ) {
      let o = e.indexOf("@group(", r);
      if (o == -1) {
        i += e.substring(r);
        break;
      }
      let n = e.indexOf(")", o), l = Number.parseInt(e.substring(o + 7, n));
      if (o = e.indexOf("@binding(", n), n = e.indexOf(")", o), i += e.substring(r, o), l == t)
        if (a.has(l)) {
          let h = a.get(l) + 1;
          i += `@binding(${h})`, a.set(l, h);
        } else
          i += "@binding(0)", a.set(l, 0);
      else
        i += e.substring(o, n + 1);
      r = n + 1;
    }
    return i;
  }
  static parseAutoLocation(e) {
    let t = 0, r = "", i = 0;
    for (; t < e.length; ) {
      let a = e.indexOf("@location(", t);
      if (a == -1) {
        r += e.substring(t);
        break;
      }
      let o = e.indexOf(")", a), n = e.substring(a + 10, o);
      r += e.substring(t, a), n === "auto" ? (r += `@location(${i})`, i++) : r += e.substring(a, o + 1), t = o + 1;
    }
    return r;
  }
  static parseAutoLocationBlock(e) {
    let t = 0, r = "";
    for (; t < e.length; ) {
      let i = e.indexOf("@location(", t);
      if (i == -1) {
        r += e.substring(t);
        break;
      }
      let a = e.indexOf("}", i), o = e.indexOf("->", i);
      o != -1 && o < a && (a = o);
      let n = e.substring(i, a + 1);
      n = this.parseAutoLocation(n), r += e.substring(t, i), r += n, t = a + 1;
    }
    return r;
  }
  static parsePreprocessCommand(e, t, r) {
    let i = "", a = t.split(`
`), o = [false], n = [false];
    for (let l = 0; l < a.length; l++) {
      let h = a[l], u = o[o.length - 1];
      if (h.trim().indexOf("#") != 0) {
        u || (i += h + `
`);
        continue;
      }
      let c = h.trim();
      if (c.indexOf("#if") != -1) {
        if (u && o.length > 1) {
          o.push(u);
          continue;
        }
        let f = c.substring(3).trim();
        u = !this.parseCondition(f, r), o.push(u), n.push(!u);
        continue;
      } else if (c.indexOf("#elseif") != -1 || c.indexOf("#else") != -1 && c.indexOf(" if") != -1) {
        if (n[n.length - 1]) {
          o.pop(), u = true, o.push(u);
          continue;
        }
        if (o.pop(), u = o[o.length - 1], u && o.length > 1) {
          o.push(u);
          continue;
        }
        let g = c.substring(c.indexOf("if") + 2).trim();
        g == "" && console.error(`preprocess command error, conditions missing: ${c}`), u = !this.parseCondition(g, r), o.push(u), n.push(!u);
        continue;
      } else if (c.indexOf("#else") != -1) {
        o.pop(), u && o.length > 1 && o[o.length - 1] ? o.push(u) : o.push(!u);
        continue;
      } else if (c.indexOf("#endif") != -1) {
        o.pop(), n.pop();
        continue;
      } else if (c.indexOf("#include") != -1) {
        let f = "", g = c.charAt(c.length - 1);
        if (g == ">" ? f = this.extract(c, "<", ">") : f = this.extract(c, g, g), !e.includeMap.has(f)) {
          e.includeMap.set(f, true);
          let m = O.getShader(f);
          if (!m)
            throw `${c} error: '${f}' not found`;
          m = this.filterComment(m), m = this.parsePreprocess(e, m, r), i += m + `\r
`;
        }
        continue;
      } else if (c.indexOf("#define ") != -1) {
        let f = c.substring(c.indexOf("#define ") + 8).trim(), g = f.indexOf(" "), m = f, A = "";
        g != -1 && (m = f.substring(0, g).trim(), A = f.substring(g + 1).trim()), r[m] = A;
        continue;
      } else
        throw "nonsupport: " + c;
    }
    return i;
  }
  static parseCondition(e, t) {
    let r = t[e];
    return r == null ? false : r == true || r != 0;
  }
  static filterComment(e) {
    let t = "", r = true, i = true;
    for (let a = 0; a < e.length; ) {
      let o = r ? e.indexOf("//", a) : -1, n = i ? e.indexOf("/*", a) : -1;
      if (o == -1 && n == -1) {
        t += e.substring(a);
        break;
      }
      r = o != -1, i = n != -1, o != -1 && n != -1 && (o < n ? n = -1 : o = -1), o != -1 ? (n = e.indexOf(`
`, o), t += e.substring(a, o), a = n != -1 ? n : e.length) : n != -1 && (o = e.indexOf("*/", n), t += e.substring(a, n), a = o + 2);
    }
    return t;
  }
  static extract(e, t, r) {
    let i = e.indexOf(t) + t.length, a = e.indexOf(r, i);
    return e.substring(i, a).trim();
  }
};
var $n = class {
  constructor() {
    __publicField(this, "includeMap", /* @__PURE__ */ new Map());
  }
};
var _Je = class _Je {
  constructor() {
    __publicField(this, "attributes", []);
    __publicField(this, "vs_variables", []);
    __publicField(this, "fs_variables", []);
    __publicField(this, "cs_variables", []);
    __publicField(this, "groups", []);
    __publicField(this, "variables", {});
    __publicField(this, "useSplit", false);
  }
  static parser(e, t) {
    t.shaderReflection || (t.shaderReflection = new _Je()), e.indexOf("@vertex") != -1 ? (t.shaderReflection.attributes = this.parserVertexOld(e), t.shaderReflection.vs_variables = this.parserVariables(e)) : e.indexOf("@fragment") != -1 ? t.shaderReflection.fs_variables = this.parserVariables(e) : e.indexOf("@compute") != -1 && (t.shaderReflection.cs_variables = this.parserVariables(e));
  }
  static parser2(e, t) {
    t.shaderReflection || (t.shaderReflection = new _Je());
    let r = t.shaderReflection;
    e.indexOf("@vertex") != -1 ? (r.attributes = this.parserVertex(t.vsEntryPoint, e), r.vs_variables = this.parserVariables(e)) : e.indexOf("@fragment") != -1 ? r.fs_variables = this.parserVariables(e) : e.indexOf("@compute") != -1 && (r.cs_variables = this.parserVariables(e)), e.indexOf("splitTexture") != -1 && (r.useSplit = true);
  }
  static combineShaderReflectionVarInfo(e, t) {
    for (const r of t) {
      e.groups[r.group] || (e.groups[r.group] = []);
      let i = r;
      if (e.groups[r.group][r.binding]) {
        let a = e.groups[r.group][r.binding], o = r;
        if (a.dataFields)
          for (let n = 0; n < a.dataFields.length; n++)
            a.dataFields[n];
        if (o.dataFields)
          for (let n = 0; n < o.dataFields.length; n++)
            o.dataFields[n];
      }
      e.groups[r.group][r.binding] = i, e.variables[r.varName] = i;
    }
  }
  static final(e) {
    let t = e.shaderReflection;
    this._shaderReflectionMap.set(e.shaderVariant, t), this.combineShaderReflectionVarInfo(t, t.vs_variables), this.combineShaderReflectionVarInfo(t, t.fs_variables);
  }
  static getShaderReflection2(e, t) {
    let r = Dt.parse(e, t.defineValue);
    _Je.parser2(r, t);
  }
  static poolGetReflection(e) {
    return this._shaderReflectionMap.get(e);
  }
  static genShaderVar(e) {
    let t = `${e.vs}${e.fs}${e.compute}`;
    t += "|";
    for (const r in e.uniforms)
      t += r + ":";
    t += "|";
    for (const r in e.constValues)
      t += r + ":", t += e.constValues[r];
    t += "|";
    for (const r in e.defines)
      t += r + ":", t += e.defines[r];
    t += "|";
    for (const r in e.shaderState)
      t += r + ":", t += e.shaderState[r] + ";";
    return t;
  }
  static genShaderVariant(e) {
    let t = "";
    for (const r in e.uniforms)
      t += r + ":";
    t += "|";
    for (const r in e.constValues)
      t += r + ":", t += e.constValues[r];
    t += "|";
    for (const r in e.defineValue)
      t += r + ":", t += e.defineValue[r];
    return t;
  }
  static genRenderShaderVariant(e) {
    let t = `RenderShader(${e.vsName},${e.fsName})`;
    t += "|", t += this.genShaderVariant(e), t += "|";
    for (const r in e.shaderState)
      t += r + ":", t += e.shaderState[r] + ";";
    return t;
  }
  static genComputeShaderVariant(e) {
    let t = `ComputeShader(${e.instanceID})`;
    return t += "|", t += this.genShaderVariant(e), t;
  }
  combine(e) {
    let t = e.shaderReflection, r = e.defines, i = {};
    for (let o = 0; o < this.attributes.length; o++) {
      let n = this.attributes[o];
      r[n.name] && (i[n.name] = n);
    }
    let a = t.attributes.length;
    for (let o = 0; o < a; o++) {
      const n = t.attributes[o];
      if (!i[n.name])
        this.attributes.push(n);
      else {
        let l = i[n.name];
        l.location == n.location && l.name != n.name && console.log("location must same!");
      }
    }
  }
  static parserVariables(e) {
    let t = 0, r = [];
    for (; t < e.length; ) {
      let i = e.indexOf("@group(", t);
      if (i < 0)
        break;
      let a = e.indexOf(";", i);
      t = a;
      let o = e.substring(i, a), n = this.extract(o, "@group(", ")"), l = this.extract(o, "@binding(", ")"), h = "", u = "var";
      o.indexOf("var<") != -1 ? (h = this.extract(o, ">", ":"), u = this.extract(o, "var<", ">").replace(",", "-").replaceAll(" ", "")) : h = this.extract(o, "var", ":");
      let c = o.substring(o.lastIndexOf(":") + 1).trim(), f = { group: 0, binding: 0, varType: "", varName: "", dataType: "", dataIsBuiltinType: true, dataFields: null };
      f.group = Number.parseInt(n), f.binding = Number.parseInt(l), f.varType = u, f.varName = h, f.dataType = c, f.dataIsBuiltinType = this.isBuiltinTypes(f.dataType), f.dataIsBuiltinType || (f.dataFields = this.parserStructFields(e, f.dataType)), r.push(f);
    }
    return r;
  }
  static extract(e, t, r) {
    let i = e.indexOf(t) + t.length, a = e.indexOf(r, i);
    return e.substring(i, a).trim();
  }
  static isBuiltinTypes(e) {
    switch (e) {
      case "i32":
        return true;
      case "u32":
        return true;
      case "f32":
        return true;
      default:
        let t = e.indexOf("<");
        if (t != -1)
          switch (e.substring(0, t)) {
            case "vec2":
              return true;
            case "vec3":
              return true;
            case "vec4":
              return true;
            case "mat3":
              return true;
            case "mat4":
              return true;
            case "array":
              return this.isBuiltinTypes(e.substring(t + 1, e.lastIndexOf(">")));
          }
        break;
    }
    return false;
  }
  static parserStructFields(e, t) {
    let r = [], i = 0;
    for (; i < e.length; ) {
      let a = e.indexOf("struct ", i);
      if (a < 0)
        break;
      let o = e.indexOf("{", a);
      if (i = o, e.substring(a + 6, o).trim() === t) {
        a = e.indexOf("{", a), o = e.indexOf("}", a);
        let h = e.substring(a + 1, o).split(",");
        for (let u of h) {
          let c = u.indexOf(":");
          if (c != -1) {
            let f = { name: u.substring(0, c).trim(), type: u.substring(c + 1).trim() };
            r.push(f);
          }
        }
        break;
      }
    }
    return r;
  }
  static parserVertexOld(e) {
    let t = [], i = e.split("fn main(")[1].split("->")[0], a = i.split("@");
    if (a && a.length > 1)
      for (let n = 1; n < a.length; n++) {
        let h = a[n].replace(/\s*$/g, "");
        h = h.replaceAll(",", ""), h = h.replaceAll(`
`, ""), h = h.replaceAll("  ", " "), this.parserAttribute(h, t);
      }
    else {
      var o = i.split(":")[1];
      o = o.replaceAll("  ", ""), o = o.replaceAll(" ", ""), o = o.replaceAll(")", ""), o = e.split(`struct ${o}`)[1];
      let l = o.indexOf("{"), h = o.indexOf("}");
      o = o.slice(l, h), a = o.split("@");
      for (let u = 1; u < a.length; u++) {
        let f = a[u].replace(/\s*$/g, "");
        f = f.replaceAll(`
`, ""), f = f.split(",")[0], f = f.replaceAll("  ", " "), this.parserAttribute(f, t);
      }
    }
    return t;
  }
  static parserVertex(e, t) {
    let r = [], a = t.split(`fn ${e}(`)[1].split("->")[0], o = a.split("@");
    if (o && o.length > 1)
      for (let l = 1; l < o.length; l++) {
        let u = o[l].replace(/\s*$/g, "");
        u = u.replaceAll(",", ""), u = u.replaceAll(`
`, ""), u = u.replaceAll("  ", " "), this.parserAttribute(u, r);
      }
    else {
      var n = a.split(":")[1];
      n = n.replaceAll("  ", ""), n = n.replaceAll(" ", ""), n = n.replaceAll(")", ""), n = t.split(`struct ${n}`)[1];
      let h = n.indexOf("{"), u = n.indexOf("}");
      n = n.slice(h, u), o = n.split("@");
      for (let c = 1; c < o.length; c++) {
        let g = o[c].replace(/\s*$/g, "");
        g = g.replaceAll(`
`, ""), g = g.split(",")[0], g = g.replaceAll("  ", " "), this.parserAttribute(g, r);
      }
    }
    return r;
  }
  static parserAttribute(e, t) {
    let r = { name: "", group: 0, location: 0, type: "", valueType: "", value: 0, size: 0, format: "float32" };
    if (e.indexOf("builtin") != -1) {
      r.type = "builtin";
      var i = e.match(/\((.+?)\)/g)[0];
      i = e.match(/\((.+?)\)/g)[0], i = i.replace("(", ""), i = i.replaceAll(")", ""), r.location = parseInt(i);
      let a = e.split(":");
      r.name = a[0].split(" ")[1], r.name = r.name.replaceAll("  ", " "), r.name = r.name.replaceAll(" ", ""), r.valueType = a[1], r.valueType = r.valueType.replaceAll("  ", " "), r.valueType = r.valueType.replaceAll(" ", ""), r.valueType = r.valueType.replaceAll("\r", ""), r.valueType = r.valueType.replaceAll(")", ""), r.valueType = r.valueType.replaceAll(")", ""), r.size = gr[r.valueType], t.push(r);
    } else if (e.indexOf("location") != -1) {
      r.type = "location";
      var i = e.match(/\((.+?)\)/g)[0];
      i = e.match(/\((.+?)\)/g)[0], i = i.replace("(", ""), i = i.replaceAll(")", ""), r.location = parseInt(i);
      let o = e.split(":");
      r.name = o[0].split(" ")[1], r.name = r.name.replaceAll("  ", " "), r.name = r.name.replaceAll(" ", ""), r.valueType = o[1], r.valueType = r.valueType.replaceAll("  ", " "), r.valueType = r.valueType.replaceAll(" ", ""), r.valueType = r.valueType.replaceAll("\r", ""), r.valueType = r.valueType.replaceAll(")", ""), r.valueType = r.valueType.replaceAll(")", ""), r.size = gr[r.valueType], t.push(r);
    }
    r.format = an[gr[r.valueType]];
  }
};
__publicField(_Je, "_shaderReflectionMap", /* @__PURE__ */ new Map());
var Je = _Je;
var ae = class extends Es {
  constructor(e) {
    super();
    __publicField(this, "entryPoint", "CsMain");
    __publicField(this, "workerSizeX", 1);
    __publicField(this, "workerSizeY", 0);
    __publicField(this, "workerSizeZ", 0);
    __publicField(this, "_computePipeline");
    __publicField(this, "_csShaderModule");
    __publicField(this, "_destCS");
    __publicField(this, "_sourceCS");
    __publicField(this, "_storageTextureDic");
    __publicField(this, "_sampleTextureDic");
    __publicField(this, "_groupsShaderReflectionVarInfos");
    __publicField(this, "_groupCache", {});
    this._sourceCS = e, Je.getShaderReflection2(e, this), this._storageTextureDic = /* @__PURE__ */ new Map(), this._sampleTextureDic = /* @__PURE__ */ new Map();
  }
  setStorageTexture(e, t) {
    this._storageTextureDic.has(e) || this._storageTextureDic.set(e, t);
  }
  setSamplerTexture(e, t) {
    this._sampleTextureDic.set(e, t);
  }
  compute(e) {
    this._computePipeline || this.genComputePipeline(), e.setPipeline(this._computePipeline);
    for (let t = 0; t < this.bindGroups.length; ++t)
      e.setBindGroup(t, this.bindGroups[t]);
    this.workerSizeX && this.workerSizeY && this.workerSizeZ ? e.dispatchWorkgroups(this.workerSizeX, this.workerSizeY, this.workerSizeZ) : this.workerSizeX && this.workerSizeY ? e.dispatchWorkgroups(this.workerSizeX, this.workerSizeY) : e.dispatchWorkgroups(this.workerSizeX);
  }
  createBufferBindGroup(e, t, r, i) {
    let a = this._bufferDic.get(t);
    if (a) {
      let o = { binding: r, resource: { buffer: a.buffer, offset: 0, size: a.memory.shareDataBuffer.byteLength } };
      i.push(o);
    } else
      console.error(`ComputeShader(${this.instanceID})`, `buffer ${t} is missing!`);
  }
  noticeBufferChange(e) {
    let t = this._groupCache[e];
    t && this.genGroups(t.groupIndex, t.infos, true);
  }
  genGroups(e, t, r = false) {
    if (!this.bindGroups[e] || r) {
      const i = t[e];
      let a = [];
      for (let n = 0; n < i.length; ++n) {
        const l = i[n];
        if (l)
          switch (l.varType) {
            case "uniform":
            case "storage-read":
            case "storage-read_write":
              this.createBufferBindGroup(e, l.varName, l.binding, a), this._groupCache[l.varName] = { groupIndex: e, infos: t };
              break;
            case "var":
              if (l.dataType == "sampler") {
                let h = l.varName.replace("Sampler", ""), u = this._sampleTextureDic.get(h);
                if (u) {
                  let c = { binding: l.binding, resource: u.gpuSampler };
                  a.push(c);
                } else
                  console.error(`ComputeShader(${this.instanceID})`, `texture ${l.varName} is missing! `);
              } else if (l.dataType == "sampler_comparison") {
                let h = l.varName.replace("Sampler", ""), u = this._sampleTextureDic.get(h);
                if (u) {
                  let c = { binding: l.binding, resource: u.gpuSampler_comparison };
                  a.push(c);
                } else
                  console.error(`ComputeShader(${this.instanceID})`, `texture ${l.varName} is missing! `);
              } else if (l.dataType.indexOf("texture_storage") != -1) {
                let h = this._storageTextureDic.get(l.varName);
                if (h) {
                  let u = { binding: l.binding, resource: h.getGPUView() };
                  a.push(u), ie.getInstance().attached(h, this);
                } else
                  console.error(`ComputeShader(${this.instanceID})`, `texture ${l.varName} is missing! `);
              } else if (l.dataType.indexOf("texture") != -1) {
                let h = this._sampleTextureDic.get(l.varName);
                if (h) {
                  let u = { binding: l.binding, resource: h.getGPUView() };
                  a.push(u), ie.getInstance().attached(h, this);
                } else
                  console.error(`ComputeShader(${this.instanceID})`, `texture ${l.varName} is missing! `);
              }
              break;
            default:
              console.error("unprocessed type:", l.varType);
              break;
          }
      }
      let o = w.device.createBindGroup({ layout: this._computePipeline.getBindGroupLayout(e), entries: a });
      this.bindGroups[e] = o;
    }
  }
  genComputePipeline() {
    this.preCompileShader(this._sourceCS), this.genReflection(), this._computePipeline = w.device.createComputePipeline({ layout: "auto", compute: { module: this.compileShader(), entryPoint: this.entryPoint } }), this._groupsShaderReflectionVarInfos = [];
    let e = this.shaderReflection;
    this.bindGroups = [];
    for (let t = 0; t < e.groups.length; ++t) {
      let r = e.groups[t];
      this._groupsShaderReflectionVarInfos[t] = r, this.genGroups(t, this._groupsShaderReflectionVarInfos);
    }
    w.addEventListener(br.RESIZE, (t) => {
      for (let r = 0; r < e.groups.length; ++r) {
        let i = e.groups[r];
        this._groupsShaderReflectionVarInfos[r] = i, this.genGroups(r, this._groupsShaderReflectionVarInfos, true);
      }
    }, this);
  }
  preCompileShader(e) {
    for (const t in this.constValues)
      if (Object.prototype.hasOwnProperty.call(this.constValues, t)) {
        const r = this.constValues[t];
        e = e.replaceAll(`&${t}`, r.toString());
      }
    this._destCS = Dt.parseComputeShader(e, this.defineValue);
  }
  compileShader() {
    let e = w.device.createShaderModule({ label: `ComputeShader(${this.instanceID})`, code: this._destCS });
    return e.getCompilationInfo().then((t) => {
      t.messages.length > 0 && console.log(this._destCS);
    }), this._csShaderModule = e, e;
  }
  genReflection() {
    this.shaderVariant += Je.genComputeShaderVariant(this);
    let e = Je.poolGetReflection(this.shaderVariant);
    e ? this.shaderReflection = e : (Je.getShaderReflection2(this._destCS, this), Je.combineShaderReflectionVarInfo(this.shaderReflection, this.shaderReflection.cs_variables));
  }
};
var St = class {
  static start(e) {
    let t = this.profilerLabelMap.get(e);
    t || (t = { lable: e, start: 0, end: 0, total: 0, count: 0, child: /* @__PURE__ */ new Map() }, this.profilerLabelMap.set(e, t)), t.start = performance.now(), t.end = performance.now(), t.count = 0, t.child.clear();
  }
  static end(e) {
    let t = this.profilerLabelMap.get(e);
    t && (t.end = performance.now(), t.total = t.end - t.start);
  }
  static countStart(e, t = "") {
    let r = this.profilerLabelMap.get(e);
    if (r && (r.count++, t != "")) {
      let i = r.child.get(t);
      i || (i = { lable: t, start: 0, end: 0, total: 0, count: 0 }), i.start = performance.now(), i.end = performance.now(), i.count = 0, r.child.set(t, i);
    }
  }
  static countEnd(e, t) {
    let r = this.profilerLabelMap.get(e);
    if (r && t != "") {
      let i = r.child.get(t);
      i || (i = { lable: t, start: 0, end: 0, total: 0, count: 0 }), i.end = performance.now(), i.total = i.end - i.start, i.count++;
    }
  }
  static print(e) {
    let t = this.profilerLabelMap.get(e);
    t && console.log("performance", e, t.total + " ms");
  }
};
__publicField(St, "profilerLabelMap", /* @__PURE__ */ new Map());
var Nf = `var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `;
var _ee = class _ee {
  static async init(e) {
    await new Promise((t) => {
      const r = document.createElement("script");
      r.async = true, r.type = "text/javascript", r.src = URL.createObjectURL(new Blob([Nf])), document.head.appendChild(r), r.onload = () => {
        let i = () => {
          this.wasm = window.wasmMatrix, this.wasm && this.wasm.calledRun ? t(true) : setTimeout(i, 20);
        };
        i();
      };
    }), this.allocMatrix(e);
  }
  static allocMatrix(e) {
    e > P.maxCount && console.error(`The maximum allocation size is exceeded! current:${e}, limit:${P.maxCount}`), this.wasm._allocation(e), this.matrixBufferPtr = this.wasm._getMatrixBufferPtr(), this.matrixSRTBufferPtr = this.wasm._getSRTPtr(), this.matrixStateBufferPtr = this.wasm._getInfoPtr(), this.matrixContinuedSRTBufferPtr = this.wasm._getContinuedSRTPtr(), this.matrixBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixBufferPtr, 16 * e), this.matrixSRTBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixSRTBufferPtr, 3 * 3 * e), this.matrixContinuedSRTBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixContinuedSRTBufferPtr, 3 * 3 * e), this.matrixStateBuffer = new Int32Array(this.wasm.HEAP32.buffer, this.matrixStateBufferPtr, _ee.stateStruct * e), P.allocMatrix(e);
  }
  static updateAllContinueTransform(e, t, r) {
    this.wasm._updateAllMatrixContinueTransform(e, t, r);
  }
  static setParent(e, t, r) {
    this.matrixStateBuffer[e * _ee.stateStruct + 2] = t >= 0 ? t : -1, this.matrixStateBuffer[e * _ee.stateStruct + 3] = r;
  }
  static setTranslate(e, t, r, i) {
    this.matrixSRTBuffer[e * 9 + 6] = t, this.matrixSRTBuffer[e * 9 + 7] = r, this.matrixSRTBuffer[e * 9 + 8] = i;
  }
  static setRotation(e, t, r, i) {
    this.matrixSRTBuffer[e * 9 + 3] = t % 360, this.matrixSRTBuffer[e * 9 + 4] = r % 360, this.matrixSRTBuffer[e * 9 + 5] = i % 360;
  }
  static setScale(e, t, r, i) {
    this.matrixSRTBuffer[e * 9 + 0] = t, this.matrixSRTBuffer[e * 9 + 1] = r, this.matrixSRTBuffer[e * 9 + 2] = i;
  }
  static setContinueTranslate(e, t, r, i) {
    (t != 0 || r != 0 || i != 0) && (this.matrixContinuedSRTBuffer[e * 9 + 6] = t, this.matrixContinuedSRTBuffer[e * 9 + 7] = r, this.matrixContinuedSRTBuffer[e * 9 + 8] = i, this.matrixStateBuffer[e * _ee.stateStruct + 1] = 1);
  }
  static setContinueRotation(e, t, r, i) {
    (t != 0 || r != 0 || i != 0) && (this.matrixContinuedSRTBuffer[e * 9 + 3] = t, this.matrixContinuedSRTBuffer[e * 9 + 4] = r, this.matrixContinuedSRTBuffer[e * 9 + 5] = i, this.matrixStateBuffer[e * _ee.stateStruct + 1] = 1);
  }
  static setContinueScale(e, t, r, i) {
    (t != 0 || r != 0 || i != 0) && (this.matrixContinuedSRTBuffer[e * 9 + 0] = t, this.matrixContinuedSRTBuffer[e * 9 + 1] = r, this.matrixContinuedSRTBuffer[e * 9 + 2] = i, this.matrixStateBuffer[e * _ee.stateStruct + 1] = 1);
  }
};
__publicField(_ee, "matrixBuffer");
__publicField(_ee, "matrixSRTBuffer");
__publicField(_ee, "matrixContinuedSRTBuffer");
__publicField(_ee, "matrixStateBuffer");
__publicField(_ee, "matrixBufferPtr");
__publicField(_ee, "matrixSRTBufferPtr");
__publicField(_ee, "matrixContinuedSRTBufferPtr");
__publicField(_ee, "matrixStateBufferPtr");
__publicField(_ee, "wasm");
__publicField(_ee, "stateStruct", 4);
var ee = _ee;
var Zt = class {
};
__publicField(Zt, "AXIS_ANGLE", "axisAngle");
__publicField(Zt, "EULER_ANGLES", "eulerAngles");
__publicField(Zt, "QUATERNION", "quaternion");
var _H = class _H {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "w", 1);
    this.x = e, this.y = t, this.z = r, this.w = i;
  }
  static identity() {
    return _H._zero;
  }
  static quaternionToMatrix(e, t) {
    let r = e.x * 2, i = e.y * 2, a = e.z * 2, o = e.x * r, n = e.y * i, l = e.z * a, h = e.x * i, u = e.x * a, c = e.y * a, f = e.w * r, g = e.w * i, m = e.w * a;
    t.rawData[0] = 1 - (n + l), t.rawData[1] = h + m, t.rawData[2] = u - g, t.rawData[3] = 0, t.rawData[4] = h - m, t.rawData[5] = 1 - (o + l), t.rawData[6] = c + f, t.rawData[7] = 0, t.rawData[8] = u + g, t.rawData[9] = c - f, t.rawData[10] = 1 - (o + n), t.rawData[11] = 0, t.rawData[12] = 0, t.rawData[13] = 0, t.rawData[14] = 0, t.rawData[15] = 1;
  }
  get magnitude() {
    return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
  }
  set(e = 0, t = 0, r = 0, i = 1) {
    this.x = e, this.y = t, this.z = r, this.w = i;
  }
  divide(e) {
    return e instanceof _H ? new _H(this.x / e.x, this.y / e.y, this.z / e.z) : (this.x = this.x / e, this.y = this.y / e, this.z = this.z / e, this);
  }
  setFromArray(e) {
    return this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3], this;
  }
  multiply(e, t) {
    var r = e.w, i = e.x, a = e.y, o = e.z, n = t.w, l = t.x, h = t.y, u = t.z;
    this.w = r * n - i * l - a * h - o * u, this.x = r * l + i * n + a * u - o * h, this.y = r * h - i * u + a * n + o * l, this.z = r * u + i * h - a * l + o * n;
  }
  multiplyVector(e, t = null) {
    t || (t = new _H());
    var r = e.x, i = e.y, a = e.z;
    return t.w = -this.x * r - this.y * i - this.z * a, t.x = this.w * r + this.y * a - this.z * i, t.y = this.w * i - this.x * a + this.z * r, t.z = this.w * a + this.x * i - this.y * r, t;
  }
  fromAxisAngle(e, t) {
    t *= Math.PI / 180;
    var r = t * 0.5, i = Math.sin(r);
    this.w = Math.cos(r), this.x = e.x * i, this.y = e.y * i, this.z = e.z * i, this.normalize();
  }
  toAxisAngle(e) {
    var t = this.x * this.x + this.y * this.y + this.z * this.z, r = 0;
    return t > 0 ? (r = 2 * Math.acos(this.w), t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t) : (r = 0, e.x = 1, e.y = 0, e.z = 0), r;
  }
  slerp(e, t, r) {
    var i = e.w, a = e.x, o = e.y, n = e.z, l = t.w, h = t.x, u = t.y, c = t.z, f = i * l + a * h + o * u + n * c;
    if (f < 0 && (f = -f, l = -l, h = -h, u = -u, c = -c), f < 0.95) {
      var g = Math.acos(f), m = 1 / Math.sin(g), A = Math.sin(g * (1 - r)) * m, _ = Math.sin(g * r) * m;
      this.w = i * A + l * _, this.x = a * A + h * _, this.y = o * A + u * _, this.z = n * A + c * _;
    } else {
      this.w = i + r * (l - i), this.x = a + r * (h - a), this.y = o + r * (u - o), this.z = n + r * (c - n);
      var x = 1 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
      this.w *= x, this.x *= x, this.y *= x, this.z *= x;
    }
  }
  lerp(e, t, r) {
    var i = e.w, a = e.x, o = e.y, n = e.z, l = t.w, h = t.x, u = t.y, c = t.z, f;
    i * l + a * h + o * u + n * c < 0 && (l = -l, h = -h, u = -u, c = -c), this.w = i + r * (l - i), this.x = a + r * (h - a), this.y = o + r * (u - o), this.z = n + r * (c - n), f = 1 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z), this.w *= f, this.x *= f, this.y *= f, this.z *= f;
  }
  fromEulerAngles(e, t, r) {
    e *= me, t *= me, r *= me;
    var i = e * 0.5, a = t * 0.5, o = r * 0.5, n = Math.cos(i), l = Math.sin(i), h = Math.cos(a), u = Math.sin(a), c = Math.cos(o), f = Math.sin(o);
    return this.w = n * h * c + l * u * f, this.x = l * h * c - n * u * f, this.y = n * u * c + l * h * f, this.z = n * h * f - l * u * c, this;
  }
  setFromRotationMatrix(e) {
    const t = e.rawData, r = t[0], i = t[4], a = t[8], o = t[1], n = t[5], l = t[9], h = t[2], u = t[6], c = t[10], f = r + n + c;
    if (f > 0) {
      const g = 0.5 / Math.sqrt(f + 1);
      this.w = 0.25 / g, this.x = (u - l) * g, this.y = (a - h) * g, this.z = (o - i) * g;
    } else if (r > n && r > c) {
      const g = 2 * Math.sqrt(1 + r - n - c);
      this.w = (u - l) / g, this.x = 0.25 * g, this.y = (i + o) / g, this.z = (a + h) / g;
    } else if (n > c) {
      const g = 2 * Math.sqrt(1 + n - r - c);
      this.w = (a - h) / g, this.x = (i + o) / g, this.y = 0.25 * g, this.z = (l + u) / g;
    } else {
      const g = 2 * Math.sqrt(1 + c - r - n);
      this.w = (o - i) / g, this.x = (a + h) / g, this.y = (l + u) / g, this.z = 0.25 * g;
    }
    return this;
  }
  getEulerAngles(e) {
    var t, r, i, a, o, n, l, h;
    return e || (e = new d()), a = this.x, o = this.y, n = this.z, l = this.w, h = 2 * (l * o - a * n), h <= -0.99999 ? (t = 2 * Math.atan2(a, l), r = -Math.PI / 2, i = 0) : h >= 0.99999 ? (t = 2 * Math.atan2(a, l), r = Math.PI / 2, i = 0) : (t = Math.atan2(2 * (l * a + o * n), 1 - 2 * (a * a + o * o)), r = Math.asin(h), i = Math.atan2(2 * (l * n + a * o), 1 - 2 * (o * o + n * n))), e.set(t, r, i).scaleBy(Yr);
  }
  normalize(e = 1) {
    var t = e / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    this.x *= t, this.y *= t, this.z *= t, this.w *= t;
  }
  toString() {
    return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
  }
  fromMatrix(e) {
    var t = e.decompose(Zt.QUATERNION)[1];
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  inverse(e = null) {
    e || (e = new _H());
    var t = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
    if (t > 0) {
      var r = 1 / t;
      e.w = this.w * r, e.x = -this.x * r, e.y = -this.y * r, e.z = -this.z * r;
    }
    return e;
  }
  clone() {
    return new _H(this.x, this.y, this.z, this.w);
  }
  transformVector(e, t = null) {
    var r, i, a, o, n = e.x, l = e.y, h = e.z;
    return t || (t = new d()), o = -this.x * n - this.y * l - this.z * h, r = this.w * n + this.y * h - this.z * l, i = this.w * l - this.x * h + this.z * n, a = this.w * h + this.x * l - this.y * n, t.x = -o * this.x + r * this.w - i * this.z + a * this.y, t.y = -o * this.y + r * this.z + i * this.w - a * this.x, t.z = -o * this.z - r * this.y + i * this.x + a * this.w, t;
  }
  copyFrom(e) {
    var t = this;
    return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, this;
  }
  mul(e, t, r) {
    let i = r || new _H();
    return i.x = e.w * t.x + e.x * t.w + e.y * t.z - e.z * t.y, i.y = e.w * t.y + e.y * t.w + e.z * t.x - e.x * t.z, i.z = e.w * t.z + e.z * t.w + e.x * t.y - e.y * t.x, i.w = e.w * t.w - e.x * t.x - e.y * t.y - e.z * t.z, i;
  }
  clampf(e, t, r) {
    if (t > r) {
      var i = t;
      t = r, r = i;
    }
    return e < t ? t : e < r ? e : r;
  }
  static serialize(e) {
    return new _H(e.x, e.y, e.z, e.w);
  }
};
__publicField(_H, "HELP_0", new _H(0, 0, 0, 1));
__publicField(_H, "HELP_1", new _H(0, 0, 0, 1));
__publicField(_H, "HELP_2", new _H(0, 0, 0, 1));
__publicField(_H, "_zero", new _H(0, 0, 0, 1));
__publicField(_H, "CALCULATION_QUATERNION", new _H());
var H = _H;
function zf(s, e, t) {
  let r = s.x * 2, i = s.y * 2, a = s.z * 2, o = s.x * r, n = s.y * i, l = s.z * a, h = s.x * i, u = s.x * a, c = s.y * a, f = s.w * r, g = s.w * i, m = s.w * a, A = t || new d();
  return A.x = (1 - (n + l)) * e.x + (h - m) * e.y + (u + g) * e.z, A.y = (h + m) * e.x + (1 - (o + l)) * e.y + (c - f) * e.z, A.z = (u - g) * e.x + (c + f) * e.y + (1 - (o + n)) * e.z, A;
}
var Wi = class _Wi {
  constructor(e = 0) {
    __publicField(this, "_x", 0);
    __publicField(this, "_y", 0);
    __publicField(this, "_z", 0);
    __publicField(this, "_w", 0);
    this.seed = e;
  }
  get seed() {
    return this._x;
  }
  set seed(e) {
    this._x = e, this._y = this._x * 1812433253 + 1, this._z = this._y * 1812433253 + 1, this._w = this._z * 1812433253 + 1;
  }
  static getFloatFromInt(e) {
    return Math.floor((e & 8388607) * (1 / 8388607));
  }
  static getByteFromInt(e) {
    return e >> 15;
  }
  clone() {
    let e = new _Wi();
    return e._x = this._x, e._y = this._y, e._z = this._z, e._w = this._w, e;
  }
  get() {
    let e = this._x ^ this._x << 11;
    return this._x = this._y, this._y = this._z, this._z = this._w, this._w = this._w ^ this._w >> 19 ^ (e ^ e >> 8);
  }
  getFloat() {
    return rl(this.get());
  }
  getSignedFloat() {
    return this.getFloat() * 2 - 1;
  }
};
var Yr = 180 / Math.PI;
var me = Math.PI / 180;
var kf = 2147483647;
var Gf = -2147483647;
function W(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
var Ze = class _Ze {
  static gaussFunction(e, t, r, i) {
    let a = Math.pow(e - r, 2), o = 2 * Math.pow(i, 2), n = -1 * (a / o), l = Math.pow(Math.E, n);
    return Math.round(l * t);
  }
  static computeGaussian(e, t) {
    return 1 / Math.sqrt(2 * Math.PI * t) * Math.exp(-(e * e) / (2 * t * t));
  }
  static gaussCoef(e) {
    e < 0.5 && (e = 0.5);
    let t = Math.exp(0.726 * 0.726) / e, r = Math.exp(-t), i = Math.exp(-2 * t), a = (1 - r) * (1 - r) / (1 + 2 * t * r - i), o = a, n = a * (t - 1) * r, l = a * (t + 1) * r, h = -a * i, u = 2 * r, c = -i, f = (o + n) / (1 - u - c), g = (l + h) / (1 - u - c);
    return new Float32Array([o, n, l, h, u, c, f, g]);
  }
  static clampf(e, t, r) {
    if (t > r) {
      let i = t;
      t = r, r = i;
    }
    return e < t ? t : e < r ? e : r;
  }
  static normalizeAngle(e) {
    for (; e > 180; )
      e -= 360;
    for (; e < -180; )
      e += 360;
    return e;
  }
  static fract(e) {
    return e - Math.floor(e);
  }
  static getRandDirXZ(e) {
    let t = e * Math.random(), r = 360 * Math.random() * me, i = Math.cos(r) * t, a = Math.sin(r) * t;
    return { x: i, z: a };
  }
  static getRandDirXYZ(e) {
    let t = e * Math.random(), r = 360 * Math.random() * me, i = Math.cos(r) * t, a = Math.tan(r) * t, o = Math.sin(r) * t;
    return new d(i, a, o);
  }
  static getCycleXYZ(e) {
    let t = e * Math.random(), r = 360 * Math.random() * me, i = Math.cos(r) * t, a = e * Math.random() - e * 0.5, o = Math.sin(r) * t;
    return new d(i, a, o);
  }
  static angle(e, t) {
    let r = Q.HELP_0, i = Q.HELP_1;
    return r.set(e.x, e.z), i.set(t.x, t.z), Math.acos((r.x * i.x + r.y * i.y) / (r.abs() * i.abs()));
  }
  static angle_360(e, t) {
    let r = d.HELP_0;
    return e.crossProduct(t, r), r.z > 0 ? _Ze.angle(e, t) : 360 - _Ze.angle(e, t);
  }
  getRotationY(e) {
    return _Ze.normalizeAngle(Math.atan2(e.z, e.x) * Yr);
  }
  static fromToRotation(e, t, r = null) {
    r || (r = new H());
    let i = P.help_matrix_2;
    return P.fromToRotation(e, t, i), r.fromMatrix(i), r;
  }
  static getEularDir_yUp(e) {
    let t = H.HELP_0;
    return t.fromEulerAngles(0, e, 0), t.transformVector(d.Z_AXIS, d.HELP_5), d.HELP_5;
  }
  static transformVector(e, t, r = null) {
    r || (r = new d());
    let i = e.rawData, a = i[0], o = i[1], n = i[2], l = i[3], h = i[4], u = i[5], c = i[6], f = i[7], g = i[8], m = i[9], A = i[10], _ = i[11], x = i[12], C = i[13], S = i[14], I = i[15], T = t.x, b = t.y, B = t.z;
    return r.x = a * T + h * b + g * B + x, r.y = o * T + u * b + m * B + C, r.z = n * T + c * b + A * B + S, r.w = l * T + f * b + _ * B + I, r;
  }
};
var Er = function(s, e, t) {
  return s * (1 - t) + e * t;
};
function Qf(s, e, t) {
  let r = new d(), i = s.x, a = s.y, o = s.z, n = s.w, l = e.x, h = e.y, u = e.z, c = e.w;
  return r.x = (l - i) * t + i, r.y = (h - a) * t + a, r.z = (u - o) * t + o, r.w = (c - n) * t + n, r;
}
function Vf(s, e, t) {
  let r = new M();
  return r.r = (1 - t) * s.r + t * e.r, r.g = (1 - t) * s.g + t * e.g, r.b = (1 - t) * s.b + t * e.b, r.a = (1 - t) * s.a + t * e.a, r;
}
function Hf(s, e, t) {
  return s + ((e - s) * t >> 8) & 255;
}
var Rs = function(s, e, t) {
  let r = t - e;
  return Math.floor(s / r) % 2 == 0 ? s % r + e : t - s % r + e;
};
var Us = function(s, e, t) {
  let r = t - e;
  return s % r + e;
};
var Yf = function(s, e) {
  let t = 0;
  for (let r in s)
    r == e && t++;
  return t;
};
var Xf = class {
  constructor() {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "w", 0);
    __publicField(this, "randSeedList");
    this.randSeedList = [];
  }
  reset() {
    this.x = Math.random() * 1, this.y = Math.random() * 1, this.z = Math.random() * 1, this.w = Math.random() * 1, this.randSeedList.length = 0;
    for (let e = 0; e < 20; e++)
      this.randSeedList.push(Math.random() * 1);
  }
};
function Ye(s, e) {
  return s instanceof d && e instanceof d || s instanceof H && e instanceof H ? s.x * e.x + s.y * e.y + s.z * e.z : s.x * e.x + s.y * e.y;
}
function Ls(s, e) {
  return new d(s.x * e.x, s.y * e.y, s.z * e.z);
}
function el(s) {
  return Math.sqrt(s);
}
function Os(s) {
  return el(Ye(s, s));
}
function tl(s, e) {
  if (Os(s) > d.EPSILON)
    return s.divide(Os(s));
  if (s instanceof Q)
    return new Q();
  if (s instanceof d)
    return new d();
  if (s instanceof H)
    return new H();
}
function rl(s) {
  return (s & 8388607) * (1 / 8388607);
}
function Xr(s) {
  return s.getFloat();
}
function ke(s, e, t) {
  let r = s.getFloat();
  return r = e * r + (1 - r) * t, r;
}
function Wf(s, e, t) {
  let r;
  if (e < t) {
    r = t - e;
    let i = s.get() % r;
    return i += e, i;
  } else if (e > t) {
    r = e - t;
    let i = s.get() % r;
    return i = e - i, i;
  } else
    return e;
}
function ca(s) {
  let e = ke(s, -1, 1), t = ke(s, 0, 2 * Math.PI), r = Math.sqrt(1 - e * e), i = r * Math.cos(t), a = r * Math.sin(t);
  return new d(i, a, e);
}
function il(s) {
  let e = ke(s, 0, 2 * Math.PI), t = Math.cos(e), r = Math.sin(e);
  return new Q(t, r);
}
function jf(s) {
  let e = new H();
  return e.x = ke(s, -1, 1), e.y = ke(s, -1, 1), e.z = ke(s, -1, 1), e.w = ke(s, -1, 1), e = tl(e), Ye(e, H.identity()) < 0 ? -e : e;
}
function qf(s) {
  const e = 2 * Math.PI;
  let t = ke(s, 0, 1), r = ke(s, 0, e), i = ke(s, 0, e), a = Math.sqrt(1 - t), o = Math.sqrt(t), n = new H(a * Math.sin(r), a * Math.cos(r), o * Math.sin(i), o * Math.cos(i));
  return Ye(n, H.identity()) < 0 ? -n : n;
}
function Kf(s, e) {
  return new d(ke(s, -e.x, e.x), ke(s, -e.y, e.y), ke(s, -e.z, e.z));
}
function al(s) {
  let e = ca(s);
  return e.scaleBy(Math.pow(Xr(s), 1 / 3)), e;
}
function Jf(s, e) {
  return Ls(al(s), e);
}
function Zf(s, e, t) {
  let r = ca(s), i = Math.pow(ke(s, 0, 1), 1 / 3);
  return r.scaleBy(e + (t - e) * i), r;
}
function $f(s) {
  let e = il(s);
  return e.multiply(Math.pow(ke(s, 0, 1), 1 / 2), e), e;
}
function ed(s, e, t) {
  let r = Ls(ca(s), e), i = Math.pow(ke(s, t, 1), 1 / 3);
  return r.scaleBy(i), r;
}
function td(s) {
  let e = s.getFloat(), t = s.getFloat();
  e + t > 1 && (e = 1 - e, t = 1 - t);
  let r = 1 - e - t;
  return new d(e, t, r);
}
function rd(s) {
  return s / 360 * 2 * Math.PI;
}
function id(s) {
  return 180 * s / Math.PI;
}
function ad(s) {
  return Math.sin(s);
}
function sd(s) {
  return Math.cos(s);
}
var sl = 4919;
function od() {
  return ++sl;
}
function nd(s, e, t) {
  let r = s[e], i = s[t];
  s[e] = i, s[t] = r;
}
function ol(s) {
  return Math.floor(s);
}
function Fs(s) {
  return ol(s + 0.5);
}
function ld(s) {
  return s = Math.max(s, 0), s = Math.min(s, 1), Fs(s * 65535);
}
function hd(s) {
  return s = Math.max(s, 0), s = Math.min(s, 1), Fs(s * 255);
}
function nl(s) {
  return Math.abs(s) == 0 ? s : 1 / Math.sqrt(s);
}
function ud(s) {
  let e = Ns(s);
  return s.scaleBy(nl(e));
}
function cd(s, e) {
  return s.crossProduct(e);
}
function Ns(s) {
  return Ye(s, s);
}
function fd(s) {
  let e = new Wi(s);
  return Xr(e);
}
function dd(s, e) {
  let t = new Wi(e);
  s.x = Xr(t), s.y = Xr(t), s.z = Xr(t);
}
function gd(s, e, t) {
  return s < e ? t : s > t ? e : s;
}
function zs(s, e) {
  return s - Math.floor(s / e) * e;
}
var pd = 1e-6;
var _P = class _P {
  constructor(e = false) {
    __publicField(this, "index", 0);
    __publicField(this, "offset", 0);
    __publicField(this, "rawData");
    __publicField(this, "_position");
    if (_P.useCount >= _P.allocCount) {
      let t = _P.allocCount + _P.allocOnceCount;
      ee.allocMatrix(t);
    }
    this.index = _P.useCount, this.offset = _P.wasmMatrixPtr + this.index * _P.blockBytes, _P.dynamicGlobalMatrixRef[this.index] = this, _P.useCount++, this.rawData = new Float32Array(_P.dynamicMatrixBytes.buffer, this.offset, 16), this._position = new d(), this.identity();
  }
  static allocMatrix(e) {
    this.allocCount = e, _P.dynamicMatrixBytes = ee.matrixBuffer, _P.buffer = _P.dynamicMatrixBytes.buffer, _P.wasmMatrixPtr = ee.matrixBufferPtr, this.dynamicGlobalMatrixRef || (this.dynamicGlobalMatrixRef = []), this.dynamicGlobalMatrixRef.forEach((t) => {
      t.offset = _P.wasmMatrixPtr + t.index * _P.blockBytes, t.rawData = new Float32Array(_P.dynamicMatrixBytes.buffer, t.offset, 16);
    }), _P.help_matrix_0 || (_P.help_matrix_0 = new _P()), _P.help_matrix_1 || (_P.help_matrix_1 = new _P()), _P.help_matrix_2 || (_P.help_matrix_2 = new _P()), _P.helpMatrix || (_P.helpMatrix = new _P()), _P.helpMatrix2 || (_P.helpMatrix2 = new _P()), _P._getEulerMatrix || (_P._getEulerMatrix = new _P()), _P._getEulerMatrix.identity();
  }
  static fromToRotation(e, t, r) {
    return r || (r = new _P()), r.transformDir(e, t), r;
  }
  static getAxisRotation(e, t, r, i) {
    let a = new _P(), o = i * (Math.PI / 180), n = Math.cos(o), l = Math.sin(o), h = 1 - n, u, c;
    return a.rawData[0] = n + e * e * h, a.rawData[5] = n + t * t * h, a.rawData[10] = n + r * r * h, u = e * t * h, c = r * l, a.rawData[1] = u + c, a.rawData[4] = u - c, u = e * r * h, c = t * l, a.rawData[8] = u + c, a.rawData[2] = u - c, u = t * r * h, c = e * l, a.rawData[9] = u - c, a.rawData[6] = u + c, a;
  }
  static sanitizeEuler(e) {
    _P.makePositive(e);
  }
  static makePositive(e) {
    let t = -1e-4, r = Math.PI * 2 - 1e-4;
    e.x < t ? e.x += 2 * Math.PI : e.x > r && (e.x -= 2 * Math.PI), e.y < t ? e.y += 2 * Math.PI : e.y > r && (e.y -= 2 * Math.PI), e.z < t ? e.z += 2 * Math.PI : e.z > r && (e.z -= 2 * Math.PI);
  }
  static matrixToEuler(e, t) {
    return e.get(1, 2) < 0.999 ? e.get(1, 2) > -0.999 ? (t.x = Math.asin(-e.get(1, 2)), t.y = Math.atan2(e.get(0, 2), e.get(2, 2)), t.z = Math.atan2(e.get(1, 0), e.get(1, 1)), _P.sanitizeEuler(t), true) : (t.x = Math.PI * 0.5, t.y = Math.atan2(e.get(0, 1), e.get(0, 0)), t.z = 0, _P.sanitizeEuler(t), false) : (t.x = -Math.PI * 0.5, t.y = Math.atan2(-e.get(0, 1), e.get(0, 0)), t.z = 0, _P.sanitizeEuler(t), false);
  }
  static matrixMultiply(e, t, r) {
    _P.wasm.Matrix_Multiply(e.index, t.index, r.index);
  }
  static matrixAppend(e, t, r) {
    _P.wasm.Matrix_Append(e.index, t.index, r.index);
  }
  static matrixRotateY(e, t) {
    _P.wasm.Matrix_Append(e, t.index);
  }
  static matrixRotate(e, t, r) {
    _P.wasm.Matrix_Rotate(e, t, r.index);
  }
  lookAt(e, t, r = d.Y_AXIS) {
    let i = this.rawData, a = t.subtract(e, d.HELP_0);
    a.length < 1e-4 && (a.z = 1), a.normalize();
    let o = r.crossProduct(a, d.HELP_1);
    o.length < 1e-4 && (Math.abs(r.z) > 0.9999 ? a.x += 1e-4 : a.z += 1e-4, a.normalize()), o = r.crossProduct(a, o).normalize();
    let n = a.crossProduct(o, d.HELP_2).normalize();
    i[0] = o.x, i[1] = n.x, i[2] = a.x, i[3] = 0, i[4] = o.y, i[5] = n.y, i[6] = a.y, i[7] = 0, i[8] = o.z, i[9] = n.z, i[10] = a.z, i[11] = 0, i[12] = -o.dotProduct(e), i[13] = -n.dotProduct(e), i[14] = -a.dotProduct(e), i[15] = 1;
  }
  multiply(e) {
    let t = this.rawData, r = e.rawData, i = _P.float32Array;
    i[0] = t[0] * r[0] + t[1] * r[4] + t[2] * r[8] + t[3] * r[12], i[1] = t[0] * r[1] + t[1] * r[5] + t[2] * r[9] + t[3] * r[13], i[2] = t[0] * r[2] + t[1] * r[6] + t[2] * r[10] + t[3] * r[14], i[3] = t[0] * r[3] + t[1] * r[7] + t[2] * r[11] + t[3] * r[15], i[4] = t[4] * r[0] + t[5] * r[4] + t[6] * r[8] + t[7] * r[12], i[5] = t[4] * r[1] + t[5] * r[5] + t[6] * r[9] + t[7] * r[13], i[6] = t[4] * r[2] + t[5] * r[6] + t[6] * r[10] + t[7] * r[14], i[7] = t[4] * r[3] + t[5] * r[7] + t[6] * r[11] + t[7] * r[15], i[8] = t[8] * r[0] + t[9] * r[4] + t[10] * r[8] + t[11] * r[12], i[9] = t[8] * r[1] + t[9] * r[5] + t[10] * r[9] + t[11] * r[13], i[10] = t[8] * r[2] + t[9] * r[6] + t[10] * r[10] + t[11] * r[14], i[11] = t[8] * r[3] + t[9] * r[7] + t[10] * r[11] + t[11] * r[15], i[12] = t[12] * r[0] + t[13] * r[4] + t[14] * r[8] + t[15] * r[12], i[13] = t[12] * r[1] + t[13] * r[5] + t[14] * r[9] + t[15] * r[13], i[14] = t[12] * r[2] + t[13] * r[6] + t[14] * r[10] + t[15] * r[14], i[15] = t[12] * r[3] + t[13] * r[7] + t[14] * r[11] + t[15] * r[15], t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15];
  }
  multiplyMatrices(e, t) {
    const r = e.rawData, i = t.rawData, a = this.rawData, o = r[0], n = r[4], l = r[8], h = r[12], u = r[1], c = r[5], f = r[9], g = r[13], m = r[2], A = r[6], _ = r[10], x = r[14], C = r[3], S = r[7], I = r[11], T = r[15], b = i[0], B = i[4], R = i[8], E = i[12], F = i[1], k = i[5], V = i[9], j = i[13], te = i[2], pe = i[6], ne = i[10], we = i[14], Oe = i[3], se = i[7], Be = i[11], le = i[15];
    return a[0] = o * b + n * F + l * te + h * Oe, a[4] = o * B + n * k + l * pe + h * se, a[8] = o * R + n * V + l * ne + h * Be, a[12] = o * E + n * j + l * we + h * le, a[1] = u * b + c * F + f * te + g * Oe, a[5] = u * B + c * k + f * pe + g * se, a[9] = u * R + c * V + f * ne + g * Be, a[13] = u * E + c * j + f * we + g * le, a[2] = m * b + A * F + _ * te + x * Oe, a[6] = m * B + A * k + _ * pe + x * se, a[10] = m * R + A * V + _ * ne + x * Be, a[14] = m * E + A * j + _ * we + x * le, a[3] = C * b + S * F + I * te + T * Oe, a[7] = C * B + S * k + I * pe + T * se, a[11] = C * R + S * V + I * ne + T * Be, a[15] = C * E + S * j + I * we + T * le, this;
  }
  multiplyPoint3(e, t) {
    t || (t = new d());
    let r = this.rawData;
    return t.x = r[0] * e.x + r[4] * e.y + r[8] * e.z + r[12], t.y = r[1] * e.x + r[5] * e.y + r[9] * e.z + r[13], t.z = r[2] * e.x + r[6] * e.y + r[10] * e.z + r[14], t;
  }
  multiplyVector4(e, t) {
    t || (t = new d());
    let r = this.rawData, i = e.x, a = e.y, o = e.z, n = r[3] * i + r[7] * a + r[11] * o + r[15];
    return n = n || 1, t.x = (r[0] * i + r[4] * a + r[8] * o + r[12]) / n, t.y = (r[1] * i + r[5] * a + r[9] * o + r[13]) / n, t.z = (r[2] * i + r[6] * a + r[10] * o + r[14]) / n, t.w = 1, t;
  }
  transformVector4(e, t) {
    let r = this.rawData;
    t || (t = new d());
    let i = e.x, a = e.y, o = e.z, n = e.w;
    return t.x = i * r[0] + a * r[4] + o * r[8] + n * r[12], t.y = i * r[1] + a * r[5] + o * r[9] + n * r[13], t.z = i * r[2] + a * r[6] + o * r[10] + n * r[14], t.w = i * r[3] + a * r[7] + o * r[11] + n * r[15], t;
  }
  perspectiveMultiplyPoint3(e, t) {
    let r = d.HELP_2, i, a = this.rawData;
    if (r.x = a[0] * e.x + a[4] * e.y + a[8] * e.z + a[12], r.y = a[1] * e.x + a[5] * e.y + a[9] * e.z + a[13], r.z = a[2] * e.x + a[6] * e.y + a[10] * e.z + a[14], i = a[3] * e.x + a[7] * e.y + a[11] * e.z + a[15], Math.abs(i) > 1e-7) {
      let o = 1 / i;
      return t.x = r.x * o, t.y = r.y * o, t.z = r.z * o, true;
    } else
      return t.x = 0, t.y = 0, t.z = 0, false;
  }
  perspective(e, t, r, i) {
    let a = this.rawData, o = e * me / 2, n = Math.cos(o) / Math.sin(o);
    a[0] = -n / t, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = n, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = i / (i - r), a[11] = 1, a[12] = 0, a[13] = 0, a[14] = -r * i / (i - r), a[15] = 0;
  }
  perspective3(e, t, r, i) {
    var a = Math.tan(e * Math.PI / 360) * r, o = a * t;
    this.frustum(-o, o, -a, a, r, i);
  }
  frustum(e, t, r, i, a, o) {
    var n = this.rawData;
    n[0] = -2 * a / (t - e), n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 2 * a / (i - r), n[6] = 0, n[7] = 0, n[8] = (t + e) / (t - e), n[9] = (i + r) / (i - r), n[10] = o / (o - a), n[11] = 1, n[12] = 0, n[13] = 0, n[14] = -o * a / (o - a), n[15] = 0;
  }
  ortho(e, t, r, i) {
    let a = this.rawData;
    return a[0] = 2 / e, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 / t, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1 / (i - r), a[11] = 0, a[12] = 0, a[13] = 0, a[14] = r / (r - i), a[15] = 1, this;
  }
  orthoZO(e, t, r, i, a, o) {
    let n = this.rawData, l = 1 / (e - t), h = 1 / (r - i), u = 1 / (a - o);
    return n[0] = -2 * l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * h, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = u, n[11] = 0, n[12] = (e + t) * l, n[13] = (i + r) * h, n[14] = a * u, n[15] = 1, this;
  }
  orthoOffCenter(e, t, r, i, a, o) {
    let n = this.rawData;
    n[0] = 2 / (t - e), n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 2 / (i - r), n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1 / (o - a), n[11] = 0, n[12] = (e + t) / (e - t), n[13] = (i + r) / (r - i), n[14] = a / (a - o), n[15] = 1;
  }
  transformDir(e, t) {
    let r = this.rawData, i = 1e-6, a = d.ZERO;
    t.crossProduct(e, a);
    let o = t.dotProduct(e);
    if (o > 1 - i)
      this.identity();
    else {
      let n, l, h, u, c, f = a.dotProduct(a), g = (1 - o) / f;
      n = g * a.x, l = g * a.z, h = n * a.y, u = n * a.z, c = l * a.y, r[0] = o + n * a.x, r[1] = h - a.z, r[2] = u + a.y, r[4] = h + a.z, r[5] = o + g * a.y * a.y, r[6] = c - a.x, r[8] = u - a.y, r[9] = c + a.x, r[10] = o + l * a.z, r[3] = 0, r[7] = 0, r[11] = 0, r[15] = 1;
    }
  }
  append(e) {
    let t = this.rawData, r = t[0], i = t[4], a = t[8], o = t[12], n = t[1], l = t[5], h = t[9], u = t[13], c = t[2], f = t[6], g = t[10], m = t[14], A = t[3], _ = t[7], x = t[11], C = t[15];
    t[0] = r * e.rawData[0] + n * e.rawData[4] + c * e.rawData[8] + A * e.rawData[12], t[1] = r * e.rawData[1] + n * e.rawData[5] + c * e.rawData[9] + A * e.rawData[13], t[2] = r * e.rawData[2] + n * e.rawData[6] + c * e.rawData[10] + A * e.rawData[14], t[3] = r * e.rawData[3] + n * e.rawData[7] + c * e.rawData[11] + A * e.rawData[15], t[4] = i * e.rawData[0] + l * e.rawData[4] + f * e.rawData[8] + _ * e.rawData[12], t[5] = i * e.rawData[1] + l * e.rawData[5] + f * e.rawData[9] + _ * e.rawData[13], t[6] = i * e.rawData[2] + l * e.rawData[6] + f * e.rawData[10] + _ * e.rawData[14], t[7] = i * e.rawData[3] + l * e.rawData[7] + f * e.rawData[11] + _ * e.rawData[15], t[8] = a * e.rawData[0] + h * e.rawData[4] + g * e.rawData[8] + x * e.rawData[12], t[9] = a * e.rawData[1] + h * e.rawData[5] + g * e.rawData[9] + x * e.rawData[13], t[10] = a * e.rawData[2] + h * e.rawData[6] + g * e.rawData[10] + x * e.rawData[14], t[11] = a * e.rawData[3] + h * e.rawData[7] + g * e.rawData[11] + x * e.rawData[15], t[12] = o * e.rawData[0] + u * e.rawData[4] + m * e.rawData[8] + C * e.rawData[12], t[13] = o * e.rawData[1] + u * e.rawData[5] + m * e.rawData[9] + C * e.rawData[13], t[14] = o * e.rawData[2] + u * e.rawData[6] + m * e.rawData[10] + C * e.rawData[14], t[15] = o * e.rawData[3] + u * e.rawData[7] + m * e.rawData[11] + C * e.rawData[15];
  }
  add(e) {
    let t = this.rawData, r = t[0], i = t[4], a = t[8], o = t[12], n = t[1], l = t[5], h = t[9], u = t[13], c = t[2], f = t[6], g = t[10], m = t[14], A = t[3], _ = t[7], x = t[11], C = t[15], S = e.rawData[0], I = e.rawData[4], T = e.rawData[8], b = e.rawData[12], B = e.rawData[1], R = e.rawData[5], E = e.rawData[9], F = e.rawData[13], k = e.rawData[2], V = e.rawData[6], j = e.rawData[10], te = e.rawData[14], pe = e.rawData[3], ne = e.rawData[7], we = e.rawData[11], Oe = e.rawData[15];
    return t[0] = r + S, t[1] = n + B, t[2] = c + k, t[3] = A + pe, t[4] = i + I, t[5] = l + R, t[6] = f + V, t[7] = _ + ne, t[8] = a + T, t[9] = h + E, t[10] = g + j, t[11] = x + we, t[12] = o + b, t[13] = u + F, t[14] = m + te, t[15] = C + Oe, this;
  }
  sub(e) {
    let t = this.rawData, r = t[0], i = t[4], a = t[8], o = t[12], n = t[1], l = t[5], h = t[9], u = t[13], c = t[2], f = t[6], g = t[10], m = t[14], A = t[3], _ = t[7], x = t[11], C = t[15], S = e.rawData[0], I = e.rawData[4], T = e.rawData[8], b = e.rawData[12], B = e.rawData[1], R = e.rawData[5], E = e.rawData[9], F = e.rawData[13], k = e.rawData[2], V = e.rawData[6], j = e.rawData[10], te = e.rawData[14], pe = e.rawData[3], ne = e.rawData[7], we = e.rawData[11], Oe = e.rawData[15];
    return t[0] = r - S, t[1] = n - B, t[2] = c - k, t[3] = A - pe, t[4] = i - I, t[5] = l - R, t[6] = f - V, t[7] = _ - ne, t[8] = a - T, t[9] = h - E, t[10] = g - j, t[11] = x - we, t[12] = o - b, t[13] = u - F, t[14] = m - te, t[15] = C - Oe, this;
  }
  mult(e) {
    let t = this.rawData;
    return t[0] *= e, t[1] *= e, t[2] *= e, t[3] *= e, t[4] *= e, t[5] *= e, t[6] *= e, t[7] *= e, t[8] *= e, t[9] *= e, t[10] *= e, t[11] *= e, t[12] *= e, t[13] *= e, t[14] *= e, t[15] *= e, this;
  }
  appendRotation(e, t) {
    let r = _P.getAxisRotation(t.x, t.y, t.z, e);
    this.append(r);
  }
  createByRotation(e, t) {
    let r = _P.helpMatrix, i, a, o = e * me;
    return i = Math.sin(o), a = Math.cos(o), t.x == 1 && (r.rawData[0] = 1, r.rawData[1] = 0, r.rawData[2] = 0, r.rawData[3] = 0, r.rawData[4] = 0, r.rawData[5] = a, r.rawData[6] = i, r.rawData[7] = 0, r.rawData[8] = 0, r.rawData[9] = -i, r.rawData[10] = a, r.rawData[11] = 0, r.rawData[12] = 0, r.rawData[13] = 0, r.rawData[14] = 0, r.rawData[15] = 1), t.y == 1 && (r.rawData[0] = a, r.rawData[1] = 0, r.rawData[2] = -i, r.rawData[3] = 0, r.rawData[4] = 0, r.rawData[5] = 1, r.rawData[6] = 0, r.rawData[7] = 0, r.rawData[8] = i, r.rawData[9] = 0, r.rawData[10] = a, r.rawData[11] = 0, r.rawData[12] = 0, r.rawData[13] = 0, r.rawData[14] = 0, r.rawData[15] = 1), t.z == 1 && (r.rawData[0] = a, r.rawData[1] = i, r.rawData[2] = 0, r.rawData[3] = 0, r.rawData[4] = -i, r.rawData[5] = a, r.rawData[6] = 0, r.rawData[7] = 0, r.rawData[8] = 0, r.rawData[9] = 0, r.rawData[10] = 1, r.rawData[11] = 0, r.rawData[12] = 0, r.rawData[13] = 0, r.rawData[14] = 0, r.rawData[15] = 1), this.append(r), this;
  }
  appendScale(e, t, r) {
    _P.helpMatrix.createByScale(e, t, r), this.append(_P.helpMatrix);
  }
  createByScale(e, t, r) {
    let i = this.rawData;
    i[0] = e, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = r, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1;
  }
  appendTranslation(e, t, r) {
    let i = this.rawData;
    i[12] += e, i[13] += t, i[14] += r;
  }
  clone() {
    let e = new _P();
    return e.copyFrom(this), e;
  }
  copyRowFrom(e, t) {
    let r = this.rawData;
    switch (e) {
      case 0:
        r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = t.w;
        break;
      case 1:
        r[4] = t.x, r[5] = t.y, r[6] = t.z, r[7] = t.w;
        break;
      case 2:
        r[8] = t.x, r[9] = t.y, r[10] = t.z, r[11] = t.w;
        break;
      case 3:
        r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = t.w;
        break;
    }
  }
  copyRowTo(e, t) {
    let r = this.rawData;
    switch (e) {
      case 0:
        t.x = r[0], t.y = r[1], t.z = r[2], t.w = r[3];
        break;
      case 1:
        t.x = r[4], t.y = r[5], t.z = r[6], t.w = r[7];
        break;
      case 2:
        t.x = r[8], t.y = r[9], t.z = r[10], t.w = r[11];
        break;
      case 3:
        t.x = r[12], t.y = r[13], t.z = r[14], t.w = r[15];
        break;
    }
  }
  copyFrom(e) {
    let t = this.rawData;
    return t[0] = e.rawData[0], t[1] = e.rawData[1], t[2] = e.rawData[2], t[3] = e.rawData[3], t[4] = e.rawData[4], t[5] = e.rawData[5], t[6] = e.rawData[6], t[7] = e.rawData[7], t[8] = e.rawData[8], t[9] = e.rawData[9], t[10] = e.rawData[10], t[11] = e.rawData[11], t[12] = e.rawData[12], t[13] = e.rawData[13], t[14] = e.rawData[14], t[15] = e.rawData[15], this;
  }
  copyRawDataTo(e, t = 0, r = false) {
    let i = this.rawData;
    e[0 + t] = i[0], e[1 + t] = i[1], e[2 + t] = i[2], e[3 + t] = i[3], e[4 + t] = i[4], e[5 + t] = i[5], e[6 + t] = i[6], e[7 + t] = i[7], e[8 + t] = i[8], e[9 + t] = i[9], e[10 + t] = i[10], e[11 + t] = i[11], e[12 + t] = i[12], e[13 + t] = i[13], e[14 + t] = i[14], e[15 + t] = i[15];
  }
  copyColFrom(e, t) {
    let r = this.rawData;
    switch (e) {
      case 0:
        r[0] = t.x, r[4] = t.y, r[8] = t.z, r[12] = t.w;
        break;
      case 1:
        r[1] = t.x, r[5] = t.y, r[9] = t.z, r[13] = t.w;
        break;
      case 2:
        r[2] = t.x, r[6] = t.y, r[10] = t.z, r[14] = t.w;
        break;
      case 3:
        r[3] = t.x, r[7] = t.y, r[11] = t.z, r[15] = t.w;
        break;
    }
  }
  copyColTo(e, t) {
    let r = this.rawData;
    switch (e) {
      case 0:
        t.x = r[0], t.y = r[4], t.z = r[8], t.w = r[12];
        break;
      case 1:
        t.x = r[1], t.y = r[5], t.z = r[9], t.w = r[13];
        break;
      case 2:
        t.x = r[2], t.y = r[6], t.z = r[10], t.w = r[14];
        break;
      case 3:
        t.x = r[3], t.y = r[7], t.z = r[11], t.w = r[15];
        break;
    }
  }
  copyToMatrix3D(e) {
    e.rawData = this.rawData.slice(0);
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_P._zero, e, _P._one), this;
  }
  decompose(e = "eulerAngles", t) {
    let r = H.CALCULATION_QUATERNION, i = t || _P._prs;
    this.copyRawDataTo(_P.decomposeRawData);
    let a = _P.decomposeRawData, o = i[0];
    o.x = a[12], o.y = a[13], o.z = a[14], a[12] = 0, a[13] = 0, a[14] = 0;
    let n = i[2];
    n.x = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]), n.y = Math.sqrt(a[4] * a[4] + a[5] * a[5] + a[6] * a[6]), n.z = Math.sqrt(a[8] * a[8] + a[9] * a[9] + a[10] * a[10]), a[0] * (a[5] * a[10] - a[6] * a[9]) - a[1] * (a[4] * a[10] - a[6] * a[8]) + a[2] * (a[4] * a[9] - a[5] * a[8]) < 0 && (n.z = -n.z), a[0] /= n.x, a[1] /= n.x, a[2] /= n.x, a[4] /= n.y, a[5] /= n.y, a[6] /= n.y, a[8] /= n.z, a[9] /= n.z, a[10] /= n.z;
    let l = i[1], h;
    switch (e) {
      case Zt.AXIS_ANGLE:
        l.w = Math.acos((a[0] + a[5] + a[10] - 1) / 2);
        let u = Math.sqrt((a[6] - a[9]) * (a[6] - a[9]) + (a[8] - a[2]) * (a[8] - a[2]) + (a[1] - a[4]) * (a[1] - a[4]));
        l.x = (a[6] - a[9]) / u, l.y = (a[8] - a[2]) / u, l.z = (a[1] - a[4]) / u;
        break;
      case Zt.QUATERNION:
        h = a[0] + a[5] + a[10], h > 0 ? (l.w = Math.sqrt(1 + h) / 2, l.x = (a[6] - a[9]) / (4 * l.w), l.y = (a[8] - a[2]) / (4 * l.w), l.z = (a[1] - a[4]) / (4 * l.w)) : a[0] > a[5] && a[0] > a[10] ? (l.x = Math.sqrt(1 + a[0] - a[5] - a[10]) / 2, l.w = (a[6] - a[9]) / (4 * l.x), l.y = (a[1] + a[4]) / (4 * l.x), l.z = (a[8] + a[2]) / (4 * l.x)) : a[5] > a[10] ? (l.y = Math.sqrt(1 + a[5] - a[0] - a[10]) / 2, l.x = (a[1] + a[4]) / (4 * l.y), l.w = (a[8] - a[2]) / (4 * l.y), l.z = (a[6] + a[9]) / (4 * l.y)) : (l.z = Math.sqrt(1 + a[10] - a[0] - a[5]) / 2, l.x = (a[8] + a[2]) / (4 * l.z), l.y = (a[6] + a[9]) / (4 * l.z), l.w = (a[1] - a[4]) / (4 * l.z));
        break;
      case Zt.EULER_ANGLES:
        h = a[0] + a[5] + a[10], h > 0 ? (r.w = Math.sqrt(1 + h) / 2, r.x = (a[6] - a[9]) / (4 * r.w), r.y = (a[8] - a[2]) / (4 * r.w), r.z = (a[1] - a[4]) / (4 * r.w)) : a[0] > a[5] && a[0] > a[10] ? (r.x = Math.sqrt(1 + a[0] - a[5] - a[10]) / 2, r.w = (a[6] - a[9]) / (4 * r.x), r.y = (a[1] + a[4]) / (4 * r.x), r.z = (a[8] + a[2]) / (4 * r.x)) : a[5] > a[10] ? (l.y = Math.sqrt(1 + a[5] - a[0] - a[10]) / 2, r.x = (a[1] + a[4]) / (4 * r.y), r.w = (a[8] - a[2]) / (4 * r.y), r.z = (a[6] + a[9]) / (4 * r.y)) : (r.z = Math.sqrt(1 + a[10] - a[0] - a[5]) / 2, r.x = (a[8] + a[2]) / (4 * r.z), r.y = (a[6] + a[9]) / (4 * r.z), r.w = (a[1] - a[4]) / (4 * r.z)), r.getEulerAngles(l);
        break;
    }
    return i[0] = o, i[1] = l, i[2] = n, i;
  }
  static getEuler(e, t, r = true, i) {
    return e || (e = new d()), _P._getEulerMatrix.makeRotationFromQuaternion(t).makeEuler(e, r, i), e;
  }
  compose(e, t, r) {
    const i = this.rawData, a = t.x, o = t.y, n = t.z, l = t.w, h = a + a, u = o + o, c = n + n, f = a * h, g = a * u, m = a * c, A = o * u, _ = o * c, x = n * c, C = l * h, S = l * u, I = l * c, T = r.x, b = r.y, B = r.z;
    return i[0] = (1 - (A + x)) * T, i[1] = (g + I) * T, i[2] = (m - S) * T, i[3] = 0, i[4] = (g - I) * b, i[5] = (1 - (f + x)) * b, i[6] = (_ + C) * b, i[7] = 0, i[8] = (m + S) * B, i[9] = (_ - C) * B, i[10] = (1 - (f + A)) * B, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  deltaTransformVector(e, t) {
    t || (t = new d());
    let r = this.rawData, i = e.x, a = e.y, o = e.z;
    return t.x = i * r[0] + a * r[4] + o * r[8], t.y = i * r[1] + a * r[5] + o * r[9], t.z = i * r[2] + a * r[6] + o * r[10], t.w = i * r[3] + a * r[7] + o * r[11], t;
  }
  identity() {
    let e = this.rawData;
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  fill(e) {
    let t = this.rawData;
    t[1] = e, t[2] = e, t[3] = e, t[4] = e, t[6] = e, t[7] = e, t[8] = e, t[9] = e, t[11] = e, t[12] = e, t[13] = e, t[14] = e, t[0] = e, t[5] = e, t[10] = e, t[15] = e;
  }
  invers33() {
    let e = this.rawData, t = e[5] * e[10] - e[9] * e[6], r = e[8] * e[6] - e[4] * e[10], i = e[4] * e[9] - e[8] * e[5], a = e[9] * e[2] - e[1] * e[10], o = e[0] * e[10] - e[8] * e[2], n = e[8] * e[1] - e[0] * e[9], l = e[1] * e[6] - e[5] * e[2], h = e[4] * e[2] - e[0] * e[6], u = e[0] * e[5] - e[4] * e[1], c = e[0] * t + e[4] * a + e[8] * l;
    if (Math.abs(c) > 1e-11) {
      let f = 1 / c;
      e[0] = f * t, e[4] = f * r, e[8] = f * i, e[1] = f * a, e[5] = f * o, e[9] = f * n, e[2] = f * l, e[6] = f * h, e[10] = f * u;
    }
  }
  invert() {
    let e = this.determinant, t = Math.abs(e) > 1e-11, r = this.rawData;
    if (t) {
      e = 1 / e;
      let i = r[0], a = r[4], o = r[8], n = r[12], l = r[1], h = r[5], u = r[9], c = r[13], f = r[2], g = r[6], m = r[10], A = r[14], _ = r[3], x = r[7], C = r[11], S = r[15];
      r[0] = e * (h * (m * S - A * C) - u * (g * S - A * x) + c * (g * C - m * x)), r[1] = -e * (l * (m * S - A * C) - u * (f * S - A * _) + c * (f * C - m * _)), r[2] = e * (l * (g * S - A * x) - h * (f * S - A * _) + c * (f * x - g * _)), r[3] = -e * (l * (g * C - m * x) - h * (f * C - m * _) + u * (f * x - g * _)), r[4] = -e * (a * (m * S - A * C) - o * (g * S - A * x) + n * (g * C - m * x)), r[5] = e * (i * (m * S - A * C) - o * (f * S - A * _) + n * (f * C - m * _)), r[6] = -e * (i * (g * S - A * x) - a * (f * S - A * _) + n * (f * x - g * _)), r[7] = e * (i * (g * C - m * x) - a * (f * C - m * _) + o * (f * x - g * _)), r[8] = e * (a * (u * S - c * C) - o * (h * S - c * x) + n * (h * C - u * x)), r[9] = -e * (i * (u * S - c * C) - o * (l * S - c * _) + n * (l * C - u * _)), r[10] = e * (i * (h * S - c * x) - a * (l * S - c * _) + n * (l * x - h * _)), r[11] = -e * (i * (h * C - u * x) - a * (l * C - u * _) + o * (l * x - h * _)), r[12] = -e * (a * (u * A - c * m) - o * (h * A - c * g) + n * (h * m - u * g)), r[13] = e * (i * (u * A - c * m) - o * (l * A - c * f) + n * (l * m - u * f)), r[14] = -e * (i * (h * A - c * g) - a * (l * A - c * f) + n * (l * g - h * f)), r[15] = e * (i * (h * m - u * g) - a * (l * m - u * f) + o * (l * g - h * f));
    }
    return t;
  }
  transformPoint(e, t) {
    let r = this.rawData;
    t || (t = new d());
    let i = e.x, a = e.y, o = e.z;
    return t.x = i * r[0] + a * r[4] + o * r[8] + r[12], t.y = i * r[1] + a * r[5] + o * r[9] + r[13], t.z = i * r[2] + a * r[6] + o * r[10] + r[14], t;
  }
  transformVector(e, t) {
    let r = this.rawData;
    t || (t = new d());
    let i = e.x, a = e.y, o = e.z;
    return t.x = i * r[0] + a * r[4] + o * r[8], t.y = i * r[1] + a * r[5] + o * r[9], t.z = i * r[2] + a * r[6] + o * r[10], t;
  }
  transpose() {
    let e = this.rawData;
    for (let t = 0; t < _P.helpMatrix.rawData.length; t++)
      _P.helpMatrix.rawData[t] = e[t];
    e[1] = _P.helpMatrix.rawData[4], e[2] = _P.helpMatrix.rawData[8], e[3] = _P.helpMatrix.rawData[12], e[4] = _P.helpMatrix.rawData[1], e[6] = _P.helpMatrix.rawData[9], e[7] = _P.helpMatrix.rawData[13], e[8] = _P.helpMatrix.rawData[2], e[9] = _P.helpMatrix.rawData[6], e[11] = _P.helpMatrix.rawData[14], e[12] = _P.helpMatrix.rawData[3], e[13] = _P.helpMatrix.rawData[7], e[14] = _P.helpMatrix.rawData[11];
  }
  get determinant() {
    let e = this.rawData;
    return (e[0] * e[5] - e[4] * e[1]) * (e[10] * e[15] - e[14] * e[11]) - (e[0] * e[9] - e[8] * e[1]) * (e[6] * e[15] - e[14] * e[7]) + (e[0] * e[13] - e[12] * e[1]) * (e[6] * e[11] - e[10] * e[7]) + (e[4] * e[9] - e[8] * e[5]) * (e[2] * e[15] - e[14] * e[3]) - (e[4] * e[13] - e[12] * e[5]) * (e[2] * e[11] - e[10] * e[3]) + (e[8] * e[13] - e[12] * e[9]) * (e[2] * e[7] - e[6] * e[3]);
  }
  getPosition(e) {
    e || (e = new d());
    let t = this.rawData;
    return e.x = t[12], e.y = t[13], e.z = t[14], e;
  }
  get position() {
    return this._position.set(this.rawData[12], this.rawData[13], this.rawData[14]), this._position;
  }
  set position(e) {
    let t = this.rawData;
    t[12] = e.x, t[13] = e.y, t[14] = e.z;
  }
  get scale() {
    let e = this.rawData;
    return new d(e[0], e[5], e[10]);
  }
  set scale(e) {
    let t = this.rawData;
    t[0] = e.x, t[5] = e.y, t[10] = e.z;
  }
  toString() {
    let e = this.rawData;
    return "matrix3d(" + Math.round(e[0] * 1e3) / 1e3 + "," + Math.round(e[1] * 1e3) / 1e3 + "," + Math.round(e[2] * 1e3) / 1e3 + "," + Math.round(e[3] * 1e3) / 1e3 + "," + Math.round(e[4] * 1e3) / 1e3 + "," + Math.round(e[5] * 1e3) / 1e3 + "," + Math.round(e[6] * 1e3) / 1e3 + "," + Math.round(e[7] * 1e3) / 1e3 + "," + Math.round(e[8] * 1e3) / 1e3 + "," + Math.round(e[9] * 1e3) / 1e3 + "," + Math.round(e[10] * 1e3) / 1e3 + "," + Math.round(e[11] * 1e3) / 1e3 + "," + Math.round(e[12] * 1e3) / 1e3 + "," + Math.round(e[13] * 1e3) / 1e3 + "," + Math.round(e[14] * 1e3) / 1e3 + "," + Math.round(e[15] * 1e3) / 1e3 + ")";
  }
  lerp(e, t, r) {
    this.copyFrom(t).sub(e).mult(r).add(e);
  }
  get(e, t) {
    return this.rawData[e + t * 4];
  }
  set(e, t, r) {
    this.rawData[e + t * 4] = r;
  }
  getMaxScaleOnAxis() {
    let e = this.rawData, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  translate(e) {
    let t = this.get(0, 0) * e.x + this.get(0, 1) * e.y + this.get(0, 2) * e.z + this.get(0, 3), r = this.get(1, 0) * e.x + this.get(1, 1) * e.y + this.get(1, 2) * e.z + this.get(1, 3), i = this.get(2, 0) * e.x + this.get(2, 1) * e.y + this.get(2, 2) * e.z + this.get(2, 3), a = this.get(3, 0) * e.x + this.get(3, 1) * e.y + this.get(3, 2) * e.z + this.get(3, 3);
    return this.set(0, 3, t), this.set(1, 3, r), this.set(2, 3, i), this.set(3, 3, a), this;
  }
  setTRInverse(e, t) {
    t = t.inverse(), H.quaternionToMatrix(t, this), this.translate(new d(-e.x, -e.y, -e.z));
  }
  setScale(e) {
    return this.set(0, 0, e.x), this.set(0, 1, 0), this.set(0, 2, 0), this.set(0, 3, 0), this.set(1, 0, 0), this.set(1, 1, e.y), this.set(1, 2, 0), this.set(1, 3, 0), this.set(2, 0, 0), this.set(2, 1, 0), this.set(2, 2, e.z), this.set(2, 3, 0), this.set(3, 0, 0), this.set(3, 1, 0), this.set(3, 2, 0), this.set(3, 3, 1), this;
  }
  makeBasis(e, t, r) {
    return this.setElements(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), i = Math.sin(t), a = 1 - r, o = e.x, n = e.y, l = e.z, h = a * o, u = a * n;
    return this.setElements(h * o + r, h * n - i * l, h * l + i * n, 0, h * n + i * l, u * n + r, u * l - i * o, 0, h * l - i * n, u * l + i * o, a * l * l + r, 0, 0, 0, 0, 1), this;
  }
  static transpose(e, t) {
    t || (t = new _P());
    let r = e.rawData, i = t.rawData;
    return i[0] = r[0], i[1] = r[4], i[2] = r[8], i[3] = r[12], i[4] = r[1], i[5] = r[5], i[6] = r[9], i[7] = r[13], i[8] = r[2], i[9] = r[6], i[10] = r[10], i[11] = r[14], i[12] = r[3], i[13] = r[7], i[14] = r[11], i[15] = r[15], t;
  }
  static inverse(e, t) {
    t || (t = new _P());
    let r = e.rawData, i = t.rawData;
    i[0] = r[5] * r[10] * r[15] - r[5] * r[14] * r[11] - r[6] * r[9] * r[15] + r[6] * r[13] * r[11] + r[7] * r[9] * r[14] - r[7] * r[13] * r[10], i[1] = -r[1] * r[10] * r[15] + r[1] * r[14] * r[11] + r[2] * r[9] * r[15] - r[2] * r[13] * r[11] - r[3] * r[9] * r[14] + r[3] * r[13] * r[10], i[2] = r[1] * r[6] * r[15] - r[1] * r[14] * r[7] - r[2] * r[5] * r[15] + r[2] * r[13] * r[7] + r[3] * r[5] * r[14] - r[3] * r[13] * r[6], i[3] = -r[1] * r[6] * r[11] + r[1] * r[10] * r[7] + r[2] * r[5] * r[11] - r[2] * r[9] * r[7] - r[3] * r[5] * r[10] + r[3] * r[9] * r[6], i[4] = -r[4] * r[10] * r[15] + r[4] * r[14] * r[11] + r[6] * r[8] * r[15] - r[6] * r[12] * r[11] - r[7] * r[8] * r[14] + r[7] * r[12] * r[10], i[5] = r[0] * r[10] * r[15] - r[0] * r[14] * r[11] - r[2] * r[8] * r[15] + r[2] * r[12] * r[11] + r[3] * r[8] * r[14] - r[3] * r[12] * r[10], i[6] = -r[0] * r[6] * r[15] + r[0] * r[14] * r[7] + r[2] * r[4] * r[15] - r[2] * r[12] * r[7] - r[3] * r[4] * r[14] + r[3] * r[12] * r[6], i[7] = r[0] * r[6] * r[11] - r[0] * r[10] * r[7] - r[2] * r[4] * r[11] + r[2] * r[8] * r[7] + r[3] * r[4] * r[10] - r[3] * r[8] * r[6], i[8] = r[4] * r[9] * r[15] - r[4] * r[13] * r[11] - r[5] * r[8] * r[15] + r[5] * r[12] * r[11] + r[7] * r[8] * r[13] - r[7] * r[12] * r[9], i[9] = -r[0] * r[9] * r[15] + r[0] * r[13] * r[11] + r[1] * r[8] * r[15] - r[1] * r[12] * r[11] - r[3] * r[8] * r[13] + r[3] * r[12] * r[9], i[10] = r[0] * r[5] * r[15] - r[0] * r[13] * r[7] - r[1] * r[4] * r[15] + r[1] * r[12] * r[7] + r[3] * r[4] * r[13] - r[3] * r[12] * r[5], i[11] = -r[0] * r[5] * r[11] + r[0] * r[9] * r[7] + r[1] * r[4] * r[11] - r[1] * r[8] * r[7] - r[3] * r[4] * r[9] + r[3] * r[8] * r[5], i[12] = -r[4] * r[9] * r[14] + r[4] * r[13] * r[10] + r[5] * r[8] * r[14] - r[5] * r[12] * r[10] - r[6] * r[8] * r[13] + r[6] * r[12] * r[9], i[13] = r[0] * r[9] * r[14] - r[0] * r[13] * r[10] - r[1] * r[8] * r[14] + r[1] * r[12] * r[10] + r[2] * r[8] * r[13] - r[2] * r[12] * r[9], i[14] = -r[0] * r[5] * r[14] + r[0] * r[13] * r[6] + r[1] * r[4] * r[14] - r[1] * r[12] * r[6] - r[2] * r[4] * r[13] + r[2] * r[12] * r[5], i[15] = r[0] * r[5] * r[10] - r[0] * r[9] * r[6] - r[1] * r[4] * r[10] + r[1] * r[8] * r[6] + r[2] * r[4] * r[9] - r[2] * r[8] * r[5];
    let a = r[0] * i[0] + r[1] * i[4] + r[2] * i[8] + r[3] * i[12];
    for (let o = 0; o < 16; o++)
      i[o] /= a;
    return t;
  }
  makeEuler(e, t, r = "XYZ") {
    const i = this.rawData, a = i[0], o = i[4], n = i[8], l = i[1], h = i[5], u = i[9], c = i[2], f = i[6], g = i[10];
    switch (r) {
      case "XYZ":
        e.y = Math.asin(W(n, -1, 1)), Math.abs(n) < 0.9999999 ? (e.x = Math.atan2(-u, g), e.z = Math.atan2(-o, a)) : (e.x = Math.atan2(f, h), e.z = 0);
        break;
      case "YXZ":
        e.x = Math.asin(-W(u, -1, 1)), Math.abs(u) < 0.9999999 ? (e.y = Math.atan2(n, g), e.z = Math.atan2(l, h)) : (e.y = Math.atan2(-c, a), e.z = 0);
        break;
      case "ZXY":
        e.x = Math.asin(W(f, -1, 1)), Math.abs(f) < 0.9999999 ? (e.y = Math.atan2(-c, g), e.z = Math.atan2(-o, h)) : (e.y = 0, e.z = Math.atan2(l, a));
        break;
      case "ZYX":
        e.y = Math.asin(-W(c, -1, 1)), Math.abs(c) < 0.9999999 ? (e.x = Math.atan2(f, g), e.z = Math.atan2(l, a)) : (e.x = 0, e.z = Math.atan2(-o, h));
        break;
      case "YZX":
        e.z = Math.asin(W(l, -1, 1)), Math.abs(l) < 0.9999999 ? (e.x = Math.atan2(-u, h), e.y = Math.atan2(-c, a)) : (e.x = 0, e.y = Math.atan2(n, g));
        break;
      case "XZY":
        e.z = Math.asin(-W(o, -1, 1)), Math.abs(o) < 0.9999999 ? (e.x = Math.atan2(f, h), e.y = Math.atan2(n, a)) : (e.x = Math.atan2(-u, g), e.y = 0);
        break;
    }
    return t && e.multiplyScalar(Yr), e;
  }
  setElements(e, t, r, i, a, o, n, l, h, u, c, f, g, m, A, _) {
    const x = this.rawData;
    return x[0] = e, x[4] = t, x[8] = r, x[12] = i, x[1] = a, x[5] = o, x[9] = n, x[13] = l, x[2] = h, x[6] = u, x[10] = c, x[14] = f, x[3] = g, x[7] = m, x[11] = A, x[15] = _, this;
  }
  makeMatrix44ByQuaternion(e, t, r) {
    this.identity(), H.quaternionToMatrix(r, this), this.appendTranslation(e.x, e.y, e.z), this.appendScale(t.x, t.y, t.z);
  }
};
__publicField(_P, "blockBytes", 16 * 4);
__publicField(_P, "block", 16);
__publicField(_P, "allocCount", 1e3);
__publicField(_P, "allocOnceCount", 1e3);
__publicField(_P, "maxCount", 50 * 1e4);
__publicField(_P, "useCount", 0);
__publicField(_P, "buffer");
__publicField(_P, "wasmMatrixPtr", 0);
__publicField(_P, "dynamicMatrixBytes");
__publicField(_P, "dynamicGlobalMatrixRef");
__publicField(_P, "wasm");
__publicField(_P, "help_matrix_0");
__publicField(_P, "help_matrix_1");
__publicField(_P, "help_matrix_2");
__publicField(_P, "helpMatrix");
__publicField(_P, "helpMatrix2");
__publicField(_P, "_getEulerMatrix");
__publicField(_P, "_zero", new d(0, 0, 0));
__publicField(_P, "_one", new d(1, 1, 1));
__publicField(_P, "_prs", [new d(), new d(), new d()]);
__publicField(_P, "float32Array", new Float32Array(16).fill(0));
__publicField(_P, "decomposeRawData", new Float32Array(16).fill(0));
var P = _P;
function ll(s, e, t) {
  for (let r = 0; r < 4; r++)
    t.rawData[r] = s.rawData[r] * e.rawData[0] + s.rawData[r + 4] * e.rawData[1] + s.rawData[r + 8] * e.rawData[2] + s.rawData[r + 12] * e.rawData[3], t.rawData[r + 4] = s.rawData[r] * e.rawData[4] + s.rawData[r + 4] * e.rawData[5] + s.rawData[r + 8] * e.rawData[6] + s.rawData[r + 12] * e.rawData[7], t.rawData[r + 8] = s.rawData[r] * e.rawData[8] + s.rawData[r + 4] * e.rawData[9] + s.rawData[r + 8] * e.rawData[10] + s.rawData[r + 12] * e.rawData[11], t.rawData[r + 12] = s.rawData[r] * e.rawData[12] + s.rawData[r + 4] * e.rawData[13] + s.rawData[r + 8] * e.rawData[14] + s.rawData[r + 12] * e.rawData[15];
}
function fa(s, e, t, r) {
  let i = r.rawData, a = s.x * me, o = s.y * me, n = s.z * me, l = 0, h = a * 0.5, u = o * 0.5, c = n * 0.5, f = Math.cos(h), g = Math.sin(h), m = Math.cos(u), A = Math.sin(u), _ = Math.cos(c), x = Math.sin(c);
  l = f * m * _ + g * A * x, a = g * m * _ - f * A * x, o = f * A * _ + g * m * x, n = f * m * x - g * A * _;
  let C = a + a, S = o + o, I = n + n, T = a * C, b = a * S, B = a * I, R = o * S, E = o * I, F = n * I, k = l * C, V = l * S, j = l * I, te = t.x, pe = t.y, ne = t.z;
  i[0] = (1 - (R + F)) * te, i[1] = (b + j) * te, i[2] = (B - V) * te, i[3] = 0, i[4] = (b - j) * pe, i[5] = (1 - (T + F)) * pe, i[6] = (E + k) * pe, i[7] = 0, i[8] = (B + V) * ne, i[9] = (E - k) * ne, i[10] = (1 - (T + R)) * ne, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
}
function hl(s, e, t) {
  let r = s.rawData, i = t.rawData, a = r[0], o = r[4], n = r[8], l = r[12], h = r[1], u = r[5], c = r[9], f = r[13], g = r[2], m = r[6], A = r[10], _ = r[14], x = r[3], C = r[7], S = r[11], I = r[15];
  i[0] = a * e.rawData[0] + h * e.rawData[4] + g * e.rawData[8] + x * e.rawData[12], i[1] = a * e.rawData[1] + h * e.rawData[5] + g * e.rawData[9] + x * e.rawData[13], i[2] = a * e.rawData[2] + h * e.rawData[6] + g * e.rawData[10] + x * e.rawData[14], i[3] = a * e.rawData[3] + h * e.rawData[7] + g * e.rawData[11] + x * e.rawData[15], i[4] = o * e.rawData[0] + u * e.rawData[4] + m * e.rawData[8] + C * e.rawData[12], i[5] = o * e.rawData[1] + u * e.rawData[5] + m * e.rawData[9] + C * e.rawData[13], i[6] = o * e.rawData[2] + u * e.rawData[6] + m * e.rawData[10] + C * e.rawData[14], i[7] = o * e.rawData[3] + u * e.rawData[7] + m * e.rawData[11] + C * e.rawData[15], i[8] = n * e.rawData[0] + c * e.rawData[4] + A * e.rawData[8] + S * e.rawData[12], i[9] = n * e.rawData[1] + c * e.rawData[5] + A * e.rawData[9] + S * e.rawData[13], i[10] = n * e.rawData[2] + c * e.rawData[6] + A * e.rawData[10] + S * e.rawData[14], i[11] = n * e.rawData[3] + c * e.rawData[7] + A * e.rawData[11] + S * e.rawData[15], i[12] = l * e.rawData[0] + f * e.rawData[4] + _ * e.rawData[8] + I * e.rawData[12], i[13] = l * e.rawData[1] + f * e.rawData[5] + _ * e.rawData[9] + I * e.rawData[13], i[14] = l * e.rawData[2] + f * e.rawData[6] + _ * e.rawData[10] + I * e.rawData[14], i[15] = l * e.rawData[3] + f * e.rawData[7] + _ * e.rawData[11] + I * e.rawData[15];
}
function md(s, e) {
  let t = e.x, r = e.y, i = e.z, a = e.w, o = s.rawData, n = 2 * t * r, l = 2 * t * i, h = 2 * t * a, u = 2 * r * i, c = 2 * r * a, f = 2 * i * a, g = t * t, m = r * r, A = i * i, _ = a * a;
  return o[0] = g - m - A + _, o[4] = n - f, o[8] = l + c, o[12] = 0, o[1] = n + f, o[5] = -g + m - A + _, o[9] = u - h, o[13] = 0, o[2] = l - c, o[6] = u + h, o[10] = -g - m + A + _, o[14] = 0, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, s;
}
function Ad(s, e) {
  let t = e.rawData, r = Math.sin(s), i = Math.cos(s);
  return t[0] = i, t[1] = 0, t[2] = -r, t[3] = 0, t[8] = r, t[9] = 0, t[10] = i, t[11] = 0, t;
}
function vd(s, e, t) {
  let r = e.x, i = e.y, a = e.z, o = Math.hypot(r, i, a), n, l, h, u, c, f, g, m, A, _, x, C;
  if (o < pd)
    return null;
  o = 1 / o, r *= o, i *= o, a *= o, n = Math.sin(s), l = Math.cos(s), h = 1 - l, u = r * r * h + l, c = i * r * h + a * n, f = a * r * h - i * n, g = r * i * h - a * n, m = i * i * h + l, A = a * i * h + r * n, _ = r * a * h + i * n, x = i * a * h - r * n, C = a * a * h + l;
  let S = t.rawData;
  return S[0] = u, S[1] = c, S[2] = f, S[3] = 0, S[4] = g, S[5] = m, S[6] = A, S[7] = 0, S[8] = _, S[9] = x, S[10] = C, S[11] = 0, S[12] = 0, S[13] = 0, S[14] = 0, S[15] = 1, S;
}
function ks(s, e, t) {
  let r = s.rawData, i = r[0], a = r[1], o = r[2], n = r[3], l = r[4], h = r[5], u = r[6], c = r[7], f = r[8], g = r[9], m = r[10], A = r[11], _ = r[12], x = r[13], C = r[14], S = r[15], I = e.rawData, T = t.rawData, b = I[0], B = I[1], R = I[2], E = I[3];
  return T[0] = b * i + B * l + R * f + E * _, T[1] = b * a + B * h + R * g + E * x, T[2] = b * o + B * u + R * m + E * C, T[3] = b * n + B * c + R * A + E * S, b = I[4], B = I[5], R = I[6], E = I[7], T[4] = b * i + B * l + R * f + E * _, T[5] = b * a + B * h + R * g + E * x, T[6] = b * o + B * u + R * m + E * C, T[7] = b * n + B * c + R * A + E * S, b = I[8], B = I[9], R = I[10], E = I[11], T[8] = b * i + B * l + R * f + E * _, T[9] = b * a + B * h + R * g + E * x, T[10] = b * o + B * u + R * m + E * C, T[11] = b * n + B * c + R * A + E * S, b = I[12], B = I[13], R = I[14], E = I[15], T[12] = b * i + B * l + R * f + E * _, T[13] = b * a + B * h + R * g + E * x, T[14] = b * o + B * u + R * m + E * C, T[15] = b * n + B * c + R * A + E * S, T;
}
var Pe = ((s) => (s[s.None = 0] = "None", s[s.PointLight = 1] = "PointLight", s[s.DirectionLight = 2] = "DirectionLight", s[s.SpotLight = 3] = "SpotLight", s[s.SkyLight = 4] = "SkyLight", s))(Pe || {});
var da = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "index", -1);
    __publicField(this, "lightType", -1);
    __publicField(this, "radius", 0.5);
    __publicField(this, "linear", 1);
    __publicField(this, "lightPosition", new d());
    __publicField(this, "lightMatrixIndex", -1);
    __publicField(this, "direction", new d());
    __publicField(this, "quadratic", 0.032);
    __publicField(this, "lightColor", new M(1, 1, 1, 1));
    __publicField(this, "intensity", 1);
    __publicField(this, "innerAngle", 0);
    __publicField(this, "outerAngle", 1);
    __publicField(this, "range", 100);
    __publicField(this, "castShadowIndex", -1);
    __publicField(this, "lightTangent", d.FORWARD);
    __publicField(this, "iesIndex", -1);
  }
};
__publicField(da, "lightSize", 24);
var _ue = class _ue {
  static init() {
    this._init || (this._init = true, this.componentsUpdateList = /* @__PURE__ */ new Map(), this.componentsLateUpdateList = /* @__PURE__ */ new Map(), this.componentsBeforeUpdateList = /* @__PURE__ */ new Map(), this.componentsComputeList = /* @__PURE__ */ new Map(), this.componentsEnablePickerList = /* @__PURE__ */ new Map(), this.graphicComponent = /* @__PURE__ */ new Map(), this.waitStartComponent = /* @__PURE__ */ new Map());
  }
  static bindUpdate(e, t, r) {
    this.init();
    let i = this.componentsUpdateList.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.componentsUpdateList.set(e, i)), i.set(t, r);
  }
  static unBindUpdate(e, t) {
    this.init();
    let r = this.componentsUpdateList.get(e);
    r && r.delete(t);
  }
  static bindLateUpdate(e, t, r) {
    this.init();
    let i = this.componentsLateUpdateList.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.componentsLateUpdateList.set(e, i)), i.set(t, r);
  }
  static unBindLateUpdate(e, t) {
    this.init();
    let r = this.componentsLateUpdateList.get(e);
    r && r.delete(t);
  }
  static bindBeforeUpdate(e, t, r) {
    this.init();
    let i = this.componentsBeforeUpdateList.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.componentsBeforeUpdateList.set(e, i)), i.set(t, r);
  }
  static unBindBeforeUpdate(e, t) {
    this.init();
    let r = this.componentsBeforeUpdateList.get(e);
    r && r.delete(t);
  }
  static bindCompute(e, t, r) {
    this.init();
    let i = this.componentsComputeList.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.componentsComputeList.set(e, i)), i.set(t, r);
  }
  static unBindCompute(e, t) {
    this.init();
    let r = this.componentsComputeList.get(e);
    r && r.delete(t);
  }
  static bindGraphic(e, t, r) {
    this.init();
    let i = this.graphicComponent.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.graphicComponent.set(e, i)), i.set(t, r);
  }
  static unBindGraphic(e, t) {
    this.init();
    let r = this.graphicComponent.get(e);
    r && r.delete(t);
  }
  static appendWaitStart(e) {
    this.init();
    let t = this.waitStartComponent.get(e.object3D);
    t ? t.indexOf(e) == -1 && t.push(e) : this.waitStartComponent.set(e.object3D, [e]);
  }
  static removeWaitStart(e, t) {
    this.init();
    let r = _ue.waitStartComponent.get(e);
    if (r) {
      let i = r.indexOf(t);
      i != -1 && r.splice(i);
    }
  }
  static bindEnablePick(e, t, r) {
    this.init();
    let i = this.componentsEnablePickerList.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.componentsEnablePickerList.set(e, i)), i.set(t, r);
  }
  static unBindEnablePick(e, t) {
    this.init();
    let r = this.componentsEnablePickerList.get(e);
    r && r.delete(t);
  }
};
__publicField(_ue, "componentsUpdateList");
__publicField(_ue, "componentsLateUpdateList");
__publicField(_ue, "componentsBeforeUpdateList");
__publicField(_ue, "componentsComputeList");
__publicField(_ue, "componentsEnablePickerList");
__publicField(_ue, "graphicComponent");
__publicField(_ue, "waitStartComponent");
__publicField(_ue, "_init", false);
var ue = _ue;
var _e = class {
  constructor() {
    __publicField(this, "object3D", null);
    __publicField(this, "_eventDispatcher");
    __publicField(this, "_enable", true);
    __publicField(this, "__isStart", false);
    __publicField(this, "isDestroyed");
  }
  get eventDispatcher() {
    return this._eventDispatcher || (this._eventDispatcher = new qt()), this._eventDispatcher;
  }
  set eventDispatcher(e) {
    console.error("The eventDispatcher should not be set externally!");
  }
  get isStart() {
    return this.__isStart;
  }
  get transform() {
    return this.object3D.transform;
  }
  set enable(e) {
    var _a3, _b;
    this._enable != e && (this._enable = e, this._enable ? (_a3 = this.onEnable) == null ? void 0 : _a3.call(this, this.transform.view3D) : (_b = this.onDisable) == null ? void 0 : _b.call(this, this.transform.view3D));
  }
  get enable() {
    return this._enable;
  }
  __init(e) {
    this.init(e);
  }
  __start() {
    var _a3, _b;
    this.transform && this.transform.scene3D && this._enable && ((_a3 = this.onEnable) == null ? void 0 : _a3.call(this, this.transform.view3D)), this.transform && this.transform.scene3D && this.__isStart == false && ((_b = this.start) == null ? void 0 : _b.call(this), this.__isStart = true), this.onUpdate && this._onUpdate(this.onUpdate.bind(this)), this.onLateUpdate && this._onLateUpdate(this.onLateUpdate.bind(this)), this.onBeforeUpdate && this._onBeforeUpdate(this.onBeforeUpdate.bind(this)), this.onCompute && this._onCompute(this.onCompute.bind(this)), this.onGraphic && this._onGraphic(this.onGraphic.bind(this));
  }
  __stop() {
    var _a3;
    this.transform && this.transform.scene3D && ((_a3 = this.onDisable) == null ? void 0 : _a3.call(this, this.transform.view3D)), this._onUpdate(null), this._onLateUpdate(null), this._onBeforeUpdate(null), this._onCompute(null), this._onGraphic(null);
  }
  init(e) {
  }
  start() {
  }
  stop() {
  }
  cloneTo(e) {
  }
  copyComponent(e) {
    return this;
  }
  _onUpdate(e) {
    e != null ? ue.bindUpdate(this.transform.view3D, this, e) : ue.unBindUpdate(this.transform.view3D, this);
  }
  _onLateUpdate(e) {
    e != null ? ue.bindLateUpdate(this.transform.view3D, this, e) : ue.unBindLateUpdate(this.transform.view3D, this);
  }
  _onBeforeUpdate(e) {
    e != null ? ue.bindBeforeUpdate(this.transform.view3D, this, e) : ue.unBindBeforeUpdate(this.transform.view3D, this);
  }
  _onCompute(e) {
    e != null ? ue.bindCompute(this.transform.view3D, this, e) : ue.unBindCompute(this.transform.view3D, this);
  }
  _onGraphic(e) {
    e != null ? ue.bindGraphic(this.transform.view3D, this, e) : ue.unBindGraphic(this.transform.view3D, this);
  }
  beforeDestroy(e) {
    ue.removeWaitStart(this.object3D, this);
  }
  destroy(e) {
    this.isDestroyed || (this.isDestroyed = true, this.enable = false, this.stop(), this._onBeforeUpdate(null), this._onUpdate(null), this._onLateUpdate(null), this.onEnable = null, this.onDisable = null, this.onUpdate = null, this.onLateUpdate = null, this.onBeforeUpdate = null, this.onCompute = null, this.onGraphic = null);
  }
};
var ga = class {
  constructor() {
    __publicField(this, "value", 0);
    __publicField(this, "inv_base", 0);
  }
  static get(e, t) {
    let r = 0, i = 1 / t;
    for (; e > 0; )
      r += e % t * i, e /= t, i /= t;
    return r;
  }
  getBase(e, t) {
    let r = this.inv_base = 1 / t;
    for (; e > 0; )
      this.value += r * (e % t), e /= t, r *= this.inv_base;
  }
  next() {
    let e = 1 - this.value - 1e-7;
    if (this.inv_base < e)
      this.value += this.inv_base;
    else {
      let t = this.inv_base, r;
      do
        r = t, t *= this.inv_base;
      while (t >= e);
      this.value += r + t - 1;
    }
  }
  get() {
    return this.value;
  }
};
var _bt = class _bt {
  constructor(e, t) {
    __publicField(this, "origin", new d());
    __publicField(this, "length", Number.MAX_VALUE);
    __publicField(this, "_vector", new d());
    __publicField(this, "_dir", new d());
    __publicField(this, "_v0", new d());
    __publicField(this, "_v1", new d());
    __publicField(this, "_v2", new d());
    __publicField(this, "_E1", new d());
    __publicField(this, "_E2", new d());
    __publicField(this, "_P", new d());
    __publicField(this, "_T", new d());
    __publicField(this, "_Q", new d());
    this.origin.copyFrom(e || new d()), this._dir.copyFrom(t || new d()), this._dir.normalize();
  }
  get direction() {
    return this._dir;
  }
  set direction(e) {
    this._dir.copyFrom(e), this._dir.normalize();
  }
  clone() {
    return new _bt(this.origin, this.direction);
  }
  intersectBox(e, t) {
    let r = this.direction, i = this.origin, a, o, n, l, h, u;
    const c = 1 / r.x, f = 1 / r.y, g = 1 / r.z, m = e.min, A = e.max;
    return a = ((c >= 0 ? m.x : A.x) - i.x) * c, o = ((c >= 0 ? A.x : m.x) - i.x) * c, n = ((f >= 0 ? m.y : A.y) - i.y) * f, l = ((f >= 0 ? A.y : m.y) - i.y) * f, a > l || n > o || (n > a && (a = n), l < o && (o = l), h = ((g >= 0 ? m.z : A.z) - i.z) * g, u = ((g >= 0 ? A.z : m.z) - i.z) * g, a > u || h > o) || (h > a && (a = h), u < o && (o = u), o < 0) ? null : (t || (t = new d()), this.pointAt(a >= 0 ? a : o, t));
  }
  pointAt(e, t) {
    return t || (t = new d()), t.copy(this.direction), t.multiplyScalar(e), t.add(this.origin, t), t;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this._dir.copy(e._dir), this.length = e.length, this;
  }
  setApproxDirection(e) {
    this._dir = e.normalize();
  }
  setOrigin(e) {
    this.origin.copyFrom(e);
  }
  getOrigin() {
    return this.origin;
  }
  getPoint(e) {
    return this._dir.scaleBy(e), this.origin.add(this._dir);
  }
  sqrDistToPoint(e) {
    let t = this._dir, r = e.subtract(this.origin), i = Ye(r, t), a = Ye(t, t), o = i / a, n = this.getPoint(o);
    return Ns(e.subtract(n));
  }
  applyMatrix(e) {
    this.origin = e.transformPoint(this.origin), this._dir = e.transformVector(this._dir);
  }
  pointInTriangle(e, t, r, i) {
    let a = this._v0, o = this._v1, n = this._v2;
    i.subtract(t, a), r.subtract(t, o), e.subtract(t, n);
    let l = d.dot(a, a), h = d.dot(a, o), u = d.dot(a, n), c = d.dot(o, o), f = d.dot(o, n), g = 1 / (l * c - h * h), m = (c * u - h * f) * g, A = (l * f - h * u) * g;
    return m >= 0 && A >= 0 && m + A < 1;
  }
  intersectTriangle(e, t, r) {
    let i = r.v1, a = r.v2, o = r.v3;
    a.subtract(i, this._E1), o.subtract(i, this._E2), t.crossProduct(this._E2, this._P);
    let n = this._E1.dotProduct(this._P);
    if (n > 0 ? e.subtract(i, this._T) : (i.subtract(e, this._T), n = -n), n < 1e-4 || (r.u = this._T.dotProduct(this._P), r.u < 0 || r.u > n) || (this._T.crossProduct(this._E1, this._Q), r.v = t.dotProduct(this._Q), r.v < 0 || r.u + r.v > n))
      return null;
    let l = new d();
    r.t0 = r.t = this._E2.dotProduct(this._Q);
    let h = 1 / n;
    return r.t *= h, r.u *= h, r.v *= h, l.x = e.x + r.t * t.x, l.y = e.y + r.t * t.y, l.z = e.z + r.t * t.z, l;
  }
  intersectSphere(e, t, r, i) {
    let a = e.subtract(r), o = d.dot(t, t), n = 2 * d.dot(a, t), l = d.dot(a, a) - i * i, h = n * n - 4 * o * l, u = d.HELP_3;
    if (h < 0)
      return null;
    {
      let c = (-n - Math.sqrt(h)) / (o * 2);
      return c < 0 ? null : (u.x = e.x + c * t.x, u.y = e.y + c * t.y, u.z = e.z + c * t.z, u);
    }
  }
  intersectionSegment(e, t, r) {
    const i = this.origin, a = d.HELP_0, o = d.HELP_1, n = d.HELP_2, l = d.HELP_3;
    t.subtract(e, a), this._dir.scaleToRef(_bt._rayl, n), i.add(n, o), e.subtract(i, l);
    var h = d.dot(a, a), u = d.dot(a, n), c = d.dot(n, n), f = d.dot(a, l), g = d.dot(n, l), m = h * c - u * u, A, _, x = m, C, S, I = m;
    m < _bt._smallnum ? (_ = 0, x = 1, S = g, I = c) : (_ = u * g - c * f, S = h * g - u * f, _ < 0 ? (_ = 0, S = g, I = c) : _ > x && (_ = x, S = g + u, I = c)), S < 0 ? (S = 0, -f < 0 ? _ = 0 : -f > h ? _ = x : (_ = -f, x = h)) : S > I && (S = I, -f + u < 0 ? _ = 0 : -f + u > h ? _ = x : (_ = -f + u, x = h)), A = Math.abs(_) < _bt._smallnum ? 0 : _ / x, C = Math.abs(S) < _bt._smallnum ? 0 : S / I;
    const T = d.HELP_4;
    n.scaleToRef(C, T);
    const b = d.HELP_5;
    a.scaleToRef(A, b), b.add(l, b);
    const B = d.HELP_6;
    b.subtract(T, B);
    var R = C > 0 && C <= this._dir.length && B.lengthSquared < r * r;
    if (R) {
      let E = new d();
      return E.copyFrom(t.subtract(e)), E.scaleBy(A), E.add(e, E), { out: E, length: b.length };
    }
    return { out: null, length: -1 };
  }
  get_vec(e, t) {
    let r = d.HELP_1;
    return r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r;
  }
};
__publicField(_bt, "_rayl", 1e9);
__publicField(_bt, "_smallnum", 1e-8);
var bt = _bt;
var ia = class _ia {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "w");
    __publicField(this, "h");
    this.x = e, this.y = t, this.w = r, this.h = i;
  }
  get width() {
    return this.w;
  }
  set width(e) {
    this.w = e;
  }
  get height() {
    return this.h;
  }
  set height(e) {
    this.h = e;
  }
  static pointInRect(e, t, r, i, a, o) {
    return !(e < r || e > a || t < i || t > o);
  }
  clone() {
    return new _ia(this.x, this.y, this.w, this.h);
  }
  copyFrom(e) {
    this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h;
  }
  copyTo(e) {
    e.copyFrom(this);
  }
  inner(e, t) {
    return !(e < this.x || e > this.x + this.width || t < this.y || t > this.y + this.height);
  }
  equal(e) {
    return !(this.x != e.x || this.y != e.y || this.width != e.width || this.height != e.height);
  }
  equalArea(e, t, r, i) {
    return !(this.x != e || this.y != t || this.width != r || this.height != i);
  }
  equalInnerArea(e) {
    var t = this.x, r = this.y, i = this.x + this.width, a = this.y + this.height, o = e.x, n = e.y, l = e.x + e.width, h = e.y + e.height;
    return Math.max(t, o) <= Math.min(i, l) && Math.max(r, n) <= Math.min(a, h);
  }
  innerArea(e, t) {
    t = t || new _ia();
    var r = this.x, i = this.y, a = this.x + this.width, o = this.y + this.height, n = e.x, l = e.y, h = e.x + e.width, u = e.y + e.height, c = Math.max(i, l), f = Math.min(o, u), g = Math.max(r, n), m = Math.min(h, a);
    return c >= 0 && f >= 0 && f - c >= 0 && m - g > 0 ? (t.x = g, t.y = c, t.width = m - g, t.height = f - c) : (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t;
  }
  setTo(e, t, r, i) {
    this.x = e, this.y = t, this.width = r, this.height = i;
  }
};
var _ge = class _ge {
  constructor(e, t) {
    __publicField(this, "center");
    __publicField(this, "extents");
    __publicField(this, "max");
    __publicField(this, "min");
    __publicField(this, "size");
    e || (e = d.ZERO.clone()), t || (t = d.ZERO.clone()), this.setFromCenterAndSize(e, t);
  }
  makeEmpty() {
    return this.setFromMinMax(_ge.maxVector3, _ge.minVector3), this;
  }
  setFromMinMax(e, t) {
    return this.init(), t.subtract(e, this.size), e.add(t, this.center).multiplyScalar(0.5), this.extents.copyFrom(this.size).multiplyScalar(0.5), this.min.copyFrom(e), this.max.copyFrom(t), this;
  }
  init() {
    return this.min || (this.min = new d()), this.max || (this.max = new d()), this.size || (this.size = new d()), this.center || (this.center = new d()), this.extents || (this.extents = new d()), this;
  }
  setFromCenterAndSize(e, t) {
    return this.size = t, this.center = e, this.init(), this.extents.copy(t).multiplyScalar(0.5), this.center.subtract(this.extents, this.min), this.center.add(this.extents, this.max), this;
  }
  inFrustum(e, t) {
    return t.containsBox(e.bound);
  }
  merge(e) {
    e.min.x < this.min.x && (this.min.x = e.min.x), e.min.y < this.min.y && (this.min.y = e.min.y), e.min.z < this.min.z && (this.min.z = e.min.z), e.max.x > this.max.x && (this.max.x = e.max.x), e.max.y > this.max.y && (this.max.y = e.max.y), e.max.z > this.max.z && (this.max.z = e.max.z), this.size.x = e.max.x - e.min.x, this.size.y = e.max.y - e.min.y, this.size.z = e.max.z - e.min.z, this.extents.x = this.size.x * 0.5, this.extents.y = this.size.y * 0.5, this.extents.z = this.size.z * 0.5, this.center.x = this.extents.x + e.min.x, this.center.y = this.extents.y + e.min.y, this.center.z = this.extents.z + e.min.z;
  }
  intersects(e) {
    return this.min.x <= e.max.x && this.max.x >= e.min.x && this.min.y <= e.max.y && this.max.y >= e.min.y && this.min.z <= e.max.z && this.max.z >= e.min.z;
  }
  intersectsSphere(e) {
    return this.min.x <= e.max.x && this.max.x >= e.min.x && this.min.y <= e.max.y && this.max.y >= e.min.y && this.min.z <= e.max.z && this.max.z >= e.min.z;
  }
  intersectsBox(e) {
    return this.min.x <= e.max.x && this.max.x >= e.min.x && this.min.y <= e.max.y && this.max.y >= e.min.y && this.min.z <= e.max.z && this.max.z >= e.min.z;
  }
  equals(e) {
    return this.center.equals(e.center) && this.extents.equals(e.extents);
  }
  expandByPoint(e) {
    e.x < this.min.x && (this.min.x = e.x), e.x > this.max.x && (this.max.x = e.x), e.y < this.min.y && (this.min.y = e.y), e.y > this.max.y && (this.max.y = e.y), e.z < this.min.z && (this.min.z = e.z), e.z > this.max.z && (this.max.z = e.z);
  }
  static fromPoints(e) {
    for (var t = new _ge(new d(), new d()), r = 0; r < e.length; r++)
      t.expandByPoint(e[r]);
    return t;
  }
  calculateTransform(e) {
  }
  clone() {
    var e = new _ge(this.center.clone(), this.size.clone());
    return e;
  }
  intersectsRay(e, t) {
    throw new Error("Method not implemented.");
  }
  containsPoint(e) {
    return this.min.x <= e.x && this.max.x >= e.x && this.min.y <= e.y && this.max.y >= e.y && this.min.z <= e.z && this.max.z >= e.z;
  }
  containsBox(e) {
    let t = this.min, r = this.max;
    return t.x <= e.min.x && t.y <= e.min.y && t.z <= e.min.z && r.x >= e.max.x && r.y >= e.max.y && r.z >= e.max.z;
  }
  updateBound() {
  }
  destroy(e) {
    this.center = null, this.extents = null, this.min = null, this.max = null, this.size = null;
  }
};
__publicField(_ge, "maxVector3", new d(1, 1, 1).multiplyScalar(Number.MAX_VALUE * 0.1));
__publicField(_ge, "minVector3", new d(1, 1, 1).multiplyScalar(-Number.MAX_VALUE * 0.1));
var ge = _ge;
var ul = class {
  constructor() {
    __publicField(this, "planes");
    __publicField(this, "corners");
    __publicField(this, "boundingBox", new ge());
    this.planes = [], this.corners = [];
    for (var e = 0; e < 6; e++)
      this.planes[e] = new d();
    for (var e = 0; e < 2 * 2 * 2; e++)
      this.corners[e] = new d();
  }
  updateBoundBox(e) {
    this.boundingBox.makeEmpty();
    let t = this.boundingBox.min, r = this.boundingBox.max, i = 0;
    for (let a = 0; a < 2; ++a)
      for (let o = 0; o < 2; ++o)
        for (let n = 0; n < 2; ++n) {
          let l = this.corners[i];
          i++, l.set(2 * a - 1, 2 * o - 1, n, 1), e.transformVector4(l, l), l.div(l.w, l), t.x = Math.min(l.x, t.x), t.y = Math.min(l.y, t.y), t.z = Math.min(l.z, t.z), r.x = Math.max(l.x, r.x), r.y = Math.max(l.y, r.y), r.z = Math.max(l.z, r.z);
        }
    return this.boundingBox.setFromMinMax(t, r), this;
  }
  setFrustumCorners(e) {
    let t = 0;
    for (let r = 0; r < 2; ++r)
      for (let i = 0; i < 2; ++i)
        for (let a = 0; a < 2; ++a) {
          let o = this.corners[t];
          o.set(2 * r - 1, 2 * i - 1, a, 1), e.transformVector4(o, o), o.div(o.w, o), t++;
        }
  }
  update(e) {
    var t = e.rawData;
    this.planes[0].x = t[3] - t[0], this.planes[0].y = t[7] - t[4], this.planes[0].z = t[11] - t[8], this.planes[0].w = t[15] - t[12];
    var r = Math.sqrt(this.planes[0].x * this.planes[0].x + this.planes[0].y * this.planes[0].y + this.planes[0].z * this.planes[0].z);
    this.planes[0].x /= r, this.planes[0].y /= r, this.planes[0].z /= r, this.planes[0].w /= r, this.planes[1].x = t[3] + t[0], this.planes[1].y = t[7] + t[4], this.planes[1].z = t[11] + t[8], this.planes[1].w = t[15] + t[12], r = Math.sqrt(this.planes[1].x * this.planes[1].x + this.planes[1].y * this.planes[1].y + this.planes[1].z * this.planes[1].z), this.planes[1].x /= r, this.planes[1].y /= r, this.planes[1].z /= r, this.planes[1].w /= r, this.planes[2].x = t[3] + t[1], this.planes[2].y = t[7] + t[5], this.planes[2].z = t[11] + t[9], this.planes[2].w = t[15] + t[13], r = Math.sqrt(this.planes[2].x * this.planes[2].x + this.planes[2].y * this.planes[2].y + this.planes[2].z * this.planes[2].z), this.planes[2].x /= r, this.planes[2].y /= r, this.planes[2].z /= r, this.planes[2].w /= r, this.planes[3].x = t[3] - t[1], this.planes[3].y = t[7] - t[5], this.planes[3].z = t[11] - t[9], this.planes[3].w = t[15] - t[13], r = Math.sqrt(this.planes[3].x * this.planes[3].x + this.planes[3].y * this.planes[3].y + this.planes[3].z * this.planes[3].z), this.planes[3].x /= r, this.planes[3].y /= r, this.planes[3].z /= r, this.planes[3].w /= r, this.planes[4].x = t[3] - t[2], this.planes[4].y = t[7] - t[6], this.planes[4].z = t[11] - t[10], this.planes[4].w = t[15] - t[14], r = Math.sqrt(this.planes[4].x * this.planes[4].x + this.planes[4].y * this.planes[4].y + this.planes[4].z * this.planes[4].z), this.planes[4].x /= r, this.planes[4].y /= r, this.planes[4].z /= r, this.planes[4].w /= r, this.planes[5].x = t[3] + t[2], this.planes[5].y = t[7] + t[6], this.planes[5].z = t[11] + t[10], this.planes[5].w = t[15] + t[14], r = Math.sqrt(this.planes[5].x * this.planes[5].x + this.planes[5].y * this.planes[5].y + this.planes[5].z * this.planes[5].z), this.planes[5].x /= r, this.planes[5].y /= r, this.planes[5].z /= r, this.planes[5].w /= r;
  }
  containsPoint(e) {
    for (var t = 0; t < 6; t++)
      if (this.planes[t].x * e.x + this.planes[t].y * e.y + this.planes[t].z * e.z + this.planes[t].w <= 0)
        return false;
    return true;
  }
  containsSphere(e) {
    let t = e.bound, r = 0, i, a = e.transform.worldPosition, o = t.radius, n = t.center.x + a.x, l = t.center.y + a.y, h = t.center.z + a.z;
    for (let u of this.planes) {
      if (i = u.x * n + u.y * l + u.z * h + u.w, i <= -o)
        return 0;
      i > o && r++;
    }
    return r === 6 ? 2 : 1;
  }
  containsBox(e) {
    let t = 0, r, a = Math.max(e.size.x, e.size.y, e.size.z) * 2, o = e.center.x, n = e.center.y, l = e.center.z;
    for (let h of this.planes) {
      if (r = h.x * o + h.y * n + h.z * l + h.w, r <= -a)
        return 0;
      r > a && t++;
    }
    return t === 6 ? 2 : 1;
  }
  containsBox2(e) {
    let t = 0, r, i = 1.74 * Math.max(e.extents.x, e.extents.y, e.extents.z);
    for (let a of this.planes) {
      if (r = a.x * e.center.x + a.y * e.center.y + a.z * e.center.z + a.w, r <= -i)
        return 0;
      r > i && t++;
    }
    return t === 6 ? 2 : 1;
  }
};
var Ae = ((s) => (s[s.ortho = 0] = "ortho", s[s.perspective = 1] = "perspective", s[s.shadow = 2] = "shadow", s))(Ae || {});
var xd = class {
  constructor(e) {
    __publicField(this, "corners");
    __publicField(this, "index");
    this.index = e, this.corners = [];
    for (let t = 0; t < 4; t++)
      this.corners.push(new d());
  }
};
var _d2 = class {
  constructor(e, t, r) {
    __publicField(this, "bound");
    __publicField(this, "twoSections");
    __publicField(this, "name");
    __publicField(this, "color");
    __publicField(this, "shadowCamera");
    __publicField(this, "index");
    this.bound = new ge(), this.shadowCamera = Me.createCamera3DObject(null, "csmShadowCamera_" + r), this.shadowCamera.isShadowCamera = true, this.shadowCamera.orthoOffCenter(100, -100, 100, -100, 1, 1e4), this.twoSections = [e, t], this.index = r, r == 0 ? this.color = new M(1, 0, 0, 1) : r == 1 ? this.color = new M(0, 1, 0, 1) : r == 2 ? this.color = new M(0, 0, 1, 1) : r == 3 && (this.color = new M(0, 1, 1, 1)), this.name = "child_" + r;
  }
  updateBound() {
    this.bound.makeEmpty();
    let e = this.bound.min, t = this.bound.max;
    for (let r of this.twoSections)
      for (let i of r.corners)
        e.x = Math.min(i.x, e.x), e.y = Math.min(i.y, e.y), e.z = Math.min(i.z, e.z), t.x = Math.max(i.x, t.x), t.y = Math.max(i.y, t.y), t.z = Math.max(i.z, t.z);
    return this.bound.setFromMinMax(e, t), this;
  }
};
var cl = class {
  constructor(e) {
    __publicField(this, "sections");
    __publicField(this, "children");
    __publicField(this, "name");
    this.sections = [];
    let t = e + 1;
    for (let r = 0; r < t; r++)
      this.sections.push(new xd(r));
    this.children = [];
    for (let r = 0; r < e; r++)
      this.children.push(new _d2(this.sections[r], this.sections[r + 1], r));
  }
  update(e, t, r, i, a) {
    let o = this.sections.length - 1;
    for (let n = 0; n <= o; ++n) {
      let l = this.sections[n], h = 0, u = this.logSplit(r, i, n, this.sections.length);
      {
        let f = (u - r) / i;
        f = f ** a.csmScatteringExp, u = (i - r) * f + r;
      }
      u *= a.csmAreaScale;
      let c = (e.rawData[10] * u + e.rawData[14]) / u;
      for (let f = 0; f < 2; ++f)
        for (let g = 0; g < 2; ++g) {
          let m = l.corners[h];
          h++, m.set(2 * f - 1, 2 * g - 1, c, 1), t.transformVector4(m, m), m.div(m.w, m);
        }
    }
    for (let n of this.children)
      n.updateBound();
    return this;
  }
  squareSplit(e, t, r, i) {
    return (r / (i - 1)) ** 4 * (t - e) + e;
  }
  uniformSplit(e, t, r, i) {
    return r / (i - 1) * (t - e) + e;
  }
  logSplit(e, t, r, i) {
    return e * (t / e) ** (r / (i - 1));
  }
};
var Wr = class extends _e {
  constructor() {
    super();
    __publicField(this, "fov", 1);
    __publicField(this, "name");
    __publicField(this, "aspect", 1);
    __publicField(this, "near", 1);
    __publicField(this, "far", 5e3);
    __publicField(this, "viewPort", new ia());
    __publicField(this, "frustum");
    __publicField(this, "isShadowCamera", false);
    __publicField(this, "_projectionMatrixInv", new P());
    __publicField(this, "_projectionMatrix", new P());
    __publicField(this, "_viewMatrix", new P());
    __publicField(this, "_unprojection", new P());
    __publicField(this, "_pvMatrixInv", new P());
    __publicField(this, "_pvMatrix", new P());
    __publicField(this, "_halfw");
    __publicField(this, "_halfh");
    __publicField(this, "_ray");
    __publicField(this, "_enableCSM", false);
    __publicField(this, "lookTarget");
    __publicField(this, "type", Ae.perspective);
    __publicField(this, "csm");
    __publicField(this, "cubeShadowCameras", []);
    __publicField(this, "_haltonSeq");
    __publicField(this, "_jitterOffsetList");
    __publicField(this, "_useJitterProjection", false);
    __publicField(this, "_jitterFrameIndex", 0);
    __publicField(this, "_sampleIndex", 0);
    __publicField(this, "_jitterX", 0);
    __publicField(this, "_jitterY", 0);
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get enableCSM() {
    return this._enableCSM;
  }
  set enableCSM(e) {
    e && !this.csm && (this.csm = new cl(Ct.Cascades)), this._enableCSM = e;
  }
  init() {
    super.init(), this._ray = new bt(), this.frustum = new ul(), this.viewPort.x = 0, this.viewPort.y = 0, this.viewPort.w = w.presentationSize[0], this.viewPort.h = w.presentationSize[1], this.lookTarget = new d(0, 0, 0);
  }
  getShadowBias(e) {
    let t = 2 * this.getShadowWorldExtents() / e, r = this.far - this.near;
    return t / r - p.setting.shadow.shadowBias * 0.01;
  }
  getShadowWorldExtents() {
    let e = p.setting.shadow.shadowBound;
    return e ? e *= 0.5 : e = Math.round(0.05 * this.frustum.boundingBox.extents.length), e;
  }
  getCSMShadowBias(e, t) {
    let r = 2 * this.getCSMShadowWorldExtents(e) / t, i = this.far - this.near;
    return r / i;
  }
  getCSMShadowWorldExtents(e) {
    return Math.round(this.csm.children[e].bound.extents.length);
  }
  perspective(e, t, r, i) {
    this.fov = e, this.aspect = t, this.near = r, this.far = i, this._projectionMatrix.perspective(e, t, r, i), this.type = Ae.perspective;
  }
  resetPerspective(e) {
    this.type == Ae.perspective && this._projectionMatrix.perspective(this.fov, e, this.near, this.far);
  }
  ortho(e, t, r, i) {
    this.near = Math.max(r, 0.1), this.far = i, this._projectionMatrix.ortho(e, t, r, i), this.type = Ae.ortho;
  }
  orthoOffCenter(e, t, r, i, a, o) {
    this.near = Math.max(a, 0.01), this.far = o, this._projectionMatrix.orthoOffCenter(e, t, r, i, a, o), this.type = Ae.ortho;
  }
  orthoZo(e, t, r, i, a, o) {
    this.near = Math.max(a, 0.01), this.far = o, this._projectionMatrix.orthoZO(e, t, r, i, a, o), this.type = Ae.ortho;
  }
  get viewMatrix() {
    return this._viewMatrix.copyFrom(this.transform.worldMatrix), this._viewMatrix.invert(), this._viewMatrix;
  }
  get shadowViewMatrix() {
    return this._viewMatrix.copyFrom(this.transform.worldMatrix), this._viewMatrix.appendScale(1, 1, 1), this._viewMatrix.invert(), this._viewMatrix;
  }
  object3DToScreenRay(e, t = null) {
    return t || (t = new d(0, 0, 0, 1)), this._halfw = this.viewPort.width * 0.5, this._halfh = this.viewPort.height * 0.5, Ze.transformVector(this.viewMatrix, e, t), this.project(t, t), t.x = this._halfw + t.x * this._halfw, t.y = this.viewPort.height - (this._halfh - t.y * this._halfh), t;
  }
  screenRayToObject3D(e, t = null) {
    t || (t = new d()), this._halfw = this.viewPort.width * 0.5, this._halfh = this.viewPort.height * 0.5;
    let r = e.x, i = e.y;
    return t.x = r / this.viewPort.width - 0.25, t.y = i / this.viewPort.height - 0.25, this.unProject(t.x, t.y, e.z, t), t;
  }
  get pvMatrix() {
    return ks(this._projectionMatrix, this.viewMatrix, this._pvMatrix), this._pvMatrix;
  }
  get pvMatrix2() {
    ks(this._projectionMatrix, this.transform.worldMatrix, this._pvMatrix);
    let e = this._pvMatrixInv.copyFrom(this.pvMatrix);
    return e.invert(), e;
  }
  get pvMatrixInv() {
    let e = this._pvMatrixInv.copyFrom(this.pvMatrix);
    return e.invert(), e;
  }
  get projectionMatrixInv() {
    return this._projectionMatrixInv.copyFrom(this._projectionMatrix), this._projectionMatrixInv.invert(), this._projectionMatrixInv;
  }
  unProject(e, t, r, i) {
    return i || (i = new d()), i.x = e, i.y = -t, i.z = r, i.w = 1, i.x *= r, i.y *= r, this._unprojection.copyFrom(this._projectionMatrix), this._unprojection.invert(), Ze.transformVector(this._unprojection, i, i), i.z = r, i;
  }
  project(e, t) {
    return this._projectionMatrix.perspectiveMultiplyPoint3(e, t), t.x = t.x / t.w, t.y = -t.y / t.w, t.z = e.z, t;
  }
  screenPointToRay(e, t) {
    let r = this._ray, i = Me.UnProjection(e, t, 0.01, this), a = Me.UnProjection(e, t, 1, this);
    return a = a.subtract(i).normalize(), r.origin.copyFrom(i), r.direction = a, r;
  }
  screenPointToWorld(e, t, r) {
    return Me.UnProjection(e, t, r, this);
  }
  worldToScreenPoint(e, t) {
    return Me.Projection(e, this, t);
  }
  lookAt(e, t, r = d.Y_AXIS) {
    this.transform.lookAt(e, t, r), t && this.lookTarget.copyFrom(t);
  }
  resetProjectMatrix() {
    this.perspective(this.fov, this.aspect, this.near, this.far);
  }
  onUpdate() {
    var _a3;
    this.type == Ae.perspective && (this.aspect = w.aspect, this.resetProjectMatrix()), this._useJitterProjection && this.getJitteredProjectionMatrix(), this.frustum.update(this.pvMatrix), this.frustum.updateBoundBox(this.pvMatrixInv);
    let e = p.setting.shadow;
    this.enableCSM && ((_a3 = this.csm) == null ? void 0 : _a3.update(this._projectionMatrix, this._pvMatrixInv, this.near, this.far, e));
  }
  get jitterFrameIndex() {
    return this._jitterFrameIndex;
  }
  get jitterX() {
    return this._jitterX;
  }
  get jitterY() {
    return this._jitterY;
  }
  enableJitterProjection(e) {
    this._jitterFrameIndex = 0, this._useJitterProjection = e, this._haltonSeq || (this._haltonSeq = new ga()), this._jitterOffsetList = [];
    for (let t = 0; t < 8; t++) {
      let r = this.generateRandomOffset();
      this._jitterOffsetList.push(r);
    }
    this._jitterOffsetList.reverse();
  }
  generateRandomOffset() {
    let e = new Q(ga.get((this._sampleIndex & 1023) + 1, 2) - 0.5, ga.get((this._sampleIndex & 1023) + 1, 3) - 0.5);
    return ++this._sampleIndex >= 8 && (this._sampleIndex = 0), e;
  }
  getJitteredProjectionMatrix() {
    let e = p.setting.render.postProcessing.taa, t = this._projectionMatrix, r = e.temporalJitterScale, i = this._jitterFrameIndex % e.jitterSeedCount, a = this._jitterOffsetList[i].x * r, o = this._jitterOffsetList[i].y * r, n = t.get(0, 2), l = t.get(1, 2);
    this._jitterX = a / this.viewPort.width, this._jitterY = o / this.viewPort.height, n += this._jitterX, l += this._jitterY, t.set(0, 2, n), t.set(1, 2, l), this._jitterFrameIndex++;
  }
  getWorldDirection(e) {
    e || (e = new d());
    const t = this.transform._worldMatrix.rawData;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
};
var _ht = class _ht extends _e {
  constructor() {
    super();
    __publicField(this, "eventPositionChange", new ze(_ht.POSITION_ONCHANGE));
    __publicField(this, "eventRotationChange", new ze(_ht.ROTATION_ONCHANGE));
    __publicField(this, "eventScaleChange", new ze(_ht.SCALE_ONCHANGE));
    __publicField(this, "eventLocalChange", new ze(_ht.LOCAL_ONCHANGE));
    __publicField(this, "onPositionChange");
    __publicField(this, "onRotationChange");
    __publicField(this, "onScaleChange");
    __publicField(this, "_scene3d");
    __publicField(this, "_parent");
    __publicField(this, "_localPos");
    __publicField(this, "_localRot");
    __publicField(this, "_localRotQuat");
    __publicField(this, "_localScale");
    __publicField(this, "_localDetailPos");
    __publicField(this, "_localDetailRot");
    __publicField(this, "_localDetailScale");
    __publicField(this, "index");
    __publicField(this, "index2");
    __publicField(this, "_forward", new d());
    __publicField(this, "_back", new d());
    __publicField(this, "_right", new d());
    __publicField(this, "_left", new d());
    __publicField(this, "_up", new d());
    __publicField(this, "_down", new d());
    __publicField(this, "_worldMatrix");
    __publicField(this, "_targetPos");
    __publicField(this, "static", false);
    __publicField(this, "depthOrder", 0);
    this._worldMatrix = new P(true), this.index = this._worldMatrix.index, this.index2 = this._worldMatrix.index * ee.stateStruct, this._localPos = new d(), this._localRot = new d(), this._localRotQuat = new H(), this._localScale = new d(1, 1, 1), ee.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z), ee.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z), ee.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z);
  }
  get localChange() {
    return ee.matrixStateBuffer[this.index2] != 0;
  }
  set localChange(e) {
    ee.matrixStateBuffer[this.index2] = e ? 1 : 0;
  }
  get targetPos() {
    return this._targetPos;
  }
  set targetPos(e) {
    this._targetPos = e;
  }
  get parent() {
    return this._parent;
  }
  set parent(e) {
    var _a3;
    let t = (_a3 = this._parent) == null ? void 0 : _a3.object3D;
    if (this._parent = e, this.depthOrder = e ? e.depthOrder + 1 : 0, ee.setParent(this.index, e ? e.worldMatrix.index : -1, this.depthOrder), this.localChange = true, this.object3D) {
      let r = e ? e.scene3D : null;
      r ? (this._scene3d = r, this.object3D.components.forEach((i) => {
        ue.appendWaitStart(i);
      })) : this.object3D.components.forEach((i) => {
        i.__stop();
      });
      for (let i of this.object3D.entityChildren)
        i.transform.parent = e ? this : null;
      this.object3D.components.forEach((i) => {
        var _a4, _b;
        (_b = i.onParentChange) == null ? void 0 : _b.call(i, t, (_a4 = this._parent) == null ? void 0 : _a4.object3D);
      });
    }
    this.notifyLocalChange();
  }
  set enable(e) {
    this.transform._scene3d && e ? super.enable = true : super.enable = false;
    for (let t of this.object3D.entityChildren)
      t.transform.enable = e;
  }
  get enable() {
    return this._enable;
  }
  get scene3D() {
    return this._scene3d;
  }
  set scene3D(e) {
    this._scene3d = e;
  }
  get view3D() {
    return this._scene3d && this._scene3d.view ? this._scene3d.view : null;
  }
  awake() {
  }
  start() {
  }
  stop() {
  }
  notifyLocalChange() {
    if (this.localChange = true, this.object3D) {
      let e = this.object3D.entityChildren, t = 0, r = e.length;
      for (t = 0; t < r; t++)
        e[t].transform.notifyLocalChange();
    }
    this.eventDispatcher.dispatchEvent(this.eventLocalChange);
  }
  get up() {
    return this.worldMatrix.transformVector(d.UP, this._up), this._up;
  }
  set up(e) {
    this._up.copyFrom(e), Ze.fromToRotation(d.UP, this._up, H.HELP_0), this.transform.localRotQuat = H.HELP_0;
  }
  get down() {
    return this.worldMatrix.transformVector(d.DOWN, this._down), this._down;
  }
  set down(e) {
    var _a3;
    this._down.copyFrom(e), Ze.fromToRotation(d.DOWN, this._down, H.HELP_0), this.transform.localRotQuat = H.HELP_0, this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange);
  }
  get forward() {
    return this.worldMatrix.transformVector(d.FORWARD, this._forward), this._forward;
  }
  set forward(e) {
    var _a3;
    this._forward.copyFrom(e), Ze.fromToRotation(d.FORWARD, this._forward, H.HELP_0), this.transform.localRotQuat = H.HELP_0, this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange);
  }
  get back() {
    return this.worldMatrix.transformVector(d.BACK, this._back), this._back;
  }
  set back(e) {
    this._back.copyFrom(e), Ze.fromToRotation(d.BACK, this._back, H.HELP_0), this.transform.localRotQuat = H.HELP_0;
  }
  get left() {
    return this.worldMatrix.transformVector(d.neg_X_AXIS, this._left), this._left;
  }
  set left(e) {
    this._left.copyFrom(e), Ze.fromToRotation(d.LEFT, this._left, H.HELP_0), this.transform.localRotQuat = H.HELP_0;
  }
  get right() {
    return this.worldMatrix.transformVector(d.X_AXIS, this._right), this._right;
  }
  set right(e) {
    var _a3;
    this._right.copyFrom(e), Ze.fromToRotation(d.RIGHT, this._right, H.HELP_0), this.transform.localRotQuat = H.HELP_0, this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange);
  }
  get localRotQuat() {
    return this._localRotQuat;
  }
  set localRotQuat(e) {
    var _a3;
    (e.x != this._localRotQuat.x || e.y != this._localRotQuat.y || e.z != this._localRotQuat.z || e.w != this._localRotQuat.w) && (this._localRotQuat.copyFrom(e), this._localRotQuat.getEulerAngles(this._localRot), ee.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z), this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange));
  }
  notifyChange() {
    var _a3, _b, _c2;
    this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), (_b = this.onScaleChange) == null ? void 0 : _b.call(this), (_c2 = this.onPositionChange) == null ? void 0 : _c2.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange), this.eventPositionChange && this.eventDispatcher.dispatchEvent(this.eventPositionChange), this.eventScaleChange && this.eventDispatcher.dispatchEvent(this.eventScaleChange);
  }
  get worldMatrix() {
    return this.updateWorldMatrix(), this._worldMatrix;
  }
  updateWorldMatrix(e = false) {
    (this.localChange || e) && (this.parent ? (fa(this._localRot, this._localPos, this._localScale, this._worldMatrix), hl(this._worldMatrix, this.parent.worldMatrix, this._worldMatrix)) : fa(this._localRot, this._localPos, this._localScale, this._worldMatrix), this.localChange = false);
  }
  updateChildTransform() {
    let e = this;
    if (e.localChange && e.updateWorldMatrix(), e.object3D.numChildren > 0)
      for (const t of e.object3D.entityChildren)
        t.transform.updateChildTransform();
  }
  lookTarget(e, t = d.UP) {
    this.lookAt(this.transform.worldPosition, e, t);
  }
  lookAt(e, t, r = d.UP) {
    this._targetPos || (this._targetPos = new d()), this._targetPos.copyFrom(t), this.localPosition = e, P.helpMatrix.lookAt(e, t, r), P.helpMatrix.invert();
    var i = P.helpMatrix.decompose(Zt.QUATERNION);
    this.localRotQuat = H.CALCULATION_QUATERNION.copyFrom(i[1]);
  }
  decomposeFromMatrix(e, t = "eulerAngles") {
    let r = e.decompose(t), i = this.transform;
    return i.localRotQuat.copyFrom(r[1]), i.localRotQuat = i.localRotQuat, i.localPosition.copyFrom(r[0]), i.localPosition = i.localPosition, i.localScale.copyFrom(r[2]), i.localScale = i.localScale, this;
  }
  cloneTo(e) {
    e.transform.localPosition = this.localPosition, e.transform.localRotation = this.localRotation, e.transform.localScale = this.localScale;
  }
  set x(e) {
    var _a3;
    this._localPos.x != e && (this._localPos.x = e, ee.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z), this.notifyLocalChange(), (_a3 = this.onPositionChange) == null ? void 0 : _a3.call(this), this.eventPositionChange && this.eventDispatcher.dispatchEvent(this.eventPositionChange));
  }
  get x() {
    return this._localPos.x;
  }
  set y(e) {
    var _a3;
    this._localPos.y != e && (this._localPos.y = e, ee.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z), this.notifyLocalChange(), (_a3 = this.onPositionChange) == null ? void 0 : _a3.call(this), this.eventPositionChange && this.eventDispatcher.dispatchEvent(this.eventPositionChange));
  }
  get y() {
    return this._localPos.y;
  }
  set z(e) {
    var _a3;
    this._localPos.z != e && (this._localPos.z = e, ee.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z), this.notifyLocalChange(), (_a3 = this.onPositionChange) == null ? void 0 : _a3.call(this), this.eventPositionChange && this.eventDispatcher.dispatchEvent(this.eventPositionChange));
  }
  get z() {
    return this._localPos.z;
  }
  set scaleX(e) {
    var _a3;
    this._localScale.x != e && (this._localScale.x = e, ee.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z), this.notifyLocalChange(), (_a3 = this.onScaleChange) == null ? void 0 : _a3.call(this), this.eventScaleChange && this.eventDispatcher.dispatchEvent(this.eventScaleChange));
  }
  get scaleX() {
    return this._localScale.x;
  }
  set scaleY(e) {
    var _a3;
    this._localScale.y != e && (this._localScale.y = e, ee.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z), this.notifyLocalChange(), (_a3 = this.onScaleChange) == null ? void 0 : _a3.call(this), this.eventScaleChange && this.eventDispatcher.dispatchEvent(this.eventScaleChange));
  }
  get scaleY() {
    return this._localScale.y;
  }
  set scaleZ(e) {
    var _a3;
    this._localScale.z != e && (this._localScale.z = e, ee.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z), this.notifyLocalChange(), (_a3 = this.onScaleChange) == null ? void 0 : _a3.call(this), this.eventScaleChange && this.eventDispatcher.dispatchEvent(this.eventScaleChange));
  }
  get scaleZ() {
    return this._localScale.z;
  }
  set rotationX(e) {
    var _a3;
    this._localRot.x != e && (this._localRot.x = e, ee.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z), this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange));
  }
  get rotationX() {
    return this._localRot.x;
  }
  set rotationY(e) {
    var _a3;
    this._localRot.y != e && (this._localRot.y = e, ee.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z), this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange));
  }
  get rotationY() {
    return this._localRot.y;
  }
  set rotationZ(e) {
    var _a3;
    this._localRot.z != e && (this._localRot.z = e, ee.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z), this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange));
  }
  get rotationZ() {
    return this._localRot.z;
  }
  get worldPosition() {
    return this.localChange && this.updateWorldMatrix(), this._worldMatrix.position;
  }
  set localPosition(e) {
    var _a3;
    this._localPos.copyFrom(e), ee.setTranslate(this.index, e.x, e.y, e.z), this.notifyLocalChange(), (_a3 = this.onPositionChange) == null ? void 0 : _a3.call(this), this.eventPositionChange && this.eventDispatcher.dispatchEvent(this.eventPositionChange);
  }
  get localPosition() {
    return this._localPos;
  }
  set localRotation(e) {
    var _a3;
    ee.setRotation(this.index, e.x, e.y, e.z), this._localRot.copyFrom(e), this.notifyLocalChange(), (_a3 = this.onRotationChange) == null ? void 0 : _a3.call(this), this.eventRotationChange && this.eventDispatcher.dispatchEvent(this.eventRotationChange);
  }
  get localRotation() {
    return this._localRot;
  }
  set localScale(e) {
    var _a3;
    ee.setScale(this.index, e.x, e.y, e.z), this._localScale.copyFrom(e), this.notifyLocalChange(), (_a3 = this.onScaleChange) == null ? void 0 : _a3.call(this), this.eventScaleChange && this.eventDispatcher.dispatchEvent(this.eventScaleChange);
  }
  get localScale() {
    return this._localScale;
  }
  get localDetailScale() {
    return this._localDetailScale;
  }
  set localDetailScale(e) {
    this._localDetailScale = e, ee.setContinueScale(this.index, e.x, e.y, e.z);
  }
  get localDetailRot() {
    return this._localDetailRot;
  }
  set localDetailRot(e) {
    this._localDetailRot = e, ee.setContinueRotation(this.index, e.x, e.y, e.z);
  }
  get localDetailPos() {
    return this._localDetailPos;
  }
  set localDetailPos(e) {
    this._localDetailPos = e, ee.setContinueTranslate(this.index, e.x, e.y, e.z);
  }
  beforeDestroy(e) {
    this.parent && this.parent.object3D && this.parent.object3D.removeChild(this.object3D), super.beforeDestroy(e);
  }
  destroy() {
    super.destroy(), this.scene3D = null, this.eventPositionChange = null, this.eventRotationChange = null, this.eventScaleChange = null, this.onPositionChange = null, this.onRotationChange = null, this.onScaleChange = null, this._scene3d = null, this._parent = null, this._localPos = null, this._localRot = null, this._localRotQuat = null, this._localScale = null, this._forward = null, this._back = null, this._right = null, this._left = null, this._up = null, this._down = null, this.localChange = null, this._targetPos = null;
  }
};
__publicField(_ht, "LIMIT", 1);
__publicField(_ht, "COMPONENT_NAME", "UUTransform");
__publicField(_ht, "COMPONENT_TYPE", "Transform");
__publicField(_ht, "POSITION_ONCHANGE", "POSITION_ONCHANGE");
__publicField(_ht, "ROTATION_ONCHANGE", "ROTATION_ONCHANGE");
__publicField(_ht, "SCALE_ONCHANGE", "SCALE_ONCHANGE");
__publicField(_ht, "PARENT_ONCHANGE", "PARENT_ONCHANGE");
__publicField(_ht, "CHILDREN_ONCHANGE", "CHILDREN_ONCHANGE");
__publicField(_ht, "ADD_ONCHANGE", "ADD_ONCHANGE");
__publicField(_ht, "LOCAL_ONCHANGE", "LOCAL_ONCHANGE");
var ht = _ht;
var _pa = class _pa {
  static genMeshBounds(e, t) {
    let r = this.genMeshMinVector, i = this.genMeshMaxVector, a = this.genMeshVectorList8;
    t || (t = new ge(d.ZERO, d.ZERO)), t.setFromMinMax(this.maxVector, this.minVector);
    let o = e.getComponents(J);
    for (const n of o)
      if (n && n.geometry) {
        let l = n.object3D.transform.worldMatrix;
        r.copy(n.geometry.bounds.min), i.copy(n.geometry.bounds.max), a[0].set(r.x, r.y, r.z), a[1].set(r.x, r.y, i.z), a[2].set(r.x, i.y, r.z), a[3].set(r.x, i.y, i.z), a[4].set(i.x, r.y, r.z), a[5].set(i.x, r.y, i.z), a[6].set(i.x, i.y, r.z), a[7].set(i.x, i.y, i.z);
        for (const h of a)
          l.transformPoint(h, h), t.expandByPoint(h);
      }
    return i.copyFrom(t.max), r.copyFrom(t.min), t.setFromMinMax(r, i), t;
  }
  static transformBound(e, t, r) {
    let i = this.genMeshMinVector.copyFrom(t.min), a = this.genMeshMaxVector.copyFrom(t.max), o = this.genMeshVectorList8;
    r || (r = new ge(d.ZERO, d.ZERO)), r.setFromMinMax(this.maxVector, this.minVector), o[0].set(i.x, i.y, i.z), o[1].set(i.x, i.y, a.z), o[2].set(i.x, a.y, i.z), o[3].set(i.x, a.y, a.z), o[4].set(a.x, i.y, i.z), o[5].set(a.x, i.y, a.z), o[6].set(a.x, a.y, i.z), o[7].set(a.x, a.y, a.z);
    for (const n of o)
      e.transformPoint(n, n), r.expandByPoint(n);
    return a.copyFrom(r.max), i.copyFrom(r.min), r.setFromMinMax(i, a), r;
  }
};
__publicField(_pa, "maxVector", new d(Number.MAX_VALUE * 0.1, Number.MAX_VALUE * 0.1, Number.MAX_VALUE * 0.1));
__publicField(_pa, "minVector", _pa.maxVector.clone().multiplyScalar(-1));
__publicField(_pa, "genMeshMaxVector", d.ZERO.clone());
__publicField(_pa, "genMeshMinVector", d.ZERO.clone());
__publicField(_pa, "genMeshVectorList8", [new d(), new d(), new d(), new d(), new d(), new d(), new d(), new d()]);
var pa = _pa;
var fl = class extends qt {
  constructor() {
    super();
    __publicField(this, "name", "");
    __publicField(this, "_instanceID", "");
    __publicField(this, "_numChildren");
    __publicField(this, "transform");
    __publicField(this, "renderNode");
    __publicField(this, "entityChildren");
    __publicField(this, "components");
    __publicField(this, "waitDisposeComponents");
    __publicField(this, "_bound");
    __publicField(this, "_boundWorld");
    __publicField(this, "_isBoundChange", true);
    __publicField(this, "_dispose", false);
    this.entityChildren = [], this.components = /* @__PURE__ */ new Map(), this._instanceID = bs().toString(), this.waitDisposeComponents = [];
  }
  get instanceID() {
    return this._instanceID;
  }
  getObjectByName(e) {
    if (e.indexOf("/") >= 0) {
      let r = e.split("/"), i = this;
      for (; r.length > 0 && i; ) {
        let a = r.shift();
        if (i = i.getChildByName(a, false), !i)
          return null;
      }
      return i;
    } else
      return this.getChildByName(e, false);
  }
  get numChildren() {
    return this._numChildren;
  }
  addChild(e) {
    if (e == null)
      throw new Error("child is null!");
    if (e === this)
      throw new Error("child is self!");
    return this.entityChildren.indexOf(e) == -1 ? (e.removeFromParent(), e.transform.parent = this.transform, this.entityChildren.push(e), this._numChildren = this.entityChildren.length, e) : null;
  }
  removeChild(e) {
    if (e === null)
      return;
    if (e === this)
      throw new Error("add child is self!");
    let t = this.entityChildren.indexOf(e);
    t != -1 && (this.entityChildren.splice(t, 1), e.transform.parent = null, this._numChildren = this.entityChildren.length);
  }
  removeAllChild() {
    for (; this.numChildren > 0; )
      this.removeChild(this.entityChildren[0]);
  }
  removeSelf() {
    return this.removeFromParent();
  }
  removeChildByIndex(e) {
    e >= 0 && e < this.entityChildren.length ? this.removeChild(this.entityChildren[e]) : console.error("remove child by index , index out of range");
  }
  hasChild(e) {
    return this.entityChildren.indexOf(e) != -1;
  }
  removeFromParent() {
    let e = this.transform.parent;
    return e && e.object3D && e.object3D.removeChild(this), this;
  }
  getChildByIndex(e) {
    let t = null;
    return e < this.entityChildren.length && (t = this.entityChildren[e]), t;
  }
  getChildByName(e, t = true) {
    let r = null;
    for (const i of this.entityChildren) {
      if (i.name == e)
        return r = i, r;
      if (t && (r = i.getChildByName(e, t), r))
        return r;
    }
    return r;
  }
  update() {
  }
  instantiate() {
    return null;
  }
  onTransformLocalChange(e) {
    this._isBoundChange = true;
  }
  get bound() {
    return (this._isBoundChange || !this._bound) && this.updateBound(), this._boundWorld;
  }
  set bound(e) {
    this._bound = e, this._boundWorld = this._bound.clone(), this._isBoundChange = true;
  }
  updateBound() {
    return this._bound || (this._bound = new ge(), this._boundWorld = this._bound.clone(), this._isBoundChange = true), this._isBoundChange && (pa.transformBound(this.transform.worldMatrix, this._bound, this._boundWorld), this._isBoundChange = false), this._boundWorld;
  }
  waitUpdate() {
    this._dispose ? (this.transform.parent && this.transform.parent.object3D.removeChild(this), this.components.forEach((e, t) => {
      e.enable = false, e.beforeDestroy(), e.destroy();
    }), this.components.clear()) : ue.waitStartComponent.forEach((e, t) => {
      for (; e.length > 0; ) {
        const r = e.shift();
        r.__start(), ue.waitStartComponent.delete(r.object3D);
      }
    });
  }
  destroy(e) {
    this._dispose || (this.components.forEach((t) => {
      t.beforeDestroy(e);
    }), this.components.forEach((t) => {
      t.destroy(e);
    }), this.components.clear(), this.entityChildren.forEach((t) => {
      t.destroy(e);
    }), this.removeAllChild(), this.transform.parent = null, this._dispose = true, super.destroy());
  }
};
var Cd = Object.defineProperty;
var Sd = Object.getOwnPropertyDescriptor;
var yd = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Sd(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Cd(e, t, i), i;
};
var Y = class extends fl {
  constructor() {
    super();
    __publicField(this, "_isScene3D");
    __publicField(this, "prefabRef");
    __publicField(this, "serializeTag");
    this.transform = this.addComponent(ht), this.transform.eventDispatcher.addEventListener(ht.LOCAL_ONCHANGE, this.onTransformLocalChange, this);
  }
  get isScene3D() {
    return this._isScene3D;
  }
  forChild(s) {
    this.entityChildren.forEach((e) => {
      s(e), e.forChild(s);
    });
  }
  addComponent(s, e) {
    if (!this.components.has(s)) {
      let t = new s();
      return t.object3D = this, this.components.set(s, t), t.__init(e), ue.appendWaitStart(t), t;
    }
    return null;
  }
  getOrAddComponent(s) {
    let e = this.components.get(s);
    return e || (e = this.addComponent(s)), e;
  }
  removeComponent(s) {
    if (this.components.has(s)) {
      let e = this.components.get(s);
      ue.removeWaitStart(this, e), this.components.delete(s), e.__stop(), e.beforeDestroy(), e.destroy();
    }
  }
  hasComponent(s) {
    return this.components.has(s);
  }
  getComponent(s) {
    return this.components.get(s);
  }
  getComponentFromParent(s) {
    if (!this.parent)
      return null;
    let e = this.parent.object3D.getComponent(s);
    return e || this.parent.object3D.getComponentFromParent(s);
  }
  getComponentsInChild(s) {
    let e = [], t = this.components.get(s);
    t && e.push(t);
    for (let r = 0; r < this.entityChildren.length; r++) {
      let a = this.entityChildren[r].getComponentsInChild(s);
      e.push(...a);
    }
    return e;
  }
  getComponents(s, e, t) {
    e || (e = []);
    let r = this.getComponent(s);
    r && (r.enable || t) && e.push(r);
    for (let i = 0, a = this.entityChildren.length; i < a; i++) {
      let o = this.entityChildren[i];
      o && o instanceof Y && o.getComponents(s, e, t);
    }
    return e;
  }
  getComponentsExt(s, e, t) {
    e || (e = []);
    let r = this.components.get(s);
    if (r && (r.enable || t))
      e.push(r);
    else
      for (const i of this.entityChildren)
        i instanceof Y && i.getComponentsExt(s, e, t);
    return e;
  }
  getComponentsByProperty(s, e, t = true, r, i) {
    r || (r = []);
    let a;
    for (const o of this.components.values())
      o && (o.enable || i) && o[s] === e && (r.push(o), a = true);
    if (!(a && t))
      for (const o of this.entityChildren)
        o instanceof Y && o.getComponentsByProperty(s, e, t, r, i);
    return r;
  }
  clone() {
    return this.instantiate();
  }
  instantiate() {
    let s = new Y();
    return s.name = this.name, s.serializeTag = this.serializeTag, s.prefabRef = this.prefabRef, this.entityChildren.forEach((e, t) => {
      let r = e.instantiate();
      s.addChild(r);
    }), this.components.forEach((e, t) => {
      e.cloneTo(s);
    }), s;
  }
  get localPosition() {
    return this.transform.localPosition;
  }
  set localPosition(s) {
    this.transform.localPosition = s;
  }
  get localRotation() {
    return this.transform.localRotation;
  }
  set localRotation(s) {
    this.transform.localRotation = s;
  }
  get localScale() {
    return this.transform.localScale;
  }
  set localScale(s) {
    this.transform.localScale = s;
  }
  get localQuaternion() {
    return this.transform.localRotQuat;
  }
  set localQuaternion(s) {
    this.transform.localRotQuat = s;
  }
  notifyChange() {
    this.transform.notifyChange();
  }
  get parent() {
    return this.transform.parent;
  }
  get parentObject() {
    return this.transform.parent.object3D;
  }
  set x(s) {
    this.transform.x = s;
  }
  get x() {
    return this.transform.x;
  }
  set y(s) {
    this.transform.y = s;
  }
  get y() {
    return this.transform.y;
  }
  set z(s) {
    this.transform.z = s;
  }
  get z() {
    return this.transform.z;
  }
  set scaleX(s) {
    this.transform.scaleX = s;
  }
  get scaleX() {
    return this.transform.scaleX;
  }
  set scaleY(s) {
    this.transform.scaleY = s;
  }
  get scaleY() {
    return this.transform.scaleY;
  }
  set scaleZ(s) {
    this.transform.scaleZ = s;
  }
  get scaleZ() {
    return this.transform.scaleZ;
  }
  set rotationX(s) {
    this.transform.rotationX = s;
  }
  get rotationX() {
    return this.transform.rotationX;
  }
  set rotationY(s) {
    this.transform.rotationY = s;
  }
  get rotationY() {
    return this.transform.rotationY;
  }
  set rotationZ(s) {
    this.transform.rotationZ = s;
  }
  get rotationZ() {
    return this.transform.rotationZ;
  }
  fixedUpdate() {
  }
  lateUpdate() {
  }
  traverse(s) {
    s(this);
    for (let e = 0, t = this.entityChildren.length; e < t; e++) {
      let r = this.entityChildren[e];
      r instanceof Y && r.traverse(s);
    }
  }
  destroy(s) {
    this.transform.eventDispatcher.removeEventListener(ht.LOCAL_ONCHANGE, this.onTransformLocalChange, this), super.destroy(s);
  }
};
Y = yd([wd], Y);
function wd(s, e) {
  return class extends Y {
    set active(t) {
      this.transform.enable = t > 0;
    }
    get active() {
      return this.transform.enable ? 1 : 0;
    }
    get materialColor() {
      var _a3, _b;
      return (_b = (_a3 = this.getComponent(J)) == null ? void 0 : _a3.material) == null ? void 0 : _b.shader.getDefaultColorShader().baseColor;
    }
    set materialColor(t) {
      var _a3;
      let r = (_a3 = this.getComponent(J)) == null ? void 0 : _a3.material;
      r && (r.shader.getDefaultColorShader().baseColor = t);
    }
    notifyMaterialColorChange(t, r) {
      var _a3, _b;
      (_b = (_a3 = this.getComponent(J).materials) == null ? void 0 : _a3[t]) == null ? void 0 : _b.shader.getDefaultColorShader().uniforms[r].onChange();
    }
  };
}
var Me = class {
  static createCamera3DObject(e, t) {
    return this.createCamera3D(null, e, t);
  }
  static createCamera3D(e, t, r) {
    return e || (e = new Y()), t && t.addChild(e), r && (e.name = r), e.getOrAddComponent(Wr);
  }
  static UnProjection(e, t, r = 1, i) {
    let a = new d(e, t, 0), o = 1, n = d.HELP_0, l = w.canvas.offsetLeft, h = w.canvas.offsetTop, u = w.canvas.clientWidth, c = w.canvas.clientHeight;
    n.x = ((a.x - l) * o / u - 0.5) * 2, n.y = -((a.y - h) * o / c - 0.5) * 2, n.z = r;
    let f = new d(0, 0, 0), g = P.helpMatrix2;
    g.copyFrom(i.projectionMatrix), g.invert();
    let m = P.helpMatrix;
    return m.identity(), m.multiply(g), m.multiply(i.transform.worldMatrix), m.perspectiveMultiplyPoint3(n, f), f;
  }
  static Projection(e, t, r) {
    let i = r || new d(0, 0, 0), a = P.helpMatrix;
    a.copyFrom(t.viewMatrix), a.multiply(t.projectionMatrix), a.perspectiveMultiplyPoint3(e, i);
    let o = w.canvas.clientWidth / 2, n = w.canvas.clientHeight / 2;
    return i.x = i.x * o + o, i.y = n - i.y * n, i;
  }
  static UnProjection2(e, t, r, i, a) {
    let o = a || new d(0, 0, 0), n = P.helpMatrix;
    n.copyFrom(i.pvMatrixInv);
    let l = w.canvas.clientWidth / 2, h = w.canvas.clientHeight / 2;
    return o.x = (e - l) / l, o.y = (h - t) / h, o.z = r, n.perspectiveMultiplyPoint3(o, o), o;
  }
};
var _lt = class _lt {
  static init() {
    this.directionLightList = /* @__PURE__ */ new Map(), this.pointLightList = /* @__PURE__ */ new Map(), this.shadowLights = /* @__PURE__ */ new Map();
  }
  static createBuffer(e) {
    if (!this.shadowLights.has(e.scene)) {
      let t = new Float32Array(16);
      this.shadowLights.set(e.scene, t);
    }
  }
  static getShadowLightList(e) {
    if (!e.transform.view3D)
      return null;
    if (e.lightData.lightType == Pe.DirectionLight) {
      let t = this.directionLightList.get(e.transform.view3D.scene);
      return t || (t = [], this.directionLightList.set(e.transform.view3D.scene, t)), t;
    } else if (e.lightData.lightType == Pe.PointLight) {
      let t = this.pointLightList.get(e.transform.view3D.scene);
      return t || (t = [], this.pointLightList.set(e.transform.view3D.scene, t)), t;
    } else if (e.lightData.lightType == Pe.SpotLight) {
      let t = this.pointLightList.get(e.transform.view3D.scene);
      return t || (t = [], this.pointLightList.set(e.transform.view3D.scene, t)), t;
    }
  }
  static getShadowLightWhichScene(e, t) {
    if (t == Pe.DirectionLight) {
      let r = this.directionLightList.get(e);
      return r || (r = [], this.directionLightList.set(e, r)), r;
    } else if (t == Pe.PointLight) {
      let r = this.pointLightList.get(e);
      return r || (r = [], this.pointLightList.set(e, r)), r;
    }
  }
  static getDirectShadowLightWhichScene(e) {
    let t = this.directionLightList.get(e);
    return t || (t = [], this.directionLightList.set(e, t)), t;
  }
  static getPointShadowLightWhichScene(e) {
    let t = this.pointLightList.get(e);
    return t || (t = [], this.pointLightList.set(e, t)), t;
  }
  static addShadowLight(e) {
    if (!e.transform.view3D)
      return null;
    let t = e.transform.view3D.scene;
    if (e.lightData.lightType == Pe.DirectionLight) {
      let r = this.directionLightList.get(t);
      if (r || (r = [], this.directionLightList.set(t, r)), !e.shadowCamera) {
        e.shadowCamera = Me.createCamera3DObject(null, "shadowCamera"), e.shadowCamera.isShadowCamera = true;
        let i = -1e3;
        e.shadowCamera.orthoOffCenter(i, -i, i, -i, 1, 1e4);
      }
      return r.indexOf(e) == -1 && r.push(e), r;
    } else if (e.lightData.lightType == Pe.PointLight || e.lightData.lightType == Pe.SpotLight) {
      let r = this.pointLightList.get(t);
      return r && r.length >= 8 || (r || (r = [], this.pointLightList.set(t, r)), r.indexOf(e) == -1 && r.push(e)), r;
    }
  }
  static removeShadowLight(e) {
    if (e.lightData.castShadowIndex = -1, !e.transform.view3D)
      return null;
    if (e.lightData.lightType == Pe.DirectionLight) {
      let t = this.directionLightList.get(e.transform.view3D.scene);
      if (t) {
        let r = t.indexOf(e);
        r != -1 && t.splice(r, 1);
      }
      return e.lightData.castShadowIndex = -1, t;
    } else if (e.lightData.lightType == Pe.PointLight || e.lightData.lightType == Pe.SpotLight) {
      let t = this.pointLightList.get(e.transform.view3D.scene);
      if (t) {
        let r = t.indexOf(e);
        r != -1 && t.splice(r, 1);
      }
      return e.lightData.castShadowIndex = -1, t;
    }
  }
  static update(e) {
    let t = oe.getCameraGroup(e.camera), r = this.shadowLights.get(e.scene), i = _lt.directionLightList.get(e.scene), a = _lt.pointLightList.get(e.scene), o = 0, n = 0, l = 0, h = 0;
    if (r.fill(0), i) {
      let u = 0;
      for (let c = 0; c < i.length; c++) {
        const f = i[c];
        r[c] = f.lightData.index, f.lightData.castShadowIndex = u++;
      }
      n = i.length;
    }
    if (t.dirShadowStart = o, t.dirShadowEnd = n, a) {
      l = n;
      let u = 0;
      for (let c = l; c < a.length; c++) {
        const f = a[c];
        r[c] = f.lightData.index, f.lightData.castShadowIndex = u++;
      }
      h = l + a.length;
    }
    t.pointShadowStart = l, t.pointShadowEnd = h, t.shadowLights = r;
  }
};
__publicField(_lt, "maxNumDirectionShadow", 8);
__publicField(_lt, "maxNumPointShadow", 8);
__publicField(_lt, "directionLightList");
__publicField(_lt, "pointLightList");
__publicField(_lt, "shadowLights");
var lt = _lt;
var Gs = class {
  static getGlobalDataBindGroupLayout() {
    if (this._globalDataBindGroupLayout)
      return this._globalDataBindGroupLayout;
    let e = [];
    return e.push({ binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }), e.push({ binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }), this._globalDataBindGroupLayout = w.device.createBindGroupLayout({ entries: e }), this._globalDataBindGroupLayout;
  }
};
__publicField(Gs, "_globalDataBindGroupLayout");
var dl = class {
  constructor(e) {
    __publicField(this, "uuid");
    __publicField(this, "usage");
    __publicField(this, "globalBindGroup");
    __publicField(this, "uniformGPUBuffer");
    __publicField(this, "matrixBindGroup");
    __publicField(this, "uniformByteLength");
    __publicField(this, "matrixesByteLength");
    __publicField(this, "shadowMatrixRaw", new Float32Array(8 * 16));
    __publicField(this, "csmMatrixRaw", new Float32Array(Ct.Cascades * 16));
    __publicField(this, "csmShadowBias", new Float32Array(4));
    __publicField(this, "shadowLights", new Float32Array(16));
    __publicField(this, "dirShadowStart", 0);
    __publicField(this, "dirShadowEnd", 0);
    __publicField(this, "pointShadowStart", 0);
    __publicField(this, "pointShadowEnd", 0);
    this.uuid = gt(), this.usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, this.uniformGPUBuffer = new ft(8192), this.uniformGPUBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, this.matrixBindGroup = e, this.createBindGroup();
  }
  createBindGroup() {
    this.uniformByteLength = this.uniformGPUBuffer.memory.shareDataBuffer.byteLength, this.matrixesByteLength = P.blockBytes * P.maxCount, this.globalBindGroup = w.device.createBindGroup({ label: "global_bindGroupLayout", layout: Gs.getGlobalDataBindGroupLayout(), entries: [{ binding: 0, resource: { buffer: this.uniformGPUBuffer.buffer, offset: 0, size: this.uniformByteLength } }, { binding: 1, resource: { buffer: this.matrixBindGroup.matrixBufferDst.buffer, offset: 0, size: this.matrixesByteLength } }] });
  }
  setCamera(e) {
    this.uniformGPUBuffer.setMatrix("_projectionMatrix", e.projectionMatrix), this.uniformGPUBuffer.setMatrix("_viewMatrix", e.viewMatrix), this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix", e.transform.worldMatrix), this.uniformGPUBuffer.setMatrix("pvMatrixInv", e.projectionMatrixInv);
    let t = lt.getDirectShadowLightWhichScene(e.transform.scene3D);
    this.csmShadowBias.fill(1e-4), this.shadowMatrixRaw.fill(0), this.csmMatrixRaw.fill(0);
    for (let o = 0; o < 8; o++)
      if (o < t.length) {
        let n = t[o].shadowCamera;
        this.shadowMatrixRaw.set(n.pvMatrix.rawData, o * 16);
      } else
        this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData, o * 16);
    this.uniformGPUBuffer.setFloat32Array("shadowMatrix", this.shadowMatrixRaw);
    let r = p.setting.shadow.shadowSize;
    if (Ct.Cascades > 1 && e.enableCSM && t[0])
      for (let o = 0; o < Ct.Cascades; o++) {
        let n = e.csm.children[o].shadowCamera;
        this.csmMatrixRaw.set(n.pvMatrix.rawData, o * 16), this.csmShadowBias[o] = e.getCSMShadowBias(o, r);
      }
    this.uniformGPUBuffer.setFloat32Array("csmShadowBias", this.csmShadowBias), this.uniformGPUBuffer.setFloat32Array("csmMatrix", this.csmMatrixRaw), this.uniformGPUBuffer.setFloat32Array("shadowLights", this.shadowLights), this.uniformGPUBuffer.setVector3("CameraPos", e.transform.worldPosition), this.uniformGPUBuffer.setFloat("frame", ce.frame), this.uniformGPUBuffer.setFloat("time", ce.frame), this.uniformGPUBuffer.setFloat("delta", ce.delta), this.uniformGPUBuffer.setFloat("shadowBias", e.getShadowBias(r)), this.uniformGPUBuffer.setFloat("skyExposure", p.setting.sky.skyExposure), this.uniformGPUBuffer.setFloat("renderPassState", p.setting.render.renderPassState), this.uniformGPUBuffer.setFloat("quadScale", p.setting.render.quadScale), this.uniformGPUBuffer.setFloat("hdrExposure", p.setting.render.hdrExposure), this.uniformGPUBuffer.setInt32("renderState_left", p.setting.render.renderState_left), this.uniformGPUBuffer.setInt32("renderState_right", p.setting.render.renderState_right), this.uniformGPUBuffer.setFloat("renderState_split", p.setting.render.renderState_split);
    let i = p.inputSystem.mouseX * w.pixelRatio, a = p.inputSystem.mouseY * w.pixelRatio;
    this.uniformGPUBuffer.setFloat("mouseX", i), this.uniformGPUBuffer.setFloat("mouseY", a), this.uniformGPUBuffer.setFloat("windowWidth", w.windowWidth), this.uniformGPUBuffer.setFloat("windowHeight", w.windowHeight), this.uniformGPUBuffer.setFloat("near", e.near), this.uniformGPUBuffer.setFloat("far", e.far), this.uniformGPUBuffer.setFloat("pointShadowBias", p.setting.shadow.pointShadowBias), this.uniformGPUBuffer.setFloat("shadowMapSize", r), this.uniformGPUBuffer.setFloat("shadowSoft", p.setting.shadow.shadowSoft), this.uniformGPUBuffer.setFloat("enableCSM", e.enableCSM ? 1 : 0), this.uniformGPUBuffer.setFloat("csmMargin", p.setting.shadow.csmMargin), this.uniformGPUBuffer.setInt32("nDirShadowStart", this.dirShadowStart), this.uniformGPUBuffer.setInt32("nDirShadowEnd", this.dirShadowEnd), this.uniformGPUBuffer.setInt32("nPointShadowStart", this.pointShadowStart), this.uniformGPUBuffer.setInt32("nPointShadowEnd", this.pointShadowEnd), this.uniformGPUBuffer.setInt32("empty1", 0), this.uniformGPUBuffer.setInt32("empty2", 0), this.uniformGPUBuffer.setInt32("empty3", 0), this.uniformGPUBuffer.setVector4Array("frustumPlanes", e.frustum.planes), this.uniformGPUBuffer.apply();
  }
  setShadowCamera(e) {
    this.uniformGPUBuffer.setMatrix("_projectionMatrix", e.projectionMatrix), this.uniformGPUBuffer.setMatrix("_viewMatrix", e.viewMatrix), this.uniformGPUBuffer.setMatrix("_pvMatrix", e.pvMatrix), this.uniformGPUBuffer.setMatrix("pvMatrixInv", e.projectionMatrixInv), this.csmShadowBias.fill(1e-4), this.shadowMatrixRaw.fill(0), this.csmMatrixRaw.fill(0), this.uniformGPUBuffer.setFloat32Array("shadowCamera", this.shadowMatrixRaw), this.uniformGPUBuffer.setFloat32Array("csmShadowBias", this.csmShadowBias), this.uniformGPUBuffer.setFloat32Array("csmMatrix", this.csmMatrixRaw), this.uniformGPUBuffer.setFloat32Array("shadowLights", this.shadowLights), this.uniformGPUBuffer.setVector3("CameraPos", e.transform.worldPosition), this.uniformGPUBuffer.setFloat("frame", ce.frame), this.uniformGPUBuffer.setFloat("time", ce.frame), this.uniformGPUBuffer.setFloat("delta", ce.delta), this.uniformGPUBuffer.setFloat("shadowBias", p.setting.shadow.shadowBias), this.uniformGPUBuffer.setFloat("skyExposure", p.setting.sky.skyExposure), this.uniformGPUBuffer.setFloat("renderPassState", p.setting.render.renderPassState), this.uniformGPUBuffer.setFloat("quadScale", p.setting.render.quadScale), this.uniformGPUBuffer.setFloat("hdrExposure", p.setting.render.hdrExposure), this.uniformGPUBuffer.setInt32("renderState_left", p.setting.render.renderState_left), this.uniformGPUBuffer.setInt32("renderState_right", p.setting.render.renderState_right), this.uniformGPUBuffer.setFloat("renderState_split", p.setting.render.renderState_split);
    let t = p.inputSystem.mouseX * w.pixelRatio, r = p.inputSystem.mouseY * w.pixelRatio;
    this.uniformGPUBuffer.setFloat("mouseX", t), this.uniformGPUBuffer.setFloat("mouseY", r), this.uniformGPUBuffer.setFloat("windowWidth", w.windowWidth), this.uniformGPUBuffer.setFloat("windowHeight", w.windowHeight), this.uniformGPUBuffer.setFloat("near", e.near), this.uniformGPUBuffer.setFloat("far", e.far), this.uniformGPUBuffer.setFloat("pointShadowBias", p.setting.shadow.pointShadowBias), this.uniformGPUBuffer.setFloat("shadowMapSize", p.setting.shadow.shadowSize), this.uniformGPUBuffer.setFloat("shadowSoft", p.setting.shadow.shadowSoft), this.uniformGPUBuffer.setFloat("enableCSM", 0), this.uniformGPUBuffer.setFloat("csmMargin", p.setting.shadow.csmMargin), this.uniformGPUBuffer.setInt32("nDirShadowStart", this.dirShadowStart), this.uniformGPUBuffer.setInt32("nDirShadowEnd", this.dirShadowEnd), this.uniformGPUBuffer.setInt32("nPointShadowStart", this.pointShadowStart), this.uniformGPUBuffer.setInt32("nPointShadowEnd", this.pointShadowEnd), this.uniformGPUBuffer.apply();
  }
  setShadowLight() {
  }
};
var _Sr = class _Sr {
  constructor(e, t = 0, r = null, i = 0) {
    __publicField(this, "entities");
    __publicField(this, "box");
    __publicField(this, "subTrees", []);
    __publicField(this, "parent");
    __publicField(this, "level");
    __publicField(this, "index");
    __publicField(this, "uuid");
    __publicField(this, "__rayCastTempVector", new d());
    this.parent = r, this.box = e.clone(), this.level = i, this.index = t, this.uuid = i + "_" + t, this.entities = /* @__PURE__ */ new Map();
  }
  tryInsertEntity(e) {
    let t = e.renderer.object3D.bound;
    if (this.level == 0 || this.box.containsBox(t)) {
      this.subTrees.length == 0 && this.level < _Sr.maxSplitLevel && this.splitTree();
      let r;
      if (this.subTrees.length > 0) {
        for (let i of this.subTrees)
          if (i.tryInsertEntity(e)) {
            r = true;
            break;
          }
      }
      return r || e.enterNode(this), true;
    }
    return false;
  }
  splitTree() {
    if (this.subTrees.length == 0) {
      const e = _Sr._v1, t = this.box.extents.clone();
      let r = this.level + 1, i = 0;
      for (let a = 0; a < 2; a++)
        for (let o = 0; o < 2; o++)
          for (let n = 0; n < 2; n++) {
            const l = new ge();
            this.box.min.add(e.set(a, o, n).multiply(t), l.min), l.min.add(t, l.max), l.setFromMinMax(l.min, l.max);
            let h = new _Sr(l, i++, this, r);
            this.subTrees.push(h);
          }
    }
  }
  rayCasts(e, t) {
    if (this.level == 0 || e.intersectBox(this.box, this.__rayCastTempVector)) {
      this.entities.size > 0 && t.push(...this.entities.values());
      for (let r of this.subTrees)
        r.rayCasts(e, t);
      return true;
    }
    return false;
  }
  frustumCasts(e, t) {
    if (this.level == 0 || e.containsBox2(this.box) > 0) {
      if (this.entities.size > 0)
        for (const r of this.entities.values())
          (this.level > _Sr.autoSplitLevel || e.containsBox2(r.renderer.object3D.bound) > 0) && t.push(r);
      for (let r of this.subTrees)
        r.frustumCasts(e, t);
      return true;
    }
    return false;
  }
  getRenderNode(e, t) {
    if (this.level == 0 || e.containsBox2(this.box) > 0) {
      if (this.entities.size > 0)
        for (const r of this.entities.values())
          (this.level > _Sr.autoSplitLevel || e.containsBox2(r.renderer.object3D.bound) > 0) && (r.renderer.renderOrder < 3e3 ? t.opaqueList.push(r.renderer) : r.renderer.renderOrder >= 3e3 && t.transparentList.push(r.renderer));
      for (let r of this.subTrees)
        r.getRenderNode(e, t);
      return true;
    }
    return false;
  }
  boxCasts(e, t) {
    if (e.intersectsBox(this.box)) {
      this.entities.size > 0 && t.push(...this.entities.values());
      for (let r of this.subTrees)
        r.boxCasts(e, t);
      return true;
    }
    return false;
  }
  clean() {
    for (let e of this.entities.values())
      e.leaveNode();
    return this.entities.clear(), this;
  }
};
__publicField(_Sr, "_v1", new d());
__publicField(_Sr, "_v2", new d());
__publicField(_Sr, "maxSplitLevel", 6);
__publicField(_Sr, "autoSplitLevel", 3);
var Sr = _Sr;
var gl = class {
  constructor() {
    __publicField(this, "_pool", []);
    __publicField(this, "_worldPosition", new d());
    __publicField(this, "_viewPosition", new d());
    __publicField(this, "_zSortList", []);
  }
  pop() {
    return this._pool.pop() || {};
  }
  recycle() {
    for (let e of this._zSortList)
      e.z = 0, e.userData = null, e.obj3d = null, this._pool.push(e);
    this._zSortList.length = 0;
  }
  sort(e, t, r, i) {
    this._zSortList = [];
    for (let a of t) {
      let o = this.pop();
      o.userData = a, o.obj3d = r(a), o.z = this.worldToCameraDepth(o.obj3d, e), this._zSortList.push(o);
    }
    this._zSortList.sort((a, o) => a.z - o.z > 0 ? 1 : -1), i || (i = []);
    for (let a of this._zSortList)
      i.push(a.userData);
    return this.recycle(), i;
  }
  worldToCameraDepth(e, t) {
    t || (t = e.transform.view3D.camera);
    let r = 0;
    return t && (this._worldPosition.copyFrom(e.transform.worldPosition), t.worldToScreenPoint(this._worldPosition, this._viewPosition), r = this._viewPosition.z), r;
  }
};
var pl = new gl();
var _i = ((s) => (s[s.None = 2] = "None", s[s.StaticBatch = 4] = "StaticBatch", s[s.DynamicBatch = 8] = "DynamicBatch", s))(_i || {});
var Qs = class {
  static addMask(e, t) {
    return e | t;
  }
  static removeMask(e, t) {
    return e & ~t;
  }
  static hasMask(e, t) {
    return (e & t) != 0;
  }
};
var q = ((s) => (s[s.COLOR = 1] = "COLOR", s[s.NORMAL = 2] = "NORMAL", s[s.POSITION = 4] = "POSITION", s[s.GRAPHIC = 8] = "GRAPHIC", s[s.GI = 16] = "GI", s[s.Cluster = 32] = "Cluster", s[s.SHADOW = 64] = "SHADOW", s[s.POINT_SHADOW = 128] = "POINT_SHADOW", s[s.POST = 256] = "POST", s[s.DEPTH = 512] = "DEPTH", s[s.REFLECTION = 1024] = "REFLECTION", s))(q || {});
var Vt = class {
};
__publicField(Vt, "GLTF_NODE_INDEX_PROPERTY");
__publicField(Vt, "BASE_COLOR_UNIFORM", "u_baseColorFactor");
__publicField(Vt, "BASE_COLOR_TEXTURE_UNIFORM", "u_baseColorSampler");
__publicField(Vt, "METALROUGHNESS_UNIFORM", "u_metallicRoughnessValues");
__publicField(Vt, "METALROUGHNESS_TEXTURE_UNIFORM", "u_metallicRoughnessSampler");
__publicField(Vt, "NORMAL_TEXTURE_UNIFORM", "u_normalSampler");
__publicField(Vt, "NORMAL_SCALE_UNIFORM", "u_normalScale");
__publicField(Vt, "EMISSIVE_TEXTURE_UNIFORM", "u_emissiveSampler");
__publicField(Vt, "EMISSIVE_FACTOR_UNIFORM", "u_emissiveFactor");
__publicField(Vt, "OCCLUSION_TEXTURE_UNIFORM", "u_occlusionSampler");
__publicField(Vt, "OCCLUSION_FACTOR_UNIFORM", "u_occlusionFactor");
__publicField(Vt, "MAX_MORPH_TARGETS", 8);
__publicField(Vt, "MORPH_POSITION_PREFIX", "a_morphPositions_");
__publicField(Vt, "MORPH_NORMAL_PREFIX", "a_morphNormals_");
__publicField(Vt, "MORPH_TANGENT_PREFIX", "a_morphTangents_");
__publicField(Vt, "MORPH_WEIGHT_UNIFORM", "u_morphWeights");
__publicField(Vt, "SCENE_ROOT_SKELETON", "SCENE_ROOT");
__publicField(Vt, "IDENTITY_INVERSE_BIND_MATRICES", "IDENTITY_IBM");
__publicField(Vt, "JOINT_MATRICES_UNIFORM", "u_jointMatrix");
__publicField(Vt, "ALPHA_CUTOFF_UNIFORM", "u_alphaCutoff");
var D = ((s) => (s.position = "position", s.normal = "normal", s.uv = "uv", s.TANGENT = "TANGENT", s.TEXCOORD_1 = "TEXCOORD_1", s.TEXCOORD_2 = "TEXCOORD_2", s.TEXCOORD_3 = "TEXCOORD_3", s.TEXCOORD_4 = "TEXCOORD_4", s.TEXCOORD_5 = "TEXCOORD_5", s.TEXCOORD_6 = "TEXCOORD_6", s.TEXCOORD_7 = "TEXCOORD_7", s.color = "color", s.joints0 = "joints0", s.joints1 = "joints1", s.weights0 = "weights0", s.weights1 = "weights1", s.weight = "weight", s.indices = "indices", s.vIndex = "vIndex", s.a_morphPositions_0 = "a_morphPositions_0", s.all = "all", s))(D || {});
var re = ((s) => (s[s.NONE = 0] = "NONE", s[s.ABOVE = 1] = "ABOVE", s[s.ALPHA = 2] = "ALPHA", s[s.NORMAL = 3] = "NORMAL", s[s.ADD = 4] = "ADD", s[s.BELOW = 5] = "BELOW", s[s.ERASE = 6] = "ERASE", s[s.MUL = 7] = "MUL", s[s.SCREEN = 8] = "SCREEN", s[s.DIVD = 9] = "DIVD", s[s.SOFT_ADD = 10] = "SOFT_ADD", s))(re || {});
var ml = ((s) => (s[s.src_a = 0] = "src_a", s[s.dest_a = 1] = "dest_a", s))(ml || {});
var Al = class {
  static getBlend(e) {
    let t = { color: { srcFactor: "src-alpha", dstFactor: "one" }, alpha: { srcFactor: "one", dstFactor: "one" } };
    switch (e) {
      case 0:
        t.color.srcFactor = "one", t.color.dstFactor = "zero", t.color.operation = "add";
        break;
      case 1:
        t.color.srcFactor = "one-minus-src-alpha", t.color.dstFactor = "dst-alpha", t.color.operation = "add";
        break;
      case 4:
        t.color.srcFactor = "one", t.color.dstFactor = "one", t.color.operation = "add", t.alpha.srcFactor = "one", t.alpha.dstFactor = "one", t.alpha.operation = "add";
        break;
      case 2:
        t.color.srcFactor = "src-alpha", t.color.dstFactor = "one-minus-src-alpha";
        break;
      case 5:
        t.color.srcFactor = "one-minus-src-alpha", t.color.dstFactor = "one", t.color.operation = "add";
        break;
      case 6:
        t.color.srcFactor = "zero", t.color.dstFactor = "one-minus-src-alpha", t.color.operation = "add";
        break;
      case 7:
        t.color.srcFactor = "dst", t.color.dstFactor = "one-minus-src-alpha", t.color.operation = "add";
        break;
      case 3:
        t.color.srcFactor = "src-alpha", t.color.dstFactor = "one-minus-src-alpha", t.color.operation = "add";
        break;
      case 10:
        t.color.srcFactor = "one", t.color.dstFactor = "one", t.color.operation = "max", t.alpha.srcFactor = "one", t.alpha.dstFactor = "one", t.alpha.operation = "add";
        break;
      case 8:
        t.color.srcFactor = "one", t.color.dstFactor = "one-minus-src", t.color.operation = "add";
        break;
    }
    return t;
  }
};
var _at = class _at {
  static getMipmapPipeline(e) {
    let t = e.format, r = w.device, i = _at.pipelineCache[e.format], a;
    if (!i) {
      a = r.createShaderModule({ code: _at.mipmapShader });
      let o = r.createBindGroupLayout({ entries: [{ binding: 0, visibility: e.visibility, sampler: e.samplerBindingLayout }, { binding: 1, visibility: e.visibility, texture: e.textureBindingLayout }] }), n = w.device.createPipelineLayout({ bindGroupLayouts: [o] });
      i = y.createPipeline({ layout: n, vertex: { module: a, entryPoint: "vertexMain" }, fragment: { module: a, entryPoint: "fragmentMain", targets: [{ format: t }] } }), _at.pipelineCache[t] = i;
    }
    return i;
  }
  static getMipmapCount(e) {
    let t = e.width, r = e.height, i = Math.max(t, r);
    return 1 + Math.log2(i) | 0;
  }
  static webGPUGenerateMipmap(e) {
    let t = w.device, r = e.textureDescriptor;
    if (!_at.pipeline) {
      const n = t.createShaderModule({ code: `
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
          return outColor;
        }
      ` });
      _at.pipeline = t.createRenderPipeline({ layout: "auto", vertex: { module: n, entryPoint: "vertexMain" }, fragment: { module: n, entryPoint: "fragmentMain", targets: [{ format: r.format }] }, primitive: { topology: "triangle-strip", stripIndexFormat: "uint32" } });
    }
    let i;
    e.format == "rgba16float" ? i = t.createSampler({ minFilter: "nearest", magFilter: "linear" }) : i = t.createSampler({ minFilter: Gt.linear, magFilter: Gt.linear });
    let a = e.getGPUTexture().createView({ baseMipLevel: 0, mipLevelCount: 1 });
    const o = y.beginCommandEncoder();
    for (let n = 1; n < r.mipLevelCount; ++n) {
      const l = e.getGPUTexture().createView({ baseMipLevel: n, mipLevelCount: 1 }), h = o.beginRenderPass({ colorAttachments: [{ view: l, clearValue: [0, 0, 0, 0], loadOp: "clear", storeOp: "store" }] }), u = t.createBindGroup({ layout: _at.pipeline.getBindGroupLayout(0), entries: [{ binding: 0, resource: i }, { binding: 1, resource: a }] });
      h.setPipeline(_at.pipeline), h.setBindGroup(0, u), h.draw(4), h.end(), a = l;
    }
    y.endCommandEncoder(o);
  }
};
__publicField(_at, "mipmapShader", `
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`);
__publicField(_at, "pipelineCache", {});
__publicField(_at, "pipeline");
var at = _at;
var Re = class {
  constructor(e = 32, t = 32, r = 1) {
    __publicField(this, "name");
    __publicField(this, "url");
    __publicField(this, "gpuTexture");
    __publicField(this, "pid");
    __publicField(this, "view");
    __publicField(this, "gpuSampler");
    __publicField(this, "gpuSampler_comparison");
    __publicField(this, "format");
    __publicField(this, "usage");
    __publicField(this, "width", 4);
    __publicField(this, "height", 4);
    __publicField(this, "depthOrArrayLayers", 1);
    __publicField(this, "numberLayer", 1);
    __publicField(this, "viewDescriptor");
    __publicField(this, "textureDescriptor");
    __publicField(this, "visibility", GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT);
    __publicField(this, "textureBindingLayout", { viewDimension: "2d", multisampled: false });
    __publicField(this, "samplerBindingLayout", { type: "filtering" });
    __publicField(this, "sampler_comparisonBindingLayout", { type: "comparison" });
    __publicField(this, "flipY");
    __publicField(this, "isVideoTexture");
    __publicField(this, "isHDRTexture");
    __publicField(this, "_useMipmap", false);
    __publicField(this, "_sourceImageData");
    __publicField(this, "_addressModeU");
    __publicField(this, "_addressModeV");
    __publicField(this, "_addressModeW");
    __publicField(this, "_magFilter");
    __publicField(this, "_minFilter");
    __publicField(this, "_mipmapFilter");
    __publicField(this, "_lodMinClamp");
    __publicField(this, "_lodMaxClamp");
    __publicField(this, "_compare");
    __publicField(this, "_maxAnisotropy");
    __publicField(this, "mipmapCount", 1);
    __publicField(this, "_textureChange", false);
    __publicField(this, "_stateChangeRef", /* @__PURE__ */ new Map());
    this.width = e, this.height = t, this.numberLayer = r, this.minFilter = Gt.linear, this.magFilter = Gt.linear, this.mipmapFilter = Gt.linear, this.addressModeU = ct.repeat, this.addressModeV = ct.repeat;
  }
  init() {
    let e = this;
    return e.internalCreateBindingLayoutDesc && e.internalCreateBindingLayoutDesc(), e.internalCreateTexture && e.internalCreateTexture(), e.internalCreateView && e.internalCreateView(), e.internalCreateSampler && e.internalCreateSampler(), this;
  }
  createTextureDescriptor(e, t, r, i, a = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING, o = 1, n = 0) {
    this.width = e, this.height = t, this.format = i, this.usage = a, this.textureDescriptor = { size: [e, t, o], mipLevelCount: r, format: i, usage: a, label: `${this.name + this.width + this.height + this.format}` }, n > 0 && (this.textureDescriptor.sampleCount = n), o > 1 ? this.viewDescriptor = { dimension: "2d-array" } : this.viewDescriptor = { dimension: this.textureBindingLayout.viewDimension, mipLevelCount: r, baseMipLevel: 0 };
  }
  generate(e) {
    let t = 32, r = 32;
    "width" in e && (t = e.width, r = e.height), (t < 32 || r < 32) && console.log(e.name + "Size must be greater than 32!"), this.width = t, this.height = r, this.createTexture(e);
  }
  createTexture(e) {
    this._sourceImageData = e, this.updateTextureDescription(), this.updateGPUTexture();
    let t = w.device;
    this.gpuTexture instanceof GPUTexture && t.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]), this.useMipmap && at.webGPUGenerateMipmap(this);
  }
  get useMipmap() {
    return this._useMipmap;
  }
  set useMipmap(e) {
    if (e) {
      if (this.samplerBindingLayout.type = "filtering", this._useMipmap == false && this._sourceImageData) {
        this._useMipmap = true, this.updateTextureDescription(), this.updateGPUTexture();
        let t = w.device;
        this.gpuTexture instanceof GPUTexture && t.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]), at.webGPUGenerateMipmap(this);
      }
    } else if (this.samplerBindingLayout.type = "non-filtering", this._useMipmap == true && this._sourceImageData) {
      this._useMipmap = false, this.updateTextureDescription(), this.updateGPUTexture();
      let t = w.device;
      this.gpuTexture instanceof GPUTexture && t.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]);
    }
    this._textureChange = true, this._useMipmap = e, this.noticeChange();
  }
  get sourceImageData() {
    return this._sourceImageData;
  }
  getMipmapCount() {
    let e = this.width, t = this.height, r = Math.max(e, t);
    return 1 + Math.log2(r) | 0;
  }
  updateTextureDescription() {
    this.mipmapCount = Math.floor(this.useMipmap ? this.getMipmapCount() : 1), this.createTextureDescriptor(this.width, this.height, this.mipmapCount, this.format);
  }
  updateGPUTexture() {
    this.gpuTexture && this.gpuTexture instanceof GPUTexture && this.gpuTexture.destroy(), this.gpuTexture = null, this.view = null, this.gpuTexture = this.getGPUTexture();
  }
  getGPUTexture() {
    return this.gpuTexture || (this.gpuTexture = w.device.createTexture(this.textureDescriptor)), this.gpuTexture;
  }
  getGPUView(e = 0) {
    return this.view || (this.gpuTexture = this.getGPUTexture(), this.gpuTexture instanceof GPUTexture && (this.view = this.gpuTexture.createView(this.viewDescriptor), this.view.label = this.name)), this.view;
  }
  bindStateChange(e, t) {
    this._stateChangeRef.set(t, e);
  }
  unBindStateChange(e) {
    this._stateChangeRef.delete(e);
  }
  noticeChange() {
    this.gpuSampler = w.device.createSampler(this), this._stateChangeRef.forEach((e, t) => {
      e();
    });
  }
  destroy(e) {
    e && this.gpuTexture instanceof GPUTexture && (this.gpuSampler = null, this.gpuSampler_comparison = null, this.textureBindingLayout = null, this.textureDescriptor = null, this.gpuTexture.destroy(), this.gpuTexture = null), this._stateChangeRef.clear();
  }
  get addressModeU() {
    return this._addressModeU;
  }
  set addressModeU(e) {
    this._addressModeU != e && (this._addressModeU = e, this.noticeChange());
  }
  get addressModeV() {
    return this._addressModeV;
  }
  set addressModeV(e) {
    this._addressModeV != e && (this._addressModeV = e, this.noticeChange());
  }
  get addressModeW() {
    return this._addressModeW;
  }
  set addressModeW(e) {
    this._addressModeW != e && (this._addressModeW = e, this.noticeChange());
  }
  get magFilter() {
    return this._magFilter;
  }
  set magFilter(e) {
    this._magFilter != e && (this._magFilter = e, this.noticeChange());
  }
  get minFilter() {
    return this._minFilter;
  }
  set minFilter(e) {
    this._minFilter != e && (this._minFilter = e, this.noticeChange());
  }
  get mipmapFilter() {
    return this._mipmapFilter;
  }
  set mipmapFilter(e) {
    this._mipmapFilter != e && (this._mipmapFilter = e, this.noticeChange());
  }
  get lodMinClamp() {
    return this._lodMinClamp;
  }
  set lodMinClamp(e) {
    this._lodMinClamp != e && (this._lodMinClamp = e, this.noticeChange());
  }
  get lodMaxClamp() {
    return this._lodMaxClamp;
  }
  set lodMaxClamp(e) {
    this._lodMaxClamp != e && (this._lodMaxClamp = e, this.noticeChange());
  }
  get compare() {
    return this._compare;
  }
  set compare(e) {
    this._compare != e && (this._compare = e, this.noticeChange());
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  set maxAnisotropy(e) {
    this._maxAnisotropy != e && (this._maxAnisotropy = e, this.noticeChange());
  }
  static delayDestroyTexture(e) {
    this._texs.includes(e) || this._texs.push(e);
  }
  static destroyTexture() {
    if (this._texs.length > 0)
      for (; this._texs.length > 0; )
        this._texs.shift().destroy();
  }
};
__publicField(Re, "_texs", []);
var vl = class extends Re {
  constructor(e, t, r) {
    super(e, t, r);
    __publicField(this, "_bitmapTextures");
    this.format = N.rgba8unorm, this.mipmapCount = 1, this._bitmapTextures = [], this.init();
  }
  setTextures(e) {
    this._bitmapTextures.length = 0;
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.addTexture(r);
    }
  }
  addTexture(e) {
    (e.width != this.width || e.height != this.height) && console.error("bitmap texture must match bitmapTextureArray size!"), e.pid = this._bitmapTextures.length, this._bitmapTextures.push(e), this.updateTexture();
  }
  removeTexture(e) {
    let t = this._bitmapTextures.indexOf(e);
    if (t != -1) {
      this._bitmapTextures.splice(t, 1);
      for (let r = 0; r < this._bitmapTextures.length; r++) {
        const i = this._bitmapTextures[r];
        i.pid = r;
      }
    }
  }
  updateTexture() {
    let e = y.beginCommandEncoder();
    for (let t = 0; t < this._bitmapTextures.length; t++) {
      let r = this._bitmapTextures[t];
      e.copyTextureToTexture({ texture: r.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: this.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: t } }, { width: this.width, height: this.height, depthOrArrayLayers: 1 });
    }
    y.endCommandEncoder(e);
  }
  internalCreateBindingLayoutDesc() {
    this.textureBindingLayout.viewDimension = "2d-array", this.samplerBindingLayout.type = "filtering", this.minFilter = Gt.linear, this.magFilter = Gt.linear;
  }
  internalCreateTexture() {
    this.textureDescriptor = { format: this.format, size: { width: this.width, height: this.height, depthOrArrayLayers: this.numberLayer }, dimension: "2d", usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING }, this.gpuTexture = this.getGPUTexture();
  }
  internalCreateView() {
    this.viewDescriptor = { dimension: "2d-array" }, this.view = this.getGPUView();
  }
  internalCreateSampler() {
    this.gpuSampler = w.device.createSampler(this);
  }
};
var _zt = class _zt {
  constructor() {
    __publicField(this, "_iesTexture");
    __publicField(this, "index", 0);
  }
  generateIES(e) {
  }
  set IESTexture(e) {
    this._iesTexture = e, e.addressModeU = ct.repeat, e.addressModeV = ct.repeat, e.addressModeW = ct.repeat, _zt.ies_list.indexOf(this) == -1 && (this.index = _zt.ies_list.length, _zt.ies_list.push(this), _zt.iesTexture || _zt.create(e.width, e.height), _zt.iesTexture.addTexture(e));
  }
  get IESTexture() {
    return this._iesTexture;
  }
  static create(e, t) {
    let r = 48;
    this.iesTexture = new vl(e, t, r);
  }
};
__publicField(_zt, "use", false);
__publicField(_zt, "iesTexture");
__publicField(_zt, "ies_list", []);
var zt = _zt;
var Ci = class {
  constructor(e = 0, t = "\0") {
    __publicField(this, "Type", 0);
    __publicField(this, "Line", 0);
    __publicField(this, "Colume", 0);
    __publicField(this, "Literal", "");
    this.Type = e, this.Literal = t;
  }
  isTypeEqual(e) {
    return this.Type == e;
  }
  isLiteralEqual(e) {
    return this.Literal == e;
  }
  isBuiltinType() {
    return this.Type > 33 && this.Type < 101;
  }
  isDataType() {
    return this.Type == 1 || this.isBuiltinType();
  }
  isOperation() {
    return this.Type > 102 && this.Type < 127;
  }
  isAssignOperation() {
    return this.Type > 128 && this.Type < 133;
  }
  get nOperationPriorityLevel() {
    switch (this.Type) {
      case 26:
        return 1;
      case 27:
        return 1;
      case 125:
        return 2;
      case 110:
        return 3;
      case 114:
        return 3;
      case 105:
        return 4;
      case 106:
        return 4;
      case 103:
        return 5;
      case 104:
        return 5;
      case 115:
        return 6;
      case 116:
        return 6;
      case 119:
        return 7;
      case 120:
        return 7;
      case 122:
        return 7;
      case 123:
        return 7;
      case 121:
        return 8;
      case 124:
        return 8;
      case 111:
        return 9;
      case 113:
        return 10;
      case 112:
        return 11;
      case 107:
        return 12;
      case 109:
        return 13;
      case 108:
        return 14;
      case 24:
        return 15;
      case 126:
        return 16;
      case 129:
        return 16;
      case 130:
        return 16;
      case 131:
        return 16;
      case 132:
        return 16;
    }
    return 99;
  }
};
var v = ((s) => (s[s.EOF = 0] = "EOF", s[s.IDENT = 1] = "IDENT", s[s.VOID = 2] = "VOID", s[s.CONST = 3] = "CONST", s[s.LAYOUT = 4] = "LAYOUT", s[s.PRECISION = 5] = "PRECISION", s[s.ATTRIBUTE = 6] = "ATTRIBUTE", s[s.UNIFORM = 7] = "UNIFORM", s[s.VARYING = 8] = "VARYING", s[s.INVARIANT = 9] = "INVARIANT", s[s.IN = 10] = "IN", s[s.OUT = 11] = "OUT", s[s.INOUT = 12] = "INOUT", s[s.IF = 13] = "IF", s[s.ELSE = 14] = "ELSE", s[s.FOR = 15] = "FOR", s[s.WHILE = 16] = "WHILE", s[s.DO = 17] = "DO", s[s.BREAK = 18] = "BREAK", s[s.RETURN = 19] = "RETURN", s[s.CONTINUE = 20] = "CONTINUE", s[s.STRUCT = 21] = "STRUCT", s[s.COMMA = 22] = "COMMA", s[s.COLON = 23] = "COLON", s[s.QUEMARK = 24] = "QUEMARK", s[s.SEMICOLON = 25] = "SEMICOLON", s[s.LEFTSAMLL = 26] = "LEFTSAMLL", s[s.RIGHTSAMLL = 27] = "RIGHTSAMLL", s[s.LEFTMEDI = 28] = "LEFTMEDI", s[s.RIGHTMEDI = 29] = "RIGHTMEDI", s[s.LEFTBIG = 30] = "LEFTBIG", s[s.RIGHTBIG = 31] = "RIGHTBIG", s[s.LITERAL = 32] = "LITERAL", s[s.BeginBuiltinType = 33] = "BeginBuiltinType", s[s.INT = 34] = "INT", s[s.INT_ARRAY = 35] = "INT_ARRAY", s[s.UINT = 36] = "UINT", s[s.UINT_ARRAY = 37] = "UINT_ARRAY", s[s.BOOL = 38] = "BOOL", s[s.BOOL_ARRAY = 39] = "BOOL_ARRAY", s[s.FLOAT = 40] = "FLOAT", s[s.FLOAT_ARRAY = 41] = "FLOAT_ARRAY", s[s.DOUBLE = 42] = "DOUBLE", s[s.DOUBLE_ARRAY = 43] = "DOUBLE_ARRAY", s[s.VEC2 = 44] = "VEC2", s[s.VEC2_ARRAY = 45] = "VEC2_ARRAY", s[s.VEC3 = 46] = "VEC3", s[s.VEC3_ARRAY = 47] = "VEC3_ARRAY", s[s.VEC4 = 48] = "VEC4", s[s.VEC4_ARRAY = 49] = "VEC4_ARRAY", s[s.BVEC2 = 50] = "BVEC2", s[s.BVEC2_ARRAY = 51] = "BVEC2_ARRAY", s[s.BVEC3 = 52] = "BVEC3", s[s.BVEC3_ARRAY = 53] = "BVEC3_ARRAY", s[s.BVEC4 = 54] = "BVEC4", s[s.BVEC4_ARRAY = 55] = "BVEC4_ARRAY", s[s.IVEC2 = 56] = "IVEC2", s[s.IVEC2_ARRAY = 57] = "IVEC2_ARRAY", s[s.IVEC3 = 58] = "IVEC3", s[s.IVEC3_ARRAY = 59] = "IVEC3_ARRAY", s[s.IVEC4 = 60] = "IVEC4", s[s.IVEC4_ARRAY = 61] = "IVEC4_ARRAY", s[s.UVEC2 = 62] = "UVEC2", s[s.UVEC2_ARRAY = 63] = "UVEC2_ARRAY", s[s.UVEC3 = 64] = "UVEC3", s[s.UVEC3_ARRAY = 65] = "UVEC3_ARRAY", s[s.UVEC4 = 66] = "UVEC4", s[s.UVEC4_ARRAY = 67] = "UVEC4_ARRAY", s[s.MAT2x2 = 68] = "MAT2x2", s[s.MAT2x2_ARRAY = 69] = "MAT2x2_ARRAY", s[s.MAT2x3 = 70] = "MAT2x3", s[s.MAT2x3_ARRAY = 71] = "MAT2x3_ARRAY", s[s.MAT2x4 = 72] = "MAT2x4", s[s.MAT2x4_ARRAY = 73] = "MAT2x4_ARRAY", s[s.MAT3x2 = 74] = "MAT3x2", s[s.MAT3x2_ARRAY = 75] = "MAT3x2_ARRAY", s[s.MAT3x3 = 76] = "MAT3x3", s[s.MAT3x3_ARRAY = 77] = "MAT3x3_ARRAY", s[s.MAT3x4 = 78] = "MAT3x4", s[s.MAT3x4_ARRAY = 79] = "MAT3x4_ARRAY", s[s.MAT4x2 = 80] = "MAT4x2", s[s.MAT4x2_ARRAY = 81] = "MAT4x2_ARRAY", s[s.MAT4x3 = 82] = "MAT4x3", s[s.MAT4x3_ARRAY = 83] = "MAT4x3_ARRAY", s[s.MAT4x4 = 84] = "MAT4x4", s[s.MAT4x4_ARRAY = 85] = "MAT4x4_ARRAY", s[s.SAMPLER = 86] = "SAMPLER", s[s.SAMPLER_1D = 87] = "SAMPLER_1D", s[s.SAMPLER_2D = 88] = "SAMPLER_2D", s[s.SAMPLER_3D = 89] = "SAMPLER_3D", s[s.SAMPLER_CUBE = 90] = "SAMPLER_CUBE", s[s.SAMPLER_SHADOW = 91] = "SAMPLER_SHADOW", s[s.SAMPLER_1D_SHADOW = 92] = "SAMPLER_1D_SHADOW", s[s.SAMPLER_2D_SHADOW = 93] = "SAMPLER_2D_SHADOW", s[s.TEXTURE_1D = 94] = "TEXTURE_1D", s[s.TEXTURE_1D_ARRAY = 95] = "TEXTURE_1D_ARRAY", s[s.TEXTURE_2D = 96] = "TEXTURE_2D", s[s.TEXTURE_2D_ARRAY = 97] = "TEXTURE_2D_ARRAY", s[s.TEXTURE_3D = 98] = "TEXTURE_3D", s[s.TEXTURE_CUBE = 99] = "TEXTURE_CUBE", s[s.TEXTURE_CUBE_ARRAY = 100] = "TEXTURE_CUBE_ARRAY", s[s.EndBuiltinType = 101] = "EndBuiltinType", s[s.BeginOperation = 102] = "BeginOperation", s[s.ADD = 103] = "ADD", s[s.SUB = 104] = "SUB", s[s.MUL = 105] = "MUL", s[s.DIV = 106] = "DIV", s[s.AND = 107] = "AND", s[s.OR = 108] = "OR", s[s.XOR = 109] = "XOR", s[s.NOT = 110] = "NOT", s[s.BITAND = 111] = "BITAND", s[s.BITOR = 112] = "BITOR", s[s.BITXOR = 113] = "BITXOR", s[s.BITNOT = 114] = "BITNOT", s[s.BITSHIFT_L = 115] = "BITSHIFT_L", s[s.BITSHIFT_R = 116] = "BITSHIFT_R", s[s.INC = 117] = "INC", s[s.DEC = 118] = "DEC", s[s.GREATER = 119] = "GREATER", s[s.GREATEREQUAL = 120] = "GREATEREQUAL", s[s.EQUAL = 121] = "EQUAL", s[s.LESS = 122] = "LESS", s[s.LESSEQUAL = 123] = "LESSEQUAL", s[s.NOTEQUAL = 124] = "NOTEQUAL", s[s.DOT = 125] = "DOT", s[s.ASSIGN = 126] = "ASSIGN", s[s.EndOperation = 127] = "EndOperation", s[s.BeginAssignOperation = 128] = "BeginAssignOperation", s[s.ADDASSIGN = 129] = "ADDASSIGN", s[s.SUBASSIGN = 130] = "SUBASSIGN", s[s.MULASSIGN = 131] = "MULASSIGN", s[s.DIVASSIGN = 132] = "DIVASSIGN", s[s.EndAssignOperation = 133] = "EndAssignOperation", s))(v || {});
var jr = class {
  constructor(e) {
    __publicField(this, "_char");
    __publicField(this, "_line");
    __publicField(this, "_column");
    __publicField(this, "_source");
    __publicField(this, "_currPosition");
    __publicField(this, "_nextPosition");
    this.reset(e);
  }
  reset(e) {
    this._char = "", this._line = 0, this._column = 0, this._source = e, this._currPosition = 0, this._nextPosition = 0;
  }
  get source() {
    return this._source;
  }
  getChar() {
    return this._char;
  }
  get currPosition() {
    return this._currPosition;
  }
  peekChar() {
    return this._nextPosition >= this._source.length ? "\0" : this._source[this._nextPosition];
  }
  readChar() {
    this._char = this._nextPosition >= this._source.length ? "\0" : this._source[this._nextPosition], this._char !== `
` ? this._column++ : (this._line++, this._column = 0), this._currPosition = this._nextPosition, this._nextPosition++;
  }
  readCharAndSkipWhitespace() {
    this.readChar(), this.skipWhitespace();
  }
  readIdentifier() {
    for (var e = this._currPosition; this.isIdentifier(this._char); )
      this.readChar();
    return this._source.substring(e, this._currPosition);
  }
  isIdentifier(e) {
    var t = e.charCodeAt(0);
    return 97 <= t && t <= 122 || 65 <= t && t <= 90 || 48 <= t && t <= 57 || t == 95;
  }
  skipWhitespace() {
    for (; this.IsWhitespace(this._char); )
      this.readChar();
  }
  IsWhitespace(e) {
    return e === " " || e === "	" || e === "\r" || e === `
`;
  }
  skipComment() {
    for (; this._char !== `
` && this._char !== "\0"; )
      this.readChar();
    this.skipWhitespace();
  }
  skipMultilineComment() {
    if (!(this._char !== "/" && this.peekChar() !== "*")) {
      this.readChar(), this.readChar();
      for (let e = 1; e > 0 && this._char !== "\0"; )
        if (this.readChar(), this._char === "/" && this.peekChar() === "*") {
          e++, this.readChar();
          continue;
        } else if (this._char === "*" && this.peekChar() === "/") {
          e--, this.readChar();
          continue;
        }
      this.readChar(), this.readChar(), this.skipWhitespace();
    }
  }
  isDigit(e) {
    var t = e.charCodeAt(0);
    return 48 <= t && t <= 57;
  }
  readNumber() {
    for (var e = this._currPosition; this.isDigit(this._char); )
      this.readChar();
    if (this._char === ".")
      for (this.readChar(); this.isDigit(this._char); )
        this.readChar();
    return this._source.substring(e, this._currPosition);
  }
  readValue() {
    return this.isDigit(this._char) ? this.readNumber() : this.readIdentifier();
  }
  readLine() {
    var e = this._currPosition, t = this._source.indexOf(`
`, this._currPosition);
    return t == -1 && (t = this._source.length), this._line++, this._column = 0, this._currPosition = t, this._nextPosition = t + 1, this._source.substring(e, t + 1);
  }
};
var xl = class extends jr {
  constructor(e) {
    super(e.source);
    __publicField(this, "_tokenPosition", 0);
    __publicField(this, "_tokens", []);
    this.parse();
  }
  skipToken(e) {
    this._tokenPosition += e;
  }
  peekToken(e) {
    return this._tokenPosition + e >= this._tokens.length ? new Ci(v.EOF, "\0") : this._tokens[this._tokenPosition + e];
  }
  GetNextToken() {
    if (this._tokenPosition >= this._tokens.length)
      return new Ci(v.EOF, "\0");
    let e = this._tokens[this._tokenPosition];
    return this._tokenPosition++, e;
  }
  get currTokenPosition() {
    return this._tokenPosition;
  }
  parse() {
    this.readChar(), this._tokens = new Array();
    var e;
    do
      e = this.nextToken(), this._tokens.push(e);
    while (e.Type != v.EOF);
  }
  nextToken() {
    if (this.skipWhitespace(), this._char === "/") {
      if (this.peekChar() === "/")
        return this.skipComment(), this.nextToken();
      if (this.peekChar() === "*")
        return this.skipMultilineComment(), this.nextToken();
    }
    var e = new Ci();
    switch (e.Line = this._line, e.Colume = this._column, this._char) {
      case "\0":
        e.Type = v.EOF, e.Literal = "EOF";
        break;
      case ".":
        e.Type = v.DOT, e.Literal = ".";
        break;
      case ",":
        e.Type = v.COMMA, e.Literal = ",";
        break;
      case ":":
        e.Type = v.COLON, e.Literal = ":";
        break;
      case "?":
        e.Type = v.QUEMARK, e.Literal = "?";
        break;
      case ";":
        e.Type = v.SEMICOLON, e.Literal = ";";
        break;
      case "(":
        e.Type = v.LEFTSAMLL, e.Literal = "(";
        break;
      case ")":
        e.Type = v.RIGHTSAMLL, e.Literal = ")";
        break;
      case "[":
        e.Type = v.LEFTMEDI, e.Literal = "[";
        break;
      case "]":
        e.Type = v.RIGHTMEDI, e.Literal = "]";
        break;
      case "{":
        e.Type = v.LEFTBIG, e.Literal = "{";
        break;
      case "}":
        e.Type = v.RIGHTBIG, e.Literal = "}";
        break;
      case "+":
        if (this.peekChar() === "+") {
          this.readChar(), e.Type = v.INC, e.Literal = "++";
          break;
        } else if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.ADDASSIGN, e.Literal = "+=";
          break;
        }
        e.Type = v.ADD, e.Literal = "+";
        break;
      case "-":
        if (this.peekChar() === "-") {
          this.readChar(), e.Type = v.DEC, e.Literal = "--";
          break;
        } else if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.SUBASSIGN, e.Literal = "-=";
          break;
        }
        e.Type = v.SUB, e.Literal = "-";
        break;
      case "*":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.MULASSIGN, e.Literal = "*=";
          break;
        }
        e.Type = v.MUL, e.Literal = "*";
        break;
      case "/":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.DIVASSIGN, e.Literal = "/=";
          break;
        }
        e.Type = v.DIV, e.Literal = "/";
        break;
      case "&":
        if (this.peekChar() === "&") {
          this.readChar(), e.Type = v.AND, e.Literal = "&&";
          break;
        }
        e.Type = v.BITAND, e.Literal = "&";
        break;
      case "|":
        if (this.peekChar() === "|") {
          this.readChar(), e.Type = v.OR, e.Literal = "||";
          break;
        }
        e.Type = v.BITOR, e.Literal = "&";
        break;
      case "^":
        e.Type = v.BITXOR, e.Literal = "^";
        break;
      case "!":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.NOTEQUAL, e.Literal = "!=";
          break;
        }
        e.Type = v.NOT, e.Literal = "!";
        break;
      case ">":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.GREATEREQUAL, e.Literal = ">=";
          break;
        } else if (this.peekChar() === ">") {
          this.readChar(), e.Type = v.BITSHIFT_R, e.Literal = ">>";
          break;
        }
        e.Type = v.GREATER, e.Literal = ">";
        break;
      case "=":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.EQUAL, e.Literal = "==";
          break;
        }
        e.Type = v.ASSIGN, e.Literal = "=";
        break;
      case "<":
        if (this.peekChar() === "=") {
          this.readChar(), e.Type = v.LESSEQUAL, e.Literal = "<=";
          break;
        } else if (this.peekChar() === "<") {
          this.readChar(), e.Type = v.BITSHIFT_L, e.Literal = "<<";
          break;
        }
        e.Type = v.LESS, e.Literal = "<";
        break;
      default:
        return this.isDigit(this._char) ? this.readDecimal() : (e.Literal = this.readIdentifier(), e.Type = this.lookupIdentifier(e.Literal), this.getChar() == "[" && this.peekChar() == "]" && e.isBuiltinType() && (e.Type++, e.Literal += "[]", this.readChar(), this.readChar()), e);
    }
    return this.readChar(), e;
  }
  readDecimal() {
    var e = new Ci();
    e.Line = this._line, e.Colume = this._column, e.Type = v.LITERAL;
    var t = this.readNumber();
    return this._char === "e" ? (e.Literal = t + this._char, this.readChar(), e.Literal += this._char, this.readChar(), e.Literal += this.readNumber(), e.Type = v.LITERAL, e) : this._char === "u" ? (this.readChar(), e.Type = v.LITERAL, e.Literal = t + "u", e) : this._char === "f" ? (this.readChar(), e.Type = v.LITERAL, e.Literal = t + "f", e) : (e.Type = v.LITERAL, e.Literal = t, e);
  }
  lookupIdentifier(e) {
    switch (e) {
      case "void":
        return v.VOID;
      case "int":
        return v.INT;
      case "uint":
        return v.UINT;
      case "bool":
        return v.BOOL;
      case "true":
        return v.BOOL;
      case "false":
        return v.BOOL;
      case "float":
        return v.FLOAT;
      case "vec2":
        return v.VEC2;
      case "vec3":
        return v.VEC3;
      case "vec4":
        return v.VEC4;
      case "bvec2":
        return v.BVEC2;
      case "bvec3":
        return v.BVEC3;
      case "bvec4":
        return v.BVEC4;
      case "ivec2":
        return v.IVEC2;
      case "ivec3":
        return v.IVEC3;
      case "ivec4":
        return v.IVEC4;
      case "uvec2":
        return v.UVEC2;
      case "uvec3":
        return v.UVEC3;
      case "uvec4":
        return v.UVEC4;
      case "mat2":
        return v.MAT2x2;
      case "mat2x2":
        return v.MAT2x2;
      case "mat2x3":
        return v.MAT2x3;
      case "mat2x4":
        return v.MAT2x4;
      case "mat3":
        return v.MAT3x3;
      case "mat3x2":
        return v.MAT3x2;
      case "mat3x3":
        return v.MAT3x3;
      case "mat3x4":
        return v.MAT3x4;
      case "mat4":
        return v.MAT4x4;
      case "mat4x2":
        return v.MAT4x2;
      case "mat4x3":
        return v.MAT4x3;
      case "mat4x4":
        return v.MAT4x4;
      case "sampler":
        return v.SAMPLER;
      case "sampler1D":
        return v.SAMPLER_1D;
      case "sampler2D":
        return v.SAMPLER_2D;
      case "sampler3D":
        return v.SAMPLER_3D;
      case "samplerCube":
        return v.SAMPLER_CUBE;
      case "samplerShadow":
        return v.SAMPLER_SHADOW;
      case "sampler1DShadow":
        return v.SAMPLER_1D_SHADOW;
      case "sampler2DShadow":
        return v.SAMPLER_2D_SHADOW;
      case "texture1D":
        return v.TEXTURE_1D;
      case "texture2D":
        return v.TEXTURE_2D;
      case "texture3D":
        return v.TEXTURE_3D;
      case "textureCube":
        return v.TEXTURE_CUBE;
      case "texture1DArray":
        return v.TEXTURE_1D_ARRAY;
      case "texture2DArray":
        return v.TEXTURE_2D_ARRAY;
      case "textureCubeArray":
        return v.TEXTURE_CUBE_ARRAY;
      case "const":
        return v.CONST;
      case "layout":
        return v.LAYOUT;
      case "precision":
        return v.PRECISION;
      case "attribute":
        return v.ATTRIBUTE;
      case "uniform":
        return v.UNIFORM;
      case "varying":
        return v.VARYING;
      case "invariant":
        return v.INVARIANT;
      case "in":
        return v.IN;
      case "out":
        return v.OUT;
      case "inout":
        return v.INOUT;
      case "if":
        return v.IF;
      case "else":
        return v.ELSE;
      case "for":
        return v.FOR;
      case "while":
        return v.WHILE;
      case "do":
        return v.DO;
      case "break":
        return v.BREAK;
      case "return":
        return v.RETURN;
      case "continue":
        return v.CONTINUE;
      case "struct":
        return v.STRUCT;
    }
    return v.IDENT;
  }
};
var Id = class {
  constructor() {
    __publicField(this, "name", "");
    __publicField(this, "value", "");
    __publicField(this, "args", []);
  }
};
var _l = class extends jr {
  constructor(e) {
    super(e);
    __publicField(this, "_result");
    __publicField(this, "_skipLine");
    __publicField(this, "_definitionTables");
    this._result = "", this._skipLine = false, this._definitionTables = /* @__PURE__ */ new Map(), this.parse();
  }
  parse() {
    for (this.readChar(); this._char !== "\0"; ) {
      if (this.skipWhitespace(), this._char === "/") {
        if (this.peekChar() === "/") {
          this.skipComment();
          continue;
        }
        if (this.peekChar() === "*") {
          this.skipMultilineComment();
          continue;
        }
      }
      if (this._char === "#") {
        this.readCharAndSkipWhitespace();
        var e = this.readIdentifier();
        switch (e) {
          case "version":
            this.readLine().trim();
            break;
          case "define":
            this.readCharAndSkipWhitespace();
            var t = this.readIdentifier();
            if (this.getChar() === "(") {
              let n = new Id();
              if (this.readCharAndSkipWhitespace(), this.getChar() !== ")")
                do {
                  var r = this.readIdentifier();
                  if (n.args.push(r), this.skipWhitespace(), this.getChar() === ",") {
                    this.readCharAndSkipWhitespace();
                    continue;
                  }
                } while (this.getChar() !== ")");
              this.readCharAndSkipWhitespace(), n.name = t, n.value = this.readLine().trim(), this._definitionTables.set(t, n), this.readCharAndSkipWhitespace();
            } else {
              let n = this.readLine().trim();
              n[0] == "=" && (n = n.substring(1)), this._definitionTables.set(t, n);
            }
            break;
          case "if":
            let o = this.readLine().trim();
            if (o == "0" || o == "false") {
              this._skipLine = true;
              break;
            }
            if (this._definitionTables.has(o) && (o = this._definitionTables.get(o), o == "0" || o == "false")) {
              this._skipLine = true;
              break;
            }
            break;
          case "ifdef":
            this.readCharAndSkipWhitespace();
            var i = this.readIdentifier();
            this._skipLine = !this._definitionTables.has(i);
            break;
          case "else":
            this._skipLine = !this._skipLine;
            break;
          case "endif":
            this._skipLine = false;
            break;
          default:
            throw "Unknown preprocessing command:" + e;
        }
      } else {
        var a = this.readLine();
        if (!this._skipLine) {
          for (let o of this._definitionTables.keys()) {
            let n = a.indexOf(o);
            if (n != -1) {
              let l = this._definitionTables.get(o);
              if (typeof l == "string")
                a = a.replace(o, l);
              else {
                let h = l, u = new jr(a.substring(n + o.length));
                if (u.readCharAndSkipWhitespace(), u.getChar() === "(") {
                  u.readCharAndSkipWhitespace();
                  for (let m = 1; u.getChar() !== "\0" && m > 0; ) {
                    switch (u.getChar()) {
                      case "(":
                        m++;
                        break;
                      case ")":
                        m--;
                        break;
                    }
                    u.readCharAndSkipWhitespace();
                  }
                }
                let c = n, f = c + o.length + u.currPosition, g = a.substring(c, f).trim();
                if (h.args.length > 0) {
                  let m = [], A = g.substring(g.indexOf("(") + 1, g.lastIndexOf(")")).trim();
                  A.length > 0 && (m = this.parseArgs(A));
                  let _ = h.value.substring(h.value.indexOf("("));
                  for (let x = 0; x < h.args.length; x++)
                    _ = _.replace(h.args[x], m[x]);
                  _ = h.value.substring(0, h.value.indexOf("(")) + _, a = a.replace(g, _);
                } else
                  a = a.replace(g, h.value);
              }
            }
          }
          this._result += a;
        }
        this.readChar();
      }
    }
  }
  get source() {
    return this._result;
  }
  parseArgs(e) {
    let t = [], r = 0, i = new jr(e), a = i.currPosition;
    if (i.readCharAndSkipWhitespace(), i.getChar() !== "\0")
      for (i.readCharAndSkipWhitespace(); i.getChar() !== "\0"; ) {
        switch (i.getChar()) {
          case "(":
            r++;
            break;
          case ")":
            r--;
            break;
          case ",":
            if (r == 0) {
              let o = e.substring(a, i.currPosition);
              t.push(o), a = i.currPosition + 1;
            }
            break;
        }
        i.readCharAndSkipWhitespace();
      }
    if (a < i.currPosition) {
      let o = e.substring(a, i.currPosition);
      t.push(o);
    }
    return t;
  }
};
var Cl = class {
  constructor(e) {
    __publicField(this, "result");
    __publicField(this, "ASTRoot");
    __publicField(this, "_syntax");
    this.result = "", this._syntax = e, this.ASTRoot = e.ASTRoot;
  }
  generateWGSL() {
    let e = new Vs();
    var t = new bl();
    let r = [], i = [], a = [];
    for (let u of this.ASTRoot.nodes)
      if (u instanceof Ki)
        if (u.scope == "in")
          if (u.nodes[0] instanceof Ce) {
            e.layoutsIn.push(u);
            let c = new Ys();
            c.name = u.nodes[0].name, c.type = u.nodes[0].type, c.locationID = Number.parseInt(u.qualifier.get("location")), t.inputAttribute.push(c);
          } else if (u.qualifier.has("local_size_x"))
            e.workGroupSize = u;
          else
            throw "not impl";
        else if (u.scope == "out")
          if (e.layoutsOut.push(u), u.nodes[0] instanceof Ce) {
            let c = new Ys();
            c.name = u.nodes[0].name, c.type = u.nodes[0].type, c.locationID = Number.parseInt(u.qualifier.get("location")), t.outputAttribute.push(c);
          } else
            throw "not impl";
        else if (u.scope == "uniform")
          if (i.push(u), u.nodes[0] instanceof Ce) {
            let c = new Hs();
            c.name = u.nodes[0].name, c.type = u.nodes[0].type, c.setID = Number.parseInt(u.qualifier.get("set")), c.bindingID = Number.parseInt(u.qualifier.get("binding")), t.uniformInfo.push(c);
          } else if (u.nodes[0] instanceof ir) {
            let c = new Hs();
            c.name = "unif" + t.uniformInfo.length.toString(), c.type = u.nodes[0].name, c.setID = Number.parseInt(u.qualifier.get("set")), c.bindingID = Number.parseInt(u.qualifier.get("binding")), t.uniformInfo.push(c);
          } else
            throw "not impl";
        else
          u.scope == "buffer" && r.push(u);
      else
        a.push(u);
    e.stage = "fragment";
    let o = 0, n = new jr(""), l = this._syntax.lexer.source, h = /* @__PURE__ */ new Map();
    for (; (o = l.indexOf("gl_", o)) != -1; ) {
      n.reset(l.substring(o, o + 32)), n.readChar();
      let u = n.readIdentifier();
      if (o += u.length, !h.has(u))
        switch (h.set(u, u), u) {
          case "gl_InstanceID":
            e.stage = "vertex", e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");
            break;
          case "gl_Position":
            e.stage = "vertex", e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"), e.addIdentifier("gl_Position", "stout.gl_Position");
            break;
          case "gl_VertexIndex":
            e.stage = "vertex", e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");
            break;
          case "gl_FrontFacing":
            e.stage = "fragment", e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");
            break;
          case "gl_FragDepth":
            e.stage = "fragment", e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"), e.addIdentifier("gl_FragDepth", "stout.gl_FragDepth");
            break;
          case "gl_WorkGroupID":
            e.stage = "compute", e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");
            break;
          case "gl_NumWorkGroups":
            e.stage = "compute", e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");
            break;
          case "gl_LocalInvocationID":
            e.stage = "compute", e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");
            break;
          case "gl_LocalInvocationIndex":
            e.stage = "compute", e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");
            break;
          case "gl_GlobalInvocationID":
            e.stage = "compute", e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");
            break;
          default:
            throw "Unprocessed built-in variables: " + u;
        }
    }
    for (let u of i)
      u.nodes[0] instanceof ir && (t.sourceCode += u.nodes[0].formatToWGSL(e, 0), t.sourceCode += `\r
`);
    for (let u of i)
      t.sourceCode += u.formatToWGSL(e, 0);
    t.sourceCode += `\r
`;
    for (let u of r)
      u.nodes[0] instanceof ir && (t.sourceCode += u.nodes[0].formatToWGSL(e, 0), t.sourceCode += `\r
`);
    for (let u of r)
      t.sourceCode += u.formatToWGSL(e, 0);
    t.sourceCode += `\r
`;
    for (let u of a)
      t.sourceCode += u.formatToWGSL(e, 0), u instanceof Ce && (t.sourceCode += `;\r
`);
    return t;
  }
};
var Vs = class {
  constructor(e) {
    __publicField(this, "_stage", "fragment");
    __publicField(this, "_builtinIn", []);
    __publicField(this, "_builtinOut", []);
    __publicField(this, "_layoutsIn", []);
    __publicField(this, "_layoutsOut", []);
    __publicField(this, "_layoutUniformCount", 0);
    __publicField(this, "_workGroupSize");
    __publicField(this, "_parentContext");
    __publicField(this, "_identifierEnv", /* @__PURE__ */ new Map());
    this._parentContext = e;
  }
  get stage() {
    return this.parentContext != null ? this.parentContext.stage : this._stage;
  }
  set stage(e) {
    this.parentContext != null && (this.parentContext.stage = e), this._stage = e;
  }
  get builtinIn() {
    return this.parentContext != null ? this.parentContext.builtinIn : this._builtinIn;
  }
  get builtinOut() {
    return this.parentContext != null ? this.parentContext.builtinOut : this._builtinOut;
  }
  get layoutsIn() {
    return this.parentContext != null ? this.parentContext.layoutsIn : this._layoutsIn;
  }
  get layoutsOut() {
    return this.parentContext != null ? this.parentContext.layoutsOut : this._layoutsOut;
  }
  get layoutUniformCount() {
    return this.parentContext != null ? this.parentContext.layoutUniformCount : this._layoutUniformCount;
  }
  set layoutUniformCount(e) {
    if (this.parentContext != null) {
      this.parentContext.layoutUniformCount = e;
      return;
    }
    this._layoutUniformCount = e;
  }
  get workGroupSize() {
    return this.parentContext != null ? this.parentContext.workGroupSize : this._workGroupSize;
  }
  set workGroupSize(e) {
    this.parentContext != null && (this.parentContext.workGroupSize = e), this._workGroupSize = e;
  }
  get parentContext() {
    return this._parentContext;
  }
  findIdentifier(e) {
    return this._identifierEnv.has(e) ? this._identifierEnv.get(e) : this._parentContext != null ? this._parentContext.findIdentifier(e) : e;
  }
  addIdentifier(e, t) {
    this._identifierEnv.set(e, t);
  }
  hasIdentifier(e) {
    return this._identifierEnv.has(e);
  }
};
var he = class {
  constructor() {
    __publicField(this, "nodes", []);
  }
  addNode(e) {
    this.nodes.push(e);
  }
  formatToWGSL(e, t) {
    return "";
  }
};
var ir = class _ir extends he {
  constructor(e) {
    super();
    __publicField(this, "name", "");
    __publicField(this, "fields", []);
    this.name = e;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.IDENT && e.peekToken(1).Type == v.LEFTBIG) {
      let t = new _ir(e.peekToken(0).Literal);
      for (e.skipToken(2); e.peekToken(0).Type != v.RIGHTBIG; ) {
        let r = Ce.parse(e);
        t.fields.push(r);
      }
      return e.peekToken(0).Type == v.RIGHTBIG && e.skipToken(1), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1), t;
    }
    throw "Error parsing structure: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    r += i + "struct " + this.name + ` {\r
`;
    for (let a of this.fields)
      a.arraySize.nodes.length <= 0 ? r += i + "  " + a.name + ": " + yt(a.type) + `,\r
` : a.arraySize.nodes[0] instanceof sr ? r += i + "  " + a.name + ": array<" + yt(a.type) + ", " + a.arraySize.nodes[0].value + `>,\r
` : r += i + "  " + a.name + ": array<" + yt(a.type) + ", " + a.arraySize.nodes[0].formatToWGSL(e, 0) + `>,\r
`;
    return r += i + `};\r
`, r;
  }
};
var Ha = class _Ha extends he {
  constructor(e, t, r, i) {
    super();
    __publicField(this, "name");
    __publicField(this, "args");
    __publicField(this, "body");
    __publicField(this, "returnType");
    this.name = e, this.args = t, this.body = r, this.returnType = i;
  }
  static parse(e) {
    if ((e.peekToken(0).isBuiltinType() || e.peekToken(0).Type == v.VOID) && e.peekToken(1).Type == v.IDENT && e.peekToken(2).Type == v.LEFTSAMLL) {
      let t = e.peekToken(0).Literal, r = e.peekToken(1).Literal;
      e.skipToken(2);
      let i = new Array();
      if (e.peekToken(0).Type != v.LEFTSAMLL)
        throw "Error parsing function parameter list: Unexpected character";
      for (e.skipToken(1); e.peekToken(0).Type != v.EOF; ) {
        if (e.peekToken(0).Type == v.RIGHTSAMLL) {
          e.skipToken(1);
          break;
        }
        (e.peekToken(0).Type == v.INOUT || e.peekToken(0).Type == v.IN || e.peekToken(0).Type == v.OUT) && e.skipToken(1);
        let o = Ce.parse(e);
        i.push(o), e.peekToken(0).Type == v.COMMA && e.skipToken(1);
      }
      let a = Ut.parse(e);
      return new _Ha(r, i, a, t);
    }
    throw "Error parsing function: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t), a, o = e.layoutsOut.length > 0 || e.builtinOut.length > 0;
    switch (e.stage) {
      case "compute":
        a = "ComputeOutput";
        break;
      case "vertex":
        a = "VertexOutput";
        break;
      case "fragment":
        a = "FragmentOutput";
        break;
      default:
        a = "StructOutput";
        break;
    }
    if (this.name == "main" && o) {
      r += "struct " + a + ` {\r
`;
      for (let u of e.layoutsOut)
        if (u.nodes[0] instanceof Ce) {
          let c = u.nodes[0];
          u.qualifier.size == 1 && u.qualifier.has("location") && (r += "  @location(" + u.qualifier.get("location") + ") "), r += c.name + ": " + yt(c.type) + `,\r
`, e.addIdentifier(c.name, "stout." + c.name);
        }
      let h = e.builtinOut;
      for (let u of h)
        r += "  " + u + `,\r
`;
      r += `};\r
\r
`;
    }
    let n = "";
    if (this.name == "main" && (e.workGroupSize != null ? n += "@" + e.stage + " " + e.workGroupSize.formatToWGSL(e, 0) + ` \r
` : n += "@" + e.stage + `\r
`), e = new Vs(e), n += i + "fn " + this.name + "(", this.name != "main") {
      for (let h = 0; h < this.args.length; h++) {
        let u = this.args[h];
        h > 0 && (n += ", "), n += u.name + ": " + yt(u.type), e.addIdentifier(u.name, u.name);
      }
      n += ") -> " + yt(this.returnType);
    } else {
      let h = e.layoutsIn;
      for (let c = 0; c < h.length; c++) {
        let f = h[c];
        if (c > 0 ? n += `,\r
    ` : n += `\r
    `, f.nodes[0] instanceof Ce) {
          let g = f.nodes[0];
          f.qualifier.size == 1 && f.qualifier.has("location") && (n += "@location(" + f.qualifier.get("location") + ") "), n += g.name + ": " + yt(g.type), e.addIdentifier(g.name, g.name);
        }
      }
      h.length > 0 && (n += `,\r
    `);
      let u = e.builtinIn;
      for (let c of u)
        n += c + `,\r
    `;
      o ? n += ") -> " + a : n += ") ";
    }
    let l = "";
    this.name == "main" && o && (l += "    var stout: " + a + ` ;\r
`);
    for (let h of this.body.nodes)
      l += h.formatToWGSL(e, t + 1), !(h instanceof Lr) && !(h instanceof kr) && !(h instanceof zr) && (l += `;\r
`);
    return this.name == "main" && o && (l += `    return stout;\r
`), r += n + ` {\r
`, r += l, r += i + `}\r
`, r += `\r
`, r;
  }
};
var Ya = class _Ya extends he {
  constructor() {
    super();
    __publicField(this, "args", []);
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.LEFTSAMLL) {
      e.skipToken(1);
      let t = new _Ya();
      for (; e.peekToken(0).Type != v.EOF; ) {
        if (e.peekToken(0).Type == v.RIGHTSAMLL) {
          e.skipToken(1);
          break;
        }
        let r = Z.parse(e);
        t.args.push(r), e.peekToken(0).Type == v.COMMA && e.skipToken(1);
      }
      return t;
    }
    throw "Error parsing function argument table: Unexpected character";
  }
};
var Nr = class _Nr extends he {
  constructor(e, t) {
    super();
    __publicField(this, "name");
    __publicField(this, "args");
    this.name = e, this.args = t;
  }
  static parse(e) {
    if (e.peekToken(0).isDataType() && e.peekToken(1).Type == v.LEFTSAMLL) {
      let t = e.peekToken(0).Literal;
      e.skipToken(1);
      let r = Ya.parse(e);
      return new _Nr(t, r);
    }
    throw "Error parsing function argument table: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    if (this.name == "texture" && this.args.args[0].nodes[0] instanceof _Nr) {
      let a = this.args.args[0].nodes[0];
      if (a.name == "sampler2D") {
        r += i + "textureSample(";
        for (let o = 0; o < a.args.args.length; o++) {
          let n = a.args.args[o];
          o > 0 && (r += ", "), r += n.formatToWGSL(e, 0);
        }
        for (let o = 1; o < this.args.args.length; o++) {
          let n = this.args.args[o];
          o > 0 && (r += ", "), r += n.formatToWGSL(e, 0);
        }
        return r += ")", r;
      }
    }
    r += i + yt(this.name) + "(";
    for (let a = 0; a < this.args.args.length; a++) {
      let o = this.args.args[a];
      a > 0 && (r += ", "), r += o.formatToWGSL(e, 0);
    }
    return r += ")", r;
  }
};
var Ce = class _Ce extends he {
  constructor(e, t, r = new Z()) {
    super();
    __publicField(this, "type");
    __publicField(this, "name");
    __publicField(this, "arraySize");
    __publicField(this, "hasIn");
    __publicField(this, "hasOut");
    __publicField(this, "hasConst");
    this.type = e, this.name = t, this.hasIn = false, this.hasOut = false, this.hasConst = false, this.arraySize = r;
  }
  static parse(e) {
    let t = new _Ce("", ""), r = e.peekToken(0);
    if (r.Type == v.CONST)
      e.skipToken(1), t.hasConst = true;
    else if (r.Type == v.IN)
      e.skipToken(1), t.hasIn = true;
    else if (r.Type == v.OUT)
      e.skipToken(1), t.hasOut = true;
    else if (r.Type == v.INOUT)
      e.skipToken(1), t.hasIn = true, t.hasOut = true;
    else if (!r.isDataType())
      throw "Error parsing declaration expression: Unexpected character(" + r.Literal + ")";
    if (r = e.peekToken(0), r.isDataType() && e.peekToken(1).Type == v.LEFTMEDI) {
      if (t.type = r.Literal, e.skipToken(2), t.arraySize = Z.parse(e), e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1), e.peekToken(0).Type != v.IDENT)
        throw "Unexpected";
      t.name = e.peekToken(0).Literal, e.skipToken(1);
    } else if (r.isDataType() && e.peekToken(1).Type == v.IDENT && e.peekToken(2).Type == v.LEFTMEDI)
      t.type = e.peekToken(0).Literal, t.name = e.peekToken(1).Literal, e.skipToken(3), e.peekToken(0).Type == v.RIGHTMEDI ? e.skipToken(1) : (t.arraySize = Z.parse(e), e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1));
    else if (r.isDataType() && e.peekToken(1).Type == v.IDENT)
      t.type = e.peekToken(0).Literal, t.name = e.peekToken(1).Literal, e.skipToken(2);
    else
      throw "Error parsing declaration expression: Unexpected character(" + r.Literal + ")";
    if (r = e.peekToken(0), r.Type == v.SEMICOLON)
      return e.skipToken(1), t;
    if (r.Type == v.RIGHTSAMLL)
      return t;
    if (r.Type == v.ASSIGN) {
      let i = e.peekToken(0);
      e.skipToken(1);
      let a = new $t(t.name), o = Z.parse(e);
      return e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1), t.addNode(new pr(i, a, o)), t;
    } else if (r.Type == v.COMMA) {
      for (; e.peekToken(0).Type == v.COMMA && e.peekToken(1).Type == v.IDENT; ) {
        let i = new _Ce(t.type, e.peekToken(1).Literal);
        t.addNode(i), e.skipToken(2), e.peekToken(0).Type == v.ASSIGN && (e.skipToken(-1), i.addNode(Z.parse(e)));
      }
      return t;
    }
    throw "Error parsing declaration expression: Unexpected character(" + e.peekToken(0).Literal + ")";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    if (this.hasConst ? r += i + "let " : r += i + "var ", e.addIdentifier(this.name, this.name), this.arraySize.nodes.length <= 0 ? r += this.name + ": " + yt(this.type) : this.arraySize.nodes[0] instanceof sr ? r += this.name + ": array<" + yt(this.type) + ", " + this.arraySize.nodes[0].value + ">" : r += this.name + ": array<" + yt(this.type) + ", " + this.arraySize.nodes[0].formatToWGSL(e, 0) + ">", this.nodes.length > 0 && this.nodes[0] instanceof pr)
      r += " = " + this.nodes[0].rightValue.formatToWGSL(e, 0);
    else if (this.nodes.length > 0 && this.nodes[0] instanceof Z && this.nodes[0].nodes[0] instanceof pr)
      r += " = " + this.nodes[0].nodes[0].rightValue.formatToWGSL(e, 0);
    else if (this.nodes.length > 0 && this.nodes[0] instanceof _Ce) {
      r += `;\r
`;
      for (let a of this.nodes)
        r += a.formatToWGSL(e, t) + `;\r
`;
    } else
      r += `;\r
`;
    return r;
  }
};
var zr = class _zr extends he {
  constructor(e, t, r, i) {
    super();
    __publicField(this, "expression1");
    __publicField(this, "condition");
    __publicField(this, "expression2");
    __publicField(this, "loopBody");
    this.expression1 = e, this.condition = t, this.expression2 = r, this.loopBody = i;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.FOR && e.peekToken(1).Type == v.LEFTSAMLL) {
      e.skipToken(2);
      let t;
      e.peekToken(0).Type == v.SEMICOLON ? (e.skipToken(1), t = new Z()) : e.peekToken(0).isDataType() && e.peekToken(1).Type == v.IDENT && e.peekToken(2).Type == v.ASSIGN ? (t = new Ce(e.peekToken(0).Literal, e.peekToken(1).Literal), e.skipToken(1), t.addNode(Z.parse(e)), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1)) : (t = Z.parse(e), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1));
      let r;
      e.peekToken(0).Type == v.SEMICOLON ? (e.skipToken(1), r = new Z()) : (r = Z.parse(e), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1));
      let i;
      e.peekToken(0).Type == v.SEMICOLON ? (e.skipToken(1), i = new Z()) : (i = Z.parse(e), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1)), e.peekToken(0).Type == v.RIGHTSAMLL && e.skipToken(1);
      let a;
      return e.peekToken(0).Type == v.LEFTBIG ? a = Ut.parse(e) : a = new Ut(), new _zr(t, r, i, a);
    }
    throw "Error parsing for loop: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    r += i + "for (", r += this.expression1.formatToWGSL(e, 0) + "; ", r += this.condition.formatToWGSL(e, 0) + "; ", r += this.expression2.formatToWGSL(e, 0) + ")", r += ` { \r
`;
    for (let a of this.loopBody.nodes)
      r += a.formatToWGSL(e, t + 1), !(a instanceof Lr) && !(a instanceof kr) && !(a instanceof _zr) && (r += `;\r
`);
    return r += i + `} \r
`, r;
  }
};
var kr = class _kr extends he {
  constructor(e, t) {
    super();
    __publicField(this, "conditionExpr");
    __publicField(this, "loopBody");
    this.conditionExpr = e, this.loopBody = t;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.WHILE) {
      e.skipToken(1), e.peekToken(0).Type == v.LEFTSAMLL && e.skipToken(1);
      let t = Z.parse(e);
      e.peekToken(0).Type == v.RIGHTSAMLL && e.skipToken(1);
      let r = Ut.parse(e);
      return new _kr(t, r);
    }
    throw "Error parsing while loop: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    r += i + `loop {\r
`, r += i + "    if (" + this.conditionExpr.formatToWGSL(e, 0) + `) { break; }\r
\r
`;
    for (let a of this.loopBody.nodes)
      r += a.formatToWGSL(e, t + 1), !(a instanceof Lr) && !(a instanceof _kr) && !(a instanceof zr) && (r += `;\r
`);
    return r += i + `}\r
`, r;
  }
};
var bd = class extends he {
  constructor() {
    super();
  }
};
var Lr = class _Lr extends he {
  constructor(e, t, r) {
    super();
    __publicField(this, "conditionExpr");
    __publicField(this, "trueBranch");
    __publicField(this, "falseBranch");
    this.conditionExpr = e, this.trueBranch = t, this.falseBranch = r;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.IF) {
      e.skipToken(1), e.peekToken(0).Type == v.LEFTSAMLL && e.skipToken(1);
      let t = Z.parse(e), r, i = new Ut();
      if (e.peekToken(0).Type == v.RIGHTSAMLL && e.skipToken(1), e.peekToken(0).Type == v.LEFTBIG ? r = Ut.parse(e) : (r = new Ut(), e.peekToken(0).Type == v.RETURN ? r.addNode(ji.parse(e)) : r.addNode(Z.parse(e))), e.peekToken(0).Type == v.ELSE)
        if (e.skipToken(1), e.peekToken(0).Type == v.LEFTBIG)
          i = Ut.parse(e);
        else
          throw "not impl";
      return new _Lr(t, r, i);
    }
    throw "Error parsing IF branch statement: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    r += i + "if (" + this.conditionExpr.formatToWGSL(e, 0) + `) {\r
`;
    for (let a of this.trueBranch.nodes)
      r += a.formatToWGSL(e, t + 1) + `;\r
`;
    if (this.falseBranch.nodes.length > 0) {
      r += i + `} else {\r
`;
      for (let a of this.falseBranch.nodes)
        r += a.formatToWGSL(e, t + 1) + `;\r
`;
    }
    return r += i + `}\r
`, r;
  }
};
var Z = class _Z extends he {
  constructor() {
    super();
  }
  static parse(e) {
    let t = new Array(), r = new Array(), i = 0;
    for (; e.peekToken(0).Type != v.EOF; ) {
      let a = e.peekToken(0);
      if (a.Type == v.SEMICOLON || a.Type == v.RIGHTMEDI || a.Type == v.COMMA || a.Type == v.COLON || a.Type == v.RIGHTBIG)
        break;
      if (a.isOperation()) {
        if (a.isOperation()) {
          if (a.Type == v.INC || a.Type == v.DEC) {
            let o = a;
            e.skipToken(1);
            let n = _Z.parse(e);
            r.push(new qr(o, void 0, n));
            continue;
          } else if (t.length > 0) {
            if (t[t.length - 1].nOperationPriorityLevel <= a.nOperationPriorityLevel)
              _Z.unionOperation(t, r);
            else if (t.length > 0 && t[t.length - 1].Literal == "-") {
              let n = t.pop(), l = r.pop();
              r.push(new qr(n, void 0, l));
            }
          }
          t.push(a), e.skipToken(1);
        }
      } else if (a.Type == v.LITERAL) {
        r.push(new sr(a.Literal)), e.skipToken(1);
        continue;
      } else if (a.Type == v.LEFTSAMLL) {
        i++, t.push(a), e.skipToken(1);
        continue;
      } else if (a.Type == v.RIGHTSAMLL) {
        if (i <= 0)
          break;
        for (i--; _Z.unionOperation(t, r); )
          ;
        if (t[t.length - 1].Type == v.LEFTSAMLL) {
          t.pop();
          let o = new Sl();
          o.addNode(r.pop()), r.push(o);
        }
        e.skipToken(1);
        continue;
      } else if (a.Type == v.IDENT) {
        if (e.peekToken(1).Type == v.INC || e.peekToken(1).Type == v.DEC) {
          let o = e.peekToken(1), n = new $t(a.Literal);
          r.push(new qr(o, n, void 0)), e.skipToken(2);
          continue;
        } else if (e.peekToken(1).Type == v.LEFTSAMLL) {
          r.push(Nr.parse(e));
          continue;
        } else if (e.peekToken(1).Type == v.DOT) {
          r.push(qi.parse(e));
          continue;
        } else if (e.peekToken(1).Type == v.LEFTMEDI) {
          r.push(Gr.parse(e));
          continue;
        }
        r.push(new $t(a.Literal)), e.skipToken(1);
        continue;
      } else {
        if (a.isBuiltinType() && e.peekToken(1).Type == v.LEFTSAMLL) {
          r.push(Nr.parse(e));
          continue;
        }
        if (a.isAssignOperation()) {
          let o = a;
          e.skipToken(1);
          let n = r.pop(), l = _Z.parse(e);
          r.push(new pr(o, n, l));
          continue;
        }
        if (a.Type == v.LEFTBIG && (e.peekToken(1).Type == v.LITERAL || e.peekToken(1).Type == v.SUB && e.peekToken(2).Type == v.LITERAL)) {
          r.push(aa.parse(e));
          continue;
        }
        if (a.Type == v.QUEMARK) {
          t.length > 0 && t[t.length - 1].nOperationPriorityLevel <= a.nOperationPriorityLevel && _Z.unionOperation(t, r), e.skipToken(1);
          let o = r.pop(), n = _Z.parse(e);
          e.peekToken(0).Type == v.COLON && e.skipToken(1);
          let l = _Z.parse(e);
          if (r.push(new yl(o, n, l)), e.peekToken(-1).Type == v.SEMICOLON)
            break;
          continue;
        }
        if (a.Type == v.LEFTMEDI) {
          e.skipToken(1);
          let o = _Z.parse(e);
          e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1);
          let n = r.pop();
          r.push(new Gr(n, o));
          continue;
        }
        throw "An unexpected character";
      }
    }
    for (; t.length > 0 && _Z.unionOperation(t, r); )
      ;
    if (t.length <= 0 && r.length == 1) {
      let a = new _Z();
      return a.addNode(r.pop()), a;
    }
    throw "Error parsing expression: Unexpected character(" + e.peekToken(0).Literal + ")";
  }
  formatToWGSL(e, t) {
    return this.nodes[0].formatToWGSL(e, t);
  }
  static unionOperation(e, t) {
    if (e.length < 0 || t.length < 2) {
      if (e.length > 0 && e[e.length - 1].Literal == "-") {
        let r = e.pop(), i = t.pop();
        return t.push(new qr(r, void 0, i)), true;
      }
      return false;
    }
    if (e[e.length - 1].isOperation()) {
      let r = t.pop(), i = e.pop(), a = t.pop();
      return i.Type == v.DOT ? t.push(new qi(a, r)) : t.push(new pr(i, a, r)), true;
    }
    return false;
  }
};
var Sl = class extends he {
  constructor() {
    super();
  }
  formatToWGSL(e, t) {
    return (t <= 0 ? "" : "    ".repeat(t)) + "(" + this.nodes[0].formatToWGSL(e, 0) + ")";
  }
};
var $t = class extends he {
  constructor(e) {
    super();
    __publicField(this, "name");
    this.name = e;
  }
  formatToWGSL(e, t) {
    return (t <= 0 ? "" : "    ".repeat(t)) + e.findIdentifier(this.name);
  }
};
var sr = class _sr extends he {
  constructor(e) {
    super();
    __publicField(this, "value");
    this.value = e;
  }
  static parse(e) {
    let t = e.peekToken(0);
    if (t.Type == v.SUB && e.peekToken(1).Type == v.LITERAL) {
      let r = new _sr("-" + e.peekToken(1).Literal);
      return e.skipToken(2), r;
    } else if (t.Type == v.LITERAL) {
      let r = new _sr(t.Literal);
      return e.skipToken(1), r;
    }
    throw "Error parsing literal constants: Unexpected characters(" + t.Literal + ")";
  }
  formatToWGSL(e, t) {
    return (t <= 0 ? "" : "    ".repeat(t)) + this.value;
  }
};
var aa = class _aa extends sr {
  constructor(e) {
    super("");
    __publicField(this, "arrayValue");
    this.arrayValue = e;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.LEFTBIG && e.peekToken(1).Type == v.LITERAL || e.peekToken(0).Type == v.LEFTBIG && e.peekToken(1).Type == v.SUB && e.peekToken(2).Type == v.LITERAL) {
      e.skipToken(1);
      let t = [];
      for (; e.peekToken(0).Type != v.RIGHTBIG; ) {
        if (e.peekToken(0).Type == v.LEFTSAMLL) {
          t.push(_aa.parse(e));
          continue;
        }
        if (t.push(sr.parse(e)), e.peekToken(0).Type == v.COMMA) {
          e.skipToken(1);
          continue;
        } else if (e.peekToken(0).Type == v.RIGHTBIG) {
          e.skipToken(1);
          break;
        } else
          throw "Error parsing array constants: Unexpected characters";
      }
      return new _aa(t);
    }
    throw "Error parsing array constants: Unexpected characters";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    this.arrayValue[0].value.includes(".") ? r += i + "array<f32, " + this.arrayValue.length.toString() + ">(" : r += i + "array<i32, " + this.arrayValue.length.toString() + ">(";
    for (let a = 0; a < this.arrayValue.length; a++)
      a > 0 && (r += ", "), r += this.arrayValue[a].formatToWGSL(e, 0);
    return r += ")", r;
  }
};
var Ed = class extends he {
  constructor() {
    super();
  }
};
var Bd = class extends he {
  constructor() {
    super();
  }
};
var Xa = class _Xa extends he {
  constructor() {
    super();
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.CONTINUE && e.peekToken(1).Type == v.SEMICOLON)
      return e.skipToken(2), new _Xa();
    throw "Error parsing continue: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    return r += i + "continue", r;
  }
};
var ji = class _ji extends he {
  constructor(e) {
    super();
    __publicField(this, "value");
    this.value = e;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.RETURN) {
      e.skipToken(1);
      let t = Z.parse(e);
      return e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1), new _ji(t);
    }
    throw "Error parsing return expression: Unexpected character";
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    return r += i + "return " + this.value.formatToWGSL(e, 0), r;
  }
};
var qr = class extends he {
  constructor(e, t, r) {
    super();
    __publicField(this, "op");
    __publicField(this, "leftValue");
    __publicField(this, "rightValue");
    this.op = e, this.leftValue = t, this.rightValue = r;
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    if (this.op.Literal == "++" || this.op.Literal == "--")
      if (this.leftValue != null) {
        let a = this.leftValue.formatToWGSL(e, 0);
        r += i + a + " = " + a + " " + this.op.Literal[0] + " 1";
      } else {
        let a = this.rightValue.formatToWGSL(e, 0);
        r += i + a + " = " + a + " " + this.op.Literal[0] + " 1";
      }
    else
      this.leftValue != null ? r += i + this.leftValue.formatToWGSL(e, 0) + this.op.Literal : r += i + this.op.Literal + this.rightValue.formatToWGSL(e, 0);
    return r;
  }
};
var pr = class extends he {
  constructor(e, t, r) {
    super();
    __publicField(this, "op");
    __publicField(this, "leftValue");
    __publicField(this, "rightValue");
    this.op = e, this.leftValue = t, this.rightValue = r;
  }
  formatToWGSL(e, t) {
    let r = "", i = t <= 0 ? "" : "    ".repeat(t);
    return r += i + this.leftValue.formatToWGSL(e, 0) + " " + this.op.Literal + " " + this.rightValue.formatToWGSL(e, 0), r;
  }
};
var yl = class extends he {
  constructor(e, t, r) {
    super();
    __publicField(this, "condition");
    __publicField(this, "expression1");
    __publicField(this, "expression2");
    this.condition = e, this.expression1 = t, this.expression2 = r;
  }
  static parse(e) {
    throw "Error parsing ternary operation expression: Unexpected character";
  }
  formatToWGSL(e, t) {
    return "";
  }
};
var qi = class _qi extends he {
  constructor(e, t) {
    super();
    __publicField(this, "leftValue");
    __publicField(this, "rightValue");
    this.leftValue = e, this.rightValue = t;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.IDENT && e.peekToken(1).Type == v.DOT && e.peekToken(2).Type == v.IDENT) {
      let t = new $t(e.peekToken(0).Literal), r = new $t(e.peekToken(2).Literal);
      return e.skipToken(3), new _qi(t, r);
    }
    throw "Error parsing selection expression: Unexpected character";
  }
  formatToWGSL(e, t) {
    return (t <= 0 ? "" : "    ".repeat(t)) + this.leftValue.formatToWGSL(e, 0) + "." + this.rightValue.formatToWGSL(e, 0);
  }
};
var Gr = class _Gr extends he {
  constructor(e, t) {
    super();
    __publicField(this, "leftValue");
    __publicField(this, "indexValue");
    this.leftValue = e, this.indexValue = t;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.IDENT && e.peekToken(1).Type == v.LEFTMEDI) {
      let t = new $t(e.peekToken(0).Literal);
      e.skipToken(2);
      let r = Z.parse(e);
      e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1);
      let i = new _Gr(t, r);
      for (; e.peekToken(0).Type == v.LEFTMEDI; )
        e.skipToken(1), r = Z.parse(e), e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1), i = new _Gr(i, r);
      return i;
    }
    throw "Error parsing index expression: Unexpected character";
  }
  formatToWGSL(e, t) {
    return (t <= 0 ? "" : "    ".repeat(t)) + this.leftValue.formatToWGSL(e, 0) + "[" + this.indexValue.formatToWGSL(e, 0) + "]";
  }
};
var Ut = class _Ut extends he {
  constructor() {
    super();
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.LEFTBIG) {
      e.skipToken(1);
      let t = new _Ut();
      for (let r = 1; r > 0 && e.peekToken(0).Type != v.EOF; ) {
        let i = e.peekToken(0);
        if (i.Type == v.LEFTBIG) {
          r++, e.skipToken(1);
          continue;
        }
        if (i.Type == v.RIGHTBIG) {
          r--, e.skipToken(1);
          continue;
        }
        if (i.Type == v.SEMICOLON) {
          e.skipToken(1);
          continue;
        }
        if (i.isDataType() && e.peekToken(1).Type == v.IDENT) {
          t.addNode(Ce.parse(e));
          continue;
        }
        if (i.Type == v.CONST && e.peekToken(1).isDataType() && e.peekToken(2).Type == v.IDENT) {
          t.addNode(Ce.parse(e));
          continue;
        } else if (i.Type == v.IDENT && e.peekToken(1).Type == v.ASSIGN) {
          t.addNode(Z.parse(e)), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1);
          continue;
        } else if (i.Type == v.IDENT && e.peekToken(1).Type == v.LEFTMEDI) {
          let a = Gr.parse(e);
          if (e.peekToken(0).Type == v.ASSIGN) {
            let o = e.peekToken(0);
            e.skipToken(1);
            let n = Z.parse(e);
            e.peekToken(0).Type == v.RIGHTMEDI && e.skipToken(1), t.addNode(new pr(o, a, n));
            continue;
          }
          t.addNode(a);
          continue;
        } else if (i.Type == v.IDENT && e.peekToken(1).Type == v.DOT) {
          let a = Z.parse(e);
          t.addNode(a);
          continue;
        } else if (i.Type == v.IDENT && e.peekToken(1).isAssignOperation()) {
          let a = e.peekToken(1), o = new $t(i.Literal);
          e.skipToken(2);
          let n = Z.parse(e);
          e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1), t.addNode(new pr(a, o, n));
          continue;
        } else if (i.Type == v.IDENT && (e.peekToken(1).Type == v.INC || e.peekToken(1).Type == v.DEC) && e.peekToken(2).Type == v.SEMICOLON) {
          let a = e.peekToken(1);
          t.addNode(new qr(a, new $t(i.Literal), void 0)), e.skipToken(3);
          continue;
        } else if (i.Type == v.RETURN) {
          t.addNode(ji.parse(e));
          continue;
        } else if (i.Type == v.CONTINUE) {
          t.addNode(Xa.parse(e));
          continue;
        } else if (i.Type == v.WHILE) {
          t.addNode(kr.parse(e));
          continue;
        } else if (i.Type == v.FOR) {
          t.addNode(zr.parse(e));
          continue;
        } else if (i.Type == v.IF) {
          t.addNode(Lr.parse(e));
          continue;
        } else if (i.Type == v.IDENT && e.peekToken(1).Type == v.LEFTSAMLL) {
          t.addNode(Nr.parse(e)), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(0);
          continue;
        }
        throw "Error parsing block: Unexpected symbol(" + i.Literal + ")";
      }
      return t;
    }
    throw "Error parsing block: Unexpected symbol";
  }
};
var Wa = class _Wa extends he {
  constructor(e, t) {
    super();
    __publicField(this, "type");
    __publicField(this, "qualifier");
    this.type = t, this.qualifier = e;
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.PRECISION && e.peekToken(1).Type == v.IDENT && e.peekToken(2).isBuiltinType()) {
      let t = new _Wa(e.peekToken(1).Literal, e.peekToken(2).Literal);
      return e.skipToken(3), e.peekToken(0).Type == v.SEMICOLON && e.skipToken(1), t;
    }
    throw "Error parsing precision qualifier: Unexpected character";
  }
  formatToWGSL(e, t) {
    return "";
  }
};
var Ki = class _Ki extends he {
  constructor() {
    super();
    __publicField(this, "scope", "");
    __publicField(this, "qualifier", /* @__PURE__ */ new Map());
  }
  addQualifier(e, t = "") {
    this.qualifier.set(e, t);
  }
  static parse(e) {
    if (e.peekToken(0).Type == v.LAYOUT && e.peekToken(1).Type == v.LEFTSAMLL) {
      let t = new _Ki();
      e.skipToken(2);
      do
        if (e.peekToken(0).Type == v.IDENT) {
          if (e.peekToken(1).Type == v.ASSIGN && e.peekToken(2).Type == v.LITERAL) {
            let i = e.peekToken(0).Literal, a = e.peekToken(2).Literal;
            if (t.addQualifier(i, a), e.skipToken(3), e.peekToken(0).Type == v.COMMA) {
              e.skipToken(1);
              continue;
            }
            let o = e.peekToken(0);
            o.Line = 0;
          } else if (e.peekToken(1).Type == v.RIGHTSAMLL) {
            let i = e.peekToken(0).Literal;
            t.addQualifier(i, ""), e.skipToken(1);
            break;
          } else if (e.peekToken(1).Type == v.COMMA) {
            let i = e.peekToken(0).Literal;
            t.addQualifier(i, ""), e.skipToken(2);
            continue;
          }
        }
      while (e.peekToken(0).Type != v.RIGHTSAMLL);
      if (e.peekToken(0).Type == v.RIGHTSAMLL && e.skipToken(1), t.scope = e.peekToken(0).Literal, e.skipToken(1), e.peekToken(0).Type == v.SEMICOLON)
        return e.skipToken(1), t;
      if (e.peekToken(0).isBuiltinType() && e.peekToken(1).Type == v.IDENT && e.peekToken(2).Type == v.SEMICOLON) {
        let r = new Ce(e.peekToken(0).Literal, e.peekToken(1).Literal);
        return t.addNode(r), e.skipToken(3), t;
      } else if (e.peekToken(0).Type == v.IDENT && e.peekToken(1).Type == v.LEFTBIG) {
        let r = ir.parse(e);
        return t.addNode(r), e.peekToken(0).Type == v.IDENT && e.peekToken(1).Type == v.SEMICOLON && (r.addNode(new Ce(r.name, e.peekToken(0).Literal)), e.skipToken(2)), t;
      } else
        throw "Error parsing layout qualifier type: Unexpected symbol(" + e.peekToken(0).Literal + ")";
    }
    throw "Error parsing layout qualifier: Unexpected symbol";
  }
  formatToWGSL(e, t) {
    let r = "";
    if (this.qualifier.size == 1 && this.qualifier.has("location"))
      r += "@location(" + this.qualifier.get("location") + ") ";
    else if (this.qualifier.size == 2 && this.qualifier.has("set") && this.qualifier.has("binding"))
      r += "@group(" + this.qualifier.get("set") + ") @binding(" + this.qualifier.get("binding") + ") ";
    else if (this.qualifier.size >= 1 && this.qualifier.has("binding"))
      r += "@group(0) @binding(" + this.qualifier.get("binding") + ") ";
    else if (this.qualifier.size == 1 && this.qualifier.has("push_constant"))
      r += "@push_constant ";
    else if (this.qualifier.size >= 1 && this.qualifier.has("local_size_x"))
      r += "@workgroup_size(", r += this.qualifier.get("local_size_x") + ", ", r += this.qualifier.has("local_size_y") ? this.qualifier.get("local_size_y") + ", " : "1, ", r += this.qualifier.has("local_size_z") ? this.qualifier.get("local_size_z") + "" : "1", r += ")";
    else if (this.nodes.length <= 0)
      return "";
    let i = this.nodes[0];
    if (i instanceof Ce) {
      switch (i.type) {
        case "sampler":
        case "texture2D":
          r += "var ";
          break;
        default:
          this.scope == "buffer" ? e.stage == "compute" ? r += "var<storage, read_write> " : r += "var<storage, read> " : r += "var<" + this.scope + "> ";
          break;
      }
      e.addIdentifier(i.name, i.name), r += i.name + ": " + yt(i.type) + `;\r
`;
    } else if (i instanceof ir) {
      if (this.scope == "buffer" ? e.stage == "compute" ? r += "var<storage, read_write> " : r += "var<storage, read> " : r += "var<" + this.scope + "> ", i.nodes.length <= 0) {
        let a = "unif" + e.layoutUniformCount.toString();
        for (; e.hasIdentifier(a); )
          e.layoutUniformCount++, a = "unif" + e.layoutUniformCount.toString();
        for (let o of i.fields)
          e.addIdentifier(o.name, a + "." + o.name);
        r += a + ": " + i.name + `;\r
`, e.layoutUniformCount++;
      } else {
        let a = i.nodes[0];
        r += a.name + ": " + a.type + `;\r
`;
      }
      return r;
    }
    return r;
  }
};
function yt(s) {
  switch (s) {
    case "int":
      return "i32";
    case "int[]":
      return "array<i32>";
    case "uint":
      return "u32";
    case "uint[]":
      return "array<u32>";
    case "float":
      return "f32";
    case "float[]":
      return "array<f32>";
    case "vec2":
      return "vec2<f32>";
    case "vec3":
      return "vec3<f32>";
    case "vec4":
      return "vec4<f32>";
    case "vec2[]":
      return "array<vec2<f32>>";
    case "vec3[]":
      return "array<vec3<f32>>";
    case "vec4[]":
      return "array<vec4<f32>>";
    case "ivec2":
      return "vec2<i32>";
    case "ivec3":
      return "vec3<i32>";
    case "ivec4":
      return "vec4<i32>";
    case "ivec2[]":
      return "array<vec2<i32>>";
    case "ivec3[]":
      return "array<vec3<i32>>";
    case "ivec4[]":
      return "array<vec4<i32>>";
    case "mat2":
      return "mat2x2<f32>";
    case "mat2x2":
      return "mat2x2<f32>";
    case "mat2x3":
      return "mat2x3<f32>";
    case "mat2x4":
      return "mat2x4<f32>";
    case "mat2[]":
      return "array<mat2x2<f32>>";
    case "mat2x2[]":
      return "array<mat2x2<f32>>";
    case "mat2x3[]":
      return "array<mat2x3<f32>>";
    case "mat2x4[]":
      return "array<mat2x4<f32>>";
    case "mat3":
      return "mat3x3<f32>";
    case "mat3x2":
      return "mat3x2<f32>";
    case "mat3x3":
      return "mat3x3<f32>";
    case "mat3x4":
      return "mat3x4<f32>";
    case "mat3[]":
      return "array<mat3x3<f32>>";
    case "mat3x2[]":
      return "array<mat3x2<f32>>";
    case "mat3x3[]":
      return "array<mat3x3<f32>>";
    case "mat3x4[]":
      return "array<mat3x4<f32>>";
    case "mat4":
      return "mat4x4<f32>";
    case "mat4x2":
      return "mat4x2<f32>";
    case "mat4x3":
      return "mat4x3<f32>";
    case "mat4x4":
      return "mat4x4<f32>";
    case "mat4[]":
      return "array<mat4x4<f32>>";
    case "mat4x2[]":
      return "array<mat4x2<f32>>";
    case "mat4x3[]":
      return "array<mat4x3<f32>>";
    case "mat4x4[]":
      return "array<mat4x4<f32>>";
    case "texture2D":
      return "texture_2d<f32>";
  }
  return s;
}
var wl = class {
  constructor(e) {
    __publicField(this, "_lexer");
    __publicField(this, "_rootNode");
    this._lexer = e, this._rootNode = new he(), this.parse();
  }
  get lexer() {
    return this._lexer;
  }
  parse() {
    for (; this.peekToken(0).Type !== v.EOF; ) {
      if (this.peekToken(0).Type == v.SEMICOLON) {
        this.skipToken(1);
        continue;
      }
      let e = this.parseStatement();
      e !== null && this._rootNode.addNode(e);
    }
  }
  parseStatement() {
    let e = this.peekToken();
    if (e.Type == v.LAYOUT && this.peekToken(1).Type == v.LEFTSAMLL)
      return Ki.parse(this._lexer);
    if (e.Type == v.STRUCT)
      return this.skipToken(1), ir.parse(this._lexer);
    if ((e.isBuiltinType() || e.Type == v.VOID) && this.peekToken(1).Type == v.IDENT && this.peekToken(2).Type == v.LEFTSAMLL)
      return Ha.parse(this._lexer);
    if (e.Type == v.CONST && this.peekToken(1).isDataType())
      return Ce.parse(this._lexer);
    if (e.isDataType() && this.peekToken(1).Type == v.IDENT)
      return Ce.parse(this._lexer);
    if (e.Type == v.OUT && this.peekToken(1).isDataType() && this.peekToken(2).Type == v.IDENT)
      return Ce.parse(this._lexer);
    if (e.Type == v.PRECISION)
      return Wa.parse(this._lexer);
    throw "Error parsing statement: Unexpected character";
  }
  skipToken(e) {
    this._lexer.skipToken(e);
  }
  peekToken(e = 0) {
    return this._lexer.peekToken(e);
  }
  getNextToken() {
    return this._lexer.GetNextToken();
  }
  get ASTRoot() {
    return this._rootNode;
  }
};
var Il = class {
  static convertGLSL(e) {
    var t = new _l(e), r = new xl(t), i = new wl(r), a = new Cl(i);
    return a.generateWGSL();
  }
};
__publicField(Il, "VertexShader", "VertexShader");
__publicField(Il, "FragmentShader", "FragmentShader");
var Hs = class {
  constructor() {
    __publicField(this, "setID", 0);
    __publicField(this, "bindingID", 0);
    __publicField(this, "name", "");
    __publicField(this, "type", "");
  }
};
var Ys = class {
  constructor() {
    __publicField(this, "name", "");
    __publicField(this, "type", "");
    __publicField(this, "locationID", 0);
    __publicField(this, "builtinName", "");
  }
  isBuiltinAttribute() {
    return this.builtinName != "";
  }
};
var bl = class {
  constructor() {
    __publicField(this, "uniformInfo", []);
    __publicField(this, "inputAttribute", []);
    __publicField(this, "outputAttribute", []);
    __publicField(this, "sourceCode", "");
  }
};
var Pt = ((s) => (s[s.vertex = 0] = "vertex", s[s.fragment = 1] = "fragment", s[s.computer = 2] = "computer", s))(Pt || {});
var El = class {
  constructor() {
    __publicField(this, "blendMode", re.NONE);
    __publicField(this, "depthCompare", kt.less);
    __publicField(this, "depthWriteEnabled", true);
    __publicField(this, "frontFace", "ccw");
    __publicField(this, "cullMode", nt.back);
    __publicField(this, "topology", Ai.triangle_list);
    __publicField(this, "depthBias", 10);
    __publicField(this, "useLight", false);
    __publicField(this, "useProbe", false);
    __publicField(this, "acceptGI", false);
    __publicField(this, "acceptShadow", false);
    __publicField(this, "castShadow", false);
    __publicField(this, "castReflection", false);
    __publicField(this, "receiveEnv", false);
    __publicField(this, "renderLayer", 1e3);
    __publicField(this, "renderOrder", 2e3);
    __publicField(this, "unclippedDepth", false);
    __publicField(this, "transparent", false);
    __publicField(this, "multisample", 0);
    __publicField(this, "label");
    __publicField(this, "useZ", true);
    __publicField(this, "splitTexture", false);
    __publicField(this, "alphaCutoff");
    __publicField(this, "useFragDepth", false);
    __publicField(this, "writeMasks", []);
  }
  setFromMapValues(e) {
    e.has("blendMode") && (this.blendMode = this.convertBlendMode(e.get("blendMode"))), e.has("depthCompare") && (this.depthCompare = e.get("depthCompare")), e.has("depthWriteEnabled") && (this.depthWriteEnabled = e.get("depthWriteEnabled")), e.has("frontFace") && (this.frontFace = e.get("frontFace")), e.has("cullMode") && (this.cullMode = e.get("cullMode")), e.has("topology") && (this.topology = e.get("topology")), e.has("depthBias") && (this.depthBias = e.get("depthBias")), e.has("useLight") && (this.useLight = e.get("useLight")), e.has("useProbe") && (this.useProbe = e.get("useProbe")), e.has("acceptGI") && (this.acceptGI = e.get("acceptGI")), e.has("acceptShadow") && (this.acceptShadow = e.get("acceptShadow")), e.has("castShadow") && (this.castShadow = e.get("castShadow")), e.has("receiveEnv") && (this.receiveEnv = e.get("receiveEnv")), e.has("renderLayer") && (this.renderLayer = e.get("renderLayer")), e.has("renderOrder") && (this.renderOrder = e.get("renderOrder")), e.has("unclippedDepth") && (this.unclippedDepth = e.get("unclippedDepth")), e.has("multisample") && (this.multisample = e.get("multisample")), e.has("label") && (this.label = e.get("label")), e.has("useZ") && (this.useZ = e.get("useZ"));
  }
  convertBlendMode(e) {
    switch (e) {
      case "ABOVE":
        return re.ABOVE;
      case "ALPHA":
        return re.ALPHA;
      case "NORMAL":
        return re.NORMAL;
      case "ADD":
        return re.ADD;
      case "BELOW":
        return re.BELOW;
      case "ERASE":
        return re.ERASE;
      case "MUL":
        return re.MUL;
      case "SCREEN":
        return re.SCREEN;
      case "DIVD":
        return re.DIVD;
      case "SOFT_ADD":
        return re.SOFT_ADD;
    }
    return re.NONE;
  }
};
var Bl = class extends Jt {
  constructor() {
    super();
    __publicField(this, "uniformNodes", []);
    __publicField(this, "_onChange", true);
    this.bufferType = Tt.MaterialDataUniformGPUBuffer;
  }
  initDataUniform(e) {
    this.uniformNodes = e;
    let t = 0;
    for (const r in e) {
      const i = e[r];
      i || console.error(r, "is empty"), t += i.size * 4;
    }
    t = Math.floor(t / 256 + 1) * 256, this.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, t / 4, null, "MaterialDataUniformGPUBuffer");
    for (const r in e) {
      const i = e[r];
      i || console.error(r, "is empty");
      let a = this.memory.allocation_node(i.size * 4);
      i.memoryInfo = a, i.bindOnChange = () => this.onChange();
    }
  }
  onChange() {
    this._onChange = true;
  }
  apply() {
    if (this.uniformNodes.length != 0 && this._onChange) {
      for (const e in this.uniformNodes)
        this.uniformNodes[e].update();
      super.apply(), this._onChange = false;
    }
  }
};
var er = class {
  static init() {
    this.renderShaderModulePool = /* @__PURE__ */ new Map(), this.renderShader = /* @__PURE__ */ new Map();
  }
};
__publicField(er, "renderShaderModulePool");
__publicField(er, "renderShader");
var _ie = class _ie {
  constructor() {
    __publicField(this, "reference");
  }
  static getInstance() {
    return this._ins || (this._ins = new _ie()), this._ins;
  }
  attached(e, t) {
    this.reference || (this.reference = /* @__PURE__ */ new Map());
    let r = this.reference.get(e);
    r || (r = /* @__PURE__ */ new Map()), r.set(t, e), this.reference.set(e, r);
  }
  detached(e, t) {
    let r = this.reference.get(e);
    r && r.delete(t);
  }
  hasReference(e) {
    let t = this.reference.get(e);
    return t ? t.size > 0 : false;
  }
  getReferenceCount(e) {
    let t = this.reference.get(e);
    return t ? t.size : 0;
  }
  getReference(e) {
    let t = this.reference.get(e);
    return t || null;
  }
};
__publicField(_ie, "_ins");
var ie = _ie;
var Xs = class {
  static getSharePipeline(e) {
    let t = this.pipelineMap.get(e);
    return t || null;
  }
  static setSharePipeline(e, t) {
    this.pipelineMap.set(e, t);
  }
};
__publicField(Xs, "pipelineMap", /* @__PURE__ */ new Map());
var ve = class _ve extends Es {
  constructor(e, t) {
    super();
    __publicField(this, "passType", q.COLOR);
    __publicField(this, "useRz", false);
    __publicField(this, "vsName");
    __publicField(this, "fsName");
    __publicField(this, "shaderState");
    __publicField(this, "textures");
    __publicField(this, "pipeline");
    __publicField(this, "bindGroupLayouts");
    __publicField(this, "envMap");
    __publicField(this, "prefilterMap");
    __publicField(this, "_sourceVS");
    __publicField(this, "_sourceFS");
    __publicField(this, "_destVS");
    __publicField(this, "_destFS");
    __publicField(this, "_vsShaderModule");
    __publicField(this, "_fsShaderModule");
    __publicField(this, "_textureGroup", -1);
    __publicField(this, "_textureChange", false);
    __publicField(this, "_groupsShaderReflectionVarInfos");
    __publicField(this, "outBufferMask");
    __publicField(this, "_cacheEntries");
    this.vsName = e.toLowerCase(), this.fsName = t.toLowerCase(), this.vsName in O || console.error("Shader Not Register, Please Register Shader!", this.vsName), this.fsName in O || console.error("Shader Not Register, Please Register Shader!", this.fsName), O[this.vsName] && (this._sourceVS = O[this.vsName]), O[this.fsName] && (this._sourceFS = O[this.fsName]), this.textures = {}, this.bindGroups = [], this.shaderState = new El(), this.materialDataUniformBuffer = new Bl(), this.materialDataUniformBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, this._bufferDic.set("global", this.materialDataUniformBuffer), this._bufferDic.set("materialUniform", this.materialDataUniformBuffer);
  }
  get renderOrder() {
    return this.shaderState.renderOrder;
  }
  set renderOrder(e) {
    this.shaderState.renderOrder != e && (this._valueChange = true), this.shaderState.renderOrder = e;
  }
  get doubleSide() {
    return this.shaderState.cullMode == nt.none;
  }
  set doubleSide(e) {
    let t = e ? nt.none : this.cullMode;
    this.shaderState.cullMode != t && (this._valueChange = true), this.shaderState.cullMode = t;
  }
  get depthWriteEnabled() {
    return this.shaderState.depthWriteEnabled;
  }
  set depthWriteEnabled(e) {
    this.shaderState.depthWriteEnabled != e && (this._valueChange = true), this.shaderState.depthWriteEnabled = e;
  }
  get cullMode() {
    return this.shaderState.cullMode;
  }
  set cullMode(e) {
    this.shaderState.cullMode != e && (this._valueChange = true), this.shaderState.cullMode = e;
  }
  get frontFace() {
    return this.shaderState.frontFace;
  }
  set frontFace(e) {
    this.shaderState.frontFace != e && (this._valueChange = true), this.shaderState.frontFace = e;
  }
  get depthBias() {
    return this.shaderState.depthBias;
  }
  set depthBias(e) {
    this.shaderState.depthBias != e && (this._valueChange = true), this.shaderState.depthBias = e;
  }
  get topology() {
    return this.shaderState.topology;
  }
  set topology(e) {
    this.shaderState.topology != e && (this._valueChange = true), this.shaderState.topology = e;
  }
  get blendMode() {
    return this.shaderState.blendMode;
  }
  set blendMode(e) {
    this.shaderState.blendMode != e && (this._valueChange = true, e != re.NORMAL && e != re.NONE && (this.renderOrder = 3e3)), this.shaderState.blendMode = e;
  }
  get depthCompare() {
    return this.shaderState.depthCompare;
  }
  set depthCompare(e) {
    this.shaderState.depthCompare != e && (this._valueChange = true), this.shaderState.depthCompare = e;
  }
  setShaderEntry(e = "", t = "") {
    this.vsEntryPoint = e, this.fsEntryPoint = t;
  }
  setUniform(e, t) {
    super.setUniform(e, t), this.materialDataUniformBuffer.onChange();
  }
  setTexture(e, t) {
    t && this.textures[e] != t && (this.textures[e] && this.textures[e].unBindStateChange(this), this._textureChange = true, this.textures[e] = t, e == "envMap" ? this.envMap = t : e == "prefilterMap" && (this.prefilterMap = t), t.bindStateChange(() => {
      this._textureChange = true;
    }, this));
  }
  get baseColor() {
    return this.getUniform("baseColor");
  }
  set baseColor(e) {
    this.setUniform("baseColor", e);
  }
  getTexture(e) {
    return this.textures[e];
  }
  genRenderPipeline(e, t) {
    let r = this.createGroupLayouts();
    this.createPipeline(e, t, r);
  }
  reBuild(e, t) {
    this.compileShader(Pt.vertex, this._destVS, t), this.compileShader(Pt.fragment, this._destFS, t), this.genRenderPipeline(e, t);
  }
  apply(e, t, r) {
    this.materialDataUniformBuffer.apply(), this._textureChange && this._textureGroup != -1 && (this._textureChange = false, this.genGroups(this._textureGroup, this.shaderReflection.groups, true)), this._valueChange && (this._shaderChange && (this.preCompile(e), this._shaderChange = false), this.shaderVariant = Je.genRenderShaderVariant(this), this.reBuild(e, t), this._valueChange = false, r && r());
  }
  preCompile(e) {
    this.preDefine(e), this.preCompileShader(Pt.vertex, this._sourceVS.concat()), this.preCompileShader(Pt.fragment, this._sourceFS.concat()), this.genReflection();
  }
  applyPostDefine(e, t) {
    return t.renderTargetTextures.length > 1 ? (this.defineValue.USE_WORLDPOS = true, this.defineValue.USEGBUFFER = true) : (this.defineValue.USE_WORLDPOS = false, this.defineValue.USEGBUFFER = false), Dt.parse(e, this.defineValue);
  }
  setBindGroup(e, t) {
    this.bindGroups[e] = t;
  }
  checkBuffer(e, t) {
  }
  preCompileShader(e, t, r) {
    let i = t;
    if (i.indexOf("version ") != -1) {
      var a = Il.convertGLSL(i);
      i = a.sourceCode;
    }
    for (const o in this.constValues)
      if (Object.prototype.hasOwnProperty.call(this.constValues, o)) {
        const n = this.constValues[o];
        i = i.replaceAll(`&${o}`, n.toString());
      }
    switch (e) {
      case Pt.vertex:
        this._destVS = i;
        break;
      case Pt.fragment:
        this._destFS = i;
        break;
    }
  }
  compileShader(e, t, r) {
    let i = t;
    i = this.applyPostDefine(i, r);
    let a = t;
    for (let n in this.defineValue)
      a += `${n}=${this.defineValue[n]},`;
    let o = er.renderShaderModulePool.get(a);
    switch (o || (i = this.applyPostDefine(i, r), o = w.device.createShaderModule({ label: e == Pt.vertex ? this.vsName : this.fsName, code: i }), o.getCompilationInfo().then((n) => {
      n.messages.length > 0 && (console.log(i), console.log(n));
    }), er.renderShaderModulePool.set(a, o)), e) {
      case Pt.vertex:
        this._vsShaderModule = o, this._destVS = i;
        break;
      case Pt.fragment:
        this._fsShaderModule = o, this._destFS = i;
        break;
    }
  }
  getGroupLayout(e, t) {
    let r = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i];
      if (a)
        if (a.varType == "uniform") {
          this._bufferDic.has(a.varName) || console.error(`not set ${a.varName} buffer`);
          let o = this._bufferDic.get(a.varName).visibility, n = { binding: a.binding, visibility: o, buffer: { type: "uniform" } };
          r.push(n);
        } else if (a.varType == "storage-read") {
          this._bufferDic.has(a.varName) || console.error(`not set ${a.varName} buffer`);
          let o = this._bufferDic.get(a.varName).visibility, n = { binding: a.binding, visibility: o, buffer: { type: "read-only-storage" } };
          r.push(n);
        } else if (a.varType == "var")
          switch (a.dataType) {
            case "sampler":
              {
                let o = a.varName.replace("Sampler", ""), n = this.textures[o] ? this.textures[o] : p.res.redTexture, l = { binding: a.binding, visibility: n.visibility, sampler: n.samplerBindingLayout };
                r.push(l), this._textureGroup = e;
              }
              break;
            case "sampler_comparison":
              {
                let o = a.varName.replace("Sampler", ""), n = this.textures[o] ? this.textures[o] : p.res.redTexture, l = { binding: a.binding, visibility: n.visibility, sampler: n.sampler_comparisonBindingLayout };
                r.push(l), this._textureGroup = e;
              }
              break;
            case "texture_2d<f32>":
            case "texture_2d_array<f32>":
            case "texture_cube<f32>":
            case "texture_depth_2d":
            case "texture_depth_2d_array":
            case "texture_depth_cube":
            case "texture_depth_cube_array":
              {
                let o = this.textures[a.varName] ? this.textures[a.varName] : p.res.redTexture, n = { binding: a.binding, visibility: o.visibility, texture: o.textureBindingLayout };
                r.push(n), this._textureGroup = e, ie.getInstance().attached(o, this);
              }
              break;
            case "texture_external":
              {
                let o = this.textures[a.varName] ? this.textures[a.varName] : p.res.redTexture, n = { binding: a.binding, visibility: o.visibility, externalTexture: {} };
                r.push(n), this._textureGroup = e, ie.getInstance().attached(o, this);
              }
              break;
            default:
              {
                let o = this.textures[a.varName] ? this.textures[a.varName] : p.res.redTexture, n = { binding: a.binding, visibility: o.visibility, texture: o.textureBindingLayout };
                r.push(n), this._textureGroup = e, ie.getInstance().attached(o, this);
              }
              break;
          }
        else {
          debugger;
          console.error("bind group can't empty");
        }
    }
    return r;
  }
  genGroups(e, t, r = false) {
    if (!this.bindGroups[e] || r) {
      const i = t[e];
      let a = [];
      for (let n = 0; n < i.length; n++) {
        const l = i[n];
        if (l) {
          if (l.varType == "uniform") {
            let h = this._bufferDic.get(l.varName);
            if (h) {
              if (h.bufferType == Tt.MaterialDataUniformGPUBuffer) {
                let c = [];
                for (let f = 0; f < l.dataFields.length; f++) {
                  const g = l.dataFields[f];
                  this.uniforms[g.name] || console.error(`shader-${this.vsName}:${this.fsName} ${g.name}is empty`), c.push(this.uniforms[g.name]);
                }
                this.materialDataUniformBuffer.initDataUniform(c);
              }
              let u = { binding: l.binding, resource: { buffer: h.buffer, offset: 0, size: h.memory.shareDataBuffer.byteLength } };
              a.push(u), this.checkBuffer(l.varName, h);
            } else
              console.error(`shader${this.vsName}-${this.fsName}`, `buffer ${l.varName} is missing!`);
          } else if (l.varType == "storage-read") {
            let h = this._bufferDic.get(l.varName);
            if (h) {
              let u = { binding: l.binding, resource: { buffer: h.buffer, offset: 0, size: h.memory.shareDataBuffer.byteLength } };
              a.push(u), this.checkBuffer(l.varName, h);
            } else
              console.error(`buffer ${l.varName} is missing!`);
          } else if (l.varType == "var")
            if (l.dataType == "sampler") {
              let h = l.varName.replace("Sampler", ""), u = this.textures[h];
              if (u || (u = p.res.blackTexture, this.setTexture(h, u)), u) {
                let c = { binding: l.binding, resource: u.gpuSampler };
                a.push(c);
              } else
                console.error(`shader${this.vsName}-${this.fsName}`, `texture ${l.varName} is missing! `);
            } else if (l.dataType == "sampler_comparison") {
              let h = l.varName.replace("Sampler", ""), u = this.textures[h];
              if (u) {
                let c = { binding: l.binding, resource: u.gpuSampler_comparison };
                a.push(c);
              } else
                console.error(`shader${this.vsName}-${this.fsName}`, `texture ${l.varName} is missing! `);
            } else {
              let h = this.textures[l.varName];
              if (h || (h = p.res.whiteTexture, this.setTexture(l.varName, h)), h) {
                let u = { binding: l.binding, resource: h.getGPUView() };
                a.push(u);
              } else
                console.error(`shader${this.vsName}-${this.fsName}`, `texture ${l.varName} is missing! `);
            }
        }
      }
      let o = w.device.createBindGroup({ layout: this.bindGroupLayouts[e], entries: a });
      this.bindGroups[e] = o;
    }
  }
  createPipeline(e, t, r) {
    let i = e, a = this.shaderState, o = [];
    for (const h of t.renderTargetTextures)
      o.push({ format: h.format });
    for (let h = 0; h < o.length; h++) {
      const u = o[h];
      a.writeMasks && a.writeMasks.length > 0 && (u.writeMask = a.writeMasks[h]);
    }
    if (t.outColor != -1) {
      let h = o[t.outColor];
      a.blendMode != re.NONE ? h.blend = Al.getBlend(a.blendMode) : delete h.blend;
    }
    let n = { label: this.vsName + "|" + this.fsName, layout: r, primitive: { topology: a.topology, cullMode: a.cullMode, frontFace: a.frontFace }, vertex: void 0 };
    this.vsEntryPoint != "" && (n.vertex = { module: this._vsShaderModule, entryPoint: this.vsEntryPoint, buffers: i.vertexBuffer.vertexBufferLayouts }), this.fsEntryPoint != "" && (n.fragment = { module: this._fsShaderModule, entryPoint: this.fsEntryPoint, targets: o }), a.multisample > 0 && (n.multisample = { count: a.multisample }), (t.zPreTexture || t.depthTexture) && (a.blendMode != re.NONE, p.setting.render.zPrePass && t.zPreTexture && a.useZ ? n.depthStencil = { depthWriteEnabled: false, depthCompare: kt.less, format: t.zPreTexture.format } : n.depthStencil = { depthWriteEnabled: a.depthWriteEnabled, depthCompare: a.depthCompare, format: t.depthTexture.format });
    let l = Xs.getSharePipeline(this.shaderVariant);
    l ? this.pipeline = l : (this.pipeline = y.createPipeline(n), Xs.setSharePipeline(this.shaderVariant, this.pipeline));
  }
  createGroupLayouts() {
    this._groupsShaderReflectionVarInfos = [];
    let e = this.shaderReflection;
    this.bindGroupLayouts = [Gs.getGlobalDataBindGroupLayout()];
    for (let r = 1; r < e.groups.length; r++) {
      let i = e.groups[r];
      if (i) {
        let a = this.getGroupLayout(r, i);
        this._groupsShaderReflectionVarInfos[r] = i;
        let o = w.device.createBindGroupLayout({ entries: a, label: `vs${this.vsName} fs${this.fsName} ${i.length}` });
        this.bindGroupLayouts[r] = o;
      } else
        console.error("can't set empty group!", r);
    }
    let t = w.device.createPipelineLayout({ bindGroupLayouts: this.bindGroupLayouts });
    return this._groupsShaderReflectionVarInfos[0], this._groupsShaderReflectionVarInfos[1] && this.genGroups(1, this._groupsShaderReflectionVarInfos), this._groupsShaderReflectionVarInfos[2] && this.genGroups(2, this._groupsShaderReflectionVarInfos), this._groupsShaderReflectionVarInfos[3] && this.genGroups(3, this._groupsShaderReflectionVarInfos), t;
  }
  preDefine(e) {
    let t = e.hasAttribute(D.TEXCOORD_1), r = e.hasAttribute(D.joints0), i = e.hasAttribute(D.a_morphPositions_0), a = e.hasAttribute(D.TANGENT), o = e.hasAttribute(D.color), n = this.shaderState.acceptGI, l = this.shaderState.useLight;
    t && (this.defineValue.USE_SECONDUV = true), r && i ? this.defineValue.USE_METAHUMAN = true : (this.defineValue.USE_SKELETON = r, this.defineValue.USE_MORPHTARGETS = i), "USE_TANGENT" in this.defineValue || (this.defineValue.USE_TANGENT = a), this.defineValue.USE_GI = n, this.defineValue.USE_SHADOWMAPING = this.shaderState.acceptShadow, this.defineValue.USE_LIGHT = l, this.defineValue.USE_VERTXCOLOR = o, p.setting.pick.mode == "pixel" && (this.defineValue.USE_WORLDPOS = true), p.setting.gi.enable ? this.defineValue.USEGI = true : this.defineValue.USEGI = false, p.setting.render.debug && (this.defineValue.USE_DEBUG = true, this.defineValue.DEBUG_CLUSTER = true), this.shaderState.useLight ? this.defineValue.USE_LIGHT = true : this.defineValue.USE_LIGHT = false, p.setting.render.useLogDepth ? (this.defineValue.USE_LOGDEPTH = true, this.shaderState.useFragDepth = true) : this.defineValue.USE_LOGDEPTH = false, this.shaderState.useFragDepth ? this.defineValue.USE_OUTDEPTH = true : this.defineValue.USE_OUTDEPTH = false, this.defineValue.USE_PCF_SHADOW = p.setting.shadow.type == "PCF", this.defineValue.USE_HARD_SHADOW = p.setting.shadow.type == "HARD", this.defineValue.USE_SOFT_SHADOW = p.setting.shadow.type == "SOFT", this.defineValue.USE_CSM = Ct.Cascades > 1, this.defineValue.USE_IES_PROFILE = zt.use;
  }
  genReflection() {
    this.shaderVariant = Je.genRenderShaderVariant(this);
    let e = Je.poolGetReflection(this.shaderVariant);
    if (e)
      this.shaderReflection = e;
    else {
      let t = Dt.parse(this._destVS, this.defineValue);
      t = Dt.parse(t, this.defineValue), Je.getShaderReflection2(t, this);
      let r = Dt.parse(this._destFS, this.defineValue);
      r = Dt.parse(r, this.defineValue), Je.getShaderReflection2(r, this), Je.final(this);
    }
    this.shaderState.splitTexture = this.shaderReflection.useSplit;
  }
  destroy(e) {
    for (const t in this.textures)
      if (Object.prototype.hasOwnProperty.call(this.textures, t)) {
        const r = this.textures[t];
        if (ie.getInstance().detached(r, this), e && !ie.getInstance().hasReference(r))
          r.destroy(e);
        else {
          r.destroy(false);
          let i = ie.getInstance().getReference(r);
          if (i) {
            let a = [];
            i.forEach((o, n) => {
              "name" in o ? a.push(o.name) : a.push("NaN");
            });
          }
        }
      }
    this.bindGroups.length = 0, this.shaderState = null, this.textures = null, this.pipeline = null, this.bindGroupLayouts = null, this._sourceVS = null, this._sourceFS = null, this._destVS = null, this._destFS = null, this._vsShaderModule = null, this._fsShaderModule = null, this.materialDataUniformBuffer.destroy(e), this.materialDataUniformBuffer = null;
  }
  static destroyShader(e) {
    er.renderShader.has(e) && (er.renderShader.get(e).destroy(), er.renderShader.delete(e));
  }
  static getShader(e) {
    return er.renderShader.get(e);
  }
  static createShader(e, t) {
    let r = new _ve(e, t);
    return er.renderShader.set(r.instanceID, r), r.instanceID;
  }
};
var Tl = class extends ve {
  constructor() {
    super("sky_vs_frag_wgsl", "SkyGBuffer_fs"), this.passType = q.GI, this.setUniformVector3("eyesPos", new d()), this.setUniformFloat("exposure", 1), this.setUniformFloat("roughness", 0);
    let e = this.shaderState;
    e.frontFace = "ccw", e.cullMode = nt.front, e.depthWriteEnabled = false, e.depthCompare = kt.less;
  }
};
var Dl = class extends ve {
  constructor() {
    super("gbuffer_vs", "gbuffer_fs");
    __publicField(this, "transparency");
    this.setShaderEntry("VertMain", "FragMain"), this.passType = q.GI, this.setUniformColor("baseColor", new M()), this.setUniformColor("emissiveColor", new M()), this.setUniformFloat("emissiveIntensity", 1), this.setUniformFloat("normalScale", 1), this.setUniformFloat("alphaCutoff", 1), this.blendMode = re.NONE, this.setTexture("normalMap", p.res.normalTexture);
  }
};
var Pl = class extends ve {
  constructor() {
    super("shadowCastMap_vert", "directionShadowCastMap_frag"), this.passType = q.SHADOW, this.setShaderEntry("main"), this.setUniformFloat("cameraFar", 5e3), this.setUniformVector3("lightWorldPos", d.ZERO), this.shaderState.receiveEnv = false, this.shaderState.castShadow = false, this.shaderState.acceptShadow = false, this.setDefine("USE_ALPHACUT", true);
  }
};
var Ml = class extends ve {
  constructor() {
    super("castPointShadowMap_vert", "shadowCastMap_frag"), this.passType = q.POINT_SHADOW, this.setShaderEntry("main", "main"), this.setUniformFloat("cameraFar", 5e3), this.setUniformVector3("lightWorldPos", d.ZERO), this.shaderState.receiveEnv = false, this.shaderState.castShadow = false, this.shaderState.acceptShadow = false, this.setDefine("USE_ALPHACUT", true);
  }
};
var Rl = class extends ve {
  constructor() {
    super("ZPass_shader_vs", "ZPass_shader_vs"), this.passType = q.DEPTH, this.setShaderEntry("main"), this.useRz = false;
    let e = this.shaderState;
    e.receiveEnv = false;
  }
};
var Si = class {
  static createGIPass(e, t) {
    if (Et.hasMask(e.rendererMask, De.Sky)) {
      if (!t.passShader.get(q.GI)) {
        let i = t.getSubShaders(q.COLOR)[0], a = new Tl();
        a.setTexture("baseMap", i.getTexture("baseMap")), a.cullMode = i.cullMode, a.frontFace = i.frontFace, t.addRenderPass(a, 0), a.preCompile(e.geometry);
      }
    } else
      this.castGBufferPass(e, t);
  }
  static castGBufferPass(e, t) {
    let r = t.getDefaultShaders();
    for (let i = 0; i < r.length; i++) {
      const a = r[i];
      let o = t.getSubShaders(q.GI);
      if (!o || o.length == 0 || o.length < i) {
        let n = new Dl();
        n.setTexture("baseMap", a.getTexture("baseMap")), n.setTexture("normalMap", a.getTexture("normalMap")), n.setTexture("emissiveMap", a.getTexture("emissiveMap")), n.setUniform("baseColor", a.getUniform("baseColor")), n.setUniform("envIntensity", a.getUniform("envIntensity")), n.setUniform("emissiveColor", a.getUniform("emissiveColor")), n.setUniform("emissiveIntensity", a.getUniform("emissiveIntensity")), n.setUniform("alphaCutoff", a.getUniform("alphaCutoff")), n.cullMode = a.cullMode, n.frontFace = a.frontFace, n.preCompile(e.geometry), t.addRenderPass(n);
      }
    }
  }
  static createShadowPass(e, t) {
    let r = Et.hasMask(e.rendererMask, De.SkinnedMesh), i = e.geometry.hasAttribute(D.TANGENT), a = e.geometry.hasAttribute(Vt.MORPH_POSITION_PREFIX + "0"), o = e.geometry.hasAttribute(Vt.MORPH_NORMAL_PREFIX + "0"), n = t.getSubShaders(q.COLOR);
    for (let l = 0; l < n.length; l++) {
      const h = n[l];
      let u = t.getSubShaders(q.SHADOW);
      if (!u || u.length < l + 1) {
        let f = new Pl();
        f.setTexture("baseMap", h.getTexture("baseMap")), f.setUniform("alphaCutoff", h.getUniform("alphaCutoff")), i && f.setDefine("USE_TANGENT", i), r && f.setDefine("USE_SKELETON", r), a && f.setDefine("USE_MORPHTARGETS", a), o && f.setDefine("USE_MORPHNORMALS", o), h.cullMode == "none" ? f.shaderState.cullMode = "none" : h.cullMode == "back" ? f.shaderState.cullMode = "front" : h.cullMode == "front" && (f.shaderState.cullMode = "back"), f.preCompile(e.geometry), t.addRenderPass(f);
      }
      let c = t.getSubShaders(q.POINT_SHADOW);
      if (!c || c.length < l + 1) {
        let f = new Ml();
        f.setTexture("baseMap", h.getTexture("baseMap")), f.setUniform("alphaCutoff", h.getUniform("alphaCutoff")), f.setDefine("USE_ALPHACUT", 1);
        for (let g = 0; g < 1; g++)
          i && f.setDefine("USE_TANGENT", i), r && f.setDefine("USE_SKELETON", r), a && f.setDefine("USE_MORPHTARGETS", a), o && f.setDefine("USE_MORPHNORMALS", o), f.shaderState.cullMode = "front", f.preCompile(e.geometry);
        t.addRenderPass(f);
      }
    }
  }
  static createDepthPass(e, t) {
    let r = t.getSubShaders(q.COLOR), i = e.geometry.hasAttribute("TANGENT"), a = e.geometry.hasAttribute(Vt.MORPH_POSITION_PREFIX + "0"), o = e.geometry.hasAttribute(Vt.MORPH_NORMAL_PREFIX + "0"), n = Et.hasMask(e.rendererMask, De.SkinnedMesh);
    for (let l = 0; l < r.length; l++) {
      const h = r[l];
      let u = t.getSubShaders(q.DEPTH);
      if (!u && h.shaderState.useZ && (!u || u.length < l)) {
        let c = new Rl();
        c.setTexture("baseMap", h.getTexture("baseMap")), i || c.setDefine("USE_TANGENT", i), n && c.setDefine("USE_SKELETON", n), a && c.setDefine("USE_MORPHTARGETS", a), o && c.setDefine("USE_MORPHNORMALS", o), c.cullMode = h.cullMode, c.frontFace = h.frontFace, c.preCompile(e.geometry), t.addRenderPass(c);
      }
    }
  }
};
var Ul = class {
  constructor(e) {
    __publicField(this, "renderer");
    __publicField(this, "owner");
    __publicField(this, "uuid");
    this.renderer = e, this.uuid = e.object3D.instanceID;
  }
  leaveNode() {
    this.owner && (this.owner.entities.delete(this.uuid), this.owner = null);
  }
  enterNode(e) {
    this.owner && this.leaveNode(), this.owner = e, e.entities.set(this.uuid, this);
  }
  update(e) {
    var _a3;
    return ((_a3 = this.owner) == null ? void 0 : _a3.tryInsertEntity(this)) || (this.leaveNode(), e.tryInsertEntity(this)), this.owner;
  }
};
var Td = Object.defineProperty;
var Dd = Object.getOwnPropertyDescriptor;
var yi = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Dd(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Td(e, t, i), i;
};
var tr = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "instanceCount", 0);
    __publicField(this, "lodLevel", 0);
    __publicField(this, "alwaysRender", false);
    __publicField(this, "instanceID");
    __publicField(this, "drawType", 0);
    __publicField(this, "_geometry");
    __publicField(this, "_materials", []);
    __publicField(this, "_castShadow", true);
    __publicField(this, "_castReflection", false);
    __publicField(this, "_castGI", false);
    __publicField(this, "_rendererMask", De.Default);
    __publicField(this, "_inRenderer", false);
    __publicField(this, "_readyPipeline", false);
    __publicField(this, "_combineShaderRefection");
    __publicField(this, "_ignoreEnvMap");
    __publicField(this, "_ignorePrefilterMap");
    __publicField(this, "__renderOrder", 0);
    __publicField(this, "_renderOrder", 0);
    __publicField(this, "isRenderOrderChange");
    __publicField(this, "needSortOnCameraZ");
    __publicField(this, "_octreeBinder");
    __publicField(this, "preInit", false);
    __publicField(this, "_renderLayer", _i.None);
    __publicField(this, "_computes");
  }
  init(e) {
    this.renderOrder = 0, this.rendererMask = De.Default, this.instanceID = bs().toString(), this._computes = [];
  }
  attachSceneOctree(e) {
    this._octreeBinder = { octree: e, entity: new Ul(this) }, this.transform.eventDispatcher.addEventListener(ht.LOCAL_ONCHANGE, this.updateOctreeEntity, this);
  }
  detachSceneOctree() {
    var _a3;
    this._octreeBinder && ((_a3 = this._octreeBinder.entity) == null ? void 0 : _a3.leaveNode(), this.transform.eventDispatcher.removeEventListener(ht.LOCAL_ONCHANGE, this.updateOctreeEntity, this), this._octreeBinder = null);
  }
  updateOctreeEntity(e) {
    var _a3, _b;
    (_b = (_a3 = this._octreeBinder) == null ? void 0 : _a3.entity) == null ? void 0 : _b.update(this._octreeBinder.octree);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.geometry = e._geometry, this.materials = e._materials.slice(), this.drawType = e.drawType, this.alwaysRender = e.alwaysRender, this.needSortOnCameraZ = e.needSortOnCameraZ, this.isRenderOrderChange = e.isRenderOrderChange, this.castShadow = e.castShadow, this.castGI = e.castGI, this.rendererMask = e.rendererMask, this;
  }
  get renderLayer() {
    return this._renderLayer;
  }
  set renderLayer(e) {
    this._renderLayer = e;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(e) {
    this._geometry != e && (this._geometry && ie.getInstance().detached(this._geometry, this), ie.getInstance().attached(e, this)), this._geometry = e;
  }
  addMask(e) {
    this._rendererMask = Et.addMask(this.rendererMask, e);
  }
  removeMask(e) {
    this._rendererMask = Et.removeMask(this.rendererMask, e);
  }
  hasMask(e) {
    return Et.hasMask(this.rendererMask, e);
  }
  get rendererMask() {
    return this._rendererMask;
  }
  set rendererMask(e) {
    this._rendererMask = e;
  }
  get renderOrder() {
    return this._renderOrder;
  }
  set renderOrder(e) {
    e != this._renderOrder && (this.isRenderOrderChange = true, this.__renderOrder = e), this._renderOrder = e;
  }
  get materials() {
    return this._materials;
  }
  set materials(e) {
    this._readyPipeline = false;
    for (let r = 0; r < this._materials.length; r++) {
      let i = this._materials[r];
      ie.getInstance().detached(i, this), i.shader && i.shader.computes && this.removeComputes(i.shader.computes);
    }
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      ie.getInstance().attached(i, this), i.shader && i.shader.computes && this.addComputes(i.shader.computes);
    }
    this._materials = e;
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      const o = e[r].getPass(q.COLOR)[0];
      o.shaderState.transparent && (t = t > o.renderOrder ? t : o.renderOrder);
    }
    this.renderOrder = t, this._readyPipeline || this.initPipeline();
  }
  addComputes(e) {
    this._computes.push(...e);
  }
  removeComputes(e) {
    for (const t of e) {
      let r = this._computes.indexOf(t);
      r != -1 && this._computes.splice(r, 1);
    }
  }
  addRendererMask(e) {
    this._rendererMask = Et.addMask(this._rendererMask, e);
  }
  removeRendererMask(e) {
    this._rendererMask = Et.removeMask(this._rendererMask, e);
  }
  onEnable() {
    this._readyPipeline || this.initPipeline(), z.instance.addRenderNode(this.transform.scene3D, this), this.updateOctreeEntity();
  }
  onDisable() {
    var _a3;
    this._enable = false, z.instance.removeRenderNode(this.transform.scene3D, this), (_a3 = super.onDisable) == null ? void 0 : _a3.call(this);
  }
  selfCloneMaterials(e) {
    let t = [];
    for (let r = 0, i = this.materials.length; r < i; r++) {
      const a = this.materials[r].clone();
      t.push(a);
    }
    return this.materials = t, this._readyPipeline = false, this.initPipeline(), this;
  }
  initPipeline() {
    if (this._geometry && this._materials.length > 0) {
      for (let t = 0; t < this._materials.length; t++) {
        let i = this._materials[t].getPass(q.COLOR);
        for (let a = 0; a < i.length; a++) {
          const o = i[a];
          o.shaderReflection || o.preCompile(this._geometry), this._geometry.generate(o.shaderReflection);
        }
        this.object3D.bound = this._geometry.bounds.clone();
      }
      this._readyPipeline = true;
      let e = 0;
      for (let t = 0; t < this.materials.length; t++) {
        const a = this.materials[t].getPass(q.COLOR)[0];
        a.renderOrder >= 3e3 ? e = e > a.renderOrder ? e : a.renderOrder : e = Math.max(e - 3e3, 0), this.castNeedPass();
      }
      this.renderOrder = e, this.enable && this.transform && this.transform.scene3D && z.instance.addRenderNode(this.transform.scene3D, this);
    }
  }
  castNeedPass() {
    if (this.castGI)
      for (let t = 0; t < this.materials.length; t++) {
        const r = this.materials[t];
        Si.createGIPass(this, r.shader);
      }
    for (let t = 0; t < this.materials.length; t++) {
      const r = this.materials[t];
      r.castShadow && Si.createShadowPass(this, r.shader);
    }
    if (this.castReflection)
      for (let t = 0; t < this.materials.length; t++) {
        const r = this.materials[t];
        r.castShadow && Si.createShadowPass(this, r.shader);
      }
    if (!Et.hasMask(this.rendererMask, De.IgnoreDepthPass) && p.setting.render.zPrePass)
      for (let t = 0; t < this.materials.length; t++) {
        const r = this.materials[t];
        Si.createDepthPass(this, r.shader);
      }
    else
      for (let t = 0; t < this.materials.length; t++)
        this.materials[t].shader.removeShaderByIndex(q.DEPTH, 0);
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(e) {
    this._castShadow = e;
  }
  get castGI() {
    return this._castGI;
  }
  set castGI(e) {
    this._castGI = e;
  }
  get castReflection() {
    return this._castReflection;
  }
  set castReflection(e) {
    this._castReflection = e;
  }
  renderPass(e, t, r) {
    let i = this, a = i.transform._worldMatrix;
    for (let o = 0; o < i.materials.length; o++) {
      const n = i.materials[o];
      if (!n || !n.enable)
        continue;
      let l = n.getPass(t);
      if (!(!l || l.length == 0)) {
        y.bindGeometryBuffer(r.encoder, i._geometry);
        for (let h = 0; h < l.length; h++) {
          if (!l || l.length == 0)
            continue;
          const c = l[h];
          if (c.pipeline) {
            c.shaderState.splitTexture && (r.endRenderPass(), be.WriteSplitColorTexture(i.instanceID), r.beginOpaqueRenderPass(), y.bindCamera(r.encoder, e.camera), y.bindGeometryBuffer(r.encoder, i._geometry)), y.bindPipeline(r.encoder, c);
            let m = i._geometry.subGeometries[o].lodLevels[i.lodLevel];
            i.instanceCount > 0 ? y.drawIndexed(r.encoder, m.indexCount, i.instanceCount, m.indexStart, 0, 0) : y.drawIndexed(r.encoder, m.indexCount, 1, m.indexStart, 0, a.index);
          }
        }
      }
    }
  }
  renderPass2(e, t, r, i, a, o = false) {
    if (!this.enable)
      return;
    let n = this, l = n.object3D.transform._worldMatrix;
    for (let h = 0; h < this.materials.length; h++) {
      const u = this.materials[h];
      if (!u.castShadow && t == q.SHADOW)
        continue;
      let c = u.getPass(t);
      if (!c || c.length == 0)
        return;
      if (this.drawType == 2)
        for (let f of c)
          f.pipeline && (y.bindPipeline(a, f), y.draw(a, 6, 1, 0, l.index));
      else {
        y.bindGeometryBuffer(a, n._geometry);
        for (let f of c)
          if (f.pipeline) {
            y.bindPipeline(a, f);
            let _ = n._geometry.subGeometries[h].lodLevels[n.lodLevel];
            y.drawIndexed(a, _.indexCount, 1, _.indexStart, 0, l.index);
          }
      }
    }
  }
  recordRenderPass2(e, t, r, i, a, o = false) {
    if (!this.enable)
      return;
    let n = this;
    for (let l = 0; l < this.materials.length; l++) {
      let u = this.materials[l].getPass(t);
      if (!u || u.length == 0)
        return;
      let c = n.object3D.transform._worldMatrix;
      for (let f = 0; f < u.length; f++) {
        const g = u[f];
        y.bindPipeline(a, g);
        let x = n._geometry.subGeometries[l].lodLevels[n.lodLevel];
        y.drawIndexed(a, x.indexCount, 1, x.indexStart, 0, c.index);
      }
    }
  }
  noticeShaderChange() {
    this.enable && (this.onEnable(), this.preInit = false);
  }
  nodeUpdate(e, t, r, i) {
    this.preInit = true;
    let a = this, o = e.scene.envMap;
    for (let n = 0; n < a.materials.length; n++) {
      let h = a.materials[n].getPass(t);
      if (h)
        for (let u = 0; u < h.length; u++) {
          const f = h[u];
          if (f.shaderState.splitTexture) {
            let C = be.CreateSplitTexture(a.instanceID);
            f.setTexture("splitTexture_Map", C);
          }
          if (!a._ignoreEnvMap && f.envMap != o && f.setTexture("envMap", o), f.setTexture("prefilterMap", o), f.pipeline) {
            f.apply(a._geometry, r, () => a.noticeShaderChange());
            continue;
          }
          let g = p.res.getTexture("BRDFLUT");
          f.setTexture("brdflutMap", g);
          let m = p.getRenderJob(e).shadowMapPassRenderer;
          m && m.depth2DArrayTexture && f.setTexture("shadowMap", p.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture);
          let A = p.getRenderJob(e).pointLightShadowRenderer;
          A && A.cubeArrayTexture && f.setTexture("pointShadowMap", A.cubeArrayTexture);
          let _ = zt.iesTexture;
          _ && f.setTexture("iesTextureArrayMap", _), r.irradianceBuffer && r.irradianceBuffer.length > 0 && (f.setTexture("irradianceMap", r.irradianceBuffer[0]), f.setTexture("irradianceDepthMap", r.irradianceBuffer[1]));
          let x = oe.getLightEntries(e.scene);
          x && (f.setStorageBuffer("lightBuffer", x.storageGPUBuffer), x.irradianceVolume && f.setUniformBuffer("irradianceData", x.irradianceVolume.irradianceVolumeBuffer)), i && (f.setStorageBuffer("clustersUniform", i.clustersUniformBuffer), f.setStorageBuffer("lightAssignBuffer", i.lightAssignBuffer), f.setStorageBuffer("assignTable", i.assignTableBuffer), f.setStorageBuffer("clusterBuffer", i.clusterBuffer)), f.apply(a._geometry, r);
        }
    }
  }
  beforeDestroy(e) {
    ie.getInstance().detached(this._geometry, this), ie.getInstance().hasReference(this._geometry) || this._geometry.destroy(e);
    for (let t = 0; t < this._materials.length; t++) {
      const r = this._materials[t];
      ie.getInstance().detached(r, this), ie.getInstance().hasReference(r) || r.destroy(e);
    }
    super.beforeDestroy(e);
  }
  destroy(e) {
    super.destroy(e), this._geometry = null, this._materials = null, this._combineShaderRefection = null;
  }
};
yi([Qt], tr.prototype, "materials", 1), yi([Qt], tr.prototype, "castShadow", 1), yi([Qt], tr.prototype, "castShadow", 1), yi([Qt], tr.prototype, "castGI", 1), yi([Qt], tr.prototype, "castGI", 1);
var Ws = class {
  constructor(e) {
    __publicField(this, "uuid");
    __publicField(this, "type");
    __publicField(this, "color");
    __publicField(this, "count", 0);
    __publicField(this, "pointData");
    __publicField(this, "colorData");
    __publicField(this, "dirtyData", false);
    __publicField(this, "memoryDataIndex", -1);
    __publicField(this, "transformIndex");
    this.transformIndex = e;
  }
  buildAxis(e = new d(0, 0, 0), t = 10) {
    this.buildLines([e, new d(e.x + t, e.y, e.z)], M.hexRGBColor(M.RED)), this.buildLines([e, new d(e.x, e.y + t, e.z)], M.hexRGBColor(M.GREEN)), this.buildLines([e, new d(e.x, e.y, e.z + t)], M.hexRGBColor(M.BLUE));
  }
  buildLines(e, t = M.COLOR_WHITE) {
    if (!(e.length < 2)) {
      if (e.length == 2) {
        this.fillShapeData(e, t);
        return;
      }
      var r = new Array(e.length + e.length - 2);
      for (let i = 1, a = 0; i < e.length; ++i)
        r[a++] = e[i - 1], r[a++] = e[i];
      this.fillShapeData(r, t);
    }
  }
  buildArcLine(e, t, r, i, a = 16, o = d.Y_AXIS, n = M.COLOR_WHITE) {
    const l = (i - r) * me;
    r *= me;
    var h = [];
    for (let g = 0; g <= a; ++g) {
      g > 1 && h.push(h[h.length - 1]);
      var u = l * (g / a) + r, c = t * Math.cos(u), f = t * Math.sin(u);
      switch (o) {
        case d.X_AXIS:
          h.push(e.add(new d(0, c, f)));
          break;
        case d.Y_AXIS:
          h.push(e.add(new d(c, 0, f)));
          break;
        case d.Z_AXIS:
          h.push(e.add(new d(c, f, 0)));
          break;
        default:
          h.push(e.add(new d(c, f, 0)));
          break;
      }
    }
    this.fillShapeData(h, n);
  }
  buildCircle(e, t, r = 32, i = d.Y_AXIS, a = M.COLOR_WHITE) {
    var o = [];
    for (let u = 0; u <= r; ++u) {
      var n = 2 * Math.PI * u / r, l = t * Math.cos(n), h = t * Math.sin(n);
      switch (i) {
        case d.X_AXIS:
          o.push(e.add(new d(0, l, h)));
          break;
        case d.Y_AXIS:
          o.push(e.add(new d(l, 0, h)));
          break;
        case d.Z_AXIS:
          o.push(e.add(new d(l, h, 0)));
          break;
        default:
          o.push(e.add(new d(l, h, 0)));
          break;
      }
      u > 0 && o.push(o[o.length - 1]);
    }
    o.push(o[0]), this.fillShapeData(o, a);
  }
  fillShapeData(e, t, r = false) {
    if (!this.pointData)
      this.pointData = new Float32Array(4 * e.length), this.colorData = new Float32Array(4 * e.length);
    else if (this.count + 4 * e.length >= this.pointData.length) {
      let i = new Float32Array(this.pointData.length + 4 * e.length);
      i.set(this.pointData), this.pointData = i, i = new Float32Array(this.colorData.length + 4 * e.length), i.set(this.colorData), this.colorData = i;
    }
    if (r || this.dirtyData == false) {
      const i = this.pointData;
      let a = this.count;
      for (let n = 0; n < e.length; ++n) {
        const l = e[n];
        i[this.count++] = l.x, i[this.count++] = l.y, i[this.count++] = l.z, i[this.count++] = this.transformIndex;
      }
      const o = this.colorData;
      for (let n = 0; n < e.length; ++n)
        if (t instanceof M)
          o[a++] = t.r, o[a++] = t.g, o[a++] = t.b, o[a++] = t.a;
        else {
          const l = t[n];
          o[a++] = l.r, o[a++] = l.g, o[a++] = l.b, o[a++] = l.a;
        }
    }
    this.dirtyData = true;
  }
  reset() {
    this.count = 0;
  }
};
var ma = class extends tr {
  constructor(e, t) {
    super();
    __publicField(this, "shapes");
    __publicField(this, "mDirtyData", false);
    __publicField(this, "mBatchSize");
    __publicField(this, "mMinIndexCount");
    __publicField(this, "mGPUPrimitiveTopology");
    this.alwaysRender = true, this.mMinIndexCount = e, this.mBatchSize = Math.trunc(65536 / this.mMinIndexCount), this.mGPUPrimitiveTopology = t, this.shapes = /* @__PURE__ */ new Map();
  }
  init() {
    super.init(), this.castGI = false, this.castShadow = false, this.geometry = new xe();
    let e = new Uint16Array((Math.trunc(this.mMinIndexCount * this.mBatchSize / 4) + 1) * 4);
    for (let t = 0; t < e.length; t++)
      e[t] = t;
    this.geometry.setIndices(e), this.geometry.setAttribute(D.position, new Float32Array(4 * e.length)), this.geometry.setAttribute(D.color, new Float32Array(4 * e.length)), this.geometry.addSubGeometry({ indexStart: 0, indexCount: 0, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 }), this.materials = [new Vc(this.mGPUPrimitiveTopology)];
  }
  fillShapeData(e, t, r, i) {
    this.mDirtyData = true;
    var a;
    this.shapes.has(e) ? (a = this.shapes.get(e), a.pointData.length < 4 * i.length && (a.pointData = new Float32Array(4 * i.length), a.colorData = new Float32Array(4 * i.length))) : (a = new Ws(this.transform._worldMatrix.index), a.type = t, a.color = r, a.pointData = new Float32Array(4 * i.length), a.colorData = new Float32Array(4 * i.length));
    const o = a.pointData, n = a.colorData, l = this.transform._worldMatrix.index;
    for (let h = 0, u = 0; h < i.length; ++h) {
      const c = i[h];
      o[u] = c.x, n[u++] = r.r, o[u] = c.y, n[u++] = r.g, o[u] = c.z, n[u++] = r.b, o[u] = l, n[u++] = r.a;
    }
    this.shapes.set(e, a);
  }
  removeShape(e) {
    this.shapes.has(e) && (this.mDirtyData = true, this.shapes.delete(e));
  }
  nodeUpdate(e, t, r, i) {
    if (this.mDirtyData) {
      let a = 0, o = this.geometry.getAttribute(D.position), n = this.geometry.getAttribute(D.color);
      this.shapes.forEach((u, c) => {
        o.data.set(u.pointData, a), n.data.set(u.colorData, a), a += u.pointData.length;
      }), this.geometry.vertexBuffer.upload(D.position, o), this.geometry.vertexBuffer.upload(D.color, n);
      let h = a / 4;
      this.geometry.subGeometries[0].lodLevels[0].indexCount = h, this.mDirtyData = false;
    }
    super.nodeUpdate(e, t, r, i);
  }
  allocGraphics3DShape(e, t) {
    let r;
    return this.shapes.has(e) ? (r = this.shapes.get(e), r.reset()) : (r = new Ws(t), r.uuid = e, r.type = "line", r.color = M.COLOR_WHITE, this.shapes.set(r.uuid, r)), this.mDirtyData = true, r;
  }
};
var Ll = class {
  constructor() {
    __publicField(this, "opaqueList", []);
    __publicField(this, "transparentList", []);
    __publicField(this, "sky");
  }
  clean() {
    this.opaqueList.length = 0, this.transparentList.length = 0;
  }
};
var Ol = class {
  constructor() {
    __publicField(this, "renderGroup");
    this.renderGroup = /* @__PURE__ */ new Map();
  }
  collect_add(e) {
    let t = "", r = "";
    t += e.geometry.instanceID;
    for (let a = 0; a < e.materials.length; a++) {
      const o = e.materials[a];
      r += o.shader.getDefaultColorShader().shaderVariant;
    }
    let i = t + r;
    this.renderGroup.has(i) || this.renderGroup.set(i, { bundleMap: /* @__PURE__ */ new Map(), key: i, renderNodes: [] }), this.renderGroup.get(i).renderNodes.indexOf(e) == -1 && this.renderGroup.get(i).renderNodes.push(e);
  }
};
var Fl = class {
  constructor() {
    __publicField(this, "renderShaderUpdateList", /* @__PURE__ */ new Map());
    __publicField(this, "renderNodeList", /* @__PURE__ */ new Map());
  }
  collect_add(e) {
    let t = e.transform.view3D;
    t && e.materials && e.materials.forEach((r) => {
      let i = this.renderShaderUpdateList.get(t);
      i || (i = /* @__PURE__ */ new Map(), this.renderShaderUpdateList.set(t, i));
      let a = this.renderNodeList.get(t);
      a || (a = /* @__PURE__ */ new Map(), this.renderNodeList.set(t, a)), a.set(e.instanceID, e);
      let o = r.getAllPass();
      for (let n = 0; n < o.length; n++) {
        const l = o[n];
        let h = `${e.geometry.instanceID + l.instanceID}`, u = i.get(h);
        u || (u = /* @__PURE__ */ new Map(), i.set(h, u)), u.set(e.instanceID, e);
      }
    });
  }
  collect_remove(e) {
    let t = e.transform.view3D;
    if (t && e.materials) {
      let r = this.renderShaderUpdateList.get(t);
      r && e.materials.forEach((i) => {
        let a = i.getAllPass();
        for (let o = 0; o < a.length; o++) {
          const n = a[o];
          let l = `${e.geometry.instanceID + n.instanceID}`;
          r.delete(l);
        }
      });
    }
  }
};
var _z = class _z {
  constructor() {
    __publicField(this, "_sceneLights");
    __publicField(this, "_sceneGIProbes");
    __publicField(this, "_op_RenderNodes");
    __publicField(this, "_tr_RenderNodes");
    __publicField(this, "_octreeRenderNodes");
    __publicField(this, "_graphics");
    __publicField(this, "_op_renderGroup");
    __publicField(this, "_tr_renderGroup");
    __publicField(this, "_renderShaderCollect");
    __publicField(this, "state", { giLightingChange: true });
    __publicField(this, "sky");
    __publicField(this, "_collectInfo");
    __publicField(this, "rendererOctree");
    this._sceneLights = /* @__PURE__ */ new Map(), this._sceneGIProbes = /* @__PURE__ */ new Map(), this._op_RenderNodes = /* @__PURE__ */ new Map(), this._tr_RenderNodes = /* @__PURE__ */ new Map(), this._graphics = [], this._op_renderGroup = /* @__PURE__ */ new Map(), this._tr_renderGroup = /* @__PURE__ */ new Map(), this._collectInfo = new Ll(), this._renderShaderCollect = new Fl(), this._octreeRenderNodes = /* @__PURE__ */ new Map();
  }
  static get instance() {
    return this._instance || (this._instance = new _z()), this._instance;
  }
  getPashList(e, t) {
    if (t.renderOrder < 3e3)
      return this._op_RenderNodes.get(e);
    if (t.renderOrder >= 3e3)
      return this._tr_RenderNodes.get(e);
  }
  sortRenderNode(e, t) {
    for (let r = e.length - 1; r > 0; r--)
      if (e[r].renderOrder < t.renderOrder) {
        e.push(t);
        return;
      }
    e.push(t);
  }
  addRenderNode(e, t) {
    if (!e)
      return;
    let r = t.renderOrder >= 3e3;
    if (t.hasMask(De.Sky))
      this.sky = t;
    else if (t instanceof ma)
      this._graphics.indexOf(t) == -1 && this._graphics.push(t);
    else if (Qs.hasMask(t.renderLayer, _i.None)) {
      this.removeRenderNode(e, t);
      let i = r ? this._tr_RenderNodes : this._op_RenderNodes;
      i.has(e) || i.set(e, []), i.get(e).push(t), p.setting.occlusionQuery.octree && t.attachSceneOctree(this.getOctree(e));
      let a = this.getPashList(e, t);
      a.indexOf(t) == -1 && this.sortRenderNode(a, t);
    } else {
      this.removeRenderNode(e, t);
      let i = r ? this._tr_renderGroup : this._op_renderGroup;
      i.has(e) || i.set(e, new Ol()), i.get(e).collect_add(t);
    }
    t.object3D.renderNode = t, this._renderShaderCollect.collect_add(t);
  }
  getOctree(e) {
    let t, r = p.setting.occlusionQuery.octree;
    if (r && (t = this._octreeRenderNodes.get(e), !t)) {
      let i = new d(r.x, r.y, r.z), a = new d(r.width, r.height, r.depth), o = new ge(i, a);
      t = new Sr(o), this._octreeRenderNodes.set(e, t);
    }
    return t;
  }
  removeRenderNode(e, t) {
    if (t.detachSceneOctree(), t.hasMask(De.Sky))
      this.sky = null;
    else if (Qs.hasMask(t.renderLayer, _i.None)) {
      let r = this.getPashList(e, t);
      if (r) {
        let i = r.indexOf(t);
        i != -1 && r.splice(i, 1);
      }
    }
    this._renderShaderCollect.collect_remove(t);
  }
  addLight(e, t) {
    if (!this._sceneLights.has(e))
      this._sceneLights.set(e, [t]);
    else {
      let r = this._sceneLights.get(e);
      if (r.length >= p.setting.light.maxLight) {
        console.warn("Alreay meet maxmium light number:", p.setting.light.maxLight);
        return;
      }
      r.indexOf(t) != -1 || r.push(t);
    }
  }
  removeLight(e, t) {
    if (this._sceneLights.has(e)) {
      let r = this._sceneLights.get(e), i = r.indexOf(t);
      i != -1 && r.splice(i, 1);
    }
  }
  getLights(e) {
    let t = this._sceneLights.get(e);
    return t || [];
  }
  addGIProbe(e, t) {
    this._sceneGIProbes.has(e) ? this._sceneGIProbes.get(e).push(t) : this._sceneGIProbes.set(e, [t]);
  }
  removeGIProbe(e, t) {
    if (this._sceneGIProbes.has(e)) {
      let r = this._sceneGIProbes.get(e), i = r.indexOf(t);
      i != -1 && r.splice(i, 1);
    }
  }
  getProbes(e) {
    let t = this._sceneGIProbes.get(e);
    return t || [];
  }
  autoSortRenderNodes(e) {
    let t = this._tr_RenderNodes.get(e);
    if (!t)
      return;
    let r = false;
    for (const i of t)
      if (i.isRenderOrderChange || i.needSortOnCameraZ) {
        r = true;
        break;
      }
    if (r) {
      for (const i of t) {
        let a = i.renderOrder;
        if (i.needSortOnCameraZ) {
          let o = pl.worldToCameraDepth(i.object3D);
          o = 1 - Math.max(0, Math.min(1, o)), a += o;
        }
        i.__renderOrder = a, i.isRenderOrderChange = false;
      }
      t.sort((i, a) => i.__renderOrder > a.__renderOrder ? 1 : -1);
    }
    return this;
  }
  getRenderNodes(e, t) {
    if (this.autoSortRenderNodes(e), this._collectInfo.clean(), this._collectInfo.sky = this.sky, p.setting.occlusionQuery.octree)
      this.rendererOctree = this.getOctree(e), this.rendererOctree.getRenderNode(t.frustum, this._collectInfo);
    else {
      let r = this._op_RenderNodes.get(e);
      r && (this._collectInfo.opaqueList = r.concat());
      let i = this._tr_RenderNodes.get(e);
      i && (this._collectInfo.transparentList = i.concat());
    }
    return this._collectInfo;
  }
  getOpRenderGroup(e) {
    return this._op_renderGroup.get(e);
  }
  getTrRenderGroup(e) {
    return this._tr_renderGroup.get(e);
  }
  getGraphicList() {
    return this._graphics;
  }
  getRenderShaderCollect(e) {
    return this._renderShaderCollect.renderShaderUpdateList.get(e);
  }
};
__publicField(_z, "_instance");
var z = _z;
var Nl = class {
  constructor() {
    __publicField(this, "setting");
    __publicField(this, "probesBufferData");
    __publicField(this, "probesBuffer");
    __publicField(this, "isVolumeFrameChange", true);
    __publicField(this, "randomOrientation");
    __publicField(this, "startPosition", new d());
    __publicField(this, "isVolumeChange", true);
    __publicField(this, "irradianceVolumeBuffer");
    __publicField(this, "directionDistance", 20);
    __publicField(this, "randomSeedCount", 3);
    __publicField(this, "useRandomIndex", 0);
    __publicField(this, "centerDirection", new d(0, 0, this.directionDistance).normalize(1));
    __publicField(this, "arroundPositions", []);
    __publicField(this, "debugX", 0);
    __publicField(this, "debugY", 0);
    __publicField(this, "debugZ", 0);
  }
  updateOrientation() {
    return this.useRandomIndex++, this.useRandomIndex >= this.arroundPositions.length && (this.useRandomIndex = 0), P.fromToRotation(this.centerDirection, this.arroundPositions[this.useRandomIndex], this.randomOrientation), this.randomOrientation;
  }
  init(e) {
    this.setting = e, this.randomOrientation = new P(false), this.randomOrientation.identity(), this.irradianceVolumeBuffer = new ft(80), this.createFramesBuffer(), this.arroundPositions.push(this.centerDirection.clone());
    for (let t = 0; t < this.randomSeedCount; t++) {
      let r = Math.PI * 2 * t / this.randomSeedCount, i = new d(Math.sin(r), Math.cos(r), this.directionDistance).normalize(1);
      this.arroundPositions.push(i);
    }
  }
  setVolumeDataChange() {
    this.isVolumeChange = true;
  }
  updateProbes(e) {
    let t = this.probesBufferData;
    for (let r of e) {
      let i = r.index * 4;
      t[i + 3] = r.drawCallFrame;
    }
  }
  createFramesBuffer() {
    if (!this.probesBufferData) {
      let e = this.setting.probeXCount * this.setting.probeYCount * this.setting.probeZCount;
      this.probesBufferData = new Float32Array(e * 4), this.probesBufferData.fill(-1), this.probesBuffer = new $(e * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    }
  }
  uploadBuffer() {
    this.isVolumeChange && (this.fillIrradianceData(), this.isVolumeChange = false, this.isVolumeFrameChange = true), this.probesBuffer.setFloat32Array("uniformFramesBuffer", this.probesBufferData);
  }
  calcPosition(e, t, r, i) {
    let a = this.setting, o = this.setting.probeSpace;
    return i = i || new d(), i.x = e * o - o * (a.probeXCount - 1) * 0.5 + a.offsetX, i.y = t * o - o * (a.probeYCount - 1) * 0.5 + a.offsetY, i.z = r * o - o * (a.probeZCount - 1) * 0.5 + a.offsetZ, i;
  }
  fillIrradianceData() {
    let e = this.setting, t = this.calcPosition(0, 0, 0, this.startPosition);
    this.irradianceVolumeBuffer.setFloat("orientationIndex", this.randomOrientation.index), this.irradianceVolumeBuffer.setFloat("hysteresis", e.hysteresis), this.irradianceVolumeBuffer.setFloat("OctRTSideSize", e.octRTSideSize), this.irradianceVolumeBuffer.setFloat("OctRTMaxSize", e.octRTMaxSize), this.irradianceVolumeBuffer.setFloat("startX", t.x), this.irradianceVolumeBuffer.setFloat("startY", t.y), this.irradianceVolumeBuffer.setFloat("startZ", t.z), this.irradianceVolumeBuffer.setFloat("ProbeSpace", e.probeSpace), this.irradianceVolumeBuffer.setFloat("probeXCount", e.probeXCount), this.irradianceVolumeBuffer.setFloat("probeYCount", e.probeYCount), this.irradianceVolumeBuffer.setFloat("probeZCount", e.probeZCount), this.irradianceVolumeBuffer.setFloat("maxDistance", e.probeSpace * 1.732), this.irradianceVolumeBuffer.setFloat("depthSharpness", e.depthSharpness), this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize", e.probeSourceTextureSize), this.irradianceVolumeBuffer.setFloat("ProbeSize", e.probeSize), this.irradianceVolumeBuffer.setFloat("bounceIntensity", e.bounceIntensity), this.irradianceVolumeBuffer.setFloat("probeRoughness", e.probeRoughness), this.irradianceVolumeBuffer.setFloat("normalBias", e.normalBias), this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias", e.irradianceChebyshevBias), this.irradianceVolumeBuffer.setFloat("rayNumber", e.rayNumber), this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias", e.irradianceDistanceBias), this.irradianceVolumeBuffer.setFloat("indirectIntensity", e.indirectIntensity), this.irradianceVolumeBuffer.setFloat("ddgiGamma", e.ddgiGamma), this.irradianceVolumeBuffer.setFloat("lerpHysteresis", e.lerpHysteresis), this.irradianceVolumeBuffer.setFloat("debugX", this.debugX), this.irradianceVolumeBuffer.setFloat("debugY", this.debugY), this.irradianceVolumeBuffer.setFloat("debugZ", this.debugZ), this.irradianceVolumeBuffer.apply();
  }
};
var zl = class {
  constructor() {
    __publicField(this, "storageGPUBuffer");
    __publicField(this, "irradianceVolume");
    __publicField(this, "_lightList", []);
    this.storageGPUBuffer = new $(da.lightSize * p.setting.light.maxLight, GPUBufferUsage.COPY_SRC), this.irradianceVolume = new Nl(), this.irradianceVolume.init(p.setting.gi);
    for (let e = 0; e < p.setting.light.maxLight; e++) {
      let t = this.storageGPUBuffer.memory.allocation_node(da.lightSize * 4);
      this._lightList.push(t);
    }
    this.storageGPUBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
  }
  update(e) {
    this.storageGPUBuffer.clean();
    let t = z.instance.getLights(e.scene);
    for (let r = 0; r < t.length; r++) {
      const i = t[r].lightData;
      i.index = r, this.writeLightBytes(i, this._lightList[r]);
    }
    this.storageGPUBuffer.apply();
  }
  writeLightBytes(e, t) {
    t.offset = 0, t.writeFloat(e.index), t.writeInt32(e.lightType), t.writeFloat(e.radius), t.writeFloat(e.linear), t.writeVector3(e.lightPosition), t.writeFloat(e.lightMatrixIndex), t.writeVector3(e.direction), t.writeFloat(e.quadratic), t.writeRGBColor(e.lightColor), t.writeFloat(e.intensity), t.writeFloat(e.innerAngle), t.writeFloat(e.outerAngle), t.writeFloat(e.range), t.writeInt32(e.castShadowIndex), t.writeVector3(e.lightTangent), t.writeFloat(e.iesIndex);
  }
};
var kl = class {
  constructor() {
    __publicField(this, "gpuBuffer");
    __publicField(this, "probes");
    __publicField(this, "memoryDo");
    __publicField(this, "_probeInfoList");
  }
  initDataUniform(e) {
    this.memoryDo = new fr(), this.probes = e, this._probeInfoList = [], this.memoryDo.destroy(), this.memoryDo.allocation(e.length * 17 * 4);
    for (let r = 0; r < e.length; r++) {
      var t = 17;
      let i = this.memoryDo.allocation_node(t * 4);
      this._probeInfoList.push(i);
      let a = e[r].transform.worldPosition;
      i.setArray(0, [a.x, a.y, a.z]);
    }
    this.gpuBuffer = w.device.createBuffer({ size: this.memoryDo.shareDataBuffer.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE, label: "ProbeBuffer", mappedAtCreation: false });
  }
  updateGPUBuffer() {
    const e = this.memoryDo.shareDataBuffer;
    let t = this.memoryDo.shareDataBuffer.byteLength, r = 0;
    const i = 5e3 * 64;
    for (; r < t; )
      w.device.queue.writeBuffer(this.gpuBuffer, r, e, r, Math.floor(Math.min(i, t - r))), r += i;
  }
};
var Gl = class extends Jt {
  constructor(e, t = 0, r) {
    super();
    __publicField(this, "size");
    this.bufferType = Tt.StorageGPUBuffer, this.size = e, this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | t, e, r, "MatrixGPUBuffer");
  }
  writeBufferByHeap(e, t) {
    let r = w.device;
    if (e.length > 0) {
      let i = null;
      for (; this.mapAsyncReady.length && (i = this.mapAsyncReady.shift(), i.usedSize != e.byteLength); )
        i.destroy(), this.mapAsyncBuffersOutstanding--, i = null;
      i || (i = r.createBuffer({ size: e.byteLength, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE, mappedAtCreation: true }), i.usedSize = e.byteLength, this.mapAsyncBuffersOutstanding++, this.mapAsyncBuffersOutstanding > 10 && console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));
      let a = new Float32Array(e.buffer, e.byteOffset, t);
      new Float32Array(i.getMappedRange(0, t * 4)).set(a), i.unmap();
      const n = r.createCommandEncoder();
      n.copyBufferToBuffer(i, 0, this.buffer, 0, t * 4), r.queue.submit([n.finish()]), i.mapAsync(GPUMapMode.WRITE).then(() => this.mapAsyncReady.push(i));
    }
  }
};
var Ql = class {
  constructor() {
    __publicField(this, "uuid");
    __publicField(this, "index");
    __publicField(this, "usage");
    __publicField(this, "groupBufferSize");
    __publicField(this, "matrixBufferDst");
    this.uuid = gt(), this.groupBufferSize = 0, this.usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, this.cacheWorldMatrix();
  }
  cacheWorldMatrix() {
    this.groupBufferSize = P.maxCount * P.blockBytes, this.matrixBufferDst = new Gl(this.groupBufferSize / 4), this.matrixBufferDst.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, this.matrixBufferDst.buffer.label = this.groupBufferSize.toString();
  }
  writeBuffer(e) {
    const t = P.dynamicMatrixBytes;
    this.matrixBufferDst.mapAsyncWrite(t, e);
  }
};
var oe = class {
  static init() {
    this.modelMatrixBindGroup = new Ql(), this._cameraBindGroups = /* @__PURE__ */ new Map(), this._lightEntriesMap = /* @__PURE__ */ new Map();
  }
  static getCameraGroup(e) {
    let t = this._cameraBindGroups.get(e);
    return t || (t = new dl(this.modelMatrixBindGroup), this._cameraBindGroups.set(e, t)), e.isShadowCamera ? t.setShadowCamera(e) : t.setCamera(e), t;
  }
  static getLightEntries(e) {
    e || console.log("getLightEntries scene is null");
    let t = this._lightEntriesMap.get(e);
    return t || (t = new zl(), this._lightEntriesMap.set(e, t)), this._lightEntriesMap.get(e);
  }
  static updateProbes(e) {
    this._probeEntries || (this._probeEntries = new kl(), this._probeEntries.initDataUniform(e));
  }
};
__publicField(oe, "_cameraBindGroups");
__publicField(oe, "_lightEntriesMap");
__publicField(oe, "_probeEntries");
__publicField(oe, "modelMatrixBindGroup");
var _y = class _y {
  static bindPipeline(e, t) {
    if (_y.lastShader != t)
      _y.lastShader = t;
    else
      return;
    _y.lastPipeline != t.pipeline && (_y.lastPipeline = t.pipeline, e.setPipeline(t.pipeline));
    for (let r = 1; r < t.bindGroups.length; r++) {
      const i = t.bindGroups[r];
      i && e.setBindGroup(r, i);
    }
  }
  static bindCamera(e, t) {
    let r = oe.getCameraGroup(t);
    e.setBindGroup(0, r.globalBindGroup);
  }
  static bindGeometryBuffer(e, t) {
    if (this.lastGeometry != t) {
      this.lastGeometry = t, t.indicesBuffer && e.setIndexBuffer(t.indicesBuffer.indicesGPUBuffer.buffer, t.indicesBuffer.indicesFormat);
      let r = t.vertexBuffer.vertexGPUBuffer, i = t.vertexBuffer.vertexBufferLayouts;
      for (let a = 0; a < i.length; a++) {
        const o = i[a];
        e.setVertexBuffer(a, r.buffer, o.offset, o.size);
      }
    }
  }
  static cleanCache() {
    this.lastGeometry = null, this.lastPipeline = null, this.lastShader = null;
  }
  static createPipeline(e) {
    return St.countStart("GPUContext", "pipeline"), w.device.createRenderPipeline(e);
  }
  static beginCommandEncoder() {
    return St.countStart("GPUContext", "beginCommandEncoder"), this.LastCommand && w.device.queue.submit([this.LastCommand.finish()]), this.LastCommand = w.device.createCommandEncoder(), this.LastCommand;
  }
  static endCommandEncoder(e) {
    this.LastCommand == e && (w.device.queue.submit([this.LastCommand.finish()]), this.LastCommand = null, St.countStart("GPUContext", "endCommandEncoder"));
  }
  static recordBundleEncoder(e) {
    return w.device.createRenderBundleEncoder(e);
  }
  static beginRenderPass(e, t) {
    if (this.cleanCache(), this.renderPassCount++, this.lastRenderPassState = t, t.renderTargets && t.renderTargets.length > 0) {
      for (let r = 0; r < t.renderTargets.length; ++r) {
        const i = t.renderTargets[r];
        let a = t.renderPassDescriptor.colorAttachments[r];
        t.multisample > 0 && t.renderTargets.length == 1 ? (a.view = t.multiTexture.createView(), a.resolveTarget = i.getGPUView()) : a.view = i.getGPUTexture().createView();
      }
      return e.beginRenderPass(t.renderPassDescriptor);
    } else {
      let r = t.renderPassDescriptor.colorAttachments[0];
      return r && (t.multisample > 0 ? (r.view = t.multiTexture.createView(), r.resolveTarget = w.context.getCurrentTexture().createView()) : r.view = w.context.getCurrentTexture().createView()), e.beginRenderPass(t.renderPassDescriptor);
    }
  }
  static drawIndexed(e, t, r, i, a, o) {
    e.drawIndexed(t, r, i, a, o), this.drawCount++;
  }
  static draw(e, t, r, i, a) {
    e.draw(t, r, i, a), this.drawCount++;
  }
  static endPass(e) {
    e.insertDebugMarker("end"), e.end();
  }
  static computeCommand(e, t) {
    let r = e.beginComputePass();
    for (let i = 0; i < t.length; i++)
      t[i].compute(r);
    r.end();
  }
};
__publicField(_y, "lastGeometry");
__publicField(_y, "lastPipeline");
__publicField(_y, "lastShader");
__publicField(_y, "drawCount", 0);
__publicField(_y, "renderPassCount", 0);
__publicField(_y, "geometryCount", 0);
__publicField(_y, "pipelineCount", 0);
__publicField(_y, "matrixCount", 0);
__publicField(_y, "lastRenderPassState");
__publicField(_y, "LastCommand");
var y = _y;
var Vl = class {
  constructor() {
    __publicField(this, "source");
    __publicField(this, "input");
    __publicField(this, "output");
  }
  reset(e) {
    this.input && this.input.destroy(), this.output && this.output.destroy(), this.input = this.output = null, this.source = e;
  }
  apply(e) {
    if (this.source) {
      if (!this.input) {
        let t = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        this.input = new $(this.source.length, t, this.source), this.input.apply();
      }
      if (!this.output) {
        let t = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;
        this.output = new $(e * 3, t), this.output.apply();
      }
    }
  }
};
var Hl = class {
  constructor() {
    __publicField(this, "enable");
    __publicField(this, "morphTargetsRelative");
    __publicField(this, "MaxMorphTargetCount", 64);
    __publicField(this, "_computeConfigArray");
    __publicField(this, "_computeConfigBuffer");
    __publicField(this, "_morphInfluenceArray");
    __publicField(this, "_morphInfluenceBuffer");
    __publicField(this, "_positionAttrDataGroup");
    __publicField(this, "_normalAttrDataGroup");
    __publicField(this, "_isInfluenceDirty");
    __publicField(this, "_morphTargetCount");
    __publicField(this, "_totalVertexCount");
    __publicField(this, "_computeShader");
    __publicField(this, "_computeShaders");
    __publicField(this, "_computeWorkGroupXY", 1);
    __publicField(this, "_collectMorphTargetData");
    __publicField(this, "_blendTarget");
    this._isInfluenceDirty = true, this.generateGPUBuffer(), this._positionAttrDataGroup = new Vl(), this._normalAttrDataGroup = new Vl();
  }
  initMorphTarget(e) {
    this._collectMorphTargetData = this.collectMorphTargetList(e), this._computeShader && this._computeShader.destroy();
    let t = dt.CsMain;
    this._computeShader = new ae(t), this._collectMorphTargetData.mergedNormal ? this._computeShader.setDefine("USE_MORPHNORMALS", true) : this._computeShader.deleteDefine("USE_MORPHNORMALS"), this._computeShaders = [this._computeShader], this._isInfluenceDirty = true, this._morphTargetCount = this._collectMorphTargetData.mtCount, this._totalVertexCount = this._collectMorphTargetData.vCount, this._morphInfluenceArray.fill(0), this._computeWorkGroupXY = this.calcWorkGroup(this._totalVertexCount), this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos), this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal);
  }
  applyRenderShader(e) {
    this.uploadMorphTargetBuffer(), this.uploadConfigGBuffer(), e.setUniformBuffer("morphTargetConfig", this._computeConfigBuffer), e.setStorageBuffer("morphTargetOpPositions", this._positionAttrDataGroup.output), this._collectMorphTargetData.mergedNormal && e.setStorageBuffer("morphTargetOpNormals", this._normalAttrDataGroup.output);
  }
  computeMorphTarget(e) {
    this.uploadConfigGBuffer(), this.uploadMorphTargetBuffer(), this._computeShader.setUniformBuffer("morphTargetConfig", this._computeConfigBuffer), this._computeShader.setStorageBuffer("morphTargetInfluence", this._morphInfluenceBuffer), this._computeShader.setStorageBuffer("morphTargetPositions", this._positionAttrDataGroup.input), this._computeShader.setStorageBuffer("morphTargetOpPositions", this._positionAttrDataGroup.output), this._collectMorphTargetData.mergedNormal && (this._computeShader.setStorageBuffer("morphTargetNormals", this._normalAttrDataGroup.input), this._computeShader.setStorageBuffer("morphTargetOpNormals", this._normalAttrDataGroup.output)), this._computeShader.workerSizeX = this._computeWorkGroupXY, this._computeShader.workerSizeY = this._computeWorkGroupXY, this._computeShader.workerSizeZ = 1, y.computeCommand(e, this._computeShaders);
  }
  updateInfluence(e, t) {
    this._isInfluenceDirty = true, this._morphInfluenceArray[e] = t;
  }
  get blendShape() {
    return this._blendTarget;
  }
  collectMorphTargetList(e) {
    let t = this.collectAttribute("a_morphPositions_", e), r = t.length, i = t[0].data.length / 3;
    if (this._blendTarget = {}, e.blendShapeData)
      for (let l = 0; l < e.blendShapeData.shapeIndexs.length; l++) {
        let h = e.blendShapeData.shapeIndexs[l], u = e.blendShapeData.shapeNames[l].split("."), c = u[u.length - 1];
        this._blendTarget[c] = (f) => this.updateInfluence(h, f);
      }
    let a = new Float32Array(i * r * 3);
    {
      let l = 0;
      for (let h = 0; h < r; h++) {
        let u = t[h];
        a.set(u.data, l), l += u.data.length;
      }
    }
    let o = this.collectAttribute("a_morphNormals_", e), n;
    if (o && o.length > 0) {
      let l = 0;
      n = new Float32Array(i * r * 3);
      for (let h = 0; h < r; h++) {
        let u = o[h];
        n.set(u.data, l), l += u.data.length;
      }
    }
    return { mtCount: r, vCount: i, mergedPos: a, mergedNormal: n };
  }
  collectAttribute(e, t) {
    let r = [];
    for (let i = 0; i < this.MaxMorphTargetCount; i++) {
      let a = e + i, o = t.getAttribute(a);
      if (o)
        r[i] = o;
      else
        break;
    }
    return r;
  }
  uploadConfigGBuffer() {
    if (this._isInfluenceDirty) {
      let e = 0;
      for (let t = 0; t < this._morphTargetCount; t++)
        e += this._morphInfluenceArray[t];
      this._morphInfluenceBuffer.setFloat32Array("data", this._morphInfluenceArray), this._morphInfluenceBuffer.apply(), this._computeConfigArray[0] = this.morphTargetsRelative ? 1 : 1 - e, this._computeConfigArray[1] = this._morphTargetCount, this._computeConfigArray[2] = this._totalVertexCount, this._computeConfigArray[3] = this._computeWorkGroupXY, this._computeConfigBuffer.setFloat32Array("data", this._computeConfigArray), this._computeConfigBuffer.apply(), this._isInfluenceDirty = false;
    }
  }
  calcWorkGroup(e) {
    let t = Math.ceil(Math.sqrt(e)), r = Math.ceil(Math.log2(t));
    return t = Math.pow(2, r), t;
  }
  uploadMorphTargetBuffer() {
    this._positionAttrDataGroup.output || this._positionAttrDataGroup.apply(this._totalVertexCount), this._normalAttrDataGroup.output || this._normalAttrDataGroup.apply(this._totalVertexCount);
  }
  generateGPUBuffer() {
    this._computeConfigArray = new Float32Array(4), this._computeConfigBuffer = new ft(4), this._morphInfluenceArray = new Float32Array(this.MaxMorphTargetCount);
    let e = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
    this._morphInfluenceBuffer = new $(this.MaxMorphTargetCount, e);
  }
};
var Pd = Object.defineProperty;
var Md = Object.getOwnPropertyDescriptor;
var wi = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Md(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Pd(e, t, i), i;
};
var J = class extends tr {
  constructor() {
    super();
    __publicField(this, "receiveShadow");
    __publicField(this, "morphData");
  }
  onEnable() {
    super.onEnable();
  }
  onDisable() {
    super.onDisable();
  }
  cloneTo(s) {
    s.addComponent(J).copyComponent(this);
  }
  copyComponent(s) {
    return super.copyComponent(s), this.receiveShadow = s.receiveShadow, this;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(s) {
    super.geometry = s;
    let e = s.morphTargetDictionary != null;
    e && (this.morphData || (this.morphData = new Hl()), this.morphData.morphTargetsRelative = s.morphTargetsRelative, this.morphData.initMorphTarget(s)), this.morphData && (this.morphData.enable = e), this.morphData && this.morphData.enable ? this.addRendererMask(De.MorphTarget) : this.removeRendererMask(De.MorphTarget), this.object3D.bound = this._geometry.bounds.clone(), this._readyPipeline || (this.initPipeline(), this._computes && this._computes && (this.onCompute = rn(this.onCompute, () => {
      for (let t = 0; t < this._computes.length; t++)
        this._computes[t].onUpdate();
    })));
  }
  get material() {
    return this._materials[0];
  }
  set material(s) {
    this.materials = [s];
  }
  setMorphInfluence(s, e) {
    if (this.morphData && this.morphData.enable) {
      let t = this._geometry.morphTargetDictionary[s];
      t >= 0 && this.morphData.updateInfluence(t, e);
    }
  }
  setMorphInfluenceIndex(s, e) {
    this.morphData && this.morphData.enable && s >= 0 && this.morphData.updateInfluence(s, e);
  }
  onCompute(s, e) {
    this.morphData && this.morphData.enable && this.morphData.computeMorphTarget(e);
  }
  nodeUpdate(s, e, t, r) {
    if (this.morphData && this.morphData.enable)
      for (let i = 0; i < this.materials.length; i++) {
        let o = this.materials[i].getPass(e);
        if (o)
          for (let n = 0; n < o.length; n++)
            this.morphData.applyRenderShader(o[n]);
      }
    super.nodeUpdate(s, e, t, r);
  }
  destroy(s) {
    super.destroy(s);
  }
};
wi([Qt], J.prototype, "geometry", 1), wi([Qt], J.prototype, "geometry", 1), wi([Qt], J.prototype, "material", 1), wi([Qt], J.prototype, "material", 1), J = wi([_t(J, "MeshRenderer")], J);
var Yl = class {
  constructor() {
    __publicField(this, "label", "");
    __publicField(this, "customSize", false);
    __publicField(this, "zPreTexture", null);
    __publicField(this, "depthTexture", null);
    __publicField(this, "renderTargetTextures");
    __publicField(this, "outColor", -1);
    __publicField(this, "renderTargets");
    __publicField(this, "rtTextureDescriptors");
    __publicField(this, "irradianceBuffer");
    __publicField(this, "multisample", 0);
    __publicField(this, "multiTexture");
    __publicField(this, "depthViewIndex", 0);
    __publicField(this, "depthCleanValue", 0);
    __publicField(this, "isOutTarget", true);
    __publicField(this, "camera3D");
    __publicField(this, "rtFrame");
    __publicField(this, "renderPassDescriptor");
    __publicField(this, "renderBundleEncoderDescriptor");
    __publicField(this, "depthLoadOp");
  }
  getLastRenderTexture() {
    return this.renderTargets && this.renderTargets.length > 0 ? this.renderTargets[0] : p.res.redTexture;
  }
};
var _ye = class _ye {
  static createRendererPassState(e, t = null) {
    let r = new Yl();
    if (r.label = e.label, r.customSize = e.customSize, r.rtFrame = e, r.zPreTexture = e.zPreTexture, r.depthTexture = e.depthTexture, r.depthViewIndex = e.depthViewIndex, r.isOutTarget = e.isOutTarget, r.depthCleanValue = e.depthCleanValue, r.depthLoadOp = e.depthLoadOp, e && e.renderTargets.length > 0) {
      r.renderTargets = e.renderTargets, r.rtTextureDescriptors = e.rtDescriptors, r.renderPassDescriptor = _ye.getRenderPassDescriptor(r), r.renderBundleEncoderDescriptor = _ye.getRenderBundleDescriptor(r), r.renderTargetTextures = [];
      for (let i = 0; i < e.renderTargets.length; i++) {
        const a = e.renderTargets[i];
        r.renderTargetTextures[i] = { format: a.format }, a.name.indexOf(Fe.colorBufferTex_NAME) != -1 && (r.outColor = i);
      }
    } else
      r.renderPassDescriptor = _ye.getRenderPassDescriptor(r, t), r.renderBundleEncoderDescriptor = _ye.getRenderBundleDescriptor(r), r.renderTargetTextures = [{ format: w.presentationFormat }], r.outColor = 0;
    return r;
  }
  static getRenderPassDescriptor(e, t = null) {
    w.device, w.presentationSize;
    let r = [];
    if (e.renderTargets && e.renderTargets.length > 0) {
      e.renderTargets[0].width, e.renderTargets[0].height;
      for (let a = 0; a < e.renderTargets.length; a++) {
        const o = e.renderTargets[a], n = e.rtTextureDescriptors[a];
        r.push({ view: o.getGPUView(), resolveTarget: void 0, loadOp: n.loadOp, clearValue: n.clearValue, storeOp: n.storeOp });
      }
    } else if (!e.customSize) {
      let a = w.canvasConfig && w.canvasConfig.alpha ? [1, 1, 1, 0] : [0, 0, 0, 1];
      e.isOutTarget == true && r.push({ view: void 0, resolveTarget: void 0, loadOp: w.canvasConfig && w.canvasConfig.alpha || t != null ? "load" : "clear", clearValue: a, storeOp: "store" });
    }
    let i = null;
    return e.depthTexture || e.zPreTexture ? (e.zPreTexture && (e.depthTexture = e.zPreTexture), i = { label: `${e.label} renderPassDescriptor zPreTexture${e.zPreTexture ? "load" : "clear"}`, colorAttachments: r, depthStencilAttachment: { view: e.depthTexture.getGPUView(), depthLoadOp: e.zPreTexture ? "load" : e.depthLoadOp, depthClearValue: e.zPreTexture ? 1 : e.depthCleanValue, depthStoreOp: "store" } }) : i = { colorAttachments: r, label: "renderPassDescriptor not writeDepth" }, this.renderPassDescriptorCount++, i;
  }
  static getRenderBundleDescriptor(e) {
    w.presentationSize;
    let t = [];
    if (e.renderTargets && e.renderTargets.length > 0) {
      e.renderTargets[0].width, e.renderTargets[0].height;
      for (let i = 0; i < e.renderTargets.length; i++) {
        const a = e.renderTargets[i];
        t.push(a.format);
      }
    }
    let r = null;
    return e.depthTexture ? r = { colorFormats: t, depthStencilFormat: e.depthTexture.format } : r = { colorFormats: t }, this.renderPassDescriptorCount++, r;
  }
};
__publicField(_ye, "bindGroupDescriptorCount", 0);
__publicField(_ye, "bindTextureDescriptorCount", 0);
__publicField(_ye, "renderPassDescriptorCount", 0);
__publicField(_ye, "pipelineDescriptorCount", 0);
var ye = _ye;
var Aa = class extends Jt {
  constructor(e) {
    super();
    __publicField(this, "node");
    this.bufferType = Tt.VertexGPUBuffer, this.createVertexBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX, e);
  }
  createVertexBuffer(e, t) {
    let r = w.device;
    this.byteSize = t * Float32Array.BYTES_PER_ELEMENT, this.usage = e, this.buffer && this.destroy(), this.buffer = r.createBuffer({ label: "VertexGPUBuffer", size: this.byteSize, usage: e, mappedAtCreation: false }), this.memory = new fr(), this.memoryNodes = /* @__PURE__ */ new Map(), this.memory.allocation(this.byteSize), this.node = this.memory.allocation_node(this.byteSize);
  }
};
var Xe = ((s) => (s[s.split = 0] = "split", s[s.compose = 1] = "compose", s[s.compose_bin = 2] = "compose_bin", s))(Xe || {});
var Xl = class {
  constructor() {
    __publicField(this, "vertexCount", 0);
    __publicField(this, "vertexGPUBuffer");
    __publicField(this, "geometryType", Xe.compose);
    __publicField(this, "_vertexBufferLayouts");
    __publicField(this, "_attributeSlotLayouts");
    __publicField(this, "_attributeLocation");
    this._vertexBufferLayouts = [], this._attributeLocation = {}, this._attributeSlotLayouts = [];
  }
  get vertexBufferLayouts() {
    return this._vertexBufferLayouts;
  }
  createVertexBuffer(e, t) {
    switch (this.geometryType) {
      case Xe.split:
        this.createSplitVertexBuffer(e, t);
        break;
      case Xe.compose:
        this.createComposeVertexBuffer(e, t);
        break;
      case Xe.compose_bin:
        this.createComposBinVertexBuffer(e, t);
        break;
    }
  }
  createSplitVertexBuffer(e, t) {
    let r = 0;
    for (let i = 0; i < t.attributes.length; i++) {
      const a = t.attributes[i];
      if (a.name == "index")
        continue;
      this._attributeLocation[a.name] = a.location;
      let o = { name: a.name, format: a.format, offset: 0, shaderLocation: a.location, stride: gr[a.format] };
      this._attributeSlotLayouts[a.location] = [o];
      let n = e.get(a.name);
      n || (n = { attribute: a.name, data: new Float32Array(a.size * this.vertexCount) }, e.set(a.name, n));
      let l = n.data.length / o.stride;
      this.vertexCount != 0 && this.vertexCount != l && console.error(" vertex count not match attribute count"), this.vertexCount = l, this._vertexBufferLayouts[a.location] = { name: a.name, arrayStride: a.size * 4, stepMode: "vertex", attributes: this._attributeSlotLayouts[a.location], offset: r * 4, size: this.vertexCount * a.size * 4 }, r += this.vertexCount * a.size;
    }
    this.vertexGPUBuffer = new Aa(r);
  }
  createComposeVertexBuffer(e, t) {
    this._attributeSlotLayouts[0] = [];
    let r = 0;
    for (let i = 0; i < t.attributes.length; i++) {
      const a = t.attributes[i];
      if (a.name == "index" || a.type == "builtin")
        continue;
      this._attributeLocation[a.name] = a.location;
      let o = { name: a.name, format: a.format, offset: r * 4, shaderLocation: a.location, stride: gr[a.format] };
      this._attributeSlotLayouts[0][a.location] = o;
      let n = e.get(a.name);
      if (n || (n = { attribute: a.name, data: new Float32Array(a.size * this.vertexCount) }, e.set(a.name, n)), n.data) {
        let l = n.data.length / o.stride;
        this.vertexCount != 0 && this.vertexCount != l && console.error(" vertex count not match attribute count"), this.vertexCount = l;
      }
      r += a.size;
    }
    this._vertexBufferLayouts[0] = { name: "composeStruct", arrayStride: r * 4, stepMode: "vertex", attributes: this._attributeSlotLayouts[0], offset: 0, size: this.vertexCount * r * 4 }, this.vertexGPUBuffer = new Aa(this.vertexCount * r);
  }
  createComposBinVertexBuffer(e, t) {
    this._attributeSlotLayouts[0] = [];
    let r = 0;
    for (let o = 0; o < t.attributes.length; o++) {
      const n = t.attributes[o];
      if (n.name == "index" || n.type == "builtin")
        continue;
      this._attributeLocation[n.name] = n.location;
      let l = { name: n.name, format: n.format, offset: r * 4, shaderLocation: n.location, stride: gr[n.format] };
      this._attributeSlotLayouts[0][n.location] = l;
      let h = e.get(n.name);
      if (h || (h = { attribute: n.name, data: new Float32Array(n.size * this.vertexCount) }, e.set(n.name, h)), h.data) {
        let u = h.data.length / l.stride;
        this.vertexCount != 0 && this.vertexCount != u && console.error(" vertex count not match attribute count"), this.vertexCount = u;
      }
      r += n.size;
    }
    let a = e.get(D.all).data.length / r;
    this.vertexCount = a, this._vertexBufferLayouts[0] = { name: "composeStruct", arrayStride: r * 4, stepMode: "vertex", attributes: this._attributeSlotLayouts[0], offset: 0, size: this.vertexCount * r * 4 }, this.vertexGPUBuffer = new Aa(this.vertexCount * r);
  }
  upload(e, t) {
    var _a3;
    if (this.vertexGPUBuffer) {
      switch (this.geometryType) {
        case Xe.split:
          {
            let r = this._attributeLocation[e], i = this._vertexBufferLayouts[r];
            this.vertexGPUBuffer.node.setFloat32Array(i.offset / 4, t.data);
          }
          break;
        case Xe.compose:
          for (let r = 0; r < this.vertexCount; r++) {
            const i = this._attributeSlotLayouts[0][this._attributeLocation[e]];
            for (let a = 0; a < i.stride; a++) {
              let o = t.data[r * i.stride + a], n = r * (this._vertexBufferLayouts[0].arrayStride / 4) + i.offset / 4 + a;
              this.vertexGPUBuffer.node.setFloat(o, n);
            }
          }
          break;
        case Xe.compose_bin:
          this.vertexGPUBuffer.node.setFloat32Array(0, t.data);
          break;
      }
      (_a3 = this.vertexGPUBuffer) == null ? void 0 : _a3.apply();
    }
  }
  updateAttributes(e) {
    switch (this.geometryType) {
      case Xe.split:
        for (let t = 0; t < this._vertexBufferLayouts.length; t++) {
          const r = this._vertexBufferLayouts[t];
          let i = e.get(r.name);
          this.vertexGPUBuffer.node.setFloat32Array(r.offset / 4, i.data);
        }
        break;
      case Xe.compose:
        for (let t = 0; t < this.vertexCount; t++)
          this._attributeSlotLayouts.forEach((r) => {
            for (let i = 0; i < r.length; i++) {
              const a = r[i];
              let o = e.get(a.name);
              for (let n = 0; n < a.stride; n++) {
                let l = o.data[t * a.stride + n], h = t * (this._vertexBufferLayouts[0].arrayStride / 4) + a.offset / 4 + n;
                this.vertexGPUBuffer.node.setFloat(l, h);
              }
            }
          });
        break;
      case Xe.compose_bin:
        {
          let t = e.get(D.all);
          this.vertexGPUBuffer.node.setFloat32Array(0, t.data);
        }
        break;
    }
    this.vertexGPUBuffer.apply();
  }
  compute() {
  }
  destroy(e) {
    this.vertexCount = null, this.geometryType = null, this._vertexBufferLayouts = null, this._attributeSlotLayouts = null, this._attributeLocation = null, this.vertexGPUBuffer && this.vertexGPUBuffer.destroy(e), this.vertexGPUBuffer = null;
  }
};
var Wl = class extends Jt {
  constructor(e) {
    super();
    __publicField(this, "indicesNode");
    this.bufferType = Tt.IndicesGPUBuffer, this.createIndicesBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.INDEX | GPUBufferUsage.INDIRECT, e);
  }
  createIndicesBuffer(e, t) {
    let r = w.device;
    this.byteSize = t.length * 4, this.usage = e, this.buffer && this.destroy(), this.buffer = r.createBuffer({ label: "IndicesGPUBuffer", size: this.byteSize, usage: e, mappedAtCreation: false }), this.memory = new fr(), this.memoryNodes = /* @__PURE__ */ new Map(), this.memory.allocation(this.byteSize), t && (this.indicesNode = this.memory.allocation_node(t.length * 4), this.indicesNode.setArrayBuffer(0, t), this.apply());
  }
};
var jl = class {
  constructor() {
    __publicField(this, "uuid", "");
    __publicField(this, "name");
    __publicField(this, "indicesGPUBuffer");
    __publicField(this, "indicesFormat", "uint16");
    __publicField(this, "indicesCount", 0);
  }
  createIndicesBuffer(e) {
    e.data instanceof Uint16Array ? this.indicesFormat = "uint16" : e.data instanceof Uint32Array && (this.indicesFormat = "uint32"), this.indicesCount = e.data.length, this.indicesGPUBuffer = new Wl(e.data);
  }
  upload(e) {
    this.indicesGPUBuffer.indicesNode.setArrayBuffer(0, e), this.indicesGPUBuffer.apply();
  }
  compute() {
  }
  destroy() {
    this.uuid = null, this.name = null, this.indicesFormat = null, this.indicesCount = null, this.indicesGPUBuffer.destroy(), this.indicesGPUBuffer = null;
  }
};
var ql = class {
  constructor() {
    __publicField(this, "lodLevels");
  }
};
var _xe = class _xe {
  constructor() {
    __publicField(this, "instanceID");
    __publicField(this, "name");
    __publicField(this, "subGeometries", []);
    __publicField(this, "morphTargetsRelative");
    __publicField(this, "morphTargetDictionary");
    __publicField(this, "skinNames");
    __publicField(this, "bindPose");
    __publicField(this, "blendShapeData");
    __publicField(this, "vertexDim");
    __publicField(this, "_bounds");
    __publicField(this, "_attributeMap");
    __publicField(this, "_attributes");
    __publicField(this, "_indicesBuffer");
    __publicField(this, "_vertexBuffer");
    __publicField(this, "_onChange", true);
    __publicField(this, "_wireframeLines");
    this.instanceID = gt(), this._attributeMap = /* @__PURE__ */ new Map(), this._attributes = [], this._vertexBuffer = new Xl();
  }
  get indicesBuffer() {
    return this._indicesBuffer;
  }
  get vertexBuffer() {
    return this._vertexBuffer;
  }
  get vertexAttributes() {
    return this._attributes;
  }
  get vertexAttributeMap() {
    return this._attributeMap;
  }
  get geometryType() {
    return this._vertexBuffer.geometryType;
  }
  set geometryType(e) {
    this._vertexBuffer.geometryType = e;
  }
  get bounds() {
    if (!this._bounds) {
      this._bounds = new ge(new d(), new d(1, 1, 1)), this._bounds.min.x = Number.MAX_VALUE, this._bounds.min.y = Number.MAX_VALUE, this._bounds.min.z = Number.MAX_VALUE, this._bounds.max.x = -Number.MAX_VALUE, this._bounds.max.y = -Number.MAX_VALUE, this._bounds.max.z = -Number.MAX_VALUE;
      let e = this.getAttribute(D.position);
      if (e && e.data)
        for (let t = 0; t < e.data.length / 3; t++) {
          const r = e.data[t * 3 + 0], i = e.data[t * 3 + 1], a = e.data[t * 3 + 2];
          this._bounds.min.x > r && (this._bounds.min.x = r), this._bounds.min.y > i && (this._bounds.min.y = i), this._bounds.min.z > a && (this._bounds.min.z = a), this._bounds.max.x < r && (this._bounds.max.x = r), this._bounds.max.y < i && (this._bounds.max.y = i), this._bounds.max.z < a && (this._bounds.max.z = a);
        }
      this._bounds.setFromMinMax(this._bounds.min, this._bounds.max);
    }
    return this._bounds;
  }
  set bounds(e) {
    this._bounds = e;
  }
  addSubGeometry(...e) {
    let t = new ql();
    return t.lodLevels = e, this.subGeometries.push(t), t;
  }
  generate(e) {
    this._onChange && (this._onChange = false, this._indicesBuffer.upload(this.getAttribute(D.indices).data), this._vertexBuffer.createVertexBuffer(this._attributeMap, e), this._vertexBuffer.updateAttributes(this._attributeMap));
  }
  setIndices(e) {
    if (!this._attributeMap.has(D.indices)) {
      let t = { attribute: D.indices, data: e };
      this._attributeMap.set(D.indices, t), this._indicesBuffer = new jl(), this._indicesBuffer.createIndicesBuffer(t);
    }
  }
  setAttribute(e, t) {
    if (e == D.indices)
      this.setIndices(t);
    else {
      let r = { attribute: e, data: t };
      this._attributeMap.set(e, r), this._attributes.push(e);
    }
  }
  getAttribute(e) {
    return this._attributeMap.get(e);
  }
  hasAttribute(e) {
    return this._attributeMap.has(e);
  }
  genWireframe() {
    if (this._wireframeLines)
      return this._wireframeLines;
    if (this.geometryType == Xe.split || this.geometryType == Xe.compose) {
      let e = this.getAttribute(D.position), t = this.getAttribute(D.indices);
      if (t && e && t.data.length > 0) {
        let r = e.data, i = [];
        for (let a = 0; a < t.data.length / 3; a++) {
          const o = t.data[a * 3 + 0], n = t.data[a * 3 + 1], l = t.data[a * 3 + 2];
          let h = new d(r[o * 3 + 0], r[o * 3 + 1], r[o * 3 + 2]), u = new d(r[n * 3 + 0], r[n * 3 + 1], r[n * 3 + 2]), c = new d(r[l * 3 + 0], r[l * 3 + 1], r[l * 3 + 2]);
          i.push(h, u), i.push(u, c), i.push(c, h);
        }
        return this._wireframeLines = i, i;
      }
    } else if (this.geometryType == Xe.compose_bin) {
      let e = this.getAttribute(D.all), t = this.vertexDim, r = this.getAttribute(D.indices);
      if (r && e && r.data.length > 0) {
        let i = e.data, a = [];
        for (let o = 0; o < r.data.length / 3; o++) {
          const n = r.data[o * 3 + 0], l = r.data[o * 3 + 1], h = r.data[o * 3 + 2];
          let u = new d(i[n * t + 0], i[n * t + 1], i[n * t + 2]), c = new d(i[l * t + 0], i[l * t + 1], i[l * t + 2]), f = new d(i[h * t + 0], i[h * t + 1], i[h * t + 2]);
          a.push(u, c), a.push(c, f), a.push(f, u);
        }
        return this._wireframeLines = a, a;
      }
    }
    return null;
  }
  compute() {
    this._indicesBuffer && this._indicesBuffer.compute(), this._vertexBuffer && this._vertexBuffer.compute();
  }
  computeNormals() {
    let e = this.getAttribute(D.position), t = this.getAttribute(D.normal), r = this.getAttribute(D.indices);
    if (!e || !t || !r)
      return this;
    let i = r.data.length / 3, a = _xe.point1, o = _xe.point2, n = _xe.point3, l = _xe.crossA, h = _xe.crossB, u = _xe.crossRet;
    for (let c = 0; c < i; c++) {
      let f = r.data[c * 3], g = r.data[c * 3 + 1], m = r.data[c * 3 + 2];
      a.set(e.data[f * 3], e.data[f * 3 + 1], e.data[f * 3 + 2]), o.set(e.data[g * 3], e.data[g * 3 + 1], e.data[g * 3 + 2]), n.set(e.data[m * 3], e.data[m * 3 + 1], e.data[m * 3 + 2]), d.sub(a, o, l).normalize(), d.sub(a, n, h).normalize();
      let A = l.crossProduct(h, u).normalize();
      t.data[f * 3] = t.data[g * 3] = t.data[m * 3] = A.x, t.data[f * 3 + 1] = t.data[g * 3 + 1] = t.data[m * 3 + 1] = A.y, t.data[f * 3 + 2] = t.data[g * 3 + 2] = t.data[m * 3 + 2] = A.z;
    }
    return this._vertexBuffer.upload(D.normal, t), this;
  }
  isPrimitive() {
    return false;
  }
  destroy(e) {
    this.instanceID = null, this.name = null, this.subGeometries = null, this.morphTargetDictionary = null, this._bounds.destroy(), this._bounds = null, this._attributeMap = null, this._attributes = null, this._indicesBuffer.destroy(), this._vertexBuffer.destroy(), this._indicesBuffer = null, this._vertexBuffer = null;
  }
};
__publicField(_xe, "crossA", d.UP.clone());
__publicField(_xe, "crossB", d.UP.clone());
__publicField(_xe, "crossRet", d.UP.clone());
__publicField(_xe, "point1", d.UP.clone());
__publicField(_xe, "point2", d.UP.clone());
__publicField(_xe, "point3", d.UP.clone());
var xe = _xe;
var Kl = class extends xe {
  constructor(e, t, r = 1, i = 1, a = d.Y_AXIS) {
    super();
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "segmentW");
    __publicField(this, "segmentH");
    __publicField(this, "up");
    this.width = e, this.height = t, this.segmentW = r, this.segmentH = i, this.up = a, this.buildGeometry(this.up);
  }
  buildGeometry(e) {
    var t, r, i, a, o = this.segmentW + 1;
    (this.segmentH + 1) * o, this.bounds = new ge(d.ZERO.clone(), new d(this.width, 1, this.height)), i = this.segmentH * this.segmentW * 6;
    let n = (this.segmentW + 1) * (this.segmentH + 1), l = new Float32Array(n * 3), h = new Float32Array(n * 3), u = new Float32Array(n * 2), c;
    this.segmentW * this.segmentH * 2 * 3 >= Uint16Array.length ? c = new Uint32Array(this.segmentW * this.segmentH * 2 * 3) : c = new Uint16Array(this.segmentW * this.segmentH * 2 * 3), i = 0;
    for (var g = 0, m = 0, A = 0, _ = 0; _ <= this.segmentH; ++_)
      for (var x = 0; x <= this.segmentW; ++x) {
        switch (t = (x / this.segmentW - 0.5) * this.width, r = (_ / this.segmentH - 0.5) * this.height, e) {
          case d.Y_AXIS:
            l[g++] = t, l[g++] = 0, l[g++] = r, h[m++] = 0, h[m++] = 1, h[m++] = 0;
            break;
          case d.Z_AXIS:
            l[g++] = t, l[g++] = -r, l[g++] = 0, h[m++] = 0, h[m++] = 0, h[m++] = 1;
            break;
          case d.X_AXIS:
            l[g++] = 0, l[g++] = t, l[g++] = r, h[m++] = 1, h[m++] = 0, h[m++] = 0;
            break;
          default:
            l[g++] = t, l[g++] = 0, l[g++] = r, h[m++] = 0, h[m++] = 1, h[m++] = 0;
            break;
        }
        u[A++] = x / this.segmentW, u[A++] = _ / this.segmentH, x != this.segmentW && _ != this.segmentH && (a = x + _ * o, c[i++] = a + 1, c[i++] = a, c[i++] = a + o, c[i++] = a + 1, c[i++] = a + o, c[i++] = a + o + 1);
      }
    this.setIndices(c), this.setAttribute(D.position, l), this.setAttribute(D.normal, h), this.setAttribute(D.uv, u), this.setAttribute(D.TEXCOORD_1, u), this.addSubGeometry({ indexStart: 0, indexCount: c.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
  }
};
var je = class _je {
  constructor() {
    __publicField(this, "instanceID");
    __publicField(this, "name");
    __publicField(this, "enable", true);
    __publicField(this, "_defaultSubShader");
    __publicField(this, "_shader");
  }
  set shader(e) {
    this._shader = e, this._defaultSubShader = e.getDefaultShaders()[0];
  }
  get shader() {
    return this._shader;
  }
  get doubleSide() {
    return this._defaultSubShader.doubleSide;
  }
  set doubleSide(e) {
    this._defaultSubShader.doubleSide = e;
  }
  get castShadow() {
    return this._defaultSubShader.shaderState.castShadow;
  }
  set castShadow(e) {
    let t = this._defaultSubShader.shaderState;
    e != t.castShadow && (t.castShadow = e);
  }
  get acceptShadow() {
    return this._defaultSubShader.shaderState.acceptShadow;
  }
  set acceptShadow(e) {
    let t = this._defaultSubShader.shaderState;
    t.acceptShadow != e && (t.acceptShadow = e, this._defaultSubShader.noticeShaderChange(), this._defaultSubShader.noticeValueChange());
  }
  get blendMode() {
    return this._defaultSubShader.blendMode;
  }
  set blendMode(e) {
    this._defaultSubShader.blendMode = e;
  }
  get depthCompare() {
    return this._defaultSubShader.depthCompare;
  }
  set depthCompare(e) {
    this._defaultSubShader.depthCompare = e;
  }
  get transparent() {
    return this._defaultSubShader.shaderState.transparent;
  }
  set transparent(e) {
    this._defaultSubShader.shaderState.transparent = e, e && (this._defaultSubShader.renderOrder = 3e3);
  }
  get cullMode() {
    return this._defaultSubShader.cullMode;
  }
  set cullMode(e) {
    if (this._defaultSubShader.cullMode != e) {
      for (let t of this._shader.passShader.values())
        for (let r of t)
          r.cullMode = e;
      this._defaultSubShader.cullMode = e;
    }
  }
  get depthWriteEnabled() {
    return this._defaultSubShader.depthWriteEnabled;
  }
  set depthWriteEnabled(e) {
    this._defaultSubShader.depthWriteEnabled = e;
  }
  set useBillboard(e) {
    this._defaultSubShader.setDefine("USE_BILLBOARD", e);
  }
  getPass(e) {
    return this._shader.getSubShaders(e);
  }
  getAllPass() {
    return this._shader.getSubShaders(q.COLOR);
  }
  clone() {
    let e = new _je();
    return e.shader = this.shader.clone(), e;
  }
  destroy(e) {
    this._shader.destroy(), this._shader = null;
  }
  setDefine(e, t) {
    this.shader.setDefine(e, t);
  }
  setTexture(e, t) {
    this._shader.setTexture(e, t);
  }
  setStorageBuffer(e, t) {
    this._shader.setStorageBuffer(e, t);
  }
  setUniformBuffer(e, t) {
    this._shader.setStorageBuffer(e, t);
  }
  setUniformFloat(e, t) {
    this._shader.setUniformFloat(e, t);
  }
  setUniformVector2(e, t) {
    this._shader.setUniformVector2(e, t);
  }
  setUniformVector3(e, t) {
    this._shader.setUniformVector3(e, t);
  }
  setUniformVector4(e, t) {
    this._shader.setUniformVector4(e, t);
  }
  setUniformColor(e, t) {
    this._shader.setUniformColor(e, t);
  }
  getUniformFloat(e) {
    return this._shader.getUniform(e).data;
  }
  getUniformV2(e) {
    return this._shader.getUniformVector2(e);
  }
  getUniformV3(e) {
    return this._shader.getUniformVector3(e);
  }
  getUniformV4(e) {
    return this._shader.getUniformVector4(e);
  }
  getUniformColor(e) {
    return this._shader.getUniformColor(e);
  }
  getTexture(e) {
    return this._shader.getTexture(e);
  }
  getStorageBuffer(e) {
    return this._shader.getStorageBuffer(e);
  }
  getStructStorageBuffer(e) {
    return this._shader.getStructStorageBuffer(e);
  }
  getUniformBuffer(e) {
    return this._shader.getUniformBuffer(e);
  }
  applyUniform() {
    this._shader.applyUniform();
  }
};
var Qe = class _Qe {
  constructor() {
    __publicField(this, "computes");
    __publicField(this, "passShader");
    this.computes = [], this.passShader = /* @__PURE__ */ new Map();
  }
  addRenderPass(e, t = -1) {
    let r = this.passShader.get(e.passType) || [];
    t == -1 ? r.push(e) : r.splice(t, -1, e), this.passShader.set(e.passType, r);
  }
  removeShader(e, t = -1) {
    let r = this.passShader.get(e.passType);
    if (r)
      if (t == -1) {
        let i = r.indexOf(e);
        i != -1 && r.splice(i);
      } else
        r.splice(t, 1);
  }
  removeShaderByIndex(e, t = -1) {
    let r = this.passShader.get(e);
    r && (t == -1 ? this.passShader.delete(e) : r.splice(t, 1));
  }
  getSubShaders(e) {
    return this.passShader.get(e) || [];
  }
  hasSubShaders(e) {
    return this.passShader.get(e).length > 0;
  }
  getDefaultShaders() {
    return this.passShader.get(q.COLOR);
  }
  getDefaultColorShader() {
    return this.passShader.get(q.COLOR)[0];
  }
  setDefine(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setDefine(e, t);
  }
  deleteDefine(e) {
    for (const t of this.passShader)
      for (const r of t[1])
        r.deleteDefine(e);
  }
  setUniform(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniform(e, t);
  }
  setUniformFloat(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformFloat(e, t);
  }
  setUniformVector2(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformVector2(e, t);
  }
  setUniformVector3(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformVector3(e, t);
  }
  setUniformVector4(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformVector4(e, t);
  }
  setUniformColor(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformColor(e, t);
  }
  getUniform(e) {
    return this.getDefaultColorShader().getUniform(e);
  }
  getUniformFloat(e) {
    return this.getDefaultColorShader().getUniformFloat(e);
  }
  getUniformVector2(e) {
    return this.getDefaultColorShader().getUniformVector2(e);
  }
  getUniformVector3(e) {
    return this.getDefaultColorShader().getUniformVector3(e);
  }
  getUniformVector4(e) {
    return this.getDefaultColorShader().getUniformVector4(e);
  }
  getUniformColor(e) {
    return this.getDefaultColorShader().getUniformColor(e);
  }
  setTexture(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setTexture(e, t);
    this.setDefine(`USE_${e.toLocaleUpperCase()}`, true);
  }
  getTexture(e) {
    return this.getDefaultColorShader().textures[e];
  }
  setUniformBuffer(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setUniformBuffer(e, t);
  }
  getUniformBuffer(e) {
    return this.getDefaultColorShader().getBuffer(e);
  }
  setStorageBuffer(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setStorageBuffer(e, t);
  }
  getStorageBuffer(e) {
    return this.getDefaultColorShader().getBuffer(e);
  }
  setStructStorageBuffer(e, t) {
    for (const r of this.passShader)
      for (const i of r[1])
        i.setStructStorageBuffer(e, t);
  }
  getStructStorageBuffer(e) {
    return this.getDefaultColorShader().getBuffer(e);
  }
  noticeValueChange() {
    for (const e of this.passShader)
      for (const t of e[1])
        t.noticeValueChange();
  }
  destroy() {
    this.getDefaultColorShader().destroy();
  }
  clone() {
    let e = new _Qe(), t = this.getDefaultShaders();
    for (const r of t)
      e.addRenderPass(r);
    return e;
  }
  applyUniform() {
    for (const e of this.passShader)
      for (const t of e[1])
        t.applyUniform();
  }
};
var Rd = Object.defineProperty;
var Ud = Object.getOwnPropertyDescriptor;
var Ld = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Ud(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Rd(e, t, i), i;
};
var va = class extends Qe {
  constructor(s = "QuadGlsl_vs", e = "QuadGlsl_fs") {
    super();
    let t = new ve(s, e);
    this.addRenderPass(t);
    let r = t.shaderState;
    t.blendMode = re.NONE, r.frontFace = "cw", r.depthWriteEnabled = false, r.depthCompare = kt.always, r.multisample = 0, this.setTexture("baseMap", p.res.blackTexture), this.setUniformFloat("x", 0), this.setUniformFloat("y", 0), this.setUniformFloat("width", 100), this.setUniformFloat("height", 100);
  }
};
va = Ld([Kt], va);
var xa = class extends Y {
  constructor(e = "QuadGlsl_vs", t = "QuadGlsl_fs", r, i = 0, a = false) {
    super();
    __publicField(this, "width", 128);
    __publicField(this, "height", 128);
    __publicField(this, "quadRenderer");
    __publicField(this, "material");
    __publicField(this, "rendererPassState");
    __publicField(this, "quadShader");
    let o = r ? r.renderTargets : [];
    this.material = new je(), this.quadShader = new va(e, t), this.material.shader = this.quadShader, this.quadRenderer = this.addComponent(J), this.quadRenderer.material = this.material, this.quadRenderer.castGI = false, this.quadRenderer.castShadow = false, this.quadRenderer.drawType = a ? 2 : 0, this.quadRenderer.geometry = new Kl(100, 100, 1, 1), this.quadRenderer.material = this.material, this.quadRenderer.__start(), this.quadRenderer._enable = true, this.quadRenderer.onEnable(), this.rendererPassState = ye.createRendererPassState(r, "load"), i > 0 && (this.rendererPassState.multisample = this.quadShader.getDefaultColorShader().shaderState.multisample, this.rendererPassState.multiTexture = w.device.createTexture({ size: { width: w.presentationSize[0], height: w.presentationSize[1] }, sampleCount: i, format: o.length > 0 ? o[0].format : w.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT })), w.addEventListener(br.RESIZE, (n) => {
      this.rendererPassState = ye.createRendererPassState(r, "load"), i > 0 && (this.rendererPassState.multisample = this.quadShader.getDefaultColorShader().shaderState.multisample, this.rendererPassState.multiTexture = w.device.createTexture({ size: { width: w.presentationSize[0], height: w.presentationSize[1] }, sampleCount: i, format: o.length > 0 ? o[0].format : w.presentationFormat, usage: GPUTextureUsage.RENDER_ATTACHMENT }));
    }, this);
  }
  renderTarget(e, t, r) {
    let i = e.camera, a = y.beginRenderPass(r, t.rendererPassState);
    y.bindCamera(a, i), t.quadRenderer.nodeUpdate(e, q.COLOR, t.rendererPassState, null), t.quadRenderer.renderPass2(e, q.COLOR, t.rendererPassState, null, a), y.endPass(a);
  }
  renderToViewQuad(e, t, r, i) {
    let a = e.camera;
    t.quadShader.setTexture("baseMap", i);
    let o = y.beginRenderPass(r, t.rendererPassState);
    y.bindCamera(o, a), t.quadRenderer.nodeUpdate(e, q.COLOR, t.rendererPassState, null), t.quadRenderer.renderPass2(e, q.COLOR, t.rendererPassState, null, o), y.endPass(o);
  }
};
var fe = class {
  constructor() {
    __publicField(this, "storeOp", "store");
    __publicField(this, "loadOp", "clear");
    __publicField(this, "clearValue", [0, 0, 0, 0]);
  }
};
var Ne = class _Ne {
  constructor(e, t, r, i, a = true) {
    __publicField(this, "label");
    __publicField(this, "customSize", false);
    __publicField(this, "renderTargets");
    __publicField(this, "rtDescriptors");
    __publicField(this, "zPreTexture");
    __publicField(this, "depthTexture");
    __publicField(this, "depthViewIndex", 0);
    __publicField(this, "depthCleanValue", 1);
    __publicField(this, "depthLoadOp", "clear");
    __publicField(this, "isOutTarget", true);
    this.renderTargets = e, this.rtDescriptors = t, this.depthTexture = r, this.zPreTexture = i, this.isOutTarget = a;
  }
  clone2Frame(e) {
    e.renderTargets.push(...this.renderTargets.concat());
    for (let t = 0; t < this.rtDescriptors.length; t++) {
      const r = this.rtDescriptors[t];
      let i = new fe();
      i.loadOp = r.loadOp, i.storeOp = r.storeOp, i.clearValue = r.clearValue, e.rtDescriptors.push(i);
    }
    e.depthTexture = this.depthTexture, e.zPreTexture = this.zPreTexture, e.customSize = this.customSize;
  }
  clone() {
    let e = new _Ne([], []);
    return this.clone2Frame(e), e;
  }
};
var it = class _it extends Re {
  constructor(e, t, r = N.rgba8unorm, i = false, a, o = 1, n = 0, l = true, h = true) {
    super(e, t, o);
    __publicField(this, "resolveTarget");
    __publicField(this, "sampleCount");
    __publicField(this, "autoResize");
    __publicField(this, "clear");
    this.name = gt(), this.autoResize = h, this.useMipmap = i, this.sampleCount = n, this.format = r, this.numberLayer = o, this.clear = l, a != null ? this.usage = a : this.usage = a | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST, this.resize(e, t), h && w.addEventListener(br.RESIZE, (u) => {
      let { width: c, height: f } = u.data;
      this.resize(c, f), this._textureChange = true;
    }, this);
  }
  resize(e, t) {
    let r = w.device;
    this.gpuTexture && (Re.delayDestroyTexture(this.gpuTexture), this.gpuTexture = null, this.view = null), this.width = e, this.height = t, this.createTextureDescriptor(e, t, 1, this.format, this.usage, this.numberLayer, this.sampleCount), this.useMipmap = false, this.visibility = GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, this.format == N.rgba32float ? (this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float", this.gpuSampler = r.createSampler({})) : this.format == N.depth32float ? (this.samplerBindingLayout.type = "filtering", this.sampler_comparisonBindingLayout.type = "comparison", this.textureBindingLayout.sampleType = "depth", this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" })) : this.format == N.depth24plus ? (this.samplerBindingLayout = { type: "filtering" }, this.sampler_comparisonBindingLayout = { type: "comparison" }, this.textureBindingLayout.sampleType = "depth", this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" })) : (this.samplerBindingLayout.type = "filtering", this.textureBindingLayout.sampleType = "float", this.sampleCount > 0 && (this.textureBindingLayout.multisampled = true), this.minFilter = "linear", this.magFilter = "linear", this.mipmapFilter = "linear", this.maxAnisotropy = 16, this.addressModeU = ct.clamp_to_edge, this.addressModeV = ct.clamp_to_edge, this.gpuSampler = r.createSampler(this)), this._textureChange = true;
  }
  create(e, t, r = true) {
    let i = w.device;
    const a = e * 4;
    let o = new Float32Array(e * t * 4);
    const n = i.createBuffer({ size: o.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    i.queue.writeBuffer(n, 0, o);
    const l = y.beginCommandEncoder();
    l.copyBufferToTexture({ buffer: n, bytesPerRow: a }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(l);
  }
  clone() {
    let e = new _it(this.width, this.height, this.format, this.useMipmap, this.usage, this.numberLayer, this.sampleCount, this.clear, this.autoResize);
    return e.name = "clone_" + e.name, e;
  }
  readTextureToImage() {
    let e = w.device, t = w.windowWidth, r = w.windowHeight, i = new Float32Array(t * r * 4);
    const a = e.createBuffer({ size: i.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    return y.beginCommandEncoder().copyTextureToBuffer({ texture: this.getGPUTexture() }, { buffer: a }, [t, r]), a.getMappedRange(0, i.byteLength);
  }
};
var _be = class _be {
  static init() {
    this.rtTextureMap = /* @__PURE__ */ new Map(), this.rtViewQuad = /* @__PURE__ */ new Map();
  }
  static createRTTexture(e, t, r, i, a = false, o = 0) {
    let n = this.rtTextureMap.get(e);
    return n || (e == Fe.colorBufferTex_NAME ? n = new it(t, r, i, a, void 0, 1, o, false) : n = new it(t, r, i, a, void 0, 1, o, true), n.name = e, _be.rtTextureMap.set(e, n)), n;
  }
  static createRTTextureArray(e, t, r, i, a = 1, o = false, n = 0) {
    let l = this.rtTextureMap.get(e);
    return l || (l = new it(t, r, i, o, void 0, a, n), l.name = e, _be.rtTextureMap.set(e, l)), l;
  }
  static createViewQuad(e, t, r, i, a = 0) {
    let o = new Ne([i], [new fe()]), n = new xa(t, r, o, a);
    return _be.rtViewQuad.set(e, n), n;
  }
  static getTexture(e) {
    return this.rtTextureMap.get(e);
  }
  static CreateSplitTexture(e) {
    let t = this.getTexture(Fe.colorBufferTex_NAME), r = this.getTexture(e + "_split");
    return r || (r = this.createRTTexture(e + "_split", t.width, t.height, t.format, false)), r;
  }
  static WriteSplitColorTexture(e) {
    let t = this.getTexture(Fe.colorBufferTex_NAME), r = this.getTexture(e + "_split");
    const i = y.beginCommandEncoder();
    i.copyTextureToTexture({ texture: t.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: r.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { width: r.width, height: r.height, depthOrArrayLayers: 1 }), y.endCommandEncoder(i);
  }
};
__publicField(_be, "rtTextureMap");
__publicField(_be, "rtViewQuad");
var be = _be;
var Jl = class {
  constructor(e) {
    __publicField(this, "command");
    __publicField(this, "encoder");
    __publicField(this, "rendererPassStates");
    __publicField(this, "rtFrame");
    this.rtFrame = e, this.rendererPassStates = [];
  }
  clean() {
    this.rendererPassStates.length = 0, y.cleanCache();
  }
  beginContinueRendererPassState(e = "load", t = "load") {
    if (this.rendererPassStates.length > 0) {
      let r = this.rtFrame.clone();
      for (const a of r.rtDescriptors)
        a.loadOp = "load";
      r.depthLoadOp = t;
      let i = ye.createRendererPassState(r, e);
      return this.rendererPassStates.push(i), i;
    } else {
      this.rtFrame.depthLoadOp = t;
      let r = ye.createRendererPassState(this.rtFrame, e);
      return this.rendererPassStates.push(r), r;
    }
  }
  get rendererPassState() {
    return this.rendererPassStates[this.rendererPassStates.length - 1];
  }
  beginOpaqueRenderPass() {
    this.beginContinueRendererPassState("clear", "clear"), this.begineNewCommand(), this.beginNewEncoder();
  }
  beginTransparentRenderPass() {
    this.beginContinueRendererPassState("load", "load"), this.begineNewCommand(), this.beginNewEncoder();
  }
  endRenderPass() {
    this.endEncoder(), this.endCommand();
  }
  begineNewCommand() {
    return this.command = y.beginCommandEncoder(), this.command;
  }
  endCommand() {
    y.endCommandEncoder(this.command), this.command = null;
  }
  beginNewEncoder() {
    return this.encoder = y.beginRenderPass(this.command, this.rendererPassState), this.encoder;
  }
  endEncoder() {
    y.endPass(this.encoder), this.encoder = null;
  }
};
var mr = class extends qt {
  constructor() {
    super();
    __publicField(this, "rendererPassState");
    __publicField(this, "splitRendererPassState");
    __publicField(this, "useRenderBundle", false);
    __publicField(this, "debugViewQuads");
    __publicField(this, "debugTextures");
    __publicField(this, "renderContext");
    __publicField(this, "_rendererType");
    __publicField(this, "_rtFrame");
    this.debugTextures = [], this.debugViewQuads = [];
  }
  get passType() {
    return this._rendererType;
  }
  set passType(e) {
    this._rendererType = e;
  }
  setRenderStates(e) {
    if (this._rtFrame = e, e) {
      this.rendererPassState = ye.createRendererPassState(e);
      let t = e.clone();
      t.depthLoadOp = "load";
      for (const r of t.rtDescriptors)
        r.loadOp = "load";
      this.splitRendererPassState = ye.createRendererPassState(t);
    }
    this.renderContext = new Jl(e);
  }
  setIrradiance(e, t) {
    this.rendererPassState.irradianceBuffer = [e, t];
  }
  compute(e, t) {
  }
  render(e, t, r, i = false) {
    y.cleanCache();
    let a = e.camera, o = e.scene;
    this.rendererPassState.camera3D = a;
    let n = z.instance.getRenderNodes(o, a), l = this.renderBundleOp(e, n, t, r), h = i ? [] : this.renderBundleTr(e, n, t, r);
    {
      let u = y.beginCommandEncoder(), c = y.beginRenderPass(u, this.rendererPassState);
      l.length > 0 && c.executeBundles(l), !i && z.instance.sky && (y.bindCamera(c, a), z.instance.sky.renderPass2(e, this._rendererType, this.rendererPassState, r, c)), this.drawRenderNodes(e, c, u, n.opaqueList, t), y.endPass(c), y.endCommandEncoder(u);
    }
    {
      let u = y.beginCommandEncoder(), c = y.beginRenderPass(u, this.rendererPassState);
      h.length > 0 && c.executeBundles(h), i || (y.bindCamera(c, a), this.drawRenderNodes(e, c, u, n.transparentList, t)), y.endPass(c), y.endCommandEncoder(u);
    }
  }
  nodeUpload(e, t, r) {
  }
  occlusionRenderNodeTest(e, t, r) {
    return r ? r.occlusionRenderNodeTest(e) > 0 : true;
  }
  renderOp(e, t, r, i, a) {
  }
  renderTr(e, t, r, i, a) {
  }
  renderBundleOp(e, t, r, i) {
    let a = z.instance.getOpRenderGroup(e.scene);
    if (a) {
      let o = [];
      return a.renderGroup.forEach((n) => {
        if (n.bundleMap.has(this._rendererType))
          o.push(n.bundleMap.get(this._rendererType));
        else {
          let l = y.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);
          this.recordRenderBundleNode(e, l, n.renderNodes, i);
          let h = l.finish();
          n.bundleMap.set(this._rendererType, h), o.push(h);
        }
      }), o;
    }
    return [];
  }
  renderBundleTr(e, t, r, i) {
    let a = z.instance.getTrRenderGroup(e.scene);
    if (a) {
      let o = [];
      return a.renderGroup.forEach((n) => {
        if (n.bundleMap.has(this._rendererType))
          o.push(n.bundleMap.get(this._rendererType));
        else {
          let l = y.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);
          this.recordRenderBundleNode(e, l, n.renderNodes, i);
          let h = l.finish();
          n.bundleMap.set(this._rendererType, h), o.push(h);
        }
      }), o;
    }
    return [];
  }
  recordRenderBundleNode(e, t, r, i) {
    y.bindCamera(t, e.camera), y.bindGeometryBuffer(t, r[0].geometry);
    for (let a = 0; a < r.length; ++a) {
      let o = r[a];
      o.transform.worldMatrix.index, o.transform.enable && o.recordRenderPass2(e, this._rendererType, this.rendererPassState, i, t);
    }
  }
  drawRenderNodes(e, t, r, i, a, o) {
    y.bindCamera(t, e.camera);
    for (let n = p.setting.render.drawOpMin; n < Math.min(i.length, p.setting.render.drawOpMax); ++n) {
      let l = i[n];
      l.transform.enable && l.enable && l.renderPass2(e, this._rendererType, this.rendererPassState, o, t);
    }
  }
  setDebugTexture(e) {
    for (let t = 0; t < e.length; t++) {
      let r = e[t], i = "Quad_vert_wgsl", a = "Quad_frag_wgsl";
      switch (r.format) {
        case N.rgba8sint:
        case N.rgba8uint:
        case N.rgba8unorm:
        case N.rgba16float:
        case N.rgba32float:
          a = "Quad_frag_wgsl";
          break;
        case N.depth24plus:
        case N.depth32float:
          a = "Quad_depth2d_frag_wgsl", r.textureBindingLayout.viewDimension == "cube" && (a = "Quad_depthCube_frag_wgsl");
          break;
      }
      let o = new xa(i, a, new Ne([], []));
      this.debugTextures.push(e[t]), this.debugViewQuads.push(o);
    }
  }
};
var Zl = class extends mr {
  constructor() {
    super(), this.passType = q.COLOR;
  }
  render(e, t, r, i = false) {
    this.renderContext.clean();
    let a = e.scene, o = e.camera;
    this.rendererPassState.camera3D = o;
    let n = z.instance.getRenderNodes(a, o), l = this.renderBundleOp(e, n, t, r), h = i ? [] : this.renderBundleTr(e, n, t, r);
    St.start("colorPass Renderer");
    {
      St.start("ColorPass Draw Opaque"), this.renderContext.beginOpaqueRenderPass(), this.renderContext.command;
      let u = this.renderContext.encoder;
      y.bindCamera(u, o), l.length > 0 && (z.instance.getOpRenderGroup(a), u.executeBundles(l)), !i && z.instance.sky && (y.bindCamera(u, o), z.instance.sky.preInit || z.instance.sky.nodeUpdate(e, this._rendererType, this.rendererPassState, r), z.instance.sky.renderPass2(e, this._rendererType, this.rendererPassState, r, u)), n.opaqueList && (y.bindCamera(u, o), this.drawNodes(e, this.renderContext, n.opaqueList, t, r), this.renderContext.endRenderPass(), St.end("ColorPass Draw Opaque"));
    }
    {
      St.start("ColorPass Draw Transparent"), this.renderContext.beginTransparentRenderPass(), this.renderContext.command;
      let u = this.renderContext.encoder;
      h.length > 0 && u.executeBundles(h), !i && n.transparentList && (y.bindCamera(u, o), this.drawNodes(e, this.renderContext, n.transparentList, t, r));
      let c = z.instance.getGraphicList();
      for (let f = 0; f < c.length; f++) {
        const g = c[f];
        g.transform.worldMatrix.index, g.nodeUpdate(e, this._rendererType, this.splitRendererPassState, r), g.renderPass2(e, this._rendererType, this.splitRendererPassState, r, u);
      }
      this.renderContext.endRenderPass(), St.end("ColorPass Draw Transparent");
    }
    St.end("colorPass Renderer");
  }
  drawNodes(e, t, r, i, a) {
    let o = z.instance.getRenderShaderCollect(e);
    if (o) {
      for (const n of o) {
        let l = n[1];
        for (const h of l) {
          let u = h[1];
          if (u.preInit) {
            u.nodeUpdate(e, this._rendererType, this.rendererPassState, a);
            break;
          }
        }
      }
      for (let n = p.setting.render.drawOpMin; n < Math.min(r.length, p.setting.render.drawOpMax); ++n) {
        let l = r[n];
        l.transform.enable && l.enable && (l.preInit || l.nodeUpdate(e, this._rendererType, this.rendererPassState, a), l.renderPass(e, this.passType, this.renderContext));
      }
    }
  }
  occlusionRenderNodeTest(e, t, r) {
    return r.zDepthRenderNodeTest(t) > 0;
  }
};
var _Ee = class _Ee extends Ne {
  constructor() {
    super([], []);
  }
  crateGBuffer(e, t, r) {
    let i = this.renderTargets, a = this.rtDescriptors, o = be.createRTTexture(e + Fe.colorBufferTex_NAME, t, r, N.rgba16float, false), n = be.createRTTexture(e + Fe.positionBufferTex_NAME, t, r, N.rgba16float, false), l = be.createRTTexture(e + Fe.normalBufferTex_NAME, t, r, N.rgba8unorm, false), h = be.createRTTexture(e + Fe.materialBufferTex_NAME, t, r, N.rgba8unorm, false);
    _Ee.bufferTexture && (i.push(o), i.push(n), i.push(l), i.push(h));
    let u = new fe();
    u.loadOp = "clear";
    let c = new it(t, r, N.depth24plus, false);
    c.name = "depthTexture";
    let f = new fe();
    f.loadOp = "load", this.depthTexture = c, _Ee.bufferTexture && (a.push(u), a.push(new fe()), a.push(new fe()), a.push(new fe()));
  }
  getColorMap() {
    return this.renderTargets[0];
  }
  getPositionMap() {
    return this.renderTargets[1];
  }
  getNormalMap() {
    return this.renderTargets[2];
  }
  getMaterialMap() {
    return this.renderTargets[3];
  }
  static getGBufferFrame(e) {
    let t;
    if (_Ee.gBufferMap.has(e))
      t = _Ee.gBufferMap.get(e);
    else {
      t = new _Ee();
      let r = w.presentationSize;
      t.crateGBuffer(e, r[0], r[1]), _Ee.gBufferMap.set(e, t);
    }
    return t;
  }
  clone() {
    let e = new _Ee();
    return this.clone2Frame(e), e;
  }
};
__publicField(_Ee, "gBufferMap", /* @__PURE__ */ new Map());
__publicField(_Ee, "bufferTexture", false);
var Ee = _Ee;
var js = class {
  constructor() {
    __publicField(this, "frustumCullingList");
    __publicField(this, "zVisibleList");
    __publicField(this, "_renderList");
    this._renderList = /* @__PURE__ */ new Map();
  }
  occlusionRenderNodeTest(e) {
    return p.setting.occlusionQuery.enable ? this.frustumCullingList ? this.frustumCullingList[e] : 0 : 1;
  }
  zDepthRenderNodeTest(e) {
    return this.zVisibleList ? this.zVisibleList[e] : 0;
  }
  update(e, t) {
  }
  collect(e, t) {
  }
  renderCommitTesting(e, t) {
    return true;
  }
};
__publicField(js, "enable", true);
var Kr = class extends Jt {
  constructor(e, t) {
    super(), this.bufferType = Tt.ComputeGPUBuffer, this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST, e, t, "ComputeGPUBuffer");
  }
};
var $l = class {
  constructor(e, t) {
    __publicField(this, "clusterBuffer");
    __publicField(this, "lightAssignBuffer");
    __publicField(this, "assignTableBuffer");
    __publicField(this, "clustersUniformBuffer");
    this.clusterBuffer = new Kr(e * 2 * 4), this.clustersUniformBuffer = new ft(10), this.clustersUniformBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, this.lightAssignBuffer = new Kr(e * t), this.lightAssignBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, this.assignTableBuffer = new Kr(e * 4), this.assignTableBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
  }
  update(e, t, r, i, a, o, n, l, h, u) {
    this.clustersUniformBuffer.setFloat("clusterTileX", i), this.clustersUniformBuffer.setFloat("clusterTileY", a), this.clustersUniformBuffer.setFloat("clusterTileZ", o), this.clustersUniformBuffer.setFloat("numLights", n), this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster", l), this.clustersUniformBuffer.setFloat("near", h), this.clustersUniformBuffer.setFloat("far", u), this.clustersUniformBuffer.setFloat("screenWidth", e), this.clustersUniformBuffer.setFloat("screenHeight", t), this.clustersUniformBuffer.setFloat("clusterPix", r), this.clustersUniformBuffer.apply();
  }
};
var We = class {
};
__publicField(We, "clusterTileX", 16);
__publicField(We, "clusterTileY", 16);
__publicField(We, "clusterTileZ", 32);
var eh = `
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${We.clusterTileX},${We.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`;
var th = `
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${We.clusterTileX},${We.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;
var rh = class extends mr {
  constructor(e) {
    super();
    __publicField(this, "maxNumLightsPerCluster", 64);
    __publicField(this, "clusterPix", 1);
    __publicField(this, "clusterLightingBuffer");
    __publicField(this, "_currentLightCount", 0);
    __publicField(this, "_clusterGenerateCompute");
    __publicField(this, "_clusterLightingCompute");
    __publicField(this, "_useCamera");
    __publicField(this, "resize", false);
    this.passType = q.Cluster, this.initCompute(e);
  }
  initCompute(e) {
    this._clusterGenerateCompute = new ae(eh), this._clusterLightingCompute = new ae(th);
    let t = w.presentationSize, r = We.clusterTileX * We.clusterTileY * We.clusterTileZ, i = e.camera, a = i.near, o = i.far;
    this.clusterLightingBuffer = new $l(r, this.maxNumLightsPerCluster), this.clusterLightingBuffer.update(t[0], t[1], this.clusterPix, We.clusterTileX, We.clusterTileY, We.clusterTileZ, 0, this.maxNumLightsPerCluster, a, o), this._clusterGenerateCompute.setUniformBuffer("clustersUniform", this.clusterLightingBuffer.clustersUniformBuffer), this._clusterGenerateCompute.setStorageBuffer("clusterBuffer", this.clusterLightingBuffer.clusterBuffer);
    let n = oe.getLightEntries(e.scene);
    this._clusterLightingCompute.setStorageBuffer("models", oe.modelMatrixBindGroup.matrixBufferDst), this._clusterLightingCompute.setUniformBuffer("clustersUniform", this.clusterLightingBuffer.clustersUniformBuffer), this._clusterLightingCompute.setStorageBuffer("clusterBuffer", this.clusterLightingBuffer.clusterBuffer), this._clusterLightingCompute.setStorageBuffer("lightBuffer", n.storageGPUBuffer), this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer", this.clusterLightingBuffer.lightAssignBuffer), this._clusterLightingCompute.setStorageBuffer("assignTable", this.clusterLightingBuffer.assignTableBuffer), this.resize = true;
  }
  render(e, t) {
    let r = e.scene, i = z.instance.getLights(r);
    if (this._useCamera != e.camera) {
      this._useCamera = e.camera;
      let n = oe.getCameraGroup(this._useCamera);
      this._clusterGenerateCompute.setUniformBuffer("globalUniform", n.uniformGPUBuffer), this._clusterLightingCompute.setUniformBuffer("globalUniform", n.uniformGPUBuffer);
    }
    this._currentLightCount != i.length && (this._currentLightCount = i.length, this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights", i.length), this.clusterLightingBuffer.clustersUniformBuffer.apply(), this._clusterGenerateCompute.workerSizeX = We.clusterTileZ, this._clusterLightingCompute.workerSizeX = We.clusterTileZ);
    let a = w.presentationSize;
    this.clusterLightingBuffer.update(a[0], a[1], this.clusterPix, We.clusterTileX, We.clusterTileY, We.clusterTileZ, i.length, this.maxNumLightsPerCluster, e.camera.near, e.camera.far), this.resize = false;
    let o = y.beginCommandEncoder();
    y.computeCommand(o, [this._clusterGenerateCompute, this._clusterLightingCompute]), y.endCommandEncoder(o);
  }
};
var de = class _de extends Re {
  constructor(e, t, r = N.rgba8unorm, i = false, a, o = 1, n = 0, l = true) {
    super(e, t, o);
    __publicField(this, "resolveTarget");
    __publicField(this, "sampleCount");
    w.device, this.name = gt(), this.useMipmap = i, this.sampleCount = n, this.format = r, this.numberLayer = o, a != null ? this.usage = a : this.usage = a | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST, this.resize(e, t);
  }
  clone() {
    let e = new _de(this.width, this.height, this.format, this.useMipmap, this.usage, this.numberLayer, this.sampleCount);
    return e.name = "clone_" + e.name, e;
  }
  resize(e, t) {
    let r = w.device;
    this.gpuTexture && (Re.delayDestroyTexture(this.gpuTexture), this.gpuTexture = null, this.view = null), this.width = e, this.height = t, this.createTextureDescriptor(e, t, 1, this.format, this.usage, this.numberLayer, this.sampleCount), this.useMipmap = false, this.visibility = GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, this.format == N.rgba32float ? (this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float", this.gpuSampler = r.createSampler({})) : this.format == N.depth32float ? (this.samplerBindingLayout.type = "filtering", this.sampler_comparisonBindingLayout.type = "comparison", this.textureBindingLayout.sampleType = "depth", this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" })) : this.format == N.depth24plus ? (this.samplerBindingLayout = { type: "filtering" }, this.sampler_comparisonBindingLayout = { type: "comparison" }, this.textureBindingLayout.sampleType = "depth", this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" })) : (this.samplerBindingLayout.type = "filtering", this.textureBindingLayout.sampleType = "float", this.sampleCount > 0 && (this.textureBindingLayout.multisampled = true), this.minFilter = "linear", this.magFilter = "linear", this.mipmapFilter = "linear", this.maxAnisotropy = 16, this.addressModeU = ct.clamp_to_edge, this.addressModeV = ct.clamp_to_edge, this.gpuSampler = r.createSampler(this)), this._textureChange = true;
  }
  create(e, t, r = true) {
    let i = w.device;
    const a = e * 4;
    let o = new Float32Array(e * t * 4);
    const n = i.createBuffer({ size: o.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    i.queue.writeBuffer(n, 0, o);
    const l = y.beginCommandEncoder();
    l.copyBufferToTexture({ buffer: n, bytesPerRow: a }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(l);
  }
  readTextureToImage() {
    let e = w.device, t = w.windowWidth, r = w.windowHeight, i = new Float32Array(t * r * 4);
    const a = e.createBuffer({ size: i.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    return y.beginCommandEncoder().copyTextureToBuffer({ texture: this.getGPUTexture() }, { buffer: a }, [t, r]), a.getMappedRange(0, i.byteLength);
  }
};
var ih = class extends Y {
  constructor(e = 1e-3, t = 1e4, r = 90, i = false) {
    super();
    __publicField(this, "up_camera");
    __publicField(this, "down_camera");
    __publicField(this, "left_camera");
    __publicField(this, "right_camera");
    __publicField(this, "front_camera");
    __publicField(this, "back_camera");
    this.initCubeCamera(e, t, r, i);
  }
  set label(e) {
    this.up_camera.name = e + "up", this.down_camera.name = e + "down", this.left_camera.name = e + "left", this.right_camera.name = e + "right", this.front_camera.name = e + "front", this.back_camera.name = e + "back";
  }
  initCubeCamera(e, t, r = 90, i = false) {
    this.up_camera = Me.createCamera3DObject(this, "up"), this.down_camera = Me.createCamera3DObject(this, "down"), this.left_camera = Me.createCamera3DObject(this, "left"), this.right_camera = Me.createCamera3DObject(this, "right"), this.front_camera = Me.createCamera3DObject(this, "front"), this.back_camera = Me.createCamera3DObject(this, "back"), this.up_camera.isShadowCamera = i, this.down_camera.isShadowCamera = i, this.left_camera.isShadowCamera = i, this.right_camera.isShadowCamera = i, this.front_camera.isShadowCamera = i, this.back_camera.isShadowCamera = i;
    let a = 1;
    this.up_camera.perspective(r, a, e, t), this.up_camera.lookAt(d.ZERO, d.UP, d.DOWN), this.up_camera.object3D.scaleX = -1, this.up_camera.object3D.rotationY = 180, this.down_camera.perspective(r, a, e, t), this.down_camera.lookAt(d.ZERO, d.DOWN, d.DOWN), this.down_camera.object3D.scaleX = -1, this.down_camera.object3D.rotationY = 180, this.left_camera.perspective(r, a, e, t), this.left_camera.lookAt(d.ZERO, d.LEFT), this.left_camera.object3D.scaleX = -1, this.right_camera.perspective(r, a, e, t), this.right_camera.lookAt(d.ZERO, d.RIGHT), this.right_camera.object3D.scaleX = -1, this.front_camera.perspective(r, a, e, t), this.front_camera.lookAt(d.ZERO, d.FORWARD), this.front_camera.object3D.scaleX = -1, this.back_camera.perspective(r, a, e, t), this.back_camera.lookAt(d.ZERO, d.BACK), this.back_camera.object3D.scaleX = -1, this.up_camera.type = Ae.shadow, this.down_camera.type = Ae.shadow, this.left_camera.type = Ae.shadow, this.right_camera.type = Ae.shadow, this.front_camera.type = Ae.shadow, this.back_camera.type = Ae.shadow;
  }
};
var ah = class extends Re {
  constructor(e, t, r) {
    super(e, t, r), this.format = N.depth32float, this.mipmapCount = 1, this.init();
  }
  internalCreateBindingLayoutDesc() {
    this.textureBindingLayout.sampleType = "depth", this.textureBindingLayout.viewDimension = "cube-array", this.samplerBindingLayout.type = "filtering", this.sampler_comparisonBindingLayout.type = "comparison";
  }
  internalCreateTexture() {
    this.textureDescriptor = { format: this.format, size: { width: this.width, height: this.height, depthOrArrayLayers: 6 * this.numberLayer }, dimension: "2d", usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING }, this.gpuTexture = this.getGPUTexture();
  }
  internalCreateView() {
    this.viewDescriptor = { dimension: "cube-array" }, this.view = this.getGPUView();
  }
  internalCreateSampler() {
    this.gpuSampler = w.device.createSampler({ minFilter: Gt.linear, magFilter: Gt.linear }), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" });
  }
};
var sh = class extends mr {
  constructor() {
    super();
    __publicField(this, "shadowPassCount");
    __publicField(this, "_forceUpdate", false);
    __publicField(this, "_shadowCameraDic");
    __publicField(this, "shadowCamera");
    __publicField(this, "cubeArrayTexture");
    __publicField(this, "colorTexture");
    __publicField(this, "shadowSize", 1024);
    this.passType = q.POINT_SHADOW, this._shadowCameraDic = /* @__PURE__ */ new Map(), this.cubeArrayTexture = new ah(this.shadowSize, this.shadowSize, 8), this.colorTexture = new de(this.shadowSize, this.shadowSize, N.bgra8unorm, false), ie.getInstance().attached(this.cubeArrayTexture, this);
  }
  getShadowCamera(e, t) {
    var _a3;
    let r;
    if (this._shadowCameraDic.has(t))
      r = this._shadowCameraDic.get(t);
    else {
      let i = new ih(e.camera.near, e.camera.far, 90, true);
      i.label = t.name;
      let a = [], o = [];
      for (let n = 0; n < 6; n++) {
        let l = new de(this.shadowSize, this.shadowSize, this.cubeArrayTexture.format, false), h = new Ne([this.colorTexture], [new fe()]);
        l.name = "shadowDepthTexture_" + t.name + n + "_face", h.depthTexture = l, h.label = "shadowRender", h.customSize = true;
        let u = ye.createRendererPassState(h);
        o[n] = u, a[n] = l, (_a3 = p.getRenderJob(e).postRenderer) == null ? void 0 : _a3.setDebugTexture([l]);
      }
      r = { cubeCamera: i, depthTexture: a, rendererPassState: o }, this._shadowCameraDic.set(t, r);
    }
    return r;
  }
  render(e, t) {
    if (!p.setting.shadow.enable)
      return;
    this.shadowPassCount = 0, e.camera;
    let r = e.scene, i = lt.getPointShadowLightWhichScene(r), a = i.length;
    for (let o = 0; o < a; o++) {
      let n = i[o];
      if (n.lightData.lightType != Pe.DirectionLight && n.lightData.castShadowIndex > -1 && (n.needUpdateShadow || this._forceUpdate || ce.frame < 5 || n.realTimeShadow)) {
        n.needUpdateShadow = false;
        let l = this.getShadowCamera(e, n), h = n.transform.worldPosition;
        l.cubeCamera.x = h.x, l.cubeCamera.y = h.y, l.cubeCamera.z = h.z;
        let u;
        l.cubeCamera.transform.updateWorldMatrix(true), t.update(l.cubeCamera.right_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.right_camera), this.renderSceneOnce(0, l, e, l.cubeCamera.right_camera, u, t), t.update(l.cubeCamera.left_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.left_camera), this.renderSceneOnce(1, l, e, l.cubeCamera.left_camera, u, t), t.update(l.cubeCamera.up_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.up_camera), this.renderSceneOnce(2, l, e, l.cubeCamera.up_camera, u, t), t.update(l.cubeCamera.down_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.down_camera), this.renderSceneOnce(3, l, e, l.cubeCamera.down_camera, u, t), t.update(l.cubeCamera.front_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.front_camera), this.renderSceneOnce(4, l, e, l.cubeCamera.front_camera, u, t), t.update(l.cubeCamera.back_camera, r), u = z.instance.getRenderNodes(r, l.cubeCamera.back_camera), this.renderSceneOnce(5, l, e, l.cubeCamera.back_camera, u, t);
        let c = y.beginCommandEncoder();
        for (let f = 0; f < 6; f++)
          c.copyTextureToTexture({ texture: l.depthTexture[f].getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: this.cubeArrayTexture.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: n.shadowIndex * 6 + f } }, { width: this.shadowSize, height: this.shadowSize, depthOrArrayLayers: 1 });
        y.endCommandEncoder(c);
      }
    }
    this._forceUpdate = false;
  }
  renderSceneOnce(e, t, r, i, a, o) {
    this.rendererPassState = t.rendererPassState[e];
    let n = y.beginCommandEncoder(), l = y.beginRenderPass(n, this.rendererPassState);
    l.setViewport(0, 0, this.shadowSize, this.shadowSize, 0, 1), l.setScissorRect(0, 0, this.shadowSize, this.shadowSize), i.onUpdate(), i.transform.updateWorldMatrix(true);
    let h = z.instance.getRenderShaderCollect(r);
    for (const u of h) {
      let c = u[1];
      for (const f of c) {
        let g = f[1];
        if (g.preInit) {
          g.nodeUpdate(r, this._rendererType, this.rendererPassState, null);
          break;
        }
      }
    }
    this.drawShadowRenderNodes(r, i, l, a.opaqueList, o), this.drawShadowRenderNodes(r, i, l, a.transparentList, o), y.endPass(l), y.endCommandEncoder(n);
  }
  drawShadowRenderNodes(e, t, r, i, a) {
    if (y.bindCamera(r, t), i)
      for (let o = p.setting.render.drawOpMin; o < Math.min(i.length, p.setting.render.drawOpMax); ++o) {
        let n = i[o];
        if (n.transform.worldMatrix.index, !!n.transform.enable && n.enable) {
          n.preInit || n.nodeUpdate(e, this._rendererType, this.rendererPassState);
          for (let l of n.materials) {
            let h = l.getPass(this._rendererType);
            if (!h || h.length == 0)
              continue;
            y.bindGeometryBuffer(r, n.geometry);
            let u = n.object3D.transform._worldMatrix;
            for (let c of h) {
              const f = c;
              if (f.pipeline) {
                f.setUniformFloat("cameraFar", t.far), f.setUniformVector3("lightWorldPos", t.transform.worldPosition), f.materialDataUniformBuffer.apply(), y.bindPipeline(r, f);
                let g = n.geometry.subGeometries;
                for (const m of g) {
                  let _ = m.lodLevels[n.lodLevel];
                  y.drawIndexed(r, _.indexCount, 1, _.indexStart, 0, u.index);
                }
              }
            }
          }
        }
      }
  }
};
var oh = class extends Re {
  constructor(e, t, r = N.depth32float, i = 4) {
    super(e, t, i), this.format = r, this.mipmapCount = 1, this.init();
  }
  internalCreateBindingLayoutDesc() {
    this.textureBindingLayout.sampleType = "depth", this.textureBindingLayout.viewDimension = "2d-array", this.samplerBindingLayout.type = "filtering", this.sampler_comparisonBindingLayout.type = "comparison";
  }
  internalCreateTexture() {
    this.textureDescriptor = { format: this.format, size: { width: this.width, height: this.height, depthOrArrayLayers: this.numberLayer }, dimension: "2d", usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING }, this.gpuTexture = this.getGPUTexture();
  }
  internalCreateView() {
    this.viewDescriptor = { dimension: "2d-array" }, this.view = this.getGPUView();
  }
  internalCreateSampler() {
    this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" });
  }
};
var nh = class extends mr {
  constructor() {
    super();
    __publicField(this, "shadowPassCount");
    __publicField(this, "depth2DArrayTexture");
    __publicField(this, "rendererPassStates");
    __publicField(this, "_forceUpdate", false);
    __publicField(this, "_shadowPos", new d());
    __publicField(this, "_shadowCameraTarget", new d());
    this.setShadowMap(p.setting.shadow.shadowSize, Ct.Cascades), this.passType = q.SHADOW;
  }
  setShadowMap(e, t) {
    this.rendererPassStates = [], this.depth2DArrayTexture = new oh(e, e, N.depth32float, 8), ie.getInstance().attached(this.depth2DArrayTexture, this);
    for (let r = 0; r < 8; r++) {
      let i = new Ne([], []);
      const a = new de(e, e, N.depth32float, false);
      a.name = `shadowDepthTexture_${r}`, i.depthTexture = a, i.label = "shadowRender", i.customSize = true, i.depthCleanValue = 1;
      let o = ye.createRendererPassState(i);
      this.rendererPassStates[r] = o;
    }
  }
  render(e, t) {
    let r = p.setting.shadow;
    if (!r.enable)
      return;
    let i = e.camera, a = e.scene;
    if (this.shadowPassCount = 0, !r.needUpdate || ce.frame % r.updateFrameRate != 0)
      return;
    let o = lt.getDirectShadowLightWhichScene(a), n = r.shadowSize;
    const l = Ct.Cascades;
    for (let h of o) {
      const u = h;
      let c = u.shadowIndex;
      this.rendererPassState = this.rendererPassStates[c], n = this.rendererPassState.depthTexture.width;
      let f = z.instance.getRenderShaderCollect(e);
      for (const g of f) {
        let m = g[1];
        for (const A of m) {
          let _ = A[1];
          if (_.preInit) {
            _.nodeUpdate(e, this._rendererType, this.rendererPassState, null);
            break;
          }
        }
      }
      if (u.castShadow && u.needUpdateShadow || this._forceUpdate || u.castShadow && r.autoUpdate)
        if (u.needUpdateShadow = false, i.enableCSM && c == 0)
          for (let g = 0; g < l; g++) {
            this.rendererPassState = this.rendererPassStates[g];
            let m = i.csm.children[g], A = i.getCSMShadowWorldExtents(g);
            this.poseShadowCamera(i, u.direction, m.shadowCamera, A, m.bound.center), this.renderShadow(e, m.shadowCamera, t, this.rendererPassState), this.copyDepthTexture(this.rendererPassState.depthTexture, this.depth2DArrayTexture, g, n);
          }
        else {
          i.enableCSM && (c += l - 1);
          let g = i.getShadowWorldExtents();
          this.rendererPassState = this.rendererPassStates[c], this.poseShadowCamera(i, u.direction, u.shadowCamera, g, i.lookTarget), this.renderShadow(e, u.shadowCamera, t, this.rendererPassState), this.copyDepthTexture(this.rendererPassState.depthTexture, this.depth2DArrayTexture, c, n);
        }
    }
    this._forceUpdate = false;
  }
  copyDepthTexture(e, t, r, i) {
    let a = y.beginCommandEncoder();
    a.copyTextureToTexture({ texture: e.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: t.getGPUTexture(), mipLevel: 0, origin: { x: 0, y: 0, z: r } }, { width: i, height: i, depthOrArrayLayers: 1 }), y.endCommandEncoder(a);
  }
  poseShadowCamera(e, t, r, i, a) {
    this._shadowPos.copy(t).normalize(e.far), a.add(this._shadowPos, this._shadowCameraTarget), a.subtract(this._shadowPos, this._shadowPos), r.transform.lookAt(this._shadowPos, this._shadowCameraTarget), r.orthoOffCenter(-i, i, -i, i, e.near, e.far * 2);
  }
  compute() {
  }
  renderShadow(e, t, r, i) {
    let a = z.instance.getRenderNodes(e.scene, t), o = y.beginCommandEncoder(), n = y.beginRenderPass(o, i);
    t.transform.updateWorldMatrix(), js.enable && (r.update(t, e.scene), r.collect(a, t)), y.bindCamera(n, t);
    let l = this.renderShadowBundleOp(e, t, i), h = this.renderShadowBundleTr(e, t, i);
    l.length > 0 && n.executeBundles(l), this.drawShadowRenderNodes(e, t, n, a.opaqueList), h.length > 0 && n.executeBundles(h), this.drawShadowRenderNodes(e, t, n, a.transparentList), y.endPass(n), y.endCommandEncoder(o);
  }
  renderShadowBundleOp(e, t, r) {
    let i = z.instance.getOpRenderGroup(e.scene);
    if (i) {
      let a = [];
      return i.renderGroup.forEach((o) => {
        if (o.bundleMap.has(this._rendererType))
          a.push(o.bundleMap.get(this._rendererType));
        else {
          let n = y.recordBundleEncoder(r.renderBundleEncoderDescriptor);
          this.recordShadowRenderBundleNode(e, t, n, o.renderNodes);
          let l = n.finish();
          o.bundleMap.set(this._rendererType, l), a.push(l);
        }
      }), a;
    }
    return [];
  }
  renderShadowBundleTr(e, t, r) {
    let i = z.instance.getTrRenderGroup(e.scene);
    if (i) {
      let a = [];
      return i.renderGroup.forEach((o) => {
        if (o.bundleMap.has(this._rendererType))
          a.push(o.bundleMap.get(this._rendererType));
        else {
          let n = y.recordBundleEncoder(r.renderBundleEncoderDescriptor);
          this.recordShadowRenderBundleNode(e, t, n, o.renderNodes);
          let l = n.finish();
          o.bundleMap.set(this._rendererType, l), a.push(l);
        }
      }), a;
    }
    return [];
  }
  recordShadowRenderBundleNode(e, t, r, i, a) {
    if (y.bindCamera(r, t), i) {
      y.bindGeometryBuffer(r, i[0].geometry);
      for (let o = 0; o < i.length; ++o) {
        let n = i[o];
        n.transform.enable && n.recordRenderPass2(e, this._rendererType, this.rendererPassState, a, r);
      }
    }
  }
  drawShadowRenderNodes(e, t, r, i, a) {
    if (y.bindCamera(r, t), i)
      for (let o = p.setting.render.drawOpMin; o < Math.min(i.length, p.setting.render.drawOpMax); ++o) {
        let n = i[o];
        n.transform.enable && n.enable && n.castShadow && n.renderPass2(e, this._rendererType, this.rendererPassState, a, r);
      }
  }
};
var lh = class extends mr {
  constructor() {
    super();
    __publicField(this, "zBufferTexture");
    __publicField(this, "useRenderBundle", false);
    __publicField(this, "shadowPassCount");
    __publicField(this, "zCullingCompute");
    this.passType = q.DEPTH;
    let e = w.presentationSize, t = 1;
    this.zBufferTexture = be.createRTTexture(Fe.zBufferTexture_NAME, Math.floor(e[0] * t), Math.floor(e[1] * t), N.rgba16float, false);
    let r = new fe();
    r.clearValue = [0, 0, 0, 0], r.loadOp = "clear";
    let i = new Ne([], [], be.createRTTexture(Fe.zPreDepthTexture_NAME, Math.floor(e[0]), Math.floor(e[1]), N.depth32float, false), null, false);
    this.setRenderStates(i);
  }
  render(e, t) {
    let r = e.camera, i = e.scene;
    y.cleanCache(), St.start("DepthPass Renderer");
    let a = i;
    this.rendererPassState.camera3D = r;
    let o = z.instance.getRenderNodes(a, r);
    this.compute(e, t);
    let n = this.renderBundleOp(e, o, t), l = [], h = y.beginCommandEncoder(), u = y.beginRenderPass(h, this.rendererPassState);
    n.length > 0 && u.executeBundles(n);
    let c = z.instance.getRenderShaderCollect(e);
    for (const f of c) {
      let g = f[1];
      for (const m of g) {
        let A = m[1];
        if (A.preInit) {
          A.nodeUpdate(e, this._rendererType, this.rendererPassState, null);
          break;
        }
      }
    }
    this.drawRenderNodes(e, u, h, o.opaqueList, t), l.length > 0 && u.executeBundles(l), y.endPass(u), y.endCommandEncoder(h), St.end("DepthPass Renderer");
  }
  drawRenderNodes(e, t, r, i, a, o) {
    y.bindCamera(t, e.camera);
    for (let n = p.setting.render.drawOpMin; n < Math.min(i.length, p.setting.render.drawOpMax); ++n) {
      let l = i[n];
      l.transform.enable && l.enable && (l.preInit || l.nodeUpdate(e, this._rendererType, this.rendererPassState), l.renderPass2(e, this._rendererType, this.rendererPassState, o, t));
    }
  }
};
var hh = class {
  constructor() {
    __publicField(this, "map");
    __publicField(this, "passRendererList");
    this.map = /* @__PURE__ */ new Map(), this.passRendererList = [];
  }
  addRenderer(e) {
    this.map.has(e.passType) ? console.error("same renderer pass repeat!") : (this.map.set(e.passType, e), e.passType <= 8 && this.addPassRenderer(e));
  }
  getRenderer(e) {
    return this.map.get(e);
  }
  addPassRenderer(e) {
    this.passRendererList.push(e);
  }
  getAllRenderer() {
    return this.map;
  }
  getAllPassRenderer() {
    return this.passRendererList;
  }
};
var uh = class extends mr {
  constructor() {
    super();
    __publicField(this, "finalQuadView");
    __publicField(this, "postList");
    this._rendererType = q.POST, this.postList = [], this.initRenderer();
  }
  initRenderer() {
    O.register("FullQuad_vert_wgsl", Mn), this.finalQuadView = new xa("Quad_vert_wgsl", "Quad_frag_wgsl", new Ne([], []), 0, false);
  }
  attachPost(e, t) {
    t.postRenderer = this, this.postList.indexOf(t) != -1 || (this.postList.push(t), t.onAttach(e));
  }
  detachPost(e, t) {
    let r = this.postList.indexOf(t);
    return r >= 0 && (this.postList.splice(r, 1), t.onDetach(e), t.postRenderer = null), r >= 0;
  }
  render(e) {
    let t = y.beginCommandEncoder();
    for (let i = 0; i < this.postList.length; i++) {
      const a = this.postList[i];
      a.enable && a.render(e, t);
    }
    let r = y.lastRenderPassState.getLastRenderTexture();
    if (this.finalQuadView.renderToViewQuad(e, this.finalQuadView, t, r), this.debugViewQuads.length) {
      let i = p.setting.render.debugQuad;
      i >= 0 && this.debugViewQuads[i].renderToViewQuad(e, this.debugViewQuads[i], t, this.debugTextures[i]);
    }
    y.endCommandEncoder(t);
  }
};
var wt = class {
  constructor() {
    __publicField(this, "enable", true);
    __publicField(this, "postRenderer");
    __publicField(this, "rtViewQuad");
    __publicField(this, "virtualTexture");
    this.rtViewQuad = /* @__PURE__ */ new Map(), this.virtualTexture = /* @__PURE__ */ new Map(), w.addEventListener(br.RESIZE, this.onResize, this);
  }
  createRTTexture(e, t, r, i, a = false, o = 0) {
    let n = be.createRTTexture(e, t, r, i, a, o);
    return n.name = e, this.virtualTexture.set(e, n), ie.getInstance().attached(n, this), n;
  }
  createViewQuad(e, t, r, i = 0) {
    let a = be.createViewQuad(e, "Quad_vert_wgsl", t, r, i);
    return this.rtViewQuad.set(e, a), a;
  }
  getOutTexture() {
    let e, t = y.lastRenderPassState.renderTargets;
    return t.length > 0 ? e = t[0] : e = be.getTexture(Fe.colorBufferTex_NAME), e;
  }
  autoSetColorTexture(e, t) {
    let r = this.getOutTexture();
    t.setSamplerTexture(e, r);
  }
  compute(e) {
  }
  onAttach(e) {
  }
  onDetach(e) {
  }
  onResize() {
  }
  render(e, t) {
    this.compute(e), this.rtViewQuad.forEach((r, i) => {
      let a = y.lastRenderPassState.getLastRenderTexture();
      r.renderToViewQuad(e, r, t, a);
    });
  }
  destroy(e) {
    this.postRenderer = null;
    for (let t = 0; t < this.rtViewQuad.size; t++)
      this.rtViewQuad.values[t].destroy(e);
    this.rtViewQuad.clear(), this.rtViewQuad = null;
    for (let t = 0; t < this.virtualTexture.size; t++) {
      const r = this.virtualTexture.values[t];
      ie.getInstance().detached(r, this), r.destroy(e);
    }
  }
};
var ch = class {
  constructor(e) {
    __publicField(this, "rendererMap");
    __publicField(this, "shadowMapPassRenderer");
    __publicField(this, "pointLightShadowRenderer");
    __publicField(this, "ddgiProbeRenderer");
    __publicField(this, "postRenderer");
    __publicField(this, "clusterLightingRender");
    __publicField(this, "occlusionSystem");
    __publicField(this, "depthPassRenderer");
    __publicField(this, "colorPassRenderer");
    __publicField(this, "pauseRender", false);
    __publicField(this, "pickFire");
    __publicField(this, "renderState", false);
    __publicField(this, "_view");
    this._view = e, this.rendererMap = new hh(), this.occlusionSystem = new js(), this.clusterLightingRender = this.addRenderer(rh, e), p.setting.render.zPrePass && (this.depthPassRenderer = this.addRenderer(lh)), this.shadowMapPassRenderer = new nh(), this.pointLightShadowRenderer = new sh();
  }
  addRenderer(e, t) {
    let r;
    return t ? r = new e(t) : r = new e(), this.rendererMap.addRenderer(r), r;
  }
  get view() {
    return this._view;
  }
  set view(e) {
    this._view = e;
  }
  start() {
    this.renderState = true;
  }
  stop() {
  }
  pause() {
    this.pauseRender = true;
  }
  resume() {
    this.pauseRender = false;
  }
  enablePost(e) {
    this.postRenderer = this.addRenderer(uh), this.postRenderer.setRenderStates(e);
  }
  addPost(e) {
    return this.postRenderer || (Ee.bufferTexture = true, this.enablePost(Ee.getGBufferFrame("ColorPassGBuffer"))), e instanceof wt && this.postRenderer.attachPost(this.view, e), e;
  }
  removePost(e) {
    if (e instanceof wt)
      this.postRenderer.detachPost(this.view, e);
    else
      for (let t = 0; t < e.length; t++)
        this.postRenderer.detachPost(this.view, e[t]);
  }
  renderFrame() {
    let e = this._view;
    oe.getLightEntries(e.scene).update(e), this.occlusionSystem.update(e.camera, e.scene), this.clusterLightingRender.render(e, this.occlusionSystem), this.shadowMapPassRenderer && (lt.update(e), this.shadowMapPassRenderer.render(e, this.occlusionSystem)), this.pointLightShadowRenderer && this.pointLightShadowRenderer.render(e, this.occlusionSystem), this.depthPassRenderer && (this.depthPassRenderer.compute(e, this.occlusionSystem), this.depthPassRenderer.render(e, this.occlusionSystem)), p.setting.gi.enable && this.ddgiProbeRenderer && (this.ddgiProbeRenderer.compute(e, this.occlusionSystem), this.ddgiProbeRenderer.render(e, this.occlusionSystem));
    let t = this.rendererMap.getAllPassRenderer();
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      i.compute(e, this.occlusionSystem), i.render(e, this.occlusionSystem, this.clusterLightingRender.clusterLightingBuffer);
    }
    this.postRenderer && this.postRenderer.postList.length > 0 && this.postRenderer.render(e);
  }
  debug() {
  }
};
var fh = class extends Y {
  constructor(e = 1e-3, t = 1e4, r = 90, i = false) {
    super();
    __publicField(this, "up_camera");
    __publicField(this, "down_camera");
    __publicField(this, "left_camera");
    __publicField(this, "right_camera");
    __publicField(this, "front_camera");
    __publicField(this, "back_camera");
    this.initCubeCamera(e, t, r, i);
  }
  initCubeCamera(e, t, r = 90, i = false) {
    this.up_camera = Me.createCamera3DObject(this, "up"), this.down_camera = Me.createCamera3DObject(this, "down"), this.left_camera = Me.createCamera3DObject(this, "left"), this.right_camera = Me.createCamera3DObject(this, "right"), this.front_camera = Me.createCamera3DObject(this, "front"), this.back_camera = Me.createCamera3DObject(this, "back"), this.up_camera.isShadowCamera = i, this.down_camera.isShadowCamera = i, this.left_camera.isShadowCamera = i, this.right_camera.isShadowCamera = i, this.front_camera.isShadowCamera = i, this.back_camera.isShadowCamera = i;
    let a = 1;
    this.up_camera.perspective(r, a, e, t), this.up_camera.lookAt(d.ZERO, d.UP, d.DOWN), this.down_camera.perspective(r, a, e, t), this.down_camera.lookAt(d.ZERO, d.DOWN, d.DOWN), this.left_camera.perspective(r, a, e, t), this.left_camera.lookAt(d.ZERO, d.LEFT), this.right_camera.perspective(r, a, e, t), this.right_camera.lookAt(d.ZERO, d.RIGHT), this.front_camera.perspective(r, a, e, t), this.front_camera.lookAt(d.ZERO, d.FORWARD), this.back_camera.perspective(r, a, e, t), this.back_camera.lookAt(d.ZERO, d.BACK), this.up_camera.type = Ae.shadow, this.down_camera.type = Ae.shadow, this.left_camera.type = Ae.shadow, this.right_camera.type = Ae.shadow, this.front_camera.type = Ae.shadow, this.back_camera.type = Ae.shadow;
  }
};
var dh = class extends Ne {
  constructor(e, t, r = true) {
    super([], []), this.crateGBuffer(e, t, r);
  }
  crateGBuffer(e, t, r) {
    let i = this.renderTargets, a = this.rtDescriptors, o = new it(e, t, N.rgba16float, false, void 0, 1, 0, true, r);
    o.name = "positionMap";
    let n = new fe();
    n.loadOp = "load";
    let l = new it(e, t, N.rgba16float, false, void 0, 1, 0, true, r);
    l.name = "normalMap";
    let h = new fe();
    h.loadOp = "load";
    let u = new it(e, t, N.rgba16float, false, void 0, 1, 0, true, r);
    u.name = "colorMap";
    let c = new fe();
    c.loadOp = "load";
    let f = new it(e, t, N.depth24plus, false, void 0, 1, 0, true, r);
    f.name = "depthTexture";
    let g = new fe();
    g.loadOp = "load", i.push(o), i.push(l), i.push(u), a.push(n), a.push(h), a.push(c), this.depthTexture = f;
  }
};
var gh = `
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;
var ph = class {
  constructor(e) {
    __publicField(this, "irradianceBuffer");
    __publicField(this, "depthBuffer");
    __publicField(this, "probeIrradianceMap");
    __publicField(this, "probeDepthMap");
    __publicField(this, "volume");
    __publicField(this, "computeShader");
    __publicField(this, "depthRaysBuffer");
    this.volume = e, this.initPipeline();
  }
  initPipeline() {
    this.computeShader = new ae(gh);
    let e = p.setting.gi, t = e.octRTMaxSize * e.octRTMaxSize;
    this.irradianceBuffer = new $(t * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST), this.computeShader.setStorageBuffer("irradianceBuffer", this.irradianceBuffer), this.depthBuffer = new $(t * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST), this.computeShader.setStorageBuffer("depthBuffer", this.depthBuffer), this.depthRaysBuffer = new $(4096 * 4 * 2 * 2 * 2, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC), this.computeShader.setStorageBuffer("depthRaysBuffer", this.depthRaysBuffer), this.computeShader.setStorageBuffer("probes", this.volume.probesBuffer), this.computeShader.setUniformBuffer("uniformData", this.volume.irradianceVolumeBuffer), this.computeShader.setStorageBuffer("models", oe.modelMatrixBindGroup.matrixBufferDst);
  }
  setTextures(e, t, r) {
    this.probeIrradianceMap = t, this.probeDepthMap = r;
    let i = e[0], a = e[1], o = e[2];
    this.computeShader.setStorageTexture("probeIrradianceMap", this.probeIrradianceMap), this.computeShader.setStorageTexture("probeDepthMap", this.probeDepthMap), this.computeShader.setSamplerTexture("positionMap", i), this.computeShader.setSamplerTexture("normalMap", a), this.computeShader.setSamplerTexture("colorMap", o);
  }
  readBuffer() {
    return this.depthRaysBuffer.readBuffer();
  }
  compute(e, t) {
    let r = this.volume.setting, i = y.beginCommandEncoder(), a = z.instance.getProbes(e.scene);
    this.computeShader.workerSizeX = r.octRTSideSize / 8, this.computeShader.workerSizeY = r.octRTSideSize / 8, this.computeShader.workerSizeZ = a.length, y.computeCommand(i, [this.computeShader]);
  }
};
var mh = `
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;
var Ah = class {
  constructor(e) {
    __publicField(this, "blendTexture");
    __publicField(this, "volume");
    __publicField(this, "computerShader");
    this.volume = e, this.initPipeline();
  }
  initPipeline() {
    let e = p.setting.gi;
    this.blendTexture = new it(e.probeSourceTextureSize, e.probeSourceTextureSize, N.rgba16float, false, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING), this.computerShader = new ae(mh), this.computerShader.setStorageTexture("outputBuffer", this.blendTexture), this.computerShader.setUniformBuffer("uniformData", this.volume.irradianceVolumeBuffer);
  }
  setInputs(e) {
    let t = e[0], r = e[1], i = e[2], a = e[3];
    this.computerShader.setSamplerTexture("normalMap", t), this.computerShader.setSamplerTexture("colorMap", r), this.computerShader.setSamplerTexture("litMap", i), this.computerShader.setSamplerTexture("irradianceMap", a);
  }
  compute(e, t) {
    let r = y.beginCommandEncoder(), i = this.volume.setting, a = i.probeXCount * i.probeYCount * i.probeZCount, o = i.probeSize;
    this.computerShader.workerSizeX = o * 6 / 8, this.computerShader.workerSizeY = o / 8, this.computerShader.workerSizeZ = a, y.computeCommand(r, [this.computerShader]);
  }
};
var vh = `
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(auto) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(auto) var prefilterMapSampler: sampler;
@group(0) @binding(auto) var prefilterMap: texture_cube<f32>;

@group(1) @binding(auto) var positionMapSampler : sampler;
@group(1) @binding(auto) var positionMap : texture_2d<f32>;

@group(1) @binding(auto) var normalMapSampler : sampler;
@group(1) @binding(auto) var normalMap : texture_2d<f32>;

@group(1) @binding(auto) var colorMapSampler : sampler;
@group(1) @binding(auto) var colorMap : texture_2d<f32>;

@group(1) @binding(auto) var shadowMapSampler : sampler_comparison;
@group(1) @binding(auto) var shadowMap : texture_depth_2d_array;
@group(1) @binding(auto) var pointShadowMapSampler: sampler;
@group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${Ct.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
    var shadowIndex = i32(light.castShadow);
    if (shadowIndex >= 0 ) {
      var shadowMatrix:mat4x4<f32>;
      if(enableCSM && csmCount > 1){
        for(var csm:i32 = 0; csm < csmCount; csm ++){
          var csmShadowBias = globalUniform.csmShadowBias[csm];
          shadowMatrix = globalUniform.csmMatrix[csm];
          let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
          if(csmShadowResult.y < 0.5){
            visibility = csmShadowResult.x;
            break;
          }
        }
      }else{
        shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
        visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
      }
    }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`;
var xh = class {
  constructor() {
    __publicField(this, "computeShader");
    __publicField(this, "worldPosMap");
    __publicField(this, "worldNormalMap");
    __publicField(this, "colorMap");
    __publicField(this, "shadowMap");
    __publicField(this, "pointShadowMap");
    __publicField(this, "lightingTexture");
    let e = p.setting.gi;
    this.lightingTexture = new it(e.probeSourceTextureSize, e.probeSourceTextureSize, N.rgba16float, false, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING);
  }
  create(e) {
    let t = oe.getLightEntries(e.scene);
    this.computeShader = new ae(vh);
    let r = oe.getCameraGroup(e.camera);
    this.computeShader.setUniformBuffer("globalUniform", r.uniformGPUBuffer), this.computeShader.setStorageTexture("outputBuffer", this.lightingTexture), this.computeShader.setStorageBuffer("lightBuffer", t.storageGPUBuffer), this.computeShader.setStorageBuffer("models", oe.modelMatrixBindGroup.matrixBufferDst), this.computeShader.setSamplerTexture("positionMap", this.worldPosMap), this.computeShader.setSamplerTexture("normalMap", this.worldNormalMap), this.computeShader.setSamplerTexture("colorMap", this.colorMap), this.computeShader.setSamplerTexture("shadowMap", this.shadowMap), this.computeShader.setSamplerTexture("pointShadowMap", this.pointShadowMap), this.computeShader.setSamplerTexture("prefilterMap", p.res.defaultSky);
  }
  setInputs(e) {
    this.worldPosMap = e[0], this.worldNormalMap = e[1], this.colorMap = e[2], this.shadowMap = e[3], this.pointShadowMap = e[4];
  }
  compute(e, t) {
    this.computeShader || this.create(e);
    let r = y.beginCommandEncoder(), i = p.setting.gi;
    this.computeShader.workerSizeX = i.probeSourceTextureSize / 8, this.computeShader.workerSizeY = i.probeSourceTextureSize / 8, this.computeShader.workerSizeZ = 1, y.computeCommand(r, [this.computeShader]);
  }
};
var _a2 = new ze("GIRenderStartEvent");
var qs = new ze("GIRenderCompleteEvent");
var Od = class {
  constructor() {
    __publicField(this, "count");
    __publicField(this, "complete");
  }
};
var _h = class extends mr {
  constructor(e) {
    super();
    __publicField(this, "cubeCamera");
    __publicField(this, "volume");
    __publicField(this, "probeCountPerFrame", 1);
    __publicField(this, "nextProbeIndex", -1);
    __publicField(this, "tempProbeList", []);
    __publicField(this, "isRenderCloudGI");
    __publicField(this, "probeRenderResult");
    __publicField(this, "renderStatus", "none");
    __publicField(this, "positionMap");
    __publicField(this, "normalMap");
    __publicField(this, "colorMap");
    __publicField(this, "probeNext", 128);
    __publicField(this, "sizeW");
    __publicField(this, "sizeH");
    __publicField(this, "lightingPass");
    __publicField(this, "bouncePass");
    __publicField(this, "irradianceComputePass");
    __publicField(this, "irradianceDepthMap");
    __publicField(this, "irradianceColorMap");
    this.passType = q.GI, this.volume = e;
    let t = e.setting;
    this.cubeCamera = new fh(0.01, 5e3), this.sizeW = t.probeSourceTextureSize, this.sizeH = t.probeSourceTextureSize, this.probeNext = t.probeSourceTextureSize / t.probeSize, this.initIrradianceMap(e), this.probeRenderResult = new Od();
    let r = new dh(this.sizeW, this.sizeH, false);
    this.positionMap = r.renderTargets[0], this.normalMap = r.renderTargets[1], this.colorMap = r.renderTargets[2], this.setRenderStates(r);
  }
  setInputTexture(e) {
    this.lightingPass = new xh(), this.bouncePass = new Ah(this.volume), this.irradianceComputePass = new ph(this.volume), this.lightingPass.setInputs([this.positionMap, this.normalMap, this.colorMap, e[0], e[1]]), this.bouncePass.setInputs([this.normalMap, this.colorMap, this.lightingPass.lightingTexture, this.irradianceColorMap]), this.irradianceComputePass.setTextures([this.positionMap, this.normalMap, this.bouncePass.blendTexture], this.irradianceColorMap, this.irradianceDepthMap);
  }
  setIrradianceData(e, t, r, i) {
    if (r != this.irradianceColorMap.width || i != this.irradianceColorMap.height) {
      console.error("irradiance image size not match !");
      return;
    }
    this.writeToTexture(this.irradianceColorMap, e, r, i), this.writeToTexture(this.irradianceDepthMap, t, r, i);
  }
  updateProbe(e, t, r) {
    let i = z.instance.getLights(e.scene), a = this.volume.setting.probeSize;
    t.drawCallFrame += 1, this.cubeCamera.x = t.x, this.cubeCamera.y = t.y, this.cubeCamera.z = t.z, this.volume.setting.debugCamera ? (this.cubeCamera.x = e.camera.transform.x, this.cubeCamera.y = e.camera.transform.y, this.cubeCamera.z = e.camera.transform.z, this.cubeCamera.rotationX = e.camera.transform.rotationX, this.cubeCamera.rotationY = e.camera.transform.rotationY, this.cubeCamera.rotationZ = e.camera.transform.rotationZ) : (this.cubeCamera.rotationX = t.rotationX, this.cubeCamera.rotationY = t.rotationY, this.cubeCamera.rotationZ = t.rotationZ);
    let o = this.cubeCamera, n = Math.floor(t.index / this.probeNext) * (a * 6), l = Math.floor(t.index % this.probeNext) * a;
    r.setViewport(0 + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.right_camera, r, i), r.setViewport(a + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.left_camera, r, i), r.setViewport(a * 2 + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.up_camera, r, i), r.setViewport(a * 3 + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.down_camera, r, i), r.setViewport(a * 4 + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.front_camera, r, i), r.setViewport(a * 5 + n, l, a, a, 0, 1), this.renderSceneOnce(e, o.back_camera, r, i);
  }
  renderSceneOnce(e, t, r, i) {
    this.volume.uploadBuffer();
    let a = z.instance.getRenderNodes(e.scene, t);
    y.bindCamera(r, t);
    let o = Math.max(0, p.setting.render.drawOpMin), n = Math.min(p.setting.render.drawOpMax, a.opaqueList.length), l = z.instance.getRenderShaderCollect(e);
    for (const h of l) {
      let u = h[1];
      for (const c of u) {
        let f = c[1];
        if (f.preInit) {
          f.nodeUpdate(e, this.passType, this.rendererPassState, null);
          break;
        }
      }
    }
    for (let h = o; h < n; ++h) {
      let u = a.opaqueList[h];
      u.enable && u.transform.enable && (u.preInit || u.nodeUpdate(e, this.passType, this.rendererPassState, null), u.renderPass2(e, this.passType, this.rendererPassState, null, r));
    }
    z.instance.sky && (z.instance.sky.preInit || z.instance.sky.nodeUpdate(e, this.passType, this.rendererPassState, null), z.instance.sky.renderPass2(e, this.passType, this.rendererPassState, null, r)), o = Math.max(0, p.setting.render.drawTrMin), n = Math.min(p.setting.render.drawTrMax, a.transparentList.length);
    for (let h = o; h < n; ++h) {
      let u = a.transparentList[h];
      u.enable && u.transform.enable && (u.preInit || u.nodeUpdate(e, this.passType, this.rendererPassState, null), u.renderPass2(e, this.passType, this.rendererPassState, null, r));
    }
  }
  render(e, t) {
    if (!p.setting.gi.enable)
      return;
    this.volume.updateOrientation(), this.volume.isVolumeFrameChange = false, this.volume.uploadBuffer(), this.rendProbe(e);
    let r = this.probeRenderResult.count > 0;
    (z.instance.state.giLightingChange || r || p.setting.gi.realTimeGI) && (z.instance.state.giLightingChange = false, this.lightingPass.compute(e, this.rendererPassState), this.bouncePass.compute(e, this.rendererPassState), this.irradianceComputePass.compute(e, this.rendererPassState)), this.probeRenderResult.complete && this.dispatchEvent(qs);
  }
  startRenderGI(e = 0) {
    this.nextProbeIndex == -1 && e == 0 && this.dispatchEvent(_a2), this.nextProbeIndex = e, this.renderStatus = "rendering";
  }
  startRenderCloudGI() {
    this.dispatchEvent(_a2), this.nextProbeIndex = 0, this.renderStatus = "rendering", this.isRenderCloudGI = true;
  }
  rendProbe(e) {
    let t = p.setting.gi.autoRenderProbe, r = false;
    if (t ? (this.nextProbeIndex == -1 && this.startRenderGI(), r = true) : r = this.renderStatus == "rendering", this.probeRenderResult.count = 0, this.probeRenderResult.complete = false, r) {
      let i = z.instance.getProbes(e.scene);
      this.renderContext.clean(), this.renderContext.beginOpaqueRenderPass(), this.tempProbeList.length = 0;
      let a = Math.min(this.probeCountPerFrame, i.length);
      for (this.probeRenderResult.count = a; a > 0; ) {
        const n = i[this.nextProbeIndex];
        this.updateProbe(e, n, this.renderContext.encoder), a--, this.nextProbeIndex++, n.drawCallFrame < 3 && this.tempProbeList.push(n);
      }
      this.tempProbeList.length > 0 && this.volume.updateProbes(this.tempProbeList);
      let o = this.nextProbeIndex >= i.length;
      this.nextProbeIndex >= i.length && this.isRenderCloudGI && this.updateProbe(e, i[0], this.renderContext.encoder), this.renderContext.endRenderPass(), o && (this.nextProbeIndex = -1, this.renderStatus = "complete", this.probeRenderResult.complete = true);
    }
  }
  initIrradianceMap(e) {
    let t = e.setting, r = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
    this.irradianceDepthMap = new it(t.octRTMaxSize, t.octRTMaxSize, N.rgba16float, false, r), this.irradianceDepthMap.name = "irradianceDepthMap", this.irradianceColorMap = new it(t.octRTMaxSize, t.octRTMaxSize, N.rgba16float, false, r), this.irradianceColorMap.name = "irradianceColorMap";
  }
  writeToTexture(e, t, r, i) {
    console.log(e.name);
    const a = w.device.createBuffer({ size: t.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    w.device.queue.writeBuffer(a, 0, t);
    const o = y.beginCommandEncoder();
    o.copyBufferToTexture({ buffer: a, bytesPerRow: r * 16 }, { texture: e.getGPUTexture() }, { width: r, height: i, depthOrArrayLayers: 1 }), y.endCommandEncoder(o);
  }
};
var Ks = class extends ch {
  constructor(e) {
    super(e);
  }
  start() {
    super.start();
    let e = Ee.getGBufferFrame("ColorPassGBuffer");
    {
      let t = [], r = new Zl();
      p.setting.render.zPrePass && (e.zPreTexture = this.depthPassRenderer.rendererPassState.depthTexture), r.setRenderStates(e);
      for (let i = 0; i < e.renderTargets.length; i++) {
        const a = e.renderTargets[i];
        t.push(a);
      }
      if (p.setting.gi.enable) {
        let i = oe.getLightEntries(this.view.scene);
        this.ddgiProbeRenderer = new _h(i.irradianceVolume), this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture, this.pointLightShadowRenderer.cubeArrayTexture]), r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap, this.ddgiProbeRenderer.irradianceDepthMap), this.rendererMap.addRenderer(this.ddgiProbeRenderer), t.push(this.ddgiProbeRenderer.positionMap, this.ddgiProbeRenderer.normalMap, this.ddgiProbeRenderer.colorMap, this.ddgiProbeRenderer.lightingPass.lightingTexture, this.ddgiProbeRenderer.irradianceColorMap, this.ddgiProbeRenderer.irradianceDepthMap);
      }
      this.postRenderer && this.postRenderer.setDebugTexture(t), this.rendererMap.addRenderer(r);
    }
    p.setting.render.debug && this.debug();
  }
  debug() {
  }
};
var Ch = class {
  constructor() {
    __publicField(this, "_factor");
    __publicField(this, "_doubleFactor");
    this._factor = 1, this._doubleFactor = 2;
  }
  get accelerateInterpolator() {
    return this._factor;
  }
  set accelerateInterpolator(e) {
    this._factor = e, this._doubleFactor = 2 * this._factor;
  }
  getInterpolation(e) {
    return this._factor == 1 ? e * e : Math.pow(e, this._doubleFactor);
  }
};
var Sh = class {
  constructor() {
    __publicField(this, "_factor", 1);
  }
  get decelerateInterpolator() {
    return this._factor;
  }
  set decelerateInterpolator(e) {
    this._factor = e;
  }
  getInterpolation(e) {
    let t;
    return this._factor == 1 ? t = 1 - (1 - e) * (1 - e) : t = 1 - Math.pow(1 - e, 2 * this._factor), t;
  }
};
var yh = class {
  constructor() {
    __publicField(this, "_factor", 1);
  }
  getInterpolation(e) {
    return Math.cos((e + 1) * Math.PI) / 2 + 0.5;
  }
};
var wh = class {
  getInterpolation(e) {
    return e;
  }
};
var Ih = class {
  getInterpolation(e) {
    return 4.9 * e + 4.9 * e;
  }
};
var mt = class _mt {
  constructor() {
  }
  static bounce(e) {
    return e * e * 9.8;
  }
  getInterpolation(e) {
    return e *= 1.1226, e < 0.3535 ? _mt.bounce(e) : e < 0.7408 ? _mt.bounce(e - 0.54719) + 0.7 : e < 0.9644 ? _mt.bounce(e - 0.8526) + 0.9 : _mt.bounce(e - 1.0435) + 0.95;
  }
  getBounceInterpolation(e) {
    return e < 0.5 ? _mt.bounce(e) : _mt.bounce(e - 1);
  }
  geJumpUp(e, t) {
    return t < 0.5 ? (t = t / 0.5, e * t - _mt.bounce(t)) : t < 0.8 ? (t = (t - 0.5) / (0.8 - 0.5), (e * t - _mt.bounce(t)) * 0.3) : t < 1 ? (t = (t - 0.8) / (1 - 0.8), (e * t - _mt.bounce(t)) * 0.15) : e * t - _mt.bounce(t);
  }
};
var bh = class {
  constructor() {
    __publicField(this, "_tension");
    this._tension = 2;
  }
  get anticipateInterpolator() {
    return this._tension;
  }
  set anticipateInterpolator(e) {
    this._tension = e;
  }
  getInterpolation(e) {
    return e * e * ((this._tension + 1) * e - this._tension);
  }
};
var sa = class _sa {
  constructor() {
    __publicField(this, "_tension");
    this._tension = 1 * 1.5;
  }
  anticipateOvershootInterpolator(e) {
    this._tension = e * 1.5;
  }
  anticipateOvershootInterpolator2(e, t) {
    this._tension = e * t;
  }
  getInterpolation(e) {
    return e < 0.5 ? 0.5 * _sa.a(e * 2, this._tension) : 0.5 * (_sa.o(e * 2 - 2, this._tension) + 2);
  }
  static a(e, t) {
    return e * e * ((t + 1) * e - t);
  }
  static o(e, t) {
    return e * e * ((t + 1) * e + t);
  }
};
var Eh = class {
  constructor(e) {
    __publicField(this, "_cycles");
    this._cycles = e;
  }
  getInterpolation(e) {
    return Math.sin(2 * this._cycles * Math.PI * e);
  }
};
var Bh = class {
  constructor() {
    __publicField(this, "_tension");
    this._tension = 2;
  }
  getInterpolation(e) {
    return e -= 1, e * e * ((this._tension + 1) * e + this._tension) + 1;
  }
};
var Js = ((s) => (s[s.AccelerateInterpolator = 0] = "AccelerateInterpolator", s[s.DecelerateInterpolator = 1] = "DecelerateInterpolator", s[s.AccelerateDecelerateInterpolator = 2] = "AccelerateDecelerateInterpolator", s[s.LinearInterpolator = 3] = "LinearInterpolator", s[s.BounceInterpolator = 4] = "BounceInterpolator", s[s.AnticipateInterpolator = 5] = "AnticipateInterpolator", s[s.AnticipateOvershootInterpolator = 6] = "AnticipateOvershootInterpolator", s[s.CycleInterpolator = 7] = "CycleInterpolator", s[s.OvershootInterpolator = 8] = "OvershootInterpolator", s[s.JumperInterpolator = 9] = "JumperInterpolator", s))(Js || {});
var _yr = class _yr {
  constructor() {
    __publicField(this, "complete", false);
    __publicField(this, "onComplete");
    __publicField(this, "onProgress");
    __publicField(this, "target");
    __publicField(this, "property");
    __publicField(this, "targetProperty");
    __publicField(this, "durtion");
    __publicField(this, "interpolatorEnum");
    __publicField(this, "delayTime", 0);
    __publicField(this, "_interpolator");
    __publicField(this, "_ct", 0);
    __publicField(this, "_p", 0);
  }
  static to(e, t, r, i = 0) {
    var a = new _yr();
    return a.target = e, a.property = t, a.durtion = r, a.interpolatorEnum = i, a.start(), a.delayTime = t.delayTime ? t.delayTime : 0, t.onComplete && (a.onComplete = t.onComplete), t.onProgress && (a.onProgress = t.onProgress), this.interpolators.push(a), a;
  }
  static tick(e) {
    let t = _yr.interpolators;
    for (let r of t)
      r.complete ? _yr.remove(r, true) : r.tick(e);
  }
  static remove(e, t) {
    let r = _yr.interpolators, i = r.indexOf(e);
    i != -1 && r.splice(i, 1), t && e.dispose();
  }
  static removeList(e, t) {
    e.forEach((r) => {
      this.remove(r, t);
    });
  }
  start() {
    window.AccelerateInterpolator = Ch, window.DecelerateInterpolator = Sh, window.AccelerateDecelerateInterpolator = yh, window.LinearInterpolator = wh, window.BounceInterpolator = mt, window.AnticipateInterpolator = bh, window.AnticipateOvershootInterpolator = sa, window.CycleInterpolator = Eh, window.OvershootInterpolator = Bh, window.JumperInterpolator = Ih, this._interpolator = new window[Js[this.interpolatorEnum]](), this.targetProperty = {};
    for (let e in this.property)
      this.targetProperty[e] = this.target[e];
  }
  tick(e) {
    if (this.delayTime <= 0) {
      this._p = Math.min(this._ct / this.durtion, 1);
      let t = this._interpolator.getInterpolation(this._p), r = this.property, i = this.target, a = this.targetProperty, o, n;
      for (let l in r)
        n = r[l], o = a[l], i[l] = o + (n - o) * t;
      this.onProgress != null && this.onProgress(this._p), this._ct >= this.durtion && (this.complete = true, this.onComplete != null && this.onComplete(this.target)), this._ct += e;
    } else
      this.delayTime -= e;
  }
  dispose() {
    this.onComplete = null, this.onProgress = null, this.target = null, this.property = null, this.targetProperty = null, this.interpolatorEnum = null, this._interpolator = null, _yr.remove(this);
  }
};
__publicField(_yr, "interpolators", []);
var yr = _yr;
var et = class {
  static hasString(e, t) {
    for (var r = 0; r < e.length; ++r)
      if (e[r] == t)
        return r;
    return -1;
  }
  static getEllipsis(e, t = 4) {
    let r = e;
    return r.length > t && (r = r.slice(0, t) + "..."), r;
  }
  static getURLName(e) {
    var t;
    t = e.split("/");
    let r = t[t.length - 1];
    return r = r.split(".")[0], r;
  }
  static getFileFormat(e) {
    var t = e.lastIndexOf(".");
    t++;
    var r = e.length;
    e.indexOf("?", t) !== -1 && (r = e.indexOf("?", t));
    var i = e.substr(t, r - t);
    return i = i.toLowerCase(), i;
  }
  static readLineProperty(e, t) {
    e.trim().split(" ").forEach((r, i) => {
      let a = r.split("=");
      if (a.length > 1) {
        let o = a[0], n = a[1];
        Object.prototype.hasOwnProperty.call(t, o) && (n.indexOf('"') == -1 ? t[o] = parseFloat(a[1]) : t[o] = n.replace('"', "").replace('"', ""));
      }
    });
  }
  static getPath(e) {
    var t = e.lastIndexOf("/");
    return t++, e.substring(0, t);
  }
  static normalizePath(e) {
    var t = e.replaceAll("//", "/");
    return t = t.replaceAll("\\", "/"), t;
  }
  static getStringList(e, t = ";") {
    return e.split(t);
  }
  static formatTime(e) {
    let r = e / 1e3 / 60, i = Math.floor(r), a = Math.floor(r - i);
    return [i.toString(), a.toString()];
  }
  static trim(e) {
    return e.replace(/^\s+/g, "").replace(/\s+$/g, "");
  }
  static isEmpty(e) {
    return !e || typeof e > "u" || e == null || typeof e == "string" && this.trim(e) === "" || e === "null";
  }
  static strCut(e, t) {
    if (e.length * 2 <= t)
      return e;
    for (var r = 0, i = "", a = 0; a < e.length; a++)
      if (i = i + e.charAt(a), e.charCodeAt(a) > 128) {
        if (r = r + 2, r >= t)
          return i.substring(0, i.length - 1) + "...";
      } else if (r = r + 1, r >= t)
        return i.substring(0, i.length - 2) + "...";
    return i;
  }
  static toQueryPair(e, t, r = false) {
    return e + "=" + (r ? encodeURIComponent(t) : t);
  }
  static stringFormat(e, ...t) {
    if (arguments.length === 0)
      throw new Error("please give arg at least one !");
    if (arguments.length === 2 && typeof arguments[1] == "object")
      for (let r in arguments[1]) {
        let i = new RegExp("({" + r + "})", "g");
        e = e.replace(i, arguments[1][r]);
      }
    else
      for (let r = 0; r < t.length; r++) {
        if (t[r] == null)
          return e;
        {
          let i = new RegExp("({[" + r + "]})", "g");
          e = e.replace(i, t[r]);
        }
      }
    return e;
  }
  static parseJson2String(e, t) {
    let r = null, i = "", a = 0, o = "    ";
    return t = t || {}, t.newlineAfterColonIfBeforeBraceOrBracket = t.newlineAfterColonIfBeforeBraceOrBracket === true, t.spaceAfterColon = t.spaceAfterColon !== false, typeof e != "string" || (e = JSON.parse(e)), e = JSON.stringify(e), r = /([\{\}])/g, e = e.replace(r, `\r
$1\r
`), r = /([\[\]])/g, e = e.replace(r, `\r
$1\r
`), r = /(\,)/g, e = e.replace(r, `$1\r
`), r = /(\r\n\r\n)/g, e = e.replace(r, `\r
`), r = /\r\n\,/g, e = e.replace(r, ","), t.newlineAfterColonIfBeforeBraceOrBracket || (r = /\:\r\n\{/g, e = e.replace(r, ":{"), r = /\:\r\n\[/g, e = e.replace(r, ":[")), t.spaceAfterColon && (r = /\:/g, e = e.replace(r, ":")), e.split(`\r
`).forEach(function(n, l) {
      let h = 0, u = 0, c = "";
      for (n.match(/\{$/) || n.match(/\[$/) ? u = 1 : n.match(/\}/) || n.match(/\]/) ? a !== 0 && (a -= 1) : u = 0, h = 0; h < a; h++)
        c += o;
      i += c + n + `\r
`, a += u;
    }), i;
  }
  static compareVersion(e, t) {
    e = e.split("."), t = t.split(".");
    let r = Math.max(e.length, t.length);
    for (; e.length < r; )
      e.push("0");
    for (; t.length < r; )
      t.push("0");
    for (let i = 0; i < r; i++) {
      let a = parseInt(e[i]), o = parseInt(t[i]);
      if (a > o)
        return 1;
      if (a < o)
        return -1;
    }
    return 0;
  }
  static buildRandomCode() {
    let e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", t = e.length, r = "";
    for (let a = 0; a < 26; a++) {
      let o = Math.floor(Math.random() * t);
      r += e.charAt(o);
    }
    return `${(/* @__PURE__ */ new Date()).getTime()}-${r}`;
  }
  static UUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
      var t = Math.random() * 16 | 0, r = e == "x" ? t : t & 3 | 8;
      return r.toString(16);
    });
  }
  static stringToHash(e) {
    let t = 0;
    if (e.length == 0)
      return t;
    for (let r = 0; r < e.length; r++) {
      const i = e.charCodeAt(r);
      t = (t << 5) - t + i, t = t & t;
    }
    return t;
  }
  static parseUrl(e, t) {
    return t.match(/^(blob|http|https):/) ? t : e + t;
  }
};
__publicField(et, "_filterChar", [" ", "  ", ";", `
`, "\r", "	", `
`, "\r", "	"]);
var rr = class extends Re {
  constructor(e = true) {
    super();
    __publicField(this, "_source");
    __publicField(this, "premultiplyAlpha", "none");
    __publicField(this, "imageData");
    this.useMipmap = e, this.lodMinClamp = 0, this.lodMaxClamp = 4;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    this._source = e, this._source instanceof HTMLImageElement ? this._source.decode().then(async () => {
      if (this._source instanceof HTMLImageElement) {
        const t = await createImageBitmap(this._source, { imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
        this.generate(t);
      }
    }) : (this._source instanceof HTMLCanvasElement || this._source instanceof ImageBitmap) && this.generate(this._source);
  }
  async load(e, t) {
    if (this.name = et.getURLName(e), e.indexOf(";base64") != -1) {
      const r = document.createElement("img");
      let i = e.indexOf("data:image"), a = e.substring(i, e.length);
      r.src = a, await r.decode(), r.width = Math.max(r.width, 32), r.height = Math.max(r.height, 32);
      const o = await createImageBitmap(r, { resizeWidth: r.width, resizeHeight: r.height, imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
      this.format = N.rgba8unorm, this.generate(o);
    } else
      return new Promise((r, i) => {
        fetch(e, { headers: Object.assign({ Accept: "image/avif,image/webp,*/*" }, t == null ? void 0 : t.headers) }).then((a) => {
          Vr.read(e, a, t).then((o) => {
            let n = new Blob([o], { type: "image/jpeg" });
            o = null, this.loadFromBlob(n).then(() => {
              r(true);
            });
          });
        });
      });
    return true;
  }
  async loadFromBlob(e) {
    this.imageData = e;
    let t = await createImageBitmap(e, { imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
    if (t.width < 32 || t.height < 32) {
      let r = Math.max(t.width, 32), i = Math.max(t.height, 32);
      t = await createImageBitmap(t, { resizeWidth: r, resizeHeight: i, imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
    }
    return this.format = N.rgba8unorm, this.generate(t), true;
  }
};
var Vr = class _Vr {
  constructor() {
    __publicField(this, "baseUrl", "");
    __publicField(this, "initUrl");
    __publicField(this, "_progress", 0);
  }
  async loadBinData(e, t) {
    return this.baseUrl = et.getPath(e), this.initUrl = e, new Promise(async (r, i) => {
      fetch(e, { headers: t == null ? void 0 : t.headers }).then(async (a) => {
        if (a.ok) {
          let o = await _Vr.read(e, a, t), n = o.buffer;
          o = null, r(n);
        } else
          throw Error("request rejected with status " + a.status);
      }).catch((a) => {
        t.onError && t.onError(a), i(a);
      });
    });
  }
  async loadAsyncBitmapTexture(e, t) {
    this.baseUrl = et.getPath(e), this.initUrl = e;
    let r = new rr();
    return r.url = e, r.name = et.getURLName(e), await r.load(e, t), p.res.addTexture(e, r), r;
  }
  async loadJson(e, t) {
    return this.baseUrl = et.getPath(e), this.initUrl = e, new Promise(async (r, i) => {
      fetch(e, { headers: t == null ? void 0 : t.headers }).then(async (a) => {
        if (a.ok) {
          let o = await _Vr.read(e, a, t);
          const l = new TextDecoder("utf-8").decode(o);
          o = null, r(JSON.parse(l));
        } else
          throw Error("request rejected with status" + a.status);
      }).catch((a) => {
        t.onError && t.onError(a), i(a);
      });
    });
  }
  async loadTxt(e, t) {
    return this.baseUrl = et.getPath(e), new Promise(async (r, i) => {
      fetch(e).then(async (a) => {
        if (a.ok) {
          let o = await _Vr.read(e, a, t);
          const l = new TextDecoder("utf-8").decode(o);
          o = null, r({ data: l });
        } else
          throw Error("request rejected with status" + a.status);
      }).catch((a) => {
        t.onError && t.onError(a), i(a);
      });
    });
  }
  static async read(e, t, r) {
    const i = t.body.getReader(), a = +t.headers.get("Content-Length");
    let o = 0, n = [], l = [];
    for (; ; ) {
      const { done: c, value: f } = await i.read();
      if (c) {
        a > 0 && r && r.onComplete && r.onComplete.call(this, e);
        break;
      }
      n.push(f), o += f.length, a > 0 ? r && r.onProgress && r.onProgress.call(this, o, a, e) : l.push(f.length);
    }
    if (l.length > 0)
      for (let c = 0; c < n.length; c++)
        console.log(l[c]), r && r.onProgress && r.onProgress.call(this, l[c], o, e), l[c] == o && r && r.onComplete && r.onComplete.call(this, e);
    let h = new Uint8Array(o), u = 0;
    for (let c of n)
      h.set(c, u), u += c.length;
    return h;
  }
};
var Ue = ((s) => (s[s.TEXT = 0] = "TEXT", s[s.BIN = 1] = "BIN", s[s.JSON = 2] = "JSON", s))(Ue || {});
var tt = class extends Vr {
  async load(e, t, r, i) {
    switch (t.format) {
      case Ue.BIN:
        return new Promise(async (a, o) => {
          this.loadBinData(e, r).then(async (n) => {
            let l = new t();
            if (l.userData = i, l.baseUrl = this.baseUrl, l.initUrl = e, await l.parseBuffer(n), l.verification())
              a(l);
            else
              throw new Error("parser error");
          }).catch((n) => {
            o(n);
          });
        });
      case Ue.JSON:
        return new Promise((a, o) => {
          this.loadJson(e, r).then(async (n) => {
            let l = new t();
            l.userData = i, l.baseUrl = this.baseUrl, l.initUrl = e, l.loaderFunctions = r, await l.parseJson(n), a(l);
          }).catch((n) => {
            o(n);
          });
        });
      case Ue.TEXT:
        return new Promise((a, o) => {
          this.loadTxt(e, r).then(async (n) => {
            let l = new t();
            l.userData = i, l.baseUrl = this.baseUrl, l.initUrl = e, l.loaderFunctions = r, n.data ? (await l.parseString(n.data), a(l)) : o("text load is empty!");
          }).catch((n) => {
            o(n);
          });
        });
    }
  }
};
var rt = class {
  constructor() {
    __publicField(this, "baseUrl");
    __publicField(this, "initUrl");
    __publicField(this, "loaderFunctions");
    __publicField(this, "userData");
    __publicField(this, "data");
  }
  parseString(e) {
  }
  parseJson(e) {
  }
  parseBuffer(e) {
  }
  parseTexture(e) {
    throw this.parserError("Method not implemented.", -1);
  }
  parse(e) {
  }
  verification(e) {
    throw this.parserError("Method not implemented.", -1);
  }
  parserError(e, t) {
    console.error(`error id:${t} ${e}`);
  }
};
__publicField(rt, "format", Ue.BIN);
var Ca = class {
  constructor() {
    __publicField(this, "asset");
    __publicField(this, "accessors");
    __publicField(this, "buffers");
    __publicField(this, "bufferViews");
    __publicField(this, "materials");
    __publicField(this, "meshes");
    __publicField(this, "nodes");
    __publicField(this, "scene", 0);
    __publicField(this, "scenes");
    __publicField(this, "textures");
    __publicField(this, "cameras");
    __publicField(this, "skins");
    __publicField(this, "resources");
    __publicField(this, "images");
    __publicField(this, "samplers");
    __publicField(this, "animations");
    __publicField(this, "extensions");
  }
};
var Fd = class {
  constructor() {
    __publicField(this, "nodes");
  }
};
var Nd = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "type");
    __publicField(this, "color");
    __publicField(this, "intensity");
    __publicField(this, "range");
    __publicField(this, "spot");
    __publicField(this, "isParsed");
  }
};
var zd = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "rotation");
    __publicField(this, "scale");
    __publicField(this, "translation");
    __publicField(this, "children");
    __publicField(this, "matrix");
    __publicField(this, "mesh", -1);
    __publicField(this, "isParsed");
    __publicField(this, "dnode");
    __publicField(this, "camera");
    __publicField(this, "skin");
    __publicField(this, "nodeId");
    __publicField(this, "primitives");
    __publicField(this, "extensions");
    __publicField(this, "light");
  }
};
var kd = class {
  constructor() {
    __publicField(this, "attributes");
    __publicField(this, "indices");
    __publicField(this, "material");
    __publicField(this, "mode");
    __publicField(this, "name");
    __publicField(this, "targets");
    __publicField(this, "extensions");
    __publicField(this, "morphTargetsRelative");
  }
};
var Gd = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "primitives");
    __publicField(this, "isParsed");
    __publicField(this, "dprimitives");
    __publicField(this, "weights");
    __publicField(this, "extras");
  }
};
var Qd = class {
  constructor() {
    __publicField(this, "bufferView");
    __publicField(this, "componentType");
    __publicField(this, "count");
    __publicField(this, "type");
    __publicField(this, "max");
    __publicField(this, "min");
    __publicField(this, "isParsed");
    __publicField(this, "daccessor");
    __publicField(this, "normalized");
    __publicField(this, "sparse");
    __publicField(this, "byteOffset");
    __publicField(this, "computeResult");
  }
};
var Vd = window.SharedArrayBuffer ? function(e) {
  return e && e.buffer && (e.buffer instanceof ArrayBuffer || e.buffer instanceof window.SharedArrayBuffer);
} : function(e) {
  return e && e.buffer && e.buffer instanceof ArrayBuffer;
};
var Zs = 5120;
var Ii = 5121;
var $s = 5122;
var eo = 5123;
var to = 5124;
var ro = 5125;
var io = 5126;
var Hd = 32819;
var Yd = 32820;
var Xd = 33635;
var Wd = 5131;
var jd = 33640;
var qd = 35899;
var Kd = 35902;
var Jd = 36269;
var Zd = 34042;
var Th = {};
{
  const s = Th;
  s[Zs] = Int8Array, s[Ii] = Uint8Array, s[$s] = Int16Array, s[eo] = Uint16Array, s[to] = Int32Array, s[ro] = Uint32Array, s[io] = Float32Array, s[Hd] = Uint16Array, s[Yd] = Uint16Array, s[Xd] = Uint16Array, s[Wd] = Uint16Array, s[jd] = Uint32Array, s[qd] = Uint32Array, s[Kd] = Uint32Array, s[Jd] = Uint32Array, s[Zd] = Uint32Array;
}
function $d(s) {
  switch (s) {
    case Int8Array:
      return Zs;
    case Uint8Array:
      return Ii;
    case Uint8ClampedArray:
      return Ii;
    case Int16Array:
      return $s;
    case Uint16Array:
      return eo;
    case Int32Array:
      return to;
    case Uint32Array:
      return ro;
    case Float32Array:
      return io;
    default:
      throw new Error("unsupported typed array type");
  }
}
function eg(s) {
  if (s instanceof Int8Array)
    return Zs;
  if (s instanceof Uint8Array || s instanceof Uint8ClampedArray)
    return Ii;
  if (s instanceof Int16Array)
    return $s;
  if (s instanceof Uint16Array)
    return eo;
  if (s instanceof Int32Array)
    return to;
  if (s instanceof Uint32Array)
    return ro;
  if (s instanceof Float32Array)
    return io;
  throw new Error("unsupported typed array type");
}
function ao(s) {
  const e = Th[s];
  if (!e)
    throw new Error("unkonw gl type");
  return e;
}
function tg(s, e = Float32Array) {
  return Vd(s) ? s : new e(s);
}
var so = class {
  static async apply(e, t) {
    if (!t.extensions)
      return;
    const r = t.extensions.KHR_draco_mesh_compression;
    if (!r)
      return;
    let i = this._workers.get(e.gltf);
    i || (i = new Worker(await this.initDecoder()), this._workers.set(e.gltf, i)), i.postMessage({ type: "init", decoderConfig: {} });
    let a = e.parseBufferView(r.bufferView);
    if (!a.result) {
      let o = await new Promise((n, l) => {
        i.onmessage = (h) => {
          const u = h.data;
          u.type == "decode" ? n(u.result) : u.type == "error" && l(u.error);
        }, i.postMessage({ type: "decoder", buffer: a, attributes: r.attributes }, [a]);
      });
      a.result = o;
    }
    return a.result;
  }
  static unload(e) {
    let t = this._workers.get(e);
    t && (t.terminate(), this._workers.delete(e));
  }
  static async initDecoder() {
    if (!this._workerCode) {
      let e = await new tt().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");
      const t = new Blob([e.data, "", `(${rg})()`], { type: "application/javascript" });
      this._workerCode = URL.createObjectURL(t);
    }
    return this._workerCode;
  }
};
__publicField(so, "_workerCode");
__publicField(so, "_workers", /* @__PURE__ */ new Map());
function rg() {
  let s, e;
  onmessage = (t) => {
    const r = t.data;
    switch (r.type) {
      case "init":
        s = r.decoderConfig, e = new Promise((o, n) => {
          s.onModuleLoaded = (l) => {
            o({ draco: l });
          }, DracoDecoderModule(s);
        });
        break;
      case "decoder":
        const i = r.buffer, a = r.attributes;
        e.then((o) => {
          const n = o.draco;
          let l = new n.Decoder(), h = new n.DecoderBuffer();
          h.Init(new Int8Array(i), i.byteLength);
          let u, c;
          try {
            const f = l.GetEncodedGeometryType(h);
            f == n.TRIANGULAR_MESH ? (c = new n.Mesh(), u = l.DecodeBufferToMesh(h, c)) : self.postMessage(new Error("INVALID_GEOMETRY_TYPE:" + f)), u.ok() || self.postMessage(new Error("DracoDecode:" + u.error_msg()));
            let g = {};
            for (const m in a) {
              let A = l.GetAttributeByUniqueId(c, a[m]);
              const _ = A.num_components(), C = c.num_points() * _, S = C * Float32Array.BYTES_PER_ELEMENT, I = n.DT_FLOAT32, T = n._malloc(S);
              l.GetAttributeDataArrayForAllPoints(c, A, I, S, T);
              const b = new Float32Array(n.HEAPF32.buffer, T, C).slice();
              n._free(T), g[m] = { data: b, numComponents: _, normalize: false };
            }
            {
              const A = c.num_faces() * 3, _ = A * 4, x = n._malloc(_);
              l.GetTrianglesUInt32Array(c, _, x);
              const C = new Uint32Array(n.HEAPF32.buffer, x, A).slice();
              n._free(x), g.indices = { data: C, numComponents: 1, normalize: false };
            }
            self.postMessage({ type: "decode", result: g });
          } catch (f) {
            self.postMessage({ type: "error", error: f.message });
          } finally {
            n.destroy(c), n.destroy(l), n.destroy(h);
          }
        });
        break;
    }
  };
}
var Dh = class {
  constructor(e) {
    __publicField(this, "gltf");
    this.gltf = e;
  }
  parse(e) {
    const t = this.gltf.cameras[e];
    if (!t)
      return this.errorMiss("camera", e);
    if (t.isParsed)
      return t.dcamera;
    t.isParsed = true, t.dcamera = false;
    const { name: r, type: i, perspective: a, orthographic: o } = t;
    if (i === "perspective" && a) {
      const { aspectRatio: n, yfov: l, zfar: h, znear: u } = a;
      t.dcamera = Object.assign({}, { name: r, type: i, yfov: l, znear: u, aspectRatio: n, zfar: h });
    } else if (i === "orthographic" && o) {
      const { xmag: n, ymag: l, zfar: h, znear: u } = o;
      t.dcamera = Object.assign({}, { name: r, type: i, xmag: n, ymag: l, zfar: h, znear: u });
    }
    return t.dcamera;
  }
  errorMiss(e, t) {
    throw new Error(e + t);
  }
};
var _qe = class _qe extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "_gltf");
  }
  async parseJson(e) {
    this._gltf = new Ca(), this._gltf = { ...this._gltf, ...e }, this._gltf.resources = {}, await Promise.all([this.load_gltf_bin(), this.load_gltf_textures()]);
    let t = new Sa(), r = await t.parse(this.initUrl, this._gltf, this._gltf.scene);
    return t.destory(), t = null, r ? (this.data = r.rootNode, r.rootNode) : (this._gltf = null, null);
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
  static getMeshNameCounter() {
    return function() {
      return `GLTF_NO_NAME_PRIMITIVE_${_qe._counter++}`;
    };
  }
  static getModelNameCounter() {
    let e = 0;
    return function() {
      return `GLTF_NO_NAME_MESH_${e++}`;
    };
  }
  static getTexCoordDefine(e) {
    return `UV_NUM ${e}`;
  }
  static getVertexColorDefine(e) {
    return `HAS_VERTEXCOLOR ${e}`;
  }
  static getBaseColorTextureDefine() {
    return "HAS_BASECOLORMAP";
  }
  static getMetalRoughnessDefine() {
    return "HAS_METALROUGHNESSMAP";
  }
  static getNormalMapDefine() {
    return "HAS_NORMALMAP";
  }
  static getEmissiveMapDefine() {
    return "HAS_EMISSIVEMAP";
  }
  static getOcclusionMapDefine() {
    return "HAS_OCCLUSIONMAP";
  }
  static getMorphTargetsDefine(e) {
    return `MORPH_TARGET_NUM ${e}`;
  }
  static getMorphtargetPositionDefine() {
    return "HAS_MORPH_POSITION";
  }
  static getMorphtargetNormalDefine() {
    return "HAS_MORPH_NORMAL";
  }
  static getMorphtargetTangentDefine() {
    return "HAS_MORPH_TANGENT";
  }
  static getJointsNumDefine(e) {
    return `JOINTS_NUM ${e}`;
  }
  static getJointVec8Define() {
    return "JOINT_VEC8";
  }
  static getHasNormalDefine() {
    return "HAS_NORMAL";
  }
  static getHasTangentDefine() {
    return "HAS_TANGENT";
  }
  static getHasNormalMapDefine() {
    return "HAS_NORMAL_MAP";
  }
  static getAlphaMaskDefine() {
    return "ALPHA_MASK";
  }
  static getAlphaBlendDefine() {
    return "ALPHA_BLEND";
  }
  async load_gltf_bin() {
    var _a3;
    if (this._gltf.buffers && this._gltf.buffers.length > 0) {
      let e = [];
      for (let t = 0; t < this._gltf.buffers.length; t++) {
        const r = this._gltf.buffers[t];
        if (r.uri.substring(0, 5) !== "data:") {
          let i = et.parseUrl(this.baseUrl, r.uri);
          ((_a3 = this.loaderFunctions) == null ? void 0 : _a3.onUrl) && (i = await this.loaderFunctions.onUrl(i));
          let a = new tt().loadBinData(i, this.loaderFunctions).then((o) => {
            this._gltf.resources[r.uri] = o;
          });
          e.push(a);
        }
      }
      await Promise.all(e);
    }
  }
  async load_gltf_textures() {
    var _a3;
    if (this._gltf, this._gltf.images) {
      let e = [];
      for (let t = 0; t < this._gltf.images.length; t++) {
        const r = this._gltf.images[t];
        if (r.uri) {
          let i = et.parseUrl(this.baseUrl, r.uri);
          ((_a3 = this.loaderFunctions) == null ? void 0 : _a3.onUrl) && (i = await this.loaderFunctions.onUrl(i));
          let a = new tt().loadAsyncBitmapTexture(i, this.loaderFunctions).then((o) => {
            o.name = et.getURLName(r.uri), this._gltf.resources[o.name] = o;
          });
          e.push(a);
        }
      }
      await Promise.all(e);
    }
  }
};
__publicField(_qe, "format", Ue.JSON);
__publicField(_qe, "_counter", 0);
__publicField(_qe, "defaultMaterial", { name: "GLTF_DEFAULT_MATERIAL", alphaCutoff: 0.33, alphaMode: "MASK", pbrMetallicRoughness: { name: "GLTF_DEFAULT_MATERIAL", defines: [], doubleSided: false, baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1, emissiveFactor: [0, 0, 0] } });
var qe = _qe;
var Ph = class {
  constructor(e) {
    __publicField(this, "gltf");
    __publicField(this, "subParser");
    this.gltf = e.gltf, this.subParser = e;
  }
  async parse(e) {
    const t = this.gltf.meshes[e];
    if (!t)
      return this.errorMiss("mesh", e);
    if (t.isParsed)
      return t.dprimitives;
    const r = t.primitives, i = t.extras, a = [];
    for (let o = 0; o < r.length; o++) {
      const n = r[o], { attributes: l, indices: h, material: u, mode: c, name: f, targets: g, morphTargetsRelative: m, extensions: A } = n;
      let _ = t.name;
      for (let B in l)
        _ += B;
      _ += `indices:${h}`, _ += `material:${u}`;
      const x = { attribArrays: { indices: [] }, weights: [], defines: [], material: null, drawMode: null, meshName: null, modelName: null, morphTargetsRelative: false, targetNames: i ? i.targetNames : null };
      let C = false, S = 0, I = false, T;
      A && A.KHR_draco_mesh_compression && (T = await so.apply(this.subParser, n));
      for (const B in l) {
        const R = T ? T[B] : this.parseAccessor(l[B]);
        if (R) {
          let E;
          switch (B) {
            case "POSITION":
              E = D.position;
              break;
            case "NORMAL":
              E = D.normal, C = true;
              break;
            case "TEXCOORD_0":
              E = D.uv, S++;
              break;
            case "JOINTS_0":
              E = D.joints0;
              break;
            case "JOINTS_1":
              E = D.joints1, I = true;
              break;
            case "WEIGHTS_0":
              E = D.weights0;
              break;
            case "WEIGHTS_1":
              E = D.weights1;
              break;
            default:
              E = B;
          }
          x.attribArrays[E] = R;
        }
      }
      if (C && x.defines.push(qe.getHasNormalDefine()), S && x.defines.push(qe.getTexCoordDefine(S)), I && x.defines.push(qe.getJointVec8Define()), h !== void 0) {
        const B = T ? T.indices : this.parseAccessor(h);
        B && (x.attribArrays.indices = B);
      }
      const b = await this.parseMaterial(u);
      if (b && (x.material = b, x.defines = x.defines.concat(b.defines)), x.drawMode = c === void 0 ? 4 : c, x.meshName = () => _, x.modelName = t.name || qe.getModelNameCounter(), g) {
        x.defines.push(qe.getMorphTargetsDefine(g.length)), x.morphTargetsRelative = true;
        let B = false, R = false, E = false;
        for (let F = 0; F < g.length; F++) {
          const k = g[F];
          Object.keys(k).forEach((V) => {
            const j = this.parseAccessor(k[V]);
            if (j) {
              let te;
              switch (V) {
                case "POSITION":
                  te = Vt.MORPH_POSITION_PREFIX + F, B = true;
                  break;
                case "NORMAL":
                  te = Vt.MORPH_NORMAL_PREFIX + F, R = true;
                  break;
                case "TANGENT":
                  te = Vt.MORPH_TANGENT_PREFIX + F, E = true;
                  break;
                default:
                  te = false;
              }
              te ? x.attribArrays[te] = j : console.error(`glTF has unsupported morph target attribute ${V}`);
            }
          });
        }
        B && x.defines.push(qe.getMorphtargetPositionDefine()), R && x.defines.push(qe.getMorphtargetNormalDefine()), E && x.defines.push(qe.getMorphtargetTangentDefine()), x.weights = t.weights || new Array(g.length).fill(0);
      }
      a.push(x);
    }
    return t.dprimitives = a, t.isParsed = true, t.dprimitives;
  }
  parseAccessor(e) {
    return this.subParser.parseAccessor(e);
  }
  parseMaterial(e) {
    return this.subParser.parseMaterial(e);
  }
  errorMiss(e, t) {
    throw new Error(e + t);
  }
};
var Mh = class {
  constructor(e) {
    __publicField(this, "gltf");
    __publicField(this, "subParser");
    this.gltf = e.gltf, this.subParser = e;
  }
  async parse(e) {
    let t;
    if (e == null ? t = qe.defaultMaterial : t = this.gltf.materials[e], !t)
      return this.errorMiss("material", e);
    if (t.isParsed)
      return t.dmaterial;
    let { name: r, pbrMetallicRoughness: i, normalTexture: a, occlusionTexture: o, emissiveTexture: n, emissiveFactor: l, alphaMode: h, alphaCutoff: u, doubleSided: c, extensions: f } = t;
    const g = { name: r, defines: [], doubleSided: !!c, baseColorFactor: [1, 1, 1, 1], emissiveFactor: null, alphaCutoff: 0, enableBlend: false, baseColorTexture: null, metallicRoughnessTexture: null, normalTexture: null, occlusionTexture: null, emissiveTexture: null, transformUV1: null, transformUV2: null, extensions: null };
    if (i) {
      const { baseColorFactor: m, metallicFactor: A, roughnessFactor: _, baseColorTexture: x, metallicRoughnessTexture: C } = i;
      if (Object.assign(g, { baseColorFactor: m || [1, 1, 1, 1], metallicFactor: A === void 0 ? 1 : A, roughnessFactor: _ === void 0 ? 0.5 : _ }), x) {
        let S = x.extensions;
        if (S) {
          let T = S.KHR_texture_transform;
          T && (g.transformUV1 = new G(T.offset ? T.offset[0] : 0, T.offset ? T.offset[1] : 0, T.scale ? T.scale[0] : 1, T.scale ? T.scale[1] : 1));
        }
        const I = await this.parseTexture(x.index);
        I ? g.baseColorTexture = I : g.baseColorTexture = p.res.redTexture;
      }
      if (C) {
        const S = await this.parseTexture(C.index);
        S ? g.metallicRoughnessTexture = S : g.metallicRoughnessTexture = p.res.blackTexture;
      }
    } else
      Object.assign(g, { baseColorFactor: [1, 1, 1, 1], metallicFactor: 0, roughnessFactor: 0.5 });
    if (g.baseColorFactor && g.baseColorFactor[3] < 1 && (h = h === "MASK" ? "MASK" : "BLEND"), h && h !== "OPAQUE" && (h === "MASK" && (g.defines.push(qe.getAlphaMaskDefine()), g.alphaCutoff = u === void 0 ? 0.5 : u), h === "BLEND" && (g.defines.push(qe.getAlphaBlendDefine()), g.enableBlend = true)), a) {
      const m = await this.parseTexture(a.index);
      m ? g.normalTexture = m : g.normalTexture = p.res.normalTexture;
    }
    if (o) {
      const m = await this.parseTexture(o.index);
      m && (g.occlusionTexture = m);
    }
    if (l && (g.emissiveFactor = l), n) {
      const m = await this.parseTexture(n.index);
      m ? g.emissiveTexture = m : g.emissiveTexture = p.res.blackTexture;
    }
    return f && (g.extensions = f), t.isParsed = true, t.dmaterial = g, g;
  }
  async parseTexture(e) {
    return this.subParser.parseTexture(e);
  }
  errorMiss(e, t) {
    throw new Error(e + t);
  }
};
var Rh = class {
  constructor(e) {
    __publicField(this, "gltf");
    __publicField(this, "subParser");
    this.gltf = e.gltf, this.subParser = e;
  }
  parse(e) {
    const t = this.gltf.skins[e];
    if (!t)
      return this.errorMiss("skin", e);
    if (t.isParsed)
      return t.dskin;
    const { name: r, joints: i, inverseBindMatrices: a, skeleton: o } = t;
    if (!i)
      return this.errorMiss("skin.joints", e);
    t.isParsed = true, t.dskin = false;
    let n = { name: r, skeleton: null, inverseBindMatrices: null, joints: i, defines: [qe.getJointsNumDefine(i.length)] };
    if (o)
      n.skeleton = o;
    else {
      var l = -1;
      for (let h = 0; h < this.gltf.nodes.length; h++)
        if (this.gltf.nodes[h].name == "root") {
          l = h;
          break;
        }
      if (l == -1) {
        let h = this.gltf.scenes[this.gltf.scene];
        l = h.nodes[h.nodes.length - 1];
      }
      n.skeleton = l;
    }
    if (n.inverseBindMatrices = Vt.IDENTITY_INVERSE_BIND_MATRICES, a !== void 0) {
      const h = this.parseAccessor(a);
      if (h) {
        const u = h.data, c = [];
        for (let f = 0; f < u.length; f += 16)
          c.push(u.slice(f, f + 16));
        n.inverseBindMatrices = c;
      } else
        n = null;
    }
    return t.dskin = n, t.dskin;
  }
  parseAccessor(e) {
    return this.subParser.parseAccessor(e);
  }
  errorMiss(e, t) {
    throw new Error(e + t);
  }
};
var Uh = class {
  constructor(e = "") {
    __publicField(this, "name", "");
    __publicField(this, "index", 0);
    __publicField(this, "instanceID", "");
    __publicField(this, "parent", null);
    __publicField(this, "scale", new d());
    __publicField(this, "rotation", new H());
    __publicField(this, "translation", new d());
    this.name = e;
  }
};
var Lh = class {
  constructor(e = []) {
    __publicField(this, "joints");
    this.joints = e;
  }
  get numJoint() {
    return this.joints.length;
  }
  addJoint(e) {
    e.index = this.joints.push(e) - 1;
  }
  getJointName(e) {
    return this.joints[e].name;
  }
  getJointParentIndex(e) {
    let t = this.joints[e];
    return t.parent ? t.parent.index : -1;
  }
  getJointByName(e) {
    for (let t of this.joints)
      if (t.name == e)
        return t;
    return null;
  }
};
var oo = class {
  constructor(e, t = false) {
    __publicField(this, "index");
    __publicField(this, "worldMatrix");
    this.index = e, this.worldMatrix = new P(!t);
  }
};
var bi = class {
  constructor(e, t = false) {
    __publicField(this, "time");
    __publicField(this, "_skeleton");
    __publicField(this, "_jointsPose");
    __publicField(this, "mJointMatrixIndexTable");
    this._skeleton = e, this._jointsPose = new Array(e.numJoint), this.mJointMatrixIndexTable = new Array(e.numJoint);
    for (let r = 0; r < e.numJoint; r++) {
      let i = new oo(r, t);
      this._jointsPose[r] = i, this.mJointMatrixIndexTable[r] = i.worldMatrix.index;
    }
  }
  buildSkeletonPose(e) {
    let t = new d(), r = new H(), i = new d(), a = new Array(this._skeleton.numJoint);
    this.time = e[11] > 0 ? e[11] : e[24];
    for (let o = 0; o < this._skeleton.numJoint; o++) {
      let n = 12 * o * 4, l = new Float32Array(e.buffer, e.byteOffset + n, 12), h = new P();
      t.set(l[0], l[1], l[2]), r.set(l[4], l[5], l[6], l[7]), i.set(l[8], l[9], l[10]), fa(r.getEulerAngles(), i, t, h), a[o] = h;
      let u = new oo(o);
      const c = this._skeleton.getJointParentIndex(o);
      if (c < 0)
        u.worldMatrix.copyFrom(h);
      else {
        let f = this._jointsPose[c];
        ll(f.worldMatrix, h, u.worldMatrix);
      }
      this._jointsPose[o] = u;
    }
  }
  get numJoint() {
    return this._skeleton.numJoint;
  }
  get joints() {
    return this._jointsPose;
  }
  get jointMatrixIndexTable() {
    return this.mJointMatrixIndexTable;
  }
  lerp(e, t, r) {
    if (e && t)
      for (let i = 0; i < this._jointsPose.length; i++) {
        let a = e._jointsPose[i], o = t._jointsPose[i];
        this._jointsPose[i].worldMatrix.lerp(a.worldMatrix, o.worldMatrix, r);
      }
    else
      for (let i = 0; i < this._jointsPose.length; i++) {
        let a = e._jointsPose[i];
        this._jointsPose[i].worldMatrix.copyFrom(a.worldMatrix);
      }
  }
  copyFrom(e) {
    for (let t = 0; t < this._jointsPose.length; t++)
      this._jointsPose[t].worldMatrix.copyFrom(e._jointsPose[t].worldMatrix);
  }
  reset() {
    for (let e = 0; e < this._jointsPose.length; e++)
      this._jointsPose[e].worldMatrix.identity();
  }
};
var Oh = class extends ze {
  constructor(e, t) {
    super();
    __publicField(this, "skeletonAnimation");
    this.type = e, this.time = t;
  }
};
var ja = class _ja {
  constructor(e, t, r, i) {
    __publicField(this, "name", "");
    __publicField(this, "_skeleton");
    __publicField(this, "_skeletonPoses");
    __publicField(this, "_animationClipData");
    __publicField(this, "_events");
    if (this.name = e, this._skeleton = t, this._animationClipData = i, r > 0 && i) {
      this._skeletonPoses = new Array(r);
      let a = 12 * t.numJoint;
      for (let o = 0; o < r; o++) {
        let n = a * o * 4, l = new Float32Array(i.buffer, n, a), h = new bi(t);
        h.buildSkeletonPose(l), this._skeletonPoses[o] = h;
      }
    }
  }
  get totalTime() {
    return this._skeletonPoses[this._skeletonPoses.length - 1].time;
  }
  get frameRate() {
    return this.totalTime / this._skeletonPoses.length;
  }
  get skeleton() {
    return this._skeleton;
  }
  get numFrame() {
    return this._skeletonPoses.length - 1;
  }
  get animationClipData() {
    return this._animationClipData;
  }
  getSkeletonPose(e) {
    return this._skeletonPoses[e];
  }
  getLerpSkeletonPose(e, t, r, i) {
    let a = this.getSkeletonPose(e), o = this.getSkeletonPose(t);
    return i.lerp(a, o, r), i;
  }
  createSubClip(e, t, r) {
    var i = new _ja(e, this._skeleton, 0, null);
    const a = Math.max(Math.floor(t / this.frameRate), 0), o = Math.min(Math.floor(r / this.frameRate), this._skeletonPoses.length - 1);
    i._skeletonPoses = this._skeletonPoses.slice(a, o);
    const n = 12 * this._skeleton.numJoint * 4;
    return this._animationClipData = new Float32Array(this._animationClipData, a * n, (o - a) * n), i;
  }
  addEvent(e, t) {
    this._events || (this._events = new Array()), this._events.push(new Oh(e, t));
  }
  removeEvent(e) {
    this._events && (this._events = this._events.filter((t) => t.type != e));
  }
  getEvents() {
    return this._events;
  }
};
var no = class {
  constructor(e) {
    __publicField(this, "gltf");
    __publicField(this, "subParser");
    this.gltf = e.gltf, this.subParser = e;
  }
  parse(e) {
    let t = new Lh();
    return this.buildSkeleton(t, void 0, e), t;
  }
  parseSkeletonAnimation(e, t) {
    let r = this.subParser.parseAccessor(t.samplers[0].input), i = r.data.length, a = r.data[1] - r.data[0];
    r.data[r.data.length - 1];
    let o = 12 * e.numJoint, n = new Float32Array(o * i);
    for (var l = 0; l < e.numJoint; l++)
      for (var h = 0; h < i; h++) {
        var u = o * h + 12 * l;
        n[u + 0] = 1, n[u + 1] = 1, n[u + 2] = 1, n[u + 3] = 1;
      }
    for (let A of t.channels) {
      let _ = t.samplers[A.sampler];
      const x = this.subParser.parseAccessor(_.input), C = this.subParser.parseAccessor(_.output);
      let S = A.target.node, I = A.target.path, T = this.gltf.nodes[S];
      if (!T)
        continue;
      let b = e.getJointByName(T.name);
      if (b)
        switch (I) {
          case "scale":
            if (i * C.numComponents == C.data.length)
              for (var h = 0; h < i; h++) {
                var c = h * C.numComponents, u = o * h + 12 * b.index;
                n[u + 0] = C.data[c + 0], n[u + 1] = C.data[c + 1], n[u + 2] = C.data[c + 2], n[u + 3] = 1;
              }
            else if (x.data.length == 2) {
              let B = 0;
              x.data[0];
              let R = x.data[1];
              var f = 0 * C.numComponents;
              d.HELP_0.set(C.data[f + 0], C.data[f + 1], C.data[f + 2]);
              var g = 1 * C.numComponents;
              d.HELP_1.set(C.data[g + 0], C.data[g + 1], C.data[g + 2]);
              for (var h = 0; h < i; h++) {
                let F = B / R;
                d.HELP_2.lerp(d.HELP_0, d.HELP_1, F);
                var u = o * h + 12 * b.index;
                n[u + 0] = d.HELP_2.x, n[u + 1] = d.HELP_2.y, n[u + 2] = d.HELP_2.z, n[u + 3] = 1, B += a;
              }
            } else
              throw new Error("Unsupported animation sampler interpolation.");
            break;
          case "rotation":
            if (i * C.numComponents == C.data.length)
              for (var h = 0; h < i; h++) {
                var c = h * C.numComponents, u = o * h + 12 * b.index + 4;
                n[u + 0] = C.data[c + 0], n[u + 1] = C.data[c + 1], n[u + 2] = C.data[c + 2], n[u + 3] = C.data[c + 3];
              }
            else if (x.data.length == 2) {
              let B = 0;
              x.data[0];
              let R = x.data[1];
              var f = 0 * C.numComponents;
              d.HELP_0.set(C.data[f + 0], C.data[f + 1], C.data[f + 2], C.data[f + 3]);
              var g = 1 * C.numComponents;
              d.HELP_1.set(C.data[g + 0], C.data[g + 1], C.data[g + 2], C.data[g + 3]);
              for (var h = 0; h < i; h++) {
                let V = B / R;
                d.HELP_2.lerp(d.HELP_0, d.HELP_1, V);
                var u = o * h + 12 * b.index + 4;
                n[u + 0] = d.HELP_2.x, n[u + 1] = d.HELP_2.y, n[u + 2] = d.HELP_2.z, n[u + 3] = d.HELP_2.w, B += a;
              }
            } else
              throw new Error("Unsupported animation sampler interpolation.");
            break;
          case "translation":
            if (i * C.numComponents == C.data.length)
              for (var h = 0; h < i; h++) {
                var c = h * C.numComponents, u = o * h + 12 * b.index + 8;
                n[u + 0] = C.data[c + 0], n[u + 1] = C.data[c + 1], n[u + 2] = C.data[c + 2], n[u + 3] = x.data[h * x.numComponents];
              }
            else if (x.data.length == 2) {
              let B = 0;
              x.data[0];
              let R = x.data[1];
              var f = 0 * C.numComponents;
              d.HELP_0.set(C.data[f + 0], C.data[f + 1], C.data[f + 2]);
              var g = 1 * C.numComponents;
              d.HELP_1.set(C.data[g + 0], C.data[g + 1], C.data[g + 2]);
              for (var h = 0; h < i; h++) {
                let V = B / R;
                d.HELP_2.lerp(d.HELP_0, d.HELP_1, V);
                var u = o * h + 12 * b.index + 8;
                n[u + 0] = d.HELP_2.x, n[u + 1] = d.HELP_2.y, n[u + 2] = d.HELP_2.z, n[u + 3] = B, B += a;
              }
            } else
              throw new Error("Unsupported animation sampler interpolation.");
            break;
        }
    }
    return new ja(t.name, e, i, n);
  }
  buildSkeleton(e, t, r, i = 0) {
    let a = this.gltf.nodes[r];
    a.name || (a.name = "Node_" + r);
    let o = new Uh(a.name);
    if (o.parent = t, a.scale && o.scale.set(a.scale[0], a.scale[1], a.scale[2]), a.rotation && o.rotation.set(a.rotation[0], a.rotation[1], a.rotation[2], a.rotation[3]), a.translation && o.translation.set(a.translation[0], a.translation[1], a.translation[2]), e.addJoint(o), a.children)
      for (let n of a.children)
        this.buildSkeleton(e, o, n, i + 1);
  }
};
var Fh = class {
  constructor(e) {
    __publicField(this, "loop", true);
    __publicField(this, "speed", 1);
    __publicField(this, "t", 0);
    __publicField(this, "time", 0);
    __publicField(this, "weight", 0);
    __publicField(this, "currFrame", 0);
    __publicField(this, "lastFrame", -1);
    __publicField(this, "nextFrame", 0);
    __publicField(this, "clip");
    __publicField(this, "animation");
    __publicField(this, "_isEnd", false);
    __publicField(this, "_currSkeletonPose");
    this.clip = e, this._currSkeletonPose = new bi(this.clip.skeleton);
  }
  reset() {
    this.time = 0, this.weight = 0, this._isEnd = false;
  }
  get name() {
    return this.clip.name;
  }
  get currSkeletonPose() {
    return this._currSkeletonPose;
  }
  update(e) {
    this.time = (this.time + e * this.speed) % this.clip.totalTime;
    let t = this.time / this.clip.frameRate;
    if (this.currFrame = Math.trunc(t), this.t = t - this.currFrame, this.currFrame < 0 && (this.currFrame = this.clip.numFrame + this.currFrame), this.time >= 0 ? this.nextFrame = (this.currFrame + 1) % this.clip.numFrame : (this.nextFrame = this.currFrame - 1, this.nextFrame < 0 && (this.nextFrame = this.clip.numFrame + this.nextFrame), this.t = 1 - this.t), this._isEnd)
      this.currFrame = this.nextFrame = this.speed < 0 ? 0 : this.clip.numFrame - 1;
    else if (this.currFrame != this.lastFrame) {
      let a = this.speed < 0 ? 0 : this.clip.numFrame;
      this.currFrame == a && (this.loop ? (this.currFrame = 0, this.nextFrame = 1, this.time = this.t = 0) : (this.currFrame = this.nextFrame = this.speed < 0 ? 0 : this.clip.numFrame - 1, this._isEnd = true));
      var r = this.clip.getEvents();
      if (r)
        for (let o of r) {
          var i = Math.floor(o.time / this.clip.frameRate);
          if (i = Math.min(i, this.clip.numFrame), i = Math.max(i, 0), i == this.currFrame) {
            o.skeletonAnimation = this.animation, this.animation.eventDispatcher.dispatchEvent(o);
            break;
          }
        }
      this.lastFrame = this.currFrame;
    }
    this.clip.getLerpSkeletonPose(this.currFrame, this.nextFrame, this.t, this._currSkeletonPose);
  }
};
var ig = Object.defineProperty;
var ag = Object.getOwnPropertyDescriptor;
var sg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? ag(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && ig(e, t, i), i;
};
var Ht = class extends _e {
  constructor() {
    super();
    __publicField(this, "isPlaying", true);
    __publicField(this, "timeScale", 1);
    __publicField(this, "_skeleton");
    __publicField(this, "_clips", []);
    __publicField(this, "_clipStates", /* @__PURE__ */ new Map());
    __publicField(this, "_mixSkeletonPose");
    __publicField(this, "_mixTempSkeletonPose");
    __publicField(this, "_currentClipState");
    __publicField(this, "_bindList", []);
    __publicField(this, "_jointMatrixIndexTableBuffer");
    __publicField(this, "_crossFadeState");
  }
  start() {
  }
  get currName() {
    return this._currentClipState ? this._currentClipState.name : "";
  }
  set skeleton(s) {
    this._skeleton = s, this._mixSkeletonPose = new bi(this._skeleton, true), this._mixTempSkeletonPose = new bi(this._skeleton);
    const e = new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);
    this._jointMatrixIndexTableBuffer = new $(this._skeleton.numJoint * 4, 0, e);
  }
  get skeleton() {
    return this._skeleton;
  }
  get finalSkeletonPose() {
    return this._mixSkeletonPose;
  }
  get jointMatrixIndexTableBuffer() {
    return this._jointMatrixIndexTableBuffer;
  }
  getJointIndexTable(s) {
    let e = new Array();
    for (let t = 0; t < s.length; t++) {
      const r = s[t];
      let i = this._skeleton.getJointByName(r);
      e[t] = i ? i.index : -1;
    }
    return e;
  }
  addAnimationClip(s) {
    if (!this._clipStates.has(s.name)) {
      this._clips.push(s);
      let e = new Fh(s);
      e.animation = this, this._clipStates.set(s.name, e), this._currentClipState || this.setCurrentClipState(e);
    }
  }
  getAnimationClip(s) {
    var e = this.getAnimationClipState(s);
    return e ? e.clip : null;
  }
  getAnimationClips() {
    return this._clips;
  }
  getAnimationClipState(s) {
    return this._clipStates.has(s) ? this._clipStates.get(s) : null;
  }
  getAnimationClipStates() {
    return this._clipStates;
  }
  pause() {
    this.isPlaying = false;
  }
  resume() {
    this.isPlaying = true;
  }
  play(s, e = 1, t = false) {
    if (this._currentClipState && this._currentClipState.name == s)
      return t && this._currentClipState.reset(), false;
    let r = this.getAnimationClipState(s);
    return r ? (r.speed = e, r.reset(), this._clipStates.forEach((i, a) => {
      i.weight = 0;
    }), this.setCurrentClipState(r), true) : false;
  }
  crossFade(s, e) {
    if (e < 0.01) {
      this.play(s);
      return;
    }
    if (this._currentClipState.name == s)
      return;
    let t = this.getAnimationClipState(s);
    t && (t.reset(), this._crossFadeState ? (this._crossFadeState.inClip && (this._crossFadeState.inClip.weight = 0), this._crossFadeState.outClip && (this._crossFadeState.outClip.weight = 0), this._crossFadeState.reset(t, this._currentClipState, e)) : this._crossFadeState = new og(t, this._currentClipState, e), this._currentClipState = t);
  }
  setAnimIsLoop(s, e) {
    this._clipStates.has(s) && (this._clipStates.get(s).loop = e);
  }
  addJointBind(s, e) {
    this._bindList.push({ jointName: s, obj: e });
  }
  removeJointBind(s) {
    for (let e = 0; e < this._bindList.length; e++)
      if (this._bindList[e].obj == s) {
        this._bindList.splice(e, 1);
        break;
      }
  }
  onUpdate() {
    if (!this.isPlaying)
      return;
    let s = ce.delta * 1e-3 * this.timeScale;
    this._crossFadeState && this._crossFadeState.update(s);
    var e = 0, t = [];
    if (this._clipStates.forEach((i, a) => {
      i.weight > 0 && (i.update(s), e += i.weight, t.push(i));
    }), t.length > 0) {
      this._mixSkeletonPose.copyFrom(t[0].currSkeletonPose);
      for (var r = 1; r < t.length; ++r) {
        const i = t[r];
        this._mixTempSkeletonPose.lerp(this._mixSkeletonPose, i.currSkeletonPose, i.weight / e), this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose);
      }
    }
  }
  cloneTo(s) {
    let e = s.addComponent(Ht);
    e.skeleton = this.skeleton;
    for (var t = 0; t < this._clips.length; ++t)
      e.addAnimationClip(this._clips[t]);
  }
  setCurrentClipState(s) {
    this._currentClipState != s && (this._currentClipState = s, this._currentClipState.weight = 1);
  }
};
Ht = sg([_t(Ht, "SkeletonAnimationComponent")], Ht);
var og = class {
  constructor(e, t, r) {
    __publicField(this, "inClip");
    __publicField(this, "outClip");
    __publicField(this, "currentTime");
    __publicField(this, "crossFadeTime");
    this.reset(e, t, r);
  }
  reset(e, t, r) {
    this.inClip = e, this.outClip = t, this.currentTime = 0, this.crossFadeTime = r;
  }
  update(e) {
    !this.inClip || !this.outClip || (this.currentTime += e, this.inClip.weight = Math.min(Math.abs(this.currentTime % this.crossFadeTime) / this.crossFadeTime, 1), this.outClip.weight = 1 - this.inClip.weight, Math.abs(this.currentTime) >= this.crossFadeTime && (this.inClip.weight = 1, this.outClip.weight = 0, this.inClip = null, this.outClip = null));
  }
};
var lo = class {
  static add(e) {
    this.list.indexOf(e) == -1 && this.list.push(e);
  }
  static remove(e) {
    let t = this.list.indexOf(e);
    t != -1 && this.list.splice(t, 1);
  }
};
__publicField(lo, "list", []);
var Ei = class extends _e {
  constructor() {
    super();
    __publicField(this, "name");
    __publicField(this, "size", 1);
    __publicField(this, "lightData");
    __publicField(this, "dirFix", 1);
    __publicField(this, "bindOnChange");
    __publicField(this, "needUpdateShadow", true);
    __publicField(this, "realTimeShadow", true);
    __publicField(this, "_castGI", false);
    __publicField(this, "_castShadow", false);
    __publicField(this, "_iesProfiles");
  }
  init() {
    this.transform.object3D.bound = new ge(new d(), new d()), this.lightData = new da(), this.lightData.lightMatrixIndex = this.transform.worldMatrix.index;
  }
  onChange() {
    this.bindOnChange && this.bindOnChange(), this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition, new d(this.size, this.size, this.size)), this._castGI && (z.instance.state.giLightingChange = true), this._castShadow ? (this.needUpdateShadow = true, lt.addShadowLight(this)) : lt.removeShadowLight(this);
  }
  start() {
    this.transform.onPositionChange = () => this.onPositionChange(), this.transform.onScaleChange = () => this.onScaleChange(), this.transform.onRotationChange = () => this.onRotChange(), this.onPositionChange(), this.onRotChange(), this.onScaleChange();
  }
  onPositionChange() {
    this.lightData.lightPosition.copyFrom(this.transform.worldPosition);
  }
  onRotChange() {
    this.dirFix == 1 ? this.lightData.direction.copyFrom(this.transform.forward) : this.lightData.direction.copyFrom(this.transform.back), this.lightData.lightTangent.copyFrom(this.transform.up), this.onChange();
  }
  onScaleChange() {
    this.onChange();
  }
  onEnable() {
    this.onChange(), z.instance.addLight(this.transform.scene3D, this);
  }
  onDisable() {
    this.onChange(), z.instance.removeLight(this.transform.scene3D, this), lt.removeShadowLight(this);
  }
  set iesProfiles(e) {
    this._iesProfiles = e, this.lightData.iesIndex = e.index, zt.use = true, this.onChange();
  }
  get iesProfile() {
    return this._iesProfiles;
  }
  get r() {
    return this.lightData.lightColor.r;
  }
  set r(e) {
    this.lightData.lightColor.r = e, this.onChange();
  }
  get g() {
    return this.lightData.lightColor.g;
  }
  set g(e) {
    this.lightData.lightColor.g = e, this.onChange();
  }
  get b() {
    return this.lightData.lightColor.b;
  }
  set b(e) {
    this.lightData.lightColor.b = e, this.onChange();
  }
  get lightColor() {
    return this.lightData.lightColor;
  }
  set lightColor(e) {
    this.lightData.lightColor = e, this.onChange();
  }
  get color() {
    return this.lightData.lightColor;
  }
  set color(e) {
    this.lightData.lightColor = e, this.onChange();
  }
  get intensity() {
    return this.lightData.intensity;
  }
  set intensity(e) {
    this.lightData.intensity = e, this.onChange();
  }
  set castShadow(e) {
    e != this._castShadow && (this._castShadow = e, this.onChange());
  }
  get castShadow() {
    return this._castShadow;
  }
  get shadowIndex() {
    return this.lightData.castShadowIndex;
  }
  get castGI() {
    return this._castGI;
  }
  set castGI(e) {
    e ? lo.add(this) : lo.remove(this), this._castGI = e, e && this.onChange();
  }
  get direction() {
    return this.lightData.direction;
  }
  destroy(e) {
    this.bindOnChange = null, z.instance.removeLight(this.transform.scene3D, this), lt.removeShadowLight(this), this.transform.eventDispatcher.removeEventListener(ht.ROTATION_ONCHANGE, this.onRotChange, this), this.transform.eventDispatcher.removeEventListener(ht.SCALE_ONCHANGE, this.onScaleChange, this), super.destroy(e);
  }
};
var ng = Object.defineProperty;
var lg = Object.getOwnPropertyDescriptor;
var hg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? lg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && ng(e, t, i), i;
};
var Bi = class extends Ei {
  constructor() {
    super();
    __publicField(this, "shadowCamera");
  }
  init() {
    super.init(), this.object3D.name == "" && (this.object3D.name = "DirectionLight_" + gt()), this.radius = Number.MAX_SAFE_INTEGER, this.lightData.lightType = Pe.DirectionLight, this.lightData.linear = 0, this.lightData.quadratic = 0.3;
  }
  start() {
    super.start(), this.castGI = true;
  }
  get radius() {
    return this.lightData.range;
  }
  set radius(s) {
    this.lightData.range = s, this.onChange();
  }
  get indirect() {
    return this.lightData.quadratic;
  }
  set indirect(s) {
    this.lightData.quadratic = s, this.onChange();
  }
  debug() {
  }
};
Bi = hg([_t(Bi, "DirectLight")], Bi);
var ug = Object.defineProperty;
var cg = Object.getOwnPropertyDescriptor;
var fg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? cg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && ug(e, t, i), i;
};
var Ti = class extends Ei {
  constructor() {
    super();
  }
  init() {
    super.init(), this.lightData.lightType = Pe.PointLight, this.object3D.name == "" && (this.object3D.name = "PointLight" + gt());
  }
  get range() {
    return this.lightData.range;
  }
  set range(s) {
    this.lightData.range = s, this.onChange();
  }
  get at() {
    return this.lightData.linear;
  }
  set at(s) {
    this.lightData.linear = s, this.onChange();
  }
  get radius() {
    return this.lightData.radius;
  }
  set radius(s) {
    this.lightData.radius = s, this.onChange();
  }
  get quadratic() {
    return this.lightData.quadratic;
  }
  set quadratic(s) {
    this.lightData.quadratic = s, this.onChange();
  }
  start() {
    this.transform.rotationX = 90, super.start();
  }
  onUpdate() {
  }
  onGraphic(s) {
  }
  debug() {
  }
  debugDraw(s) {
  }
};
Ti = fg([_t(Ti, "PointLight")], Ti);
var dg = Object.defineProperty;
var gg = Object.getOwnPropertyDescriptor;
var pg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? gg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && dg(e, t, i), i;
};
var Di = class extends Ei {
  constructor() {
    super();
  }
  init() {
    super.init(), this.lightData.lightType = Pe.SpotLight, this.object3D.name == "" && (this.object3D.name = "SpotLight" + gt());
  }
  get innerAngle() {
    return this.lightData.innerAngle / this.lightData.outerAngle * 100;
  }
  set innerAngle(s) {
    this.lightData.innerAngle = W(s, 0, 100) / 100 * this.lightData.outerAngle, this.onChange();
  }
  get outerAngle() {
    return this.lightData.outerAngle * Yr * 2;
  }
  set outerAngle(s) {
    this.lightData.outerAngle = W(s, 1, 179) * me * 0.5, this.onChange();
  }
  get radius() {
    return this.lightData.radius;
  }
  set radius(s) {
    this.lightData.radius = s, this.onChange();
  }
  get range() {
    return this.lightData.range;
  }
  set range(s) {
    this.lightData.range = s, this.onChange();
  }
  get at() {
    return this.lightData.linear;
  }
  set at(s) {
    this.lightData.linear = s, this.onChange();
  }
  start() {
    super.start(), this.lightData.lightType = Pe.SpotLight;
  }
  onUpdate() {
  }
  onGraphic(s) {
  }
  debug() {
  }
  debugDraw(s) {
  }
};
Di = pg([_t(Di, "SpotLight")], Di);
var mg = Object.defineProperty;
var Ag = Object.getOwnPropertyDescriptor;
var vg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Ag(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && mg(e, t, i), i;
};
var Jr = class extends J {
  constructor() {
    super();
    __publicField(this, "skinJointsName");
    __publicField(this, "mInverseBindMatrixData");
    __publicField(this, "mInverseBindMatrixBuffer");
    __publicField(this, "mSkeletonAnimation");
    __publicField(this, "mJointIndexTableBuffer");
    this.addRendererMask(De.SkinnedMesh);
  }
  start() {
    if (super.start(), this.skeletonAnimation = this.object3D.getComponent(Ht), !this.skeletonAnimation) {
      let s = this.object3D.parentObject.parentObject.getComponentsInChild(Ht);
      s.length > 0 && (this.skeletonAnimation = s[0]);
      let e = this.object3D;
      for (; !this.skeletonAnimation && e; )
        this.skeletonAnimation = e.getComponentFromParent(Ht), e.parent && (e = e.parent.object3D);
    }
  }
  onEnable() {
    super.onEnable();
  }
  get skeletonAnimation() {
    return this.mSkeletonAnimation;
  }
  set skeletonAnimation(s) {
    if (this.mSkeletonAnimation = s, !!s && !this.mJointIndexTableBuffer) {
      let e = this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);
      this.mJointIndexTableBuffer = new $(e.length * 4, 0, new Float32Array(e)), this.mJointIndexTableBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
    }
  }
  get skinInverseBindMatrices() {
    return this.mInverseBindMatrixData;
  }
  set skinInverseBindMatrices(s) {
    this.mInverseBindMatrixData = s;
    var e = new Float32Array(s.length * 16);
    for (let t = 0; t < s.length; t++) {
      let r = t * 16, i = s[t];
      e.set(i, r);
    }
    this.mInverseBindMatrixBuffer = new $(e.byteLength, 0, e), this.mInverseBindMatrixBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
  }
  get inverseBindMatrixBuffer() {
    return this.mInverseBindMatrixBuffer;
  }
  get jointIndexTableBuffer() {
    return this.mJointIndexTableBuffer.buffer;
  }
  cloneTo(s) {
    let e = s.addComponent(Jr);
    e.geometry = this.geometry, e.material = this.material.clone(), e.castShadow = this.castShadow, e.castGI = this.castGI, e.receiveShadow = this.receiveShadow, e.rendererMask = this.rendererMask, e.skinJointsName = this.skinJointsName, e.skinInverseBindMatrices = this.skinInverseBindMatrices, e.mJointIndexTableBuffer = this.mJointIndexTableBuffer;
  }
  nodeUpdate(s, e, t, r) {
    for (let i = 0; i < this.materials.length; i++) {
      let o = this.materials[i].getPass(e);
      if (o)
        for (let n = 0; n < o.length; n++) {
          const l = o[n];
          !l.pipeline && this.mSkeletonAnimation && (l.setStorageBuffer("jointsMatrixIndexTable", this.mSkeletonAnimation.jointMatrixIndexTableBuffer), l.setStorageBuffer("jointsInverseMatrix", this.mInverseBindMatrixBuffer), l.setStorageBuffer("jointsIndexMapingTable", this.mJointIndexTableBuffer));
        }
    }
    super.nodeUpdate(s, e, t, r);
  }
};
Jr = vg([_t(Jr, "SkinnedMeshRenderer")], Jr);
var Nh = class {
  static apply(e, t, r) {
    let i = t.extensions;
    if (i && i.KHR_materials_clearcoat) {
      r.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
      let a = i.KHR_materials_clearcoat;
      "clearcoatFactor" in a && (t.clearcoatFactor = a.clearcoatFactor, r.clearcoatFactor = t.clearcoatFactor), "clearcoatRoughnessFactor" in a && (t.clearcoatRoughnessFactor = a.clearcoatRoughnessFactor, r.clearcoatRoughnessFactor = t.clearcoatRoughnessFactor);
    }
  }
};
var zh = class {
  static apply(e, t, r) {
    let i = t.extensions;
    i && i.KHR_materials_emissive_strength ? (r.emissiveIntensity = i.KHR_materials_emissive_strength.emissiveStrength * 0.5, r.emissiveMap == p.res.blackTexture && (r.emissiveMap = p.res.whiteTexture)) : r.emissiveIntensity = 1;
  }
};
var kh = class {
  static apply(e, t, r) {
    let i = t.extensions;
    i && i.KHR_materials_unlit ? r.supportLight = true : r.supportLight = false;
  }
};
var Gh = class {
  constructor(e) {
    __publicField(this, "gltf");
    __publicField(this, "subParser");
    __publicField(this, "_testCount", 8);
    __publicField(this, "_hasCastShadow", false);
    this.gltf = e.gltf, this.subParser = e;
  }
  async convertNodeToObject3D(e, t) {
    const r = new Y();
    if (r.name = e.name, r[Vt.GLTF_NODE_INDEX_PROPERTY] = e.nodeId, e.nodeObj = r, e.matrix && (e.translation = [0, 0, 0], e.rotation = [0, 0, 0, 1], e.scale = [1, 1, 1]), e.translation && (r.transform.x = e.translation[0], r.transform.y = e.translation[1], r.transform.z = e.translation[2]), e.rotation) {
      let i = new H();
      i.setFromArray(e.rotation), r.transform.localRotQuat = i;
    }
    if (e.scale && (r.transform.scaleX = e.scale[0], r.transform.scaleY = e.scale[1], r.transform.scaleZ = e.scale[2]), t.addChild(r), e.light && this.convertLight(e, r), e.primitives && this.convertprimitives(e, r), e.skeleton) {
      let i = r.addComponent(Ht);
      if (i) {
        i.skeleton = this.subParser.parseSkeleton(e.skeleton.skeleton);
        for (let a = 0; a < this.gltf.animations.length; a++) {
          let o = this.gltf.animations[a];
          o.name || (o.name = a.toString());
          let n = this.subParser.parseSkeletonAnimation(i.skeleton, o);
          i.addAnimationClip(n);
        }
      }
    }
    return r;
  }
  convertLight(e, t) {
    switch (e.light.type) {
      case "directional":
        let r = t.addComponent(Bi);
        t.name = e.light.name, r.intensity = e.light.intensity * 0.1, r.radius = Number.MAX_SAFE_INTEGER, r.dirFix = -1, this._hasCastShadow || (this._hasCastShadow = true, r.castShadow = this._hasCastShadow), r.lightColor = e.light.color ? new M(e.light.color[0], e.light.color[1], e.light.color[2]) : new M(1, 1, 1, 1), r.debug();
        break;
      case "point":
        if (this._testCount > 0) {
          let a = t.addComponent(Ti);
          a.name = e.light.name, a.intensity = e.light.intensity ? e.light.intensity * 8 * 2 : 1, a.radius = 8, a.at = 2, a.range = e.light.range ? e.light.range : 8, a.lightColor = e.light.color ? new M(e.light.color[0], e.light.color[1], e.light.color[2]) : new M(1, 1, 1, 1);
        }
        this._testCount--;
        break;
      case "spot":
        let i = t.addComponent(Di);
        i.name = e.light.name, i.intensity = e.light.intensity * 5, i.radius = 1, i.dirFix = -1, i.at = 2, i.range = e.light.range ? e.light.range : 8, i.outerAngle = e.light.spot.outerConeAngle * Yr, i.lightColor = e.light.color ? new M(e.light.color[0], e.light.color[1], e.light.color[2]) : new M(1, 1, 1, 1);
        break;
    }
  }
  convertprimitives(e, t) {
    for (let r = 0; r < e.primitives.length; r++) {
      const i = e.primitives[r];
      i.modelName;
      let a = i.material;
      a.name == null && (a.name = gt());
      let o, n = `matkey_${a.name}`;
      if (a && this.gltf.resources[n])
        o = this.gltf.resources[n];
      else {
        let f = o = new ar();
        if (this.gltf.resources[n] = f, f.name = a.name, i.material) {
          const { baseColorTexture: g, baseColorFactor: m, metallicFactor: A, roughnessFactor: _, doubleSided: x, metallicRoughnessTexture: C, normalTexture: S, occlusionTexture: I, emissiveTexture: T, emissiveFactor: b, enableBlend: B, alphaCutoff: R } = i.material;
          let E = f = this.applyMaterialExtensions(i.material, f);
          "enableBlend" in i.material && (i.material.enableBlend ? E.blendMode = re.SOFT_ADD : E.blendMode = re.NONE), "alphaCutoff" in i.material && R > 0 && R < 1 && (E.setUniformFloat("alphaCutoff", R), E.blendMode = re.NORMAL, E.transparent = true), i.material.transformUV1 && E.setUniformVector4("uvTransform_1", i.material.transformUV1), i.material.transformUV2 && E.setUniformVector4("uvTransform_2", i.material.transformUV2), E.setUniformColor("baseColor", new M(m[0], m[1], m[2], m[3])), E.setUniformFloat("roughness", _), E.setUniformFloat("metallic", A), E.setUniformFloat("ao", 1), E.doubleSide = x, g && E.setTexture("baseMap", g), S && E.setTexture("normalMap", S), C && E.setTexture("maskMap", C), I && C != I && E.setTexture("aoMap", I), T && E.setTexture("emissiveMap", T), b && (b[0] > 0 || b[1] > 0 || b[2] > 0) && (E.shader.getTexture("emissiveMap") || E.shader.setTexture("emissiveMap", p.res.whiteTexture), E.setUniformColor("emissiveColor", new M(b[0], b[1], b[2], b[3])));
        }
      }
      const { attribArrays: l, modelName: h, drawMode: u } = i;
      let c;
      if (!l.indices.data) {
        let f = [], g = l.position.data.length / 3 / 3;
        for (let m = 0; m < g; m++) {
          let A = m * 3;
          f.push(A + 2), f.push(A + 0), f.push(A + 1);
        }
        l.indices = { data: new Uint8Array(f), normalize: false, numComponents: 1 };
      }
      if (!l.normal) {
        let f = [], g = l.position.data.length / 3;
        for (let m = 0; m < g; m++)
          f.push(0), f.push(0), f.push(0);
        l.normal = { data: new Float32Array(f), normalize: false, numComponents: 3 };
      }
      if (l.indices.data && l.indices.data.length > 3) {
        let f = i.meshName();
        this.gltf.resources[f] ? c = this.gltf.resources[f] : (c || (c = this.createGeometryBase(f, l, i)), this.gltf.resources[f] = c);
        const g = new Y();
        if (g.name = h + r, this.gltf.animations && l[D.joints0] != null) {
          c || (c = this.createGeometryBase(h, l, i)), this.gltf.resources[f] = c;
          let m = this.gltf.nodes[e.skin.skeleton];
          if (m.dnode && m.dnode.nodeObj) {
            let x = m.dnode.nodeObj.addComponent(Ht);
            if (x) {
              x.skeleton = this.subParser.parseSkeleton(e.skin.skeleton);
              for (let C = 0; C < this.gltf.animations.length; C++) {
                let S = this.gltf.animations[C];
                S.name || (S.name = C.toString());
                let I = this.subParser.parseSkeletonAnimation(x.skeleton, S);
                x.addAnimationClip(I);
              }
            }
          } else
            m.dnode.skeleton = e.skin;
          let A = g.addComponent(Jr);
          A.castShadow = true, A.castGI = true, A.geometry = c, A.material = o, A.skinJointsName = this.parseSkinJoints(e.skin), A.skinInverseBindMatrices = e.skin.inverseBindMatrices;
        } else {
          c || (c = this.createGeometryBase(h, l, i)), this.gltf.resources[f] = c, c.hasAttribute(D.joints0) && c.vertexAttributeMap.delete(D.joints0);
          let m = g.addComponent(J);
          m.castShadow = true, m.castGI = true, m.geometry = c, m.material = o;
        }
        e.skin && e.skin.defines, t.addChild(g);
      }
    }
  }
  createGeometryBase(e, t, r) {
    let i = new xe();
    i.name = e, "indices" in t && (t.indices.data.length > 65535 ? t.indices.data = new Uint32Array(t.indices.data) : t.indices.data = new Uint16Array(t.indices.data)), i.morphTargetsRelative = r.morphTargetsRelative;
    let a = r.targetNames;
    if (a && a.length > 0) {
      let n = i.morphTargetDictionary = {};
      for (let l = 0; l < a.length; l++)
        n[a[l]] = l;
    }
    if (i.morphTargetDictionary) {
      let n = t.position.data.length / 3, l = new Float32Array(n);
      for (let h = 0; h < n; h++)
        l[h] = h;
      t.vIndex = { data: l, normalize: false, numComponents: 1 };
    }
    for (const n in t) {
      let l = t[n];
      i.setAttribute(n, l.data);
    }
    let o = i.getAttribute(D.indices);
    return i.addSubGeometry({ indexStart: 0, indexCount: o.data.length, vertexStart: 0, index: 0, vertexCount: 0, firstStart: 0, topology: 0 }), i;
  }
  applyMaterialExtensions(e, t) {
    return Nh.apply(this.gltf, e, t), kh.apply(this.gltf, e, t), zh.apply(this.gltf, e, t), t;
  }
  parseSkinJoints(e) {
    let t = [];
    for (let r of e.joints) {
      let i = this.gltf.nodes[r];
      t.push(i.name);
    }
    return t;
  }
};
var Sa = class {
  constructor() {
    __publicField(this, "currentSceneName");
    __publicField(this, "gltf");
    __publicField(this, "initUrl");
    __publicField(this, "_generator");
    __publicField(this, "_version");
    __publicField(this, "_BASE64_MARKER", ";base64,");
    __publicField(this, "_cameraParser", null);
    __publicField(this, "_meshParser", null);
    __publicField(this, "_materialParser", null);
    __publicField(this, "_skinParser", null);
    __publicField(this, "_skeletonParser", null);
    __publicField(this, "_converter", null);
  }
  get version() {
    return this.version ? this.version : this.gltf ? this.gltf.asset ? (this._version = this.gltf.asset.version, this.gltf.asset.minVersion && (this._version += `\r minVersion${this.gltf.asset.minVersion}`), this.version) : this.errorMiss("asset") : (console.warn("glTF not loaded."), null);
  }
  async parse(e, t, r) {
    this.gltf = t, this.initUrl = e;
    const { version: i, generator: a } = this.gltf.asset;
    if (this._generator = a, i !== "2.0")
      return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`), false;
    const o = { nodes: await this.parseScene(r), animations: this.parseAnimations(), name: this.currentSceneName };
    return await this.convertToNode(o);
  }
  destory() {
    so.unload(this.gltf), this.gltf = null;
  }
  async parseScene(e) {
    const t = e || this.gltf.scene || 0, r = this.gltf.scenes[t];
    if (typeof r > "u")
      return this.errorMiss("scene", t);
    this.currentSceneName = r.name || "GLTF_NO_NAME_SCENE";
    const i = [], a = r.nodes;
    for (let o = 0; o < a.length; o++) {
      const n = await this.parseNode(a[o]);
      n && i.push(n);
    }
    return i;
  }
  async parseNode(e) {
    const t = this.gltf.nodes[e];
    if (!t)
      return this.errorMiss("node", e);
    if (t.isParsed)
      return t.dnode;
    const { name: r, matrix: i, translation: a, rotation: o, scale: n } = t, l = { name: r, matrix: i, translation: a, rotation: o, scale: n, nodeId: e, camera: null, primitives: null, skin: null, children: null, light: null };
    if (t.camera !== void 0 && (l.camera = this.parseCamera(t.camera)), t.mesh !== void 0 && (l.primitives = await this.parseMesh(t.mesh)), t.extensions !== void 0 && this.applyNodeExtensions(t, l), t.skin !== void 0) {
      const h = this.parseSkin(t.skin);
      h && (l.skin = h);
    }
    if (l.children = [], t.children)
      for (let h = 0; h < t.children.length; h++)
        l.children.push(await this.parseNode(t.children[h]));
    return t.dnode = l, t.isParsed = true, t.dnode;
  }
  errorMiss(e, t) {
    throw new Error(e + t);
  }
  parseCamera(e) {
    return this._cameraParser || (this._cameraParser = new Dh(this.gltf)), this._cameraParser.parse(e);
  }
  async parseMesh(e) {
    return this._meshParser || (this._meshParser = new Ph(this)), this._meshParser.parse(e);
  }
  async parseTexture(e) {
    let t = this.gltf.textures[e];
    if (t && !t.dtexture) {
      if (t && t.source != null) {
        let r = this.gltf.images[t.source];
        if (r.uri) {
          let i = r.uri;
          i = et.getURLName(i), t.dtexture = this.gltf.resources[i];
        } else if (r.bufferView) {
          let i = this.parseBufferView(r.bufferView), a = new rr(), o = new Blob([i], { type: r.mimeType });
          await a.loadFromBlob(o), t.dtexture = a;
        } else
          t.dtexture = this.gltf.resources[r.name];
      } else if (t.name) {
        let r = et.getURLName(t.name);
        t.dtexture = this.gltf.resources[r];
      }
    }
    return t.dtexture || console.log("miss texture , please check texture!", e, t), t.dtexture;
  }
  async parseMaterial(e) {
    return this._materialParser || (this._materialParser = new Mh(this)), this._materialParser.parse(e);
  }
  parseAnimations() {
    return [];
  }
  async parseObject3D(e, t) {
    return this._converter || (this._converter = new Gh(this)), this._converter.convertNodeToObject3D(e, t);
  }
  parseSkeleton(e) {
    return this._skeletonParser || (this._skeletonParser = new no(this)), this._skeletonParser.parse(e);
  }
  parseSkeletonAnimation(e, t) {
    return this._skeletonParser || (this._skeletonParser = new no(this)), this._skeletonParser.parseSkeletonAnimation(e, t);
  }
  async traverse(e, t) {
    for (let r = 0; r < t.length; r++) {
      const i = await this.parseObject3D(t[r], e);
      await this.traverse(i, t[r].children);
    }
  }
  async convertToNode(e) {
    const t = new Y();
    t.name = e.name;
    const r = e.nodes;
    e.animations;
    const i = [], a = [];
    return await this.traverse(t, r), { rootNode: t, textures: i, animations: void 0, cameras: a };
  }
  parseSkin(e) {
    return this._skinParser || (this._skinParser = new Rh(this)), this._skinParser.parse(e);
  }
  parseAccessor(e) {
    const t = this.gltf.accessors[e];
    if (!t)
      return this.errorMiss("accessor", e);
    if (t.isParsed)
      return t.daccessor;
    t.isParsed = true, t.daccessor = false;
    const r = !!t.normalized, i = this.gltf.bufferViews[t.bufferView], a = i && i.byteStride, o = ao(t.componentType);
    let n = 1;
    switch (t.type) {
      case "SCALAR":
        n = 1;
        break;
      case "VEC2":
        n = 2;
        break;
      case "VEC3":
        n = 3;
        break;
      case "VEC4":
      case "MAT2":
        n = 4;
        break;
      case "MAT3":
        n = 9;
        break;
      case "MAT4":
        n = 16;
        break;
      default:
        n = 0;
        break;
    }
    if (n === 0)
      return console.error(`glTF has unknown data type in accessor: ${t.type}`), false;
    const l = n * o.BYTES_PER_ELEMENT;
    let h;
    if (i !== void 0) {
      if (h = this.parseBufferView(t.bufferView), !h)
        return t.daccessor;
    } else
      h = new Uint8Array(l * t.count).buffer;
    let u = this.getTypedArrayFromArrayBuffer(h, a, t.byteOffset || 0, o, n, t.count);
    if (t.sparse) {
      const { count: c, indices: f, values: g } = t.sparse;
      u = new o(u);
      const m = f.byteOffset || 0, A = this.gltf.bufferViews[f.bufferView], _ = ao(f.componentType), x = this.parseBufferView(f.bufferView), C = this.getTypedArrayFromArrayBuffer(x, A.byteStride, m, _, 1, c), S = g.byteOffset || 0, I = this.gltf.bufferViews[g.bufferView], T = this.parseBufferView(g.bufferView), b = this.getTypedArrayFromArrayBuffer(T, I.byteStride, S, o, n, c);
      for (let B = 0; B < C.length; B++)
        u.set(b.slice(B * n, B * n + n), C[B] * n);
    }
    return t.computeResult = { typedArray: u, arrayType: o, numComponents: n }, t.daccessor = { data: u, numComponents: n, normalize: r }, t.daccessor;
  }
  getTypedArrayFromArrayBuffer(e, t, r, i, a, o) {
    let n;
    const l = a * i.BYTES_PER_ELEMENT;
    if (t && l !== t) {
      const h = a * o;
      n = new i(h);
      for (let u = 0; u < o; u++) {
        const c = new i(e, r + u * t, a);
        for (let f = 0; f < a; f++)
          n[u * a + f] = c[f];
      }
    } else
      n = new i(e, r, o * a);
    return n;
  }
  parseBufferView(e) {
    const t = this.gltf.bufferViews[e];
    if (!t)
      return this.errorMiss("bufferView", e);
    if (t.isParsed)
      return t.dbufferView;
    t.isParsed = true, t.dbufferView = false;
    const r = this.parseBuffer(t.buffer);
    if (r) {
      const { byteOffset: i, byteLength: a } = t, o = new Uint8Array(r, i || 0, a);
      t.dbufferView = new Uint8Array(o).buffer;
    }
    return t.dbufferView;
  }
  parseBuffer(e) {
    const t = this.gltf.buffers[e];
    if (!t)
      return this.errorMiss("buffer", e);
    if (t.isParsed)
      return t.dbuffer;
    if (t.isParsed = true, t.dbuffer = false, t.uri.substring(0, 5) !== "data:") {
      const r = t.uri, i = this.gltf.resources[r];
      i ? i.byteLength === t.byteLength ? t.dbuffer = this.gltf.resources[r] : console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`) : console.error(`load gltf resource "${r}" at buffers[${e}] failed`);
    } else {
      const r = t.uri.indexOf(this._BASE64_MARKER) + this._BASE64_MARKER.length, i = window.atob(t.uri.substring(r)), a = new Uint8Array(i.length);
      for (let o = 0; o < i.length; o++)
        a[o] = i.charCodeAt(o);
      t.dbuffer = a.buffer;
    }
    return t.dbuffer;
  }
  getLight(e) {
    return this.gltf.extensions.KHR_lights_punctual.lights[e];
  }
  applyNodeExtensions(e, t) {
    let r = e.extensions;
    r.KHR_lights_punctual && this.gltf.extensions.KHR_lights_punctual && (t.light = this.getLight(r.KHR_lights_punctual.light));
  }
};
var Qh = class {
  constructor() {
    __publicField(this, "magic");
    __publicField(this, "version");
    __publicField(this, "length");
  }
};
var Vh = class {
  constructor() {
    __publicField(this, "chunkLength");
    __publicField(this, "chunkType");
    __publicField(this, "chunkData");
  }
};
var ho = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "_gltf");
  }
  async parseBuffer(e) {
    let t = new Uint8Array(e);
    t.pos = 0;
    const r = this.parseHeader(t);
    if (r.magic != 1179937895)
      return console.error("invalid GLB file"), false;
    if (r.version !== 2)
      return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`), false;
    let i = [];
    for (; t.pos < t.length; ) {
      let c = this.parseChunk(t);
      i.push(c);
    }
    if (i[0].chunkType != 1313821514)
      return console.error("invalid GLBChunk"), false;
    let a = "", o = 65535, n = i[0].chunkData;
    for (let c = 0; c < n.length; c += o) {
      let f = n.length - c;
      f = Math.min(f, o);
      let g = n.subarray(c, c + f);
      a += String.fromCharCode(...g);
    }
    let l = JSON.parse(a);
    this._gltf = new Ca(), this._gltf = { ...this._gltf, ...l }, this._gltf.resources = {};
    for (let c = 0; c < this._gltf.buffers.length; c++) {
      let f = this._gltf.buffers[c];
      f.isParsed = true, f.dbuffer = i[c + 1].chunkData.buffer;
    }
    if (this._gltf.images)
      for (let c = 0; c < this._gltf.images.length; c++) {
        let f = this._gltf.images[c];
        f.name = f.name || "bufferView_" + f.bufferView.toString();
        const g = this._gltf.bufferViews[f.bufferView], m = this._gltf.buffers[g.buffer];
        let A = new Uint8Array(m.dbuffer, g.byteOffset, g.byteLength), _ = new Blob([A], { type: f.mimeType }), x = new rr();
        await x.loadFromBlob(_), x.name = f.name, this._gltf.resources[f.name] = x;
      }
    let u = await new Sa().parse(this.initUrl, this._gltf, this._gltf.scene);
    return u ? (this.data = u.rootNode, u.rootNode) : null;
  }
  async parseJsonAndBuffer(e, t) {
    this._gltf = new Ca(), this._gltf = { ...this._gltf, ...e }, this._gltf.resources = {};
    let r = this._gltf.buffers[0];
    if (r.isParsed = true, r.dbuffer = t, this._gltf.images)
      for (let o = 0; o < this._gltf.images.length; o++) {
        let n = this._gltf.images[o];
        n.name = n.name || "bufferView_" + n.bufferView.toString();
        const l = this._gltf.bufferViews[n.bufferView], h = this._gltf.buffers[l.buffer];
        let u = new Uint8Array(h.dbuffer, l.byteOffset, l.byteLength), c = new Blob([u], { type: n.mimeType }), f = new rr();
        await f.loadFromBlob(c), f.name = n.name, this._gltf.resources[n.name] = f;
      }
    let a = await new Sa().parse(this.initUrl, this._gltf, this._gltf.scene);
    return a ? (this.data = a.rootNode, a.rootNode) : null;
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
  parseHeader(e) {
    let t = e.pos, r = new Qh(), i = new Uint32Array(e.buffer, t, 3);
    return e.pos += i.byteLength, r.magic = i[0], r.version = i[1], r.length = i[2], r;
  }
  parseChunk(e) {
    let t = e.pos, r = new Vh(), i = new Uint32Array(e.buffer, t, 2);
    t = e.pos += i.byteLength, r.chunkLength = i[0], r.chunkType = i[1], r.chunkData = new Uint8Array(e.buffer, t, r.chunkLength);
    const a = new Uint8Array(r.chunkLength);
    for (let o = 0; o < r.chunkLength; o++)
      a[o] = r.chunkData[o];
    return r.chunkData = a, e.pos += r.chunkLength, r;
  }
};
__publicField(ho, "format", Ue.BIN);
var xg = Object.defineProperty;
var _g = Object.getOwnPropertyDescriptor;
var Cg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? _g(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && xg(e, t, i), i;
};
var ya = class extends Qe {
  constructor() {
    super();
    let s = new ve("PBRLItShader", "PBRLItShader");
    s.setShaderEntry("VertMain", "FragMain"), s.passType = q.COLOR, this.addRenderPass(s);
    let e = s.shaderState;
    e.acceptShadow = true, e.castShadow = true, e.receiveEnv = true, e.acceptGI = true, e.useLight = true, this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefault();
  }
  setDefault() {
    this.setUniformFloat("shadowBias", 35e-5), this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor", new M(0.75, 0.75, 0.75, 1)), this.setUniformColor("emissiveColor", new M(0, 0, 0)), this.setUniformVector4("materialF0", new G(0.04, 0.04, 0.04, 1)), this.setUniformColor("specularColor", new M(0.04, 0.04, 0.04)), this.setUniformFloat("envIntensity", 1), this.setUniformFloat("normalScale", 1), this.setUniformFloat("roughness", 1), this.setUniformFloat("metallic", 1), this.setUniformFloat("ao", 1), this.setUniformFloat("roughness_min", 0), this.setUniformFloat("roughness_max", 1), this.setUniformFloat("metallic_min", 0), this.setUniformFloat("metallic_max", 1), this.setUniformFloat("emissiveIntensity", 0), this.setUniformFloat("alphaCutoff", 0), this.setUniformFloat("ior", 1.5), this.setUniformFloat("clearcoatFactor", 0), this.setUniformFloat("clearcoatRoughnessFactor", 0), this.setUniformColor("clearcoatColor", new M(1, 1, 1)), this.setUniformFloat("clearcoatWeight", 0), this.baseMap = p.res.whiteTexture, this.normalMap = p.res.normalTexture, this.maskMap = p.res.maskTexture;
  }
  get baseMap() {
    return this.getDefaultColorShader().getTexture("baseMap");
  }
  set baseMap(s) {
    this.getDefaultColorShader().setTexture("baseMap", s);
  }
  get baseColor() {
    return this.getDefaultColorShader().getUniform("baseColor");
  }
  set baseColor(s) {
    this.getDefaultColorShader().setUniformColor("baseColor", s);
  }
  get normalMap() {
    return this.getDefaultColorShader().getTexture("normalMap");
  }
  set normalMap(s) {
    this.getDefaultColorShader().setTexture("normalMap", s);
  }
  get doubleSide() {
    return this.getDefaultColorShader().doubleSide;
  }
  set doubleSide(s) {
    this.getDefaultColorShader().doubleSide = s;
  }
  get alphaCutoff() {
    return this.getDefaultColorShader().shaderState.alphaCutoff;
  }
  set alphaCutoff(s) {
    this.getDefaultColorShader().setDefine("USE_ALPHACUT", true), this.getDefaultColorShader().shaderState.alphaCutoff = s, this.getDefaultColorShader().setUniform("alphaCutoff", s);
  }
  get emissiveColor() {
    return this.getDefaultColorShader().getUniform("emissiveColor");
  }
  set emissiveColor(s) {
    this.getDefaultColorShader().setUniform("emissiveColor", s);
  }
  get emissiveIntensity() {
    return this.getDefaultColorShader().getUniform("emissiveIntensity");
  }
  set emissiveIntensity(s) {
    this.getDefaultColorShader().setUniform("emissiveIntensity", s);
  }
  get uvTransform_1() {
    return this.getDefaultColorShader().uniforms.transformUV1.vector4;
  }
  set uvTransform_1(s) {
    this.getDefaultColorShader().setUniform("transformUV1", s);
  }
  get uvTransform_2() {
    return this.getDefaultColorShader().uniforms.transformUV2.vector4;
  }
  set uvTransform_2(s) {
    this.getDefaultColorShader().setUniform("transformUV2", s);
  }
  get depthWriteEnabled() {
    return this.getDefaultColorShader().shaderState.depthWriteEnabled;
  }
  set depthWriteEnabled(s) {
    this.getDefaultColorShader().shaderState.depthWriteEnabled = s;
  }
  get materialF0() {
    return this.getDefaultColorShader().uniforms.materialF0.vector4;
  }
  set materialF0(s) {
    this.getDefaultColorShader().setUniform("materialF0", s);
  }
  get specularColor() {
    return this.getDefaultColorShader().uniforms.specularColor.color;
  }
  set specularColor(s) {
    this.getDefaultColorShader().setUniform("specularColor", s);
  }
  get roughness() {
    return this.getDefaultColorShader().uniforms.roughness.value;
  }
  set roughness(s) {
    this.getDefaultColorShader().setUniform("roughness", s);
  }
  get metallic() {
    return this.getDefaultColorShader().uniforms.metallic.value;
  }
  set metallic(s) {
    this.getDefaultColorShader().setUniform("metallic", s);
  }
  get ao() {
    return this.getDefaultColorShader().uniforms.ao.value;
  }
  set ao(s) {
    this.getDefaultColorShader().setUniform("ao", s);
  }
  get metallic_min() {
    return this.getDefaultColorShader().uniforms.metallic_min.value;
  }
  set metallic_min(s) {
    this.getDefaultColorShader().setUniform("metallic_min", s);
  }
  get metallic_max() {
    return this.getDefaultColorShader().uniforms.metallic_max.value;
  }
  set metallic_max(s) {
    this.getDefaultColorShader().setUniform("metallic_max", s);
  }
  get roughness_min() {
    return this.getDefaultColorShader().uniforms.roughness_min.value;
  }
  set roughness_min(s) {
    this.getDefaultColorShader().setUniform("roughness_min", s);
  }
  get roughness_max() {
    return this.getDefaultColorShader().uniforms.roughness_max.value;
  }
  set roughness_max(s) {
    this.getDefaultColorShader().setUniform("roughness_max", s);
  }
  get normalScale() {
    return this.getDefaultColorShader().uniforms.normalScale.value;
  }
  set normalScale(s) {
    this.getDefaultColorShader().setUniform("normalScale", s);
  }
  get maskMap() {
    return this.getDefaultColorShader().textures.maskMap;
  }
  set maskMap(s) {
    this.getDefaultColorShader().setDefine("USE_MR", true), this.getDefaultColorShader().setTexture("maskMap", s);
  }
  set aoMap(s) {
    s && (this.getDefaultColorShader().setTexture("aoMap", s), s != p.res.whiteTexture && this.getDefaultColorShader().setDefine("USE_AOTEX", true));
  }
  get aoMap() {
    return this.getDefaultColorShader().textures.aoMap;
  }
  set clearCoatRoughnessMap(s) {
    s && (console.log("USE_CLEARCOAT_ROUGHNESS"), this.getDefaultColorShader().setTexture("clearCoatRoughnessMap", s), this.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS", true));
  }
  get clearCoatRoughnessMap() {
    return this.getDefaultColorShader().textures.clearCoatRoughnessMap;
  }
  get brdfLUT() {
    return this.getDefaultColorShader().textures.brdfLUT;
  }
  set brdfLUT(s) {
    this.getDefaultColorShader().setTexture("brdfLUT", s), this.getDefaultColorShader().setTexture("brdflutMap", s);
  }
  get emissiveMap() {
    return this.getDefaultColorShader().textures.emissiveMap;
  }
  set emissiveMap(s) {
    this.getDefaultColorShader().setTexture("emissiveMap", s);
  }
  set envIntensity(s) {
    this.getDefaultColorShader().setUniformFloat("envIntensity", s);
  }
  get envIntensity() {
    return this.getDefaultColorShader().uniforms.envIntensity.value;
  }
  set ior(s) {
    this.getDefaultColorShader().setUniformFloat("ior", s);
  }
  get ior() {
    return this.getDefaultColorShader().uniforms.ior.value;
  }
  useCleanCoat() {
    this.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
  }
  set clearcoatFactor(s) {
    this.getDefaultColorShader().setUniformFloat("clearcoatFactor", s), this.useCleanCoat();
  }
  get clearcoatFactor() {
    return this.getDefaultColorShader().uniforms.clearcoatFactor.value;
  }
  set clearcoatRoughnessFactor(s) {
    this.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor", s), this.useCleanCoat();
  }
  get clearcoatRoughnessFactor() {
    return this.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value;
  }
  set clearcoatWeight(s) {
    this.getDefaultColorShader().setUniformFloat("clearcoatWeight", s), this.useCleanCoat();
  }
  get clearcoatWeight() {
    return this.getDefaultColorShader().uniforms.clearcoatWeight.value;
  }
  set clearcoatColor(s) {
    this.getDefaultColorShader().setUniformColor("clearcoatColor", s), this.useCleanCoat();
  }
  get clearcoatColor() {
    return this.getDefaultColorShader().uniforms.clearcoatColor.color;
  }
};
ya = Cg([Kt], ya);
var ar = class _ar extends je {
  constructor() {
    super();
    let e = new ya();
    this.shader = e;
  }
  clone() {
    let e = new _ar(), t = e.shader.getDefaultColorShader(), r = this.shader.getDefaultColorShader();
    return t.defineValue = { ...r.defineValue }, t.setUniform("shadowBias", r.getUniform("shadowBias")), t.setUniform("transformUV1", r.getUniform("transformUV1")), t.setUniform("transformUV2", r.getUniform("transformUV2")), t.setUniform("baseColor", r.getUniform("baseColor")), t.setUniform("specularColor", r.getUniform("specularColor")), t.setUniform("emissiveColor", r.getUniform("emissiveColor")), t.setUniform("materialF0", r.getUniform("materialF0")), t.setUniform("envIntensity", r.getUniform("envIntensity")), t.setUniform("normalScale", r.getUniform("normalScale")), t.setUniform("roughness", r.getUniform("roughness")), t.setUniform("metallic", r.getUniform("metallic")), t.setUniform("ao", r.getUniform("ao")), t.setUniform("roughness_min", r.getUniform("roughness_min")), t.setUniform("roughness_max", r.getUniform("roughness_max")), t.setUniform("metallic_min", r.getUniform("metallic_min")), t.setUniform("metallic_max", r.getUniform("metallic_max")), t.setUniform("emissiveIntensity", r.getUniform("emissiveIntensity")), t.setUniform("alphaCutoff", r.getUniform("alphaCutoff")), t.setUniform("ior", r.getUniform("ior")), t.setUniform("clearcoatFactor", r.getUniform("clearcoatFactor")), t.setUniform("clearcoatRoughnessFactor", r.getUniform("clearcoatRoughnessFactor")), t.setUniform("clearcoatColor", r.getUniform("clearcoatColor")), t.setUniform("clearcoatWeight", r.getUniform("clearcoatWeight")), t.setTexture("baseMap", r.getTexture("baseMap")), t.setTexture("normalMap", r.getTexture("normalMap")), t.setTexture("emissiveMap", r.getTexture("emissiveMap")), t.setTexture("aoMap", r.getTexture("aoMap")), t.setTexture("maskMap", r.getTexture("maskMap")), e;
  }
  set baseMap(e) {
    this.shader.setTexture("baseMap", e);
  }
  get baseMap() {
    return this.shader.getTexture("baseMap");
  }
  set maskMap(e) {
    this.shader.setTexture("maskMap", e);
  }
  get maskMap() {
    return this.shader.getTexture("maskMap");
  }
  set normalMap(e) {
    this.shader.setTexture("normalMap", e);
  }
  get normalMap() {
    return this.shader.getTexture("normalMap");
  }
  set emissiveMap(e) {
    this.shader.setTexture("emissiveMap", e);
  }
  get emissiveMap() {
    return this.shader.getTexture("emissiveMap");
  }
  set aoMap(e) {
    this.shader.setTexture("aoMap", e);
  }
  get aoMap() {
    return this.shader.getTexture("aoMap");
  }
  set clearCoatRoughnessMap(e) {
    this.shader.setTexture("clearCoatRoughnessMap", e), this.shader.setDefine("USE_CLEARCOAT", true), this.shader.setDefine("USE_CLEARCOAT_ROUGHNESS", true);
  }
  get clearCoatRoughnessMap() {
    return this.shader.getTexture("clearCoatRoughnessMap");
  }
  set clearcoatColor(e) {
    this.shader.setUniformColor("clearcoatColor", e), this.shader.setDefine("USE_CLEARCOAT", true);
  }
  get clearcoatColor() {
    return this.shader.getUniformColor("clearcoatColor");
  }
  set clearcoatWeight(e) {
    this.shader.setUniformFloat("clearcoatWeight", e), this.shader.setDefine("USE_CLEARCOAT", true);
  }
  get clearcoatWeight() {
    return this.shader.getUniformFloat("clearcoatWeight");
  }
  set clearcoatFactor(e) {
    this.shader.setUniformFloat("clearcoatFactor", e), this.shader.setDefine("USE_CLEARCOAT", true);
  }
  get clearcoatFactor() {
    return this.shader.getUniformFloat("clearcoatFactor");
  }
  set clearcoatRoughnessFactor(e) {
    this.shader.setUniformFloat("clearcoatRoughnessFactor", e), this.shader.setDefine("USE_CLEARCOAT", true);
  }
  get clearcoatRoughnessFactor() {
    return this.shader.getUniformFloat("clearcoatRoughnessFactor");
  }
  set alphaCutoff(e) {
    this.shader.setUniform("alphaCutoff", e);
  }
  get alphaCutoff() {
    return this.shader.getUniform("alphaCutoff");
  }
  set baseColor(e) {
    this.shader.setUniformColor("baseColor", e);
  }
  get baseColor() {
    return this.shader.getUniformColor("baseColor");
  }
  get roughness() {
    return this.shader.getUniformFloat("roughness");
  }
  set roughness(e) {
    this.shader.setUniformFloat("roughness", e);
  }
  get metallic() {
    return this.shader.getUniformFloat("metallic");
  }
  set metallic(e) {
    this.shader.setUniformFloat("metallic", e);
  }
  get emissiveColor() {
    return this.shader.getUniformColor("emissiveColor");
  }
  set emissiveColor(e) {
    this.shader.setUniformColor("emissiveColor", e);
  }
  get emissiveIntensity() {
    return this.shader.getUniformFloat("emissiveIntensity");
  }
  set emissiveIntensity(e) {
    this.shader.setUniformFloat("emissiveIntensity", e);
  }
  get ao() {
    return this.shader.getUniform("ao");
  }
  set ao(e) {
    this.shader.setUniform("ao", e);
  }
};
var Hh = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "textData", "");
    __publicField(this, "source_vertices");
    __publicField(this, "source_normals");
    __publicField(this, "source_tangents");
    __publicField(this, "source_textureCoords");
    __publicField(this, "matLibs");
    __publicField(this, "geometrys");
    __publicField(this, "activeGeo");
    __publicField(this, "facesMaterialsIndex");
    __publicField(this, "mtl");
    __publicField(this, "mtlUrl");
  }
  async parseString(e) {
    return this.source_vertices = [], this.source_normals = [], this.source_tangents = [], this.source_textureCoords = [], this.matLibs = {}, this.geometrys = {}, this.textData = e, await Promise.all([this.parserOBJ(), this.loadMTL()]), this.parser_mesh(), "null";
  }
  applyVector2(e, t, r) {
    t[e] && t[e].length > 0 ? (r.push(t[e][0]), r.push(t[e][1])) : (r.push(0), r.push(0));
  }
  applyVector3(e, t, r) {
    r.push(t[e][0]), r.push(t[e][1]), r.push(t[e][2]);
  }
  applyVector4(e, t, r) {
    r.push(t[e][0]), r.push(t[e][1]), r.push(t[e][2]), r.push(t[e][3]);
  }
  async loadMTL() {
    let t = await new tt().loadTxt(this.baseUrl + this.mtlUrl), r = t.data, i, a = r.split(`\r
`);
    for (let l = 0; l < a.length; l++) {
      let h = a[l];
      var o = h.indexOf("#");
      o != -1 && (h = h.substring(0, o)), h = h.trim();
      var n = h.split(/\s+/);
      n[0] === "newmtl" ? (i = { name: n[1] }, this.matLibs[n[1]] = i) : n[0].indexOf("map_") != -1 ? (i[n[0]] = n[1], i.textures || (i.textures = [n[n.length - 1]]), i.textures.push(n[n.length - 1])) : n.length == 2 ? i[n[0]] = Number(n[1]) : n.length == 3 ? i[n[0]] = [Number(n[1]), Number(n[2])] : n.length == 4 && (i[n[0]] = [Number(n[1]), Number(n[2]), Number(n[3])]);
    }
    for (const l in this.matLibs) {
      const h = this.matLibs[l];
      if (h.textures && h.textures.length > 0)
        for (let u = 0; u < h.textures.length; u++) {
          const c = et.normalizePath(this.baseUrl + h.textures[u]);
          await p.res.loadTexture(c);
        }
    }
    return t = null, true;
  }
  async load_textures() {
  }
  parserLine(e) {
    var t = e.indexOf("#");
    if (t != -1) {
      if (e.indexOf("# object") != -1) {
        var r = e.split(/\s+/);
        let f = r[1], g = r[2];
        this.activeGeo = { type: f, name: g[1], source_mat: "", source_faces: [] }, this.geometrys[g] = this.activeGeo;
      }
      e = e.substring(0, t);
    }
    e = e.trim();
    var r = e.split(/\s+/);
    if (r[0] === "v") {
      var i = [Number(r[1]), Number(r[2]), Number(r[3]), r[4] ? 1 : Number(r[4])];
      this.source_vertices.push(i);
    } else if (r[0] === "vt") {
      var a = [Number(r[1]), Number(r[2]), r[3] ? 1 : Number(r[3])];
      this.source_textureCoords.push(a);
    } else if (r[0] === "vn") {
      var o = [Number(r[1]), Number(r[2]), Number(r[3])];
      this.source_normals.push(o);
    } else if (r[0] === "f") {
      for (var n = { indices: [], texture: [], normal: [] }, l = 1; l < r.length; ++l) {
        var h = r[l].indexOf("//"), u = r[l].split(/\W+/);
        h > 0 ? (n.indices.push(u[0]), n.normal.push(u[1])) : u.length === 1 ? n.indices.push(u[0]) : u.length === 2 ? (n.indices.push(u[0]), n.texture.push(u[1])) : u.length === 3 && (n.indices.push(u[0]), n.texture.push(u[1]), n.normal.push(u[2]));
      }
      this.activeGeo.source_faces.push(n);
    } else
      r[0] === "usemtl" ? this.activeGeo.source_mat = r[1] : r[0] === "mtllib" && (this.mtlUrl = r[1]);
  }
  async parserOBJ() {
    let e = this.textData.split(`\r
`);
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      this.parserLine(r);
    }
    return this.textData = "", true;
  }
  async parser_mesh() {
    for (const e in this.geometrys) {
      const t = this.geometrys[e];
      t.vertex_arr = [], t.normal_arr = [], t.uv_arr = [], t.indeice_arr = [];
      let r = 0;
      for (let a = 0; a < t.source_faces.length; a++) {
        const o = t.source_faces[a];
        let n = parseInt(o.indices[0]) - 1, l = parseInt(o.indices[1]) - 1, h = parseInt(o.indices[2]) - 1, u = parseInt(o.normal[0]) - 1, c = parseInt(o.normal[1]) - 1, f = parseInt(o.normal[2]) - 1, g = parseInt(o.texture[0]) - 1, m = parseInt(o.texture[1]) - 1, A = parseInt(o.texture[2]) - 1;
        if (this.applyVector3(n, this.source_vertices, t.vertex_arr), this.applyVector3(u, this.source_normals, t.normal_arr), this.applyVector2(g, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++, this.applyVector3(l, this.source_vertices, t.vertex_arr), this.applyVector3(c, this.source_normals, t.normal_arr), this.applyVector2(m, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++, this.applyVector3(h, this.source_vertices, t.vertex_arr), this.applyVector3(f, this.source_normals, t.normal_arr), this.applyVector2(A, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++, o.indices.length > 3) {
          let _ = parseInt(o.indices[3]) - 1, x = parseInt(o.normal[3]) - 1, C = parseInt(o.texture[3]) - 1;
          this.applyVector3(n, this.source_vertices, t.vertex_arr), this.applyVector3(u, this.source_normals, t.normal_arr), this.applyVector2(g, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++, this.applyVector3(h, this.source_vertices, t.vertex_arr), this.applyVector3(f, this.source_normals, t.normal_arr), this.applyVector2(A, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++, this.applyVector3(_, this.source_vertices, t.vertex_arr), this.applyVector3(x, this.source_normals, t.normal_arr), this.applyVector2(C, this.source_textureCoords, t.uv_arr), t.indeice_arr[r] = r++;
        }
      }
      let i = new Y();
      for (const a in this.geometrys) {
        const o = this.geometrys[a];
        let n = new xe();
        n.setIndices(new Uint32Array(o.indeice_arr)), n.setAttribute(D.position, new Float32Array(o.vertex_arr)), n.setAttribute(D.normal, new Float32Array(o.normal_arr)), n.setAttribute(D.uv, new Float32Array(o.uv_arr)), n.setAttribute(D.TEXCOORD_1, new Float32Array(o.uv_arr)), n.addSubGeometry({ indexStart: 0, indexCount: o.indeice_arr.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
        let l = new ar(), h = this.matLibs[o.source_mat];
        l.baseMap = p.res.getTexture(et.normalizePath(this.baseUrl + h.map_Kd));
        let u = new Y(), c = u.addComponent(J);
        c.geometry = n, c.material = l, i.addChild(u);
      }
      this.data = i;
    }
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
};
__publicField(Hh, "format", Ue.TEXT);
var Yh = `
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`;
var Xh = `
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;
var Wh = class {
  static blurImageFromTexture(e, t, r, i) {
    const a = w.device;
    let o = i ? Xh : Yh;
    const n = a.createComputePipeline({ layout: "auto", compute: { module: a.createShaderModule({ code: o }), entryPoint: "main" } }), l = 4 * 4, h = a.createBuffer({ size: l, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    a.queue.writeBuffer(h, 0, new Uint32Array([e.width, e.height, t, r]));
    const u = a.createTexture({ size: [t, r, 1], mipLevelCount: 1, format: "rgba8unorm", usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, label: "blurImageFromTexture" });
    let c = [{ binding: 0, resource: { buffer: h, size: 4 * 4 } }, { binding: 1, resource: e.gpuTexture.createView({ format: "rgba8unorm", dimension: "2d", baseMipLevel: 0, mipLevelCount: 1 }) }, { binding: 2, resource: u.createView({ format: "rgba8unorm", dimension: "2d", baseMipLevel: 0, mipLevelCount: 1 }) }];
    const f = a.createBindGroup({ layout: n.getBindGroupLayout(0), entries: c }), g = y.beginCommandEncoder(), m = g.beginComputePass();
    return m.setPipeline(n), m.setBindGroup(0, f), m.dispatchWorkgroups(Math.floor(t / 8), Math.floor(r / 8)), m.end(), y.endCommandEncoder(g), h.destroy(), u;
  }
};
var wa = class extends Re {
  constructor() {
    super(4, 4);
    __publicField(this, "width", 4);
    __publicField(this, "height", 4);
    __publicField(this, "depthOrArrayLayers", 6);
    __publicField(this, "visibility", GPUShaderStage.FRAGMENT);
    __publicField(this, "textureBindingLayout", { viewDimension: "cube", multisampled: false });
    __publicField(this, "samplerBindingLayout", { type: "filtering" });
    this.addressModeU = ct.clamp_to_edge, this.addressModeV = ct.clamp_to_edge, this.addressModeW = ct.clamp_to_edge, this.magFilter = this.minFilter = "linear", this.mipmapFilter = "linear", this.visibility = GPUShaderStage.FRAGMENT;
  }
  createTextureDescriptor(e, t, r, i, a = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, o = 1) {
    this.width = e, this.height = t, this.format = i, this.usage = a, this.textureDescriptor = { size: { width: e, height: t, depthOrArrayLayers: 6 }, mipLevelCount: r, format: i, usage: a, dimension: "2d" }, o > 1 ? this.viewDescriptor = { dimension: "cube-array" } : this.viewDescriptor = { dimension: this.textureBindingLayout.viewDimension };
  }
};
var _qa = class _qa {
  static createFace(e, t, r, i) {
    const a = w.device;
    this.pipeline == null && (this.pipeline = a.createComputePipeline({ layout: "auto", compute: { module: a.createShaderModule({ code: _qa.createCube }), entryPoint: "main" } }));
    const o = this.pipeline, n = 4 * 4;
    this.configBuffer || (this.configBuffer = a.createBuffer({ size: n, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST })), a.queue.writeBuffer(this.configBuffer, 0, new Uint32Array([e, 0, 0, 0])), this.blurSettingBuffer || (this.blurSettingBuffer = a.createBuffer({ size: n, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST })), a.queue.writeBuffer(this.blurSettingBuffer, 0, new Float32Array([0, 0, 0, 0]));
    let l = [{ binding: 0, resource: { buffer: this.configBuffer, size: 4 * 4 } }, { binding: 1, resource: r.getGPUView() }, { binding: 2, resource: i.getGPUView() }];
    const h = a.createBindGroup({ layout: o.getBindGroupLayout(0), entries: l }), u = y.beginCommandEncoder(), c = u.beginComputePass();
    c.setPipeline(o), c.setBindGroup(0, h), c.dispatchWorkgroups(t / 8, t / 8), c.end(), y.endCommandEncoder(u);
  }
};
__publicField(_qa, "createCube", `

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`);
__publicField(_qa, "configBuffer", null);
__publicField(_qa, "blurSettingBuffer", null);
__publicField(_qa, "pipeline");
var qa = _qa;
var uo = class extends wa {
  constructor() {
    super();
    __publicField(this, "_images");
    __publicField(this, "_url");
    this.useMipmap = true;
  }
  generateImages(e) {
    let t = w.device;
    this.width = this.height = 32, "width" in e[0] && (this.width = this.height = e[0].width);
    let r = Math.min(this.width, this.height);
    for (this.mipmapCount = 1; r > 16; )
      r /= 2, this.mipmapCount++;
    this.textureBindingLayout.viewDimension = "cube", this.samplerBindingLayout.type = "filtering", this.createTextureDescriptor(this.width, this.height, this.mipmapCount, this.format), this.textureDescriptor.size = { width: this.width, height: this.height, depthOrArrayLayers: 6 }, this.textureDescriptor.dimension = "2d", this.gpuTexture = this.getGPUTexture();
    let i = [], a = i, o = this.width, n = this.height;
    if (e[0] instanceof Re) {
      for (let l = 0; l < 6; l++) {
        let h = e[l];
        i[l] = h.getGPUTexture();
      }
      this.uploadMipmapGPUTexture(0, this.width, this.width, i);
    } else {
      this.uploadBaseImages(this.width, e);
      for (let l = 0; l < 6; l++) {
        let h = new rr(false);
        h.format = this.format, h.source = e[l], i[l] = h.getGPUTexture();
      }
    }
    for (let l = 1; l < this.mipmapCount; l++) {
      a = i, i = [];
      let h = { width: o, height: n, gpuTexture: null };
      o = o / 2, n = n / 2;
      for (let u = 0; u < 6; u++)
        h.gpuTexture = a[u], i[u] = Wh.blurImageFromTexture(h, o, n, false);
      this.uploadMipmapGPUTexture(l, o, n, i);
    }
    this.gpuSampler = t.createSampler(this);
  }
  uploadBaseImages(e, t) {
    let r = w.device;
    const i = y.beginCommandEncoder();
    for (let a = 0; a < 6; a++)
      r.queue.copyExternalImageToTexture({ source: t[a] }, { texture: this.gpuTexture, mipLevel: 0, origin: { x: 0, y: 0, z: a } }, { width: e, height: e, depthOrArrayLayers: 1 });
    y.endCommandEncoder(i);
  }
  uploadMipmapGPUTexture(e, t, r, i) {
    const a = y.beginCommandEncoder();
    for (let o = 0; o < 6; o++)
      a.copyTextureToTexture({ texture: i[o], mipLevel: 0, origin: { x: 0, y: 0, z: 0 } }, { texture: this.gpuTexture, mipLevel: e, origin: { x: 0, y: 0, z: o } }, { width: t, height: r, depthOrArrayLayers: 1 });
    y.endCommandEncoder(a);
  }
  get images() {
    return this._images;
  }
  set images(e) {
    if (this._images = e, this._images[0] instanceof HTMLImageElement) {
      let t = function(o, n) {
        n.decode().then(async () => {
          r[o] = await createImageBitmap(n), i--, i == 0 && a.generateImages(r);
        });
      }, r = [], i = 6, a = this;
      for (let o = 0; o < 6; o++)
        t(o, this._images[o]);
    } else
      (this._images instanceof HTMLCanvasElement || this._images instanceof ImageBitmap) && this.generateImages(this._images);
  }
  async load(e) {
    this._url = e;
    let t = 6, r = [];
    this.format = N.rgba8unorm;
    let i = this;
    async function a(o, n) {
      const l = document.createElement("img");
      if (l.src = n, l.setAttribute("crossOrigin", ""), await l.decode(), r[o] = await createImageBitmap(l), t--, t == 0)
        return i.generateImages(r), true;
    }
    for (let o = 0; o < 6; o++)
      await a(o, e[o]);
    return true;
  }
  async loadStd(e) {
    this._url = e, this.format = N.rgba8unorm;
    const t = document.createElement("img");
    t.src = e, t.setAttribute("crossOrigin", ""), await t.decode();
    let r = new rr(false);
    r.name = et.getURLName(e), r.format = "rgba8unorm", r.source = await createImageBitmap(t);
    let i = Math.round(Math.log2(r.width / 4));
    i = Math.pow(2, i), this.width = this.height = i;
    let a = [];
    for (let o = 0; o < 6; o++) {
      let n = new de(i, i, this.format, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
      n.name = "face " + o, a.push(n), qa.createFace(o, this.width, r, n);
    }
    return this.generateImages(a), true;
  }
};
var jh = ((s) => (s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.Bottom = 2] = "Bottom", s[s.Top = 3] = "Top", s[s.Back = 4] = "Back", s[s.Front = 5] = "Front", s))(jh || {});
var co = class {
  static getRotationToFace(e) {
    let t = H.identity().clone(), r = new d(), i = new P().identity(), a = new d();
    switch (e) {
      case 3:
        r.set(0, -1, 0), a.set(0, 0, -1);
        break;
      case 2:
        r.set(0, 1, 0), a.set(0, 0, 1);
        break;
      case 1:
        r.set(1, 0, 0), a.set(0, 1, 0);
        break;
      case 0:
        r.set(-1, 0, 0), a.set(0, 1, 0);
        break;
      case 4:
        r.set(0, 0, -1), a.set(0, 1, 0);
        break;
      case 5:
        return H.identity();
    }
    return i.lookAt(new d(), r, a), t.setFromRotationMatrix(i), t;
  }
};
var qh = `
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`;
var Kh = `
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;
var _ut = class _ut {
  static convertRGBE2RGBA(e, t) {
    const r = w.device, i = r.createComputePipeline({ layout: "auto", compute: { module: r.createShaderModule({ code: Kh }), entryPoint: "main" } }), a = r.createBuffer({ size: 4 * 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    r.queue.writeBuffer(a, 0, new Uint32Array([e.width, e.height, e.width, e.height]));
    const o = r.createBuffer({ size: t.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    r.queue.writeBuffer(o, 0, t);
    let n = [{ binding: 0, resource: { buffer: a, size: 4 * 4 } }, { binding: 1, resource: { buffer: o, size: t.byteLength } }, { binding: 2, resource: e.getGPUView() }];
    const l = r.createBindGroup({ layout: i.getBindGroupLayout(0), entries: n }), h = y.beginCommandEncoder(), u = h.beginComputePass();
    u.setPipeline(i), u.setBindGroup(0, l), u.dispatchWorkgroups(Math.floor(e.width / 8), Math.floor(e.height / 8)), u.end(), y.endCommandEncoder(h), a.destroy();
  }
  static makeTextureCube(e, t, r) {
    const i = w.device;
    _ut.makeFaceTexturePipeline || (_ut.makeFaceTexturePipeline = i.createComputePipeline({ layout: "auto", compute: { module: i.createShaderModule({ code: qh }), entryPoint: "main" } }));
    const a = _ut.makeFaceTexturePipeline, o = 4 * 4;
    _ut.configBuffer || (_ut.configBuffer = i.createBuffer({ size: o, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST })), i.queue.writeBuffer(_ut.configBuffer, 0, new Uint32Array([e.width, e.height, t, t]));
    const n = 4 * 6;
    if (!_ut.quaternionBuffer) {
      _ut.quaternionBuffer = i.createBuffer({ size: n * 4 * 6, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
      let m = new Float32Array(4 * 6);
      for (let A = 0; A < 6; A++) {
        let _ = co.getRotationToFace(A);
        m[A * 4 + 0] = _.x, m[A * 4 + 1] = _.y, m[A * 4 + 2] = _.z, m[A * 4 + 3] = _.w;
      }
      i.queue.writeBuffer(_ut.quaternionBuffer, 0, m);
    }
    let l = [{ binding: 0, resource: { buffer: _ut.configBuffer, size: 4 * 4 } }, { binding: 1, resource: { buffer: _ut.quaternionBuffer, size: n * 4 } }, { binding: 2, resource: e.gpuSampler }, { binding: 3, resource: e.getGPUView() }], h = [{ binding: 0, resource: r }];
    const u = i.createBindGroup({ layout: a.getBindGroupLayout(0), entries: l }), c = i.createBindGroup({ layout: a.getBindGroupLayout(1), entries: h }), f = y.beginCommandEncoder(), g = f.beginComputePass();
    g.setPipeline(a), g.setBindGroup(0, u), g.setBindGroup(1, c), g.dispatchWorkgroups(t / 8, t / 8, 6), g.end(), y.endCommandEncoder(f);
  }
};
__publicField(_ut, "makeFaceTexturePipeline");
__publicField(_ut, "configBuffer");
__publicField(_ut, "quaternionBuffer");
var ut = _ut;
var fo = class extends Re {
  constructor() {
    super(32, 32, null), this.isHDRTexture = true;
  }
  create(e = 32, t = 32, r = null, i = true) {
    this.width = e, this.height = t;
    let a = w.device;
    const n = e * 4 * 2;
    let l = r;
    this.format = N.rgba16float, this.useMipmap = i, this.updateTextureDescription(), this.updateGPUTexture();
    const h = a.createBuffer({ size: l.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    a.queue.writeBuffer(h, 0, l);
    const u = y.beginCommandEncoder();
    return u.copyBufferToTexture({ buffer: h, bytesPerRow: n }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(u), this.useMipmap || (this.samplerBindingLayout.type = "filtering", this.textureBindingLayout.sampleType = "float"), this.gpuSampler = a.createSampler(this), this;
  }
  async load(e, t) {
    return (await new tt().load(e, po, t)).getHDRTexture();
  }
};
var Jh = new Float32Array(1);
var Sg = new Int32Array(Jh.buffer);
var Zr = function(s) {
  Jh[0] = s;
  const e = Sg[0];
  let t = e >> 16 & 32768, r = e >> 12 & 2047;
  const i = e >> 23 & 255;
  return i < 103 ? t : i > 142 ? (t |= 31744, t |= (i == 255 ? 1 : 0) && e & 8388607, t) : i < 114 ? (r |= 2048, t |= (r >> 114 - i) + (r >> 113 - i & 1), t) : (t |= i - 112 << 10 | r >> 1, t += r & 1, t);
};
var Zh = ((s) => (s[s.RGBE_RETURN_FAILURE = -1] = "RGBE_RETURN_FAILURE", s[s.rgbe_read_error = 1] = "rgbe_read_error", s[s.rgbe_write_error = 2] = "rgbe_write_error", s[s.rgbe_format_error = 3] = "rgbe_format_error", s[s.rgbe_memory_error = 4] = "rgbe_memory_error", s))(Zh || {});
var go = class {
  constructor() {
    __publicField(this, "valid");
    __publicField(this, "string");
    __publicField(this, "comments");
    __publicField(this, "programtype");
    __publicField(this, "format");
    __publicField(this, "gamma");
    __publicField(this, "exposure");
    __publicField(this, "width");
    __publicField(this, "height");
  }
};
var po = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "_rgbeArray");
    __publicField(this, "_width");
    __publicField(this, "_height");
    __publicField(this, "_RGBE_RETURN_FAILURE", -1);
    __publicField(this, "_parserType", N.rgba8uint);
  }
  parseBuffer(e) {
    let t, r = new Uint8Array(e);
    r.pos = 0;
    const i = this.paserHeader(r);
    if (i instanceof go) {
      const a = this._width = i.width, o = this._height = i.height;
      let n = this.parserPixel(r.subarray(r.pos), a, o);
      if (n instanceof Uint8Array) {
        switch (this._rgbeArray = n, this._parserType) {
        }
        return this.data = t, t;
      }
    }
    return null;
  }
  verification() {
    if (this.data && this.data instanceof Re)
      return true;
    if (this._rgbeArray)
      return true;
    throw new Error("Method not implemented.");
  }
  getTexture() {
    return this.data;
  }
  getCubeTexture() {
    let e = this._width / 4;
    return new Ia().createFromHDRData(e, { width: this._width, height: this._height, array: this._rgbeArray });
  }
  getHDRTexture() {
    return new fo().create(this._width, this._height, this._rgbeArray);
  }
  parseError(e, t) {
    switch (e) {
      case 1:
        console.error("Read Error: " + (t || ""));
        break;
      case 2:
        console.error("Write Error: " + (t || ""));
        break;
      case 3:
        console.error("Bad File Format: " + (t || ""));
        break;
      default:
      case 4:
        console.error("Error: " + (t || ""));
    }
    return -1;
  }
  parserBlock(e, t, r) {
    t = t || 1024;
    let a = e.pos, o = -1, n = 0, l = "", h = String.fromCharCode.apply(null, new Uint16Array(e.subarray(a, a + 128)));
    const u = `
`;
    for (; 0 > (o = h.indexOf(u)) && n < t && a < e.byteLength; )
      l += h, n += h.length, a += 128, h += String.fromCharCode.apply(null, new Uint16Array(e.subarray(a, a + 128)));
    return -1 < o ? (r !== false && (e.pos += n + o + 1), l + h.slice(0, o)) : false;
  }
  paserHeader(e) {
    const t = /^#\?(\S+)/, r = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, i = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, a = /^\s*FORMAT=(\S+)\s*$/, o = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, n = new go();
    let l, h;
    if (e.pos >= e.byteLength || !(l = this.parserBlock(e)))
      return this.parseError(1, "no header found");
    if (!(h = l.match(t)))
      return this.parseError(3, "bad initial token");
    const u = 1, c = 2, f = 4;
    for (n.valid |= u, n.programtype = h[1], n.string += l + `
`; l = this.parserBlock(e), l !== false; ) {
      if (n.string += l + `
`, l.charAt(0) === "#") {
        n.comments += l + `
`;
        continue;
      }
      if ((h = l.match(r)) && (n.gamma = Math.floor(parseFloat(h[1]) * 10) / 10), (h = l.match(i)) && (n.exposure = Math.floor(parseFloat(h[1]) * 10) / 10), (h = l.match(a)) && (n.valid |= c, n.format = h[1]), (h = l.match(o)) && (n.valid |= f, n.height = parseInt(h[1], 10), n.width = parseInt(h[2], 10)), n.valid & c && n.valid & f)
        break;
    }
    return n.valid & c ? n.valid & f ? n : (this.parseError(3, "missing image size specifier"), null) : (this.parseError(3, "missing format specifier"), null);
  }
  parserPixel(e, t, r) {
    const i = t;
    if (i < 8 || i > 32767 || e[0] !== 2 || e[1] !== 2 || e[2] & 128)
      return new Uint8Array(e);
    if (i !== (e[2] << 8 | e[3]))
      return this.parseError(3, "wrong scanline width");
    const a = new Uint8Array(4 * t * r);
    if (!a.length)
      return this.parseError(4, "unable to allocate buffer space");
    let o = 0, n = 0;
    const l = 4 * i, h = new Uint8Array(4), u = new Uint8Array(l);
    let c = r;
    for (; c > 0 && n < e.byteLength; ) {
      if (n + 4 > e.byteLength)
        return this.parseError(1, "");
      if (h[0] = e[n++], h[1] = e[n++], h[2] = e[n++], h[3] = e[n++], h[0] != 2 || h[1] != 2 || (h[2] << 8 | h[3]) != i)
        return this.parseError(3, "bad rgbe scanline format");
      let f = 0, g;
      for (; f < l && n < e.byteLength; ) {
        g = e[n++];
        const A = g > 128;
        if (A && (g -= 128), g === 0 || f + g > l)
          return this.parseError(3, "bad scanline data");
        if (A) {
          const _ = e[n++];
          for (let x = 0; x < g; x++)
            u[f++] = _;
        } else
          u.set(e.subarray(n, n + g), f), f += g, n += g;
      }
      const m = i;
      for (let A = 0; A < m; A++) {
        let _ = 0;
        a[o] = u[A + _], _ += i, a[o + 1] = u[A + _], _ += i, a[o + 2] = u[A + _], _ += i, a[o + 3] = u[A + _], o += 4;
      }
      c--;
    }
    return a;
  }
  rbgeToFloat(e, t, r, i) {
    const a = e[t + 3], o = Math.pow(2, a - 128) / 255;
    r[i + 0] = e[t + 0] * o, r[i + 1] = e[t + 1] * o, r[i + 2] = e[t + 2] * o, r[i + 3] = 1;
  }
  rbgeToHalfFloat(e, t, r, i) {
    const a = e[t + 3], o = Math.pow(2, a - 128) / 255;
    r[i + 0] = Zr(e[t + 0] * o), r[i + 1] = Zr(e[t + 1] * o), r[i + 2] = Zr(e[t + 2] * o), r[i + 3] = Zr(1);
  }
};
var $h = `
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;
var eu = class {
  static importantSample(e, t, r, i) {
    const a = w.device;
    this.pipeline == null && (this.pipeline = a.createComputePipeline({ layout: "auto", compute: { module: a.createShaderModule({ code: $h }), entryPoint: "main" } }));
    const o = this.pipeline, n = 4 * 4;
    this.configBuffer || (this.configBuffer = a.createBuffer({ size: n, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST })), a.queue.writeBuffer(this.configBuffer, 0, new Uint32Array([e.width, e.height, t, t]));
    const l = 4 * 6;
    if (!this.quaternionBuffer) {
      this.quaternionBuffer = a.createBuffer({ size: l * 4 * 6, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
      let _ = new Float32Array(4 * 6);
      for (let x = 0; x < 6; x++) {
        let C = co.getRotationToFace(x);
        _[x * 4 + 0] = C.x, _[x * 4 + 1] = C.y, _[x * 4 + 2] = C.z, _[x * 4 + 3] = C.w;
      }
      a.queue.writeBuffer(this.quaternionBuffer, 0, _);
    }
    this.blurSettingBuffer || (this.blurSettingBuffer = a.createBuffer({ size: n, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST })), a.queue.writeBuffer(this.blurSettingBuffer, 0, new Float32Array([r, 0, 0, 0]));
    const h = e.erpTexture;
    let u = [{ binding: 0, resource: { buffer: this.configBuffer, size: 4 * 4 } }, { binding: 1, resource: { buffer: this.quaternionBuffer, size: l * 4 } }, { binding: 2, resource: h.gpuSampler }, { binding: 3, resource: h.getGPUView() }], c = [{ binding: 0, resource: { buffer: this.blurSettingBuffer, size: 4 * 4 } }, { binding: 1, resource: i }];
    const f = a.createBindGroup({ layout: o.getBindGroupLayout(0), entries: u }), g = a.createBindGroup({ layout: o.getBindGroupLayout(1), entries: c }), m = y.beginCommandEncoder(), A = m.beginComputePass();
    A.setPipeline(o), A.setBindGroup(0, f), A.setBindGroup(1, g), A.dispatchWorkgroups(t / 8, t / 8, 6), A.end(), y.endCommandEncoder(m);
  }
};
__publicField(eu, "configBuffer", null);
__publicField(eu, "quaternionBuffer", null);
__publicField(eu, "blurSettingBuffer", null);
__publicField(eu, "pipeline");
var mo = class {
  constructor(e) {
    __publicField(this, "faceTextureRef");
    __publicField(this, "_texture");
    this._texture = e, this.faceTextureRef = {};
  }
  uploadTexture(e, t) {
    let r = this.getGpuSource(e);
    return ut.makeTextureCube(t, this._texture.width, r.v), this;
  }
  uploadErpTexture(e) {
    let t = this.getGpuSource(0);
    return ut.makeTextureCube(e, this._texture.width, t.v), this.generateMipmap(e), this;
  }
  getGpuSource(e) {
    let t = this.faceTextureRef[e];
    return t || (t = { t: this._texture.getGPUTexture(), v: this._texture.getGPUTexture().createView({ format: this._texture.format, dimension: "2d-array", baseMipLevel: e, mipLevelCount: 1, arrayLayerCount: 6 }) }, this.faceTextureRef[e] = t), t;
  }
  generateMipmap(e) {
    let t = 1;
    for (; t < this._texture.mipmapCount; )
      this.generateMipmapAtLevel(t, e), t++;
  }
  generateMipmapAtLevel(e, t, r = 3) {
    let i = this._texture.width / Math.pow(2, e), a = { width: i, height: i, erpTexture: t }, o = (e + 1) / this._texture.mipmapCount;
    o = Math.pow(o, r);
    let n = this.getGpuSource(e);
    eu.importantSample(a, i, o, n.v);
  }
};
var Ia = class extends wa {
  constructor() {
    super();
    __publicField(this, "_url");
    __publicField(this, "_faceData");
    this.useMipmap = true, this.format = N.rgba16float, this.isHDRTexture = true, this._faceData = new mo(this);
  }
  createFromHDRData(e, t) {
    let r = new de(t.width, t.height, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING), i = new Float32Array(t.array);
    return ut.convertRGBE2RGBA(r, i), this.createFromTexture(e, r), this;
  }
  createFromTexture(e, t) {
    this.width = this.height = e, this.textureBindingLayout.viewDimension = "cube";
    let r = this.width;
    for (this.mipmapCount = 1; r > 16; )
      r /= 2, this.mipmapCount++;
    return this.createTextureDescriptor(e, e, this.mipmapCount, this.format), this.textureDescriptor.size = { width: e, height: e, depthOrArrayLayers: 6 }, this.textureDescriptor.dimension = "2d", this.gpuSampler = w.device.createSampler(this), this._faceData.uploadErpTexture(t), this;
  }
  async load(e, t) {
    return this._url = e, (await new tt().load(e, po, t)).getCubeTexture();
  }
};
function tu(s) {
  return new TextDecoder().decode(s);
}
var ba = class {
  constructor(e, t, r, i) {
    __publicField(this, "buffer");
    __publicField(this, "binOffset");
    __publicField(this, "binLength");
    __publicField(this, "header");
    this.buffer = e, this.binOffset = t + r, this.binLength = i;
    let a = null;
    if (r !== 0) {
      const o = new Uint8Array(e, t, r);
      a = JSON.parse(tu(o));
    } else
      a = {};
    this.header = a;
  }
  getKeys() {
    return Object.keys(this.header);
  }
  getData(e, t, r = null, i = null) {
    const a = this.header;
    if (!(e in a))
      return null;
    const o = a[e];
    if (o instanceof Object) {
      if (Array.isArray(o))
        return o;
      {
        const { buffer: n, binOffset: l, binLength: h } = this, u = o.byteOffset || 0, c = o.type || i, f = o.componentType || r;
        if ("type" in o && i && o.type !== i)
          throw new Error("FeatureTable: Specified type does not match expected type.");
        let g;
        switch (c) {
          case "SCALAR":
            g = 1;
            break;
          case "VEC2":
            g = 2;
            break;
          case "VEC3":
            g = 3;
            break;
          case "VEC4":
            g = 4;
            break;
          default:
            throw new Error(`FeatureTable : Feature type not provided for "${e}".`);
        }
        let m;
        const A = l + u, _ = t * g;
        switch (f) {
          case "BYTE":
            m = new Int8Array(n, A, _);
            break;
          case "UNSIGNED_BYTE":
            m = new Uint8Array(n, A, _);
            break;
          case "SHORT":
            m = new Int16Array(n, A, _);
            break;
          case "UNSIGNED_SHORT":
            m = new Uint16Array(n, A, _);
            break;
          case "INT":
            m = new Int32Array(n, A, _);
            break;
          case "UNSIGNED_INT":
            m = new Uint32Array(n, A, _);
            break;
          case "FLOAT":
            m = new Float32Array(n, A, _);
            break;
          case "DOUBLE":
            m = new Float64Array(n, A, _);
            break;
          default:
            throw new Error(`FeatureTable : Feature component type not provided for "${e}".`);
        }
        if (A + _ * m.BYTES_PER_ELEMENT > l + h)
          throw new Error("FeatureTable: Feature data read outside binary body length.");
        return m;
      }
    } else
      return o;
  }
};
var Ao = class extends ba {
  constructor(e, t, r, i, a) {
    super(e, r, i, a);
    __publicField(this, "batchSize");
    this.batchSize = t;
  }
  getData(e, t = null, r = null) {
    return super.getData(e, this.batchSize, t, r);
  }
};
function vo(s) {
  let e;
  if (s instanceof DataView ? e = s : e = new DataView(s), String.fromCharCode(e.getUint8(0)) === "{")
    return null;
  let t = "";
  for (let r = 0; r < 4; r++)
    t += String.fromCharCode(e.getUint8(r));
  return t;
}
var ru = class {
  async parse(e) {
    const t = new DataView(e), r = vo(t);
    console.assert(r === "b3dm");
    const i = t.getUint32(4, true);
    console.assert(i === 1);
    const a = t.getUint32(8, true);
    console.assert(a === e.byteLength);
    const o = t.getUint32(12, true), n = t.getUint32(16, true), l = t.getUint32(20, true), h = t.getUint32(24, true), u = 28, c = new ba(e, u, o, n), f = u + o + n, g = new Ao(e, c.getData("BATCH_LENGTH"), f, l, h), m = f + l + h, A = new Uint8Array(e, m, a - m);
    return { version: i, featureTable: c, batchTable: g, glbBytes: A };
  }
};
var _or = class _or extends ru {
  constructor() {
    super();
    __publicField(this, "adjustmentTransform");
    __publicField(this, "gltfBuffer");
    this.adjustmentTransform = new P().identity(), _or.tempMatrix || (_or.tempMatrix = new P().identity());
  }
  async parse(e) {
    const t = await super.parse(e);
    this.gltfBuffer = t.glbBytes.slice().buffer;
    let i = await new _o().parseBinary(this.gltfBuffer), { batchTable: a, featureTable: o } = t;
    const n = o.getData("RTC_CENTER");
    n && (i.x += n[0], i.y += n[1], i.z += n[2]);
    let l = i.getComponent(ht);
    l.updateWorldMatrix();
    let h = _or.tempMatrix;
    h.compose(l.localPosition, l.localRotQuat, l.localScale), h.multiply(this.adjustmentTransform);
    let u = h.decompose(Zt.QUATERNION);
    return l.localRotQuat.copyFrom(u[1]), l.localRotQuat = l.localRotQuat, l.localPosition.copyFrom(u[0]), l.localPosition = l.localPosition, l.localScale.copyFrom(u[2]), l.localScale = l.localScale, l.updateWorldMatrix(), i.batchTable = a, i.featureTable = o, i;
  }
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
};
__publicField(_or, "tempMatrix");
var or = _or;
var iu = class extends rt {
  async parseBuffer(e) {
    let t = new or();
    t.adjustmentTransform = this.userData, this.data = await t.parse(e);
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
};
__publicField(iu, "format", Ue.JSON);
var au = "glTF";
var Pi = 12;
var su = { JSON: 1313821514, BIN: 5130562 };
var xo = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
var ou = class {
  constructor(e) {
    __publicField(this, "name");
    __publicField(this, "content");
    __publicField(this, "body");
    __publicField(this, "header");
    this.name = xo.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, Pi);
    if (this.header = { magic: or.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, true), length: t.getUint32(8, true) }, this.header.magic !== au)
      throw new Error("GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - Pi, i = new DataView(e, Pi);
    let a = 0;
    for (; a < r; ) {
      const o = i.getUint32(a, true);
      a += 4;
      const n = i.getUint32(a, true);
      if (a += 4, n === su.JSON) {
        const l = new Uint8Array(e, Pi + a, o);
        this.content = or.decodeText(l);
      } else if (n === su.BIN) {
        const l = Pi + a;
        this.body = e.slice(l, l + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("GLTFLoader: JSON content not found.");
  }
};
var _o = class {
  constructor() {
    __publicField(this, "_binary");
  }
  async parseBinary(e) {
    this._binary = e;
    const t = or.decodeText(new Uint8Array(this._binary, 0, 4)), r = {};
    let i, a;
    if (t === au) {
      try {
        a = r[xo.KHR_BINARY_GLTF] = new ou(this._binary);
      } catch {
        return;
      }
      i = r[xo.KHR_BINARY_GLTF].content;
    } else
      i = or.decodeText(new Uint8Array(this._binary));
    const o = JSON.parse(i);
    return await this.parseGLB(o, a.body);
  }
  async parseGLB(e, t) {
    return await new ho().parseJsonAndBuffer(e, t);
  }
};
var nu = class {
  async parse(e) {
    const t = new DataView(e), r = vo(t);
    console.assert(r === "i3dm");
    const i = t.getUint32(4, true);
    console.assert(i === 1);
    const a = t.getUint32(8, true);
    console.assert(a === e.byteLength);
    const o = t.getUint32(12, true), n = t.getUint32(16, true), l = t.getUint32(20, true), h = t.getUint32(24, true);
    t.getUint32(28, true);
    const u = 32, c = new ba(e, u, o, n), f = u + o + n, g = new Ao(e, c.getData("INSTANCES_LENGTH"), f, l, h), m = f + l + h, A = new Uint8Array(e, m, a - m);
    return { version: i, featureTable: c, batchTable: g, glbBytes: A };
  }
};
var lu = class extends Y {
  constructor(e, t, r) {
    super();
    __publicField(this, "_geometry");
    __publicField(this, "_material");
    __publicField(this, "_instanceList");
    this._geometry = e, this._material = t, this._instanceList = [];
    for (let i = 0; i < r; i++) {
      let a, o = new Y();
      a = o.addComponent(J), a.geometry = this._geometry, a.material = this._material, this.addChild(o), this._instanceList.push(o);
    }
  }
  setMatrixAt(e, t) {
    let r = this._instanceList[e], i = t.decompose(Zt.QUATERNION), a = r.transform;
    return a.localRotQuat.copyFrom(i[1]), a.localRotQuat = a.localRotQuat, a.localPosition.copyFrom(i[0]), a.localPosition = a.localPosition, a.localScale.copyFrom(i[2]), a.localScale = a.localScale, this;
  }
};
var _Ot = class _Ot extends nu {
  constructor() {
    super();
    __publicField(this, "adjustmentTransform");
    __publicField(this, "_gltfBuffer");
    _Ot.tempFwd || (_Ot.tempFwd = new d()), _Ot.tempUp || (_Ot.tempUp = new d()), _Ot.tempRight || (_Ot.tempRight = new d()), _Ot.tempPos || (_Ot.tempPos = new d()), _Ot.tempQuat || (_Ot.tempQuat = new H()), _Ot.tempSca || (_Ot.tempSca = new d()), _Ot.tempMat || (_Ot.tempMat = new P()), this.adjustmentTransform = new P().identity();
  }
  async parse(e) {
    const t = await super.parse(e);
    this._gltfBuffer = t.glbBytes.slice().buffer;
    let i = await new _o().parseBinary(this._gltfBuffer), { batchTable: a, featureTable: o } = t;
    const n = this.adjustmentTransform, l = o.getData("INSTANCES_LENGTH"), h = o.getData("POSITION", l, "FLOAT", "VEC3"), u = o.getData("NORMAL_UP", l, "FLOAT", "VEC3"), c = o.getData("NORMAL_RIGHT", l, "FLOAT", "VEC3"), f = o.getData("SCALE_NON_UNIFORM", l, "FLOAT", "VEC3"), g = o.getData("SCALE", l, "FLOAT", "SCALAR"), m = /* @__PURE__ */ new Map(), A = [];
    i.traverse((C) => {
      let S;
      if (S = C ? C.getComponent(J) : null, S) {
        const { geometry: I, material: T } = S, b = new lu(I, T, l);
        b.localPosition = b.localPosition.copy(C.localPosition), b.localRotation = b.localRotation.copy(C.localRotation), b.localScale = b.localScale.copy(C.localScale), A.push(b), m.set(C, b);
      }
    });
    const _ = new d();
    for (let C = 0; C < l; C++)
      _.x += h[C * 3 + 0] / l, _.y += h[C * 3 + 1] / l, _.z += h[C * 3 + 2] / l;
    m.forEach((C, S) => {
      const I = S.parent ? S.parentObject : null;
      I && (I.removeChild(S), I.addChild(C), C.transform.updateWorldMatrix(), C.transform.worldMatrix.transformVector4(_, C.localPosition));
    });
    const x = _Ot;
    for (let C = 0; C < l; C++) {
      x.tempMat.identity(), x.tempPos.set(h[C * 3 + 0] - _.x, h[C * 3 + 1] - _.y, h[C * 3 + 2] - _.z), u ? (x.tempUp.set(u[C * 3 + 0], u[C * 3 + 1], u[C * 3 + 2]), x.tempRight.set(c[C * 3 + 0], c[C * 3 + 1], c[C * 3 + 2]), x.tempRight.crossProduct(x.tempUp, x.tempFwd).normalize(), x.tempMat.makeBasis(x.tempRight, x.tempUp, x.tempFwd), x.tempQuat.setFromRotationMatrix(x.tempMat)) : x.tempQuat.set(0, 0, 0, 1), g ? x.tempSca.setScalar(g[C]) : f ? x.tempSca.set(f[C * 3 + 0], f[C * 3 + 1], f[C * 3 + 2]) : x.tempSca.set(1, 1, 1), x.tempMat.compose(x.tempPos, x.tempQuat, x.tempSca), x.tempMat.multiplyMatrices(x.tempMat, n);
      for (let S = 0, I = A.length; S < I; S++)
        A[S].setMatrixAt(C, x.tempMat);
    }
    return i.batchTable = a, i.featureTable = o, i;
  }
};
__publicField(_Ot, "tempFwd");
__publicField(_Ot, "tempUp");
__publicField(_Ot, "tempRight");
__publicField(_Ot, "tempPos");
__publicField(_Ot, "tempQuat");
__publicField(_Ot, "tempSca");
__publicField(_Ot, "tempMat");
var Ot = _Ot;
var hu = class extends rt {
  async parseBuffer(e) {
    let t = new Ot();
    t.adjustmentTransform = this.userData, this.data = await t.parse(e);
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
};
__publicField(hu, "format", Ue.BIN);
var Ea = class extends wa {
  constructor() {
    super();
    __publicField(this, "_faceData");
    __publicField(this, "_url");
    this.useMipmap = true, this.format = N.rgba16float, this._faceData = new mo(this);
  }
  get ldrImageUrl() {
    return this._url;
  }
  async load(e, t) {
    this._url = e;
    let r = new rr(false);
    return await r.load(e, t), this.createFromLDRTexture(r), this;
  }
  createFromLDRTexture(e) {
    let t = Math.log2(e.width / 4);
    return t = Math.pow(2, Math.round(t)), this.createFromTexture(t, e), this;
  }
  createFromTexture(e, t) {
    this.width = this.height = e, this.textureBindingLayout.viewDimension = "cube";
    let r = this.width;
    for (this.mipmapCount = 1; r > 16; )
      r /= 2, this.mipmapCount++;
    return this.createTextureDescriptor(e, e, this.mipmapCount, this.format), this.textureDescriptor.size = { width: e, height: e, depthOrArrayLayers: 6 }, this.textureDescriptor.dimension = "2d", this.gpuSampler = w.device.createSampler(this), this._faceData.uploadErpTexture(t), this;
  }
};
var uu = `
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;
var cu = class {
  constructor() {
    __publicField(this, "compute");
    this.compute = new ae(uu);
  }
  generateBRDFLUTTexture() {
    let e = new de(256, 256, N.rgba8unorm, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
    this.compute.setStorageTexture("brdflutTexture", e), this.compute.workerSizeX = 256 / 8, this.compute.workerSizeY = 256 / 8;
    let t = y.beginCommandEncoder();
    return y.computeCommand(t, [this.compute]), y.endCommandEncoder(t), e;
  }
};
var fu = class extends Re {
  constructor() {
    super(...arguments);
    __publicField(this, "_dataBuffer");
  }
  create(e, t, r, i = false) {
    let a = w.device;
    const o = Math.ceil(e * 4 / 256) * 256;
    this.format = N.rgba8unorm, this.mipmapCount = Math.floor(i ? Math.log2(e) : 1), this.createTextureDescriptor(e, t, this.mipmapCount, this.format);
    const n = this._dataBuffer = a.createBuffer({ size: r.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    a.queue.writeBuffer(n, 0, r);
    const l = y.beginCommandEncoder();
    return l.copyBufferToTexture({ buffer: n, bytesPerRow: o }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(l), i && at.webGPUGenerateMipmap(this), this;
  }
  updateTexture(e, t, r) {
    let i = w.device;
    const a = Math.ceil(e * 4 / 256) * 256;
    this.mipmapCount = Math.floor(Math.log2(e)), this._dataBuffer && this._dataBuffer.destroy(), this._dataBuffer = null;
    const o = this._dataBuffer = i.createBuffer({ size: r.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    i.queue.writeBuffer(o, 0, r);
    const n = y.beginCommandEncoder();
    n.copyBufferToTexture({ buffer: o, bytesPerRow: a }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(n), this.gpuSampler = i.createSampler(this), this.mipmapCount > 1 && at.webGPUGenerateMipmap(this);
  }
};
var $r = class {
  constructor(e) {
    __publicField(this, "id");
    __publicField(this, "guiTexture");
    __publicField(this, "uvRec", new G(0, 0, 1, 1));
    __publicField(this, "uvBorder", new G(0, 0, 0, 0));
    __publicField(this, "offsetSize", new G(0, 0, 4, 4));
    __publicField(this, "borderSize", new G(0, 0, 0, 0));
    __publicField(this, "trimSize", new Q());
    __publicField(this, "isSliced", false);
    __publicField(this, "height", 4);
    __publicField(this, "width", 4);
    __publicField(this, "xadvance", 0);
    __publicField(this, "xoffset", 0);
    __publicField(this, "yoffset", 0);
    this.guiTexture = e || p.res.defaultGUITexture;
  }
};
var _wr = class _wr {
  constructor(e) {
    __publicField(this, "_staticId", -1);
    __publicField(this, "dynamicId", -1);
    __publicField(this, "texture");
    __publicField(this, "width", 1);
    __publicField(this, "height", 1);
    e || (e = p.res.whiteTexture), this.texture = e, _wr._maxUid++, this._staticId = _wr._maxUid, this.init();
  }
  get staticId() {
    return this._staticId;
  }
  init() {
    this.dynamicId = -1, this.width = this.texture.width, this.height = this.texture.height;
  }
};
__publicField(_wr, "_maxUid", -1);
var wr = _wr;
var yg = class {
  constructor() {
    __publicField(this, "fntCache", {});
    __publicField(this, "fntData", {});
  }
  addFontData(e, t, r) {
    this.fntData[`${e}${t}`] = r;
  }
  getFontData(e, t) {
    return this.fntData[`${e}${t}`];
  }
  addFnt(e, t, r, i) {
    let a = `${e}${t}`;
    this.fntCache[a] || (this.fntCache[a] = {}), this.fntCache[a][r] = i;
  }
  getFnt(e, t, r) {
    let i = `${e}${t}`, a = this.fntCache[i];
    return a ? a[r] : this.fntCache[" "];
  }
};
var ei = new yg();
var du = class {
  constructor() {
    __publicField(this, "face", "");
    __publicField(this, "size", 0);
    __publicField(this, "bold", false);
    __publicField(this, "italic", false);
    __publicField(this, "stretchH", 0);
    __publicField(this, "spacing", "");
    __publicField(this, "outline", 0);
    __publicField(this, "lineHeight", 0);
    __publicField(this, "base", 0);
    __publicField(this, "scaleW", 0);
    __publicField(this, "scaleH", 0);
    __publicField(this, "pages", 0);
    __publicField(this, "packed", 0);
    __publicField(this, "alphaChnl", 0);
    __publicField(this, "redChnl", 0);
    __publicField(this, "greenChnl", 0);
    __publicField(this, "blueChnl", 0);
    __publicField(this, "count", 0);
    __publicField(this, "fontPage", []);
    __publicField(this, "fontChar", {});
  }
};
var gu = class {
  constructor() {
    __publicField(this, "id", 0);
    __publicField(this, "file", "");
  }
};
var pu = class {
  constructor() {
    __publicField(this, "id", -1);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "width", 0);
    __publicField(this, "height", 0);
    __publicField(this, "xoffset", 0);
    __publicField(this, "yoffset", 0);
    __publicField(this, "xadvance", 0);
    __publicField(this, "page", 0);
    __publicField(this, "chnl", 0);
  }
};
var _nr = class _nr extends rt {
  static parseSprite(e, t) {
    for (const r in t.fontChar)
      if (Object.prototype.hasOwnProperty.call(t.fontChar, r)) {
        const i = t.fontChar[r];
        let a = new $r();
        a.id = i.id.toString(), a.offsetSize.set(0, 0, i.width, i.height), a.trimSize.set(i.width, i.height), a.width = i.width, a.height = i.height, a.xadvance = i.xadvance, a.xoffset = i.xoffset, a.yoffset = i.yoffset, a.guiTexture = e[i.page], a.uvRec.set(i.x / t.scaleW, (t.scaleH - (i.y + i.height)) / t.scaleH, i.width / t.scaleW, i.height / t.scaleH), ei.addFnt(t.face, t.size, a.id, a);
      }
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("Method not implemented.");
  }
  async parseString(e) {
    let t = this.getNewLine(e), r = e, i = new du();
    r.trim().split(t).forEach((a, o) => {
      if (o < 2)
        _nr.readLineProperty(a, i);
      else if (o < i.pages + 2) {
        let n = new gu();
        _nr.readLineProperty(a, n), i.fontPage.push(n);
      } else if (o < i.pages + 3)
        _nr.readLineProperty(a, i);
      else if (i.count > 0) {
        let n = new pu();
        _nr.readLineProperty(a, n), i.fontChar[n.id] = n, i.count--;
      }
    }), r = "", this.data = i, await this.loadFontTextures();
  }
  getNewLine(e) {
    return e.indexOf(`\r
`) != -1 ? `\r
` : e.indexOf("\r") != -1 ? "\r" : `
`;
  }
  async loadFontTextures() {
    let e = [], t = this.data;
    for (const r of t.fontPage) {
      let i = this.baseUrl + r.file;
      await p.res.loadTexture(i, null, true);
      let a = p.res.getTexture(i), o = new wr(a);
      e.push(o);
    }
    _nr.parseSprite(e, t), t.fontChar[" "] || _nr.insertSpaceChar(t, e[0]);
  }
  static insertSpaceChar(e, t) {
    let r = new $r(), i = e.size * 0.5, a = e.lineHeight * 0.5;
    r.id = " ", r.offsetSize.set(0, 0, e.size, e.size), r.trimSize.set(i, a), r.width = i, r.height = a, r.xadvance = 0, r.xoffset = 0, r.yoffset = 0, r.guiTexture = t, r.uvRec.set(0, 0, 1e-6, 1e-6), ei.addFnt(e.face, e.size, r.id, r);
  }
  static readLineProperty(e, t) {
    e.trim().split(" ").forEach((r, i) => {
      let a = r.split("=");
      if (a.length > 1) {
        let o = a[0], n = a[1];
        Object.prototype.hasOwnProperty.call(t, o) && (n.indexOf('"') == -1 ? t[o] = parseFloat(a[1]) : t[o] = n.replace('"', "").replace('"', ""));
      }
    });
  }
};
__publicField(_nr, "format", Ue.TEXT);
var nr = _nr;
function wg(s, e) {
  let t = new $r();
  return t.id = s, t.offsetSize.set(0, 0, e.width, e.height), t.trimSize.set(e.width, e.height), t.width = e.width, t.height = e.height, t.xadvance = 0, t.xoffset = 0, t.yoffset = 0, t.guiTexture = new wr(e), t.uvRec.set(0, 0, 1, 1), e.isVideoTexture || (e.flipY = true), t;
}
function mu(s, e, t) {
  let r = new $r();
  r.guiTexture = s, r.id = e, r.uvRec.copyFrom(t.textureRect), r.trimSize.x = t.textureRect.z, r.trimSize.y = t.textureRect.w, r.offsetSize.x = t.textureRectOffset.x, r.offsetSize.y = t.textureRectOffset.y, r.offsetSize.z = t.size.x, r.offsetSize.w = t.size.y, r.width = t.size.x, r.height = t.size.y;
  let i = 1 / s.width, a = 1 / s.height;
  r.uvRec.set(r.uvRec.x * i, r.uvRec.y * a, r.uvRec.z * i, r.uvRec.w * a);
  let o = 0.1;
  return t.border.x <= o && t.border.y <= o && t.border.z <= o && t.border.x <= o ? r.isSliced = false : (r.borderSize.copyFrom(t.border), r.uvBorder.copyFrom(t.border), r.uvBorder.x -= t.textureRectOffset.x, r.uvBorder.y -= t.textureRectOffset.y, r.uvBorder.z = t.border.z - (t.size.x - t.textureRect.z - t.textureRectOffset.x), r.uvBorder.w = t.border.w - (t.size.y - t.textureRect.w - t.textureRectOffset.y), r.uvBorder.x /= t.textureRect.z, r.uvBorder.z /= t.textureRect.z, r.uvBorder.y /= t.textureRect.w, r.uvBorder.w /= t.textureRect.w, r.isSliced = true), r;
}
var Au = class {
  constructor(e) {
    __publicField(this, "_spriteMap", /* @__PURE__ */ new Map());
    __publicField(this, "_spriteList", []);
    __publicField(this, "textureSize", new Q());
    __publicField(this, "name");
    this.textureSize.set(e.x, e.y);
  }
  setTexture(e, t, r) {
    let i = mu(e, t, r);
    return this._spriteMap.set(i.id, i), this._spriteList.push(i), i;
  }
  getSprite(e) {
    return this._spriteMap.get(e);
  }
  get spriteList() {
    return this._spriteList;
  }
};
var vu = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "_json");
    __publicField(this, "_texture");
  }
  async parseString(e) {
    this._json = JSON.parse(e);
    let t = this.userData.replace(".json", ".png");
    this._texture = await p.res.loadTexture(t, null, true), this.data = { json: this._json, texture: this._texture }, this.parseAtlas();
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
  parseAtlas() {
    let e = new Au(this._json.size), t = new wr(this._texture), r = this._json.atlas;
    for (const i in r)
      e.setTexture(t, i, r[i]);
    p.res.addAtlas(this.baseUrl, e), this.data = e;
  }
};
__publicField(vu, "format", Ue.TEXT);
var xu = class {
  constructor() {
    __publicField(this, "_texturePool");
    __publicField(this, "_materialPool");
    __publicField(this, "_prefabPool");
    __publicField(this, "_gltfPool");
    __publicField(this, "_geometryPool");
    __publicField(this, "_atlasList");
    __publicField(this, "_obj");
    __publicField(this, "normalTexture");
    __publicField(this, "maskTexture");
    __publicField(this, "whiteTexture");
    __publicField(this, "blackTexture");
    __publicField(this, "redTexture");
    __publicField(this, "blueTexture");
    __publicField(this, "greenTexture");
    __publicField(this, "yellowTexture");
    __publicField(this, "grayTexture");
    __publicField(this, "defaultSky");
    __publicField(this, "defaultGUITexture");
    __publicField(this, "defaultGUISprite");
    __publicField(this, "defaultMaterial");
    this._texturePool = /* @__PURE__ */ new Map(), this._materialPool = /* @__PURE__ */ new Map(), this._prefabPool = /* @__PURE__ */ new Map(), this._geometryPool = /* @__PURE__ */ new Map(), this._gltfPool = /* @__PURE__ */ new Map(), this._atlasList = /* @__PURE__ */ new Map(), this._obj = /* @__PURE__ */ new Map();
  }
  getGltf(e) {
    return this._gltfPool.get(e);
  }
  addObj(e, t) {
    this._obj.set(e, t);
  }
  getObj(e) {
    return this._obj.get(e);
  }
  addTexture(e, t) {
    this._texturePool.set(e, t);
  }
  getTexture(e) {
    return this._texturePool.get(e);
  }
  addGeometry(e, t) {
    this._geometryPool.set(e, t);
  }
  getGeometry(e) {
    return this._geometryPool.get(e);
  }
  addMat(e, t) {
    return this._materialPool.set(e, t);
  }
  getMat(e) {
    return this._materialPool.get(e);
  }
  addPrefab(e, t) {
    this._prefabPool.set(e, t);
  }
  getPrefab(e) {
    return this._prefabPool.get(e).instantiate();
  }
  addAtlas(e, t) {
    t.name = e, this._atlasList.set(e, t);
  }
  getAtlas(e) {
    return this._atlasList.get(e);
  }
  getGUISprite(e) {
    for (let t of this._atlasList.values()) {
      let r = t.getSprite(e);
      if (r)
        return r;
    }
    return null;
  }
  async load(e, t, r) {
    return (await new tt().load(e, t, r)).data;
  }
  async loadGltf(e, t) {
    if (this._prefabPool.has(e))
      return this._prefabPool.get(e);
    let r, i = e.substring(e.lastIndexOf(".")).toLowerCase(), a = new tt();
    i == ".gltf" ? r = await a.load(e, qe, t) : r = await a.load(e, ho, t);
    let o = r.data;
    return this._prefabPool.set(e, o), this._gltfPool.set(e, r.gltf), o;
  }
  async loadObj(e, t) {
    if (this._prefabPool.has(e))
      return this._prefabPool.get(e);
    let r, i = e.substring(e.lastIndexOf(".")).toLowerCase(), a = new tt();
    i == ".obj" && (r = await a.load(e, Hh, t));
    let o = r.data;
    return this._prefabPool.set(e, o), o;
  }
  async loadB3DM(e, t, r) {
    if (this._prefabPool.has(e))
      return this._prefabPool.get(e);
    let o = (await new tt().load(e, iu, t, r)).data;
    return this._prefabPool.set(e, o), o;
  }
  async loadI3DM(e, t, r) {
    if (this._prefabPool.has(e))
      return this._prefabPool.get(e);
    let o = (await new tt().load(e, hu, t, r)).data;
    return this._prefabPool.set(e, o), o;
  }
  async loadTexture(e, t, r) {
    if (this._texturePool.has(e))
      return this._texturePool.get(e);
    let i = new rr();
    return i.flipY = r, await i.load(e, t), this._texturePool.set(e, i), i;
  }
  async loadTextureCount(e, t, r, i) {
    return new Promise(async (a, o) => {
      let n = 0, l = [];
      t == 0 && a(l);
      for (let h = 0; h < t; h++) {
        const u = e.shift();
        this.loadTexture(u, r, i).then((c) => {
          l.push(c), n++, n == t && a(l);
        });
      }
    });
  }
  async loadBitmapTextures(e, t = 5, r, i) {
    let a = [], o = Math.floor(e.length / t) + 1, n = Math.floor(e.length % t);
    for (let l = 0; l < o; l++) {
      let h = await this.loadTextureCount(e, l == o - 1 ? n : t, r, i);
      a.push(...h);
    }
    return a;
  }
  async loadHDRTexture(e, t) {
    if (this._texturePool.has(e))
      return this._texturePool.get(e);
    let r = new fo();
    return r = await r.load(e, t), this._texturePool.set(e, r), r;
  }
  async loadHDRTextureCube(e, t) {
    if (this._texturePool.has(e))
      return this._texturePool.get(e);
    let r = new Ia();
    return r = await r.load(e, t), this._texturePool.set(e, r), r;
  }
  async loadLDRTextureCube(e, t) {
    if (this._texturePool.has(e))
      return this._texturePool.get(e);
    let r = new Ea();
    return r = await r.load(e, t), this._texturePool.set(e, r), r;
  }
  async loadTextureCubeMaps(e) {
    let t = e[0];
    if (this._texturePool.has(t))
      return this._texturePool.get(t);
    let r = new uo();
    return await r.load(e), this._texturePool.set(e[0], r), r;
  }
  async loadTextureCubeStd(e, t) {
    if (this._texturePool.has(e))
      return this._texturePool.get(e);
    let r = new uo();
    return await r.loadStd(e), r;
  }
  async loadJSON(e, t) {
    return await new tt().loadJson(e, t).then(async (r) => r).catch((r) => {
      console.log(r);
    });
  }
  async loadFont(e, t, r) {
    let a = await new tt().load(e, nr, t, r), o = a.data;
    return ei.addFontData(o.face, o.size, o), a.data;
  }
  async loadAtlas(e, t) {
    return (await new tt().load(e, vu, t, e)).data;
  }
  createTexture(e, t, r, i, a, o, n) {
    let l = 32, h = 32, u = new Uint8Array(l * h * 4);
    this.fillColor(u, e, t, r, i, a, o);
    let c = new fu();
    return c.name = n, c.create(16, 16, u, true), n && this.addTexture(n, c), c;
  }
  fillColor(e, t, r, i, a, o, n) {
    for (let l = 0; l < t; l++)
      for (let h = 0; h < r; h++) {
        let u = h * t + l;
        e[u * 4 + 0] = i, e[u * 4 + 1] = a, e[u * 4 + 2] = o, e[u * 4 + 3] = n;
      }
  }
  initDefault() {
    this.normalTexture = this.createTexture(32, 32, 255 * 0.5, 255 * 0.5, 255, 255, "default-normalTexture"), this.maskTexture = this.createTexture(32, 32, 255, 255 * 0.5, 255, 255, "default-maskTexture"), this.whiteTexture = this.createTexture(32, 32, 255, 255, 255, 255, "default-whiteTexture"), this.blackTexture = this.createTexture(32, 32, 0, 0, 0, 255, "default-blackTexture"), this.redTexture = this.createTexture(32, 32, 255, 0, 0, 255, "default-redTexture"), this.blueTexture = this.createTexture(32, 32, 0, 0, 255, 255, "default-blueTexture"), this.greenTexture = this.createTexture(32, 32, 0, 255, 0, 255, "default-greenTexture"), this.yellowTexture = this.createTexture(32, 32, 0, 255, 255, 255, "default-yellowTexture"), this.grayTexture = this.createTexture(32, 32, 128, 128, 128, 255, "default-grayTexture");
    let t = new cu().generateBRDFLUTTexture(), r = t.name = "BRDFLUT";
    this.addTexture(r, t), this.defaultSky = new Ia(), this.defaultSky.createFromTexture(128, this.blackTexture), ie.getInstance().attached(this.defaultSky, this), ie.getInstance().attached(t, this), ie.getInstance().attached(this.normalTexture, this), ie.getInstance().attached(this.maskTexture, this), ie.getInstance().attached(this.whiteTexture, this), ie.getInstance().attached(this.blackTexture, this), ie.getInstance().attached(this.redTexture, this), ie.getInstance().attached(this.blueTexture, this), ie.getInstance().attached(this.greenTexture, this), ie.getInstance().attached(this.yellowTexture, this), ie.getInstance().attached(this.grayTexture, this), this.defaultGUITexture = new wr(this.whiteTexture), this.defaultGUISprite = new $r(this.defaultGUITexture), this.defaultGUISprite.trimSize.set(4, 4), this.defaultMaterial = new ar();
  }
};
var Br = class extends wt {
  constructor() {
    super();
    let e = w.presentationSize;
    O.register("FXAA_Shader", Ju);
    let t = this.createRTTexture("FXAAPost", e[0], e[1], N.rgba16float), r = this.createViewQuad("fxaa", "FXAA_Shader", t);
    r.quadShader.setUniform("u_texel", new Q(1 / e[0], 1 / e[1])), r.quadShader.setUniform("u_strength", 4);
  }
  onAttach(e) {
    p.setting.render.postProcessing.fxaa.enable = true;
  }
  onDetach(e) {
    p.setting.render.postProcessing.fxaa.enable = false;
  }
};
var Co = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "_postList");
  }
  init(e) {
    this._postList = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  onEnable() {
    this.activePost();
  }
  onDisable() {
    this.unActivePost();
  }
  activePost() {
    let e = this.transform.view3D, t = p.getRenderJob(e);
    this._postList.forEach((r) => {
      t.addPost(r);
    });
  }
  unActivePost() {
    let e = this.transform.view3D, t = p.getRenderJob(e);
    this._postList.forEach((r) => {
      t.removePost(r);
    });
  }
  addPost(e) {
    if (this._postList.has(e))
      return;
    if (!this._postList.has(Br)) {
      let r = new Br();
      if (this._postList.set(Br, r), this._enable && this.activePost(), e === Br)
        return r;
    }
    let t = new e();
    return this._postList.set(e, t), this._enable && this.activePost(), t;
  }
  removePost(e) {
    if (!this._postList.has(e))
      return;
    let t = this._postList.get(e);
    this._postList.delete(e);
    let r = this.transform.view3D;
    p.getRenderJob(r).removePost(t);
  }
  getPost(e) {
    return this._postList.has(e) ? this._postList.get(e) : null;
  }
};
var p = class {
  static get frameRate() {
    return this._frameRate;
  }
  static set frameRate(e) {
    this._frameRate = e, this._frameRateValue = 1 / e, e >= 360 && (this._frameRateValue = 0);
  }
  static get size() {
    return w.presentationSize;
  }
  static get aspect() {
    return w.aspect;
  }
  static get width() {
    return w.windowWidth;
  }
  static get height() {
    return w.windowHeight;
  }
  static async init(e = {}) {
    console.log("Engine Version", bf), this.setting = { ...this.setting, ...e.engineSetting }, await ee.init(P.allocCount), await w.init(e.canvasConfig), O.init(), er.init(), oe.init(), be.init(), lt.init(), this.res = new xu(), this.res.initDefault(), this._beforeRender = e.beforeRender, this._renderLoop = e.renderLoop, this._lateRender = e.lateRender, this.inputSystem = new Ko(), this.inputSystem.initCanvas(w.canvas);
  }
  static startRenderView(e) {
    this.renderJobs || (this.renderJobs = /* @__PURE__ */ new Map()), this.views = [e];
    let t = new Ks(e);
    return this.renderJobs.set(e, t), w.presentationSize, this.setting.pick.mode == "pixel" && e.scene.getOrAddComponent(Co).addPost(Br), (this.setting.pick.mode == "pixel" || this.setting.pick.mode == "bound") && (e.enablePick = true), this.resume(), t;
  }
  static startRenderViews(e) {
    this.renderJobs || (this.renderJobs = /* @__PURE__ */ new Map()), this.views = e;
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      let i = new Ks(r);
      this.renderJobs.set(r, i);
      let a = w.presentationSize;
      this.setting.pick.mode == "pixel" ? r.scene.addComponent(Co).addPost(Br) : be.createRTTexture(Fe.colorBufferTex_NAME, a[0], a[1], N.rgba16float, false), (this.setting.pick.mode == "pixel" || this.setting.pick.mode == "bound") && (r.enablePick = true);
    }
    this.resume();
  }
  static getRenderJob(e) {
    return this.renderJobs.get(e);
  }
  static pause() {
    this._requestAnimationFrameID != 0 && (cancelAnimationFrame(this._requestAnimationFrameID), this._requestAnimationFrameID = 0);
  }
  static resume() {
    this._requestAnimationFrameID = requestAnimationFrame((e) => this.render(e));
  }
  static render(e) {
    this._deltaTime = e - this._time, this._time = e, this._frameRateValue > 0 ? (this._frameTimeCount += this._deltaTime * 1e-3, this._frameTimeCount >= this._frameRateValue * 0.95 && (this._frameTimeCount = 0, this.updateFrame(e))) : this.updateFrame(e), this.resume();
  }
  static updateFrame(e) {
    ce.delta = e - ce.time, ce.time = e, ce.frame += 1, yr.tick(ce.delta);
    let t = this.views, r = 0;
    for (r = 0; r < t.length; r++) {
      const o = t[r];
      o.scene.waitUpdate(), o.camera.resetPerspective(w.aspect);
    }
    this._beforeRender && this._beforeRender();
    for (const o of ue.componentsBeforeUpdateList) {
      let n = o[0], l = o[1];
      for (const h of l) {
        let u = h[0], c = h[1];
        u.enable && c(n);
      }
    }
    let i = w.device.createCommandEncoder();
    for (const o of ue.componentsComputeList) {
      let n = o[0], l = o[1];
      for (const h of l) {
        let u = h[0], c = h[1];
        u.enable && c(n, i);
      }
    }
    w.device.queue.submit([i.finish()]);
    for (const o of ue.componentsUpdateList) {
      let n = o[0], l = o[1];
      for (const h of l) {
        let u = h[0], c = h[1];
        u.enable && c(n);
      }
    }
    for (const o of ue.graphicComponent) {
      let n = o[0], l = o[1];
      for (const h of l) {
        let u = h[0], c = h[1];
        n && u.enable && c(n);
      }
    }
    this._renderLoop && this._renderLoop(), ee.updateAllContinueTransform(0, P.useCount, 16), oe.modelMatrixBindGroup.writeBuffer(P.useCount * 16), this.renderJobs.forEach((o, n) => {
      o.renderState || o.start(), o.renderFrame();
    });
    for (const o of ue.componentsLateUpdateList) {
      let n = o[0], l = o[1];
      for (const h of l) {
        let u = h[0], c = h[1];
        u.enable && c(n);
      }
    }
    this._lateRender && this._lateRender();
  }
};
__publicField(p, "res");
__publicField(p, "inputSystem");
__publicField(p, "views");
__publicField(p, "_frameRateValue", 0);
__publicField(p, "_frameRate", 360);
__publicField(p, "_frameTimeCount", 0);
__publicField(p, "_deltaTime", 0);
__publicField(p, "_time", 0);
__publicField(p, "_beforeRender");
__publicField(p, "_renderLoop");
__publicField(p, "_lateRender");
__publicField(p, "_requestAnimationFrameID", 0);
__publicField(p, "Engine3D");
__publicField(p, "divB");
__publicField(p, "setting", { occlusionQuery: { enable: true, debug: false }, pick: { enable: true, mode: "bound", detail: "mesh" }, render: { debug: false, renderPassState: 4, renderState_left: 5, renderState_right: 5, renderState_split: 0.5, quadScale: 1, hdrExposure: 1.5, debugQuad: -1, maxPointLight: 1e3, maxDirectLight: 4, maxSportLight: 1e3, drawOpMin: 0, drawOpMax: Number.MAX_SAFE_INTEGER, drawTrMin: 0, drawTrMax: Number.MAX_SAFE_INTEGER, zPrePass: false, useLogDepth: false, gi: false, postProcessing: { bloom: { downSampleStep: 5, downSampleBlurSize: 5, downSampleBlurSigma: 1, upSampleBlurSize: 5, upSampleBlurSigma: 1, luminanceThreshole: 1, bloomIntensity: 1 }, globalFog: { debug: false, enable: false, fogType: 0, fogHeightScale: 0.1, start: 400, end: 10, density: 0.02, ins: 0.5, skyFactor: 0.5, skyRoughness: 0.4, overrideSkyFactor: 0.8, fogColor: new M(96 / 255, 117 / 255, 133 / 255, 1), falloff: 0.7, rayLength: 200, scatteringExponent: 2.7, dirHeightLine: 10 }, godRay: { blendColor: true, rayMarchCount: 16, scatteringExponent: 5, intensity: 0.5 }, ssao: { enable: false, radius: 0.15, bias: -0.1, aoPower: 2, debug: true }, outline: { enable: false, strength: 1, groupCount: 4, outlinePixel: 2, fadeOutlinePixel: 4, textureScale: 0.7, useAddMode: false, debug: true }, taa: { enable: false, jitterSeedCount: 8, blendFactor: 0.1, sharpFactor: 0.6, sharpPreBlurFactor: 0.5, temporalJitterScale: 0.13, debug: true }, gtao: { enable: false, darkFactor: 1, maxDistance: 5, maxPixel: 50, rayMarchSegment: 6, multiBounce: false, usePosFloat32: true, blendColor: true, debug: true }, ssr: { enable: false, pixelRatio: 1, fadeEdgeRatio: 0.2, rayMarchRatio: 0.5, fadeDistanceMin: 600, fadeDistanceMax: 2e3, roughnessThreshold: 0.5, powDotRN: 0.2, mixThreshold: 0.1, debug: true }, fxaa: { enable: false }, depthOfView: { enable: false, iterationCount: 3, pixelOffset: 1, near: 150, far: 300 } } }, shadow: { enable: true, type: "HARD", pointShadowBias: 2e-3, shadowSize: 1024, pointShadowSize: 1024, shadowSoft: 5e-3, shadowBias: 1e-4, needUpdate: true, autoUpdate: true, updateFrameRate: 2, csmMargin: 0.1, csmScatteringExp: 0.7, csmAreaScale: 0.4, debug: false }, gi: { enable: false, offsetX: 0, offsetY: 0, offsetZ: 0, probeSpace: 64, probeXCount: 4, probeYCount: 2, probeZCount: 4, probeSize: 32, probeSourceTextureSize: 2048, octRTMaxSize: 2048, octRTSideSize: 16, maxDistance: 64 * 1.73, normalBias: 0.25, depthSharpness: 1, hysteresis: 0.98, lerpHysteresis: 0.01, irradianceChebyshevBias: 0.01, rayNumber: 144, irradianceDistanceBias: 32, indirectIntensity: 1, ddgiGamma: 2.2, bounceIntensity: 0.025, probeRoughness: 1, realTimeGI: false, debug: false, autoRenderProbe: false }, sky: { type: "HDRSKY", sky: null, skyExposure: 1, defaultFar: 65536, defaultNear: 1 }, light: { maxLight: 4096 }, material: { materialChannelDebug: false, materialDebug: false }, loader: { numConcurrent: 20 } });
__publicField(p, "renderJobs");
var Ig = `
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`;
var Ba = `
struct BloomCfg{
  downSampleStep: f32,
  downSampleBlurSize: f32,
  downSampleBlurSigma: f32,
  upSampleBlurSize: f32,
  upSampleBlurSigma: f32,
  luminanceThreshole: f32,
  bloomIntensity: f32,
  slot: f32,
}
@group(0) @binding(0) var<uniform> bloomCfg: BloomCfg;
`;
var So = `
  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

`;
var _u = `
fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32
  {
      let PI = 3.14159265358;
      let E  = 2.71828182846;
      let sigma_2 = pow(sigma, 2);
  
      let a = -(x*x + y*y) / (2.0 * sigma_2);
      return pow(E, a) / (2.0 * PI * sigma_2);
  }
`;
var yo = function(s, e, t) {
  var r = `
  
  
  fn ${s}(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32>
  {
      var color = vec3<f32>(0.0);
      let r:i32 = n / 2;
      var weight:f32 = 0.0;
  
      for(var i:i32=-r; i<=r; i+=1)
      {
          for(var j=-r; j<=r; j+=1)
          {
              let w = GaussWeight2D(f32(i), f32(j), sigma);
              var coord:vec2<f32> = uv + vec2<f32>(f32(i), f32(j)) * stride;
              // color += tex2D(tex, coord).rgb * w;
              color += textureSampleLevel(${e}, ${t}, coord, 0.0).xyz * w;
              weight += w;
          }
      }
  
      color /= weight;
      return color;
  }`;
  return r;
};
var Cu = `
${Ba}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(inTex, fragCoord, 0);
  let lum = dot(vec3<f32>(0.2126, 0.7152, 0.0722), color.rgb);
  
  // if(lum<=bloomCfg.luminanceThreshole) {
  //   color = vec4<f32>(0,0,0,color.w);
  // }
  var ret = color.xyz;
  var brightness = lum;
  var contribution = max(0, brightness - bloomCfg.luminanceThreshole);
  contribution /=max(brightness, 0.00001);
  ret = ret * contribution;

  textureStore(outTex, fragCoord, vec4<f32>(ret, color.w));
}
`;
var Su = `
${Ba}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var inTexSampler: sampler;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${_u}
${yo("GaussNxN", "inTex", "inTexSampler")}
${So}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  let stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));   //  texel size of last level
  let rgb = GaussNxN(uv, i32(bloomCfg.downSampleBlurSize), stride, bloomCfg.downSampleBlurSigma);
  color = vec4<f32>(rgb, color.w);
  textureStore(outTex, fragCoord, color);
}
`;
var wo = `
${Ba}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _MainTexSampler: sampler;
@group(0) @binding(3) var _PrevMip : texture_2d<f32>;
@group(0) @binding(4) var _PrevMipSampler: sampler;
@group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${_u}
${yo("GaussNxN_0", "_MainTex", "_MainTexSampler")}
${yo("GaussNxN_1", "_PrevMip", "_PrevMipSampler")}
${So}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  
  // half stride
  let prev_stride = vec2<f32>(0.5) / vec2<f32>(f32(texSize.x), f32(texSize.y));
  let curr_stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));

  let rgb1 = GaussNxN_1(uv, i32(bloomCfg.upSampleBlurSize), prev_stride, bloomCfg.upSampleBlurSigma);
  let rgb2 = GaussNxN_0(uv, i32(bloomCfg.upSampleBlurSize), curr_stride, bloomCfg.upSampleBlurSigma);
  color = vec4<f32>(rgb1 + rgb2, color.w);
  textureStore(outTex, fragCoord, color);
}
`;
var yu = `
${Ba}
${So}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _BloomTex : texture_2d<f32>;
@group(0) @binding(3) var _BloomTexSampler :  sampler;
@group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
{
    let A = 2.51;
    let B = 0.03;
    let C = 2.43;
    let D = 0.59;
    let E = 0.14;

    var color2 = color * adapted_lum;
    color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
    return color2;
}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(_MainTex, fragCoord, 0);
  var uv = CalcUV_01(fragCoord, texSize);
  var bloom = textureSampleLevel(_BloomTex, _BloomTexSampler, uv, 0.0).xyz * bloomCfg.bloomIntensity;
  
  // tone map
  bloom = ACESToneMapping(bloom, 1.0);
  let g = 1.0 / 2.2;
  bloom = saturate(pow(bloom, vec3<f32>(g)));
 
  color = vec4<f32>(color.xyz + bloom.xyz, color.w);
  textureStore(outTex, fragCoord, color);
}
`;
var wu = `
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }
 
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;
  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = globalUniform.CameraPos.xyz ;
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`;
var Iu = `
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      // textureStore(outTex, fragCoord , vec4<f32>(vec3f(newFactor), oc.w));
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyzw;
                if(samplePosition.w>0.0){
                  let distanceVec2 = samplePosition.xyz - wPosition;
                  let distance = length(distanceVec2);
                  if(distance < gtaoData.maxDistance ){
                    let sampleDir = normalize(distanceVec2);
                    var factor = saturate( dot(sampleDir, originNormal));
                    factor *= 1.0 - distance / gtaoData.maxDistance;
                    weight += factor;
                  }
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `;
var bu = `

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${Ct.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `;
var Eu = `
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`;
var Bu = `
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;


   fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
   {
      let u = (f32(coord.x) + 0.5) / f32(texSize.x);
      let v = (f32(coord.y) + 0.5) / f32(texSize.y);
      return vec2<f32>(u, v);
   }

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      let uv01 = CalcUV_01(fragCoord, texSize);
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`;
var Tu = `
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`;
var Du = `
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`;
var Pu = `

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`;
var Mu = `
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`;
var bg = `
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`;
var Ru = `
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = CalcUV_01(fragCoord, colorTexSize);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`;
var Uu = `
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`;
var Lu = `
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`;
var Ou = `
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `;
var Fu = `
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`;
var Nu = `
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`;
var Eg = `
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`;
var zu = `
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`;
var ku = `
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,
        @location(auto) vIndex: f32,
        @location(auto) index2: f32,
        
    }

    struct VertexOutput {
        @location(auto) index: f32,
        @location(auto) varying_UV0: vec2<f32>,
        @location(auto) varying_UV1: vec2<f32>,
        @location(auto) varying_ViewPos: vec4<f32>,
        @location(auto) varying_Clip: vec4<f32>,
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_WNormal: vec3<f32>,
        @location(auto) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(auto) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,

        fillRotation:f32,
        empty0:f32,
        empty1:f32,
        empty2:f32,

        baseColor:vec4f,
        lineColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
        uvRect2:vec4f,
        uvSpeed:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`;
var Bg = `
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`;
var Tg = `
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`;
var Dg = `
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`;
var Gu = `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(auto) position: vec4<f32>,
        @location(auto) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }

    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn FragMain(  
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`;
var Pg = (s) => `
    #include "GlobalUniform"
    #include "MatrixShader"

    ${s}

    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:u32,
        skipFace3:u32,
        skipFace4:u32,
    }

    var<private> uv0 = vec2f(0.0, 0.0);
    var<private> uv1 = vec2f(1.0, 0.0);
    var<private> uv2 = vec2f(1.0, 1.0);
    var<private> uv3 = vec2f(0.0, 1.0);

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read_write> drawBuffer : DrawInfo ;
    
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        compute(workgroup_id,local_invocation_id);
    }

    //* gID mesh vertex group id
    //* v1 face vertex 1 position 
    //* v2 face vertex 2 position 
    //* v3 face vertex 3 position 
    //* u1 face uv 1  
    //* u2 face uv 2  
    //* u3 face uv 3  
    fn drawFace(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawLine(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(1.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);  
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawFace2(gID:u32, fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f, uv2:vec2f){
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(gID , fID * 3u + 0u, v1, n, u1, uv2);
        writeVertexBuffer(gID , fID * 3u + 1u, v2, n, u2, uv2);
        writeVertexBuffer(gID , fID * 3u + 2u, v3, n, u3, uv2);
    }

    fn drawRect(gID:u32,center:vec3f,width:f32,height:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,0.0,1.0);
        let p1 = mat * vec4f(maxX,maxY,0.0,1.0);
        let p2 = mat * vec4f(maxX,minY,0.0,1.0);
        let p3 = mat * vec4f(minX,minY,0.0,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
    }

    fn drawCube(gID:u32,center:vec3f,width:f32,height:f32,depth:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;
        let minZ = -depth * 0.5;
        let maxZ = depth * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,minZ,1.0);
        let p1 = mat * vec4f(maxX,maxY,minZ,1.0);
        let p2 = mat * vec4f(maxX,minY,minZ,1.0);
        let p3 = mat * vec4f(minX,minY,minZ,1.0);

        let p4 = mat * vec4f(maxX,maxY,maxZ,1.0);
        let p5 = mat * vec4f(minX,maxY,maxZ,1.0);
        let p6 = mat * vec4f(minX,minY,maxZ,1.0);
        let p7 = mat * vec4f(maxX,minY,maxZ,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p4.xyz,p7.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p7.xyz,p2.xyz,uv0,uv2,uv3);
        drawFace(gID,p4.xyz,p5.xyz,p6.xyz,uv0,uv1,uv2);
        drawFace(gID,p4.xyz,p6.xyz,p7.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p0.xyz,p5.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p5.xyz,p4.xyz,uv0,uv2,uv3);
        drawFace(gID,p0.xyz,p3.xyz,p6.xyz,uv1,uv2,uv3);
        drawFace(gID,p0.xyz,p6.xyz,p5.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p6.xyz,p3.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p7.xyz,p6.xyz,uv1,uv2,uv3);
    }

    //** compute face normal */
    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    //** write vertice data to geometry */
    fn writeVertexBuffer( gID:u32, vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(gID) ;
    }

    fn GetDistance( pos: vec3f,  plane : vec4f ) -> f32 {
        return plane.x * pos.x + plane.y * pos.y + plane.z * pos.z + plane.w;
     }
  
     fn IsOutofFrustum( pos:vec3f , radius: f32) -> bool {
        var c: i32 = 0;
        var d: f32 = 0.0;
        for(var i :i32 = 0; i < 6; i++){
           d = GetDistance(pos, globalUniform.frustumPlanes[i]);
           if (d <= -radius) {
              return false;
           }
           if (d > radius) {
              c++;
           }
       }
       return c > 0;
     }

    `;
var Mg = (s) => `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${s}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                genDir(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                genDir2(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn genDir(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = lc * dc + p1 ;
        // let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;
        // let end_r = lc * dc * 2.0 + p1;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    
    fn genDir2(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * neg;

        let right = cross( normalize(d1) , up );
        let first_l = lc * dc + p1;
        let first_r = right * shapeInfo.width + p1;

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l1 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace( fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `;
var Rg = (s) => `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${s}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }else if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else{
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                let l3 = segi + 2u;
                drawLineBody(l0,l1,l2,l3,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(l0:u32,l1:u32,l2:u32,l3:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 
        let p3 = shapeInfo.paths[l3].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;
        let right1 = cross(d2 , d1) ;

        let dir0 = normalize(d1 - d0) ;
        let dir1 = normalize(d2 - d1) ;

        // let lOr0 = dot(d0 , d3);
        // let lOr1 = dot(d1 , d4);

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(d1,dir1)) ;

        if(angle0<0.0){
            angle0 *= -1.0 ;
        }
        if(angle1<0.0){
            angle1 *= -1.0 ;
        }

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;

        let d1Right = cross(d1,up);
        let d2Right = cross(d2,up);

        newP0 = dir0 * lc0 + p1 ;
        newP1 = -dir0 * lc0 + p1 ;
        newP2 = dir1 * lc1 + p2 ;
        newP3 = -dir1 * lc1 + p2 ;

        newP4 = -d2Right * shapeInfo.width + p2 ;
        newP5 = -lc1 * dir1 + p2 ;

        let uScale = 1.0 ;
        let lVScale = length(newP2 - newP0);
        let rVScale = length(newP3 - newP1);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 4u + 0u,newP0,newP1,newP2,u0,u1,u3);
        // drawFace(l1 * 4u + 1u,newP0,newP2,newP3,u0,u1,u3);

        // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u1,u2,u3);
        // drawFace(l1 * 4u + 3u,newP3,newP4,newP5,u1,u2,u3);
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let nextRight = cross( normalize(d1) , up );
        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
        var next:vec3f;
        var outer:vec3f = p1 - lc * dc;
    
        if(lOr < 0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
            next = -nextRight * shapeInfo.width + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
            next = nextRight * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 4u + 0u,end_l,end_r,next,u0,u1,u3);

        if(lOr < 0.0){
            drawFace(l0 * 4u + 1u,outer,end_l,next,u0,u1,u3);
        }else{
            drawFace(l0 * 4u + 1u,next,end_r,outer,u0,u1,u3);
        }

        drawFace(l0 * 4u + 2u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 4u + 3u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        // drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 4u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 4u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `;
var Ug = (s) => `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${s}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
    
        if(lOr<0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 3u + 0u,end_l,end_r,p1,u0,u1,u3);
        drawFace(l0 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);

        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `;
var Qu = () => `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        lineCap:f32,
        
        pathCount:f32,
        uScale:f32,
        vScale:f32,
        lineJoin:f32,

        startPath:f32,
        endPath:f32,
        uSpeed:f32,
        vSpeed:f32,
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:atomic<u32>,
        skipFace3:atomic<u32>,
        skipFace4:atomic<u32>,
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    @group(0) @binding(3) var<storage, read> pathBuffer : array<vec4f>;
    @group(0) @binding(4) var<storage, read_write> drawBuffer : DrawInfo ;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> pathOffset:u32 ;
    var<private> faceOffset:u32 ;
    // var<private> faceStrip:u32 = 1u ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        shape = shapeBuffer[workgroup_id.x];
        pathOffset = u32(shape.startPath) ;
        segCount = u32(shape.pathCount - 1.0);
        segIndex = workgroup_id.y * 256u + local_invocation_id.x ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            switch (u32(shape.shapeType)) {
                case 0u:{
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                case 3u:{
                    drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    break;
                }
                default:
                {
                    break;
                }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount - 1u)){
                drawLineEnd(segi,shapeInfo,up);
            }else if(segi == 0u){
                drawLineStart(segi,shapeInfo,up);
            }else{
                drawLineBody(segi,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = segi + 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p1,d1)) ;
        let len1 = (dot(newP1 - p1,d1)) ;
        let len2 = (dot(newP2 - p1,d1)) ;
        let len3 = (dot(newP3 - p1,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawLineStart(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = 0u;
        let l1 = 0u ;
        let l2 = 1u;
        let l3 = 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p0 = normalize(p1 - p2) * 10.0 + p1 ; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);
        
        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
        }
    }

    fn drawLineEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = 0u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = normalize(p2 - p1) * 10.0 + p2 ; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1 < 0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            // newP2 = dir1 * lc1 + p2 ;
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    // drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = pathBuffer[firstSegi+pathOffset].xyz; 
        let p1 = pathBuffer[endSegi+pathOffset].xyz; 
        // let p2 = pathBuffer[nextSegi+pathOffset].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let u0 = vec2f(0.0,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
        let u1 = vec2f(uScale,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u2 = vec2f(uScale,vScale) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u3 = vec2f(0.0,vScale) * uvScale ;//+ vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;

        drawFace(first_l,first_r,end_l,u0,u1,u3);
        drawFace(first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        var fID = atomicAdd(&drawBuffer.skipFace,1u); 
        writeVertexBuffer(fID * 3u + 0u, v1,n,u1,uv2);
        writeVertexBuffer(fID * 3u + 1u,v2,n,u2,uv2);
        writeVertexBuffer(fID * 3u + 2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    `;
var Vu = (s) => `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        // px:f32,
        // py:f32,
        // pz:f32,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct TrailInfo{
        index : f32 ,
        segment : f32 ,
        visible : f32 ,
        width: f32,

        uv: vec4f,

        uvSpeed: vec2f,
        smoothLine: f32,
        faceMode: f32,
        up: vec4f,
        ids:array<f32,${s}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read> trailBuffer : array<TrailInfo>;
    @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;

    var<private> time:f32;
    var<private> viewDir:vec3f;

    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        let rID = workgroup_id.x ;
        let trailInfo = trailBuffer[rID];
        let vLen = u32(trailInfo.segment+1.0) ;
        let vID = global_invocation_id.x ;

        // if(vID < vLen ){
            time = globalUniform.time * 0.001;
            var right:vec3f ;
            
            switch (u32(trailInfo.faceMode)) {
                case 0u:{
                    right = getRightByMode(vID,vLen,viewDir,trailInfo) ;
                    break;
                }
                case 1u:{
                    right = vec3f(0.0,0.0,1.0) ;
                    break;
                }
                case 2u:{
                    right = getRightByMode(vID,vLen,trailInfo.up.xyz,trailInfo) ;
                    break;
                }
                default:{
                    break;
                }
            }
            writeTOBuffer(rID,vID,vLen,right,trailInfo);
        // }
    }

 

    fn writeTOBuffer(rID:u32, vID:u32 , vLen:u32, right:vec3f , trailInfo:TrailInfo ){
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;

        let worldPos = models[i32(trailInfo.ids[vID])][3].xyz ;
        let leftPos = worldPos - right.xyz * trailInfo.width ;
        let rightPos = worldPos + right.xyz * trailInfo.width ;

        vertexBuffer[li].position = leftPos ;
        vertexBuffer[ri].position = rightPos ;

        let uvS = time * trailInfo.uvSpeed ;

        vertexBuffer[li].uv_x = (trailInfo.uv.x) + uvS.x ;
        vertexBuffer[ri].uv_x = (trailInfo.uv.z + trailInfo.uv.x) + uvS.x ;

        // var ld = 0.0 ;
        // var rd = 0.0 ;
        // if(vID>0u){
        //     let vid0 = getVID(vID,vLen,rID);
        //     let vid1 = getVID(vID-1u,vLen,rID);
        
        //     ld = distance( vertexBuffer[li].position , vertexBuffer[vid1.x].position ) ;
        //     rd = distance( vertexBuffer[ri].position , vertexBuffer[vid1.y].position ) ;

        //     vertexBuffer[li].uv_y = vertexBuffer[vid1.x].uv_y + 1.0 / ld * 100.0 ;//+ uvS.y ;
        //     vertexBuffer[ri].uv_y = vertexBuffer[vid1.y].uv_y + 1.0 / rd * 100.0 ;//+ uvS.y ;
        // }else{
            let v = (1.0 - f32(vID) / trailInfo.segment) * trailInfo.uv.w + trailInfo.uv.y;
            vertexBuffer[li].uv_y = v + uvS.y ;
            vertexBuffer[ri].uv_y = v + uvS.y ;
        // }
    }

    fn getRight(p0:vec3f,p1:vec3f,p2:vec3f,up:vec3f) -> vec3f {
        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        // var a = dot(d0,d1) ;
        // var ep = 0.0 ;
        // if(a<0.0){
        //     a = -a ;
        //     ep = 1.0/sin(a*0.25) ;
        // }else if(a == 0.0){
        //     ep = 1.414 ;
        // }else{
        //     ep = 1.0 ;
        // }
        let forward = normalize((d0 + d1)+ vec3f(0.000001,0.000001,0.000001)) ;
        return normalize(cross(forward,up)) ;//* ep ;
    }

    fn getVID(vID:u32,vLen:u32,rID:u32) -> vec2<u32> {
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;
        return vec2<u32>(li,ri);
    }

    fn getRightByMode( vID:u32 , vLen:u32, up:vec3f, trailInfo:TrailInfo ) -> vec3f{
        var right:vec3f;
        if(vID==0u){
            // first
            let sp0 = models[i32(trailInfo.ids[ 0 ])][3].xyz ;
            let sp1 = models[i32(trailInfo.ids[ 1 ])][3].xyz ;
            let firstFront = normalize(sp1 - sp0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - sp0) ;
            right = normalize(cross(firstFront,viewDir));
        }else if( vID < (vLen-1) ){
            // body
            let bp0 = models[i32(trailInfo.ids[vID-1])][3].xyz ;
            let bp1 = models[i32(trailInfo.ids[vID])][3].xyz ;
            let bp2 = models[i32(trailInfo.ids[vID+1])][3].xyz ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - bp1) ;
            right = getRight(bp0,bp1,bp2,viewDir) ;
        }else{
            // last
            let ep0 = models[i32(trailInfo.ids[u32(trailInfo.segment)-1u])][3].xyz ;
            let ep1 = models[i32(trailInfo.ids[u32(trailInfo.segment)])][3].xyz ;
            let endFront = normalize(ep1 - ep0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - ep1) ;
            right = normalize(cross(endFront,viewDir));
        }
        return normalize(right) ; 
    }
    `;
var Hu = `
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = 1.0 ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            useShadow();

            BxDFShading();
        }
    `;
var Yu = `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `;
var Xu = `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`;
var Wu = `
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        useShadow();

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`;
var ju = `
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`;
var Lg = `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`;
var qu = `
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        useShadow();

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity / LUMEN)  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`;
var Og = `
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `;
var Fg = `
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `;
var Ku = `
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy;
        //The fragUV1.x is 1.0 when the vertex belongs to line.
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            uv = graphicNode.uvRect2.zw * uv.xy + graphicNode.uvRect2.xy;
            uv += graphicNode.uvSpeed.zw * globalUniform.time;
        }else{
            uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy;
            uv += graphicNode.uvSpeed.xy * globalUniform.time;
            let rad = graphicNode.fillRotation;
            if(rad != 0.0){
                let zrot = mat3x3<f32>(
                    cos(rad),-sin(rad),0.0,
                    sin(rad), cos(rad),0.0,
                    0.0,0.0,1.0
                );
                uv = (zrot * vec3f(uv, 0.0)).xy;
            }
        }
        var graphicTextureID = graphicNode.texIndex;
        var graphicNodeColor = graphicNode.baseColor;
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            graphicTextureID = graphicNode.tex2Index;
            graphicNodeColor = graphicNode.lineColor;
        }
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicTextureID)) ) * materialUniform.baseColor * graphicNodeColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < 0.5){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`;
var Ng = `
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`;
var Ju = `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`;
var Zu = `
var<private> PI: f32 = 3.14159265359;

struct FragmentOutput {
    @location(auto) o_Target: vec4<f32>
};

${ua}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`;
var $u = class {
};
__publicField($u, "cs", `
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);
var ec = class {
  constructor() {
    __publicField(this, "sunRadius", 500);
    __publicField(this, "sunRadiance", 11);
    __publicField(this, "mieG", 0.76);
    __publicField(this, "mieHeight", 1200);
    __publicField(this, "eyePos", 1500);
    __publicField(this, "sunX", 0.71);
    __publicField(this, "sunY", 0.56);
    __publicField(this, "sunBrightness", 1);
    __publicField(this, "displaySun", true);
    __publicField(this, "defaultTextureCubeSize", 512);
    __publicField(this, "defaultTexture2DSize", 1024);
    __publicField(this, "skyColor", new M(1, 1, 1, 1));
  }
};
var tc = class extends Ea {
  constructor(e) {
    super();
    __publicField(this, "_internalTexture");
    __publicField(this, "_cubeSize");
    __publicField(this, "setting");
    return this.setting = e, this._cubeSize = e.defaultTextureCubeSize, this._internalTexture = new zg(e.defaultTexture2DSize, e.defaultTexture2DSize * 0.5), this._internalTexture.update(this.setting), this.createFromTexture(this._cubeSize, this._internalTexture), this;
  }
  get texture2D() {
    return this._internalTexture;
  }
  apply() {
    return this._internalTexture.update(this.setting), this._faceData.uploadErpTexture(this._internalTexture), this;
  }
};
var zg = class extends de {
  constructor(e, t) {
    super(e, t, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
    __publicField(this, "_computeShader");
    __publicField(this, "_uniformBuffer");
    this.initCompute(e, t);
  }
  initCompute(e, t) {
    this._uniformBuffer = new ft(16 * 4), this._uniformBuffer.apply(), this._computeShader = new ae($u.cs), this._computeShader.setUniformBuffer("uniformBuffer", this._uniformBuffer), this._computeShader.setStorageTexture("outTexture", this), this._computeShader.workerSizeX = e / 8, this._computeShader.workerSizeY = t / 8;
  }
  update(e) {
    this._uniformBuffer.setFloat("width", this.width), this._uniformBuffer.setFloat("height", this.height), this._uniformBuffer.setFloat("sunU", e.sunX), this._uniformBuffer.setFloat("sunV", e.sunY), this._uniformBuffer.setFloat("eyePos", e.eyePos), this._uniformBuffer.setFloat("sunRadius", e.sunRadius), this._uniformBuffer.setFloat("sunRadiance", e.sunRadiance), this._uniformBuffer.setFloat("mieG", e.mieG), this._uniformBuffer.setFloat("mieHeight", e.mieHeight), this._uniformBuffer.setFloat("sunBrightness", e.sunBrightness), this._uniformBuffer.setFloat("displaySun", e.displaySun ? 1 : 0), this._uniformBuffer.setColor("skyColor", e.skyColor), this._uniformBuffer.apply();
    let t = y.beginCommandEncoder();
    return y.computeCommand(t, [this._computeShader]), y.endCommandEncoder(t), this;
  }
};
var kg = Object.defineProperty;
var Gg = Object.getOwnPropertyDescriptor;
var Qg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Gg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && kg(e, t, i), i;
};
var Ta = class extends Qe {
  constructor() {
    super();
    let s = new ve("sky_vs_frag_wgsl", "sky_fs_frag_wgsl");
    this.addRenderPass(s), s.setUniformVector3("eyesPos", new d()), s.setUniformFloat("exposure", 1), s.setUniformFloat("roughness", 0);
    let e = s.shaderState;
    e.frontFace = "cw", e.cullMode = nt.back, e.depthWriteEnabled = false, e.depthCompare = kt.less;
  }
};
Ta = Qg([Kt], Ta);
var rc = class extends je {
  constructor() {
    super(), this.shader = new Ta(), this.shader.setUniformVector3("eyesPos", new d()), this.shader.setUniformFloat("exposure", 1), this.shader.setUniformFloat("roughness", 0);
  }
  set baseMap(e) {
    this.setTexture("baseMap", e);
    const t = "IS_HDR_SKY";
    this._shader.getDefaultShaders()[0].defineValue[t] != (e == null ? void 0 : e.isHDRTexture) && this._shader.setDefine(t, !!(e == null ? void 0 : e.isHDRTexture));
  }
  get baseMap() {
    return this._shader.getDefaultColorShader().getTexture("baseMap");
  }
  set envMap(e) {
  }
  set shadowMap(e) {
  }
  get exposure() {
    return p.setting.sky.skyExposure;
  }
  set exposure(e) {
    p.setting.sky.skyExposure = e;
  }
  get roughness() {
    return this._shader.getDefaultColorShader().uniforms.roughness.value;
  }
  set roughness(e) {
    let t = this._shader.getDefaultColorShader();
    "roughness" in t.uniforms && (t.uniforms.roughness.value = e);
  }
};
var Mi = class extends xe {
  constructor(e, t, r, i, a, o, n) {
    super();
    __publicField(this, "shape_vertices", []);
    __publicField(this, "shape_indices", []);
    __publicField(this, "radius");
    __publicField(this, "widthSegments");
    __publicField(this, "heightSegments");
    __publicField(this, "phiStart");
    __publicField(this, "phiLength");
    __publicField(this, "thetaStart");
    __publicField(this, "thetaLength");
    this.radius = e, this.widthSegments = t, this.heightSegments = r, this.phiStart = i, this.phiLength = a, this.thetaStart = o, this.thetaLength = n, this.buildGeometry();
  }
  buildGeometry() {
    var e, t, r = 0;
    let i = this.heightSegments, a = this.widthSegments, o = this.radius;
    var n = (i + 1) * (a + 1);
    let l = new Float32Array(n * 3), h = new Float32Array(n * 3), u = new Float32Array(n * 2), c = new Uint16Array(a * i * 2 * 3), f = 0, g = 0, m = 0;
    for (t = 0; t <= i; ++t) {
      var A = Math.PI * t / i, _ = -o * Math.cos(A), x = o * Math.sin(A);
      for (e = 0; e <= a; ++e) {
        var C = 2 * Math.PI * e / a, S = x * Math.cos(C), I = x * Math.sin(C), T = 1 / Math.sqrt(S * S + I * I + _ * _);
        if (l[f++] = S, l[f++] = I, l[f++] = _, h[g++] = S * T, h[g++] = I * T, h[g++] = _ * T, u[m++] = e / a, u[m++] = 1 - t / i, e > 0 && t > 0) {
          var b = (a + 1) * t + e, B = (a + 1) * t + e - 1, R = (a + 1) * (t - 1) + e - 1, E = (a + 1) * (t - 1) + e;
          t == i ? (c[r++] = b, c[r++] = R, c[r++] = E) : t == 1 ? (c[r++] = b, c[r++] = B, c[r++] = R) : (c[r++] = b, c[r++] = B, c[r++] = R, c[r++] = b, c[r++] = R, c[r++] = E);
        }
      }
    }
    this.setIndices(c), this.setAttribute(D.position, l), this.setAttribute(D.normal, h), this.setAttribute(D.uv, u), this.setAttribute(D.TEXCOORD_1, u), this.addSubGeometry({ indexStart: 0, indexCount: c.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 }), this.bounds = new ge(d.ZERO, new d(this.radius * 2, this.radius * 2, this.radius * 2));
  }
};
var Da = class extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "skyMaterial");
  }
  init() {
    super.init(), this.castShadow = false, this.castGI = true, this.addRendererMask(De.Sky), this.alwaysRender = true, this.object3D.bound = new ge(d.ZERO.clone(), d.MAX), this.geometry = new Mi(p.setting.sky.defaultFar, 20, 20), this.skyMaterial || (this.skyMaterial = new rc());
  }
  onEnable() {
    this._readyPipeline ? (this.castNeedPass(), !this._inRenderer && this.transform.scene3D && (z.instance.sky = this, this._inRenderer = true)) : this.initPipeline();
  }
  onDisable() {
    this._inRenderer && this.transform.scene3D && (this._inRenderer = false, z.instance.sky = null), super.onDisable();
  }
  renderPass2(e, t, r, i, a, o = false) {
    super.renderPass2(e, t, r, i, a, o);
  }
  set map(e) {
    this.skyMaterial.baseMap = e, this.skyMaterial.name == null && (this.skyMaterial.name = "skyMaterial"), this.material = this.skyMaterial;
  }
  get map() {
    return this.skyMaterial.baseMap;
  }
  get exposure() {
    return this.skyMaterial.exposure;
  }
  set exposure(e) {
    this.skyMaterial && (this.skyMaterial.exposure = e);
  }
  get roughness() {
    return this.skyMaterial.roughness;
  }
  set roughness(e) {
    this.skyMaterial && (this.skyMaterial.roughness = e);
  }
};
var Vg = class {
  constructor() {
    __publicField(this, "rotateX");
    __publicField(this, "rotateY");
    __publicField(this, "sunX");
    __publicField(this, "sunY");
    this.reset();
  }
  reset() {
    return this.rotateX = this.rotateY = this.sunX = this.sunY = Number.MAX_VALUE, this;
  }
  isRotateChange(e, t) {
    return Math.abs(this.rotateX - e) >= 1e-3 || Math.abs(this.rotateY - t) >= 1e-3;
  }
  isSkyChange(e, t) {
    return Math.abs(this.sunX - e) >= 1e-3 || Math.abs(this.sunY - t) >= 1e-3;
  }
  save(e, t, r, i) {
    return this.sunX = e, this.sunY = t, this.rotateX = r, this.rotateY = i, this;
  }
};
var Hg = class extends Da {
  constructor() {
    super(...arguments);
    __publicField(this, "_atmosphericScatteringSky");
    __publicField(this, "_onChange", true);
    __publicField(this, "_relatedTransform");
    __publicField(this, "_historyData");
  }
  get sunX() {
    return this._atmosphericScatteringSky.setting.sunX;
  }
  set sunX(e) {
    this._atmosphericScatteringSky.setting.sunX != e && (this._atmosphericScatteringSky.setting.sunX = e, this._onChange = true);
  }
  get sunY() {
    return this._atmosphericScatteringSky.setting.sunY;
  }
  set sunY(e) {
    this._atmosphericScatteringSky.setting.sunY != e && (this._atmosphericScatteringSky.setting.sunY = e, this._onChange = true);
  }
  get eyePos() {
    return this._atmosphericScatteringSky.setting.eyePos;
  }
  set eyePos(e) {
    this._atmosphericScatteringSky.setting.eyePos != e && (this._atmosphericScatteringSky.setting.eyePos = e, this._onChange = true);
  }
  get sunRadius() {
    return this._atmosphericScatteringSky.setting.sunRadius;
  }
  set sunRadius(e) {
    this._atmosphericScatteringSky.setting.sunRadius != e && (this._atmosphericScatteringSky.setting.sunRadius = e, this._onChange = true);
  }
  get sunRadiance() {
    return this._atmosphericScatteringSky.setting.sunRadiance;
  }
  set sunRadiance(e) {
    this._atmosphericScatteringSky.setting.sunRadiance != e && (this._atmosphericScatteringSky.setting.sunRadiance = e, this._onChange = true);
  }
  get sunBrightness() {
    return this._atmosphericScatteringSky.setting.sunBrightness;
  }
  set sunBrightness(e) {
    this._atmosphericScatteringSky.setting.sunBrightness != e && (this._atmosphericScatteringSky.setting.sunBrightness = e, this._onChange = true);
  }
  get displaySun() {
    return this._atmosphericScatteringSky.setting.displaySun;
  }
  set displaySun(e) {
    this._atmosphericScatteringSky.setting.displaySun != e && (this._atmosphericScatteringSky.setting.displaySun = e, this._onChange = true);
  }
  init() {
    super.init(), this._historyData = new Vg(), this._atmosphericScatteringSky = new tc(new ec());
    let e = this.transform.view3D, t = this.transform.scene3D;
    this.map = this._atmosphericScatteringSky, t.envMap = this._atmosphericScatteringSky, this.onUpdate(e);
  }
  start(e) {
    let t = this.transform.scene3D;
    this.map = this._atmosphericScatteringSky, t.envMap = this._atmosphericScatteringSky, super.start();
  }
  get relativeTransform() {
    return this._relatedTransform;
  }
  set relativeTransform(e) {
    this._relatedTransform = e, this._historyData.reset();
  }
  onUpdate(e) {
    this._relatedTransform && (this._relatedTransform.rotationZ = 0, this._historyData.isRotateChange(this._relatedTransform.rotationX, this._relatedTransform.rotationY) ? (this.sunX = (this._relatedTransform.rotationY + 90) / 360, this.sunY = this._relatedTransform.rotationX / 180 + 0.5) : this._historyData.isSkyChange(this.sunX, this.sunY) && (this._relatedTransform.rotationY = this.sunX * 360 - 90, this._relatedTransform.rotationX = (this.sunY - 0.5) * 180), this._historyData.save(this.sunX, this.sunY, this._relatedTransform.rotationX, this._relatedTransform.rotationY)), this._onChange && (this._onChange = false, this._atmosphericScatteringSky.apply());
  }
  destroy(e) {
    super.destroy(e), this._atmosphericScatteringSky.destroy(), this._atmosphericScatteringSky = null, this._onChange = null;
  }
};
var Tr = class {
};
__publicField(Tr, "panelRatio", 1);
__publicField(Tr, "quadMaxCountForWorld", 256);
__publicField(Tr, "quadMaxCountForView", 2048);
__publicField(Tr, "SortOrderStartWorld", 7e3);
__publicField(Tr, "SortOrderStartView", 8e3);
__publicField(Tr, "SortOrderCanvasSpan", 1e4);
var It = ((s) => (s[s.View = 0] = "View", s[s.World = 2] = "World", s))(It || {});
var ti = ((s) => (s[s.Simple = 0] = "Simple", s[s.Sliced = 1] = "Sliced", s[s.Tiled = 2] = "Tiled", s[s.Filled = 3] = "Filled", s))(ti || {});
var Ar = ((s) => (s[s.None = 0] = "None", s[s.BillboardY = 9] = "BillboardY", s[s.BillboardXYZ = 10] = "BillboardXYZ", s))(Ar || {});
var Ji = class _Ji extends _e {
  constructor() {
    super();
    __publicField(this, "type");
    __publicField(this, "camera");
    __publicField(this, "_cameraPosition");
    this._cameraPosition = new d();
  }
  onUpdate() {
    this.enable && this.transform.view3D.camera && this.updateBillboardMatrix();
  }
  updateBillboardMatrix() {
    let e = this.transform.view3D.camera;
    this._cameraPosition.copyFrom(e.transform.back), this.type == Ar.BillboardXYZ || this.type == Ar.BillboardY && (this._cameraPosition.y = 0), this._cameraPosition.normalize(), this._cameraPosition.add(this.object3D.localPosition, this._cameraPosition), this.transform.lookAt(this.object3D.localPosition, this._cameraPosition, e.transform.up);
  }
  cloneTo(e) {
    let t = e.addComponent(_Ji);
    t.type = this.type;
  }
};
var ri = ((s) => (s[s.None = 0] = "None", s[s.Box = 1] = "Box", s[s.Capsule = 2] = "Capsule", s[s.Sphere = 3] = "Sphere", s[s.Mesh = 4] = "Mesh", s))(ri || {});
var _Le = class _Le {
  constructor() {
    __publicField(this, "_center");
    __publicField(this, "_size");
    __publicField(this, "_halfSize");
    __publicField(this, "_shapeType", 0);
    _Le.v3_help_0 || (_Le.v3_help_0 = new d()), _Le.helpMatrix || (_Le.helpMatrix = new P()), _Le.helpRay || (_Le.helpRay = new bt()), this._center = new d(), this._size = new d(), this._halfSize = new d();
  }
  get shapeType() {
    return this._shapeType;
  }
  setFromCenterAndSize(e, t) {
    return e && this._center.copy(e), t && this._size.copy(t), this;
  }
  get center() {
    return this._center;
  }
  set center(e) {
    this._center.copy(e);
  }
  get size() {
    return this._size;
  }
  set size(e) {
    this._size.copy(e), this._halfSize.copy(e).multiplyScalar(0.5);
  }
  get halfSize() {
    return this._halfSize;
  }
  rayPick(e, t) {
    return null;
  }
};
__publicField(_Le, "v3_help_0");
__publicField(_Le, "helpMatrix");
__publicField(_Le, "helpRay");
var Le = _Le;
var ic = class extends Le {
  constructor() {
    super();
    __publicField(this, "_pickRet");
    __publicField(this, "box");
    this._shapeType = ri.Box, this.box = new ge(new d(), new d());
  }
  rayPick(e, t) {
    this.box.setFromCenterAndSize(this.center, this.size);
    let i = Le.helpMatrix;
    i.copyFrom(t).invert();
    let a = Le.helpRay.copy(e);
    a.applyMatrix(i);
    let o = a.intersectBox(this.box, Le.v3_help_0);
    return o ? (this._pickRet || (this._pickRet = { intersectPoint: new d(), distance: 0 }), this._pickRet.intersectPoint = o, this._pickRet.distance = d.distance(a.origin, Le.v3_help_0), this._pickRet) : null;
  }
};
var Yg = class extends _e {
  constructor() {
    super();
    __publicField(this, "_shape");
    this._shape = new ic();
  }
  start() {
    p.setting.pick.mode == "pixel" && this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index, this);
  }
  onEnable(e) {
    ue.bindEnablePick(e, this, null);
  }
  onDisable(e) {
    ue.unBindEnablePick(e, this);
  }
  get shape() {
    return this._shape;
  }
  set shape(e) {
    this._shape = e;
  }
  rayPick(e) {
    return this._enable ? this._shape.rayPick(e, this.transform.worldMatrix) : null;
  }
  beforeDestroy(e) {
    p.setting.pick.mode == "pixel" && this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index), super.beforeDestroy(e);
  }
};
var Xg = Object.defineProperty;
var Wg = Object.getOwnPropertyDescriptor;
var jg = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Wg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Xg(e, t, i), i;
};
var vr = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "jointMatrixIndexTableBuffer");
    __publicField(this, "playBlendShapeLoop", false);
    __publicField(this, "inverseBindMatrices");
    __publicField(this, "_avatar");
    __publicField(this, "_rendererList");
    __publicField(this, "propertyCache");
    __publicField(this, "_clips");
    __publicField(this, "_clipsMap");
    __publicField(this, "_currentSkeletonClip");
    __publicField(this, "_currentBlendAnimClip");
    __publicField(this, "_skeletonTime", 0);
    __publicField(this, "_blendShapeTime", 0);
    __publicField(this, "_skeletonSpeed", 1);
    __publicField(this, "_blendShapeSpeed", 1);
    __publicField(this, "_skeletonStart", true);
    __publicField(this, "_blendShapeStart", true);
    __publicField(this, "root");
    __publicField(this, "_avatarName");
    __publicField(this, "skeltonPoseObject3D", {});
    __publicField(this, "skeltonTPoseObject3D", {});
  }
  init(s) {
    this.propertyCache = /* @__PURE__ */ new Map(), this._clipsMap = /* @__PURE__ */ new Map(), this._clips = [];
  }
  start() {
    this._rendererList = this.object3D.getComponentsInChild(Dr);
  }
  debug() {
  }
  playAnim(s, e = 0, t = 1) {
    this._clipsMap.has(s) ? (this._currentSkeletonClip = this._clipsMap.get(s), this._skeletonTime = e, this._skeletonSpeed = t, this._skeletonStart = true) : console.warn(`not has anim ${s}`);
  }
  playBlendShape(s, e = 0, t = 1) {
    this._clipsMap.has(s) ? (this._currentBlendAnimClip = this._clipsMap.get(s), this._blendShapeTime = e, this._blendShapeSpeed = t, this._blendShapeStart = true) : console.warn(`not has blendShape ${s}`);
  }
  set avatar(s) {
    this._avatarName = s, this.inverseBindMatrices = [], this._avatar = p.res.getObj(s);
    let e = this.buildSkeletonPose();
    const t = new Float32Array(e);
    this.jointMatrixIndexTableBuffer = new $(this._avatar.count, 0, t);
  }
  getJointIndexTable(s) {
    let e = new Array();
    for (let t = 0; t < s.length; t++) {
      let r = this._avatar.boneMap.get(s[t]);
      e[t] = r ? r.boneID : -1;
    }
    return e;
  }
  buildSkeletonPose() {
    let s = [];
    for (const e of this._avatar.boneData) {
      let t = new Y();
      P.getEuler(d.HELP_6, e.q, true, "ZYX"), t.localPosition = e.t.clone(), t.localRotation = d.HELP_6.clone(), t.localScale = d.ONE, e.s.clone(), this.skeltonPoseObject3D[e.boneName] = t, this.skeltonTPoseObject3D[e.bonePath] = t.clone(), e.parentBoneName && e.parentBoneName != "" ? this.skeltonPoseObject3D[e.parentBoneName].addChild(t) : (this.object3D.transform.scene3D && this.object3D.transform.scene3D.addChild(t), this.root = t), s.push(t.transform.worldMatrix.index);
      let r = new P();
      r.copyFrom(t.transform.worldMatrix), r.invert(), this.inverseBindMatrices.push(r.rawData);
    }
    return s;
  }
  set clips(s) {
    this._clips = s;
    for (const e of s)
      this._clipsMap.set(e.clipName, e);
  }
  get clips() {
    return this._clips;
  }
  cloneTo(s) {
    let e = s.addComponent(vr);
    e.avatar = this._avatarName, e.clips = this._clips;
  }
  updateTime() {
    this._skeletonStart && (this._skeletonTime += ce.delta * 1e-3 * this._skeletonSpeed, this._currentSkeletonClip && this._currentSkeletonClip.loopTime && (this._skeletonTime = this._skeletonTime % this._currentSkeletonClip.stopTime)), this._blendShapeStart && (this._blendShapeTime += ce.delta * 1e-3 * this._blendShapeSpeed, this._currentBlendAnimClip && (this._currentBlendAnimClip.loopTime && this.playBlendShapeLoop ? this._blendShapeTime = this._blendShapeTime % this._currentBlendAnimClip.stopTime : this._blendShapeTime = Math.min(this._blendShapeTime, this._currentBlendAnimClip.stopTime) - 1e-4));
  }
  onUpdate(s) {
    this.transform.worldMatrix, this.updateTime(), this.updateSkeletonAnim(), this.updateMorphAnim();
  }
  updateSkeletonAnim() {
    if (this._currentSkeletonClip) {
      let s = this._avatar.boneData, e = 0, t = s.length;
      for (e = 0; e < t; e++) {
        const r = s[e];
        let i = this.skeltonPoseObject3D[r.boneName];
        if (this._currentSkeletonClip.useSkeletonPos) {
          let o = this.getPosition(r.bonePath, this._skeletonTime);
          i.transform.localPosition = o;
        }
        let a = this.getRotation(r.bonePath, this._skeletonTime);
        if (i.transform.localRotation = a, this._currentSkeletonClip.useSkeletonScale) {
          let o = this.getScale(r.bonePath, this._skeletonTime);
          i.transform.localScale = o;
        }
      }
    }
  }
  updateMorphAnim() {
    if (this._currentBlendAnimClip && this._currentBlendAnimClip.floatCurves && this._currentBlendAnimClip.floatCurves.size > 0 && this._rendererList)
      for (const s of this._currentBlendAnimClip.floatCurves) {
        let e = s[0], r = s[1].propertys, a = this._currentBlendAnimClip.floatCurves.get(e).getValue(this._blendShapeTime) / 100;
        for (const o of this._rendererList)
          if (o.blendShape) {
            let n = this.propertyCache.get(o);
            if (n && e in n)
              n[e](a);
            else {
              n = o;
              for (const l of r) {
                if (!n[l])
                  break;
                n = n[l];
              }
              if (!n || n == o)
                break;
              this.propertyCache.get(o) || this.propertyCache.set(o, {}), this.propertyCache.get(o)[e] = n, n(a);
            }
          }
      }
  }
  updateBlendShape(s, e, t) {
    for (const r of this._rendererList)
      if (r.blendShape) {
        let i = this.propertyCache.get(r);
        if (i && e in i)
          i[e](t);
        else {
          i = r;
          for (const a of s) {
            if (!i[a])
              break;
            i = i[a];
          }
          if (!i || i == r)
            break;
          this.propertyCache.get(r) || this.propertyCache.set(r, {}), this.propertyCache.get(r)[e] = i, i(t);
        }
      }
  }
  getPosition(s, e) {
    return this._currentSkeletonClip.positionCurves.has(s) ? this._currentSkeletonClip.positionCurves.get(s).getValue(e) : this.skeltonTPoseObject3D[s].localPosition;
  }
  getRotation(s, e) {
    if (this._currentSkeletonClip.rotationCurves.has(s)) {
      let t = this._currentSkeletonClip.rotationCurves.get(s).getValue(e);
      return H.HELP_2.set(t.x, t.y, t.z, t.w), P.getEuler(d.HELP_6, H.HELP_2, true, "ZYX"), d.HELP_6;
    }
    return this.skeltonTPoseObject3D[s].localRotation;
  }
  getScale(s, e) {
    return this._currentSkeletonClip.scaleCurves.has(s) ? this._currentSkeletonClip.scaleCurves.get(s).getValue(e) : this.skeltonTPoseObject3D[s].localScale;
  }
  getFloat(s, e) {
    return this._currentSkeletonClip.floatCurves.get(s).getValue(e);
  }
};
vr = jg([_t(vr, "AnimatorComponent")], vr);
var Io = class {
  constructor() {
    __publicField(this, "index");
    __publicField(this, "time");
    __publicField(this, "timeEnd");
    __publicField(this, "coeff", []);
  }
};
var xr = ((s) => (s[s.PingPong = 0] = "PingPong", s[s.Repeat = 1] = "Repeat", s[s.Clamp = 2] = "Clamp", s))(xr || {});
var Pa = class {
  constructor(e = 0, t = 0) {
    __publicField(this, "serializedVersion", "2");
    __publicField(this, "time");
    __publicField(this, "value");
    __publicField(this, "inSlope", 0);
    __publicField(this, "outSlope", 0);
    __publicField(this, "tangentMode", 0);
    __publicField(this, "weightedMode", 0);
    __publicField(this, "inWeight");
    __publicField(this, "outWeight");
    this.time = e, this.value = t;
  }
  unSerialized(e) {
    this.serializedVersion = e.serializedVersion, this.time = e.time, this.value = e.value, this.tangentMode = e.tangentMode, this.inSlope = e.inSlope == "Infinity" ? NaN : e.inSlope, this.outSlope = e.outSlope == "Infinity" ? NaN : e.outSlope;
  }
  unSerialized2(e) {
    this.serializedVersion = e.serializedVersion, this.time = e.time, this.value = e.value, this.tangentMode = e.tangentMode, this.inSlope = e.inTangent == "Infinity" ? NaN : e.inTangent, this.outSlope = e.outTangent == "Infinity" ? NaN : e.outTangent;
  }
};
var Ri = class {
  constructor(e, t = xr.Repeat, r = xr.Repeat) {
    __publicField(this, "_totalTime", 1);
    __publicField(this, "_cache", new Io());
    __publicField(this, "_cacheOut", { lhsIndex: 0, rhsIndex: 0 });
    __publicField(this, "_InvalidateCache", false);
    __publicField(this, "curve", []);
    __publicField(this, "serializedVersion");
    __publicField(this, "preWarpMode");
    __publicField(this, "postWarpMode");
    __publicField(this, "rotationOrder");
    if (e)
      for (let i = 0; i < e.length; i++) {
        const a = e[i];
        this.addKeyFrame(a);
      }
    this.preWarpMode = t, this.postWarpMode = r;
  }
  get totalTime() {
    return this._totalTime;
  }
  get first() {
    return this.curve[0];
  }
  get last() {
    return this.curve[this.curve.length - 1];
  }
  addKeyFrame(e) {
    this.curve.indexOf(e) == -1 && this.curve.push(e), this.calcTotalTime();
  }
  removeKeyFrame(e) {
    let t = this.curve.indexOf(e);
    t != -1 && this.curve.splice(t, 1), this.calcTotalTime();
  }
  calculateCacheData(e, t, r, i = 0) {
    let a = this.curve, o = a[t], n = a[r];
    e.index = t, e.time = o.time + i, e.timeEnd = n.time + i, e.index = t;
    let l, h, u, c, f, g, m;
    l = n.time - o.time, l = Math.max(l, 1e-4), u = n.value - o.value, h = 1 / (l * l), c = o.outSlope, f = n.inSlope, g = c * l, m = f * l, e.coeff[0] = (g + m - u - u) * h / l, e.coeff[1] = (u + u + u - g - g - m) * h, e.coeff[2] = c, e.coeff[3] = o.value, this.setupStepped(e.coeff, o, n);
  }
  getValue(e) {
    return e = this.wrapTime(e), this.findCurve(e, this._cacheOut), this.calculateCacheData(this._cache, this._cacheOut.lhsIndex, this._cacheOut.rhsIndex, 0), this.evaluateCache(this._cache, e);
  }
  getKeyCount() {
    return this.curve.length;
  }
  getKey(e) {
    return this.curve[e];
  }
  unSerialized(e) {
    this.preWarpMode = e.m_PreInfinity, this.postWarpMode = e.m_PostInfinity, this.rotationOrder = e.m_RotationOrder;
    let t = e.m_Curve.length;
    for (let r = 0; r < t; r++)
      this.curve[r] = new Pa(), this.curve[r].unSerialized(e.m_Curve[r.toString()]);
    return this.calcTotalTime(), this;
  }
  unSerialized2(e) {
    this.preWarpMode = e.preWrapMode, this.postWarpMode = e.postWrapMode;
    let t = e.keyFrames || e.keys, r = t.length;
    for (let i = 0; i < r; i++)
      this.curve[i] = new Pa(), this.curve[i].unSerialized2(t[i.toString()]);
    return this.calcTotalTime(), this;
  }
  wrapTime(e) {
    let t = this.curve, r = t[0].time, i = t[t.length - 1].time;
    return e < r ? this.preWarpMode == xr.Clamp ? e = r : this.preWarpMode == xr.PingPong ? e = Rs(e, r, i) : e = Us(e, r, i) : e > i && (this.postWarpMode == xr.Clamp ? e = i : this.postWarpMode == xr.PingPong ? e = Rs(e, r, i) : e = Us(e, r, i)), e;
  }
  evaluateCache(e, t) {
    let r = t - e.time;
    return r * (r * (r * e.coeff[0] + e.coeff[1]) + e.coeff[2]) + e.coeff[3];
  }
  findCurve(e, t) {
    let r = this.curve;
    for (let i = 1; i < r.length; i++) {
      let a = r[i - 1], o = r[i];
      a.time <= e && o.time > e && (t.lhsIndex = i - 1, t.rhsIndex = i);
    }
  }
  setupStepped(e, t, r) {
    (isNaN(t.outSlope) || isNaN(r.inSlope)) && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = t.value);
  }
  invalidateCache() {
    this._InvalidateCache = true;
  }
  calcTotalTime() {
    let e = 0;
    for (let t of this.curve)
      t ? e = Math.max(e, t.time) : console.error(t);
    this._totalTime = e;
  }
  static scaleCurveValue(e, t) {
    if (!e._InvalidateCache)
      for (let r = 0; r < e.curve.length; r++) {
        let i = e.curve[r];
        i.value *= t, i.inSlope *= t, i.outSlope *= t;
      }
    e.invalidateCache();
  }
};
var ac = class extends Ri {
  constructor() {
    super();
    __publicField(this, "attribute", "");
    __publicField(this, "propertyList");
    __publicField(this, "path");
  }
  unSerialized(e) {
    let { attribute: t, path: r } = e;
    return this.attribute = t, this.path = r, this.propertyList = t.split("."), super.unSerialized(e.curve), this;
  }
};
var sc = class {
  constructor() {
    __publicField(this, "curve", {});
  }
};
var ii = ((s) => (s[s.Default = 0] = "Default", s[s.Clamp = 1] = "Clamp", s[s.Once = 1] = "Once", s[s.Loop = 2] = "Loop", s[s.PingPong = 4] = "PingPong", s[s.ClampForever = 8] = "ClampForever", s))(ii || {});
var qg = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "objAnimClip");
    __publicField(this, "totalTime", 0);
    __publicField(this, "time", 0);
    __publicField(this, "_stopTime", 0);
    __publicField(this, "_loopTime");
    __publicField(this, "_wrapMode");
    __publicField(this, "_sampleRate");
  }
  get wrapMode() {
    return this._wrapMode || (this._wrapMode = 0), this._wrapMode;
  }
  set wrapMode(e) {
    this._wrapMode = e;
  }
  parse(e) {
    this.objAnimClip = {};
    let t = e.AnimationClip, { m_Name: r, m_AnimationClipSettings: i, m_WrapMode: a, m_SampleRate: o } = t;
    this.name = r, this._wrapMode = a, this._sampleRate = o, this._loopTime = i.m_LoopTime;
    for (const n in t.m_EditorCurves)
      if (Object.prototype.hasOwnProperty.call(t.m_EditorCurves, n)) {
        const l = t.m_EditorCurves[n];
        let h = l.attribute, u = new ac();
        u.unSerialized(l), this.totalTime = Math.max(this.totalTime, u.totalTime);
        let c = this.objAnimClip[l.path];
        c || (c = new sc(), this.objAnimClip[l.path] = c), c.curve[h] = u;
      }
  }
};
var oc = class {
  constructor() {
    __publicField(this, "transform");
    __publicField(this, "quaternion");
    __publicField(this, "materialColor");
  }
};
var Ui = class {
  static updatePropertyTag(e, t) {
    e.quaternion || (e.quaternion = this.tag_quaternion[t]), e.transform || (e.transform = this.tag_transform[t]), e.materialColor || (e.materialColor = this.tag_materialColor[t]);
  }
};
__publicField(Ui, "Property", { "m_LocalPosition.x": "localPosition.x", "m_LocalPosition.y": "localPosition.y", "m_LocalPosition.z": "localPosition.z", "m_LocalRotation.x": "localQuaternion.x", "m_LocalRotation.y": "localQuaternion.y", "m_LocalRotation.z": "localQuaternion.z", "m_LocalRotation.w": "localQuaternion.w", "localEulerAnglesRaw.x": "localRotation.x", "localEulerAnglesRaw.y": "localRotation.y", "localEulerAnglesRaw.z": "localRotation.z", "m_LocalEulerAngles.x": "localRotation.x", "m_LocalEulerAngles.y": "localRotation.y", "m_LocalEulerAngles.z": "localRotation.z", "m_LocalScale.x": "localScale.x", "m_LocalScale.y": "localScale.y", "m_LocalScale.z": "localScale.z", "m_Color.r": "materialColor.r", "m_Color.g": "materialColor.g", "m_Color.b": "materialColor.b", "m_Color.a": "materialColor.a", "material._Color.r": "materialColor.r", "material._Color.g": "materialColor.g", "material._Color.b": "materialColor.b", "material._Color.a": "materialColor.a", "material._UnlitColor.r": "materialColor.r", "material._UnlitColor.g": "materialColor.g", "material._UnlitColor.b": "materialColor.b", "material._UnlitColor.a": "materialColor.a", "field of view": "camera3D.fov", m_IsActive: "active", m_Sprite: "sprite", m_FlipX: "flipX", m_FlipY: "flipY" });
__publicField(Ui, "Scale", { "m_LocalPosition.x": 1, "m_LocalPosition.y": 1, "m_LocalPosition.z": -1, "localEulerAnglesRaw.x": -1, "localEulerAnglesRaw.y": 1, "localEulerAnglesRaw.z": 1, "m_LocalEulerAngles.x": -1, "m_LocalEulerAngles.y": 1, "m_LocalEulerAngles.z": 1, "m_LocalRotation.x": 1, "m_LocalRotation.y": 1, "m_LocalRotation.z": -1, "m_LocalRotation.w": -1, "field of view": 1, m_IsActive: 1, m_Sprite: 1 });
__publicField(Ui, "tag_quaternion", { "m_LocalRotation.x": true, "m_LocalRotation.y": true, "m_LocalRotation.z": true, "m_LocalRotation.w": true });
__publicField(Ui, "tag_materialColor", { "material._Color.r": true, "material._Color.g": true, "material._Color.b": true, "material._Color.a": true, "material._UnlitColor.r": true, "material._UnlitColor.g": true, "material._UnlitColor.b": true, "material._UnlitColor.a": true });
__publicField(Ui, "tag_transform", { "m_LocalPosition.x": true, "m_LocalPosition.y": true, "m_LocalPosition.z": true, "m_LocalRotation.x": true, "m_LocalRotation.y": true, "m_LocalRotation.z": true, "m_LocalRotation.w": true, "localEulerAnglesRaw.x": true, "localEulerAnglesRaw.y": true, "localEulerAnglesRaw.z": true, "m_LocalEulerAngles.x": true, "m_LocalEulerAngles.y": true, "m_LocalEulerAngles.z": true, "m_LocalScale.x": true, "m_LocalScale.y": true, "m_LocalScale.z": true });
var _Qr = class _Qr {
  constructor(e) {
    __publicField(this, "_rootObject3D");
    __publicField(this, "_animation");
    __publicField(this, "_propertyCache");
    __publicField(this, "_currentClip");
    __publicField(this, "_frame", 0);
    __publicField(this, "_time", 0);
    __publicField(this, "_isPlaying", true);
    __publicField(this, "speed", 1);
    __publicField(this, "_propertyTagDic");
    this._rootObject3D = e.object3D, this._animation = e, this._propertyTagDic = /* @__PURE__ */ new Map(), this.reset();
  }
  reset() {
    this._propertyCache = {}, this._propertyTagDic.clear();
  }
  get time() {
    return this._time;
  }
  get currentClip() {
    return this._currentClip;
  }
  play(e, t = true) {
    this._isPlaying = true, t && (this._time = 0), e != this._currentClip && e && this.parseAnimClip(e), this._currentClip = e, this.validProperty();
  }
  parseAnimClip(e) {
    var _a3;
    this.reset();
    for (const t in e.objAnimClip) {
      let r = e.objAnimClip[t], i = this._rootObject3D, a = {};
      if (t == "" ? i = this._rootObject3D : i = this._rootObject3D.getObjectByName(t), !i)
        continue;
      let o = new oc();
      this._propertyTagDic.set(i, o);
      let n = r.curve;
      for (const l in n) {
        Ui.updatePropertyTag(o, l);
        let h = (_a3 = this._propertyCache)[t] || (_a3[t] = {}), u = Ui.Property[l].split("."), c = u[0];
        if (u.length > 1) {
          let f = a[c];
          f || (f = a[c] = i[c]), h[l] = { value: f, property: u[1] };
        } else
          h[l] = { value: i, property: u[0] };
      }
    }
    return this;
  }
  stop() {
    return this._isPlaying = false, this;
  }
  toggle() {
    return this._isPlaying = !this._isPlaying, this;
  }
  get isPlaying() {
    return this._isPlaying;
  }
  update(e, t) {
    if (e = e * 1e-3, t = t * 1e-3, !this._currentClip || this._frame == e || !this._isPlaying)
      return;
    this._frame = e;
    let r = this._time;
    this._time = this.calcTime(r + t * this.speed), this.validProperty(), this._currentClip.wrapMode != ii.Loop && this._currentClip.wrapMode != ii.Default && (this.speed > 0 ? this._time >= this._currentClip.totalTime : this._time <= 0) && (this._isPlaying = false, this._animation.statusCall(_Qr.Complete, r, this._time)), this._animation.statusCall(_Qr.Seek, r, this._time);
  }
  seek(e) {
    return this._time = this.calcTime(e), this._rootObject3D && this.validProperty(), this;
  }
  calcTime(e) {
    return this._currentClip.wrapMode == ii.Loop || this._currentClip.wrapMode == ii.Default ? e = zs(e, this._currentClip.totalTime) : e = W(e, 0, this._currentClip.totalTime), e;
  }
  validProperty() {
    for (const e in this._currentClip.objAnimClip) {
      let r = this._currentClip.objAnimClip[e].curve;
      for (const i in r) {
        const a = r[i];
        let o = this._propertyCache[e][i], n = a.getValue(this._time);
        i in Ui.Scale && (n *= Ui.Scale[i]), o.value[o.property] = n;
      }
    }
    this._propertyTagDic.forEach((e, t) => {
      this.applyProperty(e, t);
    });
  }
  applyProperty(e, t) {
    e.quaternion && P.getEuler(t.transform.localRotation, t.transform.localRotQuat, true, "ZYX"), e.transform && (t.transform.localPosition = t.transform.localPosition, t.transform.localRotation = t.transform.localRotation, t.transform.localScale = t.transform.localScale);
    let r = t;
    e.materialColor && r.notifyMaterialColorChange(0, "baseColor");
  }
};
__publicField(_Qr, "Complete", 0);
__publicField(_Qr, "Seek", 1);
var Qr = _Qr;
var Kg = class {
  constructor() {
    __publicField(this, "clipName");
    __publicField(this, "data");
    __publicField(this, "time");
  }
};
var Li = class extends ze {
  constructor(e, t) {
    super(t);
    __publicField(this, "animation");
    __publicField(this, "frame");
    this.animation = e;
  }
};
__publicField(Li, "SEEK", "SEEK");
__publicField(Li, "COMPLETE", "COMPLETE");
var zo = class _zo extends _e {
  constructor() {
    super();
    __publicField(this, "_animator");
    __publicField(this, "_clips", []);
    __publicField(this, "defaultClip");
    __publicField(this, "autoPlay");
    __publicField(this, "_seekEvent");
    __publicField(this, "_completeEvent");
    __publicField(this, "_keyFrameList");
    this._seekEvent = new Li(this, Li.SEEK), this._completeEvent = new Li(this, Li.COMPLETE), this._keyFrameList = {};
  }
  registerEventKeyFrame(e) {
    let t = this._keyFrameList[e.clipName];
    t == null && (this._keyFrameList[e.clipName] = t = []), t.push(e);
  }
  init() {
    this._animator = new Qr(this);
  }
  onUpdate() {
    this.enable && this._animator.update(ce.time, ce.delta);
  }
  appendClip(e) {
    this._clips.push(e), this.play(e.name);
  }
  statusCall(e, t, r) {
    if (e == Qr.Complete)
      this.eventDispatcher.dispatchEvent(this._completeEvent);
    else if (e == Qr.Seek && t != r) {
      let i = this._keyFrameList[this.currentClip.name];
      if (i)
        for (let a of i)
          a.time > t && a.time <= r && (this._seekEvent.data = this._seekEvent.frame = a, this.eventDispatcher.dispatchEvent(this._seekEvent));
    }
  }
  set speed(e) {
    this._animator.speed = e;
  }
  get speed() {
    return this._animator.speed;
  }
  stop() {
    this._animator.stop();
  }
  toggle() {
    this._animator.toggle();
  }
  getClip(e) {
    let t;
    for (let r of this._clips)
      if (r.name == e) {
        t = r;
        break;
      }
    return t;
  }
  get currentClip() {
    return this._animator.currentClip;
  }
  get time() {
    return this._animator.time;
  }
  seek(e) {
    this._animator.seek(e);
  }
  play(e, t = true) {
    let r = this.getClip(e);
    return r ? (this._animator.play(r, t), r) : null;
  }
  start() {
    this.autoPlay && this.play(this.defaultClip);
  }
  copyComponent(e) {
    this.autoPlay = e.autoPlay, this.defaultClip = e.defaultClip;
    let t = e._clips;
    for (let r = 0, i = t.length; r < i; r++)
      this.appendClip(t[r]);
    return this;
  }
  cloneTo(e) {
    e.addComponent(_zo).copyComponent(this);
  }
};
var Jg = Object.defineProperty;
var Zg = Object.getOwnPropertyDescriptor;
var $g = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Zg(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Jg(e, t, i), i;
};
var Dr = class extends J {
  constructor() {
    super();
    __publicField(this, "skinJointsName");
    __publicField(this, "mInverseBindMatrixData");
    __publicField(this, "mInverseBindMatrixBuffer");
    __publicField(this, "mSkeletonAnimation");
    __publicField(this, "mJointIndexTableBuffer");
    this.addRendererMask(De.SkinnedMesh);
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(s) {
    this.skinJointsName = s.skinNames;
    let e = [];
    for (let t = 0; t < s.bindPose.length; t++)
      e.push(s.bindPose[t].rawData.slice(0, 16));
    this.skinInverseBindMatrices = e, super.geometry = s;
  }
  start() {
    if (super.start(), this.skeletonAnimation = this.object3D.getComponent(vr), !this.skeletonAnimation) {
      let s = this.object3D.parentObject.parentObject.getComponentsInChild(vr);
      s.length > 0 && (this.skeletonAnimation = s[0]);
      let e = this.object3D;
      for (; !this.skeletonAnimation && e; )
        this.skeletonAnimation = e.getComponentFromParent(vr), e.parent && (e = e.parent.object3D);
    }
  }
  get blendShape() {
    return this.morphData;
  }
  onEnable() {
    super.onEnable();
  }
  get skeletonAnimation() {
    return this.mSkeletonAnimation;
  }
  set skeletonAnimation(s) {
    if (this.mSkeletonAnimation = s, !!s && !this.mJointIndexTableBuffer) {
      let e = this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);
      this.mJointIndexTableBuffer = new $(e.length, 0, new Float32Array(e)), this.mJointIndexTableBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
    }
  }
  get skinInverseBindMatrices() {
    return this.mInverseBindMatrixData;
  }
  set skinInverseBindMatrices(s) {
    this.mInverseBindMatrixData = s;
    var e = new Float32Array(s.length * 16);
    for (let t = 0; t < s.length; t++) {
      let r = t * 16, i = s[t];
      e.set(i, r);
    }
    this.mInverseBindMatrixBuffer = new $(e.byteLength, 0, e), this.mInverseBindMatrixBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
  }
  get inverseBindMatrixBuffer() {
    return this.mInverseBindMatrixBuffer;
  }
  get jointIndexTableBuffer() {
    return this.mJointIndexTableBuffer.buffer;
  }
  cloneTo(s) {
    let e = s.addComponent(Dr), t = [];
    for (const r of this.materials)
      t.push(r.clone());
    e.materials = t, e.geometry = this.geometry, e.castShadow = this.castShadow, e.castGI = this.castGI, e.receiveShadow = this.receiveShadow, e.rendererMask = this.rendererMask, e.skinJointsName = this.skinJointsName, e.skinInverseBindMatrices = this.skinInverseBindMatrices, e.mJointIndexTableBuffer = this.mJointIndexTableBuffer;
  }
  nodeUpdate(s, e, t, r) {
    for (let i = 0; i < this.materials.length; i++) {
      let o = this.materials[i].getPass(e);
      if (o)
        for (let n = 0; n < o.length; n++) {
          const l = o[n];
          !l.pipeline && this.mSkeletonAnimation && (l.setStorageBuffer("jointsMatrixIndexTable", this.mSkeletonAnimation.jointMatrixIndexTableBuffer), l.setStorageBuffer("jointsInverseMatrix", this.mInverseBindMatrixBuffer), l.setStorageBuffer("jointsIndexMapingTable", this.mJointIndexTableBuffer));
        }
    }
    super.nodeUpdate(s, e, t, r);
  }
};
Dr = $g([_t(Dr, "SkinnedMeshRenderer2")], Dr);
var ep = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "_targetRenderers", {});
    __publicField(this, "_vec3", new d());
    __publicField(this, "_matrix4", new P());
    __publicField(this, "_quaternion", new H());
  }
  init(e) {
    let t = this.fetchMorphRenderers(this.object3D, Dr), r = this.fetchMorphRenderers(this.object3D, J);
    t.push(...r);
    for (const i of t) {
      Et.hasMask(i.rendererMask, De.MorphTarget) && i.selfCloneMaterials("MORPH_TARGET_UUID");
      for (const o in i.geometry.morphTargetDictionary) {
        let n = this._targetRenderers[o] || [];
        n.push(i), this._targetRenderers[o] = n;
      }
    }
  }
  getMorphRenderersByKey(e) {
    return this._targetRenderers[e];
  }
  cloneMorphRenderers() {
    let e = {};
    for (let t in this._targetRenderers)
      e[t] = this._targetRenderers[t];
    return e;
  }
  applyBlendShape(e, t, r = 1) {
    if (!e) {
      console.warn("blendShape is null");
      return;
    }
    this._vec3.setFromArray(e.transform.transform[3]), this._vec3.multiplyScalar(r), this.object3D.transform.localPosition = this._vec3, this._vec3.setFromArray(e.transform.transform[2]), this._matrix4.copyColFrom(2, this._vec3), this._vec3.setFromArray(e.transform.transform[1]), this._matrix4.copyColFrom(1, this._vec3), this._vec3.setFromArray(e.transform.transform[0]), this._matrix4.copyColFrom(0, this._vec3), this._matrix4.transpose(), this._quaternion.fromMatrix(this._matrix4), this.object3D.localQuaternion = this._quaternion;
    for (let i in t) {
      let a = this._targetRenderers[i], o = t[i], n = e.texture[o];
      this.applyMorphTargetInfluence(i, n, a);
    }
  }
  applyMorphTargetInfluence(e, t, r) {
    for (let i of r)
      i.setMorphInfluence(e, t);
  }
  fetchMorphRenderers(e, t) {
    let r = e.getComponentsInChild(t), i = [];
    for (let a of r)
      a.hasMask(De.MorphTarget) && i.push(a);
    return i;
  }
};
var tp = class {
  constructor() {
    __publicField(this, "texture");
    __publicField(this, "transform");
  }
};
var nc = ((s) => (s.mouthRollLower = "mouthRollLower", s.browOuterUp_L = "browOuterUpLeft", s.mouthSmile_L = "mouthSmileLeft", s.jawRight = "jawRight", s.eyeLookOut_L = "eyeLookOutLeft", s.mouthFunnel = "mouthFunnel", s.mouthUpperUp_R = "mouthUpperUpRight", s.browDown_L = "browDownLeft", s.jawLeft = "jawLeft", s.mouthLowerDown_L = "mouthLowerDownLeft", s.noseSneer_R = "noseSneerRight", s.jawForward = "jawForward", s.mouthLowerDown_R = "mouthLowerDownRight", s.browInnerUp = "browInnerUp", s.mouthRollUpper = "mouthRollUpper", s.mouthStretch_R = "mouthStretchRight", s.mouthPucker = "mouthPucker", s.eyeBlink_L = "eyeBlinkLeft", s.mouthUpperUp_L = "mouthUpperUpLeft", s.mouthShrugUpper = "mouthShrugUpper", s.eyeLookIn_R = "eyeLookInRight", s.noseSneer_L = "noseSneerLeft", s.mouthFrown_L = "mouthFrownLeft", s.cheekSquint_L = "cheekSquintLeft", s.eyeLookDown_L = "eyeLookDownLeft", s.mouthDimple_L = "mouthDimpleLeft", s.mouthFrown_R = "mouthFrownRight", s.eyeLookIn_L = "eyeLookInLeft", s.eyeLookOut_R = "eyeLookOutRight", s.mouthLeft = "mouthLeft", s.mouthStretch_L = "mouthStretchLeft", s.mouthPress_L = "mouthPressLeft", s.mouthDimple_R = "mouthDimpleRight", s.eyeWide_R = "eyeWideRight", s.browDown_R = "browDownRight", s.eyeLookUp_R = "eyeLookUpRight", s.eyeBlink_R = "eyeBlinkRight", s.cheekSquint_R = "cheekSquintRight", s.mouthRight = "mouthDimpleRight", s.eyeLookDown_R = "eyeLookDownRight", s.eyeLookUp_L = "eyeLookUpLeft", s.eyeSquint_L = "eyeSquintLeft", s.jawOpen = "jawOpen", s.browOuterUp_R = "browOuterUpRight", s.mouthClose = "mouthClose", s.mouthShrugLower = "mouthShrugLower", s.eyeWide_L = "eyeWideLeft", s.tongueOut = "tongueOut", s.eyeSquint_R = "eyeSquintRight", s.cheekPuff = "cheekPuff", s.mouthPress_R = "mouthPressRight", s.mouthSmile_R = "mouthSmileRight", s))(nc || {});
var rp = class {
  constructor(e, t) {
    __publicField(this, "_computePipeline");
    __publicField(this, "_computeBindGroup");
    let r = w.device;
    this._computePipeline = r.createComputePipeline({ layout: "auto", compute: { module: r.createShaderModule({ code: e }), entryPoint: "CsMain" } }), this._computeBindGroup = r.createBindGroup({ layout: this._computePipeline.getBindGroupLayout(0), entries: t });
  }
  compute(e, t, r, i) {
    let a = e.beginComputePass();
    return a.setPipeline(this._computePipeline), a.setBindGroup(0, this._computeBindGroup), a.dispatchWorkgroups(t, r, i), a.end(), this;
  }
};
var ip = class extends fr {
  constructor() {
    super();
    __publicField(this, "numJoint");
    __publicField(this, "numState");
    __publicField(this, "time");
    __publicField(this, "weight");
    __publicField(this, "argumentsData");
    __publicField(this, "_isDirty", false);
    __publicField(this, "_argumentsBuffer");
    __publicField(this, "_argumentsBufferEntries");
    this.allocationMemorySet([{ name: "numJoint", data: [0] }, { name: "numState", data: [0] }, { name: "retain1", data: [0] }, { name: "retain2", data: [0] }, { name: "time", data: [0, 0] }, { name: "weight", data: [0, 0] }]), this.generateGPUBuffer();
  }
  getGPUBuffer() {
    return this._argumentsBuffer;
  }
  getGPUBindGroupEntry() {
    return this._argumentsBufferEntries;
  }
  updateGPUBuffer() {
    return this._isDirty && (this._isDirty = false, w.device.queue.writeBuffer(this._argumentsBuffer, 0, this.shareDataBuffer)), this;
  }
  allocationMemorySet(e) {
    this.argumentsData = {};
    let t = 0;
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      t += a.data.length;
    }
    this.allocation(t * 4);
    let r = this;
    for (let i = 0; i < e.length; i++) {
      const a = e[i], o = a.name;
      this.argumentsData[o] = this.allocation_node(a.data.length * 4), r[o] = this.argumentsData[o];
    }
  }
  generateGPUBuffer() {
    let e = w.device;
    this._argumentsBuffer = e.createBuffer({ size: this.shareDataBuffer.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, mappedAtCreation: false }), this._argumentsBufferEntries = { binding: 0, resource: { buffer: this._argumentsBuffer, offset: 0, size: this.shareDataBuffer.byteLength } };
  }
};
var ap = class extends fr {
  constructor() {
    super();
    __publicField(this, "numJoint");
    __publicField(this, "numFrame");
    __publicField(this, "retain0");
    __publicField(this, "retain1");
    __publicField(this, "argumentsData");
    __publicField(this, "_isDirty", false);
    __publicField(this, "_argumentsBuffer");
    __publicField(this, "_argumentsBufferEntries");
    this.allocationMemorySet([{ name: "numJoint", data: [0] }, { name: "numFrame", data: [0] }, { name: "retain0", data: [0] }, { name: "retain1", data: [0] }]), this.generateGPUBuffer();
  }
  getGPUBuffer() {
    return this._argumentsBuffer;
  }
  getGPUBindGroupEntry() {
    return this._argumentsBufferEntries;
  }
  updateGPUBuffer() {
    this._isDirty && (this._isDirty = false, w.device.queue.writeBuffer(this._argumentsBuffer, 0, this.shareDataBuffer));
  }
  allocationMemorySet(e) {
    this.argumentsData = {};
    let t = 0;
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      t += a.data.length;
    }
    this.allocation(t * 4);
    let r = this;
    for (let i = 0; i < e.length; i++) {
      const a = e[i], o = a.name;
      this.argumentsData[o] = this.allocation_node(a.data.length * 4), r[o] = this.argumentsData[o];
    }
  }
  generateGPUBuffer() {
    let e = w.device;
    this._argumentsBuffer = e.createBuffer({ size: this.shareDataBuffer.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, mappedAtCreation: false }), this._argumentsBufferEntries = { binding: 0, resource: { buffer: this._argumentsBuffer, offset: 0, size: this.shareDataBuffer.byteLength } };
  }
};
var sp = `
  ${ha}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`;
var op = `
  ${ha}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`;
var np = class {
  constructor(e = null, t = null) {
    __publicField(this, "_autoUpdate", true);
    __publicField(this, "_target");
    __publicField(this, "_lookAtObject");
    __publicField(this, "_origin", new d(0, 0, 0));
    __publicField(this, "_speed", 300);
    this._target = e, this._lookAtObject = t;
  }
  get target() {
    return this._target;
  }
  set target(e) {
    this._target != e && (this._target = e);
  }
  get lookAtObject() {
    return this._lookAtObject;
  }
  set lookAtObject(e) {
    this._lookAtObject != e && (this._lookAtObject = e);
  }
  get speed() {
    return this._speed;
  }
  set speed(e) {
    this._speed = e;
  }
  update() {
  }
};
var lp = class extends _e {
  constructor() {
    super();
    __publicField(this, "focus");
    __publicField(this, "distance", 5);
    __publicField(this, "_camera");
  }
  start() {
    if (this._camera = this.object3D.getOrAddComponent(Wr), !this._camera) {
      console.error("FirstPersonCameraController need camera");
      return;
    }
    if (!this.focus) {
      console.error("FirstPersonCameraController need target");
      return;
    }
    p.inputSystem.addEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.addEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.addEventListener(U.POINTER_DOWN, this.mouseDown, this);
  }
  mouseDown(e) {
    p.inputSystem.addEventListener(U.POINTER_MOVE, this.mouseMove, this);
  }
  mouseUp(e) {
    p.inputSystem.removeEventListener(U.POINTER_MOVE, this.mouseMove, this);
  }
  mouseMove(e) {
    let t = this.transform.localRotation;
    t.y += e.movementX * 0.01, t.x += e.movementY * 0.01, this.transform.localRotation = t;
  }
  mouseWheel(e) {
    this.distance += p.inputSystem.wheelDelta * 0.1;
  }
  onUpdate() {
    let e = new d();
    this._camera.transform.forward.scaleToRef(this.distance, e);
    var t = this.focus.transform.worldPosition;
    this._camera.transform.localPosition = t;
  }
  destroy(e) {
    p.inputSystem.removeEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.removeEventListener(U.POINTER_DOWN, this.mouseDown, this), super.destroy(e);
  }
};
var Ge = ((s) => (s[s.Key_BackSpace = 8] = "Key_BackSpace", s[s.Key_Tab = 9] = "Key_Tab", s[s.Key_Clear = 12] = "Key_Clear", s[s.Key_Enter = 13] = "Key_Enter", s[s.Key_Shift_L = 16] = "Key_Shift_L", s[s.Key_Control_L = 17] = "Key_Control_L", s[s.Key_Alt_L = 18] = "Key_Alt_L", s[s.Key_Pause = 19] = "Key_Pause", s[s.Key_CapsLock = 20] = "Key_CapsLock", s[s.Key_Escape = 21] = "Key_Escape", s[s.Key_Esc = 27] = "Key_Esc", s[s.Key_Space = 32] = "Key_Space", s[s.Key_Prior = 33] = "Key_Prior", s[s.Key_Next = 34] = "Key_Next", s[s.Key_End = 35] = "Key_End", s[s.Key_Home = 36] = "Key_Home", s[s.Key_Left = 37] = "Key_Left", s[s.Key_Up = 38] = "Key_Up", s[s.Key_Right = 39] = "Key_Right", s[s.Key_Down = 40] = "Key_Down", s[s.Key_Select = 41] = "Key_Select", s[s.Key_Print = 42] = "Key_Print", s[s.Key_Execute = 43] = "Key_Execute", s[s.Key_Insert = 45] = "Key_Insert", s[s.Key_Delete = 46] = "Key_Delete", s[s.Key_Help = 47] = "Key_Help", s[s.Key_0 = 48] = "Key_0", s[s.Key_1 = 49] = "Key_1", s[s.Key_2 = 50] = "Key_2", s[s.Key_3 = 51] = "Key_3", s[s.Key_4 = 52] = "Key_4", s[s.Key_5 = 53] = "Key_5", s[s.Key_6 = 54] = "Key_6", s[s.Key_7 = 55] = "Key_7", s[s.Key_8 = 56] = "Key_8", s[s.Key_9 = 57] = "Key_9", s[s.Key_A = 65] = "Key_A", s[s.Key_B = 66] = "Key_B", s[s.Key_C = 67] = "Key_C", s[s.Key_D = 68] = "Key_D", s[s.Key_E = 69] = "Key_E", s[s.Key_F = 70] = "Key_F", s[s.Key_G = 71] = "Key_G", s[s.Key_H = 72] = "Key_H", s[s.Key_I = 73] = "Key_I", s[s.Key_J = 74] = "Key_J", s[s.Key_K = 75] = "Key_K", s[s.Key_L = 76] = "Key_L", s[s.Key_M = 77] = "Key_M", s[s.Key_N = 78] = "Key_N", s[s.Key_O = 79] = "Key_O", s[s.Key_P = 80] = "Key_P", s[s.Key_Q = 81] = "Key_Q", s[s.Key_R = 82] = "Key_R", s[s.Key_S = 83] = "Key_S", s[s.Key_T = 84] = "Key_T", s[s.Key_U = 85] = "Key_U", s[s.Key_V = 86] = "Key_V", s[s.Key_W = 87] = "Key_W", s[s.Key_X = 88] = "Key_X", s[s.Key_Y = 89] = "Key_Y", s[s.Key_Z = 90] = "Key_Z", s[s.Key_KP_0 = 96] = "Key_KP_0", s[s.Key_KP_1 = 97] = "Key_KP_1", s[s.Key_KP_2 = 98] = "Key_KP_2", s[s.Key_KP_3 = 99] = "Key_KP_3", s[s.Key_KP_4 = 100] = "Key_KP_4", s[s.Key_KP_5 = 101] = "Key_KP_5", s[s.Key_KP_6 = 102] = "Key_KP_6", s[s.Key_KP_7 = 103] = "Key_KP_7", s[s.Key_KP_8 = 104] = "Key_KP_8", s[s.Key_KP_9 = 105] = "Key_KP_9", s[s.Key_Multiply = 106] = "Key_Multiply", s[s.Key_Add = 107] = "Key_Add", s[s.Key_Separator = 108] = "Key_Separator", s[s.Key_Subtract = 109] = "Key_Subtract", s[s.Key_Decimal = 110] = "Key_Decimal", s[s.Key_Divide = 111] = "Key_Divide", s[s.Key_F1 = 112] = "Key_F1", s[s.Key_F2 = 113] = "Key_F2", s[s.Key_F3 = 114] = "Key_F3", s[s.Key_F4 = 115] = "Key_F4", s[s.Key_F5 = 116] = "Key_F5", s[s.Key_F6 = 117] = "Key_F6", s[s.Key_F7 = 118] = "Key_F7", s[s.Key_F8 = 119] = "Key_F8", s[s.Key_F9 = 120] = "Key_F9", s[s.Key_F10 = 121] = "Key_F10", s[s.Key_F11 = 122] = "Key_F11", s[s.Key_F12 = 123] = "Key_F12", s[s.Key_F13 = 124] = "Key_F13", s[s.Key_F14 = 125] = "Key_F14", s[s.Key_F15 = 126] = "Key_F15", s[s.Key_F16 = 127] = "Key_F16", s[s.Key_F17 = 128] = "Key_F17", s[s.Key_F18 = 129] = "Key_F18", s[s.Key_F19 = 130] = "Key_F19", s[s.Key_F20 = 131] = "Key_F20", s[s.Key_F21 = 132] = "Key_F21", s[s.Key_F22 = 133] = "Key_F22", s[s.Key_F23 = 134] = "Key_F23", s[s.Key_F24 = 135] = "Key_F24", s[s.Key_Num_Lock = 136] = "Key_Num_Lock", s[s.Key_Scroll_Lock = 137] = "Key_Scroll_Lock", s))(Ge || {});
var hp = class extends _e {
  constructor() {
    super();
    __publicField(this, "moveSpeed", 2);
    __publicField(this, "targetPos", new d(0, 0, 10));
    __publicField(this, "lookAtPos", new d(0, 0, 0));
    __publicField(this, "config", { shiftMoveScale: 20 });
    __publicField(this, "_moveScale", 1);
    __publicField(this, "_dir");
    __publicField(this, "_mouseFactory", 25);
    __publicField(this, "_factory", 1.5);
    __publicField(this, "_mouseDown", false);
    __publicField(this, "_lastPos");
    __publicField(this, "_keyState");
    this._lastPos = new d(), this._keyState = { front: false, back: false, left: false, right: false, q: false, e: false }, this.setCamera(new d(0, 0, 100), new d(0, 0, 0));
  }
  setCamera(e, t) {
    this.targetPos.copyFrom(e), this.lookAtPos.copyFrom(t), this.Reset();
  }
  start() {
    p.inputSystem.addEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.addEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.addEventListener(U.POINTER_DOWN, this.mouseDown, this), p.inputSystem.addEventListener(cr.KEY_UP, this.keyUp, this), p.inputSystem.addEventListener(cr.KEY_DOWN, this.keyDown, this), this.transform.lookAt(this.targetPos, this.lookAtPos);
  }
  mouseWheel(e) {
  }
  keyUp(e) {
    switch (e.keyCode) {
      case Ge.Key_W:
        this._keyState.front = false;
        break;
      case Ge.Key_S:
        this._keyState.back = false;
        break;
      case Ge.Key_A:
        this._keyState.left = false;
        break;
      case Ge.Key_D:
        this._keyState.right = false;
        break;
      case Ge.Key_Shift_L:
        this._moveScale = 1;
        break;
      case Ge.Key_Q:
        this._keyState.q = false;
        break;
      case Ge.Key_E:
        this._keyState.e = false;
        break;
      case Ge.Key_F:
        this.transform.lookAt(this.targetPos, this.lookAtPos);
        break;
    }
  }
  keyDown(e) {
    switch (e.keyCode) {
      case Ge.Key_W:
        this._keyState.front = true;
        break;
      case Ge.Key_S:
        this._keyState.back = true;
        break;
      case Ge.Key_A:
        this._keyState.left = true;
        break;
      case Ge.Key_D:
        this._keyState.right = true;
        break;
      case Ge.Key_Q:
        this._keyState.q = true;
        break;
      case Ge.Key_E:
        this._keyState.e = true;
        break;
      case Ge.Key_Shift_L:
        this._moveScale = this.config.shiftMoveScale;
    }
  }
  Reset() {
    this._lastPos.x = p.inputSystem.mouseLastX, this._lastPos.y = p.inputSystem.mouseLastY;
  }
  mouseDown(e) {
    this.Reset(), this._mouseDown = true;
  }
  mouseUp(e) {
    this.Reset(), this._mouseDown = false;
  }
  get factory() {
    return this._factory;
  }
  set factory(e) {
    this._factory = e;
  }
  get mouseFactory() {
    return this._mouseFactory;
  }
  set mouseFactory(e) {
    this._mouseFactory = e;
  }
  internal(e, t, r) {
    return (t - e) * r;
  }
  onUpdate() {
    let e = this.transform, t = W(ce.delta, 0, 0.016);
    if (this._mouseDown && (e.rotationY -= this.internal(e.rotationY + (p.inputSystem.mouseLastX - this._lastPos.x) * 0.25, e.rotationY, t * this._mouseFactory), e.rotationX -= this.internal(e.rotationX + (p.inputSystem.mouseLastY - this._lastPos.y) * 0.25, e.rotationX, t * this._mouseFactory), this.Reset()), this._keyState.front) {
      let r = e.forward;
      e.x -= this.internal(e.x + r.x * this.moveSpeed * this._moveScale, e.x, t * this._factory), e.y -= this.internal(e.y + r.y * this.moveSpeed * this._moveScale, e.y, t * this._factory), e.z -= this.internal(e.z + r.z * this.moveSpeed * this._moveScale, e.z, t * this._factory);
    }
    if (this._keyState.back) {
      let r = e.forward;
      e.x += this.internal(e.x + r.x * this.moveSpeed * this._moveScale, e.x, t * this._factory), e.y += this.internal(e.y + r.y * this.moveSpeed * this._moveScale, e.y, t * this._factory), e.z += this.internal(e.z + r.z * this.moveSpeed * this._moveScale, e.z, t * this._factory);
    }
    if (this._keyState.left) {
      let r = e.left;
      e.x += this.internal(e.x + r.x * this.moveSpeed * this._moveScale, e.x, t * this._factory), e.y += this.internal(e.y + r.y * this.moveSpeed * this._moveScale, e.y, t * this._factory), e.z += this.internal(e.z + r.z * this.moveSpeed * this._moveScale, e.z, t * this._factory);
    }
    if (this._keyState.right) {
      let r = e.left;
      e.x -= this.internal(e.x + r.x * this.moveSpeed * this._moveScale, e.x, t * this._factory), e.y -= this.internal(e.y + r.y * this.moveSpeed * this._moveScale, e.y, t * this._factory), e.z -= this.internal(e.z + r.z * this.moveSpeed * this._moveScale, e.z, t * this._factory);
    }
    this._keyState.q && (e.y = Er(e.y, e.y - this.moveSpeed * this._moveScale, t * this._factory)), this._keyState.e && (e.y = Er(e.y, e.y + this.moveSpeed * this._moveScale, t * this._factory));
  }
  destroy(e) {
    p.inputSystem.removeEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.removeEventListener(U.POINTER_DOWN, this.mouseDown, this), p.inputSystem.removeEventListener(cr.KEY_UP, this.keyUp, this), p.inputSystem.removeEventListener(cr.KEY_DOWN, this.keyDown, this), super.destroy(e);
  }
};
var Pr = class {
  static add(e, t, r) {
    return r || (r = new d()), r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r;
  }
  static sub(e, t, r) {
    return r || (r = new d()), r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r;
  }
  static mul(e, t, r) {
    return r || (r = new d()), r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r;
  }
  static mulScale(e, t, r) {
    return r || (r = new d()), r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r;
  }
  static div(e, t, r) {
    return r || (r = new d()), r.x = e.x / t.x, r.y = e.y / t.y, r.z = e.z / t.z, r;
  }
  static normalize(e) {
    return e.clone().normalize();
  }
  static dot(e, t) {
    let r = d.HELP_0;
    return r.copyFrom(e), r.dotProduct(t);
  }
  static calculateVectorAngle_xz(e, t) {
    return Math.acos((e.x * t.x + e.y * t.y) / Math.sqrt((e.x * e.x + e.y * e.y) * (t.x * t.x + t.y * t.y)));
  }
  static distance(e, t) {
    return d.distance(e, t);
  }
  static getRandomXYZ(e = -100, t = 100) {
    return new d(Math.random() * (t - e) + e, Math.random() * (t - e) + e, Math.random() * (t - e) + e);
  }
  static getRandomV3(e = -100, t = 100, r, i) {
    return new d(Math.random() * t + e, Math.random() * i + r, Math.random() * t + e);
  }
  static sphere(e) {
    let t = e * Math.random(), r = new d(Math.random() * 1 - 0.5, Math.random() * 1 - 0.5, Math.random() * 1 - 0.5);
    return r.normalize(), r.scaleBy(t), r;
  }
  static sphereXYZ(e, t, r = 1, i = 1, a = 1) {
    let o = e + (t - e) * Math.random(), n = new d(Math.random() * r - r * 0.5, Math.random() * i - i * 0.5, Math.random() * a - a * 0.5);
    return n.normalize(), n.scaleBy(o), n;
  }
};
var up = class extends _e {
  constructor() {
    super();
    __publicField(this, "camera");
    __publicField(this, "minDistance", 0.1);
    __publicField(this, "maxDistance", 500);
    __publicField(this, "rollSmooth", 15);
    __publicField(this, "dragSmooth", 20);
    __publicField(this, "wheelSmooth", 10);
    __publicField(this, "wheelStep", 2e-3);
    __publicField(this, "mouseRightFactor", 0.5);
    __publicField(this, "mouseLeftFactor", 20);
    __publicField(this, "smooth", true);
    __publicField(this, "_wheelStep", 2e-3);
    __publicField(this, "_distance", 0);
    __publicField(this, "distance", 10);
    __publicField(this, "_roll", 0);
    __publicField(this, "roll", 0);
    __publicField(this, "_pitch", 0);
    __publicField(this, "pitch", 0);
    __publicField(this, "_currentPos");
    __publicField(this, "_targetPos");
    __publicField(this, "_flowTarget");
    __publicField(this, "_flowOffset");
    __publicField(this, "_mouseLeftDown", false);
    __publicField(this, "_mouseRightDown", false);
    __publicField(this, "_bottomClamp", 89.99);
    __publicField(this, "_topClamp", -89.99);
    __publicField(this, "_tempDir", new d());
    __publicField(this, "_tempPos", new d());
    this._currentPos = new Y(), this._targetPos = new Y();
  }
  start() {
    this.camera = this.object3D.getOrAddComponent(Wr), p.inputSystem.addEventListener(U.POINTER_DOWN, this.onMouseDown, this), p.inputSystem.addEventListener(U.POINTER_MOVE, this.onMouseMove, this), p.inputSystem.addEventListener(U.POINTER_UP, this.onMouseUp, this), p.inputSystem.addEventListener(U.POINTER_WHEEL, this.onMouseWheel, this);
  }
  flowTarget(e, t = d.ZERO) {
    this._flowTarget = e, this._flowOffset || (this._flowOffset = new d()), this._flowOffset.copyFrom(t);
  }
  getFlowTarget() {
    return this._flowTarget;
  }
  setCamera(e, t, r, i) {
    this.roll = e, this.pitch = t, this.distance = r, this.maxDistance < r * 1.5 && (this.maxDistance = r * 1.5), i && this._targetPos.transform.localPosition.copy(i);
  }
  focusByBounds(e) {
    let t = pa.genMeshBounds(e);
    this.target = t.center;
  }
  set target(e) {
    this._targetPos.transform.localPosition.copy(e);
  }
  get target() {
    return this._targetPos.transform.localPosition;
  }
  onMouseWheel(e) {
    this.enable && (this._wheelStep = this.wheelStep * Pr.distance(this._currentPos.transform.worldPosition, this.camera.transform.worldPosition) / 10, this.distance -= p.inputSystem.wheelDelta * this._wheelStep, this.distance = W(this.distance, this.minDistance, this.maxDistance));
  }
  onMouseDown(e) {
    if (this.enable)
      switch (e.mouseCode) {
        case 0:
          this._mouseLeftDown = true;
          break;
        case 1:
          break;
        case 2:
          this._mouseRightDown = true;
          break;
      }
  }
  onMouseUp(e) {
    this._mouseLeftDown = false, this._mouseRightDown = false;
  }
  onMouseMove(e) {
    if (this.enable) {
      if (this._mouseRightDown) {
        let t = 0.25, r = this.camera.transform.forward;
        Pr.mulScale(r, e.movementY * t * this.camera.aspect, d.HELP_1), this._targetPos.x += d.HELP_1.x * this.mouseRightFactor, this._targetPos.z += d.HELP_1.z * this.mouseRightFactor;
        let i = this.camera.transform.right;
        Pr.mulScale(i, -e.movementX * t, d.HELP_1), this._targetPos.x -= d.HELP_1.x * this.mouseRightFactor, this._targetPos.z -= d.HELP_1.z * this.mouseRightFactor;
      }
      this._mouseLeftDown && (this.roll -= e.movementX * ce.delta * 1e-3 * this.mouseLeftFactor, this.pitch -= e.movementY * ce.delta * 1e-3 * this.mouseLeftFactor, this.pitch = W(this.pitch, this._topClamp, this._bottomClamp));
    }
  }
  onBeforeUpdate(e) {
    if (!this.enable)
      return;
    this._flowTarget && (d.HELP_0.copyFrom(this._flowTarget.transform.worldPosition), d.HELP_0.add(this._flowOffset, d.HELP_0), this.target = d.HELP_0);
    let t = W(ce.delta, 0, 0.016);
    this.smooth ? (this._currentPos.x += (this._targetPos.x - this._currentPos.x) * t * this.dragSmooth, this._currentPos.y += (this._targetPos.y - this._currentPos.y) * t * this.dragSmooth, this._currentPos.z += (this._targetPos.z - this._currentPos.z) * t * this.dragSmooth, this._distance += (this.distance - this._distance) * t * this.wheelSmooth, this._roll += (this.roll - this._roll) * t * this.rollSmooth, this._pitch += (this.pitch - this._pitch) * t * this.rollSmooth) : (this._currentPos.x = this._targetPos.x, this._currentPos.y = this._targetPos.y, this._currentPos.z = this._targetPos.z, this._distance = this.distance, this._roll = this.roll, this._pitch = this.pitch), this._tempDir.set(0, 0, 1);
    let r = H.HELP_0;
    r.fromEulerAngles(this._pitch, this._roll, 0), this._tempDir.applyQuaternion(r), this._tempPos = Pr.mulScale(this._tempDir, this._distance, this._tempPos), this._tempPos.add(this._currentPos.transform.localPosition, this._tempPos), this.transform.lookAt(this._tempPos, this._currentPos.transform.localPosition, d.UP), this.camera.lookTarget.copy(this._currentPos.transform.localPosition);
  }
  destroy(e) {
    p.inputSystem.removeEventListener(U.POINTER_DOWN, this.onMouseDown, this), p.inputSystem.removeEventListener(U.POINTER_MOVE, this.onMouseMove, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.onMouseUp, this), p.inputSystem.removeEventListener(U.POINTER_WHEEL, this.onMouseWheel, this), super.destroy(e), this.camera = null, this._flowTarget = null;
  }
};
var cp = class extends _e {
  constructor() {
    super();
    __publicField(this, "_camera");
    __publicField(this, "autoRotate", false);
    __publicField(this, "autoRotateSpeed", 0.1);
    __publicField(this, "rotateFactor", 0.5);
    __publicField(this, "zoomFactor", 0.1);
    __publicField(this, "panFactor", 0.25);
    __publicField(this, "_smooth", 5);
    __publicField(this, "_minDistance", 1);
    __publicField(this, "_maxDistance", 1e5);
    __publicField(this, "_maxPolarAngle", 90);
    __publicField(this, "_minPolarAngle", -90);
    __publicField(this, "_target", new d(0, 0, 0));
    __publicField(this, "_cTarget", new d(0, 0, 0));
    __publicField(this, "_position", new d(0, 0, 0));
    __publicField(this, "_cPosition", new d(0, 0, 0));
    __publicField(this, "_spherical", new fp());
    __publicField(this, "_isMouseDown", false);
    __publicField(this, "_lastMouseX", -1);
    __publicField(this, "_lastMouseY", -1);
    __publicField(this, "_isPanning", false);
  }
  get target() {
    return this._target;
  }
  set target(e) {
    this._target = e;
  }
  get smooth() {
    return this._smooth;
  }
  set smooth(e) {
    this._smooth = Math.max(e, 1);
  }
  get minDistance() {
    return this._minDistance;
  }
  set minDistance(e) {
    this._minDistance = W(e, 2e-6, this._maxDistance);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(e) {
    this._maxDistance = W(e, this._minDistance, 1 / 0);
  }
  get minPolarAngle() {
    return this._minPolarAngle;
  }
  set minPolarAngle(e) {
    this._minPolarAngle = W(e, -90, this._maxPolarAngle);
  }
  get maxPolarAngle() {
    return this._maxPolarAngle;
  }
  set maxPolarAngle(e) {
    this._maxPolarAngle = W(e, this._minPolarAngle, 90);
  }
  start() {
    this._camera = this.object3D.getComponent(Wr), this._position = this.object3D.transform.localPosition.clone(), this._cPosition = this._position.clone(), this._target = this._camera.lookTarget.clone(), this._cTarget = this._target.clone(), this._spherical.setCoords(this._position.x - this._target.x, this._position.y - this._target.y, this._position.z - this._target.z), this._camera.lookAt(this._cPosition, this._cTarget, d.UP), this.addEventListener();
  }
  onEnable() {
    this.addEventListener();
  }
  onDisable() {
    this.removeEventListener();
  }
  onUpdate() {
    let e = this._isPanning ? 1 : this.smooth, t = false;
    this._cPosition.equals(this.object3D.transform.localPosition) || (this._position.copyFrom(this.object3D.transform.localPosition), e = 1, t = true), this._cTarget.equals(this._target) || (this._cTarget.copyFrom(this._target), e = 1, t = true), t ? this._spherical.setCoords(this._position.x - this._target.x, this._position.y - this._target.y, this._position.z - this._target.z) : !this._isMouseDown && this.autoRotate && (this._spherical.theta -= this.autoRotateSpeed * Math.PI / 180, this.updateCamera());
    let r = (this._position.x - this._cPosition.x) / e, i = (this._position.y - this._cPosition.y) / e, a = (this._position.z - this._cPosition.z) / e;
    this._cPosition.x = Math.abs(r) > 1e-10 ? this._cPosition.x + r : this._position.x, this._cPosition.y = Math.abs(i) > 1e-10 ? this._cPosition.y + i : this._position.y, this._cPosition.z = Math.abs(a) > 1e-10 ? this._cPosition.z + a : this._position.z, this._camera.lookAt(this._cPosition, this._cTarget, d.UP);
  }
  onWheel(e) {
    e.deltaY = W(e.deltaY, -this._spherical.radius, this._spherical.radius), this._spherical.radius += e.deltaY * this.zoomFactor, this._spherical.radius = W(this._spherical.radius, this.minDistance, this.maxDistance), this.updateCamera();
  }
  onPointerDown(e) {
    this._isMouseDown = true, this._lastMouseX = e.mouseX, this._lastMouseY = e.mouseY, e.mouseCode === 2 && (this._isPanning = true);
  }
  onPointerMove(e) {
    if (!this._isMouseDown || !this.enable)
      return;
    let t = e.mouseX, r = e.mouseY;
    if (e.mouseCode === 0 && this._lastMouseX > 0 && this._lastMouseY > 0) {
      const i = -(t - this._lastMouseX) * this.rotateFactor, a = (r - this._lastMouseY) * this.rotateFactor;
      this._spherical.theta += i * Math.PI / 180, this._spherical.phi -= a * Math.PI / 180, this._spherical.phi = W(this._spherical.phi, this.minPolarAngle, this.maxPolarAngle), this.updateCamera();
    } else
      e.mouseCode === 2 && (Pr.mulScale(this.object3D.transform.up, e.movementY * this.panFactor * this._camera.aspect, d.HELP_1), this._target.y += d.HELP_1.y, Pr.mulScale(this.object3D.transform.right, -e.movementX * this.panFactor, d.HELP_1), this._target.x -= d.HELP_1.x, this._target.z -= d.HELP_1.z, this._cTarget.copyFrom(this._target), this.updateCamera());
    this._lastMouseX = t, this._lastMouseY = r;
  }
  onPointerUp(e) {
    this._isMouseDown = false, e.mouseCode === 2 && (this._isPanning = false);
  }
  onPointerLeave() {
    this._isMouseDown = false, this._isPanning = false;
  }
  updateCamera() {
    this._spherical.makeSafe();
    let e = this._spherical.getCoords();
    this._position.set(e.x + this._target.x, e.y + this._target.y, e.z + this._target.z);
  }
  addEventListener() {
    p.inputSystem.addEventListener(U.POINTER_WHEEL, this.onWheel, this), p.inputSystem.addEventListener(U.POINTER_DOWN, this.onPointerDown, this), p.inputSystem.addEventListener(U.POINTER_MOVE, this.onPointerMove, this), p.inputSystem.addEventListener(U.POINTER_UP, this.onPointerUp, this), p.inputSystem.addEventListener(U.POINTER_OUT, this.onPointerLeave, this);
  }
  removeEventListener() {
    p.inputSystem.removeEventListener(U.POINTER_WHEEL, this.onWheel, this), p.inputSystem.removeEventListener(U.POINTER_DOWN, this.onPointerDown, this), p.inputSystem.removeEventListener(U.POINTER_MOVE, this.onPointerMove, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.onPointerUp, this), p.inputSystem.removeEventListener(U.POINTER_OUT, this.onPointerLeave, this);
  }
};
var fp = class {
  constructor(e = 1, t = 0, r = 0) {
    __publicField(this, "radius");
    __publicField(this, "phi");
    __publicField(this, "theta");
    __publicField(this, "coords");
    return this.radius = e, this.phi = t, this.theta = r, this.coords = new d(), this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  makeSafe() {
    return this.phi = Math.max(2e-4, Math.min(Math.PI - 2e-4, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setCoords(e.x, e.y, e.z);
  }
  setCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(W(t / this.radius, -1, 1))), this;
  }
  getCoords() {
    const e = Math.sin(this.phi) * this.radius;
    return this.coords.x = e * Math.sin(this.theta), this.coords.y = Math.cos(this.phi) * this.radius, this.coords.z = e * Math.cos(this.theta), this.coords;
  }
};
var dp = class extends _e {
  constructor() {
    super();
    __publicField(this, "focus");
    __publicField(this, "_rotation", new d(45, 0, 0));
    __publicField(this, "distance", 5);
    __publicField(this, "_camera");
  }
  start() {
    if (this._camera = this.object3D.getOrAddComponent(Wr), !this._camera) {
      console.error("ThirdPersonCameraController need camera");
      return;
    }
    if (!this.focus) {
      console.error("ThirdPersonCameraController need target");
      return;
    }
    p.inputSystem.addEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.addEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.addEventListener(U.POINTER_DOWN, this.mouseDown, this);
  }
  mouseDown(e) {
    p.inputSystem.addEventListener(U.POINTER_MOVE, this.mouseMove, this);
  }
  mouseUp(e) {
    p.inputSystem.removeEventListener(U.POINTER_MOVE, this.mouseMove, this);
  }
  mouseMove(e) {
    this._rotation.y += e.movementX * 0.01, this._rotation.x += e.movementY * 0.01;
  }
  mouseWheel(e) {
    this.distance += p.inputSystem.wheelDelta * 0.1;
  }
  onUpdate() {
    let e = new d();
    this._camera.transform.forward.scaleToRef(this.distance, e);
    var t = this.focus.transform.worldPosition;
    this._camera.transform.localPosition = t.subtract(e);
  }
  destroy(e) {
    p.inputSystem.removeEventListener(U.POINTER_WHEEL, this.mouseWheel, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.mouseUp, this), p.inputSystem.removeEventListener(U.POINTER_DOWN, this.mouseDown, this), super.destroy(e);
  }
};
var Se = ((s) => (s[s.NORMAL = 0] = "NORMAL", s[s.DOWN = 1] = "DOWN", s[s.OVER = 2] = "OVER", s[s.DISABLE = 3] = "DISABLE", s))(Se || {});
var gp = Math.PI;
var lc = gp * 2;
var Or = class _Or {
  constructor(e = 1, t = 0, r = 0, i = 1, a = 0, o = 0) {
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    __publicField(this, "tx");
    __publicField(this, "ty");
    this.a = e, this.b = t, this.c = r, this.d = i, this.tx = a, this.ty = o;
  }
  clone() {
    return new _Or(this.a, this.b, this.c, this.d, this.tx, this.ty);
  }
  concat(e) {
    let t = this.a, r = this.c, i = this.tx;
    this.a = t * e.a + this.b * e.c, this.b = t * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d, this.tx = i * e.a + this.ty * e.c + e.tx, this.ty = i * e.b + this.ty * e.d + e.ty;
  }
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  identity() {
    return this.a = this.d = 1, this.b = this.c = this.tx = this.ty = 0, this;
  }
  invert() {
    this._invertInto(this);
  }
  rotate(e) {
    if (e = +e, e !== 0) {
      e = e * me;
      let t = Math.cos(e), r = Math.sin(e), i = this.a, a = this.b, o = this.c, n = this.d, l = this.tx, h = this.ty;
      this.a = i * t - a * r, this.b = i * r + a * t, this.c = o * t - n * r, this.d = o * r + n * t, this.tx = l * t - h * r, this.ty = l * r + h * t;
    }
  }
  scale(e, t) {
    e !== 1 && (this.a *= e, this.c *= e, this.tx *= e), t !== 1 && (this.b *= t, this.d *= t, this.ty *= t);
  }
  setTo(e, t, r, i, a, o) {
    return this.a = e, this.b = t, this.c = r, this.d = i, this.tx = a, this.ty = o, this;
  }
  transformPoint(e, t, r) {
    let i = this.a * e + this.c * t + this.tx, a = this.b * e + this.d * t + this.ty;
    return r ? (r.setTo(i, a, 0, 1), r) : new d(i, a, 0, 1);
  }
  setTranslate(e, t) {
    this.tx = e, this.ty = t;
  }
  translate(e, t) {
    this.tx += e, this.ty += t;
  }
  mul(e) {
    let t = this, r = e, i = t.a, a = t.b, o = t.c, n = t.d, l = t.tx, h = t.ty, u = r.a, c = r.b, f = r.c, g = r.d, m = r.tx, A = r.ty;
    c !== 0 || f !== 0 ? (this.a = i * u + a * f, this.b = i * c + a * g, this.c = o * u + n * f, this.d = o * c + n * g, this.tx = u * l + f * h + m, this.ty = c * l + g * h + A) : (this.a = i * u, this.b = a * g, this.c = o * u, this.d = n * g, this.tx = u * l + m, this.ty = g * h + A);
  }
  equals(e) {
    return this.a == e.a && this.b == e.b && this.c == e.c && this.d == e.d && this.tx == e.tx && this.ty == e.ty;
  }
  prepend(e, t, r, i, a, o) {
    let n = this.tx;
    if (e != 1 || t != 0 || r != 0 || i != 1) {
      let l = this.a, h = this.c;
      this.a = l * e + this.b * r, this.b = l * t + this.b * i, this.c = h * e + this.d * r, this.d = h * t + this.d * i;
    }
    return this.tx = n * e + this.ty * r + a, this.ty = n * t + this.ty * i + o, this;
  }
  append(e) {
    let t = this.a, r = this.b, i = this.c, a = this.d;
    return (e.a != 1 || e.b != 0 || e.c != 0 || e.d != 1) && (this.a = e.a * t + e.b * i, this.b = e.a * r + e.b * a, this.c = e.c * t + e.d * i, this.d = e.c * r + e.d * a), this.tx = e.tx * t + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * a + this.ty, this;
  }
  deltaTransformPoint(e) {
    let t = this, r = t.a * e.x + t.c * e.y, i = t.b * e.x + t.d * e.y;
    return new d(r, i);
  }
  toString() {
    return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
  }
  createBox(e, t, r = 0, i = 0, a = 0) {
    let o = this;
    if (r !== 0) {
      r = r * me;
      let n = Math.cos(r), l = Math.sin(r);
      o.a = n * e, o.b = l * t, o.c = -l * e, o.d = n * t;
    } else
      o.a = e, o.b = 0, o.c = 0, o.d = t;
    o.tx = i, o.ty = a;
  }
  createGradientBox(e, t, r = 0, i = 0, a = 0) {
    this.createBox(e / 1638.4, t / 1638.4, r, i + e / 2, a + t / 2);
  }
  _invertInto(e) {
    let t = this.a, r = this.b, i = this.c, a = this.d, o = this.tx, n = this.ty;
    if (r == 0 && i == 0) {
      e.b = e.c = 0, t == 0 || a == 0 ? e.a = e.d = e.tx = e.ty = 0 : (t = e.a = 1 / t, a = e.d = 1 / a, e.tx = -t * o, e.ty = -a * n);
      return;
    }
    let l = t * a - r * i;
    if (l == 0) {
      e.identity();
      return;
    }
    l = 1 / l;
    let h = e.a = a * l;
    r = e.b = -r * l, i = e.c = -i * l, a = e.d = t * l, e.tx = -(h * o + i * n), e.ty = -(r * o + a * n);
  }
  getScaleX() {
    let e = this;
    if (e.a == 1 && e.b == 0)
      return 1;
    let t = Math.sqrt(e.a * e.a + e.b * e.b);
    return this.getDeterminant() < 0 ? -t : t;
  }
  getScaleY() {
    let e = this;
    if (e.c == 0 && e.d == 1)
      return 1;
    let t = Math.sqrt(e.c * e.c + e.d * e.d);
    return this.getDeterminant() < 0 ? -t : t;
  }
  getSkewX() {
    return Math.atan2(this.d, this.c) - Math.PI / 2;
  }
  getSkewY() {
    return Math.atan2(this.b, this.a);
  }
  updateScaleAndRotation(e, t, r, i) {
    if ((r == 0 || r == lc) && (i == 0 || i == lc)) {
      this.a = e, this.b = this.c = 0, this.d = t;
      return;
    }
    r = r * me, i = i * me;
    let a = Math.cos(r), o = Math.sin(r);
    r == i ? (this.a = a * e, this.b = o * e) : (this.a = Math.cos(i) * e, this.b = Math.sin(i) * e), this.c = -o * t, this.d = a * t;
  }
  preMultiplyInto(e, t) {
    let r = e.a * this.a, i = 0, a = 0, o = e.d * this.d, n = e.tx * this.a + this.tx, l = e.ty * this.d + this.ty;
    (e.b !== 0 || e.c !== 0 || this.b !== 0 || this.c !== 0) && (r += e.b * this.c, o += e.c * this.b, i += e.a * this.b + e.b * this.d, a += e.c * this.a + e.d * this.c, n += e.ty * this.c, l += e.tx * this.b), t.a = r, t.b = i, t.c = a, t.d = o, t.tx = n, t.ty = l;
  }
  $transformBounds(e) {
    let t = this.a, r = this.b, i = this.c, a = this.d, o = this.tx, n = this.ty, l = e.x, h = e.y, u = l + e.width, c = h + e.height, f = t * l + i * h + o, g = r * l + a * h + n, m = t * u + i * h + o, A = r * u + a * h + n, _ = t * u + i * c + o, x = r * u + a * c + n, C = t * l + i * c + o, S = r * l + a * c + n, I = 0;
    f > m && (I = f, f = m, m = I), _ > C && (I = _, _ = C, C = I), e.x = Math.floor(f < _ ? f : _), e.width = Math.ceil((m > C ? m : C) - e.x), g > A && (I = g, g = A, A = I), x > S && (I = x, x = S, S = I), e.y = Math.floor(g < x ? g : x), e.height = Math.ceil((A > S ? A : S) - e.y);
  }
  getDeterminant() {
    return this.a * this.d - this.b * this.c;
  }
};
var Zi = class _Zi extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "isGUICanvas", true);
    __publicField(this, "index", 0);
  }
  addChild(e) {
    return this.object3D.addChild(e), this;
  }
  removeChild(e) {
    return this.object3D.removeChild(e), this;
  }
  cloneTo(e) {
    e.getOrAddComponent(_Zi).copyComponent(this);
  }
  copyComponent(e) {
    return e.index = e.index, this;
  }
};
var Ie = ((s) => (s[s.NONE = 0] = "NONE", s[s.POSITION = 1] = "POSITION", s[s.SPRITE = 2] = "SPRITE", s[s.COLOR = 4] = "COLOR", s[s.MAX = 7] = "MAX", s))(Ie || {});
var bo = class {
  constructor(e) {
    __publicField(this, "array");
    __publicField(this, "buffer");
    this.buffer = new $(e, 0), this.array = new Float32Array(this.buffer.memory.shareDataBuffer);
  }
};
var hc = class extends xe {
  constructor(e) {
    super();
    __publicField(this, "_attributeUV");
    __publicField(this, "_attributeVIndex");
    __publicField(this, "_faceIndexes");
    __publicField(this, "_uvSize", 2);
    __publicField(this, "_vIndexSize", 1);
    __publicField(this, "_posAttribute");
    __publicField(this, "_spriteAttribute");
    __publicField(this, "_colorAttribute");
    __publicField(this, "_onPositionChange", true);
    __publicField(this, "_onSpriteChange", true);
    __publicField(this, "_onColorChange", true);
    __publicField(this, "maxQuadCount");
    this.maxQuadCount = e;
  }
  updateSubGeometry(e, t, r) {
    let i = this.subGeometries[e];
    if (i) {
      let a = i.lodLevels[0];
      a.indexStart = t, a.indexCount = r, a.index = e;
    } else
      i = this.addSubGeometry({ indexStart: t, indexCount: r, vertexStart: 0, vertexCount: 0, firstStart: 0, index: e, topology: 0 });
    return i;
  }
  resetSubGeometries() {
    for (let e of this.subGeometries) {
      let t = e.lodLevels[0];
      t.indexStart = 0, t.indexCount = 0, t.index = 0;
    }
  }
  updateBounds(e, t) {
    let r = Number.MAX_VALUE * 0.1;
    return e = new d(-r, -r, -r), t = new d(r, r, r), this.bounds.setFromMinMax(e, t), this;
  }
  getPositionBuffer() {
    return this._onPositionChange && (this._posAttribute.buffer.apply(), this._onPositionChange = false), this._posAttribute.buffer;
  }
  getSpriteBuffer() {
    return this._onSpriteChange && (this._spriteAttribute.buffer.apply(), this._onSpriteChange = false), this._spriteAttribute.buffer;
  }
  getColorBuffer() {
    return this._onColorChange && (this._colorAttribute.buffer.apply(), this._onColorChange = false), this._colorAttribute.buffer;
  }
  create() {
    this.createBuffer(), this.updateBounds();
    let e = this.maxQuadCount, t = [], r = [];
    for (let a = 0; a < e; a++)
      t.push(...ai.attUV);
    for (let a = 0, o = this.maxQuadCount * ai.vertexCount; a < o; a++)
      r[a] = a;
    this._attributeUV = new Float32Array(ai.vertexCount * e * this._uvSize), this._attributeVIndex = new Float32Array(ai.vertexCount * e * this._vIndexSize), this._attributeUV.set(t, 0), this._attributeVIndex.set(r, 0);
    let i = [];
    for (let a = 0; a < e; a++)
      for (let o = 0; o < ai.indecies.length; o++) {
        const n = ai.indecies[o] + a * 4;
        i.push(n);
      }
    return this._faceIndexes = new Uint32Array(e * 6), this._faceIndexes.set(i, 0), this.setIndices(this._faceIndexes), this.setAttribute(D.uv, this._attributeUV), this.setAttribute(D.vIndex, this._attributeVIndex), this.updateSubGeometry(0, 0, this._faceIndexes.length), this;
  }
  createBuffer() {
    let e = this.maxQuadCount;
    this._posAttribute = new bo(e * 4), this._spriteAttribute = new bo(e * 12), this._colorAttribute = new bo(e * 4);
  }
  fillQuad(e, t) {
    e.dirtyAttributes & Ie.POSITION && this.fillQuadPosition(e, t), e.dirtyAttributes & Ie.COLOR && this.fillQuadColor(e, t), e.dirtyAttributes & Ie.SPRITE && this.fillQuadSprite(e, t);
  }
  fillQuadPosition(e, t) {
    uc.setXYZW(this._posAttribute.array, e.z, e.left, e.bottom, e.right, e.top), this._onPositionChange = true;
  }
  fillQuadColor(e, t) {
    let r = e.color, i = this._colorAttribute.array;
    uc.setXYZW(i, e.z, r.r, r.g, r.b, r.a), this._onColorChange = true;
  }
  fillQuadSprite(e, t) {
    let r = e.sprite, i = 0, a = 0;
    r.isSliced && e.imageType == ti.Sliced && (i = r.trimSize.x, i = (t.width - (r.offsetSize.z - r.trimSize.x)) / i, a = r.trimSize.y, a = (t.height - (r.offsetSize.w - r.trimSize.y)) / a);
    let o = r.guiTexture.dynamicId, n = r.uvRec, l = r.uvBorder, h = this._spriteAttribute.array, u = 12 * e.z;
    h[u + 0] = n.x, h[u + 1] = n.y, h[u + 2] = n.z, h[u + 3] = n.w, h[u + 4] = l.x, h[u + 5] = l.y, h[u + 6] = l.z, h[u + 7] = l.w, h[u + 8] = i, h[u + 9] = a, h[u + 10] = o, h[u + 11] = e.visible ? 1 : 0, this._onSpriteChange = true;
  }
};
var pp = class {
  static set(e, t, r, i, ...a) {
    let o = t * i + r;
    for (let n = 0, l = a.length; n < l; n++)
      e[o + n] = a[n];
  }
};
var uc = class extends pp {
  static setXYZW(e, t, r, i, a, o) {
    this.set(e, t, 0, 4, r, i, a, o);
  }
  static setXYZ(e, t, r, i, a) {
    this.set(e, t, 0, 4, r, i, a);
  }
  static setZ(e, t, r) {
    this.set(e, t, 3, 4, r);
  }
};
var ai = class {
};
__publicField(ai, "vertexCount", 4);
__publicField(ai, "attUV", [0, 0, 1, 0, 1, 1, 0, 1]);
__publicField(ai, "indecies", [0, 1, 2, 0, 2, 3]);
var cc = class {
  constructor() {
    __publicField(this, "_textureMap", /* @__PURE__ */ new Map());
    __publicField(this, "_textureList", []);
  }
  build(e, t, r) {
    let i = t._geometry;
    i.resetSubGeometries();
    let a = -1, o = 0, n = 0, l = 0, h = 0, u = this._textureList, c = this._textureMap;
    function f() {
      l > 0 && (t.updateDrawCallSegment(h, n, l), t._uiRenderer.materials[h].setTextures(u), c.clear(), u.length = 0, h++, n += l, l = 0, o = 0);
    }
    c.clear(), u.length = 0;
    let g = [], m = t.quadMaxCount - 1;
    for (let A of e) {
      let _ = A.needUpdateQuads;
      g.length = 0;
      const x = this.collectQuads(A.object3D, g);
      for (let C of x) {
        let S = C.sprite.guiTexture;
        if (c.has(S.staticId) || (o == 7 && f(), c.set(S.staticId, S), S.dynamicId = o, u[o] = S.texture, o += 1), C.z = ++a, l += 6, C.cacheTextureId != S.dynamicId && (C.dirtyAttributes = Ie.MAX, C.cacheTextureId = S.dynamicId), (_ || r) && (C.dirtyAttributes = Ie.MAX), C.dirtyAttributes & Ie.POSITION && C.applyTransform(A), C.dirtyAttributes && C.writeToGeometry(i, A), a == m)
          return f(), true;
      }
    }
    return f(), false;
  }
  collectQuads(e, t) {
    t || (t = []);
    let r = e.components.values();
    for (let i of r) {
      let a = i;
      if (a.isUIShadow || !a.mainQuads)
        continue;
      let o = a.getShadowRender();
      o && this.push(o.mainQuads, t), this.push(a.mainQuads, t);
    }
    return t;
  }
  push(e, t) {
    e && e.length > 0 && t.push(...e);
  }
};
var _Eo = class _Eo {
  static bindTextureArray() {
    let e = "";
    for (let t = 0; t < 7; t++)
      e += `
        @group(1) @binding(auto)
        var tex_${t}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${t}
        var tex_${t}: texture_external;
#else
        var tex_${t}: texture_2d<f32>;
#endif
`;
    return e;
  }
  static sampleTexture(e) {
    return `
#if VideoTexture${e}
            let size = textureDimensions(tex_${e}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${e}, iuv) ;
#else
            color = textureSampleLevel(tex_${e}, tex_${e}Sampler, uv, 0.0);
#endif        `;
  }
};
__publicField(_Eo, "fs", `
        ${Ds}
        ${_Eo.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${_Eo.sampleTexture(0)}
            }else if(texId == 1){
                ${_Eo.sampleTexture(1)}
            }else if(texId == 2){
                ${_Eo.sampleTexture(2)}
            }else if(texId == 3){            
                ${_Eo.sampleTexture(3)}
            }else if(texId == 4){            
                ${_Eo.sampleTexture(4)}
            }else if(texId == 5){            
                ${_Eo.sampleTexture(5)}
            }else if(texId == 6){            
                ${_Eo.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`);
__publicField(_Eo, "GUI_common_vs", `
        ${Ts}
        ${ua}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,
            v3:vec3<f32>
        }
        
        struct VertexOutput {
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(auto) uv: vec2<f32>,
            @location(auto) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `);
__publicField(_Eo, "GUI_shader_view", `
        ${_Eo.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${_Eo.fs}
        `);
__publicField(_Eo, "GUI_shader_world", `
        ${_Eo.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${_Eo.fs}

        `);
var Eo = _Eo;
var Bo = class extends je {
  constructor(e) {
    super();
    __publicField(this, "_scissorRect");
    __publicField(this, "_screenSize", new Q(1024, 768));
    __publicField(this, "_scissorEnable", false);
    __publicField(this, "_videoTextureFlags", {});
    O.register("GUI_shader_view", Eo.GUI_shader_view), O.register("GUI_shader_world", Eo.GUI_shader_world);
    let t = new Qe(), r = e == It.View ? "GUI_shader_view" : "GUI_shader_world", i = new ve(r, r);
    i.passType = q.COLOR, i.setShaderEntry("VertMain", "FragMain"), i.setUniformVector4("scissorRect", new G()), i.setUniformVector2("screenSize", this._screenSize), i.setUniformFloat("scissorCornerRadius", 0), i.setUniformFloat("scissorFadeOutSize", 0), i.setUniformFloat("pixelRatio", 1), i.setUniformVector3("v3", d.ZERO);
    let a = i.shaderState;
    a.depthWriteEnabled = false, i.blendMode = re.ALPHA, i.depthCompare = e == It.View ? kt.always : kt.less_equal, i.cullMode = nt.back, t.addRenderPass(i), this.shader = t;
  }
  setPanelRatio(e) {
    this.shader.setUniformFloat("pixelRatio", e);
  }
  setScissorRect(e, t, r, i) {
    this._scissorRect || (this._scissorRect = new G()), this._scissorRect.set(e, t, r, i), this.shader.setUniformVector4("scissorRect", this._scissorRect);
  }
  setScissorEnable(e) {
    this._scissorEnable != e && (this._scissorEnable = e, e ? this.shader.setDefine("SCISSOR_ENABLE", true) : this.shader.deleteDefine("SCISSOR_ENABLE"), this.shader.noticeValueChange());
  }
  setScissorCorner(e, t) {
    this.shader.setUniformFloat("scissorCornerRadius", e), this.shader.setUniformFloat("scissorFadeOutSize", t);
  }
  setScreenSize(e, t) {
    return this._screenSize.set(e, t), this.shader.setUniformVector2("screenSize", this._screenSize), this;
  }
  setTextures(e) {
    for (let t = 0; t < 7; t++) {
      let r = e[t] || p.res.whiteTexture;
      this.shader.setTexture(`tex_${t}`, r), this.setVideoTextureDefine(t, r.isVideoTexture);
    }
  }
  setVideoTextureDefine(e, t) {
    let r = false;
    t != this._videoTextureFlags[e] && (t ? this.shader.setDefine(`VideoTexture${e}`, true) : this.shader.deleteDefine(`VideoTexture${e}`), this._videoTextureFlags[e] = t, r = true), r && this.shader.noticeValueChange();
  }
  set envMap(e) {
  }
  set shadowMap(e) {
  }
  set baseMap(e) {
  }
  set normalMap(e) {
  }
  set emissiveMap(e) {
  }
  set irradianceMap(e) {
  }
  set irradianceDepthMap(e) {
  }
};
var fc = class extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "_guiGeometry");
  }
  init(e) {
    super.init(), this.addRendererMask(De.UI), this.removeRendererMask(De.Default), this.castGI = false, this.castShadow = false, this.alwaysRender = true, this._ignoreEnvMap = this._ignorePrefilterMap = true;
  }
  get geometry() {
    return super.geometry;
  }
  set geometry(e) {
    super.geometry = e, this._guiGeometry = e;
  }
  nodeUpdate(e, t, r, i) {
    for (let a = 0; a < this.materials.length; a++) {
      let n = this.materials[a].getPass(t), l = this._guiGeometry.getPositionBuffer(), h = this._guiGeometry.getSpriteBuffer(), u = this._guiGeometry.getColorBuffer();
      if (n)
        for (let c = 0; c < n.length; c++) {
          const f = n[c];
          f.pipeline || (f.setStorageBuffer("vPositionBuffer", l), f.setStorageBuffer("vSpriteBuffer", h), f.setStorageBuffer("vColorBuffer", u));
        }
    }
    super.nodeUpdate(e, t, r, i);
  }
  onUpdate(e) {
  }
};
var dc = class {
  constructor() {
    __publicField(this, "_use");
    __publicField(this, "_unUse");
    this._use = [], this._unUse = [];
  }
  pushBack(e) {
    let t = this._use.indexOf(e);
    t != -1 && (this._use.splice(t, 1), this._unUse.push(e));
  }
  getUseList() {
    return this._use;
  }
  getOne(e, t) {
    let r;
    return this._unUse.length > 0 ? (r = this._unUse[0], this._unUse.splice(0, 1), this._use.push(r), r) : (r = new e(t), this._use.push(r), r);
  }
  hasFree() {
    return this._unUse.length > 0;
  }
};
var Oi;
var _Wt = class _Wt {
  constructor() {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "width", 1);
    __publicField(this, "height", 1);
    __publicField(this, "_globalX", 0);
    __publicField(this, "_globalY", 0);
    __publicField(this, "_globalWidth", 0);
    __publicField(this, "_globalHeight", 0);
    __publicField(this, "_visible", true);
    __publicField(this, "_offsetX", 0);
    __publicField(this, "_offsetY", 0);
    __publicField(this, "_sprite", p.res.defaultGUISprite);
    __publicField(this, "_color", new M(1, 1, 1, 1));
    __publicField(this, "_imageType", ti.Simple);
    __publicField(this, "dirtyAttributes", Ie.MAX);
    __publicField(this, "cacheTextureId", -1);
  }
  static get quadPool() {
    return this.textPool || (this.textPool = new dc()), this.textPool;
  }
  static recycleQuad(e) {
    e.sprite = null, e.dirtyAttributes = Ie.MAX, e.x = 0, e.y = 0, e.z = -1, e.cacheTextureId = -1, _Wt.quadPool.pushBack(e);
  }
  static spawnQuad() {
    return _Wt.quadPool.getOne(_Wt);
  }
  get imageType() {
    return this._imageType;
  }
  set imageType(e) {
    this._imageType = e, this.setAttrChange(Ie.SPRITE | Ie.POSITION);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.copyFrom(e), this.setAttrChange(Ie.COLOR);
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    e != this._visible && (this._visible = e, this.setAttrChange(Ie.SPRITE));
  }
  get sprite() {
    return this._sprite;
  }
  set sprite(e) {
    this._sprite != e && (this._sprite = e, this.setAttrChange(Ie.SPRITE | Ie.POSITION));
  }
  get left() {
    return this._globalX - this._offsetX;
  }
  get right() {
    return this.left + this._globalWidth;
  }
  get top() {
    return this._globalY - this._offsetY;
  }
  get bottom() {
    return this.top + this._globalHeight;
  }
  setSize(e, t) {
    this.width = e, this.height = t, this.setAttrChange(Ie.POSITION);
  }
  setXY(e, t) {
    this.x = e, this.y = t, this.setAttrChange(Ie.POSITION);
  }
  setAttrChange(e) {
    this.dirtyAttributes = this.dirtyAttributes | e;
  }
  applyTransform(e) {
    this.setAttrChange(Ie.POSITION);
    let t = this._sprite, r = e.getWorldMatrix();
    (this.x != 0 || this.y != 0) && (r = this.getQuadMatrix(r));
    let i = r.getScaleX(), a = r.getScaleY(), o = t.isSliced && this._imageType == ti.Sliced;
    if (this._offsetX = e.width * 0.5 * i, this._offsetY = e.height * 0.5 * a, o)
      this._globalWidth = i * (e.width - (t.offsetSize.z - t.trimSize.x)), this._globalHeight = a * (e.height - (t.offsetSize.w - t.trimSize.y)), this._globalX = r.tx + t.offsetSize.x * i, this._globalY = r.ty + t.offsetSize.y * a;
    else {
      let n = this.width / t.offsetSize.z, l = this.height / t.offsetSize.w;
      this._globalWidth = i * t.trimSize.x * n, this._globalHeight = a * t.trimSize.y * l, this._globalX = r.tx + t.offsetSize.x * n * i, this._globalY = r.ty + t.offsetSize.y * l * a;
    }
    return this;
  }
  getQuadMatrix(e) {
    return Oi || (Oi = new Or()), Oi.identity(), Oi.setTranslate(this.x, this.y), Oi.mul(e), Oi;
  }
  writeToGeometry(e, t) {
    return e.fillQuad(this, t), this.dirtyAttributes = Ie.NONE, this;
  }
};
__publicField(_Wt, "textPool");
var Wt = _Wt;
var To = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "_uiTransform");
    __publicField(this, "_visible", true);
  }
  destroy() {
    this._uiTransform.setNeedUpdateUIPanel(), super.destroy();
  }
  get uiTransform() {
    return this._uiTransform;
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    var _a3;
    this._visible != e && (this._visible = e, (_a3 = this.onUIComponentVisible) == null ? void 0 : _a3.call(this, this._visible));
  }
  init(e) {
    var _a3;
    (_a3 = super.init) == null ? void 0 : _a3.call(this, e), this._uiTransform = this.object3D.getOrAddComponent(ur), this._uiTransform.setNeedUpdateUIPanel();
  }
  copyComponent(e) {
    return this.visible = e.visible, this;
  }
};
var Fi = class extends To {
  constructor() {
    super(...arguments);
    __publicField(this, "_mainQuads");
    __publicField(this, "_shadowRender");
    __publicField(this, "_shadowSource");
    __publicField(this, "isUIShadow");
    __publicField(this, "isShadowless");
    __publicField(this, "needUpdateShadow");
  }
  init(e) {
    var _a3;
    (_a3 = super.init) == null ? void 0 : _a3.call(this, e), this._mainQuads = [];
  }
  destroy() {
    var _a3, _b;
    this.detachQuads(), (_a3 = this._shadowRender) == null ? void 0 : _a3.setShadowSource(null), (_b = this._shadowSource) == null ? void 0 : _b.setShadowRenderer(null), super.destroy(), this._shadowRender = null, this._shadowSource = null;
  }
  start() {
    var _a3;
    (_a3 = super.start) == null ? void 0 : _a3.call(this), this.isUIShadow ? this.autoBindShadow(null, this) : this.isShadowless || this.autoBindShadow(this, null), this.setShadowDirty();
  }
  setShadowDirty() {
    this._shadowRender && (this._shadowRender.needUpdateShadow = true);
  }
  get mainQuads() {
    return this._mainQuads;
  }
  setShadowRenderer(e) {
    this._shadowRender = e;
  }
  setShadowSource(e) {
    this._shadowSource = e;
  }
  getShadowRender() {
    return this._shadowRender;
  }
  autoBindShadow(e, t) {
    let r = this.object3D.components.values();
    if (!e)
      for (let i of r) {
        let a = i;
        if (!(a.isShadowless || a.isUIShadow) && a.mainQuads) {
          e = a;
          break;
        }
      }
    if (!t)
      for (let i of r) {
        let a = i;
        if (a.isUIShadow && a.mainQuads) {
          t = a;
          break;
        }
      }
    return e && t ? (e.setShadowRenderer(t), t.setShadowSource(e), true) : false;
  }
  recycleQuad(e) {
    if (e && this._mainQuads) {
      let t = this._mainQuads.indexOf(e);
      t >= 0 ? (this._mainQuads.splice(t, 1), Wt.recycleQuad(e)) : e = null;
    }
    return e;
  }
  attachQuad(e) {
    return this._mainQuads && this._mainQuads.push(e), this;
  }
  detachQuads() {
    if (this._mainQuads)
      for (; this._mainQuads.length > 0; ) {
        let e = this._mainQuads.shift();
        this.recycleQuad(e);
      }
    return this;
  }
  copyComponent(e) {
    return super.copyComponent(e), this.isUIShadow = e.isUIShadow, this.isShadowless = e.isShadowless, this;
  }
};
var Fr = class _Fr extends Fi {
  init(e) {
    var _a3;
    (_a3 = super.init) == null ? void 0 : _a3.call(this, e), this.attachQuad(Wt.spawnQuad()), this.sprite = p.res.defaultGUISprite;
  }
  cloneTo(e) {
    e.getOrAddComponent(_Fr).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.sprite = e.sprite, this.color = e.color, this.imageType = e.imageType, this;
  }
  set sprite(e) {
    e || (e = p.res.defaultGUISprite);
    for (let t of this._mainQuads)
      t.sprite = e, t.setSize(this._uiTransform.width, this._uiTransform.height);
    this.setShadowDirty();
  }
  onTransformResize() {
    this.applyTransformSize();
  }
  applyTransformSize() {
    for (let e of this._mainQuads)
      e.setSize(this._uiTransform.width, this._uiTransform.height);
    this.setShadowDirty();
  }
  get sprite() {
    return this._mainQuads[0].sprite;
  }
  onUIComponentVisible(e) {
    this.applyComponentVisible();
  }
  onUITransformVisible(e) {
    this.applyComponentVisible();
  }
  applyComponentVisible() {
    let e = !this._visible || !this._uiTransform.globalVisible;
    for (let t of this._mainQuads)
      t.visible = !e;
    this.setShadowDirty();
  }
  get color() {
    return this._mainQuads[0].color;
  }
  set color(e) {
    for (let t of this._mainQuads)
      t.color = e;
    this.setShadowDirty();
  }
  get imageType() {
    return this._mainQuads[0].imageType;
  }
  set imageType(e) {
    for (let t of this._mainQuads)
      t.imageType = e;
    this.setShadowDirty();
  }
};
var $i = class _$i extends Fr {
  constructor() {
    super(...arguments);
    __publicField(this, "space", It.World);
    __publicField(this, "needUpdateGeometry", true);
    __publicField(this, "panelOrder", 0);
    __publicField(this, "needSortOnCameraZ");
    __publicField(this, "_billboard");
    __publicField(this, "_rebuild");
    __publicField(this, "scissorEnable", false);
    __publicField(this, "scissorCornerRadius", 0);
    __publicField(this, "scissorFadeOutSize", 0);
    __publicField(this, "_uiRenderer");
    __publicField(this, "_geometry");
    __publicField(this, "_maxCount", 128);
    __publicField(this, "panelRatio", 1);
    __publicField(this, "isUIPanel", true);
    __publicField(this, "_collectTransform", []);
  }
  cloneTo(e) {
    e.getOrAddComponent(_$i).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.panelOrder = e.panelOrder, this.needSortOnCameraZ = e.needSortOnCameraZ, this.cullMode = e.cullMode, this.billboard = e.billboard, this.scissorEnable = e.scissorEnable, this.scissorCornerRadius = e.scissorCornerRadius, this.scissorFadeOutSize = e.scissorFadeOutSize, this;
  }
  init(e) {
    super.init(e), this._uiTransform.resize(w.canvas.width, w.canvas.height), this.create(this.space), this.visible = false;
  }
  updateDrawCallSegment(e, t, r) {
    this._geometry.updateSubGeometry(e, t, r);
    let i = this._uiRenderer.material, a = this._uiRenderer.materials[e];
    if (!a) {
      a = new Bo(this.space);
      let o = this._uiRenderer.materials.slice();
      o.push(a), this._uiRenderer.materials = o, a.cullMode = i.cullMode, a.depthCompare = i.depthCompare;
    }
  }
  create(e) {
    this._maxCount = this.space == It.World ? Tr.quadMaxCountForWorld : Tr.quadMaxCountForView, this._uiRenderer = this.object3D.addComponent(fc), this._geometry = this._uiRenderer.geometry = new hc(this._maxCount).create(), this._uiRenderer.material = new Bo(e), this._uiRenderer.renderOrder = Tr.SortOrderStartWorld, this._rebuild = new cc(), this.object3D.bound = new ge(new d(), new d(1, 1, 1).multiplyScalar(Number.MAX_VALUE * 0.1));
  }
  get quadMaxCount() {
    return this._maxCount;
  }
  set billboard(e) {
    this.space == It.View ? e = Ar.None : console.warn("Cannot enable billboard in view space"), e == Ar.BillboardXYZ || e == Ar.BillboardY ? (this._billboard = this.object3D.getOrAddComponent(Ji), this._billboard.type = e) : (this.object3D.removeComponent(Ji), this._billboard = null);
  }
  get billboard() {
    return this._billboard ? this._billboard.type : Ar.None;
  }
  set cullMode(e) {
    if (this.space == It.World)
      for (let t of this._uiRenderer.materials)
        t.cullMode = e;
    else
      console.warn("Cannot change cullMode in view space");
  }
  get cullMode() {
    return this._uiRenderer.material.cullMode;
  }
  onUpdate(e) {
    var _a3;
    (_a3 = super.onUpdate) == null ? void 0 : _a3.call(this, e), this.rebuildGUIMesh(e);
  }
  rebuildGUIMesh(e) {
    let t = this, r = t._collectTransform;
    if (r.length = 0, t.object3D.getComponents(ur, r), r.length > 0) {
      t._rebuild.build(r, t, t.needUpdateGeometry);
      for (const n of r)
        n.needUpdateQuads = false;
    }
    let i = t.object3D.getComponentFromParent(Zi), a = i ? i.index : 0;
    t._uiRenderer.enable = r.length > 0;
    let o = t.isViewPanel ? Tr.SortOrderStartView : Tr.SortOrderStartWorld;
    if (t._uiRenderer.renderOrder = a * Tr.SortOrderCanvasSpan + o + t.panelOrder, t._uiRenderer.needSortOnCameraZ = t.needSortOnCameraZ, this.space == It.View) {
      let n = w.canvas.clientWidth, l = w.canvas.clientHeight, h = this._uiTransform.width, u = this._uiTransform.height;
      this.panelRatio = this.updateGUIPixelRatio(n, l, h, u);
    } else
      this.panelRatio = 1;
    for (let n of t._uiRenderer.materials) {
      let l = n;
      if (l.setPanelRatio(this.panelRatio), l.setScreenSize(w.canvas.clientWidth, w.canvas.clientHeight), l.setScissorEnable(t.scissorEnable), t.scissorEnable) {
        let h = t.mainQuads[0];
        l.setScissorRect(h.left, h.bottom, h.right, h.top), l.setScissorCorner(t.scissorCornerRadius, t.scissorFadeOutSize);
      }
    }
    t.needUpdateGeometry = false;
  }
  updateGUIPixelRatio(e, t, r, i) {
    let a = r / i, o = e / t, n = 1;
    return a < o ? n = t / i : n = e / r, n;
  }
};
var Ka = class _Ka extends $i {
  constructor() {
    super();
    __publicField(this, "isViewPanel", true);
    __publicField(this, "space", It.View);
  }
  cloneTo(e) {
    e.getOrAddComponent(_Ka).copyComponent(this);
  }
};
var Ja = class _Ja extends $i {
  constructor() {
    super();
    __publicField(this, "isWorldPanel", true);
    __publicField(this, "space", It.World);
    __publicField(this, "_depthTest", true);
  }
  cloneTo(e) {
    e.getOrAddComponent(_Ja).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.depthTest = e.depthTest, this;
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(e) {
    if (this._depthTest != e) {
      this._depthTest = e;
      let t = this.depthTest ? kt.less_equal : kt.always;
      for (let r of this._uiRenderer.materials)
        r.depthCompare = t;
    }
  }
};
var gc;
var ur = class _ur extends _e {
  constructor() {
    super();
    __publicField(this, "useParentPivot", false);
    __publicField(this, "parent");
    __publicField(this, "pivotX", 0.5);
    __publicField(this, "pivotY", 0.5);
    __publicField(this, "_width", 100);
    __publicField(this, "_height", 100);
    __publicField(this, "_localVisible", true);
    __publicField(this, "_globalVisible", true);
    __publicField(this, "_uiInteractiveList");
    __publicField(this, "_localMatrix");
    __publicField(this, "_worldMatrix");
    __publicField(this, "_onChange", true);
    __publicField(this, "needUpdateQuads", true);
    __publicField(this, "_tempTransforms", []);
    this._localMatrix = new Or(), this._worldMatrix = new Or();
  }
  get uiInteractiveList() {
    return this._uiInteractiveList;
  }
  init(e) {
    var _a3;
    super.init(e), this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type, this.onTransformChange, this), this.onParentChange(null, (_a3 = this.object3D.parent) == null ? void 0 : _a3.object3D);
  }
  onTransformChange(e) {
    this.onChange = true;
  }
  addUIInteractive(e) {
    return this._uiInteractiveList || (this._uiInteractiveList = []), this._uiInteractiveList.push(e), this;
  }
  removeUIInteractive(e) {
    if (this._uiInteractiveList) {
      let t = this._uiInteractiveList.indexOf(e);
      if (t >= 0)
        return this._uiInteractiveList.slice(t, 1), e;
    }
    return null;
  }
  get globalVisible() {
    return this._globalVisible;
  }
  set visible(e) {
    if (this._localVisible != e) {
      this._localVisible = e;
      let t = this.parent ? this.parent._globalVisible : true;
      this.onUITransformVisible(this._localVisible && t);
    }
  }
  get visible() {
    return this._localVisible;
  }
  onUITransformVisible(e) {
    let t = this._localVisible && e;
    t != this._globalVisible && (this._globalVisible = t, this.object3D.components.forEach((r, i) => {
      let a = r;
      if (a.onUITransformVisible)
        if (a == this)
          for (let o of this.object3D.entityChildren) {
            let n = o.getComponent(_ur);
            n && n.onUITransformVisible(this._globalVisible);
          }
        else
          a.onUITransformVisible(this._globalVisible);
    }));
  }
  onParentChange(e, t) {
    var _a3, _b;
    (_a3 = this.parent) == null ? void 0 : _a3.setNeedUpdateUIPanel(), this.parent = t == null ? void 0 : t.getComponent(_ur), (_b = this.parent) == null ? void 0 : _b.setNeedUpdateUIPanel();
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  resize(e, t) {
    var _a3;
    if (this._width != e || this._height != t) {
      this._width = e, this._height = t, this.onChange = true;
      for (let r of this.object3D.components.values())
        (_a3 = r.onTransformResize) == null ? void 0 : _a3.call(r);
      return true;
    }
    return false;
  }
  get x() {
    return this.object3D.x;
  }
  set x(e) {
    e != this.object3D.x && (this.object3D.x = e, this.onChange = true);
  }
  get y() {
    return this.object3D.y;
  }
  set y(e) {
    e != this.object3D.y && (this.object3D.y = e, this.onChange = true);
  }
  setXY(e, t) {
    let r = this.object3D.localPosition;
    r.set(e, t, r.z), this.object3D.localPosition = r, this.onChange = true;
  }
  get z() {
    return this.object3D.z;
  }
  set z(e) {
    e != this.object3D.z && (this.object3D.z = e, this.onChange = true);
  }
  get scaleX() {
    return this.object3D.scaleX;
  }
  set scaleX(e) {
    this.onChange = true, this.object3D.scaleX = e;
  }
  get scaleY() {
    return this.object3D.scaleY;
  }
  set scaleY(e) {
    this.onChange = true, this.object3D.scaleY = e;
  }
  get scaleZ() {
    return this.object3D.scaleZ;
  }
  set scaleZ(e) {
    this.onChange = true, this.object3D.scaleZ = e;
  }
  get onChange() {
    return this._onChange;
  }
  set onChange(e) {
    if (this._onChange != e && (this._onChange = e, e)) {
      this._tempTransforms.length = 0;
      let t = this.object3D.getComponents(_ur, this._tempTransforms, true);
      for (let r of t)
        r._onChange = true, r.needUpdateQuads = true;
    }
  }
  onEnable() {
    this.setNeedUpdateUIPanel(), this.onChange = true;
  }
  onDisable() {
    this.setNeedUpdateUIPanel(), this.onChange = true;
  }
  setNeedUpdateUIPanel() {
    let e;
    e = this.object3D.getComponentFromParent(Ja), e || (e = this.object3D.getComponentFromParent(Ka)), e && (e.needUpdateGeometry = true);
  }
  cloneTo(e) {
    let t = e.getOrAddComponent(_ur);
    t.visible = this.visible, t.x = this.x, t.y = this.y, t.z = this.z, t.resize(this.width, this.height), t.pivotX = this.pivotX, t.pivotY = this.pivotY, t.scaleX = this.scaleX, t.scaleY = this.scaleY;
  }
  matrix() {
    let e = this._localMatrix, t = this.object3D.rotationZ;
    return this.parent ? (e.updateScaleAndRotation(this.object3D.scaleX, this.object3D.scaleY, t, t), e.tx = this.object3D.x, e.ty = this.object3D.y) : e.updateScaleAndRotation(1, 1, 0, 0), (this.pivotX != 0.5 || this.pivotY != 0.5) && (gc || (gc = new Or().identity()), e.mul(gc.setTo(1, 0, 0, 1, -(this.pivotX - 0.5) * this.width, -(this.pivotY - 0.5) * this.height))), e;
  }
  getWorldMatrix() {
    let e = this, t = e._worldMatrix;
    return this._onChange && (t.copyFrom(e.matrix()), e.parent && t.mul(e.parent.getWorldMatrix()), e._onChange = false), t;
  }
  beforeDestroy(e) {
    var _a3;
    this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type, this.onTransformChange, this), (_a3 = super.beforeDestroy) == null ? void 0 : _a3.call(this, e);
  }
};
var pc = class {
  constructor() {
    __publicField(this, "_ray");
    __publicField(this, "_mouseCode");
    __publicField(this, "_clickEvent");
    __publicField(this, "_outEvent");
    __publicField(this, "_overEvent");
    __publicField(this, "_upEvent");
    __publicField(this, "_downEvent");
    __publicField(this, "_view");
    __publicField(this, "_lastDownTarget");
    __publicField(this, "_lastOverTarget");
    __publicField(this, "_lastDownPosition", new Q());
    __publicField(this, "_calcDistanceVec2", new Q());
    __publicField(this, "_lastDownTime", 0);
    __publicField(this, "_clickTimeSpan", 200);
    __publicField(this, "_clickDistanceSpan", 10);
    __publicField(this, "_colliderOut", []);
    __publicField(this, "_transformList", []);
    __publicField(this, "_sortWorldPanelList", []);
    __publicField(this, "_iteractive2PanelDict", /* @__PURE__ */ new Map());
  }
  init(e) {
    this._view = e, this._ray = new bt(), this._clickEvent = new U(U.PICK_CLICK_GUI), this._outEvent = new U(U.PICK_OUT_GUI), this._overEvent = new U(U.PICK_OVER_GUI), this._upEvent = new U(U.PICK_UP_GUI), this._downEvent = new U(U.PICK_DOWN_GUI), p.inputSystem.addEventListener(U.POINTER_DOWN, this.onTouchDown, this, null, 1), p.inputSystem.addEventListener(U.POINTER_UP, this.onTouchUp, this, null, 1), p.inputSystem.addEventListener(U.POINTER_MOVE, this.onTouchMove, this, null, 1), p.inputSystem.addEventListener(U.POINTER_CLICK, this.onTouchClick, this, null, 1);
  }
  onTouchClick(e) {
    this._lastOverTarget && e.stopImmediatePropagation();
  }
  onTouchMove(e) {
    this._mouseCode = e.mouseCode, this.collectEntities();
    let t = this.pick(this._colliderOut);
    t && e.stopImmediatePropagation();
    let r = t ? t.collider : null;
    r != this._lastOverTarget && (this._lastOverTarget && this._lastOverTarget.enable && (this._lastOverTarget.mouseStyle = Se.NORMAL, this._outEvent.data = this._lastOverTarget, this._lastOverTarget.object3D.dispatchEvent(this._outEvent)), r && (r.mouseStyle = Se.OVER, this._overEvent.data = r, r.object3D.dispatchEvent(this._overEvent)), this._lastOverTarget = r);
  }
  onTouchDown(e) {
    this._lastDownTime = ce.time, this._lastDownPosition.set(e.mouseX, e.mouseY), this._mouseCode = e.mouseCode, this.collectEntities();
    let t = this.pick(this._colliderOut);
    t && e.stopImmediatePropagation();
    let r = t ? t.collider : null;
    r && (r.mouseStyle = Se.DOWN, this._overEvent.data = r, r.object3D.dispatchEvent(this._overEvent)), this._lastDownTarget = r;
  }
  onTouchUp(e) {
    this._calcDistanceVec2.set(e.mouseX, e.mouseY), this._mouseCode = e.mouseCode, this.collectEntities();
    let t = this.pick(this._colliderOut);
    t && e.stopImmediatePropagation();
    let r = t ? t.collider : null;
    this._lastDownTarget && this._lastDownTarget.enable && (this._lastDownTarget.mouseStyle = Se.NORMAL), r && r == this._lastDownTarget && ce.time - this._lastDownTime <= this._clickTimeSpan && (this._calcDistanceVec2.set(e.mouseX, e.mouseY), this._calcDistanceVec2.distance(this._lastDownPosition) <= this._clickDistanceSpan && (this._clickEvent.data = { pick: r, pickInfo: t, mouseCode: this._mouseCode }, r.object3D.dispatchEvent(this._clickEvent))), this._lastDownTarget = null;
  }
  collectEntities() {
    return this._colliderOut.length = 0, this._sortWorldPanelList.length = 0, this._iteractive2PanelDict.clear(), this._view.canvasList.slice().reverse().forEach((t) => {
      if (t && t.transform && t.transform.parent) {
        let r = t.object3D.getComponentsByProperty("isUIPanel", true, true);
        r.sort((i, a) => {
          let o = i._uiRenderer.__renderOrder, n = a._uiRenderer.__renderOrder;
          return o > n ? -1 : 1;
        });
        for (let i of r) {
          this._transformList.length = 0, i.object3D.getComponents(ur, this._transformList), this._transformList.reverse();
          for (const a of this._transformList) {
            let o = a.uiInteractiveList;
            if (o && o.length > 0)
              for (let n of o)
                this._colliderOut.push(n), this._iteractive2PanelDict.set(n, i);
          }
        }
      }
    }), this._colliderOut;
  }
  pick(e) {
    this._ray = this._view.camera.screenPointToRay(p.inputSystem.mouseX, p.inputSystem.mouseY);
    let t = new Q(p.inputSystem.mouseX, p.inputSystem.mouseY), r = new Q(w.canvas.clientWidth, w.canvas.clientHeight), i;
    for (const a of e)
      if (a.interactive && a.enable && a.interactiveVisible) {
        let o = this._iteractive2PanelDict.get(a);
        if (i = a.rayPick(this._ray, o, t, r), i)
          return i.collider = a, i;
      }
    return null;
  }
};
var mc = ((s) => (s[s.COLLINEAR = 0] = "COLLINEAR", s[s.LINES_INTERSECT = 1] = "LINES_INTERSECT", s[s.SEGMENTS_INTERSECT = 2] = "SEGMENTS_INTERSECT", s[s.A_BISECTS_B = 3] = "A_BISECTS_B", s[s.B_BISECTS_A = 4] = "B_BISECTS_A", s[s.PARALELL = 5] = "PARALELL", s))(mc || {});
var Ac = ((s) => (s[s.ON_LINE = 0] = "ON_LINE", s[s.LEFT_SIDE = 1] = "LEFT_SIDE", s[s.RIGHT_SIDE = 2] = "RIGHT_SIDE", s))(Ac || {});
var _Ve = class _Ve {
  constructor(e, t) {
    __publicField(this, "start");
    __publicField(this, "end");
    __publicField(this, "color", new M(1, 1, 1, 1));
    __publicField(this, "_normal");
    __publicField(this, "_normalCalculated", false);
    this.start = e, this.end = t;
  }
  set(e, t) {
    this.start = e, this.end = t;
  }
  getCenter() {
    let e = d.HELP_0;
    return this.start.subtract(this.end, e), e.scaleBy(0.5), e.add(this.end), e;
  }
  inverse() {
    let e = this.start;
    this.start = this.end, this.end = e;
  }
  equals(e) {
    return this.start == e.start && this.end == e.end || this.start == e.end && this.end == e.start;
  }
  toArray() {
    return [this.start.x, this.start.y, this.start.z, this.end.x, this.end.y, this.end.z];
  }
  static getLines(e) {
    let t = [];
    for (let r = 0; r < e.length; r++) {
      let i = r, a = zs(r + 1, e.length), o = e[i], n = e[a];
      t.push(new _Ve(o, n));
    }
    return t;
  }
  intersection(e, t = null) {
    var r = (e.end.z - e.start.z) * (this.end.x - this.start.x) - (e.end.x - e.start.x) * (this.end.z - this.start.z), i = (e.end.x - e.start.x) * (this.start.z - e.start.z) - (e.end.z - e.start.z) * (this.start.x - e.start.x), a = (e.start.x - this.start.x) * (this.end.z - this.start.z) - (e.start.z - this.start.z) * (this.end.x - this.start.x);
    if (r == 0)
      return i == 0 && a == 0 ? 0 : 5;
    i = i / r, a = a / r;
    var o = this.start.x + i * (this.end.x - this.start.x), n = this.start.z + i * (this.end.z - this.start.z);
    return t != null && (t.x = o, t.y = 0, t.z = n), i >= 0 && i <= 1 && a >= 0 && a <= 1 ? 2 : a >= 0 && a <= 1 ? 3 : i >= 0 && i <= 1 ? 4 : 1;
  }
  getDirection() {
    var e = this.end.subtract(this.start), t = new d(e.x, e.y);
    return t.normalize();
  }
  copyFrom(e) {
    this.start || (this.start = new d()), this.end || (this.end = new d()), this.start.copyFrom(e.start), this.end.copyFrom(e.end);
  }
  static IsEqual(e, t) {
    return Math.abs(e - t) < 1e-7;
  }
  static squreDistanceSegmentToSegment(e, t, r) {
    let i = e.start, a = e.end, o = t.start, n = t.end, l = i.x, h = i.y, u = i.z, c = a.x, f = a.y, g = a.z, m = o.x, A = o.y, _ = o.z, x = n.x, C = n.y, S = n.z, I = c - l, T = f - h, b = g - u, B = x - m, R = C - A, E = S - _, F = l - m, k = h - A, V = u - _, j = I * I + T * T + b * b, te = I * B + T * R + b * E, pe = B * B + R * R + E * E, ne = I * F + T * k + b * V, we = B * F + R * k + E * V, Oe = j * pe - te * te, se = Oe, Be = Oe, le = 0, Te = 0;
    this.IsEqual(Oe, 0) ? (le = 0, se = 1, Te = we, Be = pe) : (le = te * we - pe * ne, Te = j * we - te * ne, le < 0 ? (le = 0, Te = we, Be = pe) : le > se && (le = se, Te = we + te, Be = pe)), Te < 0 ? (Te = 0, -ne < 0 ? le = 0 : -ne > j ? le = se : (le = -ne, se = j)) : Te > Be && (Te = Be, -ne + te < 0 ? le = 0 : -ne + te > j ? le = se : (le = -ne + te, se = j));
    let st = 0, ot = 0;
    this.IsEqual(le, 0) ? st = 0 : st = le / se, this.IsEqual(Te, 0) ? ot = 0 : ot = Te / Be;
    let At = F + st * I - ot * B, vt = k + st * T - ot * R, xt = V + st * b - ot * E;
    return At * At + vt * vt + xt * xt;
  }
  isNear(e, t = 0, r) {
    let i = d.HELP_0, a = d.HELP_1;
    i.copyFrom(e.origin), a.copyFrom(e.direction), a.scaleBy(9999), a.add(i, a), _Ve.cacluteLine0.set(i, a), _Ve.cacluteLine1.copyFrom(this), r && (r.perspectiveMultiplyPoint3(_Ve.cacluteLine1.start, _Ve.cacluteLine1.start), r.perspectiveMultiplyPoint3(_Ve.cacluteLine1.end, _Ve.cacluteLine1.end));
    let o = _Ve.squreDistanceSegmentToSegment(_Ve.cacluteLine0, _Ve.cacluteLine1, r);
    return o + 1e-4 <= t ? (e.length = o, true) : (e.length = -999999, false);
  }
};
__publicField(_Ve, "cacluteLine0", new _Ve(null, null));
__publicField(_Ve, "cacluteLine1", new _Ve(null, null));
var Ve = _Ve;
var _ea = class _ea {
  constructor(e, t, r) {
    __publicField(this, "v1");
    __publicField(this, "v2");
    __publicField(this, "v3");
    __publicField(this, "u1");
    __publicField(this, "u2");
    __publicField(this, "u3");
    __publicField(this, "n1");
    __publicField(this, "n2");
    __publicField(this, "n3");
    __publicField(this, "t0");
    __publicField(this, "t");
    __publicField(this, "u");
    __publicField(this, "v");
    __publicField(this, "min", new d());
    __publicField(this, "max", new d());
    __publicField(this, "id", 0);
    this.id = _ea.ID++ + 200, e && t && r && this.set(e, t, r);
  }
  set(e, t, r) {
    this.v1 = e, this.v2 = t, this.v3 = r;
    let i = this.min, a = this.max;
    return i.x = Math.min(this.v1.x, this.v2.x, this.v3.x), i.y = Math.min(this.v1.y, this.v2.y, this.v3.y), i.z = Math.min(this.v1.z, this.v2.z, this.v3.z), a.x = Math.max(this.v1.x, this.v2.x, this.v3.x), a.y = Math.max(this.v1.y, this.v2.y, this.v3.y), a.z = Math.max(this.v1.z, this.v2.z, this.v3.z), this;
  }
  getNormal() {
    let e = this.v1, t = this.v2, r = this.v3, i = new d(t.x - e.x, t.y - e.y, t.z - e.z), o = new d(r.x - e.x, r.y - e.y, r.z - e.z).crossProduct(i);
    return o.normalize(), o;
  }
  turnBack() {
    let e = this.v3;
    this.v3 = this.v1, this.v1 = e;
  }
  getLines() {
    let e = this.v1, t = this.v2, r = this.v3;
    return [new Ve(e, t), new Ve(t, r), new Ve(r, e)];
  }
  equals(e) {
    let t = this.getLines(), r = e.getLines(), i = 0;
    for (let a = 0; a < t.length; a++)
      for (let o = 0; o < r.length; o++)
        t[a].equals(r[o]) && i++;
    return i == 3;
  }
  getCenter() {
    let e = this.min, t = this.max, r = new d();
    return r.x = (e.x + t.x) * 0.5, r.y = (e.y + t.y) * 0.5, r.z = (e.z + t.z) * 0.5, r;
  }
  intersects(e) {
    var t = this.max, r = this.min, i = e.max, a = e.min;
    return r.x <= i.x && t.x >= a.x && r.y <= i.y && t.y >= a.y && r.z <= i.z && t.z >= a.z;
  }
  sign2D(e, t, r) {
    return (e.x - r.x) * (t.z - r.z) - (t.x - r.x) * (e.z - r.z);
  }
  pointInTriangle2D(e) {
    let t = this.v1, r = this.v2, i = this.v3, a, o, n, l, h;
    return a = this.sign2D(e, t, r), o = this.sign2D(e, r, i), n = this.sign2D(e, i, t), l = a < 0 || o < 0 || n < 0, h = a > 0 || o > 0 || n > 0, !(l && h);
  }
  toArray() {
    return [this.v1.x, this.v1.y, this.v1.z, this.v2.x, this.v2.y, this.v2.z, this.v3.x, this.v3.y, this.v3.z];
  }
};
__publicField(_ea, "ID", -1);
var ea = _ea;
var vc = class {
  static init() {
    this._pt0 = new d(), this._pt1 = new d(), this._pt2 = new d(), this._pt3 = new d(), this._ray = new bt(), this._triangle = new ea(), this._hitPoint = new d(), this._worldMatrix = new P();
  }
  static rayPick(e, t, r, i, a, o, n) {
    this._isInit || (this.init(), this._isInit = true);
    let l = this._worldMatrix;
    if (i == It.World) {
      let h;
      this.calculateHotArea_World(o, this._pt0, this._pt1, this._pt2, this._pt3), l.copyFrom(n).invert();
      let u = this._ray;
      if (u.copy(e).applyMatrix(l), this._triangle.set(this._pt0, this._pt1, this._pt2), h = u.intersectTriangle(u.origin, u.direction, this._triangle), h || (this._triangle.set(this._pt1, this._pt2, this._pt3), h = u.intersectTriangle(u.origin, u.direction, this._triangle)), h)
        return { distance: 0, intersectPoint: h };
    } else {
      this.calculateHotArea_View(o, a, this._pt0, this._pt1, this._pt2, this._pt3);
      let h = r.x, u = r.y, c = Math.min(this._pt0.x, this._pt1.x, this._pt2.x, this._pt3.x) + h * 0.5, f = Math.min(this._pt0.y, this._pt1.y, this._pt2.y, this._pt3.y) + u * 0.5, g = Math.max(this._pt0.x, this._pt1.x, this._pt2.x, this._pt3.x) + h * 0.5, m = Math.max(this._pt0.y, this._pt1.y, this._pt2.y, this._pt3.y) + u * 0.5;
      return t.x <= g && t.x >= c && t.y <= m && t.y >= f ? (this._hitPoint.set(t.x, t.y, 0), { distance: 0, intersectPoint: this._hitPoint }) : null;
    }
    return null;
  }
  static calculateHotArea_View(e, t, r, i, a, o) {
    let n = e.getWorldMatrix(), l = n.getScaleX(), h = n.getScaleY(), u = e.width * 0.5 * l, c = e.height * 0.5 * h;
    r.set(-u, -c, 0), i.set(u, -c, 0), a.set(-u, c, 0), o.set(u, c, 0);
    let f = n.tx;
    r.x += f, i.x += f, a.x += f, o.x += f, f = n.ty, r.y -= f, i.y -= f, a.y -= f, o.y -= f, r.multiplyScalar(t), i.multiplyScalar(t), a.multiplyScalar(t), o.multiplyScalar(t);
  }
  static calculateHotArea_World(e, t, r, i, a) {
    let o = e.getWorldMatrix(), n = o.getScaleX(), l = o.getScaleY(), h = e.width * 0.5 * n, u = e.height * 0.5 * l;
    t.set(-h, u, 0), r.set(h, u, 0), i.set(-h, -u, 0), a.set(h, -u, 0);
    let c = o.tx;
    t.x += c, r.x += c, i.x += c, a.x += c, c = o.ty, t.y += c, r.y += c, i.y += c, a.y += c;
  }
};
__publicField(vc, "_pt0");
__publicField(vc, "_pt1");
__publicField(vc, "_pt2");
__publicField(vc, "_pt3");
__publicField(vc, "_hitPoint");
__publicField(vc, "_worldMatrix");
__publicField(vc, "_ray");
__publicField(vc, "_triangle");
__publicField(vc, "_isInit");
var xc = ((s) => (s[s.UpperLeft = 0] = "UpperLeft", s[s.UpperCenter = 1] = "UpperCenter", s[s.UpperRight = 2] = "UpperRight", s[s.MiddleLeft = 3] = "MiddleLeft", s[s.MiddleCenter = 4] = "MiddleCenter", s[s.MiddleRight = 5] = "MiddleRight", s[s.LowerLeft = 6] = "LowerLeft", s[s.LowerCenter = 7] = "LowerCenter", s[s.LowerRight = 8] = "LowerRight", s))(xc || {});
var _c = ((s) => (s[s.Upper = 0] = "Upper", s[s.Middle = 1] = "Middle", s[s.Lower = 2] = "Lower", s))(_c || {});
var Cc = ((s) => (s[s.Left = 0] = "Left", s[s.Center = 1] = "Center", s[s.Right = 2] = "Right", s))(Cc || {});
var Sc = class {
  constructor() {
    __publicField(this, "charList", []);
    __publicField(this, "quadList", []);
    __publicField(this, "width", 0);
    __publicField(this, "index", 0);
  }
};
var yc = class {
  layout(e) {
    let t = [], r = e.originSize, i = ei.getFontData(e.font, r), a = e.fontSize / r;
    return this.makeTextLine(e.uiTransform, e.alignment, t, e.font, i, e.text, a, r, e.lineSpacing), t;
  }
  makeTextLine(e, t, r, i, a, o, n, l, h) {
    let u = -1, c = 0, f = l * n, g = f * 0.5, m = e.width / n, A = e.height / n, _ = 0, x = e.height, C = () => {
      c = 0, u++;
      let b = new Sc();
      return b.index = u, r.push(b), b;
    }, S = (b, B) => {
      const R = b.charCodeAt(0).toString();
      let E = ei.getFnt(i, l, R), F = null;
      return E ? (F = Wt.spawnQuad(), F.sprite = E, F.x = (c + E.xoffset) * n - _, F.y = (a.base - E.height - E.yoffset - a.base) * n + x, F.width = E.offsetSize.width * n, F.height = E.offsetSize.height * n, c += E.xadvance) : b == `
` || (b == "	" ? c += f : c += g), B.width = c, B.quadList.push(F), B.charList.push(b), F;
    }, I = () => {
      let b = this.getAlignment(t);
      switch (b.v) {
        case 0:
          for (let B = 0, R = r.length; B < R; B++) {
            let E = r[B];
            if (B > 0) {
              let F = B * f * h;
              for (let k = 0, V = E.quadList.length; k < V; k++) {
                let j = E.quadList[k];
                j && (j.y -= F);
              }
            }
          }
          break;
        case 1:
          for (let B = 0, R = r.length; B < R; B++) {
            let E = r[B], F = (A - R * l * h) * 0.5 * n + B * f * h;
            for (let k = 0, V = E.quadList.length; k < V; k++) {
              let j = E.quadList[k];
              j && (j.y -= F);
            }
          }
          break;
        case 2:
          for (let B = 0, R = r.length; B < R; B++) {
            let E = r[B], F = (A - R * l * h) * n + B * f * h;
            for (let k = 0, V = E.quadList.length; k < V; k++) {
              let j = E.quadList[k];
              j && (j.y -= F);
            }
          }
          break;
      }
      switch (b.h) {
        case 0:
          break;
        case 1:
          for (let B = 0, R = r.length; B < R; B++) {
            let E = r[B], F = (m - E.width) * 0.5 * n;
            for (let k = 0, V = E.quadList.length; k < V; k++) {
              let j = E.quadList[k];
              j && (j.x += F);
            }
          }
          break;
        case 2:
          for (let B = 0, R = r.length; B < R; B++) {
            let E = r[B], F = (m - E.width) * n;
            for (let k = 0, V = E.quadList.length; k < V; k++) {
              let j = E.quadList[k];
              j && (j.x += F);
            }
          }
          break;
      }
    };
    (() => {
      let b = null, B = o.length;
      for (let R = 0; R < B; R++) {
        b || (b = C());
        let E = o.charAt(R);
        E == `
` || E == "	" ? b = null : (S(E, b), b.width + g >= m && (b = C()));
      }
    })(), I();
  }
  getAlignment(e) {
    let t = { v: 0, h: 0 };
    switch (e) {
      case 1:
        t.v = 0, t.h = 1;
        break;
      case 0:
        t.v = 0, t.h = 0;
        break;
      case 2:
        t.v = 0, t.h = 2;
        break;
      case 4:
        t.v = 1, t.h = 1;
        break;
      case 3:
        t.v = 1, t.h = 0;
        break;
      case 5:
        t.v = 1, t.h = 2;
        break;
      case 7:
        t.v = 2, t.h = 1;
        break;
      case 6:
        t.v = 2, t.h = 0;
        break;
      case 8:
        t.v = 2, t.h = 2;
        break;
    }
    return t;
  }
};
var Za = class _Za extends To {
  constructor() {
    super(...arguments);
    __publicField(this, "_style", Se.NORMAL);
    __publicField(this, "_interactive", false);
  }
  set interactive(e) {
    this._interactive = e;
  }
  get interactive() {
    return this._interactive;
  }
  set mouseStyle(e) {
    this._style = e;
  }
  get interactiveVisible() {
    return this._uiTransform.globalVisible && this._visible;
  }
  init(e) {
    super.init(e), this._uiTransform.addUIInteractive(this);
  }
  destroy() {
    this._uiTransform.removeUIInteractive(this), super.destroy();
  }
  rayPick(e, t, r, i) {
    return vc.rayPick(e, r, i, t.space, t.panelRatio, this._uiTransform, t.transform.worldMatrix);
  }
  cloneTo(e) {
    e.getOrAddComponent(_Za).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.enable = e._enable, this.interactive = e._interactive, this.mouseStyle = e._style, this;
  }
};
var wc = ((s) => (s[s.NONE = 0] = "NONE", s[s.COLOR = 1] = "COLOR", s[s.SPRITE = 2] = "SPRITE", s))(wc || {});
var ko = class _ko extends Za {
  constructor() {
    super(...arguments);
    __publicField(this, "_spriteMap");
    __publicField(this, "_colorMap");
    __publicField(this, "_image");
    __publicField(this, "_isCreateImage");
    __publicField(this, "_transition", 2);
  }
  init(e) {
    super.init(e), this._interactive = true, this._spriteMap = /* @__PURE__ */ new Map(), this._colorMap = /* @__PURE__ */ new Map(), this._image = this.object3D.getComponent(Fr), this._isCreateImage = this._image == null, this._image || (this._image = this.object3D.addComponent(Fr)), this.imageType = ti.Sliced;
  }
  onEnable() {
    this.mouseStyle = Se.NORMAL;
  }
  onDisable() {
    this.mouseStyle = Se.DISABLE;
  }
  set transition(e) {
    this._transition != e && (this._transition = e, this.validateStyle(this._style, true));
  }
  get transition() {
    return this._transition;
  }
  get imageType() {
    return this._image.imageType;
  }
  set imageType(e) {
    this._image.imageType = e;
  }
  setStyleColor(e, t) {
    return this._colorMap.set(e, t), this._style == e && this.validateStyle(this._style, true), this;
  }
  getStyleColor(e) {
    return this._colorMap.get(e);
  }
  set mouseStyle(e) {
    super.mouseStyle = e, this.validateStyle(e, true);
  }
  get normalSprite() {
    return this._spriteMap.get(Se.NORMAL);
  }
  set normalSprite(e) {
    this._spriteMap.set(Se.NORMAL, e), this._style == Se.NORMAL && this.validateStyle(this._style, true);
  }
  get overSprite() {
    return this._spriteMap.get(Se.OVER);
  }
  set overSprite(e) {
    this._spriteMap.set(Se.OVER, e), this._style == Se.OVER && this.validateStyle(this._style, true);
  }
  set downSprite(e) {
    this._spriteMap.set(Se.DOWN, e), this._style == Se.DOWN && this.validateStyle(this._style, true);
  }
  get downSprite() {
    return this._spriteMap.get(Se.DOWN);
  }
  set disableSprite(e) {
    this._spriteMap.set(Se.DISABLE, e), this._style == Se.DISABLE && this.validateStyle(this._style, true);
  }
  get disableSprite() {
    return this._spriteMap.get(Se.DISABLE);
  }
  validateStyle(e, t) {
    if (this._transition & 2) {
      let r = this._spriteMap.get(e);
      this._image.sprite = r;
    }
    if (this._transition & 1) {
      let r = this._colorMap.get(e);
      r && (this._image.color = r);
    }
  }
  cloneTo(e) {
    e.getOrAddComponent(_ko).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this.imageType = e.imageType, this.transition = e.transition, e._spriteMap.forEach((t, r) => {
      t && this._spriteMap.set(r, t);
    }), e._colorMap.forEach((t, r) => {
      t && this._colorMap.set(r, t.clone());
    }), this.mouseStyle = e.mouseStyle, this;
  }
  destroy() {
    this._isCreateImage && this._image && (this.object3D.removeComponent(Fr), this._image = null), super.destroy();
  }
};
var Go = class _Go extends Fi {
  constructor() {
    super();
    __publicField(this, "_count", 0);
  }
  init(e) {
    var _a3;
    (_a3 = super.init) == null ? void 0 : _a3.call(this, e), this._count = e ? e.count : 1;
    for (let t = 0; t < this._count; t++)
      this.attachQuad(Wt.spawnQuad());
    this._uiTransform.resize(0, 0);
  }
  getQuad(e) {
    return this._mainQuads[e];
  }
  cloneTo(e) {
    e.addComponent(_Go, { count: this._count }).copyComponent(this);
  }
  copyComponent(e) {
    super.copyComponent(e);
    for (let t = 0; t < e._count; t++)
      this.setSprite(t, e.getSprite(t)), this.setColor(t, e.getColor(t)), this.setImageType(t, e.getImageType(t));
    return this;
  }
  setSprite(e, t) {
    this._mainQuads[e].sprite = t || p.res.defaultGUISprite, this.setShadowDirty();
  }
  getSprite(e) {
    return this._mainQuads[e].sprite;
  }
  onUIComponentVisible(e) {
    this.applyComponentVisible();
  }
  onUITransformVisible(e) {
    this.applyComponentVisible();
  }
  applyComponentVisible() {
    let e = !this._visible || !this._uiTransform.globalVisible;
    for (let t of this._mainQuads)
      t.visible = !e;
    this.setShadowDirty();
  }
  getColor(e) {
    return this._mainQuads[e].color;
  }
  setColor(e, t) {
    this._mainQuads[e].color = t, this.setShadowDirty();
  }
  getImageType(e) {
    return this._mainQuads[e].imageType;
  }
  setImageType(e, t) {
    this._mainQuads[e].imageType = t, this.setShadowDirty();
  }
  setSize(e, t, r) {
    this._mainQuads[e].setSize(t, r), this.setShadowDirty();
  }
  setXY(e, t, r) {
    this._mainQuads[e].setXY(t, r), this.setShadowDirty();
  }
  getXY(e, t) {
    t || (t = new Q());
    let r = this._mainQuads[e];
    return t.x = r.x, t.y = r.y, t;
  }
};
var Qo = class _Qo extends Fi {
  constructor() {
    super(...arguments);
    __publicField(this, "_shadowQuality", 1);
    __publicField(this, "_shadowOffset");
    __publicField(this, "_shadowRadius");
    __publicField(this, "_shadowColor");
    __publicField(this, "_subShadowColor");
    __publicField(this, "needUpdateShadow", false);
  }
  init(e) {
    var _a3;
    (_a3 = super.init) == null ? void 0 : _a3.call(this, e), this._shadowRadius = 2, this._shadowQuality = 1, this._shadowOffset = new Q(4, -4), this._shadowColor = new M(0.1, 0.1, 0.1, 0.8), this._subShadowColor = this._shadowColor.clone(), this.isUIShadow = true;
  }
  cloneTo(e) {
    e.getOrAddComponent(_Qo).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(this), this._shadowColor = e._shadowColor, this._shadowOffset = e._shadowOffset, this._shadowRadius = e._shadowRadius, this._shadowQuality = e.shadowQuality, this;
  }
  get shadowColor() {
    return this._shadowColor;
  }
  set shadowColor(e) {
    this._shadowColor.copyFrom(e), this.needUpdateShadow = true;
  }
  set shadowQuality(e) {
    e = W(e, 0, 4), this._shadowQuality != e && (this._shadowQuality = e, this.needUpdateShadow = true);
  }
  get shadowQuality() {
    return this._shadowQuality;
  }
  set shadowOffset(e) {
    this._shadowOffset = e, this.needUpdateShadow = true;
  }
  get shadowOffset() {
    return this._shadowOffset || (this._shadowOffset = new Q(4, -4)), this._shadowOffset;
  }
  set shadowRadius(e) {
    this._shadowRadius != e && (this._shadowRadius = e, this.applyShadow());
  }
  get shadowRadius() {
    return this._shadowRadius;
  }
  onUpdate(e) {
    this.needUpdateShadow && (this.applyShadow(), this.needUpdateShadow = false);
  }
  applyShadow() {
    if (this.detachQuads(), this._shadowSource && this._shadowQuality > 0) {
      let e = this._shadowSource.mainQuads;
      if (e.length > 0)
        for (let t of e)
          this.createQuadShadow(t);
    }
    this._uiTransform.setNeedUpdateUIPanel();
  }
  createQuadShadow(e) {
    let t = this._shadowQuality, r = Math.PI * 2;
    this._subShadowColor.copyFrom(this._shadowColor), this._subShadowColor.a = 1 / Math.max(1, t);
    for (let i = 0; i < t; i++) {
      let a = Wt.spawnQuad(), o = 0, n = 0;
      if (i == 0)
        a.color = this._shadowColor;
      else {
        let l = r * (i - 1) / (t - 1);
        o = Math.sin(l) * this._shadowRadius, n = Math.cos(l) * this._shadowRadius, a.color = this._subShadowColor;
      }
      a.setXY(o + this._shadowOffset.x + e.x, n + this._shadowOffset.y + e.y), a.setSize(e.width, e.height), a.sprite = e.sprite, a.visible = e.visible, a.imageType = e.imageType, this.attachQuad(a);
    }
  }
};
var Vo = class _Vo extends Fi {
  constructor() {
    super();
    __publicField(this, "_font", "");
    __publicField(this, "_fontSize", 14);
    __publicField(this, "_originSize", 42);
    __publicField(this, "_alignment", 0);
    __publicField(this, "_lineSpacing", 1);
    __publicField(this, "_text", "");
    __publicField(this, "_color", new M(1, 1, 1, 1));
    __publicField(this, "textLine", null);
    __publicField(this, "layoutProxy", new yc());
  }
  cloneTo(e) {
    e.getOrAddComponent(_Vo).copyComponent(this);
  }
  copyComponent(e) {
    return super.copyComponent(e), this._font = e._font, this._fontSize = e._fontSize, this._originSize = e._originSize, this._alignment = e._alignment, this._lineSpacing = e._lineSpacing, this._color.copyFrom(e._color), this.text = e.text, this;
  }
  get originSize() {
    return this._originSize;
  }
  get font() {
    return this._font;
  }
  set font(e) {
    this._font = e;
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(e) {
    this._fontSize != e && (this._fontSize = e, this.layoutText());
  }
  get text() {
    return this._text;
  }
  set text(e) {
    this._text != e && (e || (e = ""), this._text = e, this.layoutText());
  }
  layoutText() {
    this.detachQuads(), this.textLine = this.layoutProxy.layout(this);
    for (let e = 0, t = this.textLine.length; e < t; e++) {
      let r = this.textLine[e];
      for (let i = 0, a = r.quadList.length; i < a; i++) {
        let o = r.quadList[i];
        o && this.attachQuad(o);
      }
    }
    this.color = this._color, this._uiTransform.setNeedUpdateUIPanel(), this.onUIComponentVisible(this._visible), this.setShadowDirty();
  }
  onUIComponentVisible(e) {
    this.applyComponentVisible();
  }
  onUITransformVisible(e) {
    this.applyComponentVisible();
  }
  applyComponentVisible() {
    let e = !this._visible || !this._uiTransform.globalVisible;
    for (let t of this._mainQuads)
      t && (t.visible = !e);
    this.setShadowDirty();
  }
  onTransformResize() {
    this.layoutText();
  }
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.copyFrom(e);
    for (let t of this._mainQuads)
      t.color = e;
    this.setShadowDirty();
  }
  get alignment() {
    return this._alignment;
  }
  set alignment(e) {
    this._alignment != e && (this._alignment = e, this.layoutText());
  }
  get lineSpacing() {
    return this._lineSpacing;
  }
  set lineSpacing(e) {
    this._lineSpacing != e && (this._lineSpacing = e, this.layoutText());
  }
};
var mp = Object.defineProperty;
var Ap = Object.getOwnPropertyDescriptor;
var vp = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Ap(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && mp(e, t, i), i;
};
var Ma = class extends Ei {
  constructor() {
    super();
  }
  init() {
    super.init(), this.lightData.lightType = Pe.PointLight, this.object3D.name == "" && (this.object3D.name = "PointLight" + gt());
  }
  get range() {
    return this.lightData.range;
  }
  set range(s) {
    this.lightData.range = s, this.onChange();
  }
  get at() {
    return this.lightData.linear;
  }
  set at(s) {
    this.lightData.linear = s, this.onChange();
  }
  get radius() {
    return this.lightData.radius;
  }
  set radius(s) {
    this.lightData.radius = s, this.onChange();
  }
  get quadratic() {
    return this.lightData.quadratic;
  }
  set quadratic(s) {
    this.lightData.quadratic = s, this.onChange();
  }
  start() {
    this.transform.rotationX = 90, super.start();
  }
  onUpdate() {
  }
  onGraphic(s) {
    let e = s.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`, this.transform);
    e.buildAxis(), e.buildCircle(d.ZERO, this.range, 32, d.X_AXIS), e.buildCircle(d.ZERO, this.range, 32, d.Y_AXIS), e.buildCircle(d.ZERO, this.range, 32, d.Z_AXIS);
  }
  debug() {
  }
  debugDraw(s) {
  }
};
Ma = vp([_t(Ma, "Light")], Ma);
var Ic = class extends Y {
  constructor() {
    super();
    __publicField(this, "index", 0);
    __publicField(this, "drawCallFrame", -1);
  }
};
var Do = ((s) => (s[s.CastGI = 0] = "CastGI", s[s.ReceiveGI = 1] = "ReceiveGI", s[s.CastDepth = 2] = "CastDepth", s[s.Other = 3] = "Other", s))(Do || {});
var bc = class extends je {
  constructor(e = 0, t = 0) {
    super(), O.register("GIProbeShader", Yu);
    let r = new Qe(), i = new ve("GIProbeShader", "GIProbeShader");
    i.passType = q.COLOR, r.addRenderPass(i), i.setDefine("USE_BRDF", true), i.setShaderEntry("VertMain", "FragMain"), i.setUniformVector4("probeUniform", new G(t, e, 0, 0));
    let a = i.shaderState;
    a.acceptShadow = false, a.castShadow = false, a.receiveEnv = false, a.acceptGI = false, a.useLight = false, r.setTexture("baseMap", p.res.whiteTexture), r.setTexture("normalMap", p.res.normalTexture), r.setTexture("emissiveMap", p.res.blackTexture), this.shader = r;
  }
};
__publicField(bc, "count", 0);
var xp = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "_probes");
    __publicField(this, "_volume");
    __publicField(this, "_debugMr", []);
  }
  init() {
    p.setting.gi.enable = true;
  }
  start() {
    this._volume = oe.getLightEntries(this.transform.scene3D).irradianceVolume, this.initProbe();
  }
  initProbe() {
    let e = this._volume.setting.probeXCount, t = this._volume.setting.probeYCount, r = this._volume.setting.probeZCount, i = new Mi(4, 16, 16), a = new d();
    this._probes = [];
    for (let o = 0; o < e; o++)
      for (let n = 0; n < t; n++)
        for (let l = 0; l < r; l++) {
          let h = o + l * e + n * (e * r), u = new Ic();
          u.index = h, u.name = `${o}_${n}_${l}`;
          let c = u.addComponent(J);
          c.material = new bc(Do.CastGI, h), c.geometry = i, c.castGI = false, c.castShadow = false, this._debugMr.push(c), this.object3D.addChild(u), this._volume.calcPosition(o, n, l, a), u.x = a.x, u.y = a.y, u.z = a.z, this._probes[h] = u, this._debugMr.push(c);
        }
    for (let o = 0; o < this._probes.length; o++)
      z.instance.addGIProbe(this.transform.scene3D, this._probes[o]);
    this.object3D.transform.enable = false, this._volume.setting.debug && this.debug();
  }
  debug() {
  }
  debugProbeRay(e, t) {
    const r = p.setting.gi.rayNumber;
    let i = new H(0, -0.7071067811865475, 0.7071067811865475, 0);
    for (let a = 0; a < r; a++) {
      let o = e * r + a, n = new d(-t[o * 4 + 0], -t[o * 4 + 1], -t[o * 4 + 2], 0);
      i.transformVector(n, n);
      let l = t[o * 4 + 3], h = this._probes[e].transform.worldPosition.clone(), u = n.scaleBy(l);
      u.add(h, u);
    }
  }
  changeProbesVolumeData() {
    this._volume.setVolumeDataChange();
  }
  changeProbesPosition() {
    this._volume.setVolumeDataChange();
    let e = this._volume.setting.probeXCount, t = this._volume.setting.probeYCount, r = this._volume.setting.probeZCount, i = new d();
    for (let a = 0; a < e; a++)
      for (let o = 0; o < t; o++)
        for (let n = 0; n < r; n++) {
          let l = a + n * e + o * (e * r), h = this._probes[l];
          this._volume.calcPosition(a, o, n, i), h.x = i.x, h.y = i.y, h.z = i.z;
        }
  }
  onUpdate() {
    p.setting.gi.maxDistance = p.setting.gi.probeSpace * 1.5;
    let e = this.transform.scene3D.view.camera, t = d.distance(e.transform.worldPosition, e.transform.targetPos) / 300;
    if (this._debugMr && this._debugMr.length > 0)
      for (let r = 0; r < this._debugMr.length; r++) {
        const i = this._debugMr[r].transform;
        i.scaleX = t, i.scaleY = t, i.scaleZ = t;
      }
  }
};
var _p = class extends tr {
  constructor() {
    super(...arguments);
    __publicField(this, "_keyRenderGroup");
    __publicField(this, "_keyBufferGroup");
    __publicField(this, "_keyIdsGroup");
  }
  init(e) {
    this._keyRenderGroup = /* @__PURE__ */ new Map(), this._keyBufferGroup = /* @__PURE__ */ new Map(), this._keyIdsGroup = /* @__PURE__ */ new Map();
  }
  start() {
    let e = [];
    this.object3D.getComponents(J, e, true);
    for (let t = 0; t < e.length; t++) {
      const r = e[t];
      r.transform.updateWorldMatrix(true), r.enable = false;
      let i = r.geometry.instanceID;
      for (let a = 0; a < r.materials.length; a++) {
        const o = r.materials[a];
        i += o.instanceID;
      }
      if (this._keyRenderGroup.has(i))
        this._keyRenderGroup.get(i).push(r), this._keyIdsGroup.get(i).push(r.transform.worldMatrix.index);
      else {
        let a = new $(e.length);
        a.visibility = GPUShaderStage.VERTEX, this._keyRenderGroup.set(i, [r]), this._keyBufferGroup.set(i, a), this._keyIdsGroup.set(i, [r.transform.worldMatrix.index]);
      }
    }
    this._keyBufferGroup.forEach((t, r) => {
      let i = this._keyIdsGroup.get(r), a = this._keyBufferGroup.get(r);
      a.setInt32Array("matrixIDs", new Int32Array(i)), a.apply();
    });
  }
  stop() {
  }
  nodeUpdate(e, t, r, i) {
    this._keyRenderGroup.forEach((a, o) => {
      let n = this._keyBufferGroup.get(o), l = a[0];
      for (let h = 0; h < l.materials.length; h++) {
        let c = l.materials[h].getPass(t);
        if (c)
          for (let f = 0; f < c.length; f++) {
            const g = c[f];
            g.setDefine("USE_INSTANCEDRAW", true), g.setStorageBuffer("instanceDrawID", n);
          }
      }
      l.nodeUpdate(e, t, r, i);
    }), this.preInit = false;
  }
  renderPass(e, t, r) {
    this._keyRenderGroup.forEach((i, a) => {
      let o = i[0];
      o.instanceCount = i.length, this.renderItem(e, t, o, r);
    });
  }
  renderItem(e, t, r, i) {
    let a = r.transform._worldMatrix;
    for (let o = 0; o < r.materials.length; o++) {
      let l = r.materials[o].getPass(t);
      if (!(!l || l.length == 0))
        for (let h = 0; h < l.length; h++) {
          if (!l || l.length == 0)
            continue;
          let u = l[h];
          y.bindGeometryBuffer(i.encoder, r.geometry);
          const c = u;
          c.shaderState.splitTexture && (i.endRenderPass(), be.WriteSplitColorTexture(r.instanceID), i.beginOpaqueRenderPass(), y.bindCamera(i.encoder, e.camera), y.bindGeometryBuffer(i.encoder, r.geometry)), y.bindPipeline(i.encoder, c);
          let A = r.geometry.subGeometries[o].lodLevels[r.lodLevel];
          r.instanceCount > 0 ? y.drawIndexed(i.encoder, A.indexCount, r.instanceCount, A.indexStart, 0, 0) : y.drawIndexed(i.encoder, A.indexCount, 1, A.indexStart, 0, a.index);
        }
    }
  }
};
var Cp = Object.defineProperty;
var Sp = Object.getOwnPropertyDescriptor;
var yp = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Sp(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Cp(e, t, i), i;
};
var Ra = class extends J {
  constructor() {
    super();
  }
  get geometry() {
    return null;
  }
  set geometry(s) {
  }
  cloneTo(s) {
  }
  set meshURL(s) {
    let e = p.res.getGeometry(s);
    e ? this.geometry = e : console.error("no geometry set", s);
  }
};
Ra = yp([_t(Ra, "MeshFilter")], Ra);
var wp = class extends Le {
  constructor() {
    super();
    __publicField(this, "radius", 2.5);
    __publicField(this, "height", 10);
    this._shapeType = ri.Capsule;
  }
};
var _$a = class _$a extends Le {
  constructor() {
    super();
    __publicField(this, "mesh");
    __publicField(this, "_pickRet");
    this._shapeType = ri.Mesh;
  }
  rayPick(e, t) {
    if (this.mesh) {
      _$a.triangle || (_$a.triangle = new ea(new d(), new d(), new d()));
      let r = this.mesh.getAttribute("position"), i = this.mesh.getAttribute("indices"), a = Le.helpMatrix;
      a.copyFrom(t).invert();
      let o = Le.helpRay.copy(e);
      if (o.applyMatrix(a), o.intersectBox(this.mesh.bounds), !o.intersectBox(this.mesh.bounds, Le.v3_help_0))
        return null;
      if (i && r && i.data.length > 0) {
        let l = r.data;
        for (let h = 0, u = i.data.length / 3; h < u; h++) {
          let c = h * 3;
          const f = i.data[c + 0] * 3, g = i.data[c + 1] * 3, m = i.data[c + 2] * 3;
          let A = _$a.triangle, _ = A.v1.set(l[f + 0], l[f + 1], l[f + 2]), x = A.v2.set(l[g + 0], l[g + 1], l[g + 2]), C = A.v3.set(l[m + 0], l[m + 1], l[m + 2]);
          A.set(_, x, C);
          let S = o.intersectTriangle(o.origin, o.direction, A);
          if (S)
            return this._pickRet || (this._pickRet = { intersectPoint: new d(), distance: 0 }), this._pickRet.intersectPoint = S, this._pickRet.distance = d.distance(o.origin, S), this._pickRet;
        }
      }
    }
    return null;
  }
};
__publicField(_$a, "triangle");
var $a = _$a;
var es = class _es {
  constructor(e, t) {
    __publicField(this, "center", new d());
    __publicField(this, "extents");
    __publicField(this, "max");
    __publicField(this, "min");
    __publicField(this, "size");
    __publicField(this, "tmpVecA", new d());
    __publicField(this, "tmpVecB", new d());
    __publicField(this, "tmpVecC", new d());
    __publicField(this, "tmpVecD", new d());
    __publicField(this, "radius", 0);
    __publicField(this, "diffBetweenPoints", new d());
    __publicField(this, "owner");
    __publicField(this, "forward", new d(0, 0, 1));
    __publicField(this, "worldCenter");
    __publicField(this, "worldSize");
    __publicField(this, "_center", new d());
    this.center = e || new d(0, 0, 0), this.radius = t === void 0 ? 0.5 : t;
  }
  updateBound() {
    throw new Error("Method not implemented.");
  }
  containsPoint(e) {
    var t = this.tmpVecA.subtract(e, this.center).lengthSquared, r = this.radius;
    return t < r * r;
  }
  intersectsRay(e, t) {
    var r = this.tmpVecA.copyFrom(e.origin).subtract(this.center), i = r.dotProduct(this.tmpVecB.copyFrom(e.direction).normalize()), a = r.dotProduct(r) - this.radius * this.radius;
    if (a > 0 && i > 0)
      return null;
    var o = i * i - a;
    if (o < 0)
      return false;
    var n = Math.abs(-i - Math.sqrt(o));
    return t && t.copyFrom(e.direction).scaleBy(n).add(e.origin), true;
  }
  intersectsBoundingSphere(e) {
    this.tmpVecA.subtract(e.center, this.center);
    var t = e.radius + this.radius;
    return this.tmpVecA.lengthSquared <= t * t;
  }
  calculateTransform(e) {
    this.update(e);
  }
  inFrustum(e, t) {
    return t.containsSphere(e);
  }
  clone() {
    return new _es(this.center.clone(), this.radius);
  }
  update(e) {
    this.owner = e, this._center.add(e.transform.worldMatrix.position, this.center), this.forward = e.transform.forward;
  }
  merge(e) {
    throw new Error("BoundingSphere merge is not ready!");
  }
  setFromCenterAndSize(e, t) {
    this.center.copy(e), this.radius = t;
  }
};
var Ip = class extends Le {
  constructor(e) {
    super();
    __publicField(this, "_pickRet");
    __publicField(this, "box");
    __publicField(this, "radius", 0.5);
    this._shapeType = ri.Sphere, this.radius = e, this.box = new es(new d(), 1);
  }
  rayPick(e, t) {
    this.box.setFromCenterAndSize(this.center, this.radius);
    let i = Le.helpMatrix;
    i.copyFrom(t).invert();
    let a = Le.helpRay.copy(e);
    a.applyMatrix(i);
    let o = a.intersectSphere(a.origin, a.direction, this.box.center, this.box.radius);
    return o ? (this._pickRet || (this._pickRet = { intersect: false, intersectPoint: new d(), distance: 0 }), this._pickRet.intersect = true, this._pickRet.intersectPoint = o, this._pickRet.distance = d.distance(a.origin, Le.v3_help_0), this._pickRet) : null;
  }
};
var bp = class extends Y {
  constructor() {
    super();
    __publicField(this, "_envMap");
    __publicField(this, "skyObject");
    __publicField(this, "envMapChange", true);
    __publicField(this, "view");
    this.transform.scene3D = this, this.skyObject = new Y(), this.addChild(this.skyObject), this._isScene3D = true, this.envMap || (this.envMap = p.res.defaultSky);
  }
  get envMap() {
    return this._envMap;
  }
  set envMap(e) {
    this._envMap != e && (this.envMapChange = true), this._envMap = e, z.instance.sky && "map" in z.instance.sky && (z.instance.sky.map = e);
  }
  get exposure() {
    return z.instance.sky && "exposure" in z.instance.sky ? z.instance.sky.exposure : 0;
  }
  set exposure(e) {
    z.instance.sky && "exposure" in z.instance.sky && (z.instance.sky.exposure = e, p.setting.sky.skyExposure = e);
  }
  get roughness() {
    if (z.instance.sky && "roughness" in z.instance.sky)
      return z.instance.sky.roughness;
  }
  set roughness(e) {
    z.instance.sky && "roughness" in z.instance.sky && (z.instance.sky.roughness = e);
  }
};
var Ec = class extends ma {
  constructor() {
    super(3, Ai.triangle_list);
  }
};
var Bc = class extends ma {
  constructor() {
    super(2, Ai.line_list);
  }
};
var Tc = class extends Y {
  constructor() {
    super();
    __publicField(this, "mLineRender");
    __publicField(this, "mFillRender");
    this.mLineRender = this.addComponent(Bc), this.mFillRender = this.addComponent(Ec);
  }
  drawAxis(e, t = new d(0, 0, 0), r = 10) {
    this.createCustomShape(e).buildAxis(t, r);
  }
  drawLines(e, t, r = M.COLOR_WHITE) {
    this.createCustomShape(e).buildLines(t, r);
  }
  drawCurve(e, t, r = 10, i = 0.5, a = M.COLOR_WHITE) {
    var o = [];
    let n = new d(), l = new d();
    for (let h = 0; h < t.length - 1; ++h) {
      o.push(t[h]);
      const u = t[Math.max(h - 1, 0)], c = t[h], f = t[h + 1], g = t[Math.min(h + 2, t.length - 1)];
      f.subtract(u, n).multiplyScalar(i / 3).add(c, n), c.subtract(g, l).multiplyScalar(i / 3).add(f, l), o.push(...this.calculateBezierCurve(c, n, l, f, r));
    }
    o.push(t[t.length - 1]), this.drawLines(e, o, a);
  }
  calculateBezierCurve(e, t, r, i, a) {
    var o = new Array(a);
    for (let n = 0; n < a; ++n) {
      let l = (n + 1) / (a + 1), h = 1 - l, u = e.mul(h * h * h), c = t.mul(3 * l * h * h), f = r.mul(3 * l * l * h), g = i.mul(l * l * l);
      o[n] = u.add(c).add(f).add(g);
    }
    return o;
  }
  drawRect(e, t, r, i, a = M.COLOR_WHITE) {
    this.drawLines(e, [t, new d(t.x + r, t.y, t.z), new d(t.x + r, t.y + i, t.z), new d(t.x, t.y + i, t.z), t], a);
  }
  drawCircle(e, t, r, i = 32, a = d.Y_AXIS, o = M.COLOR_WHITE) {
    this.createCustomShape(e).buildCircle(t, r, i, a, o);
  }
  drawSector(e, t, r, i, a, o = 16, n = d.Y_AXIS, l = M.COLOR_WHITE) {
    const h = (a - i) * me;
    i *= me;
    var u = [];
    u.push(t);
    for (let m = 0; m <= o; ++m) {
      m > 0 && u.push(u[u.length - 1]);
      var c = h * (m / o) + i, f = r * Math.cos(c), g = r * Math.sin(c);
      switch (n) {
        case d.X_AXIS:
          u.push(t.add(new d(0, f, g)));
          break;
        case d.Y_AXIS:
          u.push(t.add(new d(f, 0, g)));
          break;
        case d.Z_AXIS:
          u.push(t.add(new d(f, g, 0)));
          break;
        default:
          u.push(t.add(new d(f, g, 0)));
          break;
      }
    }
    u.push(u[u.length - 1]), u.push(t), this.mLineRender.fillShapeData(e, "line", l, u);
  }
  drawArcLine(e, t, r, i, a, o = 16, n = d.Y_AXIS, l = M.COLOR_WHITE) {
    this.mLineRender.allocGraphics3DShape(e, this.transform._worldMatrix.index).buildArcLine(t, r, i, a, o, n, l);
  }
  createCustomShape(e, t = this.transform) {
    return this.mLineRender.allocGraphics3DShape(e, t._worldMatrix.index);
  }
  drawBox(e, t, r, i = M.COLOR_WHITE) {
    var a = [];
    a.push(t), a.push(new d(r.x, t.y, t.z)), a.push(a[a.length - 1]), a.push(new d(r.x, r.y, t.z)), a.push(a[a.length - 1]), a.push(new d(t.x, r.y, t.z)), a.push(a[a.length - 1]), a.push(t), a.push(a[a.length - 1]), a.push(new d(t.x, t.y, r.z)), a.push(a[a.length - 1]), a.push(new d(r.x, t.y, r.z)), a.push(a[a.length - 1]), a.push(new d(r.x, r.y, r.z)), a.push(a[a.length - 1]), a.push(new d(t.x, r.y, r.z)), a.push(a[a.length - 1]), a.push(new d(t.x, t.y, r.z)), a.push(new d(t.x, r.y, t.z)), a.push(new d(t.x, r.y, r.z)), a.push(new d(r.x, r.y, t.z)), a.push(new d(r.x, r.y, r.z)), a.push(new d(r.x, t.y, t.z)), a.push(new d(r.x, t.y, r.z)), this.mLineRender.fillShapeData(e, "line", i, a);
  }
  drawFillRect(e, t, r, i, a = M.COLOR_WHITE) {
    this.mFillRender.fillShapeData(e, "fill", a, [t, new d(t.x + r, t.y, t.z), new d(t.x + r, t.y, t.z + i), new d(t.x + r, t.y, t.z + i), new d(t.x, t.y, t.z + i), t]);
  }
  drawFillCircle(e, t, r, i = 32, a = d.Y_AXIS, o = M.COLOR_WHITE) {
    var n = [];
    n.push(t);
    for (let c = 0; c <= i; ++c) {
      c >= 2 && (n.push(t), n.push(n[n.length - 2]));
      var l = 2 * Math.PI * c / i, h = r * Math.cos(l), u = r * Math.sin(l);
      switch (a) {
        case d.X_AXIS:
          n.push(t.add(new d(0, h, u)));
          break;
        case d.Y_AXIS:
          n.push(t.add(new d(h, 0, u)));
          break;
        case d.Z_AXIS:
          n.push(t.add(new d(h, u, 0)));
          break;
        default:
          n.push(t.add(new d(h, u, 0)));
          break;
      }
    }
    this.mFillRender.fillShapeData(e, "fill", o, n);
  }
  drawMeshWireframe(e, t, r, i = M.COLOR_WHITE, a = false) {
    t && this.createCustomShape(e, r || this.transform).fillShapeData(t.genWireframe(), i, a);
  }
  drawFillSector(e, t, r, i, a, o = 16, n = d.Y_AXIS, l = M.COLOR_WHITE) {
    const h = (a - i) * me;
    i *= me;
    var u = [];
    u.push(t);
    for (let m = 0; m <= o; ++m) {
      m >= 2 && (u.push(t), u.push(u[u.length - 2]));
      var c = h * (m / o) + i, f = r * Math.cos(c), g = r * Math.sin(c);
      switch (n) {
        case d.X_AXIS:
          u.push(t.add(new d(0, f, g)));
          break;
        case d.Y_AXIS:
          u.push(t.add(new d(f, 0, g)));
          break;
        case d.Z_AXIS:
          u.push(t.add(new d(f, g, 0)));
          break;
        default:
          u.push(t.add(new d(f, g, 0)));
          break;
      }
    }
    this.mFillRender.fillShapeData(e, "fill", l, u);
  }
  drawBoundingBox(e, t, r = M.COLOR_WHITE) {
    this.drawBox(e, t.min, t.max, r);
  }
  drawCameraFrustum(e, t = M.COLOR_WHITE) {
    if (e.type == Ae.perspective) {
      let r = Math.tan(e.fov / 2 * me), i = r * e.aspect, a = e.transform._worldMatrix, o = a.transformVector(new d(-i, -r, 1)), n = a.transformVector(new d(-i, r, 1)), l = a.transformVector(new d(i, -r, 1)), h = a.transformVector(new d(i, r, 1)), u = e.far, c = e.near, f = e.transform.worldPosition, g = new d().copyFrom(o).multiplyScalar(u).add(f), m = new d().copyFrom(n).multiplyScalar(u).add(f), A = new d().copyFrom(l).multiplyScalar(u).add(f), _ = new d().copyFrom(h).multiplyScalar(u).add(f), x = new d().copyFrom(o).multiplyScalar(c).add(f), C = new d().copyFrom(n).multiplyScalar(c).add(f), S = new d().copyFrom(l).multiplyScalar(c).add(f), I = new d().copyFrom(h).multiplyScalar(c).add(f), T = this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);
      T.buildLines([C, m], t), T.buildLines([x, g], t), T.buildLines([I, _], t), T.buildLines([S, A], t), T.buildLines([m, _, A, g, m], t), T.buildLines([C, I, S, x, C], t);
    } else if (e.type == Ae.ortho) {
      e.viewPort, e.viewPort.height;
      let r = e.transform.worldMatrix, i = r.transformVector(new d(e.viewPort.width * -0.5, e.viewPort.height * 0.5, e.far)), a = r.transformVector(new d(e.viewPort.width * -0.5, e.viewPort.height * -0.5, e.far)), o = r.transformVector(new d(e.viewPort.width * 0.5, e.viewPort.height * 0.5, e.far)), n = r.transformVector(new d(e.viewPort.width * 0.5, e.viewPort.height * -0.5, e.far)), l = r.transformVector(new d(e.viewPort.width * -0.5, e.viewPort.height * 0.5, e.near)), h = r.transformVector(new d(e.viewPort.width * -0.5, e.viewPort.height * -0.5, e.near)), u = r.transformVector(new d(e.viewPort.width * 0.5, e.viewPort.height * 0.5, e.near)), c = r.transformVector(new d(e.viewPort.width * 0.5, e.viewPort.height * -0.5, e.near)), f = this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);
      f.buildLines([l, i], t), f.buildLines([h, a], t), f.buildLines([u, o], t), f.buildLines([c, n], t), f.buildLines([i, o, n, a, i], t), f.buildLines([l, u, c, h, l], t);
    }
  }
  drawObjectBoundingBox(e, t = M.COLOR_WHITE) {
    let r = pa.genMeshBounds(e);
    this.drawBox(`Bounds_${e.instanceID}`, r.min, r.max, t);
  }
  Clear(e) {
    this.mLineRender.shapes.has(e) ? this.mLineRender.removeShape(e) : this.mFillRender.shapes.has(e) && this.mFillRender.removeShape(e);
  }
  ClearAll() {
    this.mLineRender.shapes.clear(), this.mFillRender.shapes.clear();
  }
  ChangeColor(e, t) {
    var r;
    if (this.mLineRender.shapes.has(e))
      r = this.mLineRender.shapes.get(e);
    else if (this.mFillRender.shapes.has(e))
      r = this.mFillRender.shapes.get(e);
    else
      return;
    const i = r.colorData;
    for (let a = 0; a < i.length; a += 4)
      i[a + 0] = t.r, i[a + 1] = t.g, i[a + 2] = t.b, i[a + 3] = t.a;
  }
};
var Dc = class {
  constructor() {
    __publicField(this, "_computeShader");
    __publicField(this, "_outBuffer");
  }
  init() {
    let e = Ee.getGBufferFrame("ColorPassGBuffer");
    this._computeShader = new ae(Pu), this._outBuffer = new Kr(32), this._computeShader.setStorageBuffer("outBuffer", this._outBuffer), this._computeShader.setSamplerTexture("visibleMap", e.getPositionMap());
  }
  compute(e) {
    let t = oe.getCameraGroup(e.camera);
    this._computeShader.setStorageBuffer("globalUniform", t.uniformGPUBuffer);
    let r = y.beginCommandEncoder();
    y.computeCommand(r, [this._computeShader]), y.endCommandEncoder(r), this._outBuffer.readBuffer();
  }
  getPickMeshID() {
    var e = this._outBuffer.outFloat32Array[0] + 0.1;
    return Math.floor(e);
  }
  getPickWorldPosition(e) {
    e || (e = new d());
    var t = this._outBuffer.outFloat32Array[4], r = this._outBuffer.outFloat32Array[5], i = this._outBuffer.outFloat32Array[6];
    return e.set(t, r, i), e;
  }
  getPickScreenUV(e) {
    e || (e = new Q());
    var t = this._outBuffer.outFloat32Array[2], r = this._outBuffer.outFloat32Array[3];
    return e.set(t, r), e;
  }
};
var Pc = class extends qt {
  constructor(e) {
    super();
    __publicField(this, "ray");
    __publicField(this, "isTouching", false);
    __publicField(this, "_mouseCode");
    __publicField(this, "_pickEvent");
    __publicField(this, "_outEvent");
    __publicField(this, "_overEvent");
    __publicField(this, "_upEvent");
    __publicField(this, "_downEvent");
    __publicField(this, "_mouseMove");
    __publicField(this, "_pickCompute");
    __publicField(this, "_lastDownTarget");
    __publicField(this, "mouseEnableMap");
    __publicField(this, "_view");
    __publicField(this, "_lastFocus");
    __publicField(this, "_interestList", []);
    this._view = e, this.init();
  }
  init() {
    this.ray = new bt(), this.mouseEnableMap = /* @__PURE__ */ new Map(), this._pickEvent = new U(U.PICK_CLICK), this._outEvent = new U(U.PICK_OUT), this._overEvent = new U(U.PICK_OVER), this._mouseMove = new U(U.PICK_MOVE), this._upEvent = new U(U.PICK_UP), this._downEvent = new U(U.PICK_DOWN);
  }
  start() {
    p.setting.pick.enable && (p.inputSystem.addEventListener(U.POINTER_DOWN, this.onTouchStart, this), p.inputSystem.addEventListener(U.POINTER_UP, this.onTouchEnd, this), p.inputSystem.addEventListener(U.POINTER_CLICK, this.onTouchOnce, this), p.inputSystem.addEventListener(U.POINTER_MOVE, this.onTouchMove, this)), p.setting.pick.mode == "pixel" && (this._pickCompute = new Dc(), this._pickCompute.init());
  }
  stop() {
    p.inputSystem.removeEventListener(U.POINTER_DOWN, this.onTouchStart, this), p.inputSystem.removeEventListener(U.POINTER_UP, this.onTouchEnd, this), p.inputSystem.removeEventListener(U.POINTER_CLICK, this.onTouchOnce, this), p.inputSystem.removeEventListener(U.POINTER_MOVE, this.onTouchMove, this);
  }
  onTouchStart(e) {
    this.isTouching = true, this._mouseCode = e.mouseCode, this.pick(this._view.camera);
    let t = this.findNearestObj(this._interestList, this._view.camera);
    this._lastDownTarget = t, t && (this._downEvent.target = t.object3D, this._downEvent.ctrlKey = e.ctrlKey, this._downEvent.data = { pick: t, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode }, this.dispatchEvent(this._downEvent), t.object3D.containEventListener(U.PICK_DOWN) && t.object3D.dispatchEvent(this._downEvent));
  }
  onTouchEnd(e) {
    this.isTouching = false, this._mouseCode = e.mouseCode, this.pick(this._view.camera);
    let t = this.findNearestObj(this._interestList, this._view.camera);
    t && (this._upEvent.target = t.object3D, this._upEvent.ctrlKey = e.ctrlKey, this._upEvent.data = { pick: t, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode }, this.dispatchEvent(this._upEvent), t.object3D.containEventListener(U.PICK_UP) && t.object3D.dispatchEvent(this._upEvent));
  }
  getPickInfo() {
    return { worldPos: this._pickCompute.getPickWorldPosition(), screenUv: this._pickCompute.getPickScreenUV(), meshID: this._pickCompute.getPickMeshID() };
  }
  onTouchMove(e) {
    this.isTouching = true, this._mouseCode = e.mouseCode, this.pick(this._view.camera);
    let t = this.findNearestObj(this._interestList, this._view.camera);
    t && (this._mouseMove.target = t.object3D, this._mouseMove.ctrlKey = e.ctrlKey, this._mouseMove.data = { pick: t, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode }, this.dispatchEvent(this._mouseMove), t.object3D.containEventListener(U.PICK_MOVE) && t.object3D.dispatchEvent(this._mouseMove)), t != this._lastFocus && (this._lastFocus && this._lastFocus.object3D && (this._outEvent.target = this._lastFocus.object3D, this._outEvent.data = { pick: this._lastFocus, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode }, this._outEvent.ctrlKey = e.ctrlKey, this.dispatchEvent(this._outEvent), this._lastFocus.object3D.containEventListener(U.PICK_OUT) && this._lastFocus.object3D.dispatchEvent(this._outEvent)), t && (this._overEvent.target = t.object3D, this._overEvent.ctrlKey = e.ctrlKey, this._overEvent.data = { pick: t, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode }, this.dispatchEvent(this._overEvent), t.object3D.containEventListener(U.PICK_OVER) && t.object3D.dispatchEvent(this._overEvent))), this._lastFocus = t;
  }
  onTouchOnce(e) {
    this.isTouching = true, this._mouseCode = e.mouseCode, this.pick(this._view.camera);
    let t = this.findNearestObj(this._interestList, this._view.camera);
    if (t) {
      let r = p.setting.pick.mode == "pixel" ? this.getPickInfo() : null;
      this._pickEvent.target = t.object3D, this._pickEvent.ctrlKey = e.ctrlKey, this._pickEvent.data = { pick: t, pickInfo: r, mouseCode: this._mouseCode }, this.dispatchEvent(this._pickEvent), t === this._lastDownTarget && t.object3D.containEventListener(U.PICK_CLICK) && t.object3D.dispatchEvent(this._pickEvent);
    }
    this._lastDownTarget = null;
  }
  findNearestObj(e, t) {
    var _a3;
    return e.sort((r, i) => r.distance > i.distance ? 1 : -1), (_a3 = e[0]) == null ? void 0 : _a3.collider;
  }
  pick(e) {
    if (this._interestList.length = 0, p.setting.pick.mode == "pixel") {
      this._pickCompute.compute(this._view);
      let t = this._pickCompute.getPickMeshID(), r = this.mouseEnableMap.get(t);
      if (r) {
        let i = this._pickCompute.getPickWorldPosition(), a = d.distance(i, this.ray.origin);
        this._interestList.push({ distance: a, collider: r, intersectPoint: i });
      }
    } else if (p.setting.pick.mode == "bound") {
      this.ray = e.screenPointToRay(p.inputSystem.mouseX, p.inputSystem.mouseY);
      let t, r = ue.componentsEnablePickerList.get(this._view);
      if (r)
        for (const i of r) {
          let a = i[0];
          a.enable && (t = a.rayPick(this.ray), t && (t.collider = a, this._interestList.push(t)));
        }
    }
  }
};
var Ep = class extends la {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    super();
    __publicField(this, "_camera");
    __publicField(this, "_scene");
    __publicField(this, "_viewPort");
    __publicField(this, "_enablePick", false);
    __publicField(this, "_enable", true);
    __publicField(this, "pickFire");
    __publicField(this, "guiPick");
    __publicField(this, "canvasList");
    __publicField(this, "graphic3D");
    this.canvasList = [], this._viewPort = new G(e, t, r, i), this.graphic3D = new Tc();
  }
  get enable() {
    return this._enable;
  }
  set enable(e) {
    this._enable = e;
  }
  get enablePick() {
    return this._enablePick;
  }
  set enablePick(e) {
    this._enablePick != e && (this.pickFire = new Pc(this), this.pickFire.start()), this._enablePick = e;
  }
  get scene() {
    return this._scene;
  }
  set scene(e) {
    this._scene = e, e.view = this, lt.createBuffer(this), this.graphic3D && e.addChild(this.graphic3D), e && this.canvasList.forEach((t) => {
      t && e.addChild(t.object3D);
    });
  }
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e;
  }
  get viewPort() {
    return this._viewPort;
  }
  set viewPort(e) {
    this._viewPort = e;
  }
  enableUICanvas(e = 0) {
    let t = this.canvasList[e];
    if (!t) {
      let r = new Y();
      r.name = "Canvas " + e, t = r.addComponent(Zi), t.index = e, this.canvasList[e] = t;
    }
    return this.scene.addChild(t.object3D), this.guiPick || (this.guiPick = new pc(), this.guiPick.init(this)), t;
  }
  disableUICanvas(e = 0) {
    let t = this.canvasList[e];
    t && t.object3D && t.object3D.removeFromParent();
  }
};
var Bp = class {
  constructor(e) {
    __publicField(this, "normal");
    __publicField(this, "fixNormal");
    __publicField(this, "center");
    __publicField(this, "rotateShape");
    __publicField(this, "distance", 0);
    __publicField(this, "index");
    this.index = e, this.rotateShape = [];
  }
};
var Tp = class extends xe {
  constructor() {
    super(...arguments);
    __publicField(this, "vScale");
    __publicField(this, "uNegate");
    __publicField(this, "sections");
  }
  build(e, t, r, i = 1, a = true) {
    if (r.length < 2)
      throw new Error("path length is not enough");
    return this.vScale = i, this.uNegate = a, e = e.slice(), t && e.push(e[0]), this.sections = this.buildSections(e, r), this.buildGeometry(e, this.sections), this.bounds = new ge(d.ZERO.clone(), new d(100, 100, 100)), this;
  }
  buildSections(e, t) {
    let r, i, a, o = [], n = t.length;
    for (let h = 0; h < n; h++) {
      let u = new Bp(h);
      r = t[h], i = t[h + 1], u.center = r.clone(), i == null ? (u.normal = a.clone(), u.distance = 0) : (a = i.subtract(r), u.distance = a.length, u.normal = a.normalize()), o.push(u);
    }
    o[0].fixNormal = o[0].normal.clone();
    for (let h = 1; h < n; h++) {
      let u = o[h - 1], c = o[h];
      c.fixNormal = c.normal.add(u.normal).normalize();
    }
    let l = new P().identity();
    for (let h = 0; h < n; h++) {
      let u = o[h], c, f;
      if (h == 0)
        c = d.UP, f = e;
      else {
        let g = o[h - 1];
        c = g.fixNormal, f = g.rotateShape;
      }
      P.fromToRotation(c, u.fixNormal, l);
      for (let g = 0, m = e.length; g < m; g++) {
        let A = l.multiplyPoint3(f[g]);
        u.rotateShape.push(A);
      }
    }
    return o;
  }
  buildGeometry(e, t) {
    let r = t.length, i = e.length, a = r * i, o = r - 1, n = new Float32Array(a * 3), l = new Float32Array(a * 3), h = new Float32Array(a * 2), u = new Uint32Array(o * (i - 1) * 6), c = i - 1, f = 0, g = 0, m = [0];
    for (let _ = 1; _ < i; _++)
      g += e[_ - 1].subtract(e[_]).length, m.push(g);
    for (let _ = 0; _ < r; _++) {
      let x = t[_];
      for (let C = 0; C < i; C++) {
        let S = (_ * i + C) * 3, I = x.rotateShape[C].add(x.center);
        n[S] = I.x, n[S + 1] = I.y, n[S + 2] = I.z, l[S + 1] = 1;
        let T = (_ * i + C) * 2, b = m[C] / g;
        h[T] = this.uNegate ? 1 - b : b, h[T + 1] = f * this.vScale;
      }
      f += x.distance;
    }
    let A = 0;
    for (let _ = 0; _ < o; _++) {
      let x = _ * i;
      for (let C = 0; C < c; C++) {
        let S = C, I = C + 1, T = S + i, b = I + i;
        u[A++] = S + x, u[A++] = I + x, u[A++] = T + x, u[A++] = I + x, u[A++] = b + x, u[A++] = T + x;
      }
    }
    return this.setIndices(u), this.setAttribute(D.position, n), this.setAttribute(D.normal, l), this.setAttribute(D.uv, h), this.setAttribute(D.TEXCOORD_1, h), this.addSubGeometry({ indexStart: 0, indexCount: u.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 }), this.computeNormals(), this;
  }
};
var Dp = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "offset");
    __publicField(this, "size");
    __publicField(this, "arrayStride");
    __publicField(this, "stepMode");
    __publicField(this, "attributes");
  }
};
var Pp = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "format");
    __publicField(this, "offset");
    __publicField(this, "shaderLocation");
    __publicField(this, "stride");
  }
};
var Mc = ((s) => (s[s.position = 3] = "position", s[s.normal = 3] = "normal", s[s.TANGENT = 4] = "TANGENT", s[s.uv = 2] = "uv", s[s.TEXCOORD_1 = 2] = "TEXCOORD_1", s[s.color = 4] = "color", s[s.joints0 = 4] = "joints0", s[s.weights0 = 4] = "weights0", s[s.joints1 = 4] = "joints1", s[s.weights1 = 4] = "weights1", s[s.vIndex = 1] = "vIndex", s[s.weight = 1] = "weight", s[s.a_morphPositions_0 = 3] = "a_morphPositions_0", s))(Mc || {});
var Mp = class {
  constructor() {
  }
};
var Rp = class {
  constructor() {
    __publicField(this, "entity");
  }
  get data() {
    return null;
  }
};
var Rc = class {
  constructor() {
    __publicField(this, "min", 0);
    __publicField(this, "max", 0);
  }
  set(e, t) {
    return this.max = t, this.min = e, this;
  }
  copy(e) {
    return this.max = e.max, this.min = e.min, this;
  }
  isInterestRange(e) {
    return !(this.max > e.min || e.max < this.min);
  }
};
var Uc = class {
  constructor() {
    __publicField(this, "_spaceDesc");
  }
  getRange(e) {
    return this._spaceDesc[e];
  }
  initSpace(e) {
    this._spaceDesc = {};
    for (let t of e)
      (this._spaceDesc[t] = new Rc()).set(-Number.MAX_VALUE, Number.MAX_VALUE);
    return this;
  }
  isContain(e, t) {
    let r = this._spaceDesc[e];
    return t >= r.min && t < r.max;
  }
  isInterestRange(e, t) {
    let r = this._spaceDesc[e];
    return r ? t.isInterestRange(r) : false;
  }
  splitSpace(e, t, r) {
    let i = this._spaceDesc[e];
    return t ? i.max = r : i.min = r, this;
  }
  copySpace(e) {
    for (let t in e._spaceDesc) {
      let r = e._spaceDesc[t];
      this._spaceDesc[t].copy(r);
    }
    return this;
  }
};
var _ta = class _ta {
};
__publicField(_ta, "MaxEntityCountInLeaf", 4);
__publicField(_ta, "MaxLayer", 10);
__publicField(_ta, "ClearLeafLayer", _ta.MaxLayer - 4);
var ta = _ta;
var _ra = class _ra {
  constructor() {
    __publicField(this, "uuid", "0");
    this.uuid = (_ra.UUID++).toString();
  }
};
__publicField(_ra, "UUID", 0);
var ra = _ra;
var Up = class {
  constructor() {
    __publicField(this, "map", {});
    __publicField(this, "_count", 0);
  }
  get count() {
    return this._count;
  }
  push(e) {
    return this.map[e.uuid] ? false : (this.map[e.uuid] = e, this._count++, true);
  }
  remove(e) {
    return this.map[e] ? (delete this.map[e], this._count--, true) : false;
  }
};
var _Cr = class _Cr extends ra {
  constructor(e = 0) {
    super();
    __publicField(this, "_dimensionIndex", 0);
    __publicField(this, "_dimensions");
    __publicField(this, "_dimension");
    __publicField(this, "_left");
    __publicField(this, "_right");
    __publicField(this, "_space");
    __publicField(this, "_parent");
    __publicField(this, "_entities");
    __publicField(this, "layer");
    __publicField(this, "_splitEntityList", []);
    __publicField(this, "pointIntersect", new d());
    this.layer = e, _Cr.nodeCount++;
  }
  get dimension() {
    return this._dimension;
  }
  initNode(e, t, r) {
    return this._dimensions = t, this._dimensionIndex = r, this._dimension = t[r], this._space = new Uc().initSpace(t), e && this._space.copySpace(e._space), this._parent = e, this._entities = new Up(), this;
  }
  updateEntity(e) {
    if (e.isInNode(this, this._dimension) && (e.attachTreeNode(this), this.autoSplit(), this._left && this._right)) {
      let t = (this._dimensionIndex + 1) % this._dimensions.length, r = this._dimensions[t];
      e.isInNode(this._right, r) ? this._right.updateEntity(e) : e.isInNode(this._left, r) && this._left.updateEntity(e);
    }
  }
  buildRoot(e) {
    for (const t of e)
      t.entity.attachTreeNode(this);
    this.autoSplit();
  }
  autoSplit() {
    if (this._entities.count > ta.MaxEntityCountInLeaf && !this._right && !this._left && this.layer < ta.MaxLayer) {
      let e = this._splitEntityList, t = (this._dimensionIndex + 1) % this._dimensions.length, r = this._dimensions[t], i = 0;
      for (const a in this._entities.map) {
        let o = this._entities.map[a];
        i += o.centerValue(r), e.push(o);
      }
      i /= this._entities.count, this._left = new _Cr(this.layer + 1), this._right = new _Cr(this.layer + 1), this._left.initNode(this, this._dimensions, t), this._right.initNode(this, this._dimensions, t), this._left.setSpace(true, i), this._right.setSpace(false, i);
      for (let a of e)
        a.isInNode(this._right, r) ? a.attachTreeNode(this._right) : a.isInNode(this._left, r) && a.attachTreeNode(this._left);
    }
    this._left && this._left.autoSplit(), this._right && this._right.autoSplit();
  }
  setSpace(e, t) {
    return this._parent && this._space.splitSpace(this._dimension, e, t), this;
  }
  isEmpty() {
    return this._left == null && this._right == null && this._entities.count == 0;
  }
  pushEntity(e) {
    return this._entities.push(e);
  }
  removeEntity(e) {
    return this._entities.remove(e.uuid);
  }
  autoClear() {
    let e = this;
    for (; e && e.layer > ta.ClearLeafLayer && e.clearLeaf(); )
      e = e._parent;
  }
  clearLeaf() {
    let e = !this._left && !this._right, t = !e && this._left.isEmpty() && this._right.isEmpty();
    return t && (this._left = this._right = null, _Cr.nodeCount -= 2), e || t;
  }
  isContain(e) {
    return this._space.isContain(this._dimension, e);
  }
  nodeIntersectsBox(e) {
    let t = this._space.getRange("x"), r = this._space.getRange("y"), i = this._space.getRange("z"), a = _Cr.rangeBox;
    return a.min.set(t.min, r.min, i.min), a.max.set(t.max, r.max, i.max), a.intersectsBox(e);
  }
  nodeIntersectsRay(e) {
    let t = this._space.getRange("x"), r = this._space.getRange("y"), i = this._space.getRange("z"), a = _Cr.rangeBox;
    return a.min.set(t.min, r.min, i.min), a.max.set(t.max, r.max, i.max), true;
  }
  pointCast(e, t = 0, r) {
    if (r = r || [], this._entities.count > 0) {
      let i = this._entities.map;
      for (let a in i) {
        let o = i[a], n = o.entityContainPoint(e);
        !n && t > 0 && (n = o.squareDistanceTo(e, this._dimensions) <= t), n && r.push(o);
      }
    }
    this._left && this._left.isContain(e[this._left.dimension]) && this._left.pointCast(e, t, r), this._right && this._right.isContain(e[this._right.dimension]) && this._right.pointCast(e, t, r);
  }
  boxCast(e, t) {
    if (t = t || [], this._entities.count > 0) {
      let r = this._entities.map;
      for (let i in r) {
        let a = r[i];
        a.entityIntersectsBox(e) && t.push(a);
      }
    }
    this._left && this._left.nodeIntersectsBox(e) && this._left.boxCast(e, t), this._right && this._right.nodeIntersectsBox(e) && this._right.boxCast(e, t);
  }
  rayCast(e, t, r) {
    t = t || [], r = r || [];
    let i = this.pointIntersect;
    if (this._entities.count > 0) {
      let a = this._entities.map;
      for (let o in a) {
        let n = a[o];
        n.entityIntersectsRay(e, i) && (r.push(new d().copyFrom(i)), t.push(n));
      }
    }
    this._left && this._left.nodeIntersectsRay(e) && this._left.rayCast(e, t, r), this._right && this._right.nodeIntersectsRay(e) && this._right.rayCast(e, t, r);
  }
};
__publicField(_Cr, "nodeCount", 0);
__publicField(_Cr, "rangeBox", new ge(new d(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), new d(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE)));
var Cr = _Cr;
var Lp = class extends ra {
  constructor(e) {
    super();
    __publicField(this, "userData");
    __publicField(this, "node");
    this.userData = e;
  }
  centerValue(e) {
    return 0;
  }
  isInNode(e, t) {
    return false;
  }
  entityContainPoint(e) {
    return false;
  }
  squareDistanceTo(e, t) {
    return Number.MAX_VALUE;
  }
  entityIntersectsBox(e) {
    return false;
  }
  entityIntersectsRay(e, t) {
    return false;
  }
  attachTreeNode(e) {
    return this.node && this.detachTreeNode(), this.node = e, this.node.pushEntity(this);
  }
  detachTreeNode() {
    let e = this.node.removeEntity(this);
    return this.node = null, e;
  }
  updateNode(e) {
    let t = this.node;
    t && this.detachTreeNode(), e.updateEntity(this), t && t.autoClear();
  }
};
var _$e = class _$e {
  constructor() {
    __publicField(this, "minPosX", 0);
    __publicField(this, "minPosY", 0);
    __publicField(this, "maxPosX", 0);
    __publicField(this, "maxPosY", 0);
    __publicField(this, "testID", 0);
    __publicField(this, "points");
    __publicField(this, "offsetPosition");
    this.points = new Array(), this.offsetPosition = new d(0, 0, 0, 0), this.clear();
  }
  setAABox(e, t, r, i) {
    this.minPosX = e - r / 2 - _$e.TINY, this.maxPosX = e + r / 2 + _$e.TINY, this.minPosY = t - i / 2 - _$e.TINY, this.maxPosY = t + i / 2 + _$e.TINY, this.offsetPosition.setTo(0, 0, 0);
  }
  setOffset(e) {
    this.maxPosX += e.x - this.offsetPosition.x, this.minPosX += e.x - this.offsetPosition.x, this.minPosY += e.z - this.offsetPosition.z, this.maxPosY += e.z - this.offsetPosition.z, this.offsetPosition.copyFrom(e);
  }
  setContainRect(e, t, r, i) {
    this.minPosX > e && (this.minPosX = e), this.minPosY > t && (this.minPosY = t), this.maxPosX < r && (this.maxPosX = r), this.maxPosY < i && (this.maxPosY = i);
  }
  clear() {
    var e = 1e9;
    this.minPosX = this.minPosY = e, this.maxPosX = this.maxPosY = -e, this.points.length = 0, this.testID = 0, this.offsetPosition.setTo(0, 0, 0);
  }
  addPoint(e) {
    this.points.indexOf(e) == -1 && (e.x < this.minPosX && (this.minPosX = e.x - _$e.TINY), e.x > this.maxPosX && (this.maxPosX = e.x + _$e.TINY), e.z < this.minPosY && (this.minPosY = e.z - _$e.TINY), e.z > this.maxPosY && (this.maxPosY = e.z + _$e.TINY), this.points.push(e));
  }
  clone() {
    var e = new _$e();
    return e.minPosX = this.minPosX, e.minPosY = this.minPosY, e.maxPosX = this.maxPosX, e.maxPosY = this.maxPosY, e;
  }
  get radius() {
    return Math.sqrt((this.maxPosY - this.minPosY) * (this.maxPosY - this.minPosY) + (this.maxPosX - this.minPosX) * (this.maxPosX - this.minPosX));
  }
  get sideX() {
    return this.maxPosX - this.minPosX;
  }
  get sideY() {
    return this.maxPosY - this.minPosY;
  }
  get centreX() {
    return (this.maxPosX - this.minPosX) * 0.5 + this.minPosX;
  }
  get centreY() {
    return (this.maxPosY - this.minPosY) * 0.5 + this.minPosY;
  }
  overlapTest(e) {
    return !(this.minPosY >= e.maxPosY || this.maxPosY <= e.minPosY || this.minPosX >= e.maxPosX || this.maxPosX <= e.minPosX);
  }
  isPointInside(e) {
    return e.x >= this.minPosX && e.x <= this.maxPosX && e.z >= this.minPosY && e.z <= this.maxPosY;
  }
  isIntersectLineSegment(e, t, r, i) {
    var a = false, o = t - i, n = r - e, l = e * i - r * t, h = (-l - o * this.minPosX) / n;
    h <= this.maxPosY && h >= this.minPosY && (a = true), h = (-l - o * this.maxPosX) / n, h <= this.maxPosY && h >= this.minPosY && (a = true);
    var u = (-l - n * this.minPosY) / o;
    return u <= this.maxPosX && u >= this.minPosX && (a = true), u = (-l - n * this.maxPosY) / o, u <= this.maxPosX && u >= this.minPosX && (a = true), a;
  }
};
__publicField(_$e, "TINY", 1e-6);
var $e = _$e;
var _Ir = class _Ir {
  constructor(e) {
    __publicField(this, "childCellIndices");
    __publicField(this, "nodeIndices");
    __publicField(this, "aabb");
    __publicField(this, "points");
    this.childCellIndices = new Array(), this.childCellIndices.length = _Ir.NUM_CHILDREN, this.nodeIndices = new Array(), this.clear(), e ? this.aabb = e.clone() : this.aabb = new $e();
  }
  isLeaf() {
    return this.childCellIndices[0] == -1;
  }
  clear() {
    for (var e = 0; e < _Ir.NUM_CHILDREN; e++)
      this.childCellIndices[e] = -1;
    this.nodeIndices.splice(0, this.nodeIndices.length);
  }
};
__publicField(_Ir, "NUM_CHILDREN", 4);
var Ir = _Ir;
var Lc = class {
  constructor() {
    __publicField(this, "_cells");
    __publicField(this, "_rootCell");
    __publicField(this, "_quadNodes");
    __publicField(this, "_aabb");
    __publicField(this, "_cellsToTest");
    __publicField(this, "_testID");
    __publicField(this, "logDeep", 0);
    this._testID = 0, this._cells = new Array(), this._quadNodes = new Array(), this._cellsToTest = new Array(), this._aabb = new $e();
  }
  getQuadNode(e) {
    return this._quadNodes[e];
  }
  clear() {
    this._cells.length = 0, this._quadNodes.length = 0;
  }
  initNodes(e) {
    this.clear();
    for (var t = 0, r = e.length; t < r; )
      e[t].calcGlobalQuadAABB(), this._quadNodes.push(e[t]), t++;
  }
  buildQuadTree(e, t) {
    this._aabb.clear();
    for (var r of this._quadNodes)
      if (r.isTriangle)
        for (var i of r.aabb.points)
          this._aabb.addPoint(i);
      else
        this._aabb.setContainRect(r.aabb.minPosX, r.aabb.minPosY, r.aabb.maxPosX, r.aabb.maxPosY);
    this._cells.length = 0, this._rootCell = new Ir(this._aabb), this._cells.push(this._rootCell);
    for (var a = this._quadNodes.length, o = 0; o < a; o++)
      this._cells[0].nodeIndices[o] = o;
    var n = new Array();
    n.push(0);
    for (var l, h, u; n.length != 0; )
      if (h = n.pop(), !(this._cells[h].nodeIndices.length <= e || this._cells[h].aabb.radius < t)) {
        for (o = 0; o < Ir.NUM_CHILDREN; o++) {
          this._cells[h].childCellIndices[o] = this._cells.length, n.push(this._cells.length), this._cells.push(new Ir(this.createAABox(this._cells[h].aabb, o))), u = this._cells[this._cells.length - 1], a = this._cells[h].nodeIndices.length;
          for (var c = 0; c < a; c++)
            l = this._cells[h].nodeIndices[c], this.doesNodeIntersectCell(this._quadNodes[l], u) && u.nodeIndices.push(l);
        }
        this._cells[h].nodeIndices.length = 0;
      }
  }
  createAABox(e, t) {
    var r = e.centreX, i = e.centreY, a = e.sideX, o = e.sideY, n = new $e();
    switch (t) {
      case 0:
        n.setAABox(r + a / 4, i + o / 4, a / 2, o / 2);
        break;
      case 1:
        n.setAABox(r - a / 4, i + o / 4, a / 2, o / 2);
        break;
      case 2:
        n.setAABox(r - a / 4, i - o / 4, a / 2, o / 2);
        break;
      case 3:
        n.setAABox(r + a / 4, i - o / 4, a / 2, o / 2);
        break;
      default:
        n.setAABox(r + a / 4, i - o / 4, a / 2, o / 2);
        break;
    }
    return n;
  }
  doesNodeIntersectCell(e, t) {
    var r = e.aabb;
    if (!r.overlapTest(t.aabb))
      return false;
    if (!e.isTriangle)
      return true;
    var i = r.points, a = i[0], o = i[1], n = i[2];
    if (t.aabb.isPointInside(a) || t.aabb.isPointInside(o) || t.aabb.isPointInside(n))
      return true;
    var l = this.pointInTriangle(t.aabb.minPosX, t.aabb.minPosY, a, o, n) || this.pointInTriangle(t.aabb.minPosX, t.aabb.maxPosY, a, o, n) || this.pointInTriangle(t.aabb.maxPosX, t.aabb.maxPosY, a, o, n) || this.pointInTriangle(t.aabb.maxPosX, t.aabb.minPosY, a, o, n);
    return l ? true : (l = t.aabb.isIntersectLineSegment(a.x, a.z, o.x, o.z) || t.aabb.isIntersectLineSegment(a.x, a.z, n.x, n.z) || t.aabb.isIntersectLineSegment(o.x, o.z, n.x, n.z), l);
  }
  getNodesIntersectingtAABox(e, t) {
    if (this._cells.length == 0)
      return 0;
    this._cellsToTest.length = 0, this._cellsToTest.push(0), this.incrementTestCounter();
    for (var r, i, a, o, n = 0; this._cellsToTest.length != 0; )
      if (r = this._cellsToTest.pop(), a = this._cells[r], !!t.overlapTest(a.aabb))
        if (a.isLeaf())
          for (i = a.nodeIndices.length, n = 0; n < i; n++)
            o = this.getQuadNode(a.nodeIndices[n]).aabb, o.testID != this._testID && (o.testID = this._testID, t.overlapTest(o) && e.push(a.nodeIndices[n]));
        else
          for (n = 0; n < Ir.NUM_CHILDREN; n++)
            this._cellsToTest.push(a.childCellIndices[n]);
    return e.length;
  }
  pointInTriangle(e, t, r, i, a) {
    var o = r, n = i, l = a, h = o.z - n.z, u = n.x - o.x, c = o.x * n.z - n.x * o.z, f = n.z - l.z, g = l.x - n.x, m = n.x * l.z - l.x * n.z, A = l.z - o.z, _ = o.x - l.x, x = l.x * o.z - o.x * l.z, C = false, S = h * e + u * t + c, I = f * e + g * t + m, T = A * e + _ * t + x;
    const b = 0.01;
    return (S >= -b && I >= -b && T >= -b || S <= b && I <= b && T <= b) && (C = true), C;
  }
  incrementTestCounter() {
    if (++this._testID, this._testID == 0) {
      for (var e = this._quadNodes.length, t = 0; t < e; t++)
        this._quadNodes[t].aabb.testID = 0;
      this._testID = 1;
    }
  }
  logTree(e) {
    if (!(e < 0)) {
      this.logDeep++;
      for (var t = this._cells[e], r = "", i = 0; i < this.logDeep - 1; i++)
        r += "-|";
      console.log(r + "i=" + e + " " + t.aabb.minPosX.toFixed(2) + " " + t.aabb.maxPosX.toFixed(2) + " " + t.aabb.minPosY.toFixed(2) + " " + t.aabb.maxPosY.toFixed(2));
      var a;
      for (a = 0; a < t.nodeIndices.length; a++)
        if (t.nodeIndices[a] >= 0) {
          var o = this._quadNodes[t.nodeIndices[a]];
          console.log(r + " t=" + t.nodeIndices[a] + " " + o.aabb.minPosX.toFixed(2) + " " + o.aabb.maxPosX.toFixed(2) + " " + o.aabb.minPosY.toFixed(2) + " " + o.aabb.maxPosY.toFixed(2));
        }
      for (a = 0; a < t.childCellIndices.length; a++)
        t.childCellIndices[a] >= 0 && this.logTree(t.childCellIndices[a]);
      this.logDeep--;
    }
  }
};
var Oc = class {
  constructor(e = 10, t = 500) {
    __publicField(this, "_maxNodesPerCell");
    __publicField(this, "_minCellSize");
    __publicField(this, "_quadTree");
    __publicField(this, "_collisionNodesIdx");
    __publicField(this, "_segBox");
    __publicField(this, "_collisionNodes");
    this._maxNodesPerCell = e, this._minCellSize = t, this._segBox = new $e(), this._collisionNodesIdx = new Array(), this._collisionNodes = new Array();
  }
  createQuadTree(e) {
    this._quadTree = new Lc(), this._quadTree.initNodes(e), this._quadTree.buildQuadTree(this._maxNodesPerCell, this._minCellSize);
  }
  getNodesByAABB(e, t, r, i) {
    this._segBox.clear(), this._segBox.maxPosX = r, this._segBox.maxPosY = i, this._segBox.minPosX = e, this._segBox.minPosY = t, this._collisionNodesIdx.length = 0, this._collisionNodes.length = 0, this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
    for (var a, o = 0; o < this._collisionNodesIdx.length; o++)
      a = this._quadTree.getQuadNode(this._collisionNodesIdx[o]), this._collisionNodes.push(a);
    return this._collisionNodes;
  }
  getTriangleAtPoint(e, t = 5) {
    this._segBox.clear(), this._segBox.setAABox(e.x, e.z, 1, 1), this._collisionNodesIdx.length = 0, this._collisionNodes.length = 0, this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
    for (var r = 4294967295, i = 0, a, o, n, l, h = 0; h < this._collisionNodesIdx.length; h++)
      o = this._quadTree.getQuadNode(this._collisionNodesIdx[h]), l = o.aabb, d.pointInsideTriangle(e, l.points[0], l.points[1], l.points[2]) && (n = o, i = Math.abs(n.plane.distance(e)), !(i > t) && (o == null || i <= r) && (a = n, r = i));
    return a;
  }
};
var Fc = ((s) => (s[s.MOUSE_LEFT = 0] = "MOUSE_LEFT", s[s.MOUSE_MID = 1] = "MOUSE_MID", s[s.MOUSE_RIGHT = 2] = "MOUSE_RIGHT", s))(Fc || {});
var Op = class extends ze {
};
__publicField(Op, "LOADER_PROGRESS", "loaderProgress");
__publicField(Op, "LOADER_COMPLETE", "loaderComplete");
var Fp = class extends ze {
};
__publicField(Fp, "ADDED", "added");
__publicField(Fp, "REMOVED", "removed");
__publicField(Fp, "CHILD_ADD_EVENT", "childAddEvent");
__publicField(Fp, "CHILD_REMOVED", "childRemoved");
var Np = class extends ze {
};
__publicField(Np, "SHOW", "show");
__publicField(Np, "HIDE", "hide");
__publicField(Np, "UPDATE", "update");
var zp = class {
  static merge(e, t, r, i) {
    let a = 0, o = 0;
    a = Math.max(e.width, a), a = Math.max(t.width, a), a = Math.max(r.width, a), a = Math.max(i.width, a), o = Math.max(e.height, o), o = Math.max(t.height, o), o = Math.max(r.height, o), o = Math.max(i.height, o);
    let n = new de(a, o, N.rgba8unorm), l = new ae(Eu);
    l.setSamplerTexture("textureR", e), l.setSamplerTexture("textureG", t), l.setSamplerTexture("textureB", r), l.setSamplerTexture("textureA", i), l.setStorageTexture("outTex", n), l.workerSizeX = Math.ceil(a / 8), l.workerSizeY = Math.ceil(o / 8);
    let h = y.beginCommandEncoder();
    return y.computeCommand(h, [l]), y.endCommandEncoder(h), n;
  }
};
var Nc = class {
  constructor(e, t) {
    __publicField(this, "sourceShader");
    __publicField(this, "compute");
    __publicField(this, "needUpdate", true);
    this.sourceShader = t, this.compute = new ae(e), this.init();
  }
  init() {
  }
  onUpdate() {
    this.onFrame && this.onFrame(), this.onOnce && this.needUpdate && (this.needUpdate = false, this.onFrame());
  }
};
var zc = class extends Nc {
  constructor(e) {
    super(Mu, e);
  }
  init() {
    let e = new de(256, 256, N.rgba8unorm, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
    return this.compute.setStorageTexture("sssMap", e), this.sourceShader.setTexture("lutMap", e), e;
  }
  onFrame() {
    this.compute.workerSizeX = 256 / 8, this.compute.workerSizeY = 256 / 8;
    let e = y.beginCommandEncoder();
    y.computeCommand(e, [this.compute]), y.endCommandEncoder(e);
  }
};
var Ni = class extends Jt {
  constructor(e, t, r = 0) {
    super(), this.bufferType = Tt.StructStorageGPUBuffer, this.createBufferByStruct(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | r, e, t);
  }
};
var kp = class {
  static createMipmap(e, t) {
    const r = w.device;
    this._pipelineMax || (this._pipelineMax = r.createComputePipeline({ layout: "auto", compute: { module: r.createShaderModule({ code: this.codeMax }), entryPoint: "main" } })), this._pipelineMin || (this._pipelineMin = r.createComputePipeline({ layout: "auto", compute: { module: r.createShaderModule({ code: this.codeMin }), entryPoint: "main" } }));
    let i = Math.ceil(e.width * 0.5), a = Math.ceil(e.height * 0.5), o = { mipmapCount: t, texture: e, srcView: null, mipLevel: 1, dstHeight: a, dstWidth: i };
    o.srcView = e.getGPUTexture().createView({ format: e.format, dimension: "2d", baseMipLevel: 0, mipLevelCount: 1 }), e.width > 1024 && e.height > 1024 ? this.mipmap(this._pipelineMax, o) : this.mipmap(this._pipelineMin, o);
  }
  static mipmap(e, t) {
    const r = w.device, i = y.beginCommandEncoder();
    let a = e == this._pipelineMax, o, n;
    for (let l = t.mipLevel; l < t.mipmapCount; l++) {
      let h = [], u = 0;
      h.push({ binding: u++, resource: t.srcView }), h.push({ binding: u++, resource: t.texture.gpuSampler }), o = t.texture.getGPUTexture().createView({ format: t.texture.format, dimension: "2d", baseMipLevel: l, mipLevelCount: 1 }), h.push({ binding: u++, resource: o });
      const c = r.createBindGroup({ layout: e.getBindGroupLayout(0), entries: h }), f = i.beginComputePass();
      f.setPipeline(e), f.setBindGroup(0, c);
      let g = t.dstWidth, m = t.dstHeight;
      if (a && (g = Math.max(1, Math.floor(t.dstWidth / 8)), m = Math.max(1, Math.floor(t.dstHeight / 8))), f.dispatchWorkgroups(g, m), t.dstHeight *= 0.5, t.dstWidth *= 0.5, t.srcView = o, t.mipLevel = l + 1, n = a && (t.dstWidth < 8 || t.dstHeight < 8), f.end(), n)
        break;
    }
    y.endCommandEncoder(i), n && this.mipmap(this._pipelineMin, t);
  }
};
__publicField(kp, "codeMax", `
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `);
__publicField(kp, "codeMin", `
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `);
__publicField(kp, "_pipelineMax");
__publicField(kp, "_pipelineMin");
var kc = class {
  constructor() {
    __publicField(this, "name", "");
    __publicField(this, "passMap", /* @__PURE__ */ new Map());
  }
};
var Gc = class {
  constructor() {
    __publicField(this, "passType", "");
    __publicField(this, "shaderState", /* @__PURE__ */ new Map());
    __publicField(this, "vertexShader", "");
    __publicField(this, "fragmentShader", "");
  }
};
var Gp = class {
  static parser(e, t) {
    e = Dt.filterComment(e);
    let r = new kc(), i = e.indexOf(this.shaderKeyword), a = e.indexOf("{", i), o = e.substring(i + this.shaderKeyword.length, a).trim();
    r.name = o.substring(1, o.length - 1), o = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
    let n = this.splitPassBlock(o);
    for (let l of n) {
      let h = this.parserPassBlock(l), u;
      r.passMap.has(h.passType) ? u = r.passMap.get(h.passType) : (u = [], r.passMap.set(h.passType, u)), u.push(h), h.vertexShader.length > 0 && (h.vertexShader = Dt.parse(h.vertexShader, t)), h.fragmentShader.length > 0 && (h.fragmentShader = Dt.parse(h.fragmentShader, t));
    }
    return r;
  }
  static splitPassBlock(e) {
    let t = 0, r = [];
    for (; t < e.length; ) {
      let i = e.indexOf(this.passKeyword, t);
      if (i == -1) {
        r.push(e.substring(t));
        break;
      }
      t != 0 && r.push(e.substring(t, i)), t = i + this.passKeyword.length;
    }
    return r;
  }
  static parserPassBlock(e) {
    let t = new Gc(), r = e.indexOf(this.passTypeKeyword), i = e.indexOf('"', r);
    return r = e.indexOf('"', i + 1), t.passType = e.substring(r + 1, i).trim(), this.parserShaderState(t, e), r = e.indexOf(this.vertexKeyword), r != -1 && (t.vertexShader = this.extractBlock(e.substring(r + this.vertexKeyword.length), "{", "}")), r = e.indexOf(this.fragmentKeyword), r != -1 && (t.fragmentShader = this.extractBlock(e.substring(r + this.fragmentKeyword.length), "{", "}")), t;
  }
  static parserShaderState(e, t) {
    let r = t.indexOf("ShaderState");
    if (r == -1)
      return false;
    r = t.indexOf("{", r);
    let i = t.indexOf("}", r), o = t.substring(r + 1, i).split(",");
    for (let n of o) {
      let l = n.split(":"), h = l[0].trim(), u = this.convertValue(l[1].trim());
      e.shaderState.set(h, u);
    }
    return true;
  }
  static convertValue(e) {
    return e.length == 4 && e.toLowerCase() == "true" ? true : e.length == 5 && e.toLowerCase() == "false" ? false : e[0] == '"' ? e.substring(1, e.length - 1) : Number.parseInt(e);
  }
  static extractBlock(e, t, r) {
    let i = e.indexOf(t);
    if (i == -1)
      return "";
    let a = 0, o = 0;
    e = e.substring(i);
    for (let l of e) {
      if (l == t ? a++ : l == r && a--, a <= 0)
        break;
      o++;
    }
    return e.substring(1, o).trim();
  }
};
__publicField(Gp, "passKeyword", "pass");
__publicField(Gp, "shaderKeyword", "Shader");
__publicField(Gp, "vertexKeyword", "vertex");
__publicField(Gp, "fragmentKeyword", "fragment");
__publicField(Gp, "passTypeKeyword", "PassType");
var Qc = new ze("IrradianceDataReaderCompleteEvent");
var oa = class _oa extends qt {
  constructor() {
    super(...arguments);
    __publicField(this, "readFlag", false);
    __publicField(this, "probeRenderer");
    __publicField(this, "opColorBuffer");
    __publicField(this, "opDepthBuffer");
    __publicField(this, "srcColorMap");
    __publicField(this, "srcDepthMap");
    __publicField(this, "opDepthArray");
    __publicField(this, "opColorArray");
  }
  initReader(e, t, r) {
    this.probeRenderer = e, this.srcColorMap = t, this.srcDepthMap = r;
    let i = p.setting.gi, a = i.octRTMaxSize * i.octRTMaxSize;
    this.opColorBuffer = w.device.createBuffer({ size: a * 4 * 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ, mappedAtCreation: false }), this.opColorArray = new Float32Array(a * 4), this.opDepthBuffer = w.device.createBuffer({ size: a * 4 * 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ, mappedAtCreation: false }), this.opDepthArray = new Float32Array(a * 4), this.probeRenderer.addEventListener(qs.type, () => {
      this.onProbeRenderComplete();
    }, this), this.probeRenderer.addEventListener(_a2.type, () => {
      console.log("GIRenderStartEvent");
    }, this);
  }
  async onProbeRenderComplete() {
    if (console.log("GIRenderCompleteEvent"), this.readFlag)
      console.log("irradianceDataReader is reading yet!!!");
    else {
      this.readFlag = true;
      let e = Date.now();
      console.log("irradianceDataReader start reading "), await _oa.read(this.srcColorMap.getGPUTexture(), this.opColorBuffer, this.opColorArray), await _oa.read(this.srcDepthMap.getGPUTexture(), this.opDepthBuffer, this.opDepthArray), this.readFlag = false, console.log("process time :", Date.now() - e), console.log("irradianceDataReader read complete"), this.dispatchEvent(Qc);
    }
  }
  static async read(e, t, r) {
    let i = y.beginCommandEncoder();
    i.copyTextureToBuffer({ texture: e }, { buffer: t, bytesPerRow: e.width * 16 }, [e.width, e.height]), y.endCommandEncoder(i), await t.mapAsync(GPUMapMode.READ);
    const a = t.getMappedRange();
    r.set(new Float32Array(a), 0), t.unmap();
  }
};
var Qp = new oa();
var Vc = class extends je {
  constructor(e = Ai.triangle_list) {
    super(), O.register("Graphic3DShader", Gu);
    let t = new ve("Graphic3DShader", "Graphic3DShader");
    t.setShaderEntry("VertMain", "FragMain"), t.noticeValueChange();
    let r = new Qe();
    r.addRenderPass(t), this.shader = r;
    let i = t.shaderState;
    i.acceptShadow = false, i.castShadow = false, i.receiveEnv = false, i.acceptGI = false, i.useLight = false, i.topology = e;
  }
};
var Vp = class extends Bt {
};
var Hp = class extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "texture");
    __publicField(this, "transformBuffer");
    __publicField(this, "nodeStructBuffer");
    __publicField(this, "drawAtomicBuffer");
    __publicField(this, "object3Ds");
    __publicField(this, "nodes");
    __publicField(this, "_initCompute", false);
    __publicField(this, "_needCompute", false);
    __publicField(this, "_onBufferChange", false);
    __publicField(this, "_onStartKernel");
    __publicField(this, "_onChangeKernelGroup");
    __publicField(this, "_onFrameKernelGroup");
    __publicField(this, "nodeMat");
    __publicField(this, "maxFaceCount");
    __publicField(this, "maxNodeCount");
    __publicField(this, "_nodeStruct");
  }
  init(e) {
    super.init(e);
    let { maxFaceCount: t, maxNodeCount: r } = e;
    this.maxFaceCount = t, this.maxNodeCount = r, this._onStartKernel = [], this._onChangeKernelGroup = [], this._onFrameKernelGroup = [], this.initGeometryBuffer(), this.initMaterial(), this.initBaseBuffer(), this.createComputeKernel();
  }
  initGeometryBuffer() {
    let e = new Po(this.maxFaceCount);
    this.geometry = e;
  }
  initMaterial() {
    this.material = this.nodeMat = new zi(), this.transformBuffer = new $(this.maxNodeCount * (8 * 4), 0), this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
  }
  initBaseBuffer() {
    this.drawAtomicBuffer = new $(4), this.drawAtomicBuffer.setUint32("skipFace", 0), this.drawAtomicBuffer.setUint32("skipFace2", this.maxNodeCount), this.drawAtomicBuffer.setUint32("skipFace3", this.maxFaceCount), this.drawAtomicBuffer.setUint32("skipFace4", 0);
  }
  createComputeKernel() {
  }
  set(e, t, r) {
    this._nodeStruct = e, this.nodeMat.baseMap = t, this.nodes = [], this.nodeStructBuffer = new Ni(e, this.maxNodeCount);
    for (let u = 0; u < this.maxNodeCount; u++)
      this.nodes.push(new e());
    this.nodeStructBuffer.setStructArray(e, this.nodes), this.nodeStructBuffer.apply(), this.object3Ds = [];
    let i, a = new M(1, 1, 1, 1), o = new M(0, 0, 0, 0), n = new G(0, 0, 0.1, 0.1), l = new G(0, 0, 0, 0), h = new d(0, 0, 0);
    for (let u = 0; u < this.maxNodeCount; u++) {
      if (r) {
        const c = new Y();
        this.object3Ds.push(c), this.object3D.addChild(c), i = c;
      } else
        i = this.object3D;
      this.transformBuffer.setFloat("matrix_" + u, i.transform.worldMatrix.index), this.transformBuffer.setFloat("texId_" + u, 0), this.transformBuffer.setFloat("texId2_" + u, 0), this.transformBuffer.setFloat("texId3_" + u, 0), this.transformBuffer.setFloat("fillRotation_" + u, 0), this.transformBuffer.setVector3("empty_" + u, h), this.transformBuffer.setColor("baseColor_" + u, a), this.transformBuffer.setColor("lineColor_" + u, a), this.transformBuffer.setColor("emissiveColor_" + u, o), this.transformBuffer.setVector4("uvRect_" + u, n), this.transformBuffer.setVector4("uvRect2_" + u, n), this.transformBuffer.setVector4("uvSpeed_" + u, l);
    }
    this.transformBuffer.apply(), this.start = () => {
      for (const u of this._onStartKernel)
        u.setStorageBuffer("globalUniform", oe.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer), u.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer), u.setStorageBuffer("drawBuffer", this.drawAtomicBuffer), u.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
      for (const u of this._onChangeKernelGroup)
        u.setStorageBuffer("globalUniform", oe.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer), u.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer), u.setStorageBuffer("drawBuffer", this.drawAtomicBuffer), u.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
      for (const u of this._onFrameKernelGroup)
        u.setStorageBuffer("globalUniform", oe.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer), u.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer), u.setStorageBuffer("drawBuffer", this.drawAtomicBuffer), u.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
    };
  }
  setNodeStruct(e, t) {
    this.nodeStructBuffer.setStruct(this._nodeStruct, e, t), this.nodes || (this.nodes = []), this.nodes[e] = t, this.nodeStructBuffer.apply();
  }
  updateShape() {
    for (let e = 0; e < this.nodes.length; e++) {
      const t = this.nodes[e];
      this.nodeStructBuffer.setStruct(this._nodeStruct, e, t);
    }
    this.nodeStructBuffer.apply(), this._needCompute = true;
  }
  setTextureID(e, t) {
    this.transformBuffer.setFloat("texId_" + e, t), this._onBufferChange = true;
  }
  setLineTextureID(e, t) {
    this.transformBuffer.setFloat("texId2_" + e, t), this._onBufferChange = true;
  }
  setBaseColor(e, t) {
    this.transformBuffer.setColor("baseColor_" + e, t), this._onBufferChange = true;
  }
  setLineColor(e, t) {
    this.transformBuffer.setColor("lineColor_" + e, t), this._onBufferChange = true;
  }
  setEmissiveColor(e, t) {
    this.transformBuffer.setColor("emissiveColor_" + e, t), this._onBufferChange = true;
  }
  setFillRotation(e, t) {
    this.transformBuffer.setFloat("fillRotation_" + e, t), this._onBufferChange = true;
  }
  setUVRect(e, t) {
    this.transformBuffer.setVector4("uvRect_" + e, t), this._onBufferChange = true;
  }
  setUVRect2(e, t) {
    this.transformBuffer.setVector4("uvRect2_" + e, t), this._onBufferChange = true;
  }
  setUVSpeed(e, t) {
    this.transformBuffer.setVector4("uvSpeed_" + e, t), this._onBufferChange = true;
  }
  onUpdate(e) {
    this._onBufferChange && (this._onBufferChange = false, this.transformBuffer.apply());
  }
  onCompute(e, t) {
    this.drawAtomicBuffer.apply(), this._initCompute || (this._initCompute = true, this.onStartCompute(e, t)), this._needCompute && (this._needCompute = false, this.onChangeCompute(e, t)), this.onFrameCompute(e, t);
  }
  onStartCompute(e, t) {
    y.computeCommand(t, this._onStartKernel);
  }
  onChangeCompute(e, t) {
    y.computeCommand(t, this._onChangeKernelGroup);
  }
  onFrameCompute(e, t) {
    y.computeCommand(t, this._onFrameKernelGroup);
  }
};
var Yp = class {
  static wirteVec4(e, t, r) {
    e[t * 4 + 0] = r.x, e[t * 4 + 1] = r.y, e[t * 4 + 2] = r.z, e[t * 4 + 3] = r.w;
  }
};
var Xp = Object.defineProperty;
var Wp = Object.getOwnPropertyDescriptor;
var jp = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Wp(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Xp(e, t, i), i;
};
var Ua = class extends Qe {
  constructor() {
    super(), O.register("VertexAttributeIndexShader", ku), O.register("UnLitTextureArray", Ku);
    let s = new ve("UnLitTextureArray", "UnLitTextureArray");
    s.setShaderEntry("VertMain", "FragMain"), this.addRenderPass(s);
    let e = s.shaderState;
    e.acceptShadow = false, e.castShadow = false, e.receiveEnv = false, e.acceptGI = false, e.useLight = false, this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefault();
  }
  setDefault() {
    this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor", new M()), this.setUniformFloat("alphaCutoff", 0);
  }
  set _MainTex(s) {
    this.setTexture("baseMap", s);
  }
  set _BumpMap(s) {
    this.setTexture("normalMap", s);
  }
  set _MaskTex(s) {
    this.setTexture("maskMap", s);
  }
  set _UVTransform(s) {
    this.setUniformVector4("transformUV1", s);
  }
  set _Metallic(s) {
    this.setUniformFloat("metallic", s);
  }
  set _Roughness(s) {
    this.setUniformFloat("roughness", s);
  }
  set _MainColor(s) {
    this.setUniformColor("baseColor", s);
  }
  set _AlphaCutoff(s) {
    this.setUniformFloat("alphaCutoff", s);
  }
  set _DoubleSidedEnable(s) {
    let e = this.getDefaultColorShader();
    e.shaderState.cullMode = s ? nt.none : e.shaderState.cullMode;
  }
  set _SurfaceType(s) {
    let e = this.getDefaultColorShader();
    s == 0 ? e.blendMode = re.NONE : e.blendMode = re.ALPHA;
  }
  set _AlphaCutoffEnable(s) {
    s == 0 ? this.setDefine("USE_ALPHACUT", false) : this.setDefine("USE_ALPHACUT", true);
  }
};
Ua = jp([Kt], Ua);
var zi = class extends je {
  constructor() {
    super(), this.shader = new Ua(), this.baseMap = p.res.whiteTexture;
  }
  set baseMap(e) {
    this.shader.setTexture("baseMap", e);
  }
  get baseMap() {
    return this.shader.getTexture("baseMap");
  }
  set baseColor(e) {
    this.shader.setUniformColor("baseColor", e);
  }
  get baseColor() {
    return this.shader.getUniformColor("baseColor");
  }
  set shadowMap(e) {
  }
};
var Po = class extends xe {
  constructor(e) {
    super();
    __publicField(this, "faceCount", 0);
    this.faceCount = e, this.buildGeometry();
  }
  buildGeometry() {
    let e = new Uint32Array(this.faceCount * 3), t = new Float32Array(this.faceCount * 3 * 3), r = new Float32Array(this.faceCount * 3 * 3), i = new Float32Array(this.faceCount * 3 * 2), a = new Float32Array(this.faceCount * 3 * 1);
    for (let o = 0; o < this.faceCount; o++) {
      let n = o * 3 + 0, l = o * 3 + 1, h = o * 3 + 2;
      e[n] = n, e[l] = l, e[h] = h;
    }
    this.setIndices(e), this.setAttribute(D.position, t), this.setAttribute(D.normal, r), this.setAttribute(D.uv, i), this.setAttribute(D.TEXCOORD_1, i), this.setAttribute(D.vIndex, a), this.addSubGeometry({ indexStart: 0, indexCount: e.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
  }
};
var qp = Object.defineProperty;
var Kp = Object.getOwnPropertyDescriptor;
var Jp = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Kp(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && qp(e, t, i), i;
};
var Mr = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "shapeIndex", 0);
    __publicField(this, "shapeType", 0);
    __publicField(this, "width", 0);
    __publicField(this, "lineCap", 0);
    __publicField(this, "pathCount", 0);
    __publicField(this, "uScale", 0);
    __publicField(this, "vScale", 0);
    __publicField(this, "lineJoin", 0);
    __publicField(this, "startPath", 0);
    __publicField(this, "endPath", 0);
    __publicField(this, "uSpeed", 0);
    __publicField(this, "vSpeed", 0);
    __publicField(this, "paths", []);
  }
};
Jp([xi], Mr.prototype, "paths", 2);
var Hc = ((s) => (s[s.bevel = 0] = "bevel", s[s.miter = 1] = "miter", s[s.round = 2] = "round", s))(Hc || {});
var Yc = ((s) => (s[s.butt = 0] = "butt", s[s.square = 1] = "square", s[s.round = 2] = "round", s))(Yc || {});
var Zp = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "skipFace", 0);
    __publicField(this, "skipFace2", 0);
    __publicField(this, "skipFace3", 0);
    __publicField(this, "skipFace4", 0);
  }
};
var La = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "index", 0);
    __publicField(this, "faceStart", 0);
    __publicField(this, "faceEnd", 0);
    __publicField(this, "faceCount", 0);
  }
};
var _Ft = class _Ft extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "texture");
    __publicField(this, "transformBuffer");
    __publicField(this, "_onChange", false);
    __publicField(this, "_computeGeoShader");
    __publicField(this, "geometryInfoBuffer");
    __publicField(this, "shapeBuffer");
    __publicField(this, "pathBuffer");
    __publicField(this, "drawBuffer");
    __publicField(this, "object3Ds");
    __publicField(this, "shapes");
    __publicField(this, "realDrawShape");
    __publicField(this, "needUpdate", false);
  }
  init() {
    super.init();
  }
  create(e, t) {
    this._computeGeoShader = new ae(Qu()), this.geometryInfoBuffer = new Ni(La, _Ft.maxGeometryCount), this.shapeBuffer = new Ni(Mr, _Ft.maxShapeCount), this.pathBuffer = new $(_Ft.maxPathPointCount * 4), this.drawBuffer = new $(4);
    let r = new Po(_Ft.maxFaceCount), i = new zi();
    i.baseMap = e, this.material = i, this.transformBuffer = new $(t * (7 * 4), 0), this.material.setStorageBuffer("graphicBuffer", this.transformBuffer), this.object3Ds = [];
    for (let a = 0; a < t; a++) {
      const o = new Y();
      this.object3Ds.push(o), this.object3D.addChild(o), this.transformBuffer.setFloat("matrix_" + a, o.transform.worldMatrix.index), this.transformBuffer.setFloat("texId_" + a, 1), this.transformBuffer.setFloat("texId2_" + a, 1), this.transformBuffer.setFloat("texId3_" + a, 1), this.transformBuffer.setColor("baseColor_" + a, new M()), this.transformBuffer.setColor("lineColor_" + a, new M()), this.transformBuffer.setColor("emissiveColor_" + a, new M(0, 0, 0, 0)), this.transformBuffer.setVector4("uvRect_" + a, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvRect2_" + a, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvSpeed_" + a, new G(0, 0, 0, 0)), console.log("create dynamic geometry", a);
    }
    this.transformBuffer.apply(), this.geometry = r;
  }
  startShape(e) {
    this.create(e, _Ft.maxGeometryCount);
    let t = [];
    for (let r = 0; r < _Ft.maxGeometryCount; r++) {
      const i = new La();
      t.push(i);
    }
    this.geometryInfoBuffer.setStructArray(La, t), this.geometryInfoBuffer.apply(), this.shapes = [];
    for (let r = 0; r < _Ft.maxShapeCount; r++)
      this.shapes.push(new Mr());
    this.shapeBuffer.setStructArray(Mr, this.shapes), this.shapeBuffer.apply(), this.start = () => {
      this._computeGeoShader.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer), this._computeGeoShader.setStructStorageBuffer("geometryInfoBuffer", this.geometryInfoBuffer), this._computeGeoShader.setStructStorageBuffer("shapeBuffer", this.shapeBuffer), this._computeGeoShader.setStorageBuffer("pathBuffer", this.pathBuffer), this._computeGeoShader.setStorageBuffer("drawBuffer", this.drawBuffer), this._computeGeoShader.setStorageBuffer("globalUniform", oe.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
    };
  }
  setShape(e, t) {
    this.shapeBuffer.setStruct(Mr, e, t), this.shapes || (this.shapes = []), this.shapes[e] = t, this.shapeBuffer.apply();
  }
  updateShape() {
    let e = 0;
    this.realDrawShape = 0;
    for (let t = 0; t < this.shapes.length; t++) {
      const r = this.shapes[t];
      r.pathCount = r.paths.length, r.pathCount > 0 && this.realDrawShape++, r.startPath = e, e += r.paths.length;
      for (let i = 0; i < r.pathCount; i++)
        this.pathBuffer.setVector4(`${t}_path_${i}`, r.paths[i]);
      this.shapeBuffer.setStruct(Mr, t, r);
    }
    this.shapeBuffer.apply(), this.pathBuffer.apply(), this.needUpdate = true;
  }
  setTextureID(e, t) {
    this.transformBuffer.setFloat("texId_" + e, t), this._onChange = true;
  }
  setBaseColor(e, t) {
    this.transformBuffer.setColor("baseColor_" + e, t), this._onChange = true;
  }
  setEmissiveColor(e, t) {
    this.transformBuffer.setColor("emissiveColor_" + e, t), this._onChange = true;
  }
  setUVRect(e, t) {
    this.transformBuffer.setVector4("uvRect_" + e, t), this._onChange = true;
  }
  onUpdate(e) {
    this._onChange && (this._onChange = false, this.transformBuffer.apply());
  }
  onCompute(e, t) {
    this.needUpdate && (this.needUpdate = false, this.computeTrail(e, t));
  }
  computeTrail(e, t) {
    this._computeGeoShader.workerSizeX = this.realDrawShape, this._computeGeoShader.workerSizeY = Math.floor(_Ft.maxPathPointCount / 256 + 1), this._computeGeoShader.workerSizeZ = 1, y.computeCommand(t, [this._computeGeoShader]);
  }
};
__publicField(_Ft, "maxFaceCount", 1e6);
__publicField(_Ft, "maxGeometryCount", 1);
__publicField(_Ft, "maxPathPointCount", 1e5);
__publicField(_Ft, "maxShapeCount", 1024);
var Ft = _Ft;
var Mo = class {
  static merge(e, t, r) {
  }
  static mergeNumber(e, t, r) {
    let i = r || new xe(), a = e.getAttribute(D.position).data.length / 3, o = new Float32Array(a * t);
    for (const u of e.vertexAttributeMap) {
      let c = u[1].attribute;
      if (c == D.indices)
        continue;
      let f = e.getAttribute(c).data, g = f.length, m = new Float32Array(g * t);
      for (let A = 0; A < t; A++) {
        m.set(f, g * A);
        for (let _ = 0; _ < a; _++)
          o[a * A + _] = A;
      }
      i.setAttribute(c, m);
    }
    i.setAttribute(D.vIndex, o);
    let n = e.getAttribute(D.indices).data, l = n.length, h = new Uint32Array(n.length * t);
    for (let u = 0; u < t; u++)
      for (let c = 0; c < l; c++) {
        let f = u * a, g = u * l;
        const m = n[c] + f;
        h[g + c] = m;
      }
    return i.setIndices(h), i.addSubGeometry({ indexStart: 0, indexCount: h.length, vertexStart: 0, index: 0, vertexCount: 0, firstStart: 0, topology: 0 }), i;
  }
  static generateNormal() {
  }
  static generateTangent() {
  }
  static packUV() {
  }
};
var Xc = class extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "transformBuffer");
    __publicField(this, "sourceGeometry");
    __publicField(this, "texture");
    __publicField(this, "object3Ds");
    __publicField(this, "_onChange", false);
    __publicField(this, "_computeShader");
  }
  init() {
    super.init();
  }
  create(e, t, r) {
    let i = new zi();
    i.baseMap = t, this.material = i, this.transformBuffer = new $(r * (8 * 4), 0), this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
    let a = new d(0, 0, 0);
    this.object3Ds = [];
    for (let o = 0; o < r; o++) {
      const n = new Y();
      this.object3Ds.push(n), this.object3D.addChild(n), this.transformBuffer.setFloat("matrix_" + o, n.transform.worldMatrix.index), this.transformBuffer.setFloat("texId_" + o, 1), this.transformBuffer.setFloat("texId2_" + o, 1), this.transformBuffer.setFloat("texId3_" + o, 1), this.transformBuffer.setFloat("texId3_" + o, 1), this.transformBuffer.setFloat("fillRotation_" + o, 0), this.transformBuffer.setVector3("empty_" + o, a), this.transformBuffer.setColor("baseColor_" + o, new M()), this.transformBuffer.setColor("lineColor_" + o, new M()), this.transformBuffer.setColor("emissiveColor_" + o, new M(0, 0, 0, 0)), this.transformBuffer.setVector4("uvRect_" + o, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvRect2_" + o, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvSpeed_" + o, new G(0, 0, 0, 0));
    }
    this.transformBuffer.apply(), this.geometry = Mo.mergeNumber(e, r);
  }
  setTextureID(e, t) {
    this.transformBuffer.setFloat("texId_" + e, t), this._onChange = true;
  }
  setBaseColor(e, t) {
    this.transformBuffer.setColor("baseColor_" + e, t), this._onChange = true;
  }
  setEmissiveColor(e, t) {
    this.transformBuffer.setColor("emissiveColor_" + e, t), this._onChange = true;
  }
  setUVRect(e, t) {
    this.transformBuffer.setVector4("uvRect_" + e, t), this._onChange = true;
  }
  onUpdate(e) {
    this._onChange && (this._onChange = false, this.transformBuffer.apply());
  }
  computeTrail(e, t) {
    y.computeCommand(t, [this._computeShader]);
  }
};
var Wc = class extends xe {
  constructor(e) {
    super();
    __publicField(this, "segment");
    __publicField(this, "row", 0);
    this.segment = e, this.buildGeometry();
  }
  buildGeometry() {
    this.row = this.segment + 1;
    let e = new Uint32Array(this.segment * 6), t = new Float32Array(this.row * 3 * 2), r = new Float32Array(this.row * 3 * 2), i = new Float32Array(this.row * 2 * 2);
    for (let a = 0; a < this.row; a++) {
      t[a * 3 * 2 + 0] = 0, t[a * 3 * 2 + 1] = 0, t[a * 3 * 2 + 2] = 0, t[a * 3 * 2 + 3] = 0, t[a * 3 * 2 + 4] = 0, t[a * 3 * 2 + 5] = 0, r[a * 3 * 2 + 0] = 0, r[a * 3 * 2 + 1] = 0, r[a * 3 * 2 + 2] = 1, r[a * 3 * 2 + 3] = 0, r[a * 3 * 2 + 4] = 0, r[a * 3 * 2 + 5] = 1, i[a * 2 * 2 + 0] = 0, i[a * 2 * 2 + 1] = a / this.segment, i[a * 2 * 2 + 2] = 1, i[a * 2 * 2 + 3] = a / this.segment;
      let o = a * 2, n = o, l = o + 1, h = o + 2, u = o + 3;
      e[a * 6 + 0] = n, e[a * 6 + 1] = l, e[a * 6 + 2] = h, e[a * 6 + 3] = l, e[a * 6 + 4] = u, e[a * 6 + 5] = h;
    }
    this.setIndices(e), this.setAttribute(D.position, t), this.setAttribute(D.normal, r), this.setAttribute(D.uv, i), this.setAttribute(D.TEXCOORD_1, i), this.addSubGeometry({ indexStart: 0, indexCount: e.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
  }
};
var $p = Object.defineProperty;
var em = Object.getOwnPropertyDescriptor;
var tm = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? em(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && $p(e, t, i), i;
};
var jc = ((s) => (s[s.FaceToCamera = 0] = "FaceToCamera", s[s.FaceToPath = 1] = "FaceToPath", s[s.FaceToUp = 2] = "FaceToUp", s))(jc || {});
var ki = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "index", 1);
    __publicField(this, "segment", 5);
    __publicField(this, "visible", 1);
    __publicField(this, "width", 0.25);
    __publicField(this, "uv", new G(0, 0, 1, 30));
    __publicField(this, "uvSpeed", new Q(0, 2.1));
    __publicField(this, "smooth", 0);
    __publicField(this, "faceMode", 0);
    __publicField(this, "up", new G(0, 1, 0));
    __publicField(this, "ids", new Float32Array(ni.maxRibbonSegment));
    __publicField(this, "ribbonPoint", []);
  }
};
tm([xi], ki.prototype, "ribbonPoint", 2);
var _ni = class _ni extends J {
  constructor() {
    super(...arguments);
    __publicField(this, "transformBuffer");
    __publicField(this, "sourceGeometry");
    __publicField(this, "texture");
    __publicField(this, "object3Ds");
    __publicField(this, "ribbons");
    __publicField(this, "ribbonCount", 10);
    __publicField(this, "_onChange", false);
    __publicField(this, "_computeShader");
    __publicField(this, "_ribbonBuffer");
    __publicField(this, "ribbonSegment");
  }
  init() {
    super.init();
  }
  create(e, t, r) {
    this.ribbons = [], this.ribbonSegment = e;
    for (let o = 0; o < r; o++)
      this.ribbons[o] = new ki(), this.ribbons[o].index = o, this.ribbons[o].segment = e, this.ribbons[o].width = 0.5, this.ribbons[o].faceMode = 0;
    let i = new Wc(e), a = new zi();
    a.baseMap = t, this.material = a, this.transformBuffer = new $(r * (7 * 4), 0), this.material.setStorageBuffer("graphicBuffer", this.transformBuffer), this.object3Ds = [];
    for (let o = 0; o < r; o++) {
      const n = new Y();
      this.object3Ds.push(n), this.object3D.addChild(n), this.transformBuffer.setFloat("matrix_" + o, n.transform.worldMatrix.index), this.transformBuffer.setFloat("texId_" + o, 1), this.transformBuffer.setFloat("texId2_" + o, 1), this.transformBuffer.setFloat("texId3_" + o, 1), this.transformBuffer.setColor("baseColor_" + o, new M()), this.transformBuffer.setColor("lineColor_" + o, new M()), this.transformBuffer.setColor("emissiveColor_" + o, new M(0, 0, 0, 0)), this.transformBuffer.setVector4("uvRect_" + o, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvRect2_" + o, new G(0, 0, 1, 1)), this.transformBuffer.setVector4("uvSpeed_" + o, new G(0, 0, 0, 0));
    }
    this.transformBuffer.apply(), this.geometry = Mo.mergeNumber(i, r);
  }
  startRibbon(e, t, r) {
    this.ribbonCount = r, this.create(t, e, r), this._computeShader = new ae(Vu(_ni.maxRibbonSegment)), this._ribbonBuffer = new Ni(ki, r);
    for (let i = 0; i < r; i++) {
      this.ribbons[i].ribbonPoint = [];
      for (let a = 0; a < _ni.maxRibbonSegment; a++) {
        const o = new Y();
        this.object3D.addChild(o), this.ribbons[i].ribbonPoint[a] = o, this.ribbons[i].ids[a] = o.transform.worldMatrix.index;
      }
    }
    this._ribbonBuffer.setStructArray(ki, this.ribbons), this._ribbonBuffer.apply(), this.start = () => {
      this._computeShader.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer), this._computeShader.setStorageBuffer("trailBuffer", this._ribbonBuffer), this._computeShader.setStorageBuffer("models", oe.modelMatrixBindGroup.matrixBufferDst), this._computeShader.setStorageBuffer("globalUniform", oe.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
    }, this.onCompute = (i, a) => this.computeTrail(i, a);
  }
  setTextureID(e, t) {
    this.transformBuffer.setFloat("texId_" + e, t), this._onChange = true;
  }
  setBaseColor(e, t) {
    this.transformBuffer.setColor("baseColor_" + e, t), this._onChange = true;
  }
  setEmissiveColor(e, t) {
    this.transformBuffer.setColor("emissiveColor_" + e, t), this._onChange = true;
  }
  setUVRect(e, t) {
    this.transformBuffer.setVector4("uvRect_" + e, t), this._onChange = true;
  }
  setLineUVRect(e, t) {
    this.transformBuffer.setVector4("uvRect1_" + e, t), this._onChange = true;
  }
  onUpdate(e) {
    this._onChange && (this._onChange = false, this.transformBuffer.apply());
  }
  computeTrail(e, t) {
    this._computeShader.workerSizeX = this.ribbonCount, this._computeShader.workerSizeY = 1, y.computeCommand(t, [this._computeShader]);
  }
};
__publicField(_ni, "maxRibbonSegment", 256);
var ni = _ni;
var rm = class {
  static draw(e, t, r, i) {
    if (!this.meshMap.has(t)) {
      let a = new Y(), o = a.addComponent(Xc);
      return o.create(t, r, i), this.meshMap.set(t, o), e.addChild(a), o;
    }
  }
  static drawRibbon(e, t, r, i, a) {
    if (!this.ribbonMap.has(e)) {
      let o = new Y(), n = o.addComponent(ni);
      return n.startRibbon(r, i, a), this.ribbonMap.set(e, n), t.addChild(o), n;
    }
  }
  static drawShape(e, t, r) {
    if (!this.faceMap.has(e)) {
      let i = new Y(), a = i.addComponent(Ft);
      return a.startShape(r), this.faceMap.set(e, a), t.addChild(i), a;
    }
  }
  static drawNode(e, t, r, i, a, o, n, l) {
    if (!this.nodeMap.has(e)) {
      let h = new Y(), u = h.addComponent(t, { maxFaceCount: n || 4294967295 / 3, maxNodeCount: o });
      return u.set(r, a, l), this.nodeMap.set(e, u), i.addChild(h), u;
    }
  }
};
__publicField(rm, "meshMap", /* @__PURE__ */ new Map());
__publicField(rm, "meshDrawGroup", /* @__PURE__ */ new Map());
__publicField(rm, "ribbonMap", /* @__PURE__ */ new Map());
__publicField(rm, "nodeMap", /* @__PURE__ */ new Map());
__publicField(rm, "faceMap", /* @__PURE__ */ new Map());
var im = class {
  constructor() {
    __publicField(this, "computeShader");
    __publicField(this, "visibleBuffer");
    __publicField(this, "texture");
    this.computeShader = new ae(zu), this.visibleBuffer = new Kr(8192 * 2), this.computeShader.setStorageBuffer("visibleBuffer", this.visibleBuffer), this.texture = be.getTexture(Fe.zBufferTexture_NAME), this.computeShader.setSamplerTexture("zBufferTexture", this.texture), this.computeShader.workerSizeX = Math.ceil(this.texture.width / 8), this.computeShader.workerSizeY = Math.ceil(this.texture.height / 8), this.computeShader.workerSizeZ = 1;
  }
  compute(e, t) {
    this.visibleBuffer.reset(true, 0), this.visibleBuffer.apply();
    let r = y.beginCommandEncoder();
    y.computeCommand(r, [this.computeShader]), this.visibleBuffer.readBuffer(), t.zVisibleList = this.visibleBuffer.outFloat32Array;
  }
};
var am = class extends wt {
  constructor() {
    super();
    __publicField(this, "RT_BloomUp");
    __publicField(this, "RT_BloomDown");
    __publicField(this, "RT_threshold");
    __publicField(this, "rendererPassState");
    __publicField(this, "thresholdCompute");
    __publicField(this, "downSampleComputes");
    __publicField(this, "upSampleComputes");
    __publicField(this, "postCompute");
    __publicField(this, "bloomSetting");
    __publicField(this, "rtFrame");
    __publicField(this, "Render");
  }
  onAttach(e) {
    p.setting.render.postProcessing.bloom.enable = true, this.createGUI();
  }
  onDetach(e) {
    p.setting.render.postProcessing.bloom.enable = false, this.removeGUI();
  }
  createGUI() {
  }
  removeGUI() {
  }
  get downSampleBlurSize() {
    return p.setting.render.postProcessing.bloom.downSampleBlurSize;
  }
  set downSampleBlurSize(e) {
    p.setting.render.postProcessing.bloom.downSampleBlurSize = e;
  }
  get downSampleBlurSigma() {
    return p.setting.render.postProcessing.bloom.downSampleBlurSigma;
  }
  set downSampleBlurSigma(e) {
    p.setting.render.postProcessing.bloom.downSampleBlurSigma = e;
  }
  get upSampleBlurSize() {
    return p.setting.render.postProcessing.bloom.upSampleBlurSize;
  }
  set upSampleBlurSize(e) {
    p.setting.render.postProcessing.bloom.upSampleBlurSize = e;
  }
  get upSampleBlurSigma() {
    return p.setting.render.postProcessing.bloom.upSampleBlurSigma;
  }
  set upSampleBlurSigma(e) {
    p.setting.render.postProcessing.bloom.upSampleBlurSigma = e;
  }
  get luminanceThreshole() {
    return p.setting.render.postProcessing.bloom.luminanceThreshole;
  }
  set luminanceThreshole(e) {
    p.setting.render.postProcessing.bloom.luminanceThreshole = e;
  }
  get bloomIntensity() {
    return p.setting.render.postProcessing.bloom.bloomIntensity;
  }
  set bloomIntensity(e) {
    p.setting.render.postProcessing.bloom.bloomIntensity = e;
  }
  createThreshouldCompute() {
    this.thresholdCompute = new ae(Cu), this.autoSetColorTexture("inTex", this.thresholdCompute), this.thresholdCompute.setStorageTexture("outTex", this.RT_threshold), this.thresholdCompute.setUniformBuffer("bloomCfg", this.bloomSetting), this.thresholdCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8), this.thresholdCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8), this.thresholdCompute.workerSizeZ = 1;
  }
  createDownSampleComputes() {
    const t = p.setting.render.postProcessing.bloom.downSampleStep;
    this.downSampleComputes = [];
    for (let r = 0; r < t; r++) {
      let i = new ae(Su), a = this.RT_BloomDown[r], o = r == 0 ? this.RT_threshold : this.RT_BloomDown[r - 1];
      i.setSamplerTexture("inTex", o), i.setStorageTexture("outTex", a), i.setUniformBuffer("bloomCfg", this.bloomSetting), i.workerSizeX = Math.ceil(a.width / 8), i.workerSizeY = Math.ceil(a.height / 8), i.workerSizeZ = 1, this.downSampleComputes.push(i);
    }
  }
  createUpSampleComputes() {
    const t = p.setting.render.postProcessing.bloom.downSampleStep;
    this.upSampleComputes = [];
    {
      let r = new ae(wo), i = this.RT_BloomUp[0], a = this.RT_BloomDown[t - 2];
      r.setSamplerTexture("_MainTex", a), r.setSamplerTexture("_PrevMip", this.RT_BloomDown[t - 1]), r.setStorageTexture("outTex", i), r.setUniformBuffer("bloomCfg", this.bloomSetting), r.workerSizeX = Math.ceil(i.width / 8), r.workerSizeY = Math.ceil(i.height / 8), r.workerSizeZ = 1, this.upSampleComputes.push(r);
    }
    for (let r = 1; r < t - 1; r++) {
      let i = new ae(wo), a = this.RT_BloomUp[r], o = this.RT_BloomDown[t - 2 - r];
      i.setSamplerTexture("_MainTex", o), i.setSamplerTexture("_PrevMip", this.RT_BloomUp[r - 1]), i.setStorageTexture("outTex", a), i.setUniformBuffer("bloomCfg", this.bloomSetting), i.workerSizeX = Math.ceil(a.width / 8), i.workerSizeY = Math.ceil(a.height / 8), i.workerSizeZ = 1, this.upSampleComputes.push(i);
    }
  }
  createPostCompute() {
    const t = p.setting.render.postProcessing.bloom.downSampleStep;
    this.postCompute = new ae(yu), this.autoSetColorTexture("_MainTex", this.postCompute), this.postCompute.setSamplerTexture("_BloomTex", this.RT_BloomUp[t - 2]), this.postCompute.setStorageTexture("outTex", this.RT_threshold), this.postCompute.setUniformBuffer("bloomCfg", this.bloomSetting), this.postCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8), this.postCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8), this.postCompute.workerSizeZ = 1;
  }
  createResource() {
    let e = p.setting.render.postProcessing.bloom;
    this.bloomSetting = new ft(4 * 2);
    let t = w.presentationSize, r = t[0], i = t[1];
    this.RT_threshold = new de(r, i, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
    const a = e.downSampleStep;
    {
      let n = 2;
      this.RT_BloomDown = [];
      for (let l = 0; l < a; l++) {
        let h = Math.ceil(r / n), u = Math.ceil(i / n);
        this.RT_BloomDown[l] = new de(h, u, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), n *= 2;
      }
    }
    {
      this.RT_BloomUp = [];
      for (let n = 0; n < a - 1; n++) {
        let l = this.RT_BloomDown[a - 2 - n].width, h = this.RT_BloomDown[a - 2 - n].height;
        this.RT_BloomUp[n] = new de(l, h, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
      }
    }
    let o = new fe();
    o.loadOp = "load", this.rtFrame = new Ne([this.RT_threshold], [o]);
  }
  render(e, t) {
    this.thresholdCompute || (this.createResource(), this.createThreshouldCompute(), this.createDownSampleComputes(), this.createUpSampleComputes(), this.createPostCompute(), this.rendererPassState = ye.createRendererPassState(this.rtFrame, null), this.rendererPassState.label = "Bloom");
    let r = p.setting.render.postProcessing.bloom;
    this.bloomSetting.setFloat("downSampleStep", r.downSampleStep), this.bloomSetting.setFloat("downSampleBlurSize", r.downSampleBlurSize), this.bloomSetting.setFloat("downSampleBlurSigma", r.downSampleBlurSigma), this.bloomSetting.setFloat("upSampleBlurSize", r.upSampleBlurSize), this.bloomSetting.setFloat("upSampleBlurSigma", r.upSampleBlurSigma), this.bloomSetting.setFloat("luminanceThreshole", r.luminanceThreshole), this.bloomSetting.setFloat("bloomIntensity", r.bloomIntensity), this.bloomSetting.apply(), y.computeCommand(t, [this.thresholdCompute, ...this.downSampleComputes, ...this.upSampleComputes, this.postCompute]), y.lastRenderPassState = this.rendererPassState;
  }
  onResize() {
    let e = p.setting.render.postProcessing.bloom, t = w.presentationSize, r = t[0], i = t[1];
    this.RT_threshold.resize(r, i);
    const a = e.downSampleStep;
    let o = 2;
    for (let n = 0; n < a; n++) {
      let l = Math.ceil(r / o), h = Math.ceil(i / o);
      this.RT_BloomDown[n].resize(l, h), o *= 2;
    }
    for (let n = 0; n < a - 1; n++) {
      let l = this.RT_BloomDown[a - 2 - n].width, h = this.RT_BloomDown[a - 2 - n].height;
      this.RT_BloomUp[n].resize(l, h);
    }
    this.thresholdCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8), this.thresholdCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8), this.thresholdCompute.workerSizeZ = 1;
    for (let n = 0; n < a; n++) {
      let l = this.downSampleComputes[n], h = this.RT_BloomDown[n];
      l.workerSizeX = Math.ceil(h.width / 8), l.workerSizeY = Math.ceil(h.height / 8), l.workerSizeZ = 1;
    }
    {
      let n = this.RT_BloomUp[0], l = this.upSampleComputes[0];
      l.workerSizeX = Math.ceil(n.width / 8), l.workerSizeY = Math.ceil(n.height / 8), l.workerSizeZ = 1;
    }
    for (let n = 1; n < a - 1; n++) {
      let l = this.RT_BloomUp[n], h = this.upSampleComputes[n];
      h.workerSizeX = Math.ceil(l.width / 8), h.workerSizeY = Math.ceil(l.height / 8), h.workerSizeZ = 1;
    }
    this.postCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8), this.postCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8), this.postCompute.workerSizeZ = 1;
  }
};
var sm = class extends wt {
  constructor() {
    super();
    __publicField(this, "blurTexture1");
    __publicField(this, "blurTexture2");
    __publicField(this, "rendererPassState");
    __publicField(this, "blurComputes");
    __publicField(this, "blurSettings");
    __publicField(this, "outTexture");
    __publicField(this, "rtFrame");
  }
  onAttach(e) {
    p.setting.render.postProcessing.depthOfView.enable = true;
  }
  onDetach(e) {
    p.setting.render.postProcessing.depthOfView.enable = false;
  }
  get pixelOffset() {
    return p.setting.render.postProcessing.depthOfView.pixelOffset;
  }
  set pixelOffset(e) {
    e = Math.max(0, e);
    let t = p.setting.render.postProcessing.depthOfView;
    t.pixelOffset = e;
  }
  get near() {
    return p.setting.render.postProcessing.depthOfView.near;
  }
  set near(e) {
    e = Math.max(0, e);
    let t = p.setting.render.postProcessing.depthOfView;
    t.near = e;
  }
  get far() {
    return p.setting.render.postProcessing.depthOfView.far;
  }
  set far(e) {
    e = Math.max(0, e);
    let t = p.setting.render.postProcessing.depthOfView;
    t.far = e;
  }
  createBlurCompute() {
    this.blurSettings = [], this.blurComputes = [];
    let e = p.setting.render.postProcessing.depthOfView;
    for (let t = 0; t < e.iterationCount; t++) {
      let r = new ft(4), i = new ae(wu);
      this.blurComputes.push(i), this.blurSettings.push(r), i.setUniformBuffer("blurSetting", r);
      let a = Ee.getGBufferFrame("ColorPassGBuffer");
      i.setSamplerTexture(Fe.positionBufferTex_NAME, a.getPositionMap()), i.setSamplerTexture(Fe.normalBufferTex_NAME, a.getNormalMap());
      let o = t % 2 == 0 ? this.blurTexture1 : this.blurTexture2, n = t % 2 == 1 ? this.blurTexture1 : this.blurTexture2;
      i.setSamplerTexture("inTex", o), i.setStorageTexture("outTex", n), i.workerSizeX = Math.ceil(this.blurTexture1.width / 8), i.workerSizeY = Math.ceil(this.blurTexture1.height / 8), i.workerSizeZ = 1, this.outTexture = n;
    }
  }
  createResource() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.blurTexture1 = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.blurTexture1.name = "dof1";
    let i = new fe();
    i.clearValue = [0, 0, 0, 1], i.loadOp = "clear", this.blurTexture2 = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.blurTexture2.name = "dof2";
    let a = new fe();
    a.clearValue = [0, 0, 0, 1], a.loadOp = "clear", this.rtFrame = new Ne([this.blurTexture1, this.blurTexture2], [i, a]);
  }
  render(e, t) {
    if (!this.blurComputes) {
      this.createResource(), this.createBlurCompute();
      let i = oe.getCameraGroup(e.camera);
      for (let a = 0; a < this.blurComputes.length; a++)
        this.blurComputes[a].setUniformBuffer("globalUniform", i.uniformGPUBuffer);
      this.rendererPassState = ye.createRendererPassState(this.rtFrame, null);
    }
    this.autoSetColorTexture("inTex", this.blurComputes[0]);
    let r = p.setting.render.postProcessing.depthOfView;
    r.far = Math.max(r.near, r.far) + 1e-4;
    for (let i = 0; i < r.iterationCount; i++) {
      let a = this.blurComputes[i], o = this.blurSettings[i];
      o.setFloat("near", r.near), o.setFloat("far", r.far), o.setFloat("pixelOffset", (i + 1) * r.pixelOffset), o.apply(), a.setStorageBuffer("blurSetting", o);
    }
    y.computeCommand(t, this.blurComputes), y.lastRenderPassState = this.rendererPassState;
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1], i = p.setting.render.postProcessing.depthOfView;
    i.far = Math.max(i.near, i.far) + 1e-4, this.blurTexture1.resize(t, r), this.blurTexture2.resize(t, r);
    for (let a = 0; a < i.iterationCount; a++) {
      let o = this.blurComputes[a];
      o.workerSizeX = Math.ceil(this.blurTexture1.width / 8), o.workerSizeY = Math.ceil(this.blurTexture1.height / 8), o.workerSizeZ = 1;
    }
  }
};
var om = class extends wt {
  constructor() {
    super();
    __publicField(this, "gtaoTexture");
    __publicField(this, "rendererPassState");
    __publicField(this, "gtaoCompute");
    __publicField(this, "gtaoSetting");
    __publicField(this, "aoBuffer");
    __publicField(this, "directionsBuffer");
    __publicField(this, "directionsArray");
    __publicField(this, "rtFrame");
    __publicField(this, "Render");
    __publicField(this, "randomCount", 0);
  }
  onAttach(e) {
    p.setting.render.postProcessing.gtao.enable = true;
  }
  onDetach(e) {
    p.setting.render.postProcessing.gtao.enable = false;
  }
  get maxDistance() {
    return p.setting.render.postProcessing.gtao.maxDistance;
  }
  set maxDistance(e) {
    e = W(e, 0.1, 50);
    let t = p.setting.render.postProcessing.gtao;
    t.maxDistance = e;
  }
  get maxPixel() {
    return p.setting.render.postProcessing.gtao.maxPixel;
  }
  set maxPixel(e) {
    e = W(e, 5, 100);
    let t = p.setting.render.postProcessing.gtao;
    t.maxPixel = e;
  }
  get darkFactor() {
    return p.setting.render.postProcessing.gtao.darkFactor;
  }
  set darkFactor(e) {
    e = W(e, 0.01, 1);
    let t = p.setting.render.postProcessing.gtao;
    t.darkFactor = e;
  }
  get rayMarchSegment() {
    return p.setting.render.postProcessing.gtao.rayMarchSegment;
  }
  set rayMarchSegment(e) {
    e = W(e, 4, 10);
    let t = p.setting.render.postProcessing.gtao;
    t.rayMarchSegment = e;
  }
  get multiBounce() {
    return p.setting.render.postProcessing.gtao.multiBounce;
  }
  set multiBounce(e) {
    let t = p.setting.render.postProcessing.gtao;
    t.multiBounce = e;
  }
  get blendColor() {
    return p.setting.render.postProcessing.gtao.blendColor;
  }
  set blendColor(e) {
    let t = p.setting.render.postProcessing.gtao;
    t.blendColor = e;
  }
  get usePosFloat32() {
    return p.setting.render.postProcessing.gtao.usePosFloat32;
  }
  set usePosFloat32(e) {
    let t = p.setting.render.postProcessing.gtao;
    t.usePosFloat32 = e;
  }
  createCompute() {
    p.setting.render.postProcessing.gtao, this.gtaoCompute = new ae(Iu);
    let e = new ft(4 * 2);
    this.gtaoCompute.setUniformBuffer("gtaoData", e), this.directionsArray = new Float32Array(8 * 2), this.directionsBuffer = new $(8 * 2), this.directionsBuffer.setFloat32Array("array", this.randomDirection()), this.directionsBuffer.apply(), this.gtaoCompute.setStorageBuffer("directions", this.directionsBuffer), this.aoBuffer = new $(this.gtaoTexture.width * this.gtaoTexture.height), this.gtaoCompute.setStorageBuffer("aoBuffer", this.aoBuffer);
    let t = Ee.getGBufferFrame("ColorPassGBuffer"), r = t.getPositionMap();
    this.gtaoCompute.setSamplerTexture("posTex", r), this.gtaoCompute.setSamplerTexture("normalTex", t.renderTargets[2]), this.autoSetColorTexture("inTex", this.gtaoCompute), this.gtaoCompute.setStorageTexture("outTex", this.gtaoTexture), this.gtaoSetting = e;
  }
  createResource() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.gtaoTexture = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.gtaoTexture.name = "gtaoTex";
    let i = new fe();
    i.loadOp = "load", this.rtFrame = new Ne([this.gtaoTexture], [i]);
  }
  randomDirection() {
    this.randomCount++, this.randomCount > 1 && (this.randomCount = 0);
    let e = Math.PI * 2 * this.randomCount / 16, t = Math.PI * 2 / 8;
    for (let r = 0; r < 8; r++) {
      let i = e + r * t;
      this.directionsArray[r * 2] = Math.sin(i), this.directionsArray[r * 2 + 1] = Math.cos(i);
    }
    return this.directionsArray;
  }
  render(e, t) {
    if (!this.gtaoCompute) {
      this.createResource(), this.createCompute(), this.onResize(), this.rendererPassState = ye.createRendererPassState(this.rtFrame, null), this.rendererPassState.label = "GTAO";
      let l = oe.getCameraGroup(e.camera);
      this.gtaoCompute.setUniformBuffer("globalUniform", l.uniformGPUBuffer);
    }
    let r = p.setting.render.postProcessing.gtao;
    this.directionsBuffer.setFloat32Array("array", this.randomDirection()), this.directionsBuffer.apply();
    let i = 1 - 0.2 * (ce.frame % 2), a = r.maxDistance * i, o = r.maxPixel * i;
    this.gtaoSetting.setFloat("maxDistance", a), this.gtaoSetting.setFloat("maxPixel", o), this.gtaoSetting.setFloat("darkFactor", r.darkFactor), this.gtaoSetting.setFloat("rayMarchSegment", r.rayMarchSegment);
    let n = e.camera;
    this.gtaoSetting.setFloat("cameraNear", n.near), this.gtaoSetting.setFloat("cameraFar", n.far), this.gtaoSetting.setFloat("multiBounce", r.multiBounce ? 1 : 0), this.gtaoSetting.setFloat("blendColor", r.blendColor ? 1 : 0), this.gtaoSetting.apply(), y.computeCommand(t, [this.gtaoCompute]), y.lastRenderPassState = this.rendererPassState;
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.gtaoTexture.resize(t, r), this.gtaoCompute.workerSizeX = Math.ceil(this.gtaoTexture.width / 8), this.gtaoCompute.workerSizeY = Math.ceil(this.gtaoTexture.height / 8), this.gtaoCompute.workerSizeZ = 1;
  }
};
var nm = class extends wt {
  constructor() {
    super();
    __publicField(this, "viewQuad");
    __publicField(this, "rtTexture");
    __publicField(this, "_globalFog");
    __publicField(this, "_lastSkyTexture");
    let e = this._globalFog = p.setting.render.postProcessing.globalFog, t = Ee.getGBufferFrame("ColorPassGBuffer"), r = w.presentationSize;
    O.register("GlobalFog_shader", Zu), this.rtTexture = this.createRTTexture("GlobalFog", r[0], r[1], N.rgba16float), this.viewQuad = this.createViewQuad("GlobalFog", "GlobalFog_shader", this.rtTexture);
    let i = this.viewQuad.quadShader;
    i.setUniformColor("fogColor", new M(e.fogColor.r, e.fogColor.g, e.fogColor.b, e.fogColor.a)), i.setUniform("fogType", e.fogType), i.setUniform("fogHeightScale", e.fogHeightScale), i.setUniform("start", e.start), i.setUniform("end", e.end), i.setUniform("density", e.density), i.setUniform("ins", e.ins), i.setUniform("falloff", e.falloff), i.setUniform("rayLength", e.rayLength), i.setUniform("scatteringExponent", e.scatteringExponent), i.setUniform("dirHeightLine", e.dirHeightLine), i.setUniform("skyFactor", e.skyFactor), i.setUniform("skyRoughness", e.skyRoughness), i.setUniform("overrideSkyFactor", e.overrideSkyFactor), i.setUniform("isSkyHDR", 0);
    let a = t.getPositionMap(), o = t.getNormalMap();
    this.setInputTexture(a, o);
  }
  onAttach(e) {
    p.setting.render.postProcessing.globalFog.enable = true;
  }
  onDetach(e) {
    p.setting.render.postProcessing.globalFog.enable = false;
  }
  set fogType(e) {
    this._globalFog.fogType = e, this.viewQuad.quadShader.setUniform("fogType", e);
  }
  get fogType() {
    return this._globalFog.fogType;
  }
  set fogHeightScale(e) {
    this._globalFog.fogHeightScale = e, this.viewQuad.quadShader.setUniform("fogHeightScale", e);
  }
  get fogHeightScale() {
    return this.viewQuad.quadShader.getUniform("fogHeightScale");
  }
  set start(e) {
    this._globalFog.start = e, this.viewQuad.quadShader.setUniform("start", e);
  }
  get start() {
    return this.viewQuad.quadShader.getUniform("start");
  }
  set end(e) {
    this._globalFog.end = e, this.viewQuad.quadShader.setUniform("end", e);
  }
  get end() {
    return this.viewQuad.quadShader.getUniform("end");
  }
  set ins(e) {
    this._globalFog.ins = e, this.viewQuad.quadShader.setUniform("ins", e);
  }
  get ins() {
    return this.viewQuad.quadShader.getUniform("ins");
  }
  set density(e) {
    this._globalFog.density = e, this.viewQuad.quadShader.setUniform("density", e);
  }
  get density() {
    return this.viewQuad.quadShader.getUniform("density");
  }
  set skyRoughness(e) {
    this._globalFog.skyRoughness = e, this.viewQuad.quadShader.setUniform("skyRoughness", e);
  }
  get skyRoughness() {
    return this._globalFog.skyRoughness;
  }
  set skyFactor(e) {
    this._globalFog.skyFactor = e, this.viewQuad.quadShader.setUniform("skyFactor", e);
  }
  get skyFactor() {
    return this._globalFog.skyFactor;
  }
  set overrideSkyFactor(e) {
    this._globalFog.overrideSkyFactor = e, this.viewQuad.quadShader.setUniform("overrideSkyFactor", e);
  }
  get overrideSkyFactor() {
    return this._globalFog.overrideSkyFactor;
  }
  get fogColor() {
    return this._globalFog.fogColor;
  }
  set fogColor(e) {
    this._globalFog.fogColor.copyFrom(e), this.viewQuad.quadShader.setUniformColor("fogColor", e);
  }
  set falloff(e) {
    this._globalFog.falloff = e, this.viewQuad.quadShader.setUniform("falloff", e);
  }
  get falloff() {
    return this.viewQuad.quadShader.getUniform("falloff");
  }
  set rayLength(e) {
    this._globalFog.rayLength = e, this.viewQuad.quadShader.setUniform("rayLength", e);
  }
  get rayLength() {
    return this._globalFog.rayLength;
  }
  set scatteringExponent(e) {
    this._globalFog.scatteringExponent = e, this.viewQuad.quadShader.setUniform("scatteringExponent", e);
  }
  get scatteringExponent() {
    return this._globalFog.scatteringExponent;
  }
  set dirHeightLine(e) {
    this._globalFog.dirHeightLine = e, this.viewQuad.quadShader.setUniform("dirHeightLine", e);
  }
  get dirHeightLine() {
    return this._globalFog.dirHeightLine;
  }
  setInputTexture(e, t) {
    const r = this.viewQuad.quadShader;
    r.setTexture("positionMap", e), r.setTexture("normalMap", t), this._lastSkyTexture = this.getSkyTexture(), r.setTexture("prefilterMap", this._lastSkyTexture);
  }
  getSkyTexture() {
    let e = p.res.defaultSky;
    return z.instance.sky instanceof Da && (e = z.instance.sky.map), e;
  }
  render(e, t) {
    const r = this.viewQuad.quadShader;
    let i = this.getSkyTexture();
    i != this._lastSkyTexture && (this._lastSkyTexture = i, r.setTexture("prefilterMap", this._lastSkyTexture)), r.setTexture("colorMap", this.getOutTexture()), r.setUniformFloat("isSkyHDR", i.isHDRTexture ? 1 : 0), this.viewQuad.renderTarget(e, this.viewQuad, t);
  }
};
var lm = class extends wt {
  constructor() {
    super();
    __publicField(this, "godRayTexture");
    __publicField(this, "rendererPassState");
    __publicField(this, "godRayCompute");
    __publicField(this, "historyGodRayData");
    __publicField(this, "godRaySetting");
    __publicField(this, "rtFrame");
    __publicField(this, "Render");
  }
  onAttach(e) {
    p.setting.render.postProcessing.godRay.enable = true, this.createGUI();
  }
  onDetach(e) {
    p.setting.render.postProcessing.godRay.enable = false, this.removeGUI();
  }
  get blendColor() {
    return p.setting.render.postProcessing.godRay.blendColor;
  }
  set blendColor(e) {
    p.setting.render.postProcessing.godRay.blendColor = e;
  }
  get rayMarchCount() {
    return p.setting.render.postProcessing.godRay.rayMarchCount;
  }
  set rayMarchCount(e) {
    e = W(e, 8, 20), p.setting.render.postProcessing.godRay.rayMarchCount = e;
  }
  get scatteringExponent() {
    return p.setting.render.postProcessing.godRay.scatteringExponent;
  }
  set scatteringExponent(e) {
    e = W(e, 1, 40), p.setting.render.postProcessing.godRay.scatteringExponent = e;
  }
  get intensity() {
    return p.setting.render.postProcessing.godRay.intensity;
  }
  set intensity(e) {
    e = W(e, 0.01, 5), p.setting.render.postProcessing.godRay.intensity = e;
  }
  createGUI() {
  }
  removeGUI() {
  }
  createCompute(e) {
    p.setting.render.postProcessing.godRay, this.godRayCompute = new ae(bu);
    let t = new ft(4 * 3);
    this.godRayCompute.setUniformBuffer("godRayUniform", t), this.historyGodRayData = new $(4 * this.godRayTexture.width * this.godRayTexture.height), this.godRayCompute.setStorageBuffer("historyGodRayData", this.historyGodRayData);
    let r = Ee.getGBufferFrame("ColorPassGBuffer");
    this.godRayCompute.setSamplerTexture("posTex", r.renderTargets[1]), this.godRayCompute.setSamplerTexture("normalTex", r.renderTargets[2]), this.autoSetColorTexture("inTex", this.godRayCompute), this.godRayCompute.setStorageTexture("outTex", this.godRayTexture);
    let i = p.getRenderJob(e).shadowMapPassRenderer;
    this.godRayCompute.setSamplerTexture("shadowMap", i.depth2DArrayTexture), this.godRaySetting = t, this.onResize();
  }
  createResource() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.godRayTexture = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.godRayTexture.name = "godRayTexture";
    let i = new fe();
    i.loadOp = "load", this.rtFrame = new Ne([this.godRayTexture], [i]);
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.godRayTexture.resize(t, r), this.historyGodRayData.resizeBuffer(4 * this.godRayTexture.width * this.godRayTexture.height), this.godRayCompute.setStorageBuffer("historyGodRayData", this.historyGodRayData), this.godRayCompute.workerSizeX = Math.ceil(this.godRayTexture.width / 8), this.godRayCompute.workerSizeY = Math.ceil(this.godRayTexture.height / 8), this.godRayCompute.workerSizeZ = 1;
  }
  render(e, t) {
    if (!this.godRayCompute) {
      this.createResource(), this.createCompute(e);
      let n = oe.getLightEntries(e.scene);
      this.godRayCompute.setStorageBuffer("lightBuffer", n.storageGPUBuffer), this.godRayCompute.setStorageBuffer("models", oe.modelMatrixBindGroup.matrixBufferDst), this.rendererPassState = ye.createRendererPassState(this.rtFrame, null), this.rendererPassState.label = "GodRay";
      let l = oe.getCameraGroup(e.camera);
      this.godRayCompute.setUniformBuffer("globalUniform", l.uniformGPUBuffer);
    }
    let r = p.setting.render.postProcessing.godRay;
    this.godRaySetting.setFloat("intensity", r.intensity), this.godRaySetting.setFloat("rayMarchCount", r.rayMarchCount);
    let i = w.presentationSize, a = i[0], o = i[1];
    this.godRaySetting.setFloat("viewPortWidth", a), this.godRaySetting.setFloat("viewPortHeight", o), this.godRaySetting.setFloat("blendColor", r.blendColor ? 1 : 0), this.godRaySetting.setFloat("scatteringExponent", r.scatteringExponent), this.godRaySetting.apply(), y.computeCommand(t, [this.godRayCompute]), y.lastRenderPassState = this.rendererPassState;
  }
};
var qc = class {
  constructor() {
    __publicField(this, "indexList");
    __publicField(this, "color");
    __publicField(this, "count");
  }
};
var Kc = class {
  constructor() {
    __publicField(this, "SlotCount", 8);
    __publicField(this, "MaxEntities", 16);
    __publicField(this, "defaultColor", new M(0.2, 1, 1, 1));
    __publicField(this, "slots", []);
    __publicField(this, "dataDirty", true);
    let e = p.setting.render.postProcessing.outline.groupCount;
    this.SlotCount = Math.max(1, Math.min(e, this.SlotCount));
    for (let t = 0; t < this.SlotCount; t++) {
      let r = this.slots[t] = new qc();
      r.indexList = new Float32Array(this.MaxEntities), r.color = this.defaultColor.clone(), r.count = 0;
    }
  }
  clear() {
    for (let e = 0; e < this.SlotCount; e++)
      this.clearAt(e);
  }
  clearAt(e) {
    this.dataDirty = true;
    let t = this.slots[e];
    return t.color.copyFrom(this.defaultColor), t.indexList.fill(-1), t.count = 0, this;
  }
  fillDataAt(e, t, r) {
    this.dataDirty = true;
    let i = this.slots[e];
    if (i) {
      i.indexList.fill(-1);
      for (let a = 0, o = t.length; a < o; a++)
        i.indexList[a] = t[a];
      i.count = t.length, i.color.copyFrom(r);
    }
    return this;
  }
  fetchData(e) {
    return e.dirty = this.dataDirty, e.slots = this.slots, this.dataDirty = false, this;
  }
};
var Mt = new Kc();
var hm = class extends wt {
  constructor() {
    super();
    __publicField(this, "outlineTex");
    __publicField(this, "lowTex");
    __publicField(this, "rendererPassState");
    __publicField(this, "calcWeightCompute");
    __publicField(this, "outlineCompute");
    __publicField(this, "blendCompute");
    __publicField(this, "outlineSetting");
    __publicField(this, "slotsBuffer");
    __publicField(this, "slotsArray");
    __publicField(this, "entitiesArray");
    __publicField(this, "entitiesBuffer");
    __publicField(this, "weightBuffer");
    __publicField(this, "lowTexSize");
    __publicField(this, "oldOutlineColor");
    __publicField(this, "rtFrame");
    __publicField(this, "fetchData");
    __publicField(this, "computeList");
  }
  onAttach(e) {
    p.setting.render.postProcessing.outline.enable = true;
  }
  onDetach(e) {
    p.setting.render.postProcessing.outline.enable = false;
  }
  set outlinePixel(e) {
    e = W(e, 0, 8);
    let t = p.setting.render.postProcessing.outline;
    t.outlinePixel != e && (t.outlinePixel = e);
  }
  get outlinePixel() {
    return p.setting.render.postProcessing.outline.outlinePixel;
  }
  set fadeOutlinePixel(e) {
    let t = p.setting.render.postProcessing.outline;
    e = W(e, 0, 8), t.fadeOutlinePixel != e && (t.fadeOutlinePixel = e);
  }
  get fadeOutlinePixel() {
    return p.setting.render.postProcessing.outline.fadeOutlinePixel;
  }
  set strength(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.outline;
    t.strength != e && (t.strength = e);
  }
  get strength() {
    return p.setting.render.postProcessing.outline.strength;
  }
  set useAddMode(e) {
    p.setting.render.postProcessing.outline.useAddMode = e;
  }
  get useAddMode() {
    return p.setting.render.postProcessing.outline.useAddMode;
  }
  createGUI() {
  }
  createCompute() {
    let t = Ee.getGBufferFrame("ColorPassGBuffer").getPositionMap();
    this.calcWeightCompute = new ae(Tu), this.calcWeightCompute.setStorageBuffer("outlineSetting", this.outlineSetting), this.calcWeightCompute.setStorageBuffer("slotsBuffer", this.slotsBuffer), this.calcWeightCompute.setStorageBuffer("weightBuffer", this.weightBuffer), this.calcWeightCompute.setStorageBuffer("entitiesBuffer", this.entitiesBuffer), this.calcWeightCompute.setSamplerTexture("indexTexture", t), this.calcWeightCompute.workerSizeX = Math.ceil(this.lowTex.width / 8), this.calcWeightCompute.workerSizeY = Math.ceil(this.lowTex.height / 8), this.calcWeightCompute.workerSizeZ = 1, this.outlineCompute = new ae(Du), this.outlineCompute.setStorageBuffer("outlineSetting", this.outlineSetting), this.outlineCompute.setStorageBuffer("slotsBuffer", this.slotsBuffer), this.outlineCompute.setStorageBuffer("weightBuffer", this.weightBuffer), this.outlineCompute.setStorageBuffer("oldOutlineColor", this.oldOutlineColor), this.outlineCompute.setStorageTexture("lowTex", this.lowTex), this.outlineCompute.workerSizeX = Math.ceil(this.lowTex.width / 8), this.outlineCompute.workerSizeY = Math.ceil(this.lowTex.height / 8), this.outlineCompute.workerSizeZ = 1, this.blendCompute = new ae(Bu), this.blendCompute.setStorageBuffer("outlineSetting", this.outlineSetting), this.autoSetColorTexture("inTex", this.blendCompute), this.blendCompute.setSamplerTexture("lowTex", this.lowTex), this.blendCompute.setStorageTexture("outlineTex", this.outlineTex), this.blendCompute.workerSizeX = Math.ceil(this.outlineTex.width / 8), this.blendCompute.workerSizeY = Math.ceil(this.outlineTex.height / 8), this.blendCompute.workerSizeZ = 1;
  }
  createResource() {
    let e = w.presentationSize, t = e[0], r = e[1], i = p.setting.render.postProcessing.outline.textureScale;
    this.lowTexSize = new Q(Math.ceil(t * i), Math.ceil(r * i)), this.lowTex = new de(this.lowTexSize.x, this.lowTexSize.y, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.lowTex.name = "lowTex";
    let a = new fe();
    a.clearValue = [0, 0, 0, 1], a.loadOp = "clear", this.outlineTex = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.outlineTex.name = "outlineTex";
    let o = new fe();
    o.clearValue = [0, 0, 0, 1], o.loadOp = "clear", this.rtFrame = new Ne([this.outlineTex], [o]), this.outlineSetting = new ft(8), this.weightBuffer = new $(this.lowTexSize.x * this.lowTexSize.y * 4, GPUBufferUsage.COPY_SRC), this.oldOutlineColor = new $(this.lowTexSize.x * this.lowTexSize.y * 4, GPUBufferUsage.COPY_SRC), this.slotsArray = new Float32Array(Mt.SlotCount * 4), this.slotsBuffer = new $(this.slotsArray.length), this.slotsBuffer.setFloat32Array("slotsArray", this.slotsArray), this.slotsBuffer.apply(), this.entitiesArray = new Float32Array(Mt.SlotCount * Mt.MaxEntities), this.entitiesBuffer = new $(this.entitiesArray.length), this.entitiesBuffer.setFloat32Array("entitiesArray", this.entitiesArray), this.slotsBuffer.apply(), this.fetchData || (this.fetchData = {});
  }
  fetchOutlineData() {
    if (Mt.fetchData(this.fetchData), this.fetchData.dirty) {
      let e = Mt.SlotCount, t = Mt.MaxEntities;
      for (let r = 0; r < e; r++) {
        let i = 4 * r, a = this.fetchData.slots[r];
        this.slotsArray[i + 0] = a.color.r, this.slotsArray[i + 1] = a.color.g, this.slotsArray[i + 2] = a.color.b, this.slotsArray[i + 3] = a.count, i = t * r, this.entitiesArray.set(a.indexList, i);
      }
      this.slotsBuffer.setFloat32Array("slotsArray", this.slotsArray), this.slotsBuffer.apply(), this.entitiesBuffer.setFloat32Array("entitiesArray", this.entitiesArray), this.entitiesBuffer.apply();
    }
  }
  render(e, t) {
    this.calcWeightCompute || (this.createResource(), this.createCompute(), this.createGUI(), this.rendererPassState = ye.createRendererPassState(this.rtFrame, null)), this.computeList || (this.computeList = [this.calcWeightCompute, this.outlineCompute, this.blendCompute]);
    let r = p.setting.render.postProcessing.outline;
    this.outlineSetting.setFloat("strength", r.strength), this.outlineSetting.setFloat("useAddMode", r.useAddMode ? 1 : 0), this.outlineSetting.setFloat("outlinePixel", r.outlinePixel), this.outlineSetting.setFloat("fadeOutlinePixel", r.fadeOutlinePixel), this.outlineSetting.setFloat("lowTexWidth", this.lowTexSize.x), this.outlineSetting.setFloat("lowTexHeight", this.lowTexSize.y), this.outlineSetting.apply(), this.fetchOutlineData(), y.computeCommand(t, this.computeList), y.lastRenderPassState = this.rendererPassState;
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1], i = p.setting.render.postProcessing.outline.textureScale;
    this.lowTexSize = new Q(Math.ceil(t * i), Math.ceil(r * i)), this.lowTex.resize(this.lowTexSize.x, this.lowTexSize.y), this.outlineTex.resize(t, r), this.weightBuffer.resizeBuffer(this.lowTexSize.x * this.lowTexSize.y * 4), this.oldOutlineColor.resizeBuffer(this.lowTexSize.x * this.lowTexSize.y * 4), this.calcWeightCompute.workerSizeX = Math.ceil(this.lowTex.width / 8), this.calcWeightCompute.workerSizeY = Math.ceil(this.lowTex.height / 8), this.calcWeightCompute.workerSizeZ = 1, this.outlineCompute.workerSizeX = Math.ceil(this.lowTex.width / 8), this.outlineCompute.workerSizeY = Math.ceil(this.lowTex.height / 8), this.outlineCompute.workerSizeZ = 1, this.blendCompute.workerSizeX = Math.ceil(this.outlineTex.width / 8), this.blendCompute.workerSizeY = Math.ceil(this.outlineTex.height / 8), this.blendCompute.workerSizeZ = 1;
  }
};
var um = class extends wt {
  constructor() {
    super();
    __publicField(this, "SSR_RayTraceCompute");
    __publicField(this, "SSR_IS_Compute");
    __publicField(this, "SSR_Blend_Compute");
    __publicField(this, "isRetTexture");
    __publicField(this, "finalTexture");
    __publicField(this, "rendererPassState");
    __publicField(this, "ssrUniformBuffer");
    __publicField(this, "rayTraceData");
    __publicField(this, "ssrColorData");
    __publicField(this, "isKernelFloat32Array");
    __publicField(this, "rtFrame");
    __publicField(this, "historyPosition");
    __publicField(this, "reflectionRatio", 0.5);
  }
  onAttach(e) {
    p.setting.render.postProcessing.ssr.enable = true, this.debug();
  }
  onDetach(e) {
    p.setting.render.postProcessing.ssr.enable = false;
  }
  get fadeEdgeRatio() {
    return p.setting.render.postProcessing.ssr.fadeEdgeRatio;
  }
  set fadeEdgeRatio(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.ssr;
    t.fadeEdgeRatio = e;
  }
  get rayMarchRatio() {
    return p.setting.render.postProcessing.ssr.rayMarchRatio;
  }
  set rayMarchRatio(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.ssr;
    t.rayMarchRatio = e;
  }
  get roughnessThreshold() {
    return p.setting.render.postProcessing.ssr.roughnessThreshold;
  }
  set roughnessThreshold(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.ssr;
    t.roughnessThreshold = e;
  }
  get fadeDistanceMin() {
    return p.setting.render.postProcessing.ssr.fadeDistanceMin;
  }
  set fadeDistanceMin(e) {
    e = W(e, 0, 1e4);
    let t = p.setting.render.postProcessing.ssr;
    t.fadeDistanceMin = e;
  }
  get fadeDistanceMax() {
    return p.setting.render.postProcessing.ssr.fadeDistanceMax;
  }
  set fadeDistanceMax(e) {
    e = W(e, 0, 1e4);
    let t = p.setting.render.postProcessing.ssr;
    t.fadeDistanceMax = e;
  }
  get powDotRN() {
    return p.setting.render.postProcessing.ssr.powDotRN;
  }
  set powDotRN(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.ssr;
    t.powDotRN = e;
  }
  debug() {
  }
  createRayTraceShader() {
    this.SSR_RayTraceCompute = new ae(Lu), this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform", this.ssrUniformBuffer), this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer", this.rayTraceData), this.SSR_RayTraceCompute.setStorageBuffer("historyPosition", this.historyPosition);
    let e = Ee.getGBufferFrame("ColorPassGBuffer");
    this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture", e.getPositionMap()), this.SSR_RayTraceCompute.setSamplerTexture(Fe.normalBufferTex_NAME, e.renderTargets[2]), this.SSR_RayTraceCompute.setSamplerTexture(Fe.materialBufferTex_NAME, e.renderTargets[3]), z.instance.sky instanceof Da && this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap", z.instance.sky.map), this.SSR_RayTraceCompute.workerSizeX = Math.ceil(this.isRetTexture.width / 8), this.SSR_RayTraceCompute.workerSizeY = Math.ceil(this.isRetTexture.height / 8), this.SSR_RayTraceCompute.workerSizeZ = 1;
  }
  createISShader() {
    this.SSR_IS_Compute = new ae(Uu), this.SSR_IS_Compute.setStorageBuffer("ssrUniform", this.ssrUniformBuffer), this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer", this.rayTraceData), this.SSR_IS_Compute.setStorageBuffer("ssrColorData", this.ssrColorData), this.SSR_IS_Compute.setStorageBuffer("historyPosition", this.historyPosition), this.autoSetColorTexture("colorMap", this.SSR_IS_Compute), this.SSR_IS_Compute.setStorageTexture("outTex", this.isRetTexture), this.SSR_IS_Compute.workerSizeX = Math.ceil(this.isRetTexture.width / 8), this.SSR_IS_Compute.workerSizeY = Math.ceil(this.isRetTexture.height / 8), this.SSR_IS_Compute.workerSizeZ = 1;
  }
  createBlendShader(e) {
    this.SSR_Blend_Compute = new ae(Ru), this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer", this.rayTraceData), this.autoSetColorTexture("colorMap", this.SSR_Blend_Compute), this.SSR_Blend_Compute.setSamplerTexture("ssrMap", e), this.SSR_Blend_Compute.setStorageTexture("outTex", this.finalTexture), this.SSR_Blend_Compute.workerSizeX = Math.ceil(this.finalTexture.width / 8), this.SSR_Blend_Compute.workerSizeY = Math.ceil(this.finalTexture.height / 8), this.SSR_Blend_Compute.workerSizeZ = 1;
  }
  createResource() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.finalTexture = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING), this.finalTexture.name = "ssrOutTex";
    let i = new fe();
    i.clearValue = [0, 0, 0, 0], i.loadOp = "clear";
    let a = Math.ceil(t * p.setting.render.postProcessing.ssr.pixelRatio), o = Math.ceil(r * p.setting.render.postProcessing.ssr.pixelRatio);
    this.isRetTexture = new de(a, o, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING), this.isRetTexture.name = "ssrTextureIn";
    let n = new fe();
    n.clearValue = [0, 0, 0, 0], n.loadOp = "clear", this.rtFrame = new Ne([this.finalTexture, this.isRetTexture], [i, n]), this.rayTraceData = new $(a * o * 8, GPUBufferUsage.COPY_SRC), this.ssrColorData = new $(a * o * 4, GPUBufferUsage.COPY_SRC), this.historyPosition = new $(a * o * 4, GPUBufferUsage.COPY_SRC), this.ssrUniformBuffer = new ft(4 * 8), this.ssrUniformBuffer.setFloat("ssrBufferSizeX", this.isRetTexture.width), this.ssrUniformBuffer.setFloat("ssrBufferSizeY", this.isRetTexture.height), this.ssrUniformBuffer.setFloat("colorMapSizeX", this.finalTexture.width), this.ssrUniformBuffer.setFloat("colorMapSizeY", this.finalTexture.height), this.ssrUniformBuffer.apply();
  }
  render(e, t) {
    if (!this.SSR_RayTraceCompute) {
      this.createResource(), this.createISShader(), this.createRayTraceShader(), this.createBlendShader(this.isRetTexture), this.finalTexture, this.rendererPassState = ye.createRendererPassState(this.rtFrame, null);
      let a = oe.getCameraGroup(e.camera);
      this.SSR_RayTraceCompute.setUniformBuffer("standUniform", a.uniformGPUBuffer);
    }
    let r = p.setting.render.postProcessing.ssr;
    this.ssrUniformBuffer.setFloat("fadeEdgeRatio", r.fadeEdgeRatio), this.ssrUniformBuffer.setFloat("rayMarchRatio", r.rayMarchRatio), this.ssrUniformBuffer.setFloat("fadeDistanceMin", r.fadeDistanceMin), this.ssrUniformBuffer.setFloat("fadeDistanceMax", r.fadeDistanceMax), this.ssrUniformBuffer.setFloat("mixThreshold", r.mixThreshold), this.ssrUniformBuffer.setFloat("roughnessThreshold", r.roughnessThreshold), this.ssrUniformBuffer.setFloat("reflectionRatio", this.reflectionRatio), this.ssrUniformBuffer.setFloat("powDotRN", r.powDotRN), this.ssrUniformBuffer.setFloat("randomSeedX", Math.random()), this.ssrUniformBuffer.setFloat("randomSeedY", Math.random()), this.ssrUniformBuffer.apply();
    let i = [this.SSR_RayTraceCompute, this.SSR_IS_Compute, this.SSR_Blend_Compute];
    y.computeCommand(t, i), y.lastRenderPassState = this.rendererPassState;
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1], i = Math.ceil(t * p.setting.render.postProcessing.ssr.pixelRatio), a = Math.ceil(r * p.setting.render.postProcessing.ssr.pixelRatio);
    this.finalTexture.resize(t, r), this.isRetTexture.resize(i, a), this.rayTraceData.resizeBuffer(i * a * 8), this.ssrColorData.resizeBuffer(i * a * 4), this.historyPosition.resizeBuffer(i * a * 4), this.ssrUniformBuffer.setFloat("ssrBufferSizeX", this.isRetTexture.width), this.ssrUniformBuffer.setFloat("ssrBufferSizeY", this.isRetTexture.height), this.ssrUniformBuffer.setFloat("colorMapSizeX", this.finalTexture.width), this.ssrUniformBuffer.setFloat("colorMapSizeY", this.finalTexture.height), this.SSR_RayTraceCompute.workerSizeX = Math.ceil(this.isRetTexture.width / 8), this.SSR_RayTraceCompute.workerSizeY = Math.ceil(this.isRetTexture.height / 8), this.SSR_RayTraceCompute.workerSizeZ = 1, this.SSR_IS_Compute.workerSizeX = Math.ceil(this.isRetTexture.width / 8), this.SSR_IS_Compute.workerSizeY = Math.ceil(this.isRetTexture.height / 8), this.SSR_IS_Compute.workerSizeZ = 1, this.SSR_Blend_Compute.workerSizeX = Math.ceil(this.finalTexture.width / 8), this.SSR_Blend_Compute.workerSizeY = Math.ceil(this.finalTexture.height / 8), this.SSR_Blend_Compute.workerSizeZ = 1;
  }
};
var cm = class {
  static createSeeds() {
    let e = 20, t = 32, r = [new d(0, 0, e)], i = 0, a = 0.02;
    for (let o = 1; o < t; o++) {
      let n = new d();
      r.push(n), i += 1 - (1 - 0.618) * o / t, a += o * 0.01, n.x = Math.sin(i) * a, n.y = Math.cos(i) * a, n.z = 1 - o / t, n.multiplyScalar(e);
    }
    return r;
  }
};
var fm = class extends wt {
  constructor() {
    super();
    __publicField(this, "taaTexture");
    __publicField(this, "outTexture");
    __publicField(this, "rendererPassState");
    __publicField(this, "taaCompute");
    __publicField(this, "copyTexCompute");
    __publicField(this, "sharpCompute");
    __publicField(this, "taaSetting");
    __publicField(this, "preColorBuffer");
    __publicField(this, "preColorTex");
    __publicField(this, "preProjMatrix");
    __publicField(this, "preViewMatrix");
    __publicField(this, "rtFrame");
  }
  onAttach(e) {
    p.setting.render.postProcessing.taa.enable = true, e.camera.enableJitterProjection(true), this.createGUI();
  }
  onDetach(e) {
    p.setting.render.postProcessing.taa.enable = false, e.camera.enableJitterProjection(false);
  }
  get jitterSeedCount() {
    return p.setting.render.postProcessing.taa.jitterSeedCount;
  }
  set jitterSeedCount(e) {
    e = W(e, 2, 8), e = Math.round(e);
    let t = p.setting.render.postProcessing.taa;
    t.jitterSeedCount = e;
  }
  get blendFactor() {
    return p.setting.render.postProcessing.taa.blendFactor;
  }
  set blendFactor(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.taa;
    t.blendFactor = e;
  }
  get sharpFactor() {
    return p.setting.render.postProcessing.taa.sharpFactor;
  }
  set sharpFactor(e) {
    e = W(e, 0.1, 0.9);
    let t = p.setting.render.postProcessing.taa;
    t.sharpFactor = e;
  }
  get sharpPreBlurFactor() {
    return p.setting.render.postProcessing.taa.sharpPreBlurFactor;
  }
  set sharpPreBlurFactor(e) {
    e = W(e, 0.1, 0.9);
    let t = p.setting.render.postProcessing.taa;
    t.sharpPreBlurFactor = e;
  }
  get temporalJitterScale() {
    return p.setting.render.postProcessing.taa.temporalJitterScale;
  }
  set temporalJitterScale(e) {
    e = W(e, 0, 1);
    let t = p.setting.render.postProcessing.taa;
    t.temporalJitterScale = e;
  }
  createGUI() {
  }
  createCompute(e) {
    let t = new ae(Nu);
    p.setting.render.postProcessing.taa;
    let r = new ft(16 * 2 + 4 * 3), i = oe.getCameraGroup(e.camera);
    t.setUniformBuffer("standUniform", i.uniformGPUBuffer), t.setUniformBuffer("taaData", r), t.setStorageBuffer("preColorBuffer", this.preColorBuffer);
    let a = Ee.getGBufferFrame("ColorPassGBuffer");
    t.setSamplerTexture("preColorTex", this.preColorTex), t.setSamplerTexture("posTex", a.getPositionMap()), this.autoSetColorTexture("inTex", t), t.setStorageTexture("outTex", this.taaTexture), t.workerSizeX = Math.ceil(this.taaTexture.width / 8), t.workerSizeY = Math.ceil(this.taaTexture.height / 8), t.workerSizeZ = 1, this.taaCompute = t, this.taaSetting = r, this.copyTexCompute = new ae(Ou), this.copyTexCompute.setStorageBuffer("preColor", this.preColorBuffer), this.copyTexCompute.setStorageTexture("preColorTex", this.preColorTex), this.copyTexCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8), this.copyTexCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8), this.copyTexCompute.workerSizeZ = 1, this.sharpCompute = new ae(Fu), this.sharpCompute.setUniformBuffer("taaData", r), this.sharpCompute.setSamplerTexture("inTex", this.taaTexture), this.sharpCompute.setStorageTexture("outTex", this.outTexture), this.sharpCompute.workerSizeX = Math.ceil(this.outTexture.width / 8), this.sharpCompute.workerSizeY = Math.ceil(this.outTexture.height / 8), this.sharpCompute.workerSizeZ = 1;
  }
  createResource() {
    this.preProjMatrix = new P().identity(), this.preViewMatrix = new P().identity();
    let e = w.presentationSize, t = e[0], r = e[1];
    this.preColorBuffer = new $(t * r * 4, GPUBufferUsage.COPY_SRC), this.preColorTex = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.preColorTex.name = "taaTex";
    let i = new fe();
    i.clearValue = [0, 0, 0, 1], i.loadOp = "clear", this.taaTexture = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.taaTexture.name = "taaTex";
    let a = new fe();
    a.clearValue = [0, 0, 0, 1], a.loadOp = "clear", this.outTexture = new de(t, r, N.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING), this.outTexture.name = "sharpTaaTex";
    let o = new fe();
    o.clearValue = [0, 0, 0, 1], o.loadOp = "clear", this.rtFrame = new Ne([this.preColorTex, this.taaTexture, this.outTexture], [i, a, o]);
  }
  render(e, t) {
    this.taaCompute || (this.createResource(), this.createCompute(e), this.rendererPassState = ye.createRendererPassState(this.rtFrame, null));
    let r = p.setting.render.postProcessing.taa;
    this.taaSetting.setMatrix("preProjMatrix", this.preProjMatrix), this.taaSetting.setMatrix("preViewMatrix", this.preViewMatrix), this.taaSetting.setFloat("jitterFrameIndex", e.camera.jitterFrameIndex), this.taaSetting.setFloat("blendFactor", r.blendFactor), this.taaSetting.setFloat("sharpFactor", r.sharpFactor), this.taaSetting.setFloat("sharpPreBlurFactor", r.sharpPreBlurFactor), this.taaSetting.setFloat("jitterX", e.camera.jitterX), this.taaSetting.setFloat("jitterY", e.camera.jitterY), this.taaSetting.apply(), y.computeCommand(t, [this.copyTexCompute, this.taaCompute, this.sharpCompute]), y.lastRenderPassState = this.rendererPassState, this.preProjMatrix.copyFrom(e.camera.projectionMatrix), this.preViewMatrix.copyFrom(e.camera.viewMatrix);
  }
  onResize() {
    let e = w.presentationSize, t = e[0], r = e[1];
    this.preColorBuffer.resizeBuffer(t * r * 4), this.taaTexture.resize(t, r), this.outTexture.resize(t, r), this.preColorTex.resize(t, r), this.taaCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8), this.taaCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8), this.taaCompute.workerSizeZ = 1, this.copyTexCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8), this.copyTexCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8), this.copyTexCompute.workerSizeZ = 1, this.sharpCompute.workerSizeX = Math.ceil(this.outTexture.width / 8), this.sharpCompute.workerSizeY = Math.ceil(this.outTexture.height / 8), this.sharpCompute.workerSizeZ = 1;
  }
};
var Jc = class {
  constructor() {
    __publicField(this, "_tempIndexArray", []);
    __publicField(this, "_rendererList", []);
  }
  setOutline(e, t) {
    this.setOutlineList([e], t ? [t] : null);
  }
  setOutlineList(e, t) {
    e || (e = []);
    let r = Mt.defaultColor, i = Mt.SlotCount;
    for (let a = 0; a < i; a++) {
      this._tempIndexArray.length = 0;
      let o = e[a], n = (t ? t[a] : null) || r;
      if (o)
        for (const l of o)
          this.getEntityIdList(l, this._tempIndexArray);
      Mt.fillDataAt(a, this._tempIndexArray, n);
    }
  }
  clearOutline() {
    return Mt.clear(), this;
  }
  getEntityIdList(e, t) {
    this._rendererList.length = 0;
    let r = e.getComponents(J, this._rendererList);
    for (const i of r)
      t.push(i.object3D.transform._worldMatrix.index);
  }
};
var dm = new Jc();
var Zc = class {
  constructor() {
    __publicField(this, "localPosition", new d());
    __publicField(this, "worldPosition", new d());
    __publicField(this, "uv", new Q());
    __publicField(this, "faceIndex");
    __publicField(this, "isIn", false);
    __publicField(this, "t", 0);
    __publicField(this, "u", 0);
    __publicField(this, "v", 0);
    __publicField(this, "triangle");
    __publicField(this, "v0");
    __publicField(this, "v1");
    __publicField(this, "v2");
    __publicField(this, "pickList");
    __publicField(this, "color");
  }
};
var _oi = class _oi {
  static distPtTri(e, t, r, i) {
    let a = new d(), o = new d(), n = new d();
    i.subtract(t, a), r.subtract(t, o), e.subtract(t, n);
    let l = Ye(a, a), h = Ye(a, o), u = Ye(a, n), c = Ye(o, o), f = Ye(o, n), g = 1 / (l * c - h * h), m = (c * u - h * f) * g, A = (l * f - h * u) * g;
    if (m >= -_oi.EPS && A >= -_oi.EPS && m + A <= 1 + _oi.EPS) {
      let _ = t[1] + a[1] * m + o[1] * A;
      return Math.abs(_ - e[1]);
    }
    return _oi.FLT_MAX;
  }
  static IntersectTriangle(e, t, r) {
    let i = t.v1, a = t.v2, o = t.v3, n = a.subtract(i, d.HELP_3), l = o.subtract(i, d.HELP_4), h = e.direction.crossProduct(l, d.HELP_5), u = Ye(n, h), c;
    if (u > 0) {
      if (r)
        return null;
      c = e.origin.subtract(i, d.HELP_2);
    } else
      c = i.subtract(e.origin, d.HELP_2), u = -u;
    if (u < 1e-4)
      return this._info.isIn = false, this._info.t = 0, this._info.u = 0, this._info.v = 0, this._info;
    let f = Ye(c, h);
    if (f < 0 || f > u)
      return this._info.isIn = false, this._info.t = 0, this._info.u = 0, this._info.v = 0, this._info;
    let g = c.crossProduct(n, d.HELP_1), m = Ye(e.direction, g);
    if (m < 0 || f + m > u)
      return this._info.isIn = false, this._info.t = 0, this._info.u = 0, this._info.v = 0, this._info;
    let A = Ye(l, g), _ = 1 / u;
    A *= _, f *= _, m *= _, this._info.isIn = true, this._info.t = A, this._info.u = f, this._info.v = m;
    let x = 1 - f - m;
    return this._u0.copyFrom(t.u1), this._u0.scale(x), this._u1.copyFrom(t.u2), this._u1.scale(f), this._u2.copyFrom(t.u3), this._u2.scale(m), this._info.uv.copyFrom(this._u0), this._info.uv.add(this._u1, this._info.uv), this._info.uv.add(this._u2, this._info.uv), this._info.localPosition.copyFrom(e.direction).multiplyScalar(A), this._info.localPosition.add(e.origin, this._info.localPosition), this._info;
  }
};
__publicField(_oi, "EPS", 1e-4);
__publicField(_oi, "FLT_MAX", 3402823466e29);
__publicField(_oi, "_info", new Zc());
__publicField(_oi, "_u0", new Q());
__publicField(_oi, "_u1", new Q());
__publicField(_oi, "_u2", new Q());
var oi = _oi;
var _ts = class _ts extends qt {
  constructor() {
    super();
    __publicField(this, "_maxRetry", 3);
    if (_ts._instance)
      throw new Error("LoadManager is singleton class...");
  }
  loadAll(e, t) {
    return new Promise((r, i) => {
      let a = e.length, o = [];
      e.forEach((n, l) => {
        let h = new t();
        this.load(n, t).then((u) => {
          h.parse(u), o.push(h), a--, a === 0 && r(o);
        });
      });
    });
  }
  static getInstance() {
    return this._instance || (this._instance = new _ts());
  }
  loadUrls(e, t) {
    return new Promise((r, i) => {
      let a = e.length, o = [];
      e.forEach((n, l) => {
        this.load(n, t).then((h) => {
          o.push(h), a--, a === 0 && r(o), a < 0 && console.error(`loadUrls ${e} error`);
        });
      });
    });
  }
  get maxRetry() {
    return this._maxRetry;
  }
  set maxRetry(e) {
    this._maxRetry = e;
  }
  load(e, t) {
    return new Promise((r, i) => {
      switch (t.format) {
      }
    });
  }
};
__publicField(_ts, "_instance");
var ts = _ts;
var Oa = ((s) => (s.Point = "Point", s.LineString = "LineString", s.MultiPolygon = "MultiPolygon", s))(Oa || {});
var gm = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "json");
  }
  async parseString(e) {
    this.json = e, this.data = JSON.parse(e);
  }
};
__publicField(gm, "format", Ue.JSON);
var pm = class {
  static getPath(e) {
    let t = [];
    for (let r = 0; r < e.features.length; r++) {
      const i = e.features[r];
      switch (i.geometry.type) {
        case Oa.LineString:
          break;
        case Oa.MultiPolygon:
          let a = [];
          for (let o = 0; o < i.geometry.coordinates.length; o++) {
            const n = i.geometry.coordinates[o];
            for (const l of n)
              for (const h of l) {
                let u = new d(h[0], 0, h[1]);
                a.push(u);
              }
          }
          t.push(a);
          break;
      }
    }
    return t;
  }
};
var mm = class {
};
var Am = class {
};
var vm = class {
};
var xm = class {
};
var _m = class {
};
var Cm = class {
};
var Sm = class {
};
var ym = class {
};
var wm = class {
};
var Im = class {
};
var $c = class {
  constructor() {
    __publicField(this, "boneName");
    __publicField(this, "bonePath");
    __publicField(this, "parentBoneName");
    __publicField(this, "boneID");
    __publicField(this, "parentBoneID");
    __publicField(this, "instanceID");
    __publicField(this, "parentInstanceID");
    __publicField(this, "t");
    __publicField(this, "q");
    __publicField(this, "s");
  }
  formBytes(e) {
    this.boneName = e.readUTF(), this.bonePath = e.readUTF(), this.parentBoneName = e.readUTF(), this.boneID = e.readInt32(), this.parentBoneID = e.readInt32(), this.instanceID = e.readUTF(), this.parentInstanceID = e.readUTF(), this.t = e.readVector3(), this.q = e.readQuaternion(), this.s = e.readVector3();
  }
};
var ef = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "count");
    __publicField(this, "boneData");
    __publicField(this, "boneMap");
  }
  formBytes(e) {
    this.boneData = [], this.boneMap = /* @__PURE__ */ new Map(), this.name = e.readUTF(), this.count = e.readInt32();
    for (let t = 0; t < this.count; t++) {
      let r = new $c();
      r.formBytes(e.readBytesArray()), this.boneData[t] = r, this.boneMap.set(r.boneName, r);
    }
  }
};
var tf = class extends rt {
  static parser(e, t) {
    let r = e.readInt32();
    for (let i = 0; i < r; i++) {
      let a = new ef();
      a.formBytes(e.readBytesArray()), p.res.addObj(a.name, a);
    }
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
};
__publicField(tf, "format", Ue.BIN);
D.position, D.normal, D.color, D.TANGENT, D.uv, D.TEXCOORD_1, D.TEXCOORD_2, D.TEXCOORD_2, D.TEXCOORD_4, D.TEXCOORD_5, D.TEXCOORD_6, D.TEXCOORD_7, D.joints0, D.weights0;
var L = ((s) => (s[s.single = 0] = "single", s[s.boolean = 1] = "boolean", s[s.int = 2] = "int", s[s.int16 = 3] = "int16", s[s.int32 = 4] = "int32", s[s.float = 5] = "float", s[s.long = 6] = "long", s[s.uint = 7] = "uint", s[s.uint32 = 8] = "uint32", s[s.uint64 = 9] = "uint64", s[s.double = 10] = "double", s[s.string = 11] = "string", s[s.singleArray = 12] = "singleArray", s[s.stringArray = 13] = "stringArray", s[s.floatArray = 14] = "floatArray", s[s.vector2 = 15] = "vector2", s[s.vector3 = 16] = "vector3", s[s.vector4 = 17] = "vector4", s[s.color = 18] = "color", s[s.color32 = 19] = "color32", s[s.animationCurve = 20] = "animationCurve", s[s.quaternion = 21] = "quaternion", s[s.matrix4x4 = 22] = "matrix4x4", s[s.mesh = 23] = "mesh", s[s.texture = 24] = "texture", s[s.material = 25] = "material", s[s.materials = 26] = "materials", s[s.skeleton = 27] = "skeleton", s[s.animClip = 28] = "animClip", s[s.vector2Int = 29] = "vector2Int", s[s.int32List = 30] = "int32List", s[s.colorList = 31] = "colorList", s[s.color32List = 32] = "color32List", s))(L || {});
var Fa = class {
  static GetMaterial(e) {
    let t = e, r = t.split("/");
    t = r[r.length - 1], r = t.split("."), t = r[r.length - 1];
    let i = Zo(t);
    if (i) {
      let a = new je();
      return a.shader = new i(), a;
    } else
      throw new Error("not found shader, shader name is " + t);
  }
  static applyMaterialTexture(e, t) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r];
      i.property in e ? e[i.property] = i.texture : i.property in e.shader ? e.shader[i.property] = i.texture : e.setTexture(i.property, i.texture);
    }
  }
  static applyMaterialProperties(e, t) {
    for (let r = 0; r < t.length; r++) {
      const i = t[r], a = i.key;
      switch (i.type) {
        case L.color:
        case L.color32:
          {
            let o = i.getValue();
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformColor(a, o);
          }
          break;
        case L.single:
        case L.float:
        case L.int:
        case L.int16:
        case L.int32:
        case L.uint:
        case L.uint32:
        case L.uint64:
          {
            let o = i.getValue();
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformFloat(a, o);
          }
          break;
        case L.singleArray:
          {
            let o = i.getValue()[0];
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformFloat(a, o);
          }
          break;
        case L.vector2:
        case L.vector2Int:
          {
            let o = i.getValue();
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformVector2(a, o);
          }
          break;
        case L.vector3:
          {
            let o = i.getValue();
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformVector3(a, o);
          }
          break;
        case L.vector4:
          {
            let o = i.getValue();
            a in e ? e[a] = o : a in e.shader ? e.shader[a] = o : e.setUniformVector4(a, o);
          }
          break;
      }
    }
  }
};
var Xt = class _Xt {
  static parser(e) {
    switch (e.readInt32()) {
      case L.single:
        return { t: L.single, v: e.readFloat32() };
      case L.boolean:
        return { t: L.boolean, v: e.readBoolean() };
      case L.int:
        return { t: L.int, v: e.readInt32() };
      case L.int16:
        return { t: L.int16, v: e.readInt16() };
      case L.int32:
        return { t: L.int32, v: e.readInt32() };
      case L.float:
        return { t: L.float, v: e.readFloat32() };
      case L.long:
        return { t: L.long, v: e.readFloat64() };
      case L.uint:
        return { t: L.uint, v: e.readUnit32() };
      case L.uint32:
        return { t: L.uint32, v: e.readUnit32() };
      case L.uint64:
        return { t: L.uint64, v: e.readUnit32() };
      case L.double:
        return { t: L.double, v: e.readFloat64() };
      case L.string:
        return { t: L.string, v: e.readUTF() };
      case L.singleArray:
        return { t: L.singleArray, v: e.readFloatArray() };
      case L.stringArray:
        return { t: L.stringArray, v: e.readStringArray() };
      case L.floatArray:
        return { t: L.floatArray, v: e.readFloatArray() };
      case L.vector2:
        return { t: L.vector2, v: e.readVector2() };
      case L.vector3:
        return { t: L.vector3, v: e.readVector3() };
      case L.vector4:
        return { t: L.vector4, v: e.readVector4() };
      case L.color:
        return { t: L.color, v: e.readColor() };
      case L.color32:
        return { t: L.color32, v: e.readColor() };
      case L.animationCurve:
        return { t: L.animationCurve, v: null };
      case L.quaternion:
        return { t: L.quaternion, v: e.readQuaternion() };
      case L.matrix4x4:
        return { t: L.matrix4x4, v: null };
      case L.mesh: {
        let n = e.readUTF(), l = p.res.getGeometry(n);
        return { t: L.mesh, v: l };
      }
      case L.texture: {
        let n = e.readUTF(), l = p.res.getTexture(n);
        return { t: L.texture, v: l };
      }
      case L.material: {
        let n = e.readUTF(), l = p.res.getMat(n);
        return { t: L.material, v: l };
      }
      case L.materials: {
        let n = e.readStringArray(), l = [];
        for (let h = 0; h < n.length; h++) {
          const u = n[h];
          let c = p.res.getMat(u);
          l.push(c);
        }
        return { t: L.materials, v: l };
      }
      case L.skeleton:
        break;
      case L.animClip: {
        let n = [], l = e.readInt32();
        for (let h = 0; h < l; h++) {
          let u = new cf();
          u.formBytes(e), n.push(u);
        }
        return { t: L.animClip, v: n };
      }
      case L.vector2Int:
        return { t: L.vector2Int, v: e.readVector2int() };
      case L.int32List:
        return { t: L.int32List, v: e.readInt32List() };
      case L.colorList:
        let r = e.readInt32(), i = [];
        for (let n = 0; n < r; n++) {
          const l = _Xt.parser(e).v;
          i.push(l);
        }
        return { t: L.colorList, v: i };
      case L.color32List:
        let a = e.readInt32(), o = [];
        for (let n = 0; n < a; n++) {
          const l = _Xt.parser(e).v;
          o.push(l);
        }
        return { t: L.color32List, v: o };
    }
  }
};
var Ro = class {
  constructor() {
    __publicField(this, "key");
    __publicField(this, "type");
    __publicField(this, "_data");
  }
  getValue() {
    return this._data;
  }
  formBytes(e) {
    this.key = e.readUTF();
    let { t, v: r } = Xt.parser(e);
    this.type = t, this._data = r;
  }
};
var rf = class {
  constructor() {
    __publicField(this, "property");
    __publicField(this, "name");
    __publicField(this, "texture");
    __publicField(this, "texelSize");
    __publicField(this, "wrapModeU");
    __publicField(this, "wrapModeV");
    __publicField(this, "wrapModeW");
    __publicField(this, "wrapMode");
    __publicField(this, "anisoLevel");
    __publicField(this, "dimension");
    __publicField(this, "filterMode");
  }
};
var af = class extends rt {
  static parserMaterial(e, t) {
    let r = e.readInt32();
    for (let i = 0; i < r; i++) {
      let a = e.readBytesArray(), o = a.readUTF(), n = a.readUTF();
      a.readUTF();
      let l = a.readStringArray();
      a.readVector4(), a.readVector4();
      let h = a.readUTF(), u = [], c = [], f = a.readInt32();
      for (let A = 0; A < f; A++) {
        let _ = new Ro();
        _.formBytes(a), u.push(_);
      }
      let g = a.readInt32();
      for (let A = 0; A < g; A++) {
        let _ = a.readBytesArray(), x = new rf();
        x.property = _.readUTF(), x.name = _.readUTF(), x.texture = p.res.getTexture(x.name), x.texelSize = _.readVector2(), x.wrapModeU = _.readUnit32(), x.wrapModeV = _.readUnit32(), x.wrapModeW = _.readUnit32(), x.wrapMode = _.readUnit32(), x.anisoLevel = _.readUnit32(), x.dimension = _.readUnit32(), x.filterMode = _.readUnit32(), c.push(x);
      }
      let m = Fa.GetMaterial(h);
      m.name = o;
      for (let A = 0; A < l.length; A++) {
        const _ = l[A];
        m.shader.setDefine(_, true);
      }
      Fa.applyMaterialTexture(m, c), Fa.applyMaterialProperties(m, u), p.res.addMat(n, m);
    }
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
};
__publicField(af, "format", Ue.TEXT);
var sf = class {
  constructor() {
    __publicField(this, "shapeName");
    __publicField(this, "shapeIndex");
    __publicField(this, "frameCount");
    __publicField(this, "blendPositionList", new Float32Array());
    __publicField(this, "blendNormalList", new Float32Array());
  }
  formBytes(e) {
    let t = e.readBytesArray();
    this.shapeName = t.readUTF(), this.shapeIndex = t.readInt32(), this.frameCount = t.readInt32();
    let r = t.readInt32();
    this.blendPositionList = t.readFloat32Array(r * 3);
    let i = t.readInt32();
    this.blendNormalList = t.readFloat32Array(i * 3);
  }
};
var of = class {
  constructor() {
    __publicField(this, "vertexCount");
    __publicField(this, "shapeNames");
    __publicField(this, "shapeIndexs");
    __publicField(this, "blendCount");
    __publicField(this, "blendShapePropertyDatas");
    __publicField(this, "blendShapeMap");
  }
  formBytes(e) {
    this.blendShapeMap = /* @__PURE__ */ new Map(), this.blendShapePropertyDatas = [];
    let t = e.readBytesArray();
    this.vertexCount = t.readInt32(), this.shapeNames = t.readStringArray(), this.shapeIndexs = t.readIntArray(), this.blendCount = t.readInt32();
    for (let r = 0; r < this.blendCount; r++) {
      let i = new sf();
      i.formBytes(t), this.blendShapePropertyDatas.push(i), this.blendShapeMap.set(i.shapeName, i);
    }
    return e;
  }
};
var nf = class {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "meshName");
    __publicField(this, "meshID");
    __publicField(this, "vertexCount");
    __publicField(this, "vertexStrip");
    __publicField(this, "vertexBuffer");
    __publicField(this, "indices");
    __publicField(this, "attributes");
    __publicField(this, "bones");
    __publicField(this, "bindPose");
    __publicField(this, "blendShapeData");
  }
};
var lf = class extends rt {
  async parseBuffer(e) {
  }
  static parserMeshs(e, t) {
    let r = e.readInt32();
    for (let i = 0; i < r; i++) {
      let a = new nf(), o = e.readBytesArray();
      a.meshName = o.readUTF(), a.meshID = o.readUTF(), o.readFloat32() > 0, o.readFloat32() > 0, o.readFloat32() > 0;
      let n = o.readFloat32() > 0, l = o.readFloat32() > 0;
      n && (a.bones = o.readStringArray(), a.bindPose = o.readMatrix44Array()), l && (a.blendShapeData = new of(), a.blendShapeData.formBytes(o));
      let h = o.readBytesArray(), u = o.readBytesArray(), c = h.readInt32(), f = 0, g = [];
      for (let C = 0; C < c; C++)
        g[C] = {}, g[C].att = bm[h.readUTF()], g[C].dim = h.readInt32(), f += g[C].dim, g[C].format = h.readUTF();
      a.vertexCount = h.readInt32(), a.vertexBuffer = u.getFloat32Array();
      let m = o.readInt32Array(), A = [], _ = o.readInt32();
      for (let C = 0; C < _; C++) {
        let S = o.readInt32(), I = o.readInt32(), T = o.readInt32(), b = o.readInt32(), B = o.readInt32(), R = o.readInt32();
        o.readVector3(), o.readVector3();
        let E = { indexStart: I, indexCount: T, vertexStart: b, vertexCount: R, firstStart: B, topology: S, index: C };
        A.push(E);
      }
      m.length > 65535 ? a.indices = new Uint32Array(m) : a.indices = new Uint16Array(m);
      let x = new xe();
      if (x.vertexDim = f, x.geometryType = Xe.compose_bin, x.setIndices(a.indices), x.setAttribute(D.all, a.vertexBuffer), n && (x.skinNames = a.bones, x.bindPose = a.bindPose), l) {
        x.blendShapeData = a.blendShapeData, x.morphTargetsRelative = true, x.morphTargetDictionary = {};
        for (let C = 0; C < a.blendShapeData.blendCount; C++) {
          x.setAttribute("a_morphPositions_" + C, a.blendShapeData.blendShapePropertyDatas[C].blendPositionList), x.setAttribute("a_morphNormals_" + C, a.blendShapeData.blendShapePropertyDatas[C].blendNormalList);
          for (let S = 0; S < a.blendShapeData.blendCount; S++) {
            let I = a.blendShapeData.shapeNames[S], T = a.blendShapeData.shapeIndexs[S];
            x.morphTargetDictionary[I] = T;
          }
        }
      }
      for (let C = 0; C < g.length; C++) {
        const S = g[C].att;
        x.setAttribute(S, null);
      }
      for (let C = 0; C < A.length; C++) {
        const S = A[C];
        x.addSubGeometry(S);
      }
      x.name = a.meshName, p.res.addGeometry(a.meshID, x);
    }
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
};
__publicField(lf, "format", Ue.BIN);
var bm = { Position: D.position, Normal: D.normal, Color: D.color, Tangent: D.TANGENT, TexCoord0: D.uv, TexCoord1: D.TEXCOORD_1, TexCoord2: D.TEXCOORD_2, TexCoord3: D.TEXCOORD_2, TexCoord4: D.TEXCOORD_4, TexCoord5: D.TEXCOORD_5, TexCoord6: D.TEXCOORD_6, TexCoord7: D.vIndex, BlendIndices: D.joints0, BlendWeight: D.weights0 };
var rs = class _rs extends DataView {
  constructor(e, t, r) {
    super(e, t, r);
    __publicField(this, "position", 0);
    __publicField(this, "littleEndian", true);
    this.position = 0, this.position += this.byteOffset;
  }
  readUTF() {
    let e = this.readInt32(), t = e % 4;
    t > 0 && t < 4 && (t = 4 - t);
    let r = "", i = new Int8Array(this.buffer, this.position, e);
    return this.position += e * Int8Array.BYTES_PER_ELEMENT, r += String.fromCharCode.apply(null, i), this.position += t * Int8Array.BYTES_PER_ELEMENT, r;
  }
  readStringArray() {
    let e = [], t = this.readInt32();
    for (let r = 0; r < t; r++)
      e.push(this.readUTF());
    return e;
  }
  readByte() {
    let e = this.buffer[this.position];
    return this.position += 1, e;
  }
  readBoolean() {
    let e = this.readInt32();
    return this.position += 4, e == 1;
  }
  readBytes(e) {
    let t = new DataView(this.buffer, this.position, e);
    return this.position += e, t.buffer;
  }
  readBytesArray() {
    let e = this.readInt32(), t = new _rs(this.buffer.slice(this.position, this.position + e));
    return this.position += e, t;
  }
  readUnit8() {
    let e = this.getUint8(this.position);
    return this.position += Uint8Array.BYTES_PER_ELEMENT, e;
  }
  readUnit16() {
    let e = this.getUint16(this.position);
    return this.position += Uint16Array.BYTES_PER_ELEMENT, e;
  }
  readUnit32() {
    let e = this.getUint32(this.position);
    return this.position += Uint32Array.BYTES_PER_ELEMENT, e;
  }
  readInt8() {
    let e = this.getInt8(this.position);
    return this.position += Int8Array.BYTES_PER_ELEMENT, e;
  }
  readInt16() {
    let e = this.getInt16(this.position, this.littleEndian);
    return this.position += Int16Array.BYTES_PER_ELEMENT, e;
  }
  readInt32() {
    let e = this.getInt32(this.position, this.littleEndian);
    return this.position += Int32Array.BYTES_PER_ELEMENT, e;
  }
  readFloat32() {
    let e = this.getFloat32(this.position, this.littleEndian);
    return this.position += Float32Array.BYTES_PER_ELEMENT, e;
  }
  readFloat64() {
    let e = this.getFloat64(this.position, this.littleEndian);
    return this.position += Float64Array.BYTES_PER_ELEMENT, e;
  }
  readInt32Array() {
    let e = this.readInt32(), t = new Int32Array(this.buffer, this.position, e);
    return t = t.slice(0, e), this.position += t.byteLength, t;
  }
  readInt32List() {
    let e = this.readInt32(), t = [];
    for (let r = 0; r < e; r++)
      t.push(this.readInt32());
    return t;
  }
  readFloatArray() {
    let e = this.readInt32(), t = [];
    for (let r = 0; r < e; r++) {
      let i = this.readFloat32();
      t.push(i);
    }
    return t;
  }
  readIntArray() {
    let e = this.readInt32(), t = [];
    for (let r = 0; r < e; r++) {
      let i = this.readInt32();
      t.push(i);
    }
    return t;
  }
  readVector2int() {
    let e = new Q();
    return e.x = this.readInt32(), e.y = this.readInt32(), e;
  }
  readVector2() {
    let e = new Q();
    return e.x = this.readFloat32(), e.y = this.readFloat32(), e;
  }
  readVector3() {
    let e = new d();
    return e.x = this.readFloat32(), e.y = this.readFloat32(), e.z = this.readFloat32(), e;
  }
  readVector3Array() {
    let e = [], t = this.readInt32();
    for (let r = 0; r < t; r++)
      e.push(this.readVector3());
    return e;
  }
  readVector4() {
    let e = new G();
    return e.x = this.readFloat32(), e.y = this.readFloat32(), e.z = this.readFloat32(), e.w = this.readFloat32(), e;
  }
  readVector4Array() {
    let e = [], t = this.readInt32();
    for (let r = 0; r < t; r++)
      e.push(this.readVector4());
    return e;
  }
  readColor() {
    let e = new M();
    return e.r = this.readFloat32(), e.g = this.readFloat32(), e.b = this.readFloat32(), e.a = this.readFloat32(), e;
  }
  readColorArray() {
    let e = [], t = this.readInt32();
    for (let r = 0; r < t; r++)
      e.push(this.readColor());
    return e;
  }
  readQuaternion() {
    let e = new H();
    return e.x = this.readFloat32(), e.y = this.readFloat32(), e.z = this.readFloat32(), e.w = this.readFloat32(), e;
  }
  readQuaternionArray() {
    let e = [], t = this.readInt32();
    for (let r = 0; r < t; r++)
      e.push(this.readQuaternion());
    return e;
  }
  readMatrix44() {
    let e = new P(), t = e.rawData;
    return t[0] = this.readFloat32(), t[1] = this.readFloat32(), t[2] = this.readFloat32(), t[3] = this.readFloat32(), t[4] = this.readFloat32(), t[5] = this.readFloat32(), t[6] = this.readFloat32(), t[7] = this.readFloat32(), t[8] = this.readFloat32(), t[9] = this.readFloat32(), t[10] = this.readFloat32(), t[11] = this.readFloat32(), t[12] = this.readFloat32(), t[13] = this.readFloat32(), t[14] = this.readFloat32(), t[15] = this.readFloat32(), e;
  }
  readMatrix44Array() {
    let e = this.readInt32(), t = [];
    for (let r = 0; r < e; r++) {
      let i = this.readMatrix44();
      t.push(i);
    }
    return t;
  }
  readFloat32Array(e) {
    let t = new Float32Array(this.buffer, this.position, e);
    return t = t.slice(0, this.byteLength), this.position += e * Float32Array.BYTES_PER_ELEMENT, t;
  }
  getFloat32Array() {
    let e = new Float32Array(this.buffer, this.byteOffset, this.byteLength / Float32Array.BYTES_PER_ELEMENT);
    return e = e.slice(0, this.byteLength), e;
  }
};
var hf = class extends rt {
  static async parserTexture(e, t, r) {
    let i = e.readInt32(), a = [];
    for (let n = 0; n < i; n++) {
      let l = e.readUTF();
      uf.useWebp ? (l = l.replace("png", "webp"), l = l.replace("jpb", "webp"), a.push(t.baseUrl + "webp/" + l)) : a.push(t.baseUrl + l);
    }
    let o = await p.res.loadBitmapTextures(a, p.setting.loader.numConcurrent, r, true);
    for (const n of o)
      p.res.addTexture(n.name, n);
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
};
__publicField(hf, "format", Ue.TEXT);
var Em = Object.defineProperty;
var Bm = Object.getOwnPropertyDescriptor;
var Tm = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Bm(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Em(e, t, i), i;
};
var Uo = class extends Qe {
  constructor() {
    super(), O.register("PBRLitSSSShader", qu);
    let s = new ve("PBRLitSSSShader", "PBRLitSSSShader");
    s.setShaderEntry("VertMain", "FragMain"), this.addRenderPass(s);
    let e = s.shaderState;
    e.acceptShadow = true, e.castShadow = true, e.receiveEnv = true, e.acceptGI = true, e.useLight = true, this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefine("USE_CUSTOMUNIFORM", true), this.setDefault(), this.debug(), this.computes = [new zc(this)];
  }
  debug() {
  }
  setDefault() {
    this.setUniformFloat("shadowBias", 35e-5), this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor", new M()), this.setUniformColor("emissiveColor", new M(1, 1, 1)), this.setUniformVector4("materialF0", new G(0.04, 0.04, 0.04, 1)), this.setUniformColor("specularColor", new M(0.04, 0.04, 0.04)), this.setUniformFloat("envIntensity", 1), this.setUniformFloat("normalScale", 1), this.setUniformFloat("roughness", 1), this.setUniformFloat("metallic", 0), this.setUniformFloat("ao", 1), this.setUniformFloat("roughness_min", 0), this.setUniformFloat("roughness_max", 1), this.setUniformFloat("metallic_min", 0), this.setUniformFloat("metallic_max", 1), this.setUniformFloat("emissiveIntensity", 0), this.setUniformFloat("alphaCutoff", 0), this.setUniformFloat("ior", 1.5), this.setUniformFloat("clearcoatFactor", 0), this.setUniformFloat("clearcoatRoughnessFactor", 0), this.setUniformColor("clearcoatColor", new M(1, 1, 1)), this.setUniformFloat("clearcoatWeight", 0), this.setUniformColor("skinColor", new M(1, 0, 0)), this.setUniformFloat("skinPower", 3.4), this.setUniformFloat("skinColorIns", 0.5), this.setUniformFloat("curveFactor", 1);
  }
  set _MainTex(s) {
    this.setTexture("baseMap", s);
  }
  set _BumpMap(s) {
    this.setTexture("normalMap", s);
  }
  set _SSSMap(s) {
    this.setTexture("sssMap", s);
  }
  set _MaskTex(s) {
    this.setTexture("maskMap", s);
  }
  set _UVTransform(s) {
    this.setUniformVector4("transformUV1", s);
  }
  set _Metallic(s) {
    this.setUniformFloat("metallic", s);
  }
  set _Roughness(s) {
    this.setUniformFloat("roughness", s);
  }
  set _MainColor(s) {
    this.setUniformColor("baseColor", s);
  }
  set _AlphaCutoff(s) {
    this.setUniformFloat("alphaCutoff", s);
  }
  set _DoubleSidedEnable(s) {
    let e = this.getDefaultColorShader();
    e.shaderState.cullMode = s ? nt.none : e.shaderState.cullMode;
  }
  set _SkinColor(s) {
    this.setUniformColor("skinColor", s);
  }
  set _SkinPower(s) {
    this.setUniformFloat("skinPower", s);
  }
  set _SkinColorIns(s) {
    this.setUniformFloat("skinColorIns", s);
  }
  set curveFactor(s) {
    this.setUniformFloat("curveFactor", s);
  }
  set _SurfaceType(s) {
    let e = this.getDefaultColorShader();
    s == 0 ? e.blendMode = re.NONE : e.blendMode = re.ALPHA;
  }
  set _AlphaCutoffEnable(s) {
    s == 0 ? this.setDefine("USE_ALPHACUT", false) : this.setDefine("USE_ALPHACUT", true);
  }
};
Uo = Tm([Kt], Uo);
var Dm = Object.defineProperty;
var Pm = Object.getOwnPropertyDescriptor;
var Mm = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Pm(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Dm(e, t, i), i;
};
var Lo = class extends Qe {
  constructor() {
    super();
    let s = new ve("PBRLItShader", "PBRLItShader");
    s.setShaderEntry("VertMain", "FragMain"), this.addRenderPass(s);
    let e = s.shaderState;
    e.acceptShadow = true, e.castShadow = true, e.receiveEnv = true, e.acceptGI = true, e.useLight = true, this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefault();
  }
  setDefault() {
    this.setUniformFloat("shadowBias", 35e-5), this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor", new M()), this.setUniformColor("emissiveColor", new M(0, 0, 0)), this.setUniformVector4("materialF0", new G(0.04, 0.04, 0.04, 1)), this.setUniformColor("specularColor", new M(0.04, 0.04, 0.04)), this.setUniformFloat("envIntensity", 1), this.setUniformFloat("normalScale", 1), this.setUniformFloat("roughness", 1), this.setUniformFloat("metallic", 0), this.setUniformFloat("ao", 1), this.setUniformFloat("roughness_min", 0), this.setUniformFloat("roughness_max", 1), this.setUniformFloat("metallic_min", 0), this.setUniformFloat("metallic_max", 1), this.setUniformFloat("emissiveIntensity", 0), this.setUniformFloat("alphaCutoff", 0), this.setUniformFloat("ior", 1.5), this.setUniformFloat("clearcoatFactor", 0), this.setUniformFloat("clearcoatRoughnessFactor", 0), this.setUniformColor("clearcoatColor", new M(1, 1, 1)), this.setUniformFloat("clearcoatWeight", 0), this._MainTex = p.res.grayTexture, this._BumpMap = p.res.normalTexture, this._MaskTex = p.res.maskTexture;
  }
  set _MainTex(s) {
    this.setTexture("baseMap", s);
  }
  set _BumpMap(s) {
    this.setTexture("normalMap", s);
  }
  set _MaskTex(s) {
    this.setTexture("maskMap", s);
  }
  set _UVTransform(s) {
    this.setUniformVector4("transformUV1", s);
  }
  set _Metallic(s) {
    this.setUniformFloat("metallic", s);
  }
  set _Roughness(s) {
    this.setUniformFloat("roughness", s);
  }
  set _MainColor(s) {
    this.setUniformColor("baseColor", s);
  }
  set _AlphaCutoff(s) {
    this.setUniformFloat("alphaCutoff", s);
  }
  set _DoubleSidedEnable(s) {
    let e = this.getDefaultColorShader();
    e.shaderState.cullMode = s ? nt.none : e.shaderState.cullMode;
  }
  set _SurfaceType(s) {
    let e = this.getDefaultColorShader();
    s == 0 ? e.blendMode = re.NONE : e.blendMode = re.ALPHA;
  }
  set _AlphaCutoffEnable(s) {
    s == 0 ? this.setDefine("USE_ALPHACUT", false) : this.setDefine("USE_ALPHACUT", true);
  }
};
Lo = Mm([Kt], Lo);
var is = class _is {
  constructor() {
    __publicField(this, "comName");
    __publicField(this, "data");
  }
  static parser(e) {
    let t = e.readBytesArray(), r = new _is();
    r.comName = t.readUTF(), r.data = [];
    let i = t.readInt32();
    for (let a = 0; a < i; a++) {
      let o = new Ro();
      o.formBytes(t), r.data.push(o);
    }
    return r;
  }
};
var na = class _na {
  constructor() {
    __publicField(this, "name");
    __publicField(this, "parentName");
    __publicField(this, "position");
    __publicField(this, "rotation");
    __publicField(this, "scale");
    __publicField(this, "comDatas");
    __publicField(this, "child");
  }
  static parser(e) {
    let t = e.readBytesArray(), r = new _na();
    r.name = t.readUTF(), r.parentName = t.readUTF(), r.position = t.readVector3(), r.rotation = t.readQuaternion(), r.scale = t.readVector3(), r.comDatas = [], r.child = [];
    let i = t.readInt32();
    for (let o = 0; o < i; o++) {
      const n = is.parser(t);
      r.comDatas.push(n);
    }
    let a = t.readInt32();
    for (let o = 0; o < a; o++) {
      const n = _na.parser(t);
      r.child.push(n);
    }
    return r;
  }
};
var uf = class extends rt {
  constructor() {
    super(...arguments);
    __publicField(this, "avatarDic");
    __publicField(this, "nodeData");
  }
  async parseBuffer(e) {
    this.avatarDic = {};
    let t = new rs(e, 0);
    await hf.parserTexture(t, this, this.loaderFunctions), tf.parser(t, this), lf.parserMeshs(t, this), af.parserMaterial(t, this), this.nodeData = this.parserPrefabNode(t), this.data = this.data = this.parserNodeTree(this.nodeData);
  }
  parserPrefabNode(e) {
    return na.parser(e);
  }
  parserNodeTree(e) {
    let t = new Y();
    if (t.localPosition = d.serialize(e.position), t.localQuaternion = H.serialize(e.rotation), t.localScale = d.serialize(e.scale), t.name = e.name, e.comDatas)
      for (let r = 0; r < e.comDatas.length; r++) {
        const i = e.comDatas[r];
        let a = null, o = Jo(i.comName);
        if (o) {
          a = t.getOrAddComponent(o);
          for (let n = 0; n < i.data.length; n++) {
            const l = i.data[n];
            l.key in a && (a[l.key] = l.getValue());
          }
        }
      }
    if (e.child && e.child.length > 0)
      for (let r = 0; r < e.child.length; r++) {
        let i = this.parserNodeTree(e.child[r]);
        t.addChild(i);
      }
    return t;
  }
  verification() {
    if (this.data)
      return true;
    throw new Error("verify failed.");
  }
};
__publicField(uf, "useWebp", true);
__publicField(uf, "format", Ue.BIN);
var Rm = class {
  static getNumber(e) {
    return parseFloat(e);
  }
  static getInt(e) {
    return parseInt(e);
  }
  static getBoolean(e) {
    return e == "true";
  }
  static getNumberArray(e) {
    let t = e.replaceAll("[", "");
    t = t.replaceAll("]", "");
    let r = t.split(",");
    for (let i = 0; i < r.length; i++)
      parseFloat(r[i]);
    return t;
  }
  static getStringArray(e) {
    let t = e.replaceAll("[", "");
    t = t.replaceAll("]", "");
    let r = t.split(","), i = [];
    for (let a = 0; a < r.length; a++) {
      const o = r[a];
      i.push(o);
    }
    return i;
  }
  static getVector2(e) {
  }
  static getVector3(e) {
  }
  static getVector4(e) {
  }
  static getQuaternion(e) {
  }
  static getColor(e) {
  }
};
var Um = Object.defineProperty;
var Lm = Object.getOwnPropertyDescriptor;
var Om = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Lm(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Um(e, t, i), i;
};
var Oo = class extends Qe {
  constructor() {
    super(), this.create_opPass(), this.setDefine("USEC", true), this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefine("USE_HAIR", true), this.setDefine("USE_CUSTOMUNIFORM", true), this.setDefine("USE_HAIRCOLOR", true), this.setDefault(), this.debug();
  }
  create_opPass() {
    O.register("HairShader_op", Wu);
    let s = new ve("HairShader_op", "HairShader_op");
    this.addRenderPass(s), s.setShaderEntry("VertMain", "FragMain");
    let e = s.shaderState;
    e.acceptShadow = true, e.castShadow = true, e.receiveEnv = true, e.acceptGI = true, e.useLight = true, e.blendMode = re.NONE, e.cullMode = nt.none, e.writeMasks[0] = GPUColorWrite.ALL;
  }
  create_trPass() {
    O.register("HairShader_tr", ju);
    let s = new ve("HairShader_tr", "HairShader_tr");
    this.addRenderPass(s), s.setShaderEntry("VertMain", "FragMain");
    let e = s.shaderState;
    e.acceptShadow = true, e.castShadow = true, e.receiveEnv = true, e.acceptGI = true, e.useLight = true, e.depthWriteEnabled = false, e.blendMode = re.NORMAL, e.cullMode = nt.none, e.writeMasks[0] = GPUColorWrite.ALL, e.writeMasks[1] = 0, e.writeMasks[2] = 0, e.writeMasks[3] = 0;
  }
  debug() {
  }
  setDefault() {
    this.setUniformFloat("shadowBias", 35e-5), this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor0", new M(3 / 255, 2 / 255, 2 / 255)), this.setUniformColor("baseColor1", new M(2 / 255, 2 / 255, 2 / 255)), this.setUniformColor("emissiveColor", new M(1, 1, 1)), this.setUniformVector4("materialF0", new G(0.04, 0.04, 0.04, 1)), this.setUniformColor("specularColor", new M(36 / 255, 36 / 255, 36 / 255)), this.setUniformFloat("envIntensity", 1), this.setUniformFloat("normalScale", 1), this.setUniformFloat("roughness", 0.1), this.setUniformFloat("metallic", 0.3), this.setUniformFloat("ao", 1), this.setUniformFloat("roughness_min", 0), this.setUniformFloat("roughness_max", 1), this.setUniformFloat("metallic_min", 0), this.setUniformFloat("metallic_max", 1), this.setUniformFloat("emissiveIntensity", 0), this.setUniformFloat("alphaCutoff", 0.1), this.setUniformFloat("ior", 1.5), this.setUniformFloat("backlit", 0.3987), this.setUniformFloat("area", 0.0615);
  }
  set _MainTex(s) {
    this.setTexture("baseMap", s);
  }
  set _IDMap(s) {
    this.setTexture("idMap", s);
  }
  set _DepthMap(s) {
    this.setTexture("depthMap", s);
  }
  set _RootMap(s) {
    this.setTexture("rootMap", s);
  }
  set _AlphaMap(s) {
    this.setTexture("alphaMap", s);
  }
  set _UVTransform(s) {
    this.setUniformVector4("transformUV1", s);
  }
  set _Metallic(s) {
    this.setUniformFloat("metallic", s);
  }
  set _Roughness(s) {
    this.setUniformFloat("roughness", s);
  }
  set _HairColor0(s) {
    this.setUniformColor("baseColor0", s);
  }
  set _HairColor1(s) {
    this.setUniformColor("baseColor1", s);
  }
  set _SpecularColor(s) {
    this.setUniformColor("specularColor", s);
  }
  set _AlphaCutoff(s) {
    this.setUniformFloat("alphaCutoff", s);
  }
  set _BackLit(s) {
    this.setUniformFloat("backlit", s);
  }
  set _Area(s) {
    this.setUniformFloat("area", s);
  }
  set _DoubleSidedEnable(s) {
    let e = this.getSubShaders(q.COLOR)[0];
    e.shaderState.cullMode = s ? nt.none : e.shaderState.cullMode;
  }
  set _SurfaceType(s) {
  }
  set _AlphaCutoffEnable(s) {
    s == 0 ? this.setDefine("USE_ALPHACUT", false) : this.setDefine("USE_ALPHACUT", true);
  }
};
Oo = Om([Kt], Oo);
var Fm = Object.defineProperty;
var Nm = Object.getOwnPropertyDescriptor;
var zm = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Nm(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && Fm(e, t, i), i;
};
var Na = class extends Qe {
  constructor() {
    super();
    let s = new ve("UnLit", "UnLit");
    s.setShaderEntry("VertMain", "FragMain"), this.addRenderPass(s);
    let e = s.shaderState;
    e.acceptShadow = false, e.castShadow = false, e.receiveEnv = false, e.acceptGI = false, e.useLight = false, this.setDefine("USE_BRDF", true), this.setDefine("USE_AO_R", true), this.setDefine("USE_ROUGHNESS_G", true), this.setDefine("USE_METALLIC_B", true), this.setDefine("USE_ALPHA_A", true), this.setDefault();
  }
  setDefault() {
    this.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), this.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), this.setUniformColor("baseColor", new M()), this.setUniformFloat("alphaCutoff", 0);
  }
  set _MainTex(s) {
    this.setTexture("baseMap", s);
  }
  set _BumpMap(s) {
    this.setTexture("normalMap", s);
  }
  set _MaskTex(s) {
    this.setTexture("maskMap", s);
  }
  set _UVTransform(s) {
    this.setUniformVector4("transformUV1", s);
  }
  set _Metallic(s) {
    this.setUniformFloat("metallic", s);
  }
  set _Roughness(s) {
    this.setUniformFloat("roughness", s);
  }
  set _MainColor(s) {
    this.setUniformColor("baseColor", s);
  }
  set _AlphaCutoff(s) {
    this.setUniformFloat("alphaCutoff", s);
  }
  set _DoubleSidedEnable(s) {
    let e = this.getDefaultColorShader();
    e.shaderState.cullMode = s ? nt.none : e.shaderState.cullMode;
  }
  set _SurfaceType(s) {
    let e = this.getDefaultColorShader();
    s == 0 ? e.blendMode = re.NONE : e.blendMode = re.ALPHA;
  }
  set _AlphaCutoffEnable(s) {
    s == 0 ? this.setDefine("USE_ALPHACUT", false) : this.setDefine("USE_ALPHACUT", true);
  }
};
Na = zm([Kt], Na);
var km = Object.defineProperty;
var Gm = Object.getOwnPropertyDescriptor;
var Qm = (s, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? Gm(e, t) : e, a = s.length - 1, o; a >= 0; a--)
    (o = s[a]) && (i = (r ? o(e, t, i) : o(i)) || i);
  return r && i && km(e, t, i), i;
};
var za = class extends _e {
  constructor() {
    super(...arguments);
    __publicField(this, "size");
    __publicField(this, "blockSize");
    __publicField(this, "walk");
    __publicField(this, "obs");
    __publicField(this, "colors");
    __publicField(this, "aPaths");
  }
  onGraphic(s) {
  }
};
za = Qm([_t(za, "APatch")], za);
var Vm = class {
  constructor() {
    __publicField(this, "weight");
    __publicField(this, "deltaVertices");
    __publicField(this, "deltaNormals");
    __publicField(this, "deltaTangents");
  }
  formBytes(e) {
    let t = e.readBytesArray();
    this.weight = t.readFloat32();
    let r = 0;
    r = t.readInt32(), this.deltaVertices = t.readFloat32Array(r * 3), r = t.readInt32(), this.deltaNormals = t.readFloat32Array(r * 3), r = t.readInt32(), this.deltaTangents = t.readFloat32Array(r * 3);
  }
};
var Hm = class {
  constructor() {
    __publicField(this, "asset");
    __publicField(this, "extras");
    __publicField(this, "geometricError");
    __publicField(this, "properties");
    __publicField(this, "refine");
    __publicField(this, "root");
  }
};
var Ym = class {
  constructor() {
    __publicField(this, "boundingVolume");
    __publicField(this, "children");
    __publicField(this, "geometricError");
    __publicField(this, "transform");
  }
};
var Xm = class {
  constructor() {
    __publicField(this, "boundingVolume");
    __publicField(this, "geometricError");
    __publicField(this, "refine");
    __publicField(this, "content");
    __publicField(this, "contents");
  }
};
var Wm = class {
  constructor() {
    __publicField(this, "uri");
    __publicField(this, "group");
    __publicField(this, "metadata");
  }
};
var jm = class {
  constructor() {
    __publicField(this, "class");
    __publicField(this, "properties");
  }
};
var Ho = class _Ho {
  constructor() {
    __publicField(this, "group");
    __publicField(this, "_modelList");
    __publicField(this, "_tileSet");
    __publicField(this, "_rootPath");
    this.group = new Y();
  }
  async loadTileSet(e, t) {
    this._modelList = [], this._rootPath = e;
    let r = e + "/" + t;
    if (this._tileSet = await p.res.loadJSON(r), this._tileSet.root.transform) {
      let n = new P();
      for (let l = 0; l < 16; l++)
        n.rawData[l] = this._tileSet.root.transform[l];
    }
    let i = new P();
    switch ((this._tileSet.asset && this._tileSet.asset.gltfUpAxis || "y").toLowerCase()) {
      case "x":
        i.makeRotationAxis(d.Y_AXIS, -Math.PI / 2);
        break;
      case "y":
        i.makeRotationAxis(d.X_AXIS, Math.PI / 2);
        break;
      case "z":
        i.identity();
        break;
    }
    let o = i.clone();
    o.invert(), this.applyTransform(this.group.transform, o);
    for (let n of this._tileSet.root.children) {
      let l = [];
      if (n.content && n.content.uri && l.push(n.content.uri), n.contents)
        for (let h of n.contents)
          l.push(h.uri);
      for (let h of l) {
        let u = this._rootPath + "/" + h, c = { onProgress: (g) => this.onLoadProgress(g), onComplete: (g) => this.onComplete(g) }, f;
        if (u.endsWith(".glb"))
          f = await p.res.loadGltf(u, c), this.applyTransform(f.transform, i);
        else if (u.endsWith("tileset.json")) {
          let g = u.replace("/tileset.json", ""), m = new _Ho();
          await m.loadTileSet(g, "tileset.json"), f = m.group;
        } else
          u.endsWith(".i3dm") ? f = await p.res.loadI3DM(u, c, i) : u.endsWith(".b3dm") && (f = await p.res.loadB3DM(u, c, i));
        f && (this._modelList.push(f), this.group.addChild(f));
      }
    }
  }
  onLoadProgress(e) {
  }
  onComplete(e) {
  }
  applyTransform(e, t) {
    let r = t.decompose(Zt.QUATERNION);
    e.localRotQuat.copyFrom(r[1]), e.localRotQuat = e.localRotQuat, e.localPosition.copyFrom(r[0]), e.localPosition = e.localPosition, e.localScale.copyFrom(r[2]), e.localScale = e.localScale;
  }
};
var qm = class extends je {
  constructor() {
    super(), O.register("ColorLitShader", Hu), this.shader = new Qe();
    let e = new ve("ColorLitShader", "ColorLitShader");
    e.passType = q.COLOR, this.shader.addRenderPass(e), e.setDefine("USE_BRDF", true), e.setShaderEntry("VertMain", "FragMain"), e.setUniformColor("baseColor", new M()), e.setUniformColor("emissiveColor", new M()), e.setUniformFloat("envIntensity", 1), e.setUniformFloat("normalScale", 1), e.setUniformFloat("roughness", 0), e.setUniformFloat("metallic", 0), e.setUniformFloat("ao", 1), e.setUniformFloat("alphaCutoff", 0);
    let t = e.shaderState;
    t.acceptShadow = true, t.receiveEnv = true, t.acceptGI = true, t.useLight = true, e.setTexture("normalMap", p.res.normalTexture), e.setTexture("emissiveMap", p.res.blackTexture);
  }
  clone() {
    return null;
  }
  debug() {
  }
};
__publicField(qm, "count", 0);
var Km = class extends je {
  constructor() {
    super(), O.register("GlassShader", Xu), this.shader = new Qe();
    let e = new ve("GlassShader", "GlassShader");
    e.passType = q.COLOR, e.setDefine("USE_BRDF", true), e.setShaderEntry("VertMain", "FragMain");
    let t = e.shaderState;
    t.acceptShadow = true, t.castShadow = true, t.receiveEnv = true, t.acceptGI = true, t.useLight = true, this.shader.setTexture("baseMap", p.res.whiteTexture), this.shader.setTexture("normalMap", p.res.normalTexture), this.shader.setTexture("emissiveMap", p.res.blackTexture);
  }
};
var Jm = class extends je {
  constructor() {
    super();
    let e = new ve("LambertShader", "LambertShader");
    e.setShaderEntry("VertMain", "FragMain"), e.passType = q.COLOR, e.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), e.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), e.setUniformColor("baseColor", new M(1, 1, 1, 1)), e.setUniformFloat("alphaCutoff", 0.5);
    let t = e.shaderState;
    t.acceptShadow = false, t.castShadow = false, t.receiveEnv = false, t.acceptGI = false, t.useLight = false;
    let r = new Qe();
    r.addRenderPass(e), this.shader = r, this.baseMap = p.res.grayTexture;
  }
  set baseMap(e) {
    this.shader.setTexture("baseMap", e);
  }
  get baseMap() {
    return this.shader.getTexture("baseMap");
  }
  set baseColor(e) {
    this.shader.setUniformColor("baseColor", e);
  }
  get baseColor() {
    return this.shader.getUniformColor("baseColor");
  }
  set envMap(e) {
  }
  set shadowMap(e) {
  }
};
function Zm(s, e) {
}
var $m = class extends je {
  constructor() {
    super(), this.init();
  }
  init() {
    let e = p.res.getTexture("BRDFLUT");
    this.brdfLUT = e, this.setDefault(), this.baseMap = p.res.whiteTexture, this.normalMap = p.res.normalTexture, this.emissiveMap = p.res.blackTexture, this.alphaCutoff = 0.5;
  }
  setDefault() {
    let e = this.shader.getDefaultColorShader();
    e.setUniformFloat("shadowBias", 35e-5), e.setUniformVector4("transformUV1", new G(0, 0, 1, 1)), e.setUniformVector4("transformUV2", new G(0, 0, 1, 1)), e.setUniformColor("baseColor", new M()), e.setUniformColor("emissiveColor", new M(1, 1, 1)), e.setUniformVector4("materialF0", new G(0.04, 0.04, 0.04, 1)), e.setUniformColor("specularColor", new M(0.04, 0.04, 0.04)), e.setUniformFloat("envIntensity", 1), e.setUniformFloat("normalScale", 1), e.setUniformFloat("roughness", 1), e.setUniformFloat("metallic", 0), e.setUniformFloat("ao", 1), e.setUniformFloat("roughness_min", 0), e.setUniformFloat("roughness_max", 1), e.setUniformFloat("metallic_min", 0), e.setUniformFloat("metallic_max", 1), e.setUniformFloat("emissiveIntensity", 0), e.setUniformFloat("alphaCutoff", 0), e.setUniformFloat("ior", 1.5), e.setUniformFloat("clearcoatFactor", 0), e.setUniformFloat("clearcoatRoughnessFactor", 0), e.setUniformColor("clearcoatColor", new M(1, 1, 1)), e.setUniformFloat("clearcoatWeight", 0);
  }
  get baseMap() {
    return this.shader.getDefaultColorShader().getTexture("baseMap");
  }
  set baseMap(e) {
    this.shader.getDefaultColorShader().setTexture("baseMap", e);
  }
  get baseColor() {
    return this.shader.getDefaultColorShader().getUniform("baseColor");
  }
  set baseColor(e) {
    this.shader.getDefaultColorShader().setUniformColor("baseColor", e);
  }
  get normalMap() {
    return this.shader.getDefaultColorShader().getTexture("normalMap");
  }
  set normalMap(e) {
    this.shader.getDefaultColorShader().setTexture("normalMap", e);
  }
  get doubleSide() {
    return this.shader.getDefaultColorShader().doubleSide;
  }
  set doubleSide(e) {
    this.shader.getDefaultColorShader().doubleSide = e;
  }
  get alphaCutoff() {
    return this.shader.getDefaultColorShader().shaderState.alphaCutoff;
  }
  set alphaCutoff(e) {
    this.shader.getDefaultColorShader().setDefine("USE_ALPHACUT", true), this.shader.getDefaultColorShader().shaderState.alphaCutoff = e, this.shader.getDefaultColorShader().setUniform("alphaCutoff", e);
  }
  get emissiveColor() {
    return this.shader.getDefaultColorShader().getUniform("emissiveColor");
  }
  set emissiveColor(e) {
    this.shader.getDefaultColorShader().setUniform("emissiveColor", e);
  }
  get emissiveIntensity() {
    return this.shader.getDefaultColorShader().getUniform("emissiveIntensity");
  }
  set emissiveIntensity(e) {
    this.shader.getDefaultColorShader().setUniform("emissiveIntensity", e);
  }
  get uvTransform_1() {
    return this.shader.getDefaultColorShader().uniforms.transformUV1.vector4;
  }
  set uvTransform_1(e) {
    this.shader.getDefaultColorShader().setUniform("transformUV1", e);
  }
  get uvTransform_2() {
    return this.shader.getDefaultColorShader().uniforms.transformUV2.vector4;
  }
  set uvTransform_2(e) {
    this.shader.getDefaultColorShader().setUniform("transformUV2", e);
  }
  get depthWriteEnabled() {
    return this.shader.getDefaultColorShader().shaderState.depthWriteEnabled;
  }
  set depthWriteEnabled(e) {
    this.shader.getDefaultColorShader().shaderState.depthWriteEnabled = e;
  }
  get materialF0() {
    return this.shader.getDefaultColorShader().uniforms.materialF0.vector4;
  }
  set materialF0(e) {
    this.shader.getDefaultColorShader().setUniform("materialF0", e);
  }
  get specularColor() {
    return this.shader.getDefaultColorShader().uniforms.specularColor.color;
  }
  set specularColor(e) {
    this.shader.getDefaultColorShader().setUniform("specularColor", e);
  }
  get roughness() {
    return this.shader.getDefaultColorShader().uniforms.roughness.value;
  }
  set roughness(e) {
    this.shader.getDefaultColorShader().setUniform("roughness", e);
  }
  get metallic() {
    return this.shader.getDefaultColorShader().uniforms.metallic.value;
  }
  set metallic(e) {
    this.shader.getDefaultColorShader().setUniform("metallic", e);
  }
  get ao() {
    return this.shader.getDefaultColorShader().uniforms.ao.value;
  }
  set ao(e) {
    this.shader.getDefaultColorShader().setUniform("ao", e);
  }
  get metallic_min() {
    return this.shader.getDefaultColorShader().uniforms.metallic_min.value;
  }
  set metallic_min(e) {
    this.shader.getDefaultColorShader().setUniform("metallic_min", e);
  }
  get metallic_max() {
    return this.shader.getDefaultColorShader().uniforms.metallic_max.value;
  }
  set metallic_max(e) {
    this.shader.getDefaultColorShader().setUniform("metallic_max", e);
  }
  get roughness_min() {
    return this.shader.getDefaultColorShader().uniforms.roughness_min.value;
  }
  set roughness_min(e) {
    this.shader.getDefaultColorShader().setUniform("roughness_min", e);
  }
  get roughness_max() {
    return this.shader.getDefaultColorShader().uniforms.roughness_max.value;
  }
  set roughness_max(e) {
    this.shader.getDefaultColorShader().setUniform("roughness_max", e);
  }
  get normalScale() {
    return this.shader.getDefaultColorShader().uniforms.normalScale.value;
  }
  set normalScale(e) {
    this.shader.getDefaultColorShader().setUniform("normalScale", e);
  }
  get maskMap() {
    return this.shader.getDefaultColorShader().textures.maskMap;
  }
  set maskMap(e) {
    this.shader.getDefaultColorShader().setDefine("USE_MR", true), this.shader.getDefaultColorShader().setTexture("maskMap", e);
  }
  set aoMap(e) {
    e && (this.shader.getDefaultColorShader().setTexture("aoMap", e), e != p.res.whiteTexture && this.shader.getDefaultColorShader().setDefine("USE_AOTEX", true));
  }
  get aoMap() {
    return this.shader.getDefaultColorShader().textures.aoMap;
  }
  set clearCoatRoughnessMap(e) {
    e && (console.log("USE_CLEARCOAT_ROUGHNESS"), this.shader.getDefaultColorShader().setTexture("clearCoatRoughnessMap", e), this.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS", true));
  }
  get clearCoatRoughnessMap() {
    return this.shader.getDefaultColorShader().textures.clearCoatRoughnessMap;
  }
  get brdfLUT() {
    return this.shader.getDefaultColorShader().textures.brdfLUT;
  }
  set brdfLUT(e) {
    this.shader.getDefaultColorShader().setTexture("brdfLUT", e), this.shader.getDefaultColorShader().setTexture("brdflutMap", e);
  }
  get emissiveMap() {
    return this.shader.getDefaultColorShader().textures.emissiveMap;
  }
  set emissiveMap(e) {
    this.shader.getDefaultColorShader().setTexture("emissiveMap", e);
  }
  set envIntensity(e) {
    this.shader.getDefaultColorShader().setUniformFloat("envIntensity", e);
  }
  get envIntensity() {
    return this.shader.getDefaultColorShader().uniforms.envIntensity.value;
  }
  set ior(e) {
    this.shader.getDefaultColorShader().setUniformFloat("ior", e);
  }
  get ior() {
    return this.shader.getDefaultColorShader().uniforms.ior.value;
  }
  useCleanCoat() {
    this.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
  }
  set clearcoatFactor(e) {
    this.shader.getDefaultColorShader().setUniformFloat("clearcoatFactor", e), this.useCleanCoat();
  }
  get clearcoatFactor() {
    return this.shader.getDefaultColorShader().uniforms.clearcoatFactor.value;
  }
  set clearcoatRoughnessFactor(e) {
    this.shader.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor", e), this.useCleanCoat();
  }
  get clearcoatRoughnessFactor() {
    return this.shader.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value;
  }
  set clearcoatWeight(e) {
    this.shader.getDefaultColorShader().setUniformFloat("clearcoatWeight", e), this.useCleanCoat();
  }
  get clearcoatWeight() {
    return this.shader.getDefaultColorShader().uniforms.clearcoatWeight.value;
  }
  set clearcoatColor(e) {
    this.shader.getDefaultColorShader().setUniformColor("clearcoatColor", e), this.useCleanCoat();
  }
  get clearcoatColor() {
    return this.shader.getDefaultColorShader().uniforms.clearcoatColor.color;
  }
};
var ka = class extends je {
  constructor() {
    super(), this.shader = new Na(), this.baseMap = p.res.whiteTexture;
  }
  set baseMap(e) {
    this.shader.setTexture("baseMap", e);
  }
  get baseMap() {
    return this.shader.getTexture("baseMap");
  }
  set baseColor(e) {
    this.shader.setUniformColor("baseColor", e);
  }
  get baseColor() {
    return this.shader.getUniformColor("baseColor");
  }
  set envMap(e) {
  }
  set shadowMap(e) {
  }
};
var cf = class {
  constructor() {
    __publicField(this, "clipName");
    __publicField(this, "loopTime");
    __publicField(this, "startTime");
    __publicField(this, "stopTime");
    __publicField(this, "sampleRate");
    __publicField(this, "useSkeletonPos");
    __publicField(this, "useSkeletonScale");
    __publicField(this, "positionCurves", /* @__PURE__ */ new Map());
    __publicField(this, "rotationCurves", /* @__PURE__ */ new Map());
    __publicField(this, "scaleCurves", /* @__PURE__ */ new Map());
    __publicField(this, "floatCurves", /* @__PURE__ */ new Map());
  }
  formBytes(e) {
    if (this.clipName = e.readUTF(), this.loopTime = !e.readInt32(), this.startTime = e.readFloat32(), this.stopTime = e.readFloat32(), this.sampleRate = e.readInt32(), this.useSkeletonPos = e.readInt32() > 0, this.useSkeletonScale = e.readInt32() > 0, this.useSkeletonPos) {
      let i = e.readInt32();
      for (let a = 0; a < i; a++) {
        let o = new Gi();
        o.formBytes(e), this.positionCurves.set(o.path, o);
      }
    }
    let t = e.readInt32();
    for (let i = 0; i < t; i++) {
      let a = new Gi();
      a.formBytes(e), this.rotationCurves.set(a.path, a);
    }
    if (this.useSkeletonScale) {
      let i = e.readInt32();
      for (let a = 0; a < i; a++) {
        let o = new Gi();
        o.formBytes(e), this.scaleCurves.set(o.path, o);
      }
    }
    let r = e.readInt32();
    for (let i = 0; i < r; i++) {
      let a = new Gi();
      a.formBytes(e), this.floatCurves.set(a.attribute, a);
    }
  }
};
var Gi = class {
  constructor(e = 1) {
    __publicField(this, "path");
    __publicField(this, "attribute");
    __publicField(this, "propertys");
    __publicField(this, "preInfinity");
    __publicField(this, "postInfinity");
    __publicField(this, "rotationOrder");
    __publicField(this, "m_curves");
    __publicField(this, "k", 0);
    __publicField(this, "_cacheValue");
    __publicField(this, "_kValue");
    this.k = e, this.m_curves = [], this.check();
  }
  check() {
    var _a3;
    for (let e = 0; e < this.k; e++)
      (_a3 = this.m_curves)[e] || (_a3[e] = new Ri());
    switch (this.k) {
      case 1:
        this._cacheValue = 0;
        break;
      case 2:
        this._cacheValue = new Q();
        break;
      case 3:
        this._cacheValue = new d();
        break;
      case 4:
        this._cacheValue = new G();
        break;
    }
  }
  get totalTime() {
    return this.m_curves[0].totalTime;
  }
  addKeyFrame(e) {
    for (let t = 0; t < this.k; t++)
      this.m_curves[t].addKeyFrame(e.getK(t));
  }
  removeKeyFrame(e) {
    for (let t = 0; t < this.k; t++)
      this.m_curves[t].removeKeyFrame(e.getK(t));
  }
  getValue(e) {
    switch (this.k) {
      case 1:
        this._cacheValue = this.m_curves[0].getValue(e);
        break;
      case 2:
        this._cacheValue.x = this.m_curves[0].getValue(e), this._cacheValue.y = this.m_curves[1].getValue(e);
        break;
      case 3:
        this._cacheValue.x = this.m_curves[0].getValue(e), this._cacheValue.y = this.m_curves[1].getValue(e), this._cacheValue.z = this.m_curves[2].getValue(e);
        break;
      case 4:
        this._cacheValue.x = this.m_curves[0].getValue(e), this._cacheValue.y = this.m_curves[1].getValue(e), this._cacheValue.z = this.m_curves[2].getValue(e), this._cacheValue.w = this.m_curves[3].getValue(e);
        break;
    }
    return this._cacheValue;
  }
  getKeyCount() {
    return this.m_curves[0].getKeyCount();
  }
  getKey(e) {
    let t = [];
    for (let r = 0; r < this.k; r++)
      t.push(this.m_curves[r].getKey(e));
    return t;
  }
  formBytes(e) {
    this.path = e.readUTF(), this.k = e.readInt32(), this.check(), this.attribute = e.readUTF(), this.propertys = this.attribute.split("."), this.preInfinity = e.readInt32(), this.postInfinity = e.readInt32(), this.rotationOrder = e.readInt32();
    let t = e.readInt32();
    for (let r = 0; r < t; r++) {
      let i = new Sf(0);
      i.formBytes(e), this.addKeyFrame(i);
    }
  }
};
var as = class _as {
  constructor(e = []) {
    __publicField(this, "_points");
    __publicField(this, "_cacheValue");
    this.points = e, this._cacheValue = new Q();
  }
  get points() {
    return this._points;
  }
  set points(e) {
    this._points = e;
  }
  getValue(e) {
    e < 0 && (e = 0), e > 1 && (e = 1);
    let t = this.points.length - 1, r = Math.floor(t * e), i = r + 1, a = Ze.fract((t + 1) * e);
    return i >= t && (i = r, a = 0), this._cacheValue.x = this.points[r].x + (this.points[i].x - this.points[r].x) * a, this._cacheValue.y = this.points[r].y + (this.points[i].y - this.points[r].y) * a, this._cacheValue;
  }
  static createBezierPoints(e, t) {
    for (var r = new _as(), i = 0; i < t; i++) {
      var a = _as.multiPointBezier(e, i / t);
      r.points.push(a);
    }
    return r;
  }
  static multiPointBezier(e, t) {
    for (var r = e.length, i = 0, a = 0, o = function(h, u) {
      for (var c = 1, f = 1; u > 0; )
        c *= h, f *= u, h--, u--;
      return c / f;
    }, n = 0; n < r; n++) {
      var l = e[n];
      i += l.x * Math.pow(1 - t, r - 1 - n) * Math.pow(t, n) * o(r - 1, n), a += l.y * Math.pow(1 - t, r - 1 - n) * Math.pow(t, n) * o(r - 1, n);
    }
    return new Q(i, a);
  }
};
var eA = class {
  static calculateCubicBezierPoint(e, t, r, i, a) {
    e > 1 && (e = 1), e < 0 && (e = 0);
    let o = 1 - e, n = o * o, l = o * o * o, h = e * e, u = e * e * e, c = t.mul(l), f = r.mul(3);
    f = f.mul(e), f = f.mul(n);
    let g = i.mul(3);
    g = g.mul(h), g = g.mul(o);
    let m = a.mul(u);
    return c = c.add(f), c = c.add(g), c = c.add(m), c;
  }
  static bezierPoint(e, t, r, i) {
    e > 1 && (e = 1), e < 0 && (e = 0);
    let a = 1 - e, o = a * a, n = e * e, l = t.mul(o), h = r.mul(2);
    h.scaleBy(a), h.scaleBy(e);
    let u = i.mul(n);
    return l = l.add(h), l = l.add(u), l;
  }
  static calculateCubicBezierPoints(e, t, r) {
    e > 1 && (e = 1), e < 0 && (e = 0);
    let i = 1 - e, a = i * i, o = i * i * i, n = e * e, l = e * e * e, h = t[r].mul(o), u = t[r + 1].mul(3);
    u = u.mul(e), u = u.mul(a);
    let c = t[r + 2].mul(3);
    c = c.mul(n), c = c.mul(i);
    let f = t[r + 3].mul(l);
    return h = h.add(u), h = h.add(c), h = h.add(f), h;
  }
  static bezierPathValue(e, t) {
    e > 1 && (e = 1), e < 0 && (e = 0);
    let r = t.length, i = this.tmp_points;
    i.length = 0;
    for (let a = 1; a < r; ++a)
      for (let o = 0; o < r - a; ++o) {
        if (a == 1) {
          let l = new d();
          l.x = t[o].x * (1 - e) + t[o + 1].x * e, l.y = t[o].y * (1 - e) + t[o + 1].y * e, l.z = t[o].z * (1 - e) + t[o + 1].z * e, this.tmp_points.push(l);
          continue;
        }
        let n = new d();
        n.x = i[o].x * (1 - e) + i[o + 1].x * e, n.y = i[o].y * (1 - e) + i[o + 1].y * e, n.z = i[o].z * (1 - e) + i[o + 1].z * e, i.push(n);
      }
    return i[0];
  }
};
__publicField(eA, "tmp_points", []);
var tA = class extends Map {
  constructor(e) {
    super(e);
    __publicField(this, "negtive");
    if (this.negtive = /* @__PURE__ */ new Map(), e)
      for (let t of e)
        this.negtive.set(t[1], t[0]);
  }
  delete(e) {
    if (this.has(e)) {
      let t = this.get(e);
      return this.negtive.delete(t), super.delete(e);
    }
    return false;
  }
  getKey(e) {
    return this.negtive.get(e);
  }
  deleteValue(e) {
    let t = this.negtive.get(e);
    return t && this.delete(t), this.negtive.delete(e);
  }
  set(e, t) {
    return super.set(e, t), this.negtive.set(t, e), this;
  }
  clear() {
    this.negtive.clear(), super.clear();
  }
};
var Ga = class {
  constructor(e) {
    __publicField(this, "controlVertices");
    this.setControlVertices(e);
  }
  setControlVertices(e) {
    e.length == 4 && (this.controlVertices = e.concat());
  }
  getPoint(e) {
    if (!(e >= 0 && e <= 1))
      return d.ZERO;
    let t = 1 - e, r = t * t * t, i = 3 * e * t * t, a = 3 * e * e * t, o = e * e * e;
    return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(i)).add(this.controlVertices[2].mul(a)).add(this.controlVertices[3].mul(o));
  }
  getTangent(e) {
    if (!(e >= 0 && e <= 1))
      return d.ZERO;
    let t = this.controlVertices, r = t[0].add(t[1].add(t[0]).mul(e)), i = t[1].add(t[2].add(t[1]).mul(e)), a = t[2].add(t[3].add(t[2]).mul(e)), o = r.add(i.subtract(r).mul(e));
    return i.add(a.subtract(i).mul(e)).subtract(o);
  }
  getClosestParam(e, t = 1e-6) {
    return this.getClosestParamRec(e, 0, 1, t);
  }
  getClosestParamRec(e, t, r, i) {
    let a = (t + r) / 2;
    if (r - t < i)
      return a;
    let o = (t + a) / 2, n = (a + r) / 2, l = this.getPoint(o), h = this.getPoint(n), u = l.subtract(e).lengthSquared, c = h.subtract(e).lengthSquared;
    return u < c ? r = a : t = a, this.getClosestParamRec(e, t, r, i);
  }
};
var ff = ((s) => (s[s.Open = 0] = "Open", s[s.Closed = 1] = "Closed", s))(ff || {});
var rA = class {
  constructor(e, t = 0) {
    __publicField(this, "type", 0);
    __publicField(this, "numCurveSegments", 0);
    __publicField(this, "numControlVertices", 0);
    __publicField(this, "controlVertices", []);
    this.setControlVertices(e, t);
  }
  getPathType() {
    return this.type;
  }
  isClosed() {
    return this.type == 1;
  }
  isValid() {
    return this.numCurveSegments > 0;
  }
  clear() {
    this.controlVertices.length = 0, this.type = 0, this.numCurveSegments = 0, this.numControlVertices = 0;
  }
  computeApproxLength() {
    if (!this.isValid())
      return 0;
    let e = this.numCurveSegments + 1;
    if (e < 2)
      return 0;
    let t = 0, r = this.controlVertices;
    for (let i = 1; i < e; i++) {
      let a = r[(i - 1) * 3], o = r[i * 3];
      t += a.subtract(o).lengthSquared;
    }
    return t == 0 ? 0 : t;
  }
  computeApproxParamPerUnitLength() {
    let e = this.computeApproxLength();
    return this.numCurveSegments / e;
  }
  computeApproxNormParamPerUnitLength() {
    return 1 / this.computeApproxLength();
  }
  interpolatePoints(e, t) {
    let r = e.length;
    r < 2 && console.error("point count must great 1"), this.clear(), this.type = t;
    let i = this.controlVertices;
    switch (t) {
      case 0: {
        this.numCurveSegments = r - 1, this.numControlVertices = 3 * r - 2, i.length = this.numControlVertices;
        for (let n = 0; n < r; n++)
          i[n * 3] = e[n];
        let a = e[1].subtract(e[0]).mul(0.25);
        i[1] = e[0].add(a);
        let o = e[r - 2].subtract(e[r - 1]).mul(0.25);
        i[this.numControlVertices - 2] = e[r - 1].add(o);
        for (let n = 1; n < this.numCurveSegments; n++) {
          let l = e[n - 1].subtract(e[n]), h = e[n + 1].subtract(e[n]), u = l.lengthSquared, c = h.lengthSquared;
          if (u > 0 && c > 0) {
            let f = (u + c) / 8, g = h.div(c).subtract(l.div(u));
            g.normalize(), g = g.mul(f), i[n * 3 - 1] = e[n].subtract(g), i[n * 3 + 1] = e[n].add(g);
          } else
            i[n * 3 - 1] = e[n], i[n * 3 + 1] = e[n];
        }
        break;
      }
      case 1: {
        this.numCurveSegments = r, this.numControlVertices = 3 * r + 1, i.length = this.numControlVertices;
        for (let a = 0; a < r; a++)
          i[a * 3] = e[a];
        i[this.numControlVertices - 1] = e[0];
        for (let a = 1; a <= this.numCurveSegments; a++) {
          let o = a - 1, n = (a + 1) % this.numCurveSegments, l = a % this.numCurveSegments, h = e[o].subtract(e[l]), u = e[n].subtract(e[l]), c = h.lengthSquared, f = u.lengthSquared, g = 3 * a - 1, m = (3 * a + 1) % (this.numControlVertices - 1);
          if (c > 0 && f > 0) {
            let A = (c + f) / 8, _ = u.div(f).subtract(h.div(c));
            _.normalize(), _ = _.mul(A), i[g] = e[l].subtract(_), i[m] = e[l].add(_);
          } else
            i[g] = e[l], i[m] = e[l];
        }
        break;
      }
    }
  }
  setControlVertices(e, t) {
    let r = e.length;
    r <= 0 || t == 0 && r < 4 || t == 1 && r < 7 || (r - 1) % 3 == 0 && (this.clear(), this.type = t, this.numControlVertices = r, this.numCurveSegments = (r - 1) / 3, this.controlVertices = e);
  }
  getPoint(e) {
    if (this.type == 1) {
      for (; e < 0; )
        e += this.numCurveSegments;
      for (; e > this.numCurveSegments; )
        e -= this.numCurveSegments;
    } else
      e = Ze.clampf(e, 0, this.numCurveSegments);
    if (!(e >= 0) && e <= this.numCurveSegments)
      return;
    let t = Math.floor(e);
    t >= this.numCurveSegments && (t = this.numCurveSegments - 1);
    let r = [], i = this.controlVertices;
    return r[0] = i[3 * t + 0], r[1] = i[3 * t + 1], r[2] = i[3 * t + 2], r[3] = i[3 * t + 3], new Ga(r).getPoint(e - t);
  }
  getPointNorm(e) {
    return this.getPoint(e * this.numCurveSegments);
  }
  getTangent(e) {
    if (this.type == 1) {
      for (; e < 0; )
        e += this.numCurveSegments;
      for (; e > this.numCurveSegments; )
        e -= this.numCurveSegments;
    } else
      e = Ze.clampf(e, 0, this.numCurveSegments);
    if (!(e >= 0) && e <= this.numCurveSegments)
      return;
    let t = Math.floor(e);
    t >= this.numCurveSegments && (t = this.numCurveSegments - 1);
    let r = this.controlVertices, i = [];
    return i[0] = r[3 * t + 0], i[1] = r[3 * t + 1], i[2] = r[3 * t + 2], i[3] = r[3 * t + 3], new Ga(i).getTangent(e - t);
  }
  getTangentNorm(e) {
    return this.getTangent(e * this.numCurveSegments);
  }
  computeClosestParam(e, t) {
    let r = Number.MAX_SAFE_INTEGER, i = 0, a = [], o = new Ga(a);
    for (let n = 0; n < this.controlVertices.length - 1; n += 3) {
      for (let c = 0; c < 4; c++)
        a[c] = this.controlVertices[n + c];
      o.setControlVertices(a);
      let l = o.getClosestParam(e, t), u = o.getPoint(l).subtract(e).lengthSquared;
      u < r && (r = u, i = n / 3 + l);
    }
    return i;
  }
  computeClosestNormParam(e, t) {
    return this.computeClosestParam(e, t * this.numCurveSegments);
  }
};
var iA = class extends Map {
  constructor(e, t, r) {
    var _a3, _b;
    super(e);
    __publicField(this, "valueList");
    __publicField(this, "keyList");
    __publicField(this, "isChange", true);
    if (t && (this.keyList = []), r && (this.valueList = []), e)
      for (let i of e)
        (_a3 = this.valueList) == null ? void 0 : _a3.push(i[1]), (_b = this.keyList) == null ? void 0 : _b.push(i[0]);
  }
  delete(e) {
    if (this.has(e)) {
      let t = this.get(e);
      return this.valueList && this.deleteValue(t), this.keyList && this.deleteKey(e), this.isChange = true, super.delete(e);
    }
    return false;
  }
  deleteValue(e) {
    let t = this.valueList.indexOf(e);
    return t >= 0 && this.valueList.splice(t, 1), this;
  }
  deleteKey(e) {
    let t = this.keyList.indexOf(e);
    return t >= 0 && this.keyList.splice(t, 1), this;
  }
  set(e, t) {
    var _a3, _b;
    return this.delete(e), (_a3 = this.keyList) == null ? void 0 : _a3.push(e), (_b = this.valueList) == null ? void 0 : _b.push(t), super.set(e, t), this.isChange = true, this;
  }
  clear() {
    this.valueList && (this.valueList.length = 0), this.keyList && (this.keyList.length = 0), this.isChange = true, super.clear();
  }
};
var df = ((s) => (s[s.kParticleSystemClampVelocityCurveId = 322376503] = "kParticleSystemClampVelocityCurveId", s[s.kParticleSystemForceCurveId = 306581307] = "kParticleSystemForceCurveId", s[s.kParticleSystemRotationCurveId = 1793934638] = "kParticleSystemRotationCurveId", s[s.kParticleSystemRotationBySpeedCurveId = 3737431713] = "kParticleSystemRotationBySpeedCurveId", s[s.kParticleSystemStartSpeedCurveId = 2527743459] = "kParticleSystemStartSpeedCurveId", s[s.kParticleSystemSizeCurveId = 2368504881] = "kParticleSystemSizeCurveId", s[s.kParticleSystemSizeBySpeedCurveId = 4085612399] = "kParticleSystemSizeBySpeedCurveId", s[s.kParticleSystemVelocityCurveId = 3774601268] = "kParticleSystemVelocityCurveId", s[s.kParticleSystemUVCurveId = 326370691] = "kParticleSystemUVCurveId", s[s.kParticleSystemColorGradientId = 1494990940] = "kParticleSystemColorGradientId", s[s.kParticleSystemColorByVelocityGradientId = 1089181156] = "kParticleSystemColorByVelocityGradientId", s[s.kParticleSystemMeshSelectionId = 3159510623] = "kParticleSystemMeshSelectionId", s[s.kParticleSystemUVRowSelectionId = 2941263940] = "kParticleSystemUVRowSelectionId", s))(df || {});
var aA = 3.141592653589793;
var sA = class {
};
function gf(s, e, t) {
  let r = 0.3333333333333333, i = 0.5, a = s * r, o = a * a, l = o * a - a * e * i + t * i, h = -o + e * r, u = h * h * h, c = u + l * l;
  if (c >= 0) {
    let m = Math.sqrt(c) - l;
    return m = m > 0 ? Math.pow(m, r) : -Math.pow(-m, r), -a - h / m + m;
  }
  let f = Math.sqrt(-u), g = Math.acos(-l / f);
  return f = Math.pow(f, r), f = f - h / f, g = -a + f * Math.cos(g * r), g;
}
function Qa(s, e, t, r) {
  let i = 1e-5;
  if (Math.abs(s) < i)
    return Math.abs(e) > i ? (r.r0 = -t / e, 1) : 0;
  let a = e * e - 4 * s * t;
  if (a < 0)
    return 0;
  let o = 0.5 / s, n = Math.sqrt(a);
  return r.r0 = (n - e) * o, r.r1 = (-n - e) * o, 2;
}
function pf(s, e, t, r, i) {
  let a = 0;
  if (Math.abs(e) >= 1e-4) {
    let o = t / e, n = r / e, l = i / e;
    s[0] = gf(o, n, l), a++;
    let h = e, u = t + e * s[0], c = r + t * s[0] + e * s[0] * s[0];
    a += Qa(h, u, c, { r0: s[1], r1: s[2] });
  } else
    a += Qa(t, r, i, { r0: s[1], r1: s[2] });
  return a;
}
var Yt = class {
  constructor() {
    __publicField(this, "coeff", []);
  }
  static EvalSegment(e, t) {
    return e * (e * (e * t[0] + t[1]) + t[2]) + t[3];
  }
};
var _hr = class _hr {
  constructor() {
    __publicField(this, "segments", []);
    __publicField(this, "integrationCache", []);
    __publicField(this, "doubleIntegrationCache", []);
    __publicField(this, "times", []);
    __publicField(this, "segmentCount");
    this.segments[_hr.kMaxNumSegments] = new Yt(), this.integrationCache[_hr.kMaxNumSegments] = 0, this.doubleIntegrationCache[_hr.kMaxNumSegments] = 0, this.times[_hr.kMaxNumSegments] = 0;
  }
  calculateMinMax(e, t) {
    e.x = Math.min(e.x, t), e.y = Math.max(e.y, t);
  }
  findMinMaxDoubleIntegrated() {
    let e = Q.ZERO.clone(), t = 20, r = 1 / t, i = r;
    for (let a = 0; a < t; a++)
      this.calculateMinMax(e, this.evaluateDoubleIntegrated(i)), i += r;
    return e;
  }
  findMinMaxIntegrated() {
    let e = Q.ZERO.clone(), t = [], r = [];
    for (let i = 0; i < this.segmentCount; i++) {
      let a = 4 * this.segments[i].coeff[0], o = 3 * this.segments[i].coeff[1], n = 2 * this.segments[i].coeff[2], l = 1 * this.segments[i].coeff[3], h = [], u = pf(h, a, o, n, l);
      for (let c = 0; c < u; c++) {
        let f = h[c] + t[i];
        f >= t[i] && f < r[i] && this.calculateMinMax(e, this.evaluateIntegrated(f));
      }
      this.calculateMinMax(e, this.evaluateIntegrated(r[i])), this.times[i];
    }
    return e;
  }
  generateIntegrationCache(e) {
    e.integrationCache[0] = 0;
    let t = e.times[0], r = 0;
    for (let i = 1; i < e.segmentCount; i++) {
      let a = e.segments[i - 1].coeff;
      Fo(a);
      let o = t - r;
      e.integrationCache[i] = e.integrationCache[i - 1] + Yt.EvalSegment(o, a) * o, r = t, t = e.times[i];
    }
  }
  generateDoubleIntegrationCache(e) {
    let t = 0, r = 0;
    for (let i = 0; i < e.segmentCount; i++) {
      e.doubleIntegrationCache[i] = t;
      let a = e.times[i] - r;
      a = Math.max(a, 0), t += Yt.EvalSegment(a, e.segments[i].coeff) * a * a + e.integrationCache[i] * a, r = e.times[i];
    }
  }
  integrate() {
    this.generateIntegrationCache(this);
    for (let e = 0; e < this.segmentCount; e++)
      Fo(this.segments[e].coeff);
  }
  doubleIntegrate() {
    this.generateIntegrationCache(this);
    for (let e = 0; e < this.segmentCount; e++)
      mf(this.segments[e].coeff);
    this.generateDoubleIntegrationCache(this);
  }
  static isValidCurve(e) {
    let t = e.getKeyCount(), r = t - 1;
    return e.getKey(0).time != 0 && r++, e.getKey(t - 1).time != 1 && r++, r <= _hr.kMaxNumSegments;
  }
  evaluateDoubleIntegrated(e) {
    let t = 0;
    for (let r = 0; r < this.segmentCount; r++) {
      if (e <= this.times[r]) {
        let i = e - t;
        return this.doubleIntegrationCache[r] + this.integrationCache[r] * i + Yt.EvalSegment(i, this.segments[r].coeff) * i * i;
      }
      t = this.times[r];
    }
    return 1;
  }
  evaluateIntegrated(e) {
    let t = 0;
    for (let r = 0; r < this.segmentCount; r++) {
      if (e <= this.times[r]) {
        let i = e - t;
        return this.integrationCache[r] + Yt.EvalSegment(i, this.segments[r].coeff) * i;
      }
      t = this.times[r];
    }
    return 1;
  }
  evaluate(e) {
    let t = 0;
    for (let r = 0; r < this.segmentCount; r++) {
      if (e <= this.times[r])
        return Yt.EvalSegment(e - t, this.segments[r].coeff);
      t = this.times[r];
    }
    return 1;
  }
  buildCurve(e, t) {
    let r = e.getKeyCount();
    this.segmentCount = 1;
    let i = 1.01;
    if (this.segments.length = 0, this.integrationCache.length = 0, this.doubleIntegrationCache.length = 0, this.times.length = 0, this.times[0] = i, r != 0)
      if (r == 1)
        this.segments[0] = new Yt(), this.segments[0].coeff[3] = e.getKey(0).value * t;
      else {
        this.segmentCount = r - 1;
        let a = 0;
        e.getKey(0).time != 0 && (this.segments[0].coeff[3] = e.getKey(0).value, this.times[0] = e.getKey(0).time, a = 1);
        for (let o = 0; o < this.segmentCount; o++) {
          let n;
          e.calculateCacheData(n, o, o + 1, 0), this.segments[o + a].coeff = n.coeff.concat(), this.times[o + a] = e.getKey(o + 1).time;
        }
        this.segmentCount += a, e.getKey(r - 1).time != 1 && (this.segments[this.segmentCount].coeff[3] = e.getKey(r - 1).value, this.segmentCount++), this.times[this.segmentCount - 1] = i;
        for (let o = 0; o < this.segmentCount; o++)
          this.segments[o].coeff[0] *= t, this.segments[o].coeff[1] *= t, this.segments[o].coeff[2] *= t, this.segments[o].coeff[3] *= t;
      }
    return true;
  }
};
__publicField(_hr, "kMaxNumSegments", 8);
var hr = _hr;
function mf(s) {
  s[0] /= 20, s[1] /= 12, s[2] /= 6, s[3] /= 2;
}
function Fo(s) {
  s[0] /= 4, s[1] /= 3, s[2] /= 2, s[3] /= 1;
}
var Af = ((s) => (s[s.kEMScalar = 0] = "kEMScalar", s[s.kEMOptimized = 1] = "kEMOptimized", s[s.kEMOptimizedMinMax = 2] = "kEMOptimizedMinMax", s[s.kEMSlow = 3] = "kEMSlow", s))(Af || {});
var vf = ((s) => (s[s.kMMCScalar = 0] = "kMMCScalar", s[s.kMMCCurve = 1] = "kMMCCurve", s[s.kMMCTwoCurves = 2] = "kMMCTwoCurves", s[s.kMMCTwoConstants = 3] = "kMMCTwoConstants", s))(vf || {});
var oA = class {
  constructor() {
    __publicField(this, "max");
    __publicField(this, "min");
  }
};
var nA = class {
  constructor() {
    __publicField(this, "max");
    __publicField(this, "min");
  }
  integrate() {
    this.max.integrate(), this.min.integrate();
  }
  doubleIntegrate() {
    this.max.doubleIntegrate(), this.min.doubleIntegrate();
  }
  findMinMaxIntegrated() {
    return null;
  }
  findMinMaxDoubleIntegrated() {
    return null;
  }
};
var xf = class {
  constructor(e = 1) {
    __publicField(this, "minMaxState");
    __publicField(this, "minCurve");
    __publicField(this, "maxCurve");
    __publicField(this, "_scalar", 1);
    __publicField(this, "_minScalar");
    this._scalar = e, this.minMaxState = 0, this.minCurve = new Ri(), this.maxCurve = new Ri();
  }
  setScalar(e) {
    this._scalar = e;
  }
  getScalar() {
    return this._scalar;
  }
  static evaluateSlow(e, t, r) {
    let i = e.maxCurve.getValue(t) * e.getScalar();
    return e.minMaxState == 2 ? Er(e.minCurve.getValue(t) * e.getScalar(), i, r) : i;
  }
  static evaluate(e, t, r = 1) {
    if (e.minMaxState == 0)
      return e.getScalar();
    let i = e.maxCurve.getValue(t) * e.getScalar();
    return e.minMaxState == 1 ? Er(e.minCurve.getValue(t) * e.getScalar(), i, r) : e.minMaxState == 3 ? Er(e._minScalar, e._scalar, r) : e.minMaxState == 2 ? Er(e.minCurve.getValue(t) * e.getScalar(), i, 1 * Math.random()) : this.evaluateSlow(e, t, 1);
  }
  unSerialized(e) {
    this.minMaxState = e.minMaxState, this._scalar = e.scalar, this._minScalar = e.minScalar, this.maxCurve.unSerialized(e.maxCurve), this.minCurve.unSerialized(e.minCurve);
  }
};
var lA = class {
  constructor() {
    __publicField(this, "value", 0);
    __publicField(this, "mode", 0);
    __publicField(this, "spread", 0);
    __publicField(this, "speed", new xf());
  }
  unSerialized(e) {
    this.value = e.value, this.mode = e.mode, this.spread = e.spread, this.speed.unSerialized(e.speed);
  }
};
function hA(s, e) {
  let t = hr.isValidCurve(s.max);
  return e != 2 && e != 3 ? t : t && hr.isValidCurve(s.min);
}
function uA(s, e, t, r) {
  s.max.buildCurve(e.max, t), r != 2 && r != 3 ? s.min.buildCurve(e.max, t) : s.min.buildCurve(e.min, t);
}
function cA(s, e) {
  let t = e.getKeyCount();
  if (t != 0)
    if (t == 1)
      Qi(s, e.getKey(0).value);
    else {
      let r = t - 1;
      Qi(s, e.getKey(0).value);
      for (let i = 0; i < r; i++) {
        let a = new Io();
        e.calculateCacheData(a, i, i + 1, 0);
        let o = 3 * a.coeff[0], n = 2 * a.coeff[1], l = 1 * a.coeff[2], h = e.getKey(i).time, u = e.getKey(i + 1).time, c = [], f = Qa(o, n, l, { r0: c[0], r1: c[1] });
        for (let g = 0; g < f; g++)
          c[g] >= 0 && c[g] + h < u && Qi(s, Yt.EvalSegment(c[g], a.coeff));
        Qi(s, Yt.EvalSegment(u - h, a.coeff));
      }
    }
}
function Qi(s, e) {
  s.x = Math.min(s.x, e), s.y = Math.max(s.y, e);
}
var Yo = class _Yo {
  constructor(e, t) {
    __publicField(this, "point", new d());
    __publicField(this, "normal", d.UP);
    __publicField(this, "_tmpVecA", new d());
    this.point = e, this.normal = t;
  }
  clone() {
    return new _Yo(this.point.clone(), this.normal.clone());
  }
  intersectsLine(e, t, r) {
    var i = -this.normal.dotProduct(this.point), a = this.normal.dotProduct(e) + i, o = this.normal.dotProduct(t) + i, n = a / (a - o), l = n >= 0 && n <= 1;
    return l && r && r.lerp(e, t, n), l;
  }
  intersectsRay(e, t) {
    t || (t = this._tmpVecA), t.copy(this.point).subtract(e.origin, t);
    var r = this.normal.dotProduct(t) / this.normal.dotProduct(e.direction), i = r >= 0;
    return i && t.copyFrom(e.direction).multiplyScalar(r).add(e.origin, t), i;
  }
};
var Rr = class {
};
__publicField(Rr, "BACK", 0);
__publicField(Rr, "FRONT", 1);
__publicField(Rr, "IN", 0);
__publicField(Rr, "OUT", 1);
__publicField(Rr, "INTERSECT", 2);
var _f = class {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    this.a = e, this.b = t, this.c = r, this.d = i;
  }
  setTo(e = 0, t = 0, r = 0, i = 0) {
    this.a = e, this.b = t, this.c = r, this.d = i;
  }
  fromPoints(e, t, r) {
    var i = t.x - e.x, a = t.y - e.y, o = t.z - e.z, n = r.x - e.x, l = r.y - e.y, h = r.z - e.z;
    this.a = a * h - o * l, this.b = o * n - i * h, this.c = i * l - a * n, this.d = -(this.a * e.x + this.b * e.y + this.c * e.z);
  }
  fromNormalAndPoint(e, t) {
    this.a = e.x, this.b = e.y, this.c = e.z, this.d = -(this.a * t.x + this.b * t.y + this.c * t.z);
  }
  normalize() {
    var e = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
    if (e > 0) {
      var t = 1 / e;
      this.a *= t, this.b *= t, this.c *= t, this.d *= t;
    }
    return e;
  }
  distance(e) {
    return this.a * e.x + this.b * e.y + this.c * e.z + this.d;
  }
  classifyPoint(e, t = 0.01) {
    var r = this.distance(e);
    return r < -t ? Rr.BACK : r > t ? Rr.FRONT : Rr.INTERSECT;
  }
  toString() {
    return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
  }
};
__publicField(_f, "ALIGN_ANY", 0);
__publicField(_f, "ALIGN_XY_AXIS", 1);
__publicField(_f, "ALIGN_YZ_AXIS", 2);
__publicField(_f, "ALIGN_XZ_AXIS", 3);
function fA(s, e) {
  return Math.random() * e + Math.random() * s + (e - s) * Math.random();
}
function dA(s, e, t) {
  let r = t * Math.random();
  return Math.random() * e * r + Math.random() * s * r + (e - s) * Math.random() * r;
}
function Cf(s, e, t) {
  let r = 0, i = 0;
  for (; r === 0; )
    r = Math.random();
  for (; i === 0; )
    i = Math.random();
  let a = Math.sqrt(-2 * Math.log(r)) * Math.cos(2 * Math.PI * i);
  return a = a / 10 + 0.5, (a > 1 || a < 0) && (a = Cf(s, e, t)), a = Math.pow(a, t), a *= e - s, a += s, a;
}
function Rt(s) {
  return s > 0 ? Math.floor(s) : Math.floor(s) - 1;
}
var K = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180, 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
function No(s, e) {
  let t = s & 15, r = 1 + (t & 7);
  return t & 8 && (r = -r), r * e;
}
function Va(s, e, t) {
  let r = s & 7, i = r < 4 ? e : t, a = r < 4 ? t : e;
  return (r & 1 ? -i : i) + (r & 2 ? -2 * a : 2 * a);
}
function Vi(s, e, t, r) {
  let i = s & 15, a = i < 8 ? e : t, o = i < 4 ? t : i == 12 || i == 14 ? e : r;
  return (i & 1 ? -a : a) + (i & 2 ? -o : o);
}
function si(s, e, t, r, i) {
  let a = s & 31, o = a < 24 ? e : t, n = a < 16 ? t : r, l = a < 8 ? r : i;
  return (a & 1 ? -o : o) + (a & 2 ? -n : n) + (a & 4 ? -l : l);
}
var pt = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
function gA(s) {
  let e = Rt(s), t = e + 1, r = s - e, i = r - 1, a, o, n = 1 - r * r;
  n *= n, a = n * n * No(K[e & 255], r);
  let l = 1 - i * i;
  return l *= l, o = l * l * No(K[t & 255], i), 0.25 * (a + o);
}
function pA(s, e) {
  const t = 0.366025403, r = 0.211324865;
  let i, a, o, n = (s + e) * t, l = s + n, h = e + n, u = Rt(l), c = Rt(h), f = (u + c) * r, g = u - f, m = c - f, A = s - g, _ = e - m, x, C;
  A > _ ? (x = 1, C = 0) : (x = 0, C = 1);
  let S = A - x + r, I = _ - C + r, T = A - 1 + 2 * r, b = _ - 1 + 2 * r, B = u & 255, R = c & 255, E = 0.5 - A * A - _ * _;
  E < 0 ? i = 0 : (E *= E, i = E * E * Va(K[B + K[R]], A, _));
  let F = 0.5 - S * S - I * I;
  F < 0 ? a = 0 : (F *= F, a = F * F * Va(K[B + x + K[R + C]], S, I));
  let k = 0.5 - T * T - b * b;
  return k < 0 ? o = 0 : (k *= k, o = k * k * Va(K[B + 1 + K[R + 1]], T, b)), 40 * (i + a + o);
}
function mA(s, e, t) {
  const r = 0.333333333, i = 0.166666667;
  let a, o, n, l, h = (s + e + t) * r, u = s + h, c = e + h, f = t + h, g = Rt(u), m = Rt(c), A = Rt(f), _ = (g + m + A) * i, x = g - _, C = m - _, S = A - _, I = s - x, T = e - C, b = t - S, B, R, E, F, k, V;
  I >= T ? T >= b ? (B = 1, R = 0, E = 0, F = 1, k = 1, V = 0) : I >= b ? (B = 1, R = 0, E = 0, F = 1, k = 0, V = 1) : (B = 0, R = 0, E = 1, F = 1, k = 0, V = 1) : T < b ? (B = 0, R = 0, E = 1, F = 0, k = 1, V = 1) : I < b ? (B = 0, R = 1, E = 0, F = 0, k = 1, V = 1) : (B = 0, R = 1, E = 0, F = 1, k = 1, V = 0);
  let j = I - B + i, te = T - R + i, pe = b - E + i, ne = I - F + 2 * i, we = T - k + 2 * i, Oe = b - V + 2 * i, se = I - 1 + 3 * i, Be = T - 1 + 3 * i, le = b - 1 + 3 * i, Te = g & 255, st = m & 255, ot = A & 255, At = 0.6 - I * I - T * T - b * b;
  At < 0 ? a = 0 : (At *= At, a = At * At * Vi(K[Te + K[st + K[ot]]], I, T, b));
  let vt = 0.6 - j * j - te * te - pe * pe;
  vt < 0 ? o = 0 : (vt *= vt, o = vt * vt * Vi(K[Te + B + K[st + R + K[ot + E]]], j, te, pe));
  let xt = 0.6 - ne * ne - we * we - Oe * Oe;
  xt < 0 ? n = 0 : (xt *= xt, n = xt * xt * Vi(K[Te + F + K[st + k + K[ot + V]]], ne, we, Oe));
  let jt = 0.6 - se * se - Be * Be - le * le;
  return jt < 0 ? l = 0 : (jt *= jt, l = jt * jt * Vi(K[Te + 1 + K[st + 1 + K[ot + 1]]], se, Be, le)), 32 * (a + o + n + l);
}
function AA(s, e, t, r) {
  const i = 0.309016994, a = 0.138196601;
  let o, n, l, h, u, c = (s + e + t + r) * i, f = s + c, g = e + c, m = t + c, A = r + c, _ = Rt(f), x = Rt(g), C = Rt(m), S = Rt(A), I = (_ + x + C + S) * a, T = _ - I, b = x - I, B = C - I, R = S - I, E = s - T, F = e - b, k = t - B, V = r - R, j = E > F ? 32 : 0, te = E > k ? 16 : 0, pe = F > k ? 8 : 0, ne = E > V ? 4 : 0, we = F > V ? 2 : 0, Oe = k > V ? 1 : 0, se = j + te + pe + ne + we + Oe, Be, le, Te, st, ot, At, vt, xt, jt, ss, os, ns;
  Be = pt[se][0] >= 3 ? 1 : 0, le = pt[se][1] >= 3 ? 1 : 0, Te = pt[se][2] >= 3 ? 1 : 0, st = pt[se][3] >= 3 ? 1 : 0, ot = pt[se][0] >= 2 ? 1 : 0, At = pt[se][1] >= 2 ? 1 : 0, vt = pt[se][2] >= 2 ? 1 : 0, xt = pt[se][3] >= 2 ? 1 : 0, jt = pt[se][0] >= 1 ? 1 : 0, ss = pt[se][1] >= 1 ? 1 : 0, os = pt[se][2] >= 1 ? 1 : 0, ns = pt[se][3] >= 1 ? 1 : 0;
  let ls = E - Be + a, hs = F - le + a, us = k - Te + a, cs = V - st + a, fs = E - ot + 2 * a, ds = F - At + 2 * a, gs = k - vt + 2 * a, ps = V - xt + 2 * a, ms = E - jt + 3 * a, As = F - ss + 3 * a, vs = k - os + 3 * a, xs = V - ns + 3 * a, _s = E - 1 + 4 * a, Cs = F - 1 + 4 * a, Ss = k - 1 + 4 * a, ys = V - 1 + 4 * a, li = _ & 255, hi = x & 255, ui = C & 255, ci = S & 255, fi = 0.6 - E * E - F * F - k * k - V * V;
  fi < 0 ? o = 0 : (fi *= fi, o = fi * fi * si(K[li + K[hi + K[ui + K[ci]]]], E, F, k, V));
  let di = 0.6 - ls * ls - hs * hs - us * us - cs * cs;
  di < 0 ? n = 0 : (di *= di, n = di * di * si(K[li + Be + K[hi + le + K[ui + Te + K[ci + st]]]], ls, hs, us, cs));
  let gi = 0.6 - fs * fs - ds * ds - gs * gs - ps * ps;
  gi < 0 ? l = 0 : (gi *= gi, l = gi * gi * si(K[li + ot + K[hi + At + K[ui + vt + K[ci + xt]]]], fs, ds, gs, ps));
  let pi = 0.6 - ms * ms - As * As - vs * vs - xs * xs;
  pi < 0 ? h = 0 : (pi *= pi, h = pi * pi * si(K[li + jt + K[hi + ss + K[ui + os + K[ci + ns]]]], ms, As, vs, xs));
  let mi = 0.6 - _s * _s - Cs * Cs - Ss * Ss - ys * ys;
  return mi < 0 ? u = 0 : (mi *= mi, u = mi * mi * si(K[li + 1 + K[hi + 1 + K[ui + 1 + K[ci + 1]]]], _s, Cs, Ss, ys)), 27 * (o + n + l + h + u);
}
var _Xo = class _Xo extends Q {
  constructor(e = 0, t = 0) {
    super(e, t);
    __publicField(this, "u", 0);
    __publicField(this, "v", 0);
    this.u = e, this.v = t;
  }
  length() {
    return 0;
  }
  static getUVSheet(e, t, r) {
    let i = Math.floor(e % (t * r)), a = Math.floor(i / t), o = i % t;
    return new G(a / t, o / r, 1 / t, 1 / r);
  }
};
__publicField(_Xo, "uv_0", new _Xo());
var Xo = _Xo;
var Sf = class {
  constructor(e = 0) {
    __publicField(this, "serializedVersion", "2");
    __publicField(this, "time");
    __publicField(this, "tangentMode", 0);
    __publicField(this, "weightedMode", 0);
    __publicField(this, "propertyKeyFrame");
    this.time = e, this.propertyKeyFrame = {};
  }
  getK(e) {
    return this.propertyKeyFrame[e];
  }
  split(e, t, r) {
    switch (e) {
      case L.single:
        {
          let i = this.getKeyFrame(0);
          i[r] = t;
        }
        break;
      case L.float:
        {
          let i = this.getKeyFrame(0);
          i[r] = t;
        }
        break;
      case L.vector2:
        {
          let i = t, a = this.getKeyFrame(0);
          a[r] = i.x;
          let o = this.getKeyFrame(1);
          o[r] = i.y;
        }
        break;
      case L.vector3:
        {
          let i = t, a = this.getKeyFrame(0);
          a[r] = i.x;
          let o = this.getKeyFrame(1);
          o[r] = i.y;
          let n = this.getKeyFrame(2);
          n[r] = i.z;
        }
        break;
      case L.vector4:
        {
          let i = t, a = this.getKeyFrame(0);
          a[r] = i.x;
          let o = this.getKeyFrame(1);
          o[r] = i.y;
          let n = this.getKeyFrame(2);
          n[r] = i.y;
          let l = this.getKeyFrame(3);
          l[r] = i.y;
        }
        break;
      case L.quaternion:
        {
          let i = t, a = this.getKeyFrame(0);
          a[r] = i.x;
          let o = this.getKeyFrame(1);
          o[r] = i.y;
          let n = this.getKeyFrame(2);
          n[r] = i.z;
          let l = this.getKeyFrame(3);
          l[r] = i.w;
        }
        break;
    }
  }
  getKeyFrame(e) {
    let t = this.propertyKeyFrame[e];
    return t || (t = new Pa(), t.time = this.time, t.tangentMode = this.tangentMode, t.weightedMode = this.weightedMode, this.propertyKeyFrame[e] = t), t;
  }
  formBytes(e) {
    this.time = e.readFloat32();
    {
      let { t, v: r } = Xt.parser(e);
      this.split(t, r, "value");
    }
    {
      let { t, v: r } = Xt.parser(e);
      this.split(t, r, "inSlope");
    }
    {
      let { t, v: r } = Xt.parser(e);
      this.split(t, r, "outSlope");
    }
    this.tangentMode = e.readInt32(), this.weightedMode = e.readInt32();
    {
      let { t, v: r } = Xt.parser(e);
      this.split(t, r, "inWeight");
    }
    {
      let { t, v: r } = Xt.parser(e);
      this.split(t, r, "outWeight");
    }
  }
};
var vA = class {
  static sub(e, t) {
    switch (e.constructor.name) {
      case "number":
        return e - t;
      case "Vector2": {
        let i = e, a = t;
        return new Q(i.x - a.x, i.y - a.y);
      }
      case "Vector3": {
        let i = e, a = t;
        return new d(i.x - a.x, i.y - a.y, i.z - a.z);
      }
      case "Vector4": {
        let i = e, a = t;
        return new G(i.x - a.x, i.y - a.y, i.z - a.z, i.w - a.w);
      }
      case "Quaternion": {
        let i = e, a = t;
        return new H(i.x - a.x, i.y - a.y, i.z - a.z, i.w - a.w);
      }
    }
  }
};
var Hi = class {
  constructor() {
    __publicField(this, "_keys", new Array());
    __publicField(this, "_values", new Array());
  }
  getIndexByKey(e) {
    return this._keys.indexOf(e);
  }
  getValueByKey(e) {
    var t = this.getIndexByKey(e);
    return t > -1 ? this._values[t] : null;
  }
  put(e, t) {
    if (e == null)
      return null;
    var r = this.remove(e);
    return this._keys.push(e), this._values.push(t), r;
  }
  remove(e) {
    var t = this._keys.indexOf(e), r;
    return t > -1 && (r = this._values[t], this._keys.splice(t, 1), this._values.splice(t, 1)), r;
  }
  getValues() {
    return this._values;
  }
  getKeys() {
    return this._keys;
  }
  clear() {
    this._values.length = 0, this._keys.length = 0;
  }
};
var _r = class {
};
__publicField(_r, "WalkAble", 1);
var _Yi = class _Yi {
  static SetConst(e) {
    this.EPSILON = e, this.POWER_EPSILON = e * e;
  }
};
__publicField(_Yi, "EPSILON", 0.1);
__publicField(_Yi, "POWER_EPSILON", _Yi.EPSILON * _Yi.EPSILON);
var Yi = _Yi;
var _Ke = class _Ke extends d {
  constructor(e, t, r, i) {
    super(t, r, i, 0);
    __publicField(this, "_pointId", 0);
    this._pointId = e;
  }
  get id() {
    return this._pointId;
  }
  static equalPoint(e, t) {
    return (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y) + (e.z - t.z) * (e.z - t.z) < Yi.POWER_EPSILON;
  }
  static calcDistance(e, t) {
    return _Ke.CALC_VECTOR3D3.setTo(e.x - t.x, e.y - t.y, e.z - t.z), _Ke.CALC_VECTOR3D3.length;
  }
};
__publicField(_Ke, "CALC_VECTOR3D1", new d());
__publicField(_Ke, "CALC_VECTOR3D2", new d());
__publicField(_Ke, "CALC_VECTOR3D3", new d());
__publicField(_Ke, "CALC_VECTOR3D4", new d());
__publicField(_Ke, "CALC_VECTOR3D5", new d());
var Ke = _Ke;
var yf = class {
  constructor() {
    __publicField(this, "_openedList");
    __publicField(this, "_closedList");
    __publicField(this, "_endNode");
    __publicField(this, "_startNode");
    __publicField(this, "_triangleChannel");
    __publicField(this, "_navMesh");
    __publicField(this, "_findIndex", 0);
    this._openedList = new Array(), this._closedList = new Array();
  }
  findPath(e, t, r) {
    return this._findIndex++, this._navMesh = e, this._startNode = t, this._endNode = r, this._openedList.length = 0, this._closedList.length = 0, this._startNode && this._endNode ? (this._startNode.gg = 0, this._startNode.h = 0, this._startNode.f = 0, this._startNode.parent = null, this.search()) : false;
  }
  search() {
    for (var e = this._startNode, t = [], r; e != this._endNode; ) {
      t = e.getNeibourTriangles(t, _r.WalkAble, _r.WalkAble);
      for (r of t)
        if (r.closeId != this._findIndex && !(r == e || !r.walkAble)) {
          var i = e.gg + Ke.calcDistance(r, e) * r.costMultiplier, a = Ke.calcDistance(r, this._endNode), o = i + a;
          r.openId == this._findIndex ? r.f > o && (r.f = o, r.gg = i, r.h = a, r.parent = e) : (r.f = o, r.gg = i, r.h = a, r.parent = e, r.openId = this._findIndex, this._openedList.push(r));
        }
      if (e.closeId = this._findIndex, this._closedList.push(e), this._openedList.length == 0)
        return false;
      this._openedList.sort(function(n, l) {
        return n.f - l.f;
      }), e = this._openedList.shift();
    }
    return this.buildPath(), true;
  }
  buildPath() {
    this._triangleChannel = [];
    var e = this._endNode;
    for (this._triangleChannel.push(e); e != this._startNode; )
      e = e.parent, this._triangleChannel.unshift(e);
  }
  get channel() {
    return this._triangleChannel;
  }
};
var Lt = class _Lt extends Ke {
  constructor(e, t) {
    super(e.id, 0, 0, 0);
    __publicField(this, "_ownerPoint");
    __publicField(this, "_ownerEdge");
    __publicField(this, "radius", 0);
    this._ownerEdge = t, this._ownerPoint = e;
  }
  get ownerPoint() {
    return this._ownerPoint;
  }
  get ownerEdge() {
    return this._ownerEdge;
  }
  scalePoint(e = 0.7) {
    var t = new _Lt(this._ownerPoint, this._ownerEdge);
    return t.copyFrom(this), t.decrementBy(this._ownerPoint), t.scaleBy(e), t.radius = t.length, t.incrementBy(this._ownerPoint), t;
  }
};
var _Nt = class _Nt {
  constructor(e, t) {
    __publicField(this, "_edgeMask", 0);
    __publicField(this, "_edgeSize", 0);
    __publicField(this, "_pointA");
    __publicField(this, "_pointB");
    __publicField(this, "_triangleOwners");
    __publicField(this, "_centerPoint");
    __publicField(this, "_edgeDirA2B");
    __publicField(this, "crossPoint");
    __publicField(this, "fatPointA");
    __publicField(this, "fatPointB");
    if (this._pointA = e, this._pointB = t, e.id >= t.id)
      throw new Error("edge point order error!!!");
    this._triangleOwners = new Array(), this._centerPoint = new d(), this._edgeMask = _r.WalkAble, Ke.CALC_VECTOR3D1.setTo(e.x - t.x, e.y - t.y, e.z - t.z), this._edgeSize = Ke.CALC_VECTOR3D1.length, this._centerPoint.setTo((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2);
  }
  get size() {
    return this._edgeSize;
  }
  get triangleOwners() {
    return this._triangleOwners;
  }
  get centerPoint() {
    return this._centerPoint;
  }
  initFatPoints(e) {
    this._edgeDirA2B = this._pointB.subtract(this._pointA), this._edgeDirA2B.normalize(), this.fatPointA = this.fatPointA || new Lt(this._pointA, this), this.fatPointB = this.fatPointB || new Lt(this._pointB, this), this.fatPointA.radius != e && (_Nt.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B), _Nt.CALC_FAT_VECTOR.scaleBy(e), _Nt.CALC_FAT_VECTOR.incrementBy(this._pointA), this.fatPointA.copyFrom(_Nt.CALC_FAT_VECTOR), this.fatPointA.radius = e), this.fatPointB.radius != e && (_Nt.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B), _Nt.CALC_FAT_VECTOR.scaleBy(-e), _Nt.CALC_FAT_VECTOR.incrementBy(this._pointB), this.fatPointB.copyFrom(_Nt.CALC_FAT_VECTOR), this.fatPointB.radius = e);
  }
  getFatPoint(e) {
    return e == this._pointA ? this.fatPointA : this.fatPointB;
  }
  getAnotherFatPoint(e) {
    return e == this._pointA ? this.fatPointB : this.fatPointA;
  }
  getAnotherPoint(e) {
    return e == this._pointA ? this._pointB : this._pointA;
  }
  containsPoint(e) {
    return Ke.equalPoint(e, this._pointA) ? this._pointA : Ke.equalPoint(e, this._pointB) ? this._pointB : null;
  }
  addTriangleOwners(e) {
    if (e.edges.indexOf(this) == -1)
      throw new Error("the edge is not belong triangle!!!");
    this._triangleOwners.indexOf(e) == -1 && this._triangleOwners.push(e);
  }
  getPublicPoint(e) {
    return this._pointA == e._pointA || this._pointA == e._pointB ? this._pointA : this._pointB == e._pointA || this._pointB == e._pointB ? this._pointB : null;
  }
  getEqualPoint(e) {
    return Ke.equalPoint(e, this._pointA) ? this._pointA : Ke.equalPoint(e, this._pointB) ? this._pointB : null;
  }
  get pointA() {
    return this._pointA;
  }
  get pointB() {
    return this._pointB;
  }
  get walkAble() {
    return (this._edgeMask & _r.WalkAble) == _r.WalkAble;
  }
  testMask(e) {
    return (this._edgeMask & e) == e;
  }
};
__publicField(_Nt, "CALC_FAT_VECTOR", new d());
var Nt = _Nt;
var _X = class _X {
  constructor() {
    __publicField(this, "endPoint");
    __publicField(this, "curPoint");
    __publicField(this, "rayA");
    __publicField(this, "rayB");
    __publicField(this, "rayAPoint");
    __publicField(this, "rayBPoint");
    __publicField(this, "cornerPoint");
    __publicField(this, "cornerEdge");
  }
  continuePass(e, t, r) {
    this.resetData(), this.curPoint = e, this.endPoint = t, this.cornerEdge = r;
  }
  passEdge(e, t, r, i) {
    if ((this.rayA == null || this.rayB == null) && (this.rayA = _X.RAY_1, this.rayB = _X.RAY_2, this.rayAPoint = e.pointA, this.rayBPoint = e.pointB, this.rayA.setTo(this.rayAPoint.x - this.curPoint.x, 0, this.rayAPoint.z - this.curPoint.z), this.rayB.setTo(this.rayBPoint.x - this.curPoint.x, 0, this.rayBPoint.z - this.curPoint.z)), i)
      return this.checkEndPoint(r);
    if (_X.TEST_RAY.setTo(r.x - this.curPoint.x, 0, r.z - this.curPoint.z), this.isPointAtCenter(_X.TEST_RAY, this.rayA, this.rayB)) {
      this.hasCrossPoint(t.pointA, t.pointB, this.rayAPoint, this.rayA) ? (this.rayB.copyFrom(_X.TEST_RAY), r instanceof Ke ? this.rayBPoint = r : this.rayBPoint = null) : (this.rayA.copyFrom(_X.TEST_RAY), r instanceof Ke ? this.rayAPoint = r : this.rayAPoint = null);
      var a = t.getAnotherPoint(r);
      _X.TEST_RAY.setTo(a.x - this.curPoint.x, 0, a.z - this.curPoint.z), (a == this.rayAPoint || a == this.rayBPoint || this.isPointAtCenter(_X.TEST_RAY, this.rayA, this.rayB)) && (this.cornerEdge = t);
    } else {
      var o;
      if (_X.TEST_RAY_1.copyFrom(t.pointA), _X.TEST_RAY_1.decrementBy(this.curPoint), _X.TEST_RAY_2.copyFrom(t.pointB), _X.TEST_RAY_2.decrementBy(this.curPoint), _X.TEST_RAY_1.y = 0, _X.TEST_RAY_2.y = 0, this.isPointAtCenter(this.rayA, _X.TEST_RAY_1, _X.TEST_RAY_2) || this.isPointAtCenter(this.rayB, _X.TEST_RAY_1, _X.TEST_RAY_2) ? o = false : o = true, o)
        return this.isPointAtCenter(this.rayA, _X.TEST_RAY, this.rayB) ? this.cornerPoint = this.rayAPoint : this.cornerPoint = this.rayBPoint, this.cornerEdge.crossPoint = this.cornerPoint, false;
    }
    return true;
  }
  checkEndPoint(e) {
    return _X.TEST_RAY.setTo(e.x - this.curPoint.x, 0, e.z - this.curPoint.z), this.isPointAtCenter(_X.TEST_RAY, this.rayA, this.rayB) ? true : (this.isPointAtCenter(this.rayA, _X.TEST_RAY, this.rayB) ? this.cornerPoint = this.rayAPoint : this.cornerPoint = this.rayBPoint, this.cornerEdge.crossPoint = this.cornerPoint, false);
  }
  calcCrossEdge(e, t, r) {
    return this.calcCrossPoint(e.fatPointA, e.fatPointB, t, r);
  }
  calcCrossPoint(e, t, r, i) {
    _X.CALC_CROSS_POINT.copyFrom(t), _X.CALC_CROSS_POINT.decrementBy(e);
    let a = _X.CALC_CROSS_POINT.x * i.z - i.x * _X.CALC_CROSS_POINT.z;
    var o = 0;
    return a != 0 && (o = ((e.z - r.z) * i.x - (e.x - r.x) * i.z) / a), o > 1 ? o = 1 : o < 0 && (o = 0), _X.CALC_CROSS_POINT.scaleBy(o), _X.CALC_CROSS_POINT.incrementBy(e), _X.CALC_CROSS_POINT.clone();
  }
  calcCrossPointOut(e, t, r, i) {
    _X.CALC_CROSS_POINT.copyFrom(t), _X.CALC_CROSS_POINT.decrementBy(e);
    var a = ((e.z - r.z) * i.x - (e.x - r.x) * i.z) / (_X.CALC_CROSS_POINT.x * i.z - i.x * _X.CALC_CROSS_POINT.z);
    return a <= 1 && a >= 0 ? null : (_X.CALC_CROSS_POINT.scaleBy(a), _X.CALC_CROSS_POINT.incrementBy(e), _X.CALC_CROSS_POINT.clone());
  }
  hasCrossPoint(e, t, r, i) {
    _X.CALC_CROSS_TEST.copyFrom(t), _X.CALC_CROSS_TEST.decrementBy(e);
    var a = ((e.z - r.z) * i.x - (e.x - r.x) * i.z) / (_X.CALC_CROSS_TEST.x * i.z - i.x * _X.CALC_CROSS_TEST.z);
    return a <= 1 && a >= 0;
  }
  isPointAtCenter(e, t, r) {
    var i = t.crossProduct(e);
    if (i.length == 0 && e.length < t.length)
      return true;
    var a = r.crossProduct(e);
    return a.length == 0 && e.length < r.length ? true : (i.normalize(), a.normalize(), i.incrementBy(a), i.length < 0.01);
  }
  resetData() {
    this.cornerEdge = null, this.cornerPoint = null, this.curPoint = null, this.rayA = this.rayB = null, this.rayAPoint = this.rayBPoint = null, _X.RAY_1.setTo(0, 0, 0), _X.RAY_2.setTo(0, 0, 0);
  }
};
__publicField(_X, "RAY_1", new d());
__publicField(_X, "RAY_2", new d());
__publicField(_X, "TEST_RAY", new d());
__publicField(_X, "TEST_RAY_1", new d());
__publicField(_X, "TEST_RAY_2", new d());
__publicField(_X, "CALC_CROSS_POINT", new d());
__publicField(_X, "CALC_CROSS_TEST", new d());
var X = _X;
var _lr = class _lr {
  constructor() {
    __publicField(this, "_aiRadius", 0);
    __publicField(this, "_router");
    __publicField(this, "_result");
    __publicField(this, "_tempPublicEdgeList", new Array());
    __publicField(this, "_tempSamePlaneList", new Array());
    this._router = new X();
  }
  searchPath(e, t, r, i = 0) {
    return i <= 0 && (i = 1), this._aiRadius = i * 1.5, this.searchEnable(e, t, r) ? (this.search(e, t, r), true) : false;
  }
  get path() {
    return this._result;
  }
  searchEnable(e, t, r) {
    return !(e == null || t == null || r == null || r[0].plane.classifyPoint(e, Yi.EPSILON) != Rr.INTERSECT || r[r.length - 1].plane.classifyPoint(t, Yi.EPSILON) != Rr.INTERSECT);
  }
  search(e, t, r) {
    this._tempPublicEdgeList.length = 0, this._tempSamePlaneList.length = 0;
    var i = 0, a = r.length - 1, o, n, l, h;
    for (i = 0; i < a; i++)
      n = r[i].getPublicEdge(r[i + 1]), n.crossPoint = null, n.initFatPoints(this._aiRadius), this._tempPublicEdgeList.push(n), o = r[i], h = o.plane, o = r[i + 1], l = o.getEdgeAgainstPoint(n), this._tempSamePlaneList.push(h.classifyPoint(l, Yi.EPSILON) == Rr.INTERSECT);
    this._router.continuePass(e, t, this._tempPublicEdgeList[0]), a = this._tempPublicEdgeList.length;
    var u, c, f, g;
    for (i = 0; i < a; i++)
      n = this._tempPublicEdgeList[i], o = r[i + 1], g = i == a - 1, g ? l = t : l = o.getEdgeAgainstPoint(n), f = this._router.passEdge(n, this._tempPublicEdgeList[i + 1], l, g), f || (u = this._router.cornerPoint, c = this._router.cornerEdge, i = this._tempPublicEdgeList.indexOf(c), this._router.continuePass(u, t, this._tempPublicEdgeList[i + 1]));
    this.pushAllPathPoint2(e, t), this._result.length >= 3 && (this.optimusTerminusFat(), this.optimusByRadius());
    let m = [];
    for (let A of this._result)
      m.push(new d().copyFrom(A));
    this._result = m;
  }
  optimusTerminusFat() {
    var e, t, r;
    r = this._result[1], r instanceof Lt && (e = r), r = this._result[this._result.length - 2], r instanceof Lt && (t = r), e && (this._result[1] = e.scalePoint()), t && e != t && (this._result[this._result.length - 2] = t.scalePoint());
  }
  pushAllPathPoint2(e, t) {
    var r = this._tempPublicEdgeList.length, i, a;
    this._result = new Array(), this._result.push(e);
    for (var o = e, n, l, h, u = 0; u < r; u++)
      if (i = this._tempPublicEdgeList[u], l = null, i.crossPoint)
        l = this.getFatPoint(i, i.crossPoint), l ? this._result.push(l) : this._result.push(i.crossPoint), o = i.crossPoint;
      else {
        a = null, n = null;
        for (var c = u + 1; c < r && (a = this._tempPublicEdgeList[c], n = a.crossPoint, !n); c++)
          ;
        n == null && (n = t), l = this.getFatPoint(i, n), l ? this._result.push(l) : (n == o ? h = n.clone() : (_lr.CROSS_TEST_DIRECTION.setTo(n.x - o.x, 0, n.z - o.z), h = this._router.calcCrossEdge(i, o, _lr.CROSS_TEST_DIRECTION)), this._result.push(h));
      }
    this._result.push(t);
  }
  optimusByRadius() {
    var e = new Array();
    e.length = this._result.length;
    var t = this._result.length - 2, r, i, a, o, n, l, h, u, c, f, g, m, A;
    for (A = 0; A < t; A++)
      h = u = c = null, o = n = l = null, g = false, m = null, r = this._result[A], i = this._result[A + 1], a = this._result[A + 2], r instanceof Lt && (o = r), i instanceof Lt && (n = i), a instanceof Lt && (l = a), o && (h = o.ownerPoint), n && (u = n.ownerPoint), l && (c = l.ownerPoint), h && u && h == u && u != c && (g = true), c && u && c == u && h != u && (g = true), g && (_lr.CROSS_TEST_DIRECTION.copyFrom(r), _lr.CROSS_TEST_DIRECTION.decrementBy(a), f = n.ownerEdge, g = this._router.hasCrossPoint(f.pointA, f.pointB, a, _lr.CROSS_TEST_DIRECTION), g && (m = this._router.calcCrossPointOut(u, i, a, _lr.CROSS_TEST_DIRECTION)), m && (e[A + 1] = m));
  }
  getFatPoint(e, t) {
    if (e == null)
      return null;
    var r;
    t instanceof Lt && (r = t);
    var i;
    return r ? i = r.ownerPoint : i = e.getEqualPoint(t), i == null ? null : (r = e.getFatPoint(i), r);
  }
};
__publicField(_lr, "CROSS_TEST_DIRECTION", new d());
var lr = _lr;
var xA = class {
  constructor() {
    __publicField(this, "vertex");
    __publicField(this, "indices");
  }
  merge(e, t = 0.1) {
    let r = e.getAttribute(D.position).data;
    this.makeOriginVertex(r);
    let i = /* @__PURE__ */ new Map(), a = [], o = 0;
    for (let l = 0, h = this.vertex.length; l < h; l++) {
      let u = this.vertex[l], c = -1;
      i.forEach((f, g) => {
        d.distance(f, u) < t && (c = g);
      }), c > -1 ? (a[l] = c, o++) : (i.set(l, u), a[l] = l);
    }
    console.log("mergePointCount", o), this.indices = [];
    let n = e.getAttribute(D.indices).data;
    for (const l of n)
      this.indices.push(a[l]);
    return this;
  }
  parse(e) {
    let t = e.getAttribute(D.position).data;
    this.makeOriginVertex(t), this.indices = [];
    let r = e.getAttribute(D.indices).data;
    for (const i of r)
      this.indices.push(i);
    return this;
  }
  makeOriginVertex(e) {
    this.vertex = [];
    for (let t = 0, r = e.length / 3; t < r; t++) {
      let i = new d(e[t * 3], e[t * 3 + 1], e[t * 3 + 2]);
      this.vertex.push(i);
    }
  }
};
var wf = class extends d {
  constructor(e, t, r, i) {
    super(0, 0, 0, 0);
    __publicField(this, "_id", 0);
    __publicField(this, "_plane");
    __publicField(this, "_points", new Array());
    __publicField(this, "_edges", new Array());
    __publicField(this, "_neibourTriangles", new Hi());
    __publicField(this, "_pointAgainstEdge", new Hi());
    __publicField(this, "_edgeAgainstPoint", new Hi());
    __publicField(this, "_mask", 0);
    __publicField(this, "_aabbBox");
    __publicField(this, "f", 0);
    __publicField(this, "gg", 0);
    __publicField(this, "h", 0);
    __publicField(this, "parent");
    __publicField(this, "costMultiplier", 1);
    __publicField(this, "openId", 0);
    __publicField(this, "closeId", 0);
    this._id = e, this._mask = _r.WalkAble, this._edges.push(t, r, i);
    var a;
    for (a of this._edges)
      this._points.indexOf(a.pointA) == -1 && this._points.push(a.pointA), this._points.indexOf(a.pointB) == -1 && this._points.push(a.pointB);
    this.x = (this._points[0].x + this._points[1].x + this._points[2].x) / 3, this.y = (this._points[0].y + this._points[1].y + this._points[2].y) / 3, this.z = (this._points[0].z + this._points[1].z + this._points[2].z) / 3, this._plane = new _f(), this._plane.fromPoints(this._points[0], this._points[1], this._points[2]), this._plane.normalize(), this.genarateAgainstData(), this.initAABB();
  }
  get aabb() {
    return this._aabbBox;
  }
  initAABB() {
    this._aabbBox = new $e(), this._aabbBox.addPoint(this._points[0]), this._aabbBox.addPoint(this._points[1]), this._aabbBox.addPoint(this._points[2]);
  }
  calcGlobalQuadAABB() {
  }
  get isTriangle() {
    return true;
  }
  genarateAgainstData() {
    var e, t;
    for (e of this._edges)
      for (t of this._points)
        e.pointA != t && e.pointB != t && (this._edgeAgainstPoint.put(e, t), this._pointAgainstEdge.put(t, e));
  }
  get id() {
    return this._id;
  }
  get plane() {
    return this._plane;
  }
  get points() {
    return this._points;
  }
  addNeibour(e, t) {
    if (this._edges.indexOf(e) >= 0)
      this._neibourTriangles.put(e, t);
    else
      throw new Error("the edge is not in triangle!!!");
  }
  getNeibourTriangles(e = null, t = 1, r = 1) {
    e = e || new Array(), e.length = 0;
    var i, a, o = this._neibourTriangles.getKeys(), n;
    for (n of o)
      a = n, a.testMask(t) && (i = this._neibourTriangles.getValueByKey(a), i.testMask(r) && e.push(i));
    return e;
  }
  getEdges(e = null, t = 1) {
    e = e || new Array(), e.length = 0;
    var r;
    for (r of this._edges)
      r.testMask(t) && e.push(r);
    return e;
  }
  get walkAble() {
    return this.testMask(_r.WalkAble);
  }
  get edges() {
    return this._edges;
  }
  testMask(e) {
    return (this._mask & e) == e;
  }
  getEdgeAgainstPoint(e) {
    return this._edgeAgainstPoint.getValueByKey(e);
  }
  getPointAgainstEdge(e) {
    return this._pointAgainstEdge.getValueByKey(e);
  }
  getPublicEdge(e) {
    if (e && e != this) {
      var t = this._neibourTriangles.getKeys(), r;
      for (r of t)
        if (this._neibourTriangles.getValueByKey(r) == e)
          return r;
    }
    return null;
  }
  loopPublicEdge(e) {
    var t, r;
    if (e && e != this) {
      for (t of this._edges)
        for (r of e._edges)
          if (t == r)
            return t;
    }
    return null;
  }
  randomPoint() {
    var e = this._points[2].subtract(this._points[0]);
    e.scaleBy(Math.random()), e.incrementBy(this._points[0]);
    var t = this._points[1].subtract(e);
    return t.scaleBy(Math.random()), t.incrementBy(e), t;
  }
};
var _A = class {
  constructor(e, t) {
    __publicField(this, "_nav3dPoints");
    __publicField(this, "_nav3dEdges");
    __publicField(this, "_nav3dTriangles");
    __publicField(this, "_path");
    __publicField(this, "_edgesDict");
    __publicField(this, "_nav3dAstar");
    __publicField(this, "_nav3dFunnel");
    __publicField(this, "_terrainQuad");
    __publicField(this, "_triangleList");
    this._nav3dPoints = new Array(), this._nav3dEdges = new Array(), this._nav3dTriangles = new Array(), this._edgesDict = new Hi(), this.initPoints(e), this.initEdgesAndTriangles(t), this.createConnections(), this._nav3dAstar = new yf(), this._nav3dFunnel = new lr(), this._terrainQuad = new Oc(8, 128), this._terrainQuad.createQuadTree(this._nav3dTriangles);
  }
  get edges() {
    return this._nav3dEdges;
  }
  get points() {
    return this._nav3dPoints;
  }
  get path() {
    return this._path;
  }
  get triangles() {
    return this._nav3dTriangles;
  }
  getTriangleAtPoint(e, t = 5) {
    return this._terrainQuad.getTriangleAtPoint(e, t);
  }
  findPath(e, t, r = 5) {
    this._path = null, this._triangleList = null;
    var i = this.getTriangleAtPoint(e, 10), a = this.getTriangleAtPoint(t, 10), o = this._nav3dAstar.findPath(this, i, a);
    return o ? (this._triangleList = this._nav3dAstar.channel, o = this._nav3dFunnel.searchPath(e, t, this._triangleList, r), this._path = this._nav3dFunnel.path, o) : false;
  }
  initPoints(e) {
    for (var t, r, i = e.length, a = 0; a < i; a++)
      t = e[a], r = new Ke(a, t.x, t.y, t.z), this._nav3dPoints.push(r);
  }
  initEdgesAndTriangles(e) {
    for (var t, r, i, a, o, n = e.length, l = 0; l < n; l++)
      t = e[l], r = this.tryCreateEdge(t[0], t[1]), i = this.tryCreateEdge(t[1], t[2]), a = this.tryCreateEdge(t[2], t[0]), !(r == null || i == null || a == null) && (o = new wf(l, r, i, a), this._nav3dTriangles.push(o));
  }
  tryCreateEdge(e, t) {
    if (e == t)
      throw new Error("edge point index error!!!");
    if (e > t) {
      var r = e;
      e = t, t = r;
    }
    var i = this._edgesDict.getValueByKey(e + "_" + t);
    return i == null && (i = new Nt(this._nav3dPoints[e], this._nav3dPoints[t]), this._nav3dEdges.push(i), this._edgesDict.put(e + "_" + t, i)), i;
  }
  createConnections() {
    for (var e = this._nav3dTriangles.length, t = this._nav3dTriangles.length, r, i, a, o, n = 0; n < e; n++) {
      r = this._nav3dTriangles[n];
      for (a of r.edges)
        a.addTriangleOwners(r);
      for (var l = 0; l < t; l++)
        i = this._nav3dTriangles[l], r != i && (o = r.loopPublicEdge(i), o && (r.addNeibour(o, i), i.addNeibour(o, r)));
    }
  }
};
var Wo = class _Wo {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
  }
  setTo(e, t) {
    this.x = e, this.y = t;
  }
  equals(e, t) {
    return e == this.x && t == this.y;
  }
  equalPoint(e) {
    return this.equals(e.x, e.y);
  }
  get length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  clone() {
    var e = new _Wo();
    return e.setTo(this.x, this.y), e;
  }
  normalize() {
    var e = length;
    e != 0 && this.setTo(this.x / e, this.y / e);
  }
};
var Ur = class extends xe {
  constructor(e = 1, t = 1, r = 1) {
    super();
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "depth");
    this.width = e, this.height = t, this.depth = r, this.initVertex();
  }
  initVertex() {
    let e = this.width / 2, t = this.height / 2, r = this.depth / 2;
    this.bounds = new ge(d.ZERO.clone(), new d(this.width, this.height, this.depth));
    let i = new Float32Array([-e, t, r, e, t, r, e, t, -r, -e, t, -r, -e, t, r, e, t, -r, e, -t, r, -e, -t, r, -e, -t, -r, e, -t, -r, e, -t, r, -e, -t, -r, -e, -t, r, -e, t, r, -e, t, -r, -e, -t, -r, -e, -t, r, -e, t, -r, e, t, r, e, -t, r, e, -t, -r, e, t, -r, e, t, r, e, -t, -r, e, t, r, -e, t, r, -e, -t, r, -e, -t, r, e, -t, r, e, t, r, e, -t, -r, -e, -t, -r, -e, t, -r, e, t, -r, e, -t, -r, -e, t, -r]), a = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]), o = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0]), n = [0, 2, 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14, 13, 15, 17, 16, 18, 20, 19, 21, 23, 22, 24, 26, 25, 27, 29, 28, 30, 32, 31, 33, 35, 34], l = new Uint16Array(n.reverse());
    this.setIndices(l), this.setAttribute(D.position, i), this.setAttribute(D.normal, a), this.setAttribute(D.uv, o), this.setAttribute(D.TEXCOORD_1, o), this.addSubGeometry({ indexStart: 0, indexCount: n.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
  }
};
var CA = class extends xe {
  constructor(e = 1, t = 1, r = 1, i = 8, a = 8, o = false, n = 0, l = Math.PI * 2) {
    super();
    __publicField(this, "radiusTop");
    __publicField(this, "radiusBottom");
    __publicField(this, "height");
    __publicField(this, "radialSegments");
    __publicField(this, "heightSegments");
    __publicField(this, "openEnded");
    __publicField(this, "thetaStart");
    __publicField(this, "thetaLength");
    this.radiusTop = e, this.radiusBottom = t, this.height = r, this.radialSegments = i, this.heightSegments = a, this.openEnded = o, this.thetaStart = n, this.thetaLength = l, this.instanceID = gt(), this.buildGeometry();
  }
  addGroup(e, t, r) {
    this.addSubGeometry({ indexStart: e, indexCount: t, vertexStart: e, vertexCount: 0, firstStart: 0, index: r, topology: 0 });
  }
  buildGeometry() {
    const e = this;
    this.radialSegments = Math.floor(this.radialSegments), this.heightSegments = Math.floor(this.heightSegments);
    const t = [], r = [], i = [], a = [];
    let o = 0;
    const n = [], l = this.height / 2;
    let h = 0;
    m(), this.openEnded === false && (this.radiusTop > 0 && A(true), this.radiusBottom > 0 && A(false));
    let u = new Float32Array(t), c = new Float32Array(r), f = new Float32Array(i), g = new Uint16Array(a);
    this.setAttribute(D.position, u), this.setAttribute(D.normal, c), this.setAttribute(D.uv, f), this.setAttribute(D.TEXCOORD_1, f), this.setIndices(g);
    function m() {
      const _ = new d(), x = new d();
      let C = 0;
      const S = (e.radiusBottom - e.radiusTop) / e.height;
      for (let I = 0; I <= e.heightSegments; I++) {
        const T = [], b = I / e.heightSegments, B = b * (e.radiusBottom - e.radiusTop) + e.radiusTop;
        for (let R = 0; R <= e.radialSegments; R++) {
          const E = R / e.radialSegments, F = E * e.thetaLength + e.thetaStart, k = Math.sin(F), V = Math.cos(F);
          x.x = B * k, x.y = -b * e.height + l, x.z = B * V, t.push(x.x, x.y, x.z), _.set(k, S, V).normalize(), r.push(_.x, _.y, _.z), i.push(E, 1 - b), T.push(o++);
        }
        n.push(T);
      }
      for (let I = 0; I < e.radialSegments; I++)
        for (let T = 0; T < e.heightSegments; T++) {
          const b = n[T][I], B = n[T + 1][I], R = n[T + 1][I + 1], E = n[T][I + 1];
          a.push(b, B, E), a.push(B, R, E), C += 6;
        }
      e.addGroup(h, C, 0), h += C;
    }
    function A(_) {
      const x = o, C = new Q(), S = new d();
      let I = 0;
      const T = _ === true ? e.radiusTop : e.radiusBottom, b = _ === true ? 1 : -1;
      for (let R = 1; R <= e.radialSegments; R++)
        t.push(0, l * b, 0), r.push(0, b, 0), i.push(0.5, 0.5), o++;
      const B = o;
      for (let R = 0; R <= e.radialSegments; R++) {
        const F = R / e.radialSegments * e.thetaLength + e.thetaStart, k = Math.cos(F), V = Math.sin(F);
        S.x = T * V, S.y = l * b, S.z = T * k, t.push(S.x, S.y, S.z), r.push(0, b, 0), C.x = k * 0.5 + 0.5, C.y = V * 0.5 * b + 0.5, i.push(C.x, C.y), o++;
      }
      for (let R = 0; R < e.radialSegments; R++) {
        const E = x + R, F = B + R;
        _ === true ? a.push(F, F + 1, E) : a.push(F + 1, F, E), I += 3;
      }
      e.addGroup(h, I, _ === true ? 1 : 2), h += I;
    }
  }
};
var SA = class extends xe {
  constructor(e) {
    super();
    __publicField(this, "segments");
    this.segments = e, this.buildGeometry();
  }
  buildGeometry() {
    this.bounds = new ge();
    let e = (this.segments.length - 1) * 2 * 3, t = this.segments.length * 2, r = new Float32Array(t * 3), i = new Float32Array(t * 3), a = new Float32Array(t * 2), o = new Uint16Array(e), n = 0;
    for (let h of this.segments)
      r[n++] = h[0].x, r[n++] = h[0].y, r[n++] = h[0].z, r[n++] = h[1].x, r[n++] = h[1].y, r[n++] = h[1].z;
    n = 0;
    let l = 0;
    for (; n < e; )
      o[n++] = 2 + l, o[n++] = 1 + l, o[n++] = 0 + l, o[n++] = 1 + l, o[n++] = 2 + l, o[n++] = 3 + l, l += 2;
    this.setIndices(o), this.setAttribute(D.position, r), this.setAttribute(D.normal, i), this.setAttribute(D.uv, a), this.setAttribute(D.TEXCOORD_1, a), this.addSubGeometry({ indexStart: 0, indexCount: o.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 }), this.computeNormals();
  }
};
var yA = class extends xe {
  constructor(e = 0.4, t = 0.1, r = 32, i = 32) {
    super();
    __publicField(this, "radius");
    __publicField(this, "tube");
    __publicField(this, "radialSegments");
    __publicField(this, "tubularSegments");
    this.radius = e, this.tube = t, this.radialSegments = r, this.tubularSegments = i, this.initVertex();
  }
  initVertex() {
    const e = 2 * Math.PI, t = this.radius, r = this.tube, i = this.radialSegments, a = this.tubularSegments;
    this.bounds = new ge(d.ZERO.clone(), new d(t * 2, r * 2, t * 2));
    var o = (i + 1) * (a + 1);
    let n = new Float32Array(o * 3), l = new Float32Array(o * 3), h = new Float32Array(o * 2), u = new Uint16Array(i * a * 2 * 3), c = 0, f = 0, g = 0, m = 0;
    for (let A = 0; A <= i; A++)
      for (let _ = 0; _ <= a; _++) {
        const x = _ / a, C = A / i, S = x * e, I = C * Math.PI * 2;
        if (n[c++] = (t + r * Math.cos(I)) * Math.sin(S), n[c++] = r * Math.sin(I), n[c++] = (t + r * Math.cos(I)) * Math.cos(S), l[f++] = Math.sin(S) * Math.cos(I), l[f++] = Math.sin(I), l[f++] = Math.cos(S) * Math.cos(I), h[g++] = x, h[g++] = C, _ < a && A < i) {
          const T = a + 1, b = T * A + _, B = T * (A + 1) + _, R = T * (A + 1) + _ + 1, E = T * A + _ + 1;
          u[m++] = b, u[m++] = E, u[m++] = B, u[m++] = E, u[m++] = R, u[m++] = B;
        }
      }
    this.setIndices(u), this.setAttribute(D.position, n), this.setAttribute(D.normal, l), this.setAttribute(D.uv, h), this.setAttribute(D.TEXCOORD_1, h), this.addSubGeometry({ indexStart: 0, indexCount: u.length, vertexStart: 0, vertexCount: 0, firstStart: 0, index: 0, topology: 0 });
  }
};
var wA = class extends Re {
  constructor(e, t) {
    super(e, t, 6);
    __publicField(this, "width", 4);
    __publicField(this, "height", 4);
    __publicField(this, "depthOrArrayLayers", 6);
    __publicField(this, "visibility", GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE);
    this.format = N.depth24plus, this.mipmapCount = 1, this.init();
  }
  internalCreateBindingLayoutDesc() {
    this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float", this.textureBindingLayout.viewDimension = "cube";
  }
  internalCreateTexture() {
    this.textureDescriptor = { format: "depth24plus", size: { width: this.width, height: this.height, depthOrArrayLayers: 6 }, dimension: "2d", usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING }, this.gpuTexture = this.getGPUTexture();
  }
  internalCreateView() {
    this.viewDescriptor = { dimension: "cube" }, this.view = this.getGPUView();
  }
  internalCreateSampler() {
    this.gpuSampler = w.device.createSampler({}), this.gpuSampler_comparison = w.device.createSampler({ compare: "less", label: "sampler_comparison" });
  }
};
var If = class extends Re {
  constructor() {
    super(...arguments);
    __publicField(this, "uint16Array");
    __publicField(this, "floatArray");
    __publicField(this, "_dataBuffer");
  }
  create(e, t, r = null, i = true) {
    if (r == null) {
      r = [];
      for (let a = 0, o = e * t * 4; a < o; a++)
        r[a] = 0;
    }
    return this.updateTexture(e, t, r, i), this;
  }
  updateTexture(e, t, r, i = true) {
    (e != this.width || t != this.height) && (this._dataBuffer && this._dataBuffer.destroy(), this._dataBuffer = null, this.gpuTexture && this.gpuTexture.destroy(), this.gpuTexture = null), this.floatArray = r;
    let a = w.device;
    const o = e * 4 * 2;
    this.format = N.rgba16float, this.mipmapCount = Math.floor(i ? Math.log2(e) : 1), this.createTextureDescriptor(e, t, this.mipmapCount, this.format), (!this.uint16Array || this.uint16Array.length != r.length) && (this.uint16Array = new Uint16Array(r.length));
    let n = this.uint16Array;
    for (let u = 0, c = n.length; u < c; u++)
      n[u] = Zr(r[u]);
    const l = this._dataBuffer = a.createBuffer({ size: n.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    a.queue.writeBuffer(l, 0, n);
    const h = y.beginCommandEncoder();
    h.copyBufferToTexture({ buffer: l, bytesPerRow: o }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), this.useMipmap || (this.samplerBindingLayout.type = "filtering", this.textureBindingLayout.sampleType = "float"), y.endCommandEncoder(h), this.gpuSampler = a.createSampler(this), this.gpuTexture = this.getGPUTexture(), this.mipmapCount > 1 && at.webGPUGenerateMipmap(this);
  }
};
var IA = class extends Re {
  create(e, t, r, i = true) {
    let a = w.device;
    const o = e * 4 * 4;
    this.format = N.rgba32float, this.createTextureDescriptor(e, t, 1, this.format);
    const l = a.createBuffer({ size: r.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    a.queue.writeBuffer(l, 0, r);
    const h = y.beginCommandEncoder();
    h.copyBufferToTexture({ buffer: l, bytesPerRow: o }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(h), i && (this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float"), this.gpuSampler = a.createSampler({});
  }
  fromBuffer(e, t, r) {
    let i = w.device;
    const a = e * 4 * 4;
    this.format = N.rgba32float, this.mipmapCount = 1, this.createTextureDescriptor(e, t, this.mipmapCount, this.format);
    const o = y.beginCommandEncoder();
    return o.copyBufferToTexture({ buffer: r, bytesPerRow: a }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(o), this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float", this.gpuSampler = i.createSampler({}), this;
  }
};
var bA = class extends Ea {
  constructor(e) {
    super();
    __publicField(this, "_internalTexture");
    __publicField(this, "_minSize", 32);
    __publicField(this, "_skyColor");
    this._skyColor = e, this._internalTexture = new If();
    let t = [];
    return p.res.fillColor(t, this._minSize, this._minSize, this.color.r, this.color.g, this.color.b, this.color.a), this._internalTexture.create(this._minSize, this._minSize, t, false), this.createFromTexture(this._minSize, this._internalTexture), this;
  }
  changeColor(e) {
    return this._skyColor = e, p.res.fillColor(this._internalTexture.floatArray, this._minSize, this._minSize, this.color.r, this.color.g, this.color.b, this.color.a), this._internalTexture.updateTexture(this._minSize, this._minSize, this._internalTexture.floatArray, false), this._faceData.uploadTexture(0, this._internalTexture), this;
  }
  get color() {
    return this._skyColor;
  }
  set color(e) {
    this.changeColor(e);
  }
};
var EA = class extends Re {
  create(e, t, r, i = true) {
    let a = w.device;
    const o = e * 4 * 4;
    this.format = N.rgba16float, this.mipmapCount = Math.floor(i ? Math.log2(e) : 1), this.createTextureDescriptor(e, t, this.mipmapCount, this.format);
    const n = a.createBuffer({ size: r.byteLength, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    a.queue.writeBuffer(n, 0, r);
    const l = y.beginCommandEncoder();
    l.copyBufferToTexture({ buffer: n, bytesPerRow: o }, { texture: this.getGPUTexture() }, { width: e, height: t, depthOrArrayLayers: 1 }), y.endCommandEncoder(l), this.minFilter = "nearest", this.magFilter = "nearest", this.mipmapFilter = "nearest", this.samplerBindingLayout.type = "non-filtering", this.textureBindingLayout.sampleType = "unfilterable-float", this.minFilter = "linear", this.magFilter = "linear", this.mipmapFilter = "nearest", this.samplerBindingLayout.type = "filtering", this.textureBindingLayout.sampleType = "float", this.gpuSampler = a.createSampler(this), this.mipmapCount > 1 && at.webGPUGenerateMipmap(this);
  }
};
var BA = class extends Y {
  constructor(e, t = 0.1) {
    super();
    __publicField(this, "length", 100);
    __publicField(this, "thickness", 0.1);
    this.length = e, this.thickness = t, this.init();
  }
  init() {
    let e = new Y(), t = new Y(), r = new Y(), i = new Ur(2, 2, 2), a = new Ur(2, 2, 2), o = new Ur(2, 2, 2), n = new ka();
    n.baseColor = new M(1, 0, 0);
    let l = new ka();
    l.baseColor = new M(0, 1, 0);
    let h = new ka();
    h.baseColor = new M(0, 0, 1);
    let u = e.addComponent(J), c = t.addComponent(J), f = r.addComponent(J);
    u.geometry = i, u.material = n, u.castShadow = false, c.geometry = a, c.material = l, c.castShadow = false, f.geometry = o, f.material = h, f.castShadow = false, e.localScale = new d(this.length, this.thickness, this.thickness), e.x = this.length, t.localScale = new d(this.thickness, this.length, this.thickness), t.y = this.length, r.localScale = new d(this.thickness, this.thickness, this.length), r.z = this.length, this.addChild(e), this.addChild(t), this.addChild(r);
  }
};
var TA = class {
  static color_temperature_to_rgb(e) {
    e < 1e3 ? e = 1e3 : e > 4e4 && (e = 4e4);
    let t = e / 100, r = this.get_red(t), i = this.get_green(t), a = this.get_blue(t);
    return new M(r / 255, i / 255, a / 255, 1);
  }
  static get_red(e) {
    if (e <= 66)
      return 255;
    let t = 329.698727446 * Math.pow(e - 60, -0.1332047592);
    return this.bound(t);
  }
  static get_green(e) {
    let t = 0;
    return e <= 66 ? t = 99.4708025861 * Math.log(e) - 161.1195681661 : t = 288.1221695283 * Math.pow(e - 60, -0.0755148492), this.bound(t);
  }
  static get_blue(e) {
    let t = 0;
    return e >= 66 ? 255 : e <= 19 ? 0 : (t = 138.5177312231 * Math.log(e - 10) - 305.0447927307, this.bound(t));
  }
  static bound(e, t = 0, r = 255) {
    let i = Math.max(e, t);
    return Math.min(i, r);
  }
};
var DA = class {
  static initHeap() {
    this.boxGeo || (this.boxGeo = new Ur()), this.sphere || (this.sphere = new Mi(1, 35, 35)), this.material || (this.material = new ar());
  }
  static get CubeMesh() {
    return this.initHeap(), this.boxGeo;
  }
  static get SphereMesh() {
    return this.initHeap(), this.sphere;
  }
  static GetCube() {
    this.initHeap();
    let e = new Y(), t = e.addComponent(J);
    return t.geometry = this.boxGeo, t.material = this.material.clone(), t.castShadow = true, e;
  }
  static GetSingleCube(e, t, r, i, a, o) {
    this.initHeap();
    let n = new ar();
    n.roughness = 0.5, n.metallic = 0.1, n.baseColor = new M(i, a, o, 1);
    let l = new Y(), h = l.addComponent(J);
    return h.castGI = true, h.geometry = new Ur(e, t, r), h.material = n, l;
  }
  static GetSingleSphere(e, t, r, i) {
    this.initHeap();
    let a = new ar();
    a.baseColor = new M(t, r, i, 1);
    let o = new Y(), n = o.addComponent(J);
    return n.castGI = true, n.geometry = new Mi(e, 20, 20), n.material = a, o;
  }
  static get Sphere() {
    this.initHeap();
    let e = new Y(), t = e.addComponent(J);
    return t.geometry = this.sphere, t.material = this.material, e;
  }
  static GetSingleCube2(e, t = 10) {
    this.initHeap();
    let r = new Y(), i = r.addComponent(J);
    return i.castShadow = false, i.geometry = new Ur(t, t, t), i.material = e, r;
  }
};
__publicField(DA, "boxGeo");
__publicField(DA, "sphere");
__publicField(DA, "material");
var _jo = class _jo {
  static load(e) {
    let t = localStorage.getItem(e);
    return t ? this.localData = JSON.parse(t) : (this.localData = {}, _jo.save(e, this.localData)), this.localData;
  }
  static save(e, t) {
    let r = JSON.stringify(t);
    localStorage.setItem(e, r);
  }
};
__publicField(_jo, "localData");
var jo = _jo;
var PA = class extends Number {
};
var MA = class extends Number {
};
var RA = class extends Number {
};
var UA = class extends Bt {
  constructor() {
    super(...arguments);
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "z", 0);
    __publicField(this, "w", 0);
  }
};
export {
  za as APatch,
  yh as AccelerateDecelerateInterpolator,
  Ch as AccelerateInterpolator,
  Ri as AnimationCurve,
  Gi as AnimationCurveT,
  Qr as AnimationMonitor,
  vr as AnimatorComponent,
  Kg as AnimatorEventKeyframe,
  bh as AnticipateInterpolator,
  sa as AnticipateOvershootInterpolator,
  Lf as ArrayHas,
  Of as ArrayItemIndex,
  vu as AtlasParser,
  Hg as AtmosphericComponent,
  tc as AtmosphericScatteringSky,
  ec as AtmosphericScatteringSkySetting,
  $u as AtmosphericScatteringSky_shader,
  ac as AttributeAnimCurve,
  BA as AxisObject,
  or as B3DMLoader,
  ru as B3DMLoaderBase,
  _o as B3DMParseUtil,
  iu as B3DMParser,
  Ig as BLUR_CsShader,
  uu as BRDFLUT,
  cu as BRDFLUTGenerate,
  bn as BRDF_frag,
  Ao as BatchTable,
  as as Bezier2D,
  eA as Bezier3D,
  tA as BiMap,
  Ji as BillboardComponent,
  Ar as BillboardType,
  rr as BitmapTexture2D,
  vl as BitmapTexture2DArray,
  uo as BitmapTextureCube,
  ml as Blend,
  Al as BlendFactor,
  re as BlendMode,
  of as BlendShapeData,
  Vm as BlendShapeFrameData,
  sf as BlendShapePropertyData,
  am as BloomPost,
  Xh as BlurEffectCreatorBlur_cs,
  Yh as BlurEffectCreatorSample_cs,
  Wh as BlurTexture2DBufferCreator,
  mt as BounceInterpolator,
  pa as BoundUtil,
  ge as BoundingBox,
  es as BoundingSphere,
  ic as BoxColliderShape,
  Ur as BoxGeometry,
  mn as BrdfLut_frag,
  Gn as BsDF_frag,
  En as BxDF_frag,
  Pn as BxdfDebug_frag,
  rs as BytesArray,
  ze as CEvent,
  qt as CEventDispatcher,
  la as CEventListener,
  br as CResizeEvent,
  Ct as CSM,
  Wr as Camera3D,
  np as CameraControllerBase,
  Ae as CameraType,
  Me as CameraUtil,
  wp as CapsuleColliderShape,
  Ml as CastPointShadowMaterialPass,
  Pl as CastShadowMaterialPass,
  Bn as Clearcoat_frag,
  eh as ClusterBoundsSource_cs,
  We as ClusterConfig,
  sn as ClusterDebug_frag,
  zn as ClusterLight,
  $l as ClusterLightingBuffer,
  rh as ClusterLightingRender,
  th as ClusterLighting_cs,
  Ll as CollectInfo,
  Yg as ColliderComponent,
  Le as ColliderShape,
  ri as ColliderShapeType,
  M as Color,
  qm as ColorLitMaterial,
  Hu as ColorLitShader,
  Ds as ColorPassFragmentOutput,
  Zl as ColorPassRenderer,
  Ps as ColorUtil,
  is as ComData,
  gn as Common_frag,
  pn as Common_vert,
  _e as ComponentBase,
  ue as ComponentCollect,
  Kr as ComputeGPUBuffer,
  ae as ComputeShader,
  fh as CubeCamera,
  jh as CubeMapFaceEnum,
  Bs as CubeSky_Shader,
  Ga as CubicBezierCurve,
  rA as CubicBezierPath,
  ff as CubicBezierType,
  Eh as CycleInterpolator,
  CA as CylinderGeometry,
  ph as DDGIIrradianceComputePass,
  oa as DDGIIrradianceGPUBufferReader,
  Nl as DDGIIrradianceVolume,
  gh as DDGIIrradiance_shader,
  xh as DDGILightingPass,
  vh as DDGILighting_shader,
  Ah as DDGIMultiBouncePass,
  _h as DDGIProbeRenderer,
  me as DEGREES_TO_RADIANS,
  Sh as DecelerateInterpolator,
  oh as Depth2DTextureArray,
  ah as DepthCubeArrayTexture,
  wA as DepthCubeTexture,
  Rl as DepthMaterialPass,
  sm as DepthOfFieldPost,
  wu as DepthOfView_cs,
  Bi as DirectLight,
  Hi as DoubleArray,
  Zp as DrawInfo,
  Vp as DynamicDrawStruct,
  Hp as DynamicFaceRenderer,
  Qt as EditorInspector,
  p as Engine3D,
  fl as Entity,
  Ol as EntityBatchCollect,
  z as EntityCollect,
  An as EnvMap_frag,
  ut as ErpImage2CubeMap,
  qh as ErpImage2CubeMapCreateCube_cs,
  Kh as ErpImage2CubeMapRgbe2rgba_cs,
  Tp as ExtrudeGeometry,
  Rt as FASTFLOOR,
  Br as FXAAPost,
  Ju as FXAAShader,
  jc as FaceMode,
  xn as FastMathShader,
  ba as FeatureTable,
  tt as FileLoader,
  lp as FirstPersonCameraController,
  If as Float16ArrayTexture,
  IA as Float32ArrayTexture,
  Yp as Float32ArrayUtil,
  hp as FlyCameraController,
  pu as FontChar,
  du as FontInfo,
  gu as FontPage,
  nr as FontParser,
  Ks as ForwardRenderJob,
  Cn as FragmentVarying,
  Io as FrameCache,
  ul as Frustum,
  cl as FrustumCSM,
  Eg as FrustumCulling_cs,
  Mn as FullQuad_vert_wgsl,
  Ee as GBufferFrame,
  Dl as GBufferPass,
  Ms as GBuffer_pass,
  lo as GILighting,
  bc as GIProbeMaterial,
  Do as GIProbeMaterialType,
  Yu as GIProbeShader,
  qs as GIRenderCompleteEvent,
  _a2 as GIRenderStartEvent,
  Vh as GLBChunk,
  Qh as GLBHeader,
  ho as GLBParser,
  xl as GLSLLexer,
  Ci as GLSLLexerToken,
  _l as GLSLPreprocessor,
  wl as GLSLSyntax,
  ou as GLTFBinaryExtension,
  qe as GLTFParser,
  Sa as GLTFSubParser,
  Dh as GLTFSubParserCamera,
  Gh as GLTFSubParserConverter,
  Mh as GLTFSubParserMaterial,
  Ph as GLTFSubParserMesh,
  no as GLTFSubParserSkeleton,
  Rh as GLTFSubParserSkin,
  Vt as GLTFType,
  Qd as GLTF_Accessors,
  Ca as GLTF_Info,
  Nd as GLTF_Light,
  Gd as GLTF_Mesh,
  zd as GLTF_Node,
  kd as GLTF_Primitives,
  Fd as GLTF_Scene,
  ct as GPUAddressMode,
  Ef as GPUBlendFactor,
  Jt as GPUBufferBase,
  Tt as GPUBufferType,
  kt as GPUCompareFunction,
  y as GPUContext,
  nt as GPUCullMode,
  Gt as GPUFilterMode,
  Ai as GPUPrimitiveTopology,
  N as GPUTextureFormat,
  vi as GPUVertexFormat,
  Df as GPUVertexStepMode,
  om as GTAOPost,
  Iu as GTAO_cs,
  Au as GUIAtlasTexture,
  Zi as GUICanvas,
  Tr as GUIConfig,
  hc as GUIGeometry,
  cc as GUIGeometryRebuild,
  Bo as GUIMaterial,
  pc as GUIPick,
  vc as GUIPickHelper,
  Wt as GUIQuad,
  Ie as GUIQuadAttrEnum,
  fc as GUIRenderer,
  Eo as GUIShader,
  It as GUISpace,
  $r as GUISprite,
  wr as GUITexture,
  Fn as GenerayRandomDir,
  gm as GeoJsonParser,
  pm as GeoJsonUtil,
  Oa as GeoType,
  xe as GeometryBase,
  jl as GeometryIndicesBuffer,
  La as GeometryInfo,
  Mo as GeometryUtil,
  Xl as GeometryVertexBuffer,
  Xe as GeometryVertexType,
  Jo as GetComponentClass,
  bs as GetCountInstanceID,
  Yf as GetRepeat,
  Zo as GetShader,
  Km as GlassMaterial,
  Xu as GlassShader,
  oe as GlobalBindGroup,
  Gs as GlobalBindGroupLayout,
  nm as GlobalFog,
  Zu as GlobalFog_shader,
  xp as GlobalIlluminationComponent,
  ua as GlobalUniform,
  dl as GlobalUniformGroup,
  lm as GodRayPost,
  bu as GodRay_cs,
  Tc as Graphic3D,
  ma as Graphic3DBatchRenderer,
  Ft as Graphic3DFaceRenderer,
  Ec as Graphic3DFillRenderer,
  Vc as Graphic3DFixedRenderMaterial,
  Bc as Graphic3DLineRenderer,
  rm as Graphic3DMesh,
  Xc as Graphic3DMeshRenderer,
  ni as Graphic3DRibbonRenderer,
  Gu as Graphic3DShader,
  Ug as GraphicFaceCompute3,
  Qu as GraphicLineCompute,
  Ws as Graphics3DShape,
  fo as HDRTexture,
  Ia as HDRTextureCube,
  kn as Hair_frag,
  Wu as Hair_shader_op,
  ju as Hair_shader_tr,
  ga as HaltonSeq,
  Cc as Horizontal,
  up as HoverCameraController,
  Ot as I3DMLoader,
  nu as I3DMLoaderBase,
  hu as I3DMParser,
  eu as IBLEnvMapCreator,
  $h as IBLEnvMapCreator_cs,
  zt as IESProfiles,
  yn as IESProfiles_frag,
  Rp as IKDTreeUserData,
  ti as ImageType,
  Wl as IndicesGPUBuffer,
  dn as Inline_vert,
  Ko as InputSystem,
  _p as InstanceDrawComponent,
  vn as InstanceUniform,
  lu as InstancedMesh,
  yr as Interpolator,
  Js as InterpolatorEnum,
  Qc as IrradianceDataReaderCompleteEvent,
  fn as IrradianceVolumeData_frag,
  In as Irradiance_frag,
  Mf as IsEditorInspector,
  ws as IsNonSerialize,
  Uh as Joint,
  oo as JointPose,
  Ih as JumperInterpolator,
  Lp as KDTreeEntity,
  Cr as KDTreeNode,
  Rc as KDTreeRange,
  Uc as KDTreeSpace,
  ra as KDTreeUUID,
  so as KHR_draco_mesh_compression,
  mm as KHR_lights_punctual,
  Nh as KHR_materials_clearcoat,
  zh as KHR_materials_emissive_strength,
  Am as KHR_materials_ior,
  vm as KHR_materials_sheen,
  xm as KHR_materials_specular,
  _m as KHR_materials_transmission,
  kh as KHR_materials_unlit,
  Cm as KHR_materials_variants,
  Sm as KHR_materials_volume,
  ym as KHR_mesh_quantization,
  wm as KHR_texture_basisu,
  Im as KHR_texture_transform,
  Ro as KV,
  TA as KelvinUtil,
  Ge as KeyCode,
  cr as KeyEvent,
  Pa as Keyframe,
  Sf as KeyframeT,
  Ea as LDRTextureCube,
  Dg as LUT_glsl,
  Jm as LambertMaterial,
  Vn as Lambert_shader,
  Ma as Light,
  Ei as LightBase,
  da as LightData,
  zl as LightEntries,
  Pe as LightType,
  on as LightingFunction_frag,
  Ve as Line,
  Yc as LineCap,
  mc as LineClassification,
  Hc as LineJoin,
  wh as LinearInterpolator,
  Oo as LitHairShader,
  ar as LitMaterial,
  Uo as LitSSSShader,
  Lo as LitShader,
  Tn as Lit_shader,
  Vr as LoaderBase,
  Op as LoaderEvent,
  ts as LoaderManager,
  kf as MAX_VALUE,
  Gf as MIN_VALUE,
  je as Material,
  Bl as MaterialDataUniformGPUBuffer,
  Ng as MaterialUniform,
  Fa as MaterialUtilities,
  ha as MathShader,
  Ze as MathUtil,
  Or as Matrix3,
  P as Matrix4,
  Ql as MatrixBindGroup,
  Mp as MatrixDO,
  Gl as MatrixGPUBuffer,
  Nn as MatrixShader,
  fr as MemoryDO,
  en as MemoryInfo,
  zp as MergeRGBACreator,
  Eu as MergeRGBA_cs,
  $a as MeshColliderShape,
  Ra as MeshFilter,
  J as MeshRenderer,
  oA as MinMaxAnimationCurves,
  xf as MinMaxCurve,
  vf as MinMaxCurveState,
  nA as MinMaxPolyCurves,
  Gp as MorePassParser,
  kc as MorePassShader,
  ep as MorphTargetBlender,
  Hl as MorphTargetData,
  tp as MorphTargetFrame,
  nc as MorphTargetTransformKey,
  dt as MorphTarget_shader,
  Fc as MouseCode,
  mh as MultiBouncePass_cs,
  yf as Navi3DAstar,
  Yi as Navi3DConst,
  Nt as Navi3DEdge,
  lr as Navi3DFunnel,
  _r as Navi3DMaskType,
  xA as Navi3DMergeVertex,
  _A as Navi3DMesh,
  Ke as Navi3DPoint,
  Wo as Navi3DPoint2D,
  Lt as Navi3DPointFat,
  X as Navi3DRouter,
  wf as Navi3DTriangle,
  xi as NonSerialize,
  _n as NormalMap_frag,
  Oh as OAnimationEvent,
  Hh as OBJParser,
  Y as Object3D,
  Fp as Object3DEvent,
  DA as Object3DUtil,
  sc as ObjectAnimClip,
  js as OcclusionSystem,
  Sr as Octree,
  Ul as OctreeEntity,
  cp as OrbitController,
  iA as OrderMap,
  Zt as Orientation3D,
  Bu as OutLineBlendColor_cs,
  Tu as OutlineCalcOutline_cs,
  Lg as OutlinePass,
  hm as OutlinePost,
  Kc as OutlinePostData,
  Jc as OutlinePostManager,
  qc as OutlinePostSlot,
  Du as Outline_cs,
  Bh as OvershootInterpolator,
  Dn as PBRLItShader,
  qu as PBRLitSSSShader,
  rt as ParserBase,
  Ue as ParserFormat,
  Af as ParticleSystemCurveEvalMode,
  df as ParticleSystemRandomnessIds,
  Si as PassGenerate,
  Gc as PassShader,
  q as PassType,
  Og as PavementShader,
  $m as PhysicMaterial,
  nn as PhysicMaterialUniform_frag,
  Dc as PickCompute,
  Pc as PickFire,
  Zc as PickResult,
  Pu as Picker_cs,
  Rs as PingPong,
  Xs as PipelinePool,
  Yo as Plane,
  _f as Plane3D,
  Rr as PlaneClassification,
  Kl as PlaneGeometry,
  Ac as PointClassification,
  Ti as PointLight,
  sh as PointLightShadowRenderer,
  ih as PointShadowCubeCamera,
  Fg as PointShadowDebug,
  U as PointerEvent3D,
  Yt as Polynomial,
  hr as PolynomialCurve,
  sA as Polynomials,
  dc as PoolNode,
  wt as PostBase,
  Co as PostProcessingComponent,
  uh as PostRenderer,
  lh as PreDepthPassRenderer,
  Mu as PreIntegratedLut,
  zc as PreIntegratedLutCompute,
  ef as PrefabAvatarData,
  tf as PrefabAvatarParser,
  $c as PrefabBoneData,
  af as PrefabMaterialParser,
  nf as PrefabMeshData,
  lf as PrefabMeshParser,
  na as PrefabNode,
  uf as PrefabParser,
  Rm as PrefabStringUtil,
  rf as PrefabTextureData,
  hf as PrefabTextureParser,
  Dt as Preprocessor,
  Ic as Probe,
  kl as ProbeEntries,
  dh as ProbeGBufferFrame,
  St as ProfilerUtil,
  qg as PropertyAnimClip,
  oc as PropertyAnimTag,
  zo as PropertyAnimation,
  cf as PropertyAnimationClip,
  Li as PropertyAnimationEvent,
  Ui as PropertyHelp,
  $e as QuadAABB,
  Yn as QuadGlsl_fs,
  Hn as QuadGlsl_vs,
  Oc as QuadRoot,
  va as QuadShader,
  Lc as QuadTree,
  Ir as QuadTreeCell,
  Ff as Quad_depth2dArray_frag_wgsl,
  Ln as Quad_depth2d_frag_wgsl,
  On as Quad_depthCube_frag_wgsl,
  Un as Quad_frag_wgsl,
  Rn as Quad_vert_wgsl,
  H as Quaternion,
  Yr as RADIANS_TO_DEGREES,
  Zh as RGBEErrorCode,
  go as RGBEHeader,
  po as RGBEParser,
  fe as RTDescriptor,
  Ne as RTFrame,
  Fe as RTResourceConfig,
  be as RTResourceMap,
  Wi as Rand,
  Xf as RandomSeed,
  bt as Ray,
  oi as RayCastMeshDetail,
  jr as Reader,
  ia as Rect,
  ie as Reference,
  _t as RegisterComponent,
  Kt as RegisterShader,
  Jl as RenderContext,
  _i as RenderLayer,
  Qs as RenderLayerUtil,
  tr as RenderNode,
  Fl as RenderShaderCollect,
  Nc as RenderShaderCompute,
  ve as RenderShaderPass,
  it as RenderTexture,
  mr as RendererBase,
  ch as RendererJob,
  hh as RendererMap,
  De as RendererMask,
  Et as RendererMaskUtil,
  Yl as RendererPassState,
  Us as RepeatSE,
  xu as Res,
  ki as RibbonStruct,
  aa as SN_ArrayConstant,
  pr as SN_BinaryOperation,
  Ed as SN_Break,
  Ut as SN_CodeBlock,
  sr as SN_Constant,
  Xa as SN_Continue,
  Ce as SN_Declaration,
  Bd as SN_Discard,
  bd as SN_DoWhileLoop,
  Z as SN_Expression,
  zr as SN_ForLoop,
  Ha as SN_Function,
  Ya as SN_FunctionArgs,
  Nr as SN_FunctionCall,
  Lr as SN_IFBranch,
  $t as SN_Identifier,
  Gr as SN_IndexOperation,
  Ki as SN_Layout,
  Sl as SN_ParenExpression,
  Wa as SN_Precision,
  ji as SN_Return,
  qi as SN_SelectOperation,
  ir as SN_Struct,
  yl as SN_TernaryOperation,
  qr as SN_UnaryOperation,
  kr as SN_WhileLoop,
  bg as SSAO_cs,
  um as SSRPost,
  Ru as SSR_BlendColor_cs,
  cm as SSR_IS_Kernel,
  Uu as SSR_IS_cs,
  Lu as SSR_RayTrace_cs,
  bp as Scene3D,
  Qe as Shader,
  Ys as ShaderAttributeInfo,
  Il as ShaderConverter,
  bl as ShaderConverterResult,
  O as ShaderLib,
  Es as ShaderPassBase,
  Je as ShaderReflection,
  Pt as ShaderStage,
  El as ShaderState,
  Hs as ShaderUniformInfo,
  er as ShaderUtil,
  Sn as ShadingInput,
  lt as ShadowLightsCollect,
  nh as ShadowMapPassRenderer,
  wn as ShadowMapping_frag,
  Mr as ShapeInfo,
  Lh as Skeleton,
  ja as SkeletonAnimationClip,
  Fh as SkeletonAnimationClipState,
  Ht as SkeletonAnimationComponent,
  rp as SkeletonAnimationCompute,
  Hr as SkeletonAnimation_shader,
  ip as SkeletonBlendComputeArgs,
  bi as SkeletonPose,
  ap as SkeletonTransformComputeArgs,
  Jr as SkinnedMeshRenderer,
  Dr as SkinnedMeshRenderer2,
  Tl as SkyGBufferPass,
  Xn as SkyGBuffer_pass,
  rc as SkyMaterial,
  Da as SkyRenderer,
  Ta as SkyShader,
  Tg as Sky_glsl_fs,
  Bg as Sky_glsl_vs,
  bA as SolidColorSky,
  Ip as SphereColliderShape,
  Mi as SphereGeometry,
  Di as SpotLight,
  ya as StandShader,
  he as StatementNode,
  $ as StorageGPUBuffer,
  jo as StorageUtil,
  et as StringUtil,
  SA as StripeGeometry,
  Bt as Struct,
  Ni as StructStorageGPUBuffer,
  ql as SubGeometry,
  Ou as TAACopyTex_cs,
  fm as TAAPost,
  Fu as TAASharpTex_cs,
  Nu as TAA_cs,
  xc as TextAnchor,
  yc as TextFieldLayout,
  Sc as TextFieldLine,
  Re as Texture,
  wa as TextureCube,
  mo as TextureCubeFaceData,
  qa as TextureCubeStdCreator,
  co as TextureCubeUtils,
  kp as TextureMipmapCompute,
  at as TextureMipmapGenerator,
  dp as ThirdPersonCameraController,
  Hm as TileSet,
  Xm as TileSetChild,
  Wm as TileSetChildContent,
  jm as TileSetChildContentMetaData,
  Ym as TileSetRoot,
  Ho as TilesRenderer,
  ce as Time,
  v as TokenType,
  yA as TorusGeometry,
  qo as TouchData,
  Wc as TrailGeometry,
  ht as Transform,
  Vs as TranslatorContext,
  Po as TriGeometry,
  ea as Triangle,
  ko as UIButton,
  wc as UIButtonTransition,
  To as UIComponentBase,
  Np as UIEvent,
  Fr as UIImage,
  Go as UIImageGroup,
  Za as UIInteractive,
  Se as UIInteractiveStyle,
  $i as UIPanel,
  Fi as UIRenderAble,
  Qo as UIShadow,
  Vo as UITextField,
  ur as UITransform,
  gt as UUID,
  Xo as UV,
  EA as Uint16Texture,
  fu as Uint8ArrayTexture,
  Qn as UnLit,
  ka as UnLitMaterial,
  ln as UnLitMaterialUniform_frag,
  Na as UnLitShader,
  zi as UnLitTexArrayMaterial,
  Ua as UnLitTexArrayShader,
  Ku as UnLitTextureArray,
  hn as UnLit_frag,
  ft as UniformGPUBuffer,
  dr as UniformNode,
  He as UniformType,
  L as ValueEnumType,
  vA as ValueOp,
  Xt as ValueParser,
  lA as ValueSpread,
  Q as Vector2,
  d as Vector3,
  Pr as Vector3Ex,
  UA as Vector3Struct,
  G as Vector4,
  Pp as VertexAttribute,
  ku as VertexAttributeIndexShader,
  D as VertexAttributeName,
  gr as VertexAttributeSize,
  Mc as VertexAttributeStride,
  un as VertexAttributes,
  Dp as VertexBufferLayout,
  an as VertexFormat,
  Aa as VertexGPUBuffer,
  _c as Vertical,
  cn as VideoUniform_frag,
  Ep as View3D,
  Ka as ViewPanel,
  xa as ViewQuad,
  de as VirtualTexture,
  Cl as WGSLTranslator,
  ye as WebGPUDescriptorCreator,
  Ts as WorldMatrixUniform,
  Ja as WorldPanel,
  ii as WrapMode,
  xr as WrapTimeMode,
  im as ZCullingCompute,
  zu as ZPassShader_cs,
  Zn as ZPassShader_fs,
  Jn as ZPassShader_vs,
  gl as ZSorterUtil,
  hl as append,
  tu as arrayToString,
  Bf as blendComponent,
  uA as buildCurves,
  cA as calculateCurveRangesValue,
  Qi as calculateMinMax,
  jn as castPointShadowMap_vert,
  W as clamp,
  gd as clampRepeat,
  sp as compute_skeleton_blend,
  op as compute_skeleton_transform,
  sd as cos,
  cd as crossProduct,
  gf as cubicPolynomialRoot,
  pf as cubicPolynomialRootsGeneric,
  hA as curvesSupportProcedural,
  rd as deg2Rad,
  Kn as directionShadowCastMap_frag,
  Ye as dot,
  mf as doubleIntegrateSegment,
  Su as downSample,
  PA as f32,
  nl as fastInvSqrt,
  ol as floorfToIntPos,
  ei as fonts,
  fd as generateRandom,
  dd as generateRandom3,
  rl as getFloatFromInt,
  eg as getGLTypeFromTypedArray,
  $d as getGLTypeFromTypedArrayType,
  od as getGlobalRandomSeed,
  tg as getTypedArray,
  ao as getTypedArrayTypeFromGLType,
  No as grad1,
  Va as grad2,
  Vi as grad3,
  si as grad4,
  Pg as graphicDynamicCompute,
  Rg as graphicFaceCompute,
  Mg as graphicFaceCompute2,
  Vu as graphicTrailCompute,
  MA as i32,
  Fo as integrateSegment,
  Qp as irradianceDataReader,
  aA as kPI,
  Er as lerp,
  Hf as lerpByte,
  Vf as lerpColor,
  Qf as lerpVector3,
  Os as magnitude,
  wg as makeAloneSprite,
  mu as makeGUISprite,
  fa as makeMatrix44,
  ks as matrixMultiply,
  vd as matrixRotate,
  Ad as matrixRotateY,
  rn as mergeFunctions,
  ll as multiplyMatrices4x4REF,
  Cf as normal_distribution,
  ud as normalizeFast,
  tl as normalizeSafe,
  hd as normalizedToByte,
  ld as normalizedToWord,
  Mt as outlinePostData,
  dm as outlinePostManager,
  K as perm,
  yu as post,
  Qa as quadraticPolynomialRootsGeneric,
  id as rad2Deg,
  Xr as random01,
  td as randomBarycentricCoord,
  ed as randomPointBetweenEllipsoid,
  Zf as randomPointBetweenSphere,
  Kf as randomPointInsideCube,
  Jf as randomPointInsideEllipsoid,
  $f as randomPointInsideUnitCircle,
  al as randomPointInsideUnitSphere,
  jf as randomQuaternion,
  qf as randomQuaternionUniformDistribution,
  sl as randomSeed,
  ca as randomUnitVector,
  il as randomUnitVector2,
  ke as rangedRandomFloat,
  Wf as rangedRandomInt,
  vo as readMagicBytes,
  Zm as registerMaterial,
  zs as repeat,
  md as rotMatrix,
  zf as rotateVectorByQuat,
  Fs as roundfToIntPos,
  Ls as scale,
  qn as shadowCastMap_frag,
  Wn as shadowCastMap_vert,
  pt as simplex,
  ad as sin,
  gA as snoise1,
  pA as snoise2,
  mA as snoise3,
  AA as snoise4,
  Ns as sqrMagnitude,
  el as sqrtImpl,
  Tf as stencilStateFace,
  nd as swap,
  Cu as threshold,
  Zr as toHalfFloat,
  RA as u32,
  fA as uniform_real_distribution,
  dA as uniform_real_distribution2,
  wo as upSample,
  w as webGPUContext,
  pl as zSorterUtil
};
//# sourceMappingURL=@orillusion_core.js.map
