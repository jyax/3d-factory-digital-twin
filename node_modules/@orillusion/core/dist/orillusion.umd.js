(function(c,P){typeof exports=="object"&&typeof module<"u"?P(exports):typeof define=="function"&&define.amd?define(["exports"],P):(c=typeof globalThis<"u"?globalThis:c||self,P(c.Orillusion={}))})(void 0,function(c){"use strict";class P{static COLOR_RED=new P(1,0,0,1);static COLOR_GREEN=new P(0,1,0,1);static COLOR_BLUE=new P(0,0,1,1);static COLOR_WHITE=new P(1,1,1,1);static COLOR_0=new P;static COLOR_1=new P;static COLOR_2=new P;static HEX_CHARACTERS="a-f\\d";static MATCH_3OR4_HEX=`#?[${P.HEX_CHARACTERS}]{3}[${P.HEX_CHARACTERS}]?`;static MATCH_6OR8_HEX=`#?[${P.HEX_CHARACTERS}]{6}([${P.HEX_CHARACTERS}]{2})?`;static NON_HEX_CHARS=new RegExp(`[^#${P.HEX_CHARACTERS}]`,"gi");static VALID_HEX_SIZE=new RegExp(`^${P.MATCH_3OR4_HEX}$|^${P.MATCH_6OR8_HEX}$`,"i");r=0;g=0;b=0;a=0;constructor(e=1,t=1,r=1,i=1){this.setTo(e,t,r,i)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}hexToRGB(e){return this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}hexToRGBA(e){return this.a=(e>>24&255)/255,this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}static random(e=1){let t=new P;return t.a=e,t.r=e*Math.random(),t.g=e*Math.random(),t.b=e*Math.random(),t}static randomRGB(e=.5,t=.5,r=.5,i=.5,a=.5,s=.5){let n=new P;return n.a=1,n.r=i+e*Math.random(),n.g=a+t*Math.random(),n.b=s+r*Math.random(),n}static randomGray(e=.5,t=.5){let r=Math.random()*t+e,i=new P;return i.a=1,i.r=r,i.g=r,i.b=r,i}setTo(e,t,r,i){this.r=Math.max(e,0),this.g=Math.max(t,0),this.b=Math.max(r,0),this.a=Math.max(i,0)}setHex(e){if(typeof e!="string"||P.NON_HEX_CHARS.test(e)||!P.VALID_HEX_SIZE.test(e))throw new TypeError("Expected a valid hex string");e=e.replace(/^#/,"");let t=1;e.length===8&&(t=Number.parseInt(e.slice(6,8),16)/255,e=e.slice(0,6)),e.length===4&&(t=Number.parseInt(e.slice(3,4).repeat(2),16)/255,e=e.slice(0,3)),e.length===3&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]);const r=Number.parseInt(e,16),i=r>>16,a=r>>8&255,s=r&255,n=t;this.a=n,this.r=i/255,this.g=a/255,this.b=s/255}getHex(){let e=r=>{r*=255;let i=r.toString(16);return i.length===1&&(i="0"+i),i};return e(this.r)+e(this.g)+e(this.b)+e(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(e){this.setTo(e[0]/255,e[1]/255,e[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(e){this.setTo(e[0]/255,e[1]/255,e[2]/255,e[3]/255)}clone(){return new P().copyFrom(this)}copyFrom(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}copyFromArray(e,t=255){return this.r=e[0]/t,this.g=e[1]/t,this.b=e[2]/t,this.a=e[3]/t,this}copyFromVector(e){return this.r=e.x,this.g=e.y,this.b=e.z,this.a=e.w,this}static hexRGBColor(e,t=null){return t=t||new P,t.hexToRGB(e),t}static lerp(e,t,r,i){let a=i||new P;return a.r=(r.r-t.r)*e+t.r,a.g=(r.g-t.g)*e+t.g,a.b=(r.b-t.b)*e+t.b,a.a=(r.a-t.a)*e+t.a,i}static PRIMARY=4149685;static PRIMARYDARK=3162015;static ACCENT=16728193;static WHITE=16777215;static IVORY=16777200;static LIGHTYELLOW=16777184;static YELLOW=16776960;static SNOW=16775930;static FLORALWHITE=16775920;static LEMONCHIFFON=16775885;static CORNSILK=16775388;static SEASHELL=16774638;static LAVENDERBLUSH=16773365;static PAPAYAWHIP=16773077;static BLANCHEDALMOND=16772045;static MISTYROSE=16770273;static BISQUE=16770244;static MOCCASIN=16770229;static NAVAJOWHITE=16768685;static PEACHPUFF=16767673;static GOLD=16766720;static PINK=16761035;static LIGHTPINK=16758465;static ORANGE=16753920;static LIGHTSALMON=16752762;static DARKORANGE=16747520;static CORAL=16744272;static HOTPINK=16738740;static TOMATO=16737095;static ORANGERED=16729344;static DEEPPINK=16716947;static FUCHSIA=16711935;static MAGENTA=16711935;static RED=16711680;static OLDLACE=16643558;static LIGHTGOLDENRODYELLOW=16448210;static LINEN=16445670;static ANTIQUEWHITE=16444375;static SALMON=16416882;static GHOSTWHITE=16316671;static MINTCREAM=16121850;static WHITESMOKE=16119285;static BEIGE=16119260;static WHEAT=16113331;static SANDYBROWN=16032864;static AZURE=15794175;static HONEYDEW=15794160;static ALICEBLUE=15792383;static KHAKI=15787660;static LIGHTCORAL=15761536;static PALEGOLDENROD=15657130;static VIOLET=15631086;static DARKSALMON=15308410;static LAVENDER=15132410;static LIGHTCYAN=14745599;static BURLYWOOD=14596231;static PLUM=14524637;static GAINSBORO=14474460;static CRIMSON=14423100;static PALEVIOLETRED=14381203;static GOLDENROD=14329120;static ORCHID=14315734;static THISTLE=14204888;static LIGHTGREY=13882323;static TAN=13808780;static CHOCOLATE=13789470;static PERU=13468991;static INDIANRED=13458524;static MEDIUMVIOLETRED=13047173;static SILVER=12632256;static DARKKHAKI=12433259;static ROSYBROWN=12357519;static MEDIUMORCHID=12211667;static DARKGOLDENROD=12092939;static FIREBRICK=11674146;static POWDERBLUE=11591910;static LIGHTSTEELBLUE=11584734;static PALETURQUOISE=11529966;static GREENYELLOW=11403055;static LIGHTBLUE=11393254;static DARKGRAY=11119017;static BROWN=10824234;static SIENNA=10506797;static DARKORCHID=10040012;static PALEGREEN=10025880;static DARKVIOLET=9699539;static MEDIUMPURPLE=9662683;static LIGHTGREEN=9498256;static DARKSEAGREEN=9419919;static SADDLEBROWN=9127187;static DARKMAGENTA=9109643;static DARKRED=9109504;static BLUEVIOLET=9055202;static LIGHTSKYBLUE=8900346;static SKYBLUE=8900331;static GRAY=8421504;static OLIVE=8421376;static PURPLE=8388736;static MAROON=8388608;static AQUAMARINE=8388564;static CHARTREUSE=8388352;static LAWNGREEN=8190976;static MEDIUMSLATEBLUE=8087790;static LIGHTSLATEGRAY=7833753;static SLATEGRAY=7372944;static OLIVEDRAB=7048739;static SLATEBLUE=6970061;static DIMGRAY=6908265;static MEDIUMAQUAMARINE=6737322;static CORNFLOWERBLUE=6591981;static CADETBLUE=6266528;static DARKOLIVEGREEN=5597999;static INDIGO=4915330;static MEDIUMTURQUOISE=4772300;static DARKSLATEBLUE=4734347;static STEELBLUE=4620980;static ROYALBLUE=4286945;static TURQUOISE=4251856;static MEDIUMSEAGREEN=3978097;static LIMEGREEN=3329330;static DARKSLATEGRAY=3100495;static SEAGREEN=3050327;static FORESTGREEN=2263842;static LIGHTSEAGREEN=2142890;static DODGERBLUE=2003199;static MIDNIGHTBLUE=1644912;static AQUA=65535;static CYAN=65535;static SPRINGGREEN=65407;static LIME=65280;static MEDIUMSPRINGGREEN=64154;static DARKTURQUOISE=52945;static DEEPSKYBLUE=49151;static DARKCYAN=35723;static TEAL=32896;static GREEN=32768;static DARKGREEN=25600;static BLUE=255;static MEDIUMBLUE=205;static DARKBLUE=139;static NAVY=128;static BLACK=0}class ue{static time=0;static frame=0;static delta=0;static _startTime=0;static _timeLabel="";static start(e){this._startTime=performance.now(),this._timeLabel=e}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}class Ne{target;currentTarget;type;data;param;time=0;delay=0;mouseCode=0;ctrlKey;altKey;shiftKey;targetTouches;changedTouches;touches;_stopImmediatePropagation=!1;view;constructor(e=null,t=null){this.type=e,this.data=t}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class ea{constructor(e=null,t=null,r=null,i=null,a=0){this.type=e,this.thisObject=t,this.handler=r,this.param=i,this.priority=a}static event_id_count=0;id=0;current;equalCurrentListener(e,t,r,i){return this.type==e&&this.thisObject==r&&this.handler==t&&this.param==i}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}class Xt{listeners={};data;dispatchEvent(e){var t=this.listeners[e.type];if(t!=null){t=t.slice();for(var r=0;r<t.length;r++){var i=t[r];if(i.handler){try{e.param=i.param,e.currentTarget=i,i.thisObject,i.handler.call(i.thisObject,e)}catch{}if(e.isStopImmediatePropagation)break}}}}destroy(){for(var e in this.listeners)for(var t=this.listeners[e];t.length>0;){var r=t[0];r.handler=null,r.thisObject=null,t.splice(0,1)}}addEventListener(e,t,r,i=null,a=0){if(this.listeners[e]==null&&(this.listeners[e]=[]),!this.hasEventListener(e,t,r)){var s=new ea(e,r,t,i,a);return s.id=++ea.event_id_count,s.current=this,this.listeners[e].push(s),this.listeners[e].sort(function(n,l){return l.priority-n.priority}),s.id}for(let n=0;n<this.listeners[e].length;n++){let l=this.listeners[e][n];if(l.equalCurrentListener(e,t,r,i))return l.id}return 0}removeEventListener(e,t,r){if(this.hasEventListener(e,t,r))for(var i=0;i<this.listeners[e].length;i++){var a=this.listeners[e][i];if(a.equalCurrentListener(e,t,r,a.param)){a.handler=null,a.thisObject=null,this.listeners[e].splice(i,1);return}}}removeEventListenerAt(e){for(var t in this.listeners)for(var r=0;r<this.listeners[t].length;r++){var i=this.listeners[t][r];if(i.id==e)return i.handler=null,i.thisObject=null,this.listeners[t].splice(r,1),!0}return!1}removeAllEventListener(e=null){let t;if(e){if(this.listeners[e]){for(var r=0;r<this.listeners[e].length;r++)t=this.listeners[e][r],t.dispose(),this.listeners[e].splice(r,1);delete this.listeners[e]}}else for(let i in this.listeners){for(var r=0;r<this.listeners[i].length;r++)t=this.listeners[i][r],t.dispose(),this.listeners[i].splice(r,1);delete this.listeners[i]}}containEventListener(e){return this.listeners[e]==null?!1:this.listeners[e].length>0}hasEventListener(e,t=null,r=null){if(this.listeners[e]==null)return!1;if(r&&t)for(var i=0;i<this.listeners[e].length;i++){var a=this.listeners[e][i];if(a.equalCurrentListener(e,t,r,a.param))return!0}return!1}}class hr extends Ne{static KEY_DOWN="onKeyDown";static KEY_UP="onKeyUp";keyCode=0}class L extends Ne{static PICK_OVER="onPickOver";static PICK_OVER_GUI="onPickOverGUI";static PICK_CLICK="onPickClick";static PICK_CLICK_GUI="onPickClickGUI";static PICK_OUT="onPickOut";static PICK_OUT_GUI="onPickOutGUI";static PICK_MOVE="onPickMove";static PICK_UP="onPickUp";static PICK_UP_GUI="onPickUpGUI";static PICK_DOWN="onPickDown";static PICK_DOWN_GUI="onPickDownGUI";static POINTER_RIGHT_CLICK="onPointerRightClick";static POINTER_MID_UP="onPointerMidUp";static POINTER_MID_DOWN="onPointerMidDown";static POINTER_CLICK="onPointerClick";static POINTER_MOVE="onPointerMove";static POINTER_DOWN="onPointerDown";static POINTER_UP="onPointerUp";static POINTER_OUT="onPointerOut";static POINTER_OVER="onPointerOver";static POINTER_WHEEL="onPointerWheel";pointerId;pointerType;isPrimary;pressure;mouseX;mouseY;movementX;movementY;deltaX;deltaY;deltaZ;reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}class d{static MAX=new d(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);static MIN=new d(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE);static SAFE_MAX=new d(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);static SAFE_MIN=new d(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);static X_AXIS=new d(1,0,0);static neg_X_AXIS=new d(-1,0,0);static Y_AXIS=new d(0,1,0);static Z_AXIS=new d(0,0,1);static HELP_0=new d;static HELP_1=new d;static HELP_2=new d;static EPSILON=1e-5;static HELP_3=new d;static HELP_4=new d;static HELP_5=new d;static HELP_6=new d;static get ZERO(){return new d(0,0,0)}static get ONE(){return new d(1,1,1)}static get LEFT(){return new d(-1,0,0)}static get RIGHT(){return new d(1,0,0)}static get UP(){return new d(0,1,0)}static get DOWN(){return new d(0,-1,0)}static get BACK(){return new d(0,0,-1)}static get FORWARD(){return new d(0,0,1)}x=0;y=0;z=0;w=1;index=0;static _index=0;constructor(e=0,t=0,r=0,i=0){this.set(e,t,r,i),this.index=d._index++}set a(e){this.w=e}set r(e){this.x=e}set g(e){this.y=e}set b(e){this.z=e}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(e,t,r,i,a){a==d.Z_AXIS?(t.x=e.y,t.y=-e.x,r.x=-e.y,r.y=e.x,t.scaleBy(i*.5),r.scaleBy(i*.5)):a==d.Y_AXIS&&(t.x=e.z,t.z=-e.x,r.x=-e.z,r.z=e.x,t.scaleBy(i*.5),r.scaleBy(i*.5))}static pointToLine(e,t,r){let i=0,a,s,n;if(a=d.distance(e,t),s=d.distance(e,r),n=d.distance(t,r),n<=1e-6||s<=1e-6)return i=0,i;if(a<=1e-6||n*n>=a*a+s*s)return i=s,i;if(s*s>=a*a+n*n)return i=n,i;let l=(a+s+n)/2;return i=2*Math.sqrt(l*(l-a)*(l-s)*(l-n))/a,i}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static getPoints(e,t){let r=[];for(let i=0;i<e;i++){const a=new d(Math.random()*t-t*.5,Math.random()*t-t*.5,Math.random()*t-t*.5);r.push(a)}return r}static getPointNumbers(e,t){let r=[];for(let i=0;i<e;i++)r.push(Math.random()*t-t*.5,Math.random()*t-t*.5,Math.random()*t-t*.5);return r}static getAngle(e,t){let r=e.dotProduct(t)/(e.length*t.length);return Math.acos(r)*180/Math.PI}static sqrMagnitude(e){return e.x*e.x+e.y*e.y+e.z*e.z}static getZYAngle(e,t){return this.calAngle(e.y,e.z,t.y,t.z)}static sub(e,t,r=null){return r=r||new d,r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}static add(e,t,r=null){return r=r||new d,r.x=e.x+t.x,r.y=e.y+t.y,r.z=e.z+t.z,r}static smoothDamp(e,t,r,i,a,s){return null}static distance(e,t){var r=e.x-t.x,i=e.y-t.y,a=e.z-t.z;return Math.sqrt(r*r+i*i+a*a)}static squareDistance(e,t){var r=e.x-t.x,i=e.y-t.y,a=e.z-t.z;return r*r+i*i+a*a}static distanceXZ(e,t){var r=e.x-t.x,i=0,a=e.z-t.z;return Math.sqrt(r*r+i*i+a*a)}set(e,t,r,i=1){return this.x=e,this.y=t,this.z=r,this.w=i,this}add(e,t=null){t||=new d;var r=this.x,i=this.y,a=this.z,s=this.w,n=e.x,l=e.y,h=e.z,u=e.w;return t.setTo(r+n,i+l,a+h,s+u),t}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}distanceToSquared(e){let t=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return t*t+r*r+i*i}addXYZW(e,t,r,i,a=null){a||=new d;var s=this.x,n=this.y,l=this.z,h=this.w,u=e,f=t,g=r,p=i;return a.setTo(s+u,n+f,l+g,h+p),a}clone(){return new d(this.x,this.y,this.z,this.w)}copyFrom(e){var t=this;return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}decrementBy(e){this.x-=e.x,this.y-=e.y,this.z-=e.z}dotProduct(e){return this.x*e.x+this.y*e.y+this.z*e.z}equals(e,t=!1){return this.x==e.x&&this.y==e.y&&this.z==e.z&&(!t||this.w==e.w)}incrementBy(e){this.x+=e.x,this.y+=e.y,this.z+=e.z}divide(e){return e instanceof d?new d(this.x/e.x,this.y/e.y,this.z/e.z):(this.x=this.x/e,this.y=this.y/e,this.z=this.z/e,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(e=1){let t=this;if(this.length!=0){var r=e/this.length;return this.x*=r,this.y*=r,this.z*=r,t}return t}applyQuaternion(e){const t=this.x,r=this.y,i=this.z,a=e.x,s=e.y,n=e.z,l=e.w,h=l*t+s*i-n*r,u=l*r+n*t-a*i,f=l*i+a*r-s*t,g=-a*t-s*r-n*i;return this.x=h*l+g*-a+u*-n-f*-s,this.y=u*l+g*-s+f*-a-h*-n,this.z=f*l+g*-n+h*-s-u*-a,this}scaleBy(e){return this.x*=e,this.y*=e,this.z*=e,this}mul(e){let t=new d;return t.x=this.x*e,t.y=this.y*e,t.z=this.z*e,t}scale(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}scaleToRef(e,t){return t||(t=new d),t.x=this.x*e,t.y=this.y*e,t.z=this.z*e,t}setTo(e,t,r,i=1){this.x=e,this.y=t,this.z=r,this.w=i}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}subtract(e,t=null){return t||(t=new d),t.setTo(this.x-e.x,this.y-e.y,this.z-e.z),t}multiply(e,t=null){t||(t=new d);var r=this.x,i=this.y,a=this.z,s=e.x,n=e.y,l=e.z;return t.setTo(r*s,i*n,a*l),t}divided(e,t=null){t||(t=new d);var r=this.x,i=this.y,a=this.z,s=e.x,n=e.y,l=e.z;return t.setTo(r/s,i/n,a/l),t}div(e,t){t||(t=new d);var r=this.x,i=this.y,a=this.z,s=this.w;return t.setTo(r/e,i/e,a/e,s/e),t}lerp(e,t,r){var i=e.x,a=e.y,s=e.z,n=e.w,l=t.x,h=t.y,u=t.z,f=t.w;this.x=(l-i)*r+i,this.y=(h-a)*r+a,this.z=(u-s)*r+s,this.w=(f-n)*r+n}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let e=Math.abs(this.x),t=Math.abs(this.y);e>t?this.x>0?this.copyFrom(d.RIGHT):this.copyFrom(d.LEFT):this.y>0?this.copyFrom(d.DOWN):this.copyFrom(d.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(e){e.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),e.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),e.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(e,t=null){return t=t||new d,t.x=this.y*e.z-this.z*e.y,t.y=this.z*e.x-this.x*e.z,t.z=this.x*e.y-this.y*e.x,t.w=1,t}crossVectors(e,t){return e.crossProduct(t,this),this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}setFromArray(e,t=0){this.x=e[t],this.y=e[t+1],this.z=e[t+2]}divideScalar(e){return this.multiplyScalar(1/e)}clampLength(e,t){let r=this.length;return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}setScalar(e){return this.x=e,this.y=e,this.z=e,this}static calAngle(e,t,r,i){const a=n(r,i,e,t);let s=Math.acos(a)*180/Math.PI;return r<e&&(s=-s),s;function n(h,u,f,g){let p=[h-f,u-g];return l(p,[0,-1])}function l(h,u){let f=h[0]*u[0]+h[1]*u[1],g=Math.sqrt(h[0]*h[0]+h[1]*h[1])*Math.sqrt(u[0]*u[0]+u[1]*u[1]);return f/g}}static pointInsideTriangle(e,t,r,i){return d.HELP_0.setTo(e.x,e.z,0),d.HELP_1.setTo(t.x,t.z,0),d.HELP_2.setTo(r.x,r.z,0),d.HELP_3.setTo(i.x,i.z,0),d.pointInsideTriangle2d()}static pointInsideTriangle2d(){return d.productXY(d.HELP_1,d.HELP_2,d.HELP_3)>=0?d.productXY(d.HELP_1,d.HELP_2,d.HELP_0)>=0&&d.productXY(d.HELP_2,d.HELP_3,d.HELP_0)>=0&&d.productXY(d.HELP_3,d.HELP_1,d.HELP_0)>=0:d.productXY(d.HELP_1,d.HELP_2,d.HELP_0)<=0&&d.productXY(d.HELP_2,d.HELP_3,d.HELP_0)<=0&&d.productXY(d.HELP_3,d.HELP_1,d.HELP_0)<=0}static productXY(e,t,r){var i=(e.x-r.x)*(t.y-r.y)-(e.y-r.y)*(t.x-r.x);return i>-1e-5&&i<1e-5&&(i=0),i}static serialize(e){return new d(e.x,e.y,e.z,e.w)}}class Do{constructor(e){this.canvasX=e.clientX,this.canvasY=e.clientY,this.identifier=e.identifier,this.clientX=e.clientX,this.clientY=e.clientY,this.pageX=e.pageX,this.pageY=e.pageY,this.screenX=e.screenX,this.screenY=e.screenY}canvasX;canvasY;identifier;clientX;clientY;pageX;pageY;screenX;screenY}class Po extends Xt{canvasX=0;canvasY=0;isMouseDown=!1;isRightMouseDown=!1;canvas;mouseX=0;mouseY=0;wheelDelta=0;mouseOffsetX=0;mouseOffsetY=0;mouseLastX=0;mouseLastY=0;_time=0;_keyStatus;_mouseStatus;_isTouchStart;_keyEvent3d;_pointerEvent3D;_windowsEvent3d;initCanvas(e){this.canvas=e,e.onpointerdown=r=>{r.button==0?this.mouseStart(r):r.button==1?this.middleDown(r):r.button==2&&this.mouseStart(r)},e.onpointerup=r=>{r.button==0?this.mouseEnd(r):r.button==1?this.middleUp(r):r.button==2&&this.mouseEnd(r)},e.onpointerenter=r=>{this.mouseOver(r)},e.onpointermove=r=>{this.mouseMove(r)},e.onpointercancel=r=>{this.mouseEnd(r)},e.onpointerleave=r=>{this.mouseEnd(r)},e.onpointerout=r=>{this.mouseEnd(r)},e.addEventListener("click",r=>{r.button==2?(this.isRightMouseDown=!1,this.rightClick(r)):r.button==0&&(this.isMouseDown=!1,this.mouseClick(r))},!0),e.addEventListener("wheel",r=>this.mouseWheel(r),{passive:!1}),window.addEventListener("keydown",r=>this.keyDown(r),!0),window.addEventListener("keyup",r=>this.keyUp(r),!0),e.oncontextmenu=function(){return!1};let t=this.canvas.getBoundingClientRect();this.canvasX=t.left,this.canvasY=t.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new hr,this._pointerEvent3D=new L,this._windowsEvent3d=new Ne}_gp=!1;onPinch(e,t,r,i){this._oldPosition1=new d(e,t),this._oldPosition2=new d(r,i)}onSwipe(e,t){this.mouseX=e,this.mouseY=t,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}_oldPosition1=null;_oldPosition2=null;GetTargetTouches(e){for(var t=new Array,r=0;r<e.length;r++){var i=new Do(e[r]);t.push(i)}return t}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}middleDown(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_MID_DOWN,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}middleUp(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_MID_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=L.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}_downTime=0;mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=L.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=L.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=L.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=hr.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=hr.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,t){return Math.atan2(t,e)*180/Math.PI}GetSlideDirection(e,t,r,i){var a=t-i,s=r-e,n=0;if(Math.abs(s)<2&&Math.abs(a)<2)return n;var l=this.GetSlideAngle(s,a);return l>=-45&&l<45?n=4:l>=45&&l<135?n=1:l>=-135&&l<-45?n=2:(l>=135&&l<=180||l>=-180&&l<-135)&&(n=3),n}}const of="0.7.2";let ut={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},nf={zero:"zero",one:"one",src:"src",one_minus_src:"one-minus-src",src_alpha:"src-alpha",one_minus_src_alpha:"one-minus-src-alpha",dst:"dst",one_minus_dst:"one-minus-dst",dst_alpha:"dst-alpha",one_minus_dst_alpha:"one-minus-dst-alpha",src_alpha_saturated:"src-alpha-saturated",constant:"constant",one_minus_constant:"one-minus-constant"};const lf={srcFactor:"one",dstFactor:"zero",operation:"add"},hf={compare:"always",failOp:"keep",depthFailOp:"keep",passOp:"keep"};let zt={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},at={none:"none",front:"front",back:"back"},kt={nearest:"nearest",linear:"linear"},ii={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},z={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},ai={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"},uf={vertex:"vertex",instance:"instance"};class yr extends Ne{static RESIZE="resize"}class cf extends Xt{adapter;device;context;aspect;presentationSize=[0,0];presentationFormat;canvas;windowWidth;windowHeight;canvasConfig;super=1;_pixelRatio=1;_resizeEvent;get pixelRatio(){return this._pixelRatio}async init(e){if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");const r=this.canvas.clientWidth,i=this.canvas.clientHeight;r!=this.canvas.clientWidth&&(this.canvas.style.width=r+"px"),i!=this.canvas.clientHeight&&(this.canvas.style.height=i+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e?.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=await this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");return this._pixelRatio=this.canvasConfig?.devicePixelRatio||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2),this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"srgb"}),this._resizeEvent=new yr(yr.RESIZE,{width:this.windowWidth,height:this.windowHeight}),new ResizeObserver(()=>{this.updateSize(),De.destroyTexture()}).observe(this.canvas),this.updateSize(),!0}updateSize(){let e=Math.floor(this.canvas.clientWidth*this.pixelRatio*this.super),t=Math.floor(this.canvas.clientHeight*this.pixelRatio*this.super);(e!=this.windowWidth||t!=this.windowHeight)&&(this.canvas.width=this.windowWidth=e,this.canvas.height=this.windowHeight=t,this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight,this._resizeEvent.data.width=this.windowWidth,this._resizeEvent.data.height=this.windowHeight,this.dispatchEvent(this._resizeEvent))}}let I=new cf;class Le{static colorBufferTex_NAME="colorBufferTex";static positionBufferTex_NAME="positionBufferTex";static normalBufferTex_NAME="normalBufferTex";static materialBufferTex_NAME="materialBufferTex";static zBufferTexture_NAME="zBufferTexture";static zPreDepthTexture_NAME="zPreDepthTexture";static outTex_NAME="outTex"}var Be=(o=>(o[o.Default=1]="Default",o[o.IgnoreDepthPass=2]="IgnoreDepthPass",o[o.Sky=6]="Sky",o[o.Particle=10]="Particle",o[o.SkinnedMesh=16]="SkinnedMesh",o[o.MorphTarget=32]="MorphTarget",o[o.Terrain=64]="Terrain",o[o.UI=128]="UI",o))(Be||{});class bt{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)==t}}function si(o,e){let t=o.__NonSerialize__;t||(t=o.__NonSerialize__={},t.__NonSerialize__=!0),t[e]=!0}function Va(o,e){let t;for(;o&&(o=o.__proto__,o&&(t=o.__NonSerialize__),!t););return t&&t[e]}function Gt(o,e,t,r,i){let a=o.__EditorInspector__;a||(a=o.__EditorInspector__=new Map);let s=a.get(o.constructor.name);s||(s=new Map,a.set(o.constructor.name,s)),s.set(e,{p1:t,p2:r,p3:i})}function ff(o){let e,t=o,r=[];for(;t;){if(r.indexOf(t.constructor.name)!=-1){t=t.__proto__;continue}r.push(t.constructor.name),t=t.__proto__}for(r=r.reverse(),t=o;t&&(t=t.__proto__,t&&(e=t.__EditorInspector__),!e););let i=new Map;if(e)for(let a=0;a<r.length;a++){const s=r[a];let n=e.get(s);n&&n.forEach((l,h)=>{i.set(h,l)})}return i}function mt(o,e,t,r,i){let a=window.__Component__;a||(a=window.__Component__={}),a[e]=o}function Mo(o){let e=window.__Component__;return e[o]?e[o]:null}function jt(o,e,t,r,i){let a=window.__shader__;a||(a=window.__shader__={}),a[e]=o}function Ro(o){let e=window.__shader__;return e[o]?e[o]:null}var df=Object.defineProperty,gf=Object.getOwnPropertyDescriptor,Uo=(o,e,t,r)=>{for(var i=r>1?void 0:r?gf(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&df(e,t,i),i};const Ha=class $i{__refection;__size=0;getValueType(){if(!this.__refection){let e=this;this.__refection=[];for(const t in e)if(!Va(this,t)){const r=e[t];let i={name:t,type:r.constructor.name};this.__refection.push(i)}}return this.__refection}static getValueSize(e){switch(e.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return e.byteLength;case"Vector2":return 2*4;case"Vector3":return 3*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let r=0;for(let i=0,a=e.length;i<a;i++)r+=$i.getValueSize(e[i]);return r}return 0}static __cacheStruct=new Map;static Ref(e){return this.Get(e).getValueType()}static Get(e){let t=$i.__cacheStruct.get(e.prototype);return t||(t=new e,$i.__cacheStruct.set(e.prototype,t)),t}static GetSize(e){let t=this.Get(e);if(t.__size==0){for(const r in t)if(!Va(t,r)){const i=t[r];t.__size+=$i.getValueSize(i)}t.__size>4&&(t.__size=Math.ceil(t.__size/4)*4)}return t.__size}};Uo([si],Ha.prototype,"__refection",2),Uo([si],Ha.prototype,"__size",2);let Bt=Ha;class Lo{byteOffset;byteSize;offset=0;dataBytes;get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(e){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,e,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(e){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,e,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(e){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,e,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(e){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,e,!0)}setX(e){this.x=e}setXY(e,t){this.x=e,this.y=t}setXYZ(e,t,r){this.x=e,this.y=t,this.z=r}setXYZW(e,t,r,i){this.x=e,this.y=t,this.z=r,this.w=i}setVector2Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.dataBytes.setFloat32((t*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((t*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((t*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((t*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(e,t=0){this.dataBytes.setInt8(t*Int8Array.BYTES_PER_ELEMENT,e)}getInt8(e=0){return this.dataBytes.getInt8(e*Int8Array.BYTES_PER_ELEMENT)}setInt16(e,t=0){this.dataBytes.setInt16(t*Int16Array.BYTES_PER_ELEMENT,e,!0)}getInt16(e=0){return this.dataBytes.getInt16(e*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(e,t=0){this.dataBytes.setInt32(t*Int32Array.BYTES_PER_ELEMENT,e,!0)}getInt32(e=0){return this.dataBytes.getInt32(e*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(e,t=0){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}getFloat(e=0){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(e,t=0){this.dataBytes.setUint8(t*Uint8Array.BYTES_PER_ELEMENT,e)}getUint8(e=0){return this.dataBytes.getUint8(e*Uint8Array.BYTES_PER_ELEMENT)}setUint16(e,t=0){this.dataBytes.setUint16(t*Uint16Array.BYTES_PER_ELEMENT,e,!0)}getUint16(e=0){return this.dataBytes.getUint16(e*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(e,t=0){this.dataBytes.setUint32(t*Uint32Array.BYTES_PER_ELEMENT,e,!0)}getUint32(e=0){return this.dataBytes.getUint32(e*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(e,t){for(let r=0;r<t.length;r++){const i=t[r];this.dataBytes.setFloat32((e+r)*Float32Array.BYTES_PER_ELEMENT,i,!0)}}setFloat32Array(e,t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Float32Array.BYTES_PER_ELEMENT,t.length).set(t)}setArrayBuffer(e,t){t instanceof Uint8Array?this.setUint8Array(e,t):t instanceof Uint16Array?this.setUint16Array(e,t):t instanceof Uint32Array?this.setUint32Array(e,t):t instanceof Int8Array?this.setInt8Array(e,t):t instanceof Int16Array?this.setInt16Array(e,t):t instanceof Int32Array?this.setInt32Array(e,t):t instanceof Float32Array&&this.setFloat32Array(e,t)}setInt8Array(e,t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int8Array.BYTES_PER_ELEMENT).set(t)}setInt16Array(e,t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int16Array.BYTES_PER_ELEMENT).set(t)}setInt32Array(e,t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Int32Array.BYTES_PER_ELEMENT).set(t)}setUint8Array(e,t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint8Array.BYTES_PER_ELEMENT).set(t)}setUint16Array(e,t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint16Array.BYTES_PER_ELEMENT).set(t)}setUint32Array(e,t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+e*Uint32Array.BYTES_PER_ELEMENT).set(t)}setData(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}setVector2(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0)}setVector3(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0)}setVector4(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.x,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.y,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.z,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.w,!0)}setColor(e,t){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t.r,!0),this.dataBytes.setFloat32((e+1)*Float32Array.BYTES_PER_ELEMENT,t.g,!0),this.dataBytes.setFloat32((e+2)*Float32Array.BYTES_PER_ELEMENT,t.b,!0),this.dataBytes.setFloat32((e+3)*Float32Array.BYTES_PER_ELEMENT,t.a,!0)}getData(e){return this.dataBytes.getFloat32(e*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(e){this.dataBytes.setFloat32(this.offset,e,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(e){this.dataBytes.setInt8(this.offset,e),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(e){this.dataBytes.setInt16(this.offset,e,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(e){this.dataBytes.setInt32(this.offset,e,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(e){this.dataBytes.setUint8(this.offset,e),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(e){this.dataBytes.setUint16(this.offset,e,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(e){this.dataBytes.setUint32(this.offset,e,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(e){this.writeFloat(e.x),this.writeFloat(e.y)}writeVector3(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z)}writeVector4(e){this.writeFloat(e.x),this.writeFloat(e.y),this.writeFloat(e.z),this.writeFloat(e.w)}writeRGBColor(e){this.writeFloat(e.r),this.writeFloat(e.g),this.writeFloat(e.b)}writeArray(e){for(let t=0;t<e.length;t++){const r=e[t];this.writeFloat(r)}}writeFloat32Array(e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt8Array(e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt16Array(e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeInt32Array(e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint8Array(e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint16Array(e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}writeUint32Array(e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(e),this.offset+=e.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class ur{shareDataBuffer;_byteOffset=0;allocation(e){this.shareDataBuffer&&this.shareDataBuffer.byteLength<e?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(e)}allocation_node(e){if(this._byteOffset+e>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,e,this.shareDataBuffer.byteLength),null;let t=new Lo;return t.byteOffset=this._byteOffset,t.byteSize=e,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t}allocation_memory(e){return this._byteOffset+e.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,e.byteSize,this.shareDataBuffer.byteLength),null):(e.byteOffset=this._byteOffset,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e)}reset(){this._byteOffset=0}destroy(e){this.shareDataBuffer=null,this._byteOffset=0}}class Wt{bufferType;buffer;memory;memoryNodes;seek;outFloat32Array;byteSize;usage;visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE;mapAsyncBuffersOutstanding=0;mapAsyncReady;_readBuffer;_dataView;constructor(){this.mapAsyncReady=[]}debug(){}reset(e=!1,t=0,r){this.seek=0,this.memory.reset(),e&&this.createBuffer(this.usage,t,r)}setBoolean(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t?1:0)}setFloat(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setX(t)}setInt8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setInt8(t)}setInt16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setInt16(t)}setInt32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setInt32(t)}setUint8(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(e,r)),r.setUint8(t)}setUint16(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(e,r)),r.setUint16(t)}setUint32(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(e,r)),r.setUint32(t)}setVector2(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(e,r)),r.setXY(t.x,t.y)}setVector3(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(e,r)),r.setXYZ(t.x,t.y,t.z)}setVector4(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.x,t.y,t.z,t.w)}setVector4Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setVector4Array(t)}setColor(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(e,r)),r.setXYZW(t.r,t.g,t.b,t.a)}setColorArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(4*4*t.length),this.memoryNodes.set(e,r)),r.setColorArray(t)}setMatrix(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t.rawData)}setMatrixArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(16*4*t.length),this.memoryNodes.set(e,r));for(let i=0;i<t.length;i++){const a=t[i];r.setFloat32Array(i*16,a.rawData)}}setArray(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setArray(0,t)}setFloat32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setFloat32Array(0,t)}setInt32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setInt32Array(0,t)}setUint32Array(e,t){let r=this.memoryNodes.get(e);r||(r=this.memory.allocation_node(t.length*4),this.memoryNodes.set(e,r)),r.setUint32Array(0,t)}setStruct(e,t,r,i){let a=Bt.Ref(e);Bt.GetSize(e);let s=t,n=this.memoryNodes.get(s);n.reset();let l=r;i&&(l=l[i]);for(let h=0;h<a.length;h++){const u=a[h];let f=l[u.name];this.writeValue(n,u,f)}}writeValue(e,t,r){switch(t.type){case"Boolean":e.writeFloat(r);break;case"Number":e.writeFloat(r);break;case"Float32Array":e.writeFloat32Array(r);break;case"Vector2":e.writeVector2(r);break;case"Vector3":e.writeVector3(r);break;case"Vector4":e.writeVector4(r);break;case"Color":e.writeRGBColor(r);break;case"Array":e.writeArray(r);break}}setStructArray(e,t,r){let i=t.length;for(let a=0;a<i;a++){const s=t[a];this.setStruct(e,a,s,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){I.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}mapAsyncWrite(e,t){let r=I.device;if(e.length>0){let i=null;for(;this.mapAsyncReady.length&&(i=this.mapAsyncReady.shift(),i.usedSize!=e.byteLength);)i.destroy(),this.mapAsyncBuffersOutstanding--,i=null;i||(i=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),i.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(i.getMappedRange(0,t*4)).set(a),i.unmap();const n=r.createCommandEncoder();n.copyBufferToBuffer(i,0,this.buffer,0,t*4),r.queue.submit([n.finish()]),i.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(i))}}destroy(e){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(e,t,r,i){let a=I.device;this.buffer&&this.destroy(),this.byteSize=t*4,this.usage=e,this.buffer=a.createBuffer({label:i,size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new ur,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}resizeBuffer(e,t){this.createBuffer(this.usage,e,t)}createNewBuffer(e,t){let r=I.device,i=t*4,a=e;return this.buffer&&this.destroy(),r.createBuffer({size:i,usage:a,mappedAtCreation:!1})}createBufferByStruct(e,t,r){let i=Bt.GetSize(t),a=i*r,s=I.device;this.buffer=s.createBuffer({label:"StructStorageGPUBuffer",size:a,usage:e,mappedAtCreation:!1}),this.memory=new ur,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(a);for(let n=0;n<r;n++){let l=n,h=this.memoryNodes.get(l);h||(h=this.memory.allocation_node(i),this.memoryNodes.set(l,h))}}_readFlag=!1;readBuffer(){return this.outFloat32Array||=new Float32Array(this.memory.shareDataBuffer.byteLength/4),this._readBuffer||(this._readBuffer=I.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1})),this._readFlag||this.read(),this.outFloat32Array}async read(){this._readFlag=!0;let e=I.device.createCommandEncoder();e.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),I.device.queue.submit([e.finish()]),await this._readBuffer.mapAsync(GPUMapMode.READ);const t=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(t),0),this._readBuffer.unmap(),this._readFlag=!1}}var Et=(o=>(o[o.IndicesGPUBuffer=0]="IndicesGPUBuffer",o[o.VertexGPUBuffer=1]="VertexGPUBuffer",o[o.UniformGPUBuffer=2]="UniformGPUBuffer",o[o.StorageGPUBuffer=3]="StorageGPUBuffer",o[o.ComputeGPUBuffer=4]="ComputeGPUBuffer",o[o.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",o[o.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",o))(Et||{});class Z extends Wt{constructor(e,t=0,r){super(),this.bufferType=Et.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r,"StorageGPUBuffer")}}class ct extends Wt{constructor(e,t){super(),this.bufferType=Et.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,e,t,"UniformGPUBuffer")}genUniformNodes(){}}class ft{static getMorphTargetShaderBinding(e,t){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${e}) @binding(${t})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${e}) @binding(${t+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${e}) @binding(${t+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}static CsMain=`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`}let dt=function(o=16,e=16){var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],i;if(e=e||t.length,o)for(i=0;i<o;i++)r[i]=t[0|Math.random()*e];else{var a;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",i=0;i<36;i++)r[i]||(a=0|Math.random()*16,r[i]=t[i==19?a&3|8:a])}return r.join("")},Oo=1e6,Ya=function(){return Oo++,Oo},pf=function(o,e){let t=0,r=o.length;for(t=0;t<r;t++)if(o[t]==e)return!0;return!1},mf=function(o,e){let t=0,r=o.length;for(t=0;t<r;t++)if(o[t]==e)return t;return-1},Fo=(...o)=>function(...e){o.forEach(t=>t.apply(this,e))};class V{static HELP_0=new V;static HELP_1=new V;static HELP_2=new V;static ZERO=new V(0,0);static SAFE_MAX=new V(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);static SAFE_MIN=new V(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);x=0;y=0;constructor(e=0,t=0){this.x=e,this.y=t}static getAngle(e,t){return Math.atan2(t.y-e.y,t.x-e.x)}static slerp(e,t,r){let i=new V,a=e.dot(t);if(a<0&&(t.x=-t.x,t.y=-t.y,a=-a),a>.9995)return i.x=e.x+r*(t.x-e.x),i.y=e.y+r*(t.y-e.y),i;let s=Math.acos(a),n=Math.sin(s),l=Math.sin((1-r)*s)/n,h=Math.sin(r*s)/n;return i.x=l*e.x+h*t.x,i.y=l*e.y+h*t.y,i}static lerp(e,t,r){return V.HELP_0.copyFrom(e),V.HELP_1.copyFrom(t),V.HELP_0.scale(r),V.HELP_1.scale(1-r),new V(V.HELP_0.x+V.HELP_1.x,V.HELP_0.y+V.HELP_1.y)}set(e=0,t=0){return this.x=e,this.y=t,this}distance(e){return Math.sqrt(Math.pow(this.x-e.x,2)+Math.pow(this.y-e.y,2))}add(e,t){return t=t||new V,t.x=this.x+e.x,t.y=this.y+e.y,t}sub(e,t){return t=t||new V,t.x=this.x-e.x,t.y=this.y-e.y,t}scale(e){return this.x=this.x*e,this.y=this.y*e,this}multiply(e,t){return t=t||new V,t.x=this.x*e,t.y=this.y*e,t}multiplyScaler(e){return this.x*=e,this.y*=e,this}divide(e,t){return t=t||new V,t.x=this.x/e,t.y=this.y/e,t}neg(e){return e||(e=new V),e.x=-e.x,e.y=-e.y,e}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(e){return Math.atan2(e.y-this.y,e.x-this.x)}unt(e){e=e||new V;let t=this.abs();return e.x=this.x/t,e.y=this.y/t,e}angleTo(e){let t=e.x-this.x,r=e.y-this.y;return Math.atan2(r,t)}equals(e){return Math.abs(this.x-e.x)<1e-6&&Math.abs(this.y-e.y)<1e-6}pal(e){let t=this.unt(),r=e.unt();return t.equals(r)?1:t.equals(r.neg())?-1:0}clone(){return new V(this.x,this.y)}copyFrom(e){return this.x=e.x,this.y=e.y,this}dot(e){return this.x*e.x+this.y*e.y}normalize(){let e=this.abs();return this.x=this.x/e,this.y=this.y/e,this}addInPlace(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}}class G{static X_AXIS=new G(1,0,0);static Y_AXIS=new G(0,1,0);static Z_AXIS=new G(0,0,1);static HELP_0=new G;static HELP_1=new G;static HELP_2=new G;static EPSILON=1e-5;static HELP_3=new G;static HELP_4=new G;static HELP_5=new G;static HELP_6=new G;static ZERO=new G;static ONE=new G(1,1,1,1);static LEFT=new G(-1,0,0);static RIGHT=new G(1,0,0);static UP=new G(0,-1,0);static DOWN=new G(0,1,0);static BACK=new G(0,0,-1);static FORWARD=new G(0,0,1);x=0;y=0;z=0;w=1;constructor(e=0,t=0,r=0,i=0){this.x=e,this.y=t,this.z=r,this.w=i}get width(){return this.z}get height(){return this.w}static crossVectors(e,t,r){r=r||new G;var i=e.x,a=e.y,s=e.z,n=t.x,l=t.y,h=t.z;return r.x=a*h-s*l,r.y=s*n-i*h,r.z=i*l-a*n,r}static distance(e,t){let r=e.x-t.x,i=e.y-t.y,a=e.z-t.z,s=e.w-t.w;return Math.sqrt(r*r+i*i+a*a+s*s)}set(e,t,r,i){return this.x=e,this.y=t,this.z=r,this.w=i,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}copyFrom(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}clone(){return new G(this.x,this.y,this.z,this.w)}}var Ve=(o=>(o[o.Number=0]="Number",o[o.Vector2=1]="Vector2",o[o.Vector3=2]="Vector3",o[o.Vector4=3]="Vector4",o[o.Color=4]="Color",o[o.Float32Array=5]="Float32Array",o))(Ve||{});class cr{size;memoryInfo;bindOnChange;_data;_type=Ve.Number;_x=0;_y=0;_z=0;_w=0;constructor(e){this.data=e}get data(){return this._data}set data(e){this._data=e,this._type=Ve.Number,e instanceof V?(this.size=2,this._x=e.x,this._y=e.y,this._type=Ve.Vector2):e instanceof d?(this.size=3,this._x=e.x,this._y=e.y,this._z=e.z,this._type=Ve.Vector3):e instanceof G?(this.size=4,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._type=Ve.Vector4):e instanceof P?(this.size=4,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this._type=Ve.Color):e instanceof Float32Array?(this.size=e.length,this._type=Ve.Float32Array):(this.size=1,this._x=e,this._data=e,this._type=Ve.Number)}getColor(e){return e?e.copyFrom(this._data):e=this._data,e}get color(){return new P(this._data.r,this._data.g,this._data.b,this._data.a)}set color(e){(this._x!=e.r||this._y!=e.g||this._z!=e.b||this._w!=e.a)&&(this._data.r=e.r,this._data.g=e.g,this._data.b=e.b,this._data.a=e.a,this._x=e.r,this._y=e.g,this._z=e.b,this._w=e.a,this.onChange())}get value(){return this._x}set value(e){this._x!=e&&(this._data=e,this._x=e,this.onChange())}get vector2(){return this._data}set vector2(e){(this._x!=e.x||this._y!=e.y)&&(this._data.x=e.x,this._data.y=e.y,this._x=e.x,this._y=e.y,this.onChange())}get vector3(){return this._data}set vector3(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._x=e.x,this._y=e.y,this._z=e.z,this.onChange())}get vector4(){return this._data}set vector4(e){(this._x!=e.x||this._y!=e.y||this._z!=e.z||this._w!=e.w)&&(this._data.x=e.x,this._data.y=e.y,this._data.z=e.z,this._data.w=e.w,this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(e){this._data.set(e),this.onChange()}update(){switch(this._type){case Ve.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case Ve.Vector2:this.memoryInfo.setVector2(0,this._data);break;case Ve.Vector3:this.memoryInfo.setVector3(0,this._data);break;case Ve.Vector4:this.memoryInfo.setVector4(0,this._data);break;case Ve.Color:this.memoryInfo.setColor(0,this._data);break;case Ve.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}class Xa{instanceID;shaderVariant;vsEntryPoint="main";fsEntryPoint="main";bindGroups;shaderReflection;defineValue;constValues;uniforms;materialDataUniformBuffer;_bufferDic;_shaderChange=!0;_valueChange=!1;constructor(){this.instanceID=dt(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(e,t){this._bufferDic.has(e)?this._bufferDic.set(e,t):(this._bufferDic.set(e,t),this.noticeBufferChange(e))}setStructStorageBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setUniformBuffer(e,t){this._bufferDic.has(e)?(this._bufferDic.set(e,t),this.noticeBufferChange(e)):this._bufferDic.set(e,t)}setDefine(e,t){(this.defineValue[e]==null||this.defineValue[e]!=t)&&(this.defineValue[e]=t,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[e]=t}hasDefine(e){return this.defineValue[e]!=null}deleteDefine(e){delete this.defineValue[e],this.noticeShaderChange()}setUniformFloat(e,t){this.uniforms[e]?this.uniforms[e].value=t:(this.uniforms[e]=new cr(t),this.noticeValueChange())}setUniformVector2(e,t){this.uniforms[e]?this.uniforms[e].vector2=t:(this.uniforms[e]=new cr(t),this.noticeValueChange())}setUniformVector3(e,t){this.uniforms[e]?this.uniforms[e].vector3=t:this.uniforms[e]=new cr(t)}setUniformVector4(e,t){this.uniforms[e]?this.uniforms[e].vector4=t:this.uniforms[e]=new cr(t)}setUniformColor(e,t){this.uniforms[e]?this.uniforms[e].color=t:this.uniforms[e]=new cr(t)}setUniformArray(e,t){this.uniforms[e]?this.uniforms[e].float32Array(t):this.uniforms[e]=new cr(t)}setUniform(e,t){this.uniforms[e]?this.uniforms[e].data=t:this.uniforms[e]=new cr(t)}getUniform(e){return this.uniforms[e].data}getUniformFloat(e){return this.uniforms[e].data}getUniformVector2(e){return this.uniforms[e].data}getUniformVector3(e){return this.uniforms[e].data}getUniformVector4(e){return this.uniforms[e].data}getUniformColor(e){return this.uniforms[e].color}getBuffer(e){return this._bufferDic[e].data}noticeBufferChange(e){}applyUniform(){this.materialDataUniformBuffer&&this._valueChange&&this.materialDataUniformBuffer.apply()}destroy(e){}}var fr=(o=>(o[o.u32=1]="u32",o[o.f32=1]="f32",o[o["vec2<f32>"]=2]="vec2<f32>",o[o["vec3<f32>"]=3]="vec3<f32>",o[o["vec4<f32>"]=4]="vec4<f32>",o[o.float32=1]="float32",o[o.float32x2=2]="float32x2",o[o.float32x3=3]="float32x3",o[o.float32x4=4]="float32x4",o))(fr||{});let No=[null,ai.float32,ai.float32x2,ai.float32x3,ai.float32x4],zo=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class ja{static sky_vs_frag_wgsl=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(auto) fragUV: vec2<f32>,
      @location(auto) vWorldPos: vec4<f32>,
      @location(auto) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(auto) position: vec3<f32>,
      @location(auto) normal: vec3<f32>,
      @location(auto) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `;static sky_fs_frag_wgsl=`
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(auto) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(auto) o_Normal: vec4<f32>,
          @location(auto) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `}let ko=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 
      
      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`,ta=`


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns \xB11
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth:f32, near:f32, far:f32) -> f32 {
      let Fcoef:f32 = 2.0 / log2(far + 1.0);
      var result:f32 = (log2(max(1e-6, 1.0 + depth)) * Fcoef - 1.0);
      result = (1.0 + result) / 2.0;
      return result * depth;
    }

    fn log2DepthFixPersp(depth:f32, near:f32, far:f32) -> f32 {
      let flogz:f32 = 1.0 + depth;
      let Fcoef_half:f32 = (2.0 / log2(far + 1.0)) * 0.5;
      var result:f32 = log2(flogz) * Fcoef_half;
      result = (1.0 + result) / 2.0;
      return result;
    }


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

`,Go=`
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  transformUV1:vec4<f32>,
                  transformUV2:vec4<f32>,

                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,
                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,
                  ao: f32,

                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,
                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,
                  clearcoatColor: vec4<f32>,
                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,Qo=`


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Vo=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`;class kr{static groupBindingAndFunctions(e,t){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${e}) @binding(${t})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${e}) @binding(${t+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${e}) @binding(${t+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}let Ho=`
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${ft.getMorphTargetShaderBinding(3,0)}
        ${kr.groupBindingAndFunctions(3,2)} 
    #else
        #if USE_MORPHTARGETS
            ${ft.getMorphTargetShaderBinding(3,0)}
        #endif

        #if USE_SKELETON
            ${kr.groupBindingAndFunctions(3,0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #else
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(auto) index: f32,
    @location(auto) varying_UV0: vec2<f32>,
    @location(auto) varying_UV1: vec2<f32>,
    @location(auto) varying_ViewPos: vec4<f32>,
    @location(auto) varying_Clip: vec4<f32>,
    @location(auto) varying_WPos: vec4<f32>,
    @location(auto) varying_WNormal: vec3<f32>,
    @location(auto) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(auto) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(auto) varying_Tangent: vec4<f32>,
    #endif
   

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${ft.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${ft.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    #if USE_LOGDEPTH
        clipPosition.z = log2Depth(clipPosition.w, globalUniform.near, globalUniform.far);
    #endif

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,Yo=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Xo=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,jo=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,Wo=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2DepthFixPersp(ORI_VertexVarying.fragPosition.w, globalUniform.near, globalUniform.far);
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


`,qo=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Ko=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,Jo=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class At{static Cascades=4}let ra=`

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${At.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    empty1: i32,
    empty2: i32,
    empty3: i32,

    frustumPlanes: array<vec4f, 6u>,
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`,Zo=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,Wa=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,$o=`
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`,en=`

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,tn=`
    struct FragmentVarying {
        @location(auto) index: f32,
        @location(auto) fragUV0: vec2<f32>,
        @location(auto) fragUV1: vec2<f32>,
        @location(auto) viewPosition: vec4<f32>,
        @location(auto) fragPosition: vec4<f32>,
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) vWorldNormal: vec3<f32>,
        @location(auto) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(auto) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,qa=`
    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`,rn=`
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,
    }
`,an=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,sn=`
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }
    var<private> shadowStrut: ShadowStruct ;

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        #if USE_SHADOWMAPING
          directShadowMaping(globalUniform.shadowBias);
          pointShadowMapCompare(globalUniform.pointShadowBias);
        #endif
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${At.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {

        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }

    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        visibility = 0.0;
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var totalWeight = 0.0;
        var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
        let v = max(NoL, 0.0) ;
        var bias = shadowBias / v;
        for (var y = -1; y <= 1; y++) {
          for (var x = -1; x <= 1; x++) {
            var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
            
            // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
            var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
            if ((shadowPos.z - bias ) < depth) {
              visibility += 1.0 ;
            }
            totalWeight += 1.0;
          }
        }
        visibility /= totalWeight;
        visibility += 0.001;
      }
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              let sampleOffset = offset / (samples * 0.5);
              for (var x: f32 = -offset; x < offset; x += sampleOffset) {
                for (var y: f32 = -offset; y < offset; y += sampleOffset) {
                  for (var z: f32 = -offset; z < offset; z += sampleOffset) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
                shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
            #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    shadowStrut.pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`,on=`
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,nn=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness ;//pow(roughness,5.0) ;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , alpha);
        let G = GeometrySmith(Context.NoV,Context.NoL, alpha );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return (col.rgb) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        // var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return fragData.EnvColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let NdotV = max(dot(N,V),0.0);
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));

        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);

        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }
`,ln=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;


      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * vec3f(kdLast) * fragData.Albedo.rgb ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
          // ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,1.0,1.0);
      #endif
      
      var color = specColor + indirectResult ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      var retColor = (LinearToGammaSpace(color.rgb));
      retColor += fragData.Emissive.xyz ;
      ORI_FragmentOutput.color = vec4<f32>( retColor.rgb * fragData.Albedo.a ,fragData.Albedo.a) ;
  }

  `,hn=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`,un=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,cn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = gammaToLiner(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        useShadow();

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif


        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`,fn=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,dn=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,gn=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(auto) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,pn=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,mn=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,An=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Af=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Ka=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`,vn=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`,_n=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildYRotateXMat4(radY:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            x,y,z,1.0,
        );
        return yRot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,xn=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,Cn=`
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt / LUMEN) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              // var shadow = 0.0 ;
              // if(light.castShadow>=0){
              //     #if USE_SHADOWMAPING
              //       shadow = shadowStrut.directShadowVisibility[i32(light.castShadow)] ; 
              //     #endif
              // }

              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `,Sn=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `,yn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        
        UnLit();

        // ORI_FragmentOutput.color = vec4<f32>( 1.0,0.0,0.0,1.0) ;
    }
`,wn=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,In=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,bn=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,Bn=`
#include "GlobalUniform"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,Ja=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,En=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${ft.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${kr.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(auto) position: vec3<f32>,
    @location(auto) normal: vec3<f32>,
    @location(auto) uv: vec2<f32>,
    @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${ft.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,Tn=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @location(auto) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${ft.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${kr.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(auto) position: vec3<f32>,
  @location(auto) normal: vec3<f32>,
  @location(auto) uv: vec2<f32>,
  @location(auto) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #else
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #endif
    #else
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            @location(auto) vIndex: f32,
        #else
            @location(auto) vIndex: f32,
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${ft.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${ft.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,Dn=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,Pn=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,Mn=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(auto) vID: f32 ,
        @location(auto) vPos: vec3<f32> ,
        @location(auto) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${ft.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${kr.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            @location(auto) vIndex: f32,
        #endif
    #elseif USE_SKELETON
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(auto) joints1: vec4<f32>,
            @location(auto) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        @location(auto) vIndex: f32,
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${ft.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,Rn=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(auto) vID: f32, @location(auto) vPos:vec3<f32> ,  @location(auto) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`;class F{static init(){F.register("MathShader",ta),F.register("FastMathShader",$o),F.register("MatrixShader",_n),F.register("GlobalUniform",ra),F.register("WorldMatrixUniform",Wa),F.register("NormalMap_frag",en),F.register("LightingFunction_frag",ko),F.register("PhysicMaterialUniform_frag",Go),F.register("UnLitMaterialUniform_frag",Qo),F.register("VideoUniform_frag",Yo),F.register("InstanceUniform",Zo),F.register("Inline_vert",jo),F.register("VertexAttributes_vert",Ho),F.register("Common_vert",qo),F.register("Common_frag",Wo),F.register("FragmentVarying",tn),F.register("ColorPassFragmentOutput",qa),F.register("ClusterLight",xn),F.register("ShadingInput",rn),F.register("IESProfiles_frag",an),F.register("ShadowMapping_frag",sn),F.register("Irradiance_frag",on),F.register("IrradianceVolumeData_frag",Xo),F.register("BrdfLut_frag",Ko),F.register("EnvMap_frag",Jo),F.register("ColorUtil_frag",Ka),F.register("ColorUtil",Ka),F.register("BRDF_frag",nn),F.register("Hair_frag",Cn),F.register("BxDF_frag",ln),F.register("BsDF_frag",Sn),F.register("UnLit_frag",Vo),F.register("UnLit",yn),F.register("Clearcoat_frag",hn),F.register("LitShader",un),F.register("PBRLItShader",cn),F.register("ClusterDebug_frag",zo),F.register("BxdfDebug_frag",fn),F.register("GenerayRandomDir",vn),F.register("Quad_vert_wgsl",gn),F.register("Quad_frag_wgsl",pn),F.register("Quad_depth2d_frag_wgsl",mn),F.register("Quad_depthCube_frag_wgsl",An),F.register("sky_vs_frag_wgsl",ja.sky_vs_frag_wgsl),F.register("sky_fs_frag_wgsl",ja.sky_fs_frag_wgsl),F.register("LambertShader",wn),F.register("QuadGlsl_vs",In),F.register("QuadGlsl_fs",bn),F.register("SkyGBuffer_fs",Bn),F.register("gbuffer_vs",Ja),F.register("gbuffer_fs",Ja),F.register("castPointShadowMap_vert",Tn),F.register("shadowCastMap_frag",Dn),F.register("shadowCastMap_vert",En),F.register("directionShadowCastMap_frag",Pn),F.register("ZPass_shader_vs",Mn),F.register("ZPass_shader_fs",Rn)}static register(e,t){F[e.toLowerCase()]||(F[e.toLowerCase()]=t)}static getShader(e){return F[e.toLowerCase()],F[e.toLowerCase()]}}class Tt{static parse(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new Un,e,t),e=this.parseAutoBindingForAllGroup(e),e=this.parseAutoLocationBlock(e),e}static parseComputeShader(e,t){return e=this.filterComment(e),e=this.parsePreprocess(new Un,e,t),e=this.parseAutoBindingForAllGroup(e),e}static parsePreprocess(e,t,r){let i=t.indexOf("#");if(i==-1)return t;let a=t.substring(0,i),s=t.indexOf(`
`,t.lastIndexOf("#")),n=t.substring(i,s),l=t.substring(s);return a+this.parsePreprocessCommand(e,n,r)+l}static parseAutoBindingForAllGroup(e){let t=0,r="",i=new Map;for(;t<e.length;){let a=e.indexOf("@group(",t);if(a==-1){r+=e.substring(t);break}let s=e.indexOf(")",a),n=Number.parseInt(e.substring(a+7,s));a=e.indexOf("@binding(",s),s=e.indexOf(")",a);let l=e.substring(a+9,s);if(r+=e.substring(t,a),l.includes("auto"))if(i.has(n)){let h=i.get(n)+1;r+=`@binding(${h})`,i.set(n,h)}else r+="@binding(0)",i.set(n,0);else{let h=Number.parseInt(l);(!i.has(n)||i.get(n)<h)&&i.set(n,h),r+=`@binding(${l})`}t=s+1}return r}static parseAutoBindingForGroupX(e,t){let r=0,i="",a=new Map;for(;r<e.length;){let s=e.indexOf("@group(",r);if(s==-1){i+=e.substring(r);break}let n=e.indexOf(")",s),l=Number.parseInt(e.substring(s+7,n));if(s=e.indexOf("@binding(",n),n=e.indexOf(")",s),i+=e.substring(r,s),l==t)if(a.has(l)){let h=a.get(l)+1;i+=`@binding(${h})`,a.set(l,h)}else i+="@binding(0)",a.set(l,0);else i+=e.substring(s,n+1);r=n+1}return i}static parseAutoLocation(e){let t=0,r="",i=0;for(;t<e.length;){let a=e.indexOf("@location(",t);if(a==-1){r+=e.substring(t);break}let s=e.indexOf(")",a),n=e.substring(a+10,s);r+=e.substring(t,a),n==="auto"?(r+=`@location(${i})`,i++):r+=e.substring(a,s+1),t=s+1}return r}static parseAutoLocationBlock(e){let t=0,r="";for(;t<e.length;){let i=e.indexOf("@location(",t);if(i==-1){r+=e.substring(t);break}let a=e.indexOf("}",i),s=e.indexOf("->",i);s!=-1&&s<a&&(a=s);let n=e.substring(i,a+1);n=this.parseAutoLocation(n),r+=e.substring(t,i),r+=n,t=a+1}return r}static parsePreprocessCommand(e,t,r){let i="",a=t.split(`
`),s=[!1],n=[!1];for(let l=0;l<a.length;l++){let h=a[l],u=s[s.length-1];if(h.trim().indexOf("#")!=0){u||(i+=h+`
`);continue}let f=h.trim();if(f.indexOf("#if")!=-1){if(u&&s.length>1){s.push(u);continue}let g=f.substring(3).trim();u=!this.parseCondition(g,r),s.push(u),n.push(!u);continue}else if(f.indexOf("#elseif")!=-1||f.indexOf("#else")!=-1&&f.indexOf(" if")!=-1){if(n[n.length-1]){s.pop(),u=!0,s.push(u);continue}if(s.pop(),u=s[s.length-1],u&&s.length>1){s.push(u);continue}let p=f.substring(f.indexOf("if")+2).trim();p==""&&console.error(`preprocess command error, conditions missing: ${f}`),u=!this.parseCondition(p,r),s.push(u),n.push(!u);continue}else if(f.indexOf("#else")!=-1){s.pop(),u&&s.length>1&&s[s.length-1]?s.push(u):s.push(!u);continue}else if(f.indexOf("#endif")!=-1){s.pop(),n.pop();continue}else if(f.indexOf("#include")!=-1){let g="",p=f.charAt(f.length-1);if(p==">"?g=this.extract(f,"<",">"):g=this.extract(f,p,p),!e.includeMap.has(g)){e.includeMap.set(g,!0);let A=F.getShader(g);if(!A)throw`${f} error: '${g}' not found`;A=this.filterComment(A),A=this.parsePreprocess(e,A,r),i+=A+`\r
`}continue}else if(f.indexOf("#define ")!=-1){let g=f.substring(f.indexOf("#define ")+8).trim(),p=g.indexOf(" "),A=g,v="";p!=-1&&(A=g.substring(0,p).trim(),v=g.substring(p+1).trim()),r[A]=v;continue}else throw"nonsupport: "+f}return i}static parseCondition(e,t){let r=t[e];return r==null?!1:r==!0||r!=0}static filterComment(e){let t="",r=!0,i=!0;for(let a=0;a<e.length;){let s=r?e.indexOf("//",a):-1,n=i?e.indexOf("/*",a):-1;if(s==-1&&n==-1){t+=e.substring(a);break}r=s!=-1,i=n!=-1,s!=-1&&n!=-1&&(s<n?n=-1:s=-1),s!=-1?(n=e.indexOf(`
`,s),t+=e.substring(a,s),a=n!=-1?n:e.length):n!=-1&&(s=e.indexOf("*/",n),t+=e.substring(a,n),a=s+2)}return t}static extract(e,t,r){let i=e.indexOf(t)+t.length,a=e.indexOf(r,i);return e.substring(i,a).trim()}}class Un{includeMap=new Map;constructor(){}}class He{static _shaderReflectionMap=new Map;attributes=[];vs_variables=[];fs_variables=[];cs_variables=[];groups=[];variables={};useSplit=!1;static parser(e,t){t.shaderReflection||(t.shaderReflection=new He),e.indexOf("@vertex")!=-1?(t.shaderReflection.attributes=this.parserVertexOld(e),t.shaderReflection.vs_variables=this.parserVariables(e)):e.indexOf("@fragment")!=-1?t.shaderReflection.fs_variables=this.parserVariables(e):e.indexOf("@compute")!=-1&&(t.shaderReflection.cs_variables=this.parserVariables(e))}static parser2(e,t){t.shaderReflection||(t.shaderReflection=new He);let r=t.shaderReflection;e.indexOf("@vertex")!=-1?(r.attributes=this.parserVertex(t.vsEntryPoint,e),r.vs_variables=this.parserVariables(e)):e.indexOf("@fragment")!=-1?r.fs_variables=this.parserVariables(e):e.indexOf("@compute")!=-1&&(r.cs_variables=this.parserVariables(e)),e.indexOf("splitTexture")!=-1&&(r.useSplit=!0)}static combineShaderReflectionVarInfo(e,t){for(const r of t){e.groups[r.group]||(e.groups[r.group]=[]);let i=r;if(e.groups[r.group][r.binding]){let a=e.groups[r.group][r.binding],s=r;if(a.dataFields)for(let n=0;n<a.dataFields.length;n++)a.dataFields[n];if(s.dataFields)for(let n=0;n<s.dataFields.length;n++)s.dataFields[n]}e.groups[r.group][r.binding]=i,e.variables[r.varName]=i}}static final(e){let t=e.shaderReflection;this._shaderReflectionMap.set(e.shaderVariant,t),this.combineShaderReflectionVarInfo(t,t.vs_variables),this.combineShaderReflectionVarInfo(t,t.fs_variables)}static getShaderReflection2(e,t){let r=Tt.parse(e,t.defineValue);He.parser2(r,t)}static poolGetReflection(e){return this._shaderReflectionMap.get(e)}static genShaderVar(e){let t=`${e.vs}${e.fs}${e.compute}`;t+="|";for(const r in e.uniforms)t+=r+":";t+="|";for(const r in e.constValues)t+=r+":",t+=e.constValues[r];t+="|";for(const r in e.defines)t+=r+":",t+=e.defines[r];t+="|";for(const r in e.shaderState)t+=r+":",t+=e.shaderState[r]+";";return t}static genShaderVariant(e){let t="";for(const r in e.uniforms)t+=r+":";t+="|";for(const r in e.constValues)t+=r+":",t+=e.constValues[r];t+="|";for(const r in e.defineValue)t+=r+":",t+=e.defineValue[r];return t}static genRenderShaderVariant(e){let t=`RenderShader(${e.vsName},${e.fsName})`;t+="|",t+=this.genShaderVariant(e),t+="|";for(const r in e.shaderState)t+=r+":",t+=e.shaderState[r]+";";return t}static genComputeShaderVariant(e){let t=`ComputeShader(${e.instanceID})`;return t+="|",t+=this.genShaderVariant(e),t}combine(e){let t=e.shaderReflection,r=e.defines,i={};for(let s=0;s<this.attributes.length;s++){let n=this.attributes[s];r[n.name]&&(i[n.name]=n)}let a=t.attributes.length;for(let s=0;s<a;s++){const n=t.attributes[s];if(!i[n.name])this.attributes.push(n);else{let l=i[n.name];l.location==n.location&&l.name!=n.name&&console.log("location must same!")}}}static parserVariables(e){let t=0,r=[];for(;t<e.length;){let i=e.indexOf("@group(",t);if(i<0)break;let a=e.indexOf(";",i);t=a;let s=e.substring(i,a),n=this.extract(s,"@group(",")"),l=this.extract(s,"@binding(",")"),h="",u="var";s.indexOf("var<")!=-1?(h=this.extract(s,">",":"),u=this.extract(s,"var<",">").replace(",","-").replaceAll(" ","")):h=this.extract(s,"var",":");let f=s.substring(s.lastIndexOf(":")+1).trim(),g={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};g.group=Number.parseInt(n),g.binding=Number.parseInt(l),g.varType=u,g.varName=h,g.dataType=f,g.dataIsBuiltinType=this.isBuiltinTypes(g.dataType),g.dataIsBuiltinType||(g.dataFields=this.parserStructFields(e,g.dataType)),r.push(g)}return r}static extract(e,t,r){let i=e.indexOf(t)+t.length,a=e.indexOf(r,i);return e.substring(i,a).trim()}static isBuiltinTypes(e){switch(e){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let t=e.indexOf("<");if(t!=-1)switch(e.substring(0,t)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(e.substring(t+1,e.lastIndexOf(">")))}break}return!1}static parserStructFields(e,t){let r=[],i=0;for(;i<e.length;){let a=e.indexOf("struct ",i);if(a<0)break;let s=e.indexOf("{",a);if(i=s,e.substring(a+6,s).trim()===t){a=e.indexOf("{",a),s=e.indexOf("}",a);let h=e.substring(a+1,s).split(",");for(let u of h){let f=u.indexOf(":");if(f!=-1){let g={name:u.substring(0,f).trim(),type:u.substring(f+1).trim()};r.push(g)}}break}}return r}static parserVertexOld(e){let t=[],i=e.split("fn main(")[1].split("->")[0],a=i.split("@");if(a&&a.length>1)for(let n=1;n<a.length;n++){let h=a[n].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,t)}else{var s=i.split(":")[1];s=s.replaceAll("  ",""),s=s.replaceAll(" ",""),s=s.replaceAll(")",""),s=e.split(`struct ${s}`)[1];let l=s.indexOf("{"),h=s.indexOf("}");s=s.slice(l,h),a=s.split("@");for(let u=1;u<a.length;u++){let g=a[u].replace(/\s*$/g,"");g=g.replaceAll(`
`,""),g=g.split(",")[0],g=g.replaceAll("  "," "),this.parserAttribute(g,t)}}return t}static parserVertex(e,t){let r=[],a=t.split(`fn ${e}(`)[1].split("->")[0],s=a.split("@");if(s&&s.length>1)for(let l=1;l<s.length;l++){let u=s[l].replace(/\s*$/g,"");u=u.replaceAll(",",""),u=u.replaceAll(`
`,""),u=u.replaceAll("  "," "),this.parserAttribute(u,r)}else{var n=a.split(":")[1];n=n.replaceAll("  ",""),n=n.replaceAll(" ",""),n=n.replaceAll(")",""),n=t.split(`struct ${n}`)[1];let h=n.indexOf("{"),u=n.indexOf("}");n=n.slice(h,u),s=n.split("@");for(let f=1;f<s.length;f++){let p=s[f].replace(/\s*$/g,"");p=p.replaceAll(`
`,""),p=p.split(",")[0],p=p.replaceAll("  "," "),this.parserAttribute(p,r)}}return r}static parserAttribute(e,t){let r={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(e.indexOf("builtin")!=-1){r.type="builtin";var i=e.match(/\((.+?)\)/g)[0];i=e.match(/\((.+?)\)/g)[0],i=i.replace("(",""),i=i.replaceAll(")",""),r.location=parseInt(i);let a=e.split(":");r.name=a[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=a[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=fr[r.valueType],t.push(r)}else if(e.indexOf("location")!=-1){r.type="location";var i=e.match(/\((.+?)\)/g)[0];i=e.match(/\((.+?)\)/g)[0],i=i.replace("(",""),i=i.replaceAll(")",""),r.location=parseInt(i);let s=e.split(":");r.name=s[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=s[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=fr[r.valueType],t.push(r)}r.format=No[fr[r.valueType]]}}class ie extends Xa{entryPoint="CsMain";workerSizeX=1;workerSizeY=0;workerSizeZ=0;_computePipeline;_csShaderModule;_destCS;_sourceCS;_storageTextureDic;_sampleTextureDic;_groupsShaderReflectionVarInfos;_groupCache={};constructor(e){super(),this._sourceCS=e,He.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,t){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,t)}setSamplerTexture(e,t){this._sampleTextureDic.set(e,t)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let t=0;t<this.bindGroups.length;++t)e.setBindGroup(t,this.bindGroups[t]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,t,r,i){let a=this._bufferDic.get(t);if(a){let s={binding:r,resource:{buffer:a.buffer,offset:0,size:a.memory.shareDataBuffer.byteLength}};i.push(s)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${t} is missing!`)}noticeBufferChange(e){let t=this._groupCache[e];t&&this.genGroups(t.groupIndex,t.infos,!0)}genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const i=t[e];let a=[];for(let n=0;n<i.length;++n){const l=i[n];if(l)switch(l.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,l.varName,l.binding,a),this._groupCache[l.varName]={groupIndex:e,infos:t};break;case"var":if(l.dataType=="sampler"){let h=l.varName.replace("Sampler",""),u=this._sampleTextureDic.get(h);if(u){let f={binding:l.binding,resource:u.gpuSampler};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${l.varName} is missing! `)}else if(l.dataType=="sampler_comparison"){let h=l.varName.replace("Sampler",""),u=this._sampleTextureDic.get(h);if(u){let f={binding:l.binding,resource:u.gpuSampler_comparison};a.push(f)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${l.varName} is missing! `)}else if(l.dataType.indexOf("texture_storage")!=-1){let h=this._storageTextureDic.get(l.varName);if(h){let u={binding:l.binding,resource:h.getGPUView()};a.push(u),te.getInstance().attached(h,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${l.varName} is missing! `)}else if(l.dataType.indexOf("texture")!=-1){let h=this._sampleTextureDic.get(l.varName);if(h){let u={binding:l.binding,resource:h.getGPUView()};a.push(u),te.getInstance().attached(h,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${l.varName} is missing! `)}break;default:console.error("unprocessed type:",l.varType);break}}let s=I.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:a});this.bindGroups[e]=s}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=I.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let t=0;t<e.groups.length;++t){let r=e.groups[t];this._groupsShaderReflectionVarInfos[t]=r,this.genGroups(t,this._groupsShaderReflectionVarInfos)}I.addEventListener(yr.RESIZE,t=>{for(let r=0;r<e.groups.length;++r){let i=e.groups[r];this._groupsShaderReflectionVarInfos[r]=i,this.genGroups(r,this._groupsShaderReflectionVarInfos,!0)}},this)}preCompileShader(e){for(const t in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,t)){const r=this.constValues[t];e=e.replaceAll(`&${t}`,r.toString())}this._destCS=Tt.parseComputeShader(e,this.defineValue)}compileShader(){let e=I.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(t=>{t.messages.length>0&&console.log(this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=He.genComputeShaderVariant(this);let e=He.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(He.getShaderReflection2(this._destCS,this),He.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}class vt{static profilerLabelMap=new Map;static start(e){let t=this.profilerLabelMap.get(e);t||(t={lable:e,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(e,t)),t.start=performance.now(),t.end=performance.now(),t.count=0,t.child.clear()}static end(e){let t=this.profilerLabelMap.get(e);t&&(t.end=performance.now(),t.total=t.end-t.start)}static countStart(e,t=""){let r=this.profilerLabelMap.get(e);if(r&&(r.count++,t!="")){let i=r.child.get(t);i||(i={lable:t,start:0,end:0,total:0,count:0}),i.start=performance.now(),i.end=performance.now(),i.count=0,r.child.set(t,i)}}static countEnd(e,t){let r=this.profilerLabelMap.get(e);if(r&&t!=""){let i=r.child.get(t);i||(i={lable:t,start:0,end:0,total:0,count:0}),i.end=performance.now(),i.total=i.end-i.start,i.count++}}static print(e){let t=this.profilerLabelMap.get(e);t&&console.log("performance",e,t.total+" ms")}}const vf=`var Module=typeof Module!="undefined"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require("fs");var nodePath=require("path");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:"utf8",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module["thisProgram"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,"/")}arguments_=process.argv.slice(2);if(typeof module!="undefined"){module["exports"]=Module}process.on("uncaughtException",(ex=>{if(ex!=="unwind"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module["inspect"]=()=>"[Emscripten Module object]"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=HEAP16=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=HEAPU16=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=HEAPF32=new Float32Array(b);Module["HEAPF64"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{if(!response["ok"]){throw"failed to load wasm binary file at '"+binaryFile+"'"}return response["arrayBuffer"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err("failed to asynchronously prepare wasm: "+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(binaryFile,{credentials:"same-origin"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["f"];updateMemoryViews();wasmTable=Module["asm"]["h"];addOnInit(Module["asm"]["g"]);removeRunDependency("wasm-instantiate");return exports}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name="ExitStatus";this.message=\`Program terminated with exit(\${status})\`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort("")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):"";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module["asm"]["g"]).apply(null,arguments)};var _allocation=Module["_allocation"]=function(){return(_allocation=Module["_allocation"]=Module["asm"]["i"]).apply(null,arguments)};var _getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=function(){return(_getMatrixBufferPtr=Module["_getMatrixBufferPtr"]=Module["asm"]["j"]).apply(null,arguments)};var _getSRTPtr=Module["_getSRTPtr"]=function(){return(_getSRTPtr=Module["_getSRTPtr"]=Module["asm"]["k"]).apply(null,arguments)};var _getInfoPtr=Module["_getInfoPtr"]=function(){return(_getInfoPtr=Module["_getInfoPtr"]=Module["asm"]["l"]).apply(null,arguments)};var _getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=function(){return(_getContinuedSRTPtr=Module["_getContinuedSRTPtr"]=Module["asm"]["m"]).apply(null,arguments)};var _printMatrix=Module["_printMatrix"]=function(){return(_printMatrix=Module["_printMatrix"]=Module["asm"]["n"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=function(){return(_updateAllMatrixContinueTransform=Module["_updateAllMatrixContinueTransform"]=Module["asm"]["o"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["p"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module["asm"]["__errno_location"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module["asm"]["q"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module["asm"]["r"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();

if (!Module['ENVIRONMENT_IS_PTHREAD']) {
    // console.log("is main");
    window['wasmMatrix'] = Module;
}
        `;class ${static matrixBuffer;static matrixSRTBuffer;static matrixContinuedSRTBuffer;static matrixStateBuffer;static matrixBufferPtr;static matrixSRTBufferPtr;static matrixContinuedSRTBufferPtr;static matrixStateBufferPtr;static wasm;static stateStruct=4;static async init(e){await new Promise(t=>{const r=document.createElement("script");r.async=!0,r.type="text/javascript",r.src=URL.createObjectURL(new Blob([vf])),document.head.appendChild(r),r.onload=()=>{let i=()=>{this.wasm=window.wasmMatrix,this.wasm&&this.wasm.calledRun?t(!0):setTimeout(i,20)};i()}}),this.allocMatrix(e)}static allocMatrix(e){e>R.maxCount&&console.error(`The maximum allocation size is exceeded! current:${e}, limit:${R.maxCount}`),this.wasm._allocation(e),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.matrixBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*e),this.matrixSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*e),this.matrixContinuedSRTBuffer=new Float32Array(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*e),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,$.stateStruct*e),R.allocMatrix(e)}static updateAllContinueTransform(e,t,r){this.wasm._updateAllMatrixContinueTransform(e,t,r)}static setParent(e,t,r){this.matrixStateBuffer[e*$.stateStruct+2]=t>=0?t:-1,this.matrixStateBuffer[e*$.stateStruct+3]=r}static setTranslate(e,t,r,i){this.matrixSRTBuffer[e*9+6]=t,this.matrixSRTBuffer[e*9+7]=r,this.matrixSRTBuffer[e*9+8]=i}static setRotation(e,t,r,i){this.matrixSRTBuffer[e*9+3]=t%360,this.matrixSRTBuffer[e*9+4]=r%360,this.matrixSRTBuffer[e*9+5]=i%360}static setScale(e,t,r,i){this.matrixSRTBuffer[e*9+0]=t,this.matrixSRTBuffer[e*9+1]=r,this.matrixSRTBuffer[e*9+2]=i}static setContinueTranslate(e,t,r,i){(t!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[e*9+6]=t,this.matrixContinuedSRTBuffer[e*9+7]=r,this.matrixContinuedSRTBuffer[e*9+8]=i,this.matrixStateBuffer[e*$.stateStruct+1]=1)}static setContinueRotation(e,t,r,i){(t!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[e*9+3]=t,this.matrixContinuedSRTBuffer[e*9+4]=r,this.matrixContinuedSRTBuffer[e*9+5]=i,this.matrixStateBuffer[e*$.stateStruct+1]=1)}static setContinueScale(e,t,r,i){(t!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[e*9+0]=t,this.matrixContinuedSRTBuffer[e*9+1]=r,this.matrixContinuedSRTBuffer[e*9+2]=i,this.matrixStateBuffer[e*$.stateStruct+1]=1)}}class qt{static AXIS_ANGLE="axisAngle";static EULER_ANGLES="eulerAngles";static QUATERNION="quaternion"}class Y{static HELP_0=new Y(0,0,0,1);static HELP_1=new Y(0,0,0,1);static HELP_2=new Y(0,0,0,1);static _zero=new Y(0,0,0,1);static CALCULATION_QUATERNION=new Y;x=0;y=0;z=0;w=1;constructor(e=0,t=0,r=0,i=1){this.x=e,this.y=t,this.z=r,this.w=i}static identity(){return Y._zero}static quaternionToMatrix(e,t){let r=e.x*2,i=e.y*2,a=e.z*2,s=e.x*r,n=e.y*i,l=e.z*a,h=e.x*i,u=e.x*a,f=e.y*a,g=e.w*r,p=e.w*i,A=e.w*a;t.rawData[0]=1-(n+l),t.rawData[1]=h+A,t.rawData[2]=u-p,t.rawData[3]=0,t.rawData[4]=h-A,t.rawData[5]=1-(s+l),t.rawData[6]=f+g,t.rawData[7]=0,t.rawData[8]=u+p,t.rawData[9]=f-g,t.rawData[10]=1-(s+n),t.rawData[11]=0,t.rawData[12]=0,t.rawData[13]=0,t.rawData[14]=0,t.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(e=0,t=0,r=0,i=1){this.x=e,this.y=t,this.z=r,this.w=i}divide(e){return e instanceof Y?new Y(this.x/e.x,this.y/e.y,this.z/e.z):(this.x=this.x/e,this.y=this.y/e,this.z=this.z/e,this)}setFromArray(e){return this.x=e[0],this.y=e[1],this.z=e[2],this.w=e[3],this}multiply(e,t){var r=e.w,i=e.x,a=e.y,s=e.z,n=t.w,l=t.x,h=t.y,u=t.z;this.w=r*n-i*l-a*h-s*u,this.x=r*l+i*n+a*u-s*h,this.y=r*h-i*u+a*n+s*l,this.z=r*u+i*h-a*l+s*n}multiplyVector(e,t=null){t||=new Y;var r=e.x,i=e.y,a=e.z;return t.w=-this.x*r-this.y*i-this.z*a,t.x=this.w*r+this.y*a-this.z*i,t.y=this.w*i-this.x*a+this.z*r,t.z=this.w*a+this.x*i-this.y*r,t}fromAxisAngle(e,t){t*=Math.PI/180;var r=t*.5,i=Math.sin(r);this.w=Math.cos(r),this.x=e.x*i,this.y=e.y*i,this.z=e.z*i,this.normalize()}toAxisAngle(e){var t=this.x*this.x+this.y*this.y+this.z*this.z,r=0;return t>0?(r=2*Math.acos(this.w),t=1/Math.sqrt(t),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t):(r=0,e.x=1,e.y=0,e.z=0),r}slerp(e,t,r){var i=e.w,a=e.x,s=e.y,n=e.z,l=t.w,h=t.x,u=t.y,f=t.z,g=i*l+a*h+s*u+n*f;if(g<0&&(g=-g,l=-l,h=-h,u=-u,f=-f),g<.95){var p=Math.acos(g),A=1/Math.sin(p),v=Math.sin(p*(1-r))*A,C=Math.sin(p*r)*A;this.w=i*v+l*C,this.x=a*v+h*C,this.y=s*v+u*C,this.z=n*v+f*C}else{this.w=i+r*(l-i),this.x=a+r*(h-a),this.y=s+r*(u-s),this.z=n+r*(f-n);var x=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=x,this.x*=x,this.y*=x,this.z*=x}}lerp(e,t,r){var i=e.w,a=e.x,s=e.y,n=e.z,l=t.w,h=t.x,u=t.y,f=t.z,g;i*l+a*h+s*u+n*f<0&&(l=-l,h=-h,u=-u,f=-f),this.w=i+r*(l-i),this.x=a+r*(h-a),this.y=s+r*(u-s),this.z=n+r*(f-n),g=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=g,this.x*=g,this.y*=g,this.z*=g}fromEulerAngles(e,t,r){e*=ge,t*=ge,r*=ge;var i=e*.5,a=t*.5,s=r*.5,n=Math.cos(i),l=Math.sin(i),h=Math.cos(a),u=Math.sin(a),f=Math.cos(s),g=Math.sin(s);return this.w=n*h*f+l*u*g,this.x=l*h*f-n*u*g,this.y=n*u*f+l*h*g,this.z=n*h*g-l*u*f,this}setFromRotationMatrix(e){const t=e.rawData,r=t[0],i=t[4],a=t[8],s=t[1],n=t[5],l=t[9],h=t[2],u=t[6],f=t[10],g=r+n+f;if(g>0){const p=.5/Math.sqrt(g+1);this.w=.25/p,this.x=(u-l)*p,this.y=(a-h)*p,this.z=(s-i)*p}else if(r>n&&r>f){const p=2*Math.sqrt(1+r-n-f);this.w=(u-l)/p,this.x=.25*p,this.y=(i+s)/p,this.z=(a+h)/p}else if(n>f){const p=2*Math.sqrt(1+n-r-f);this.w=(a-h)/p,this.x=(i+s)/p,this.y=.25*p,this.z=(l+u)/p}else{const p=2*Math.sqrt(1+f-r-n);this.w=(s-i)/p,this.x=(a+h)/p,this.y=(l+u)/p,this.z=.25*p}return this}getEulerAngles(e){var t,r,i,a,s,n,l,h;return e||=new d,a=this.x,s=this.y,n=this.z,l=this.w,h=2*(l*s-a*n),h<=-.99999?(t=2*Math.atan2(a,l),r=-Math.PI/2,i=0):h>=.99999?(t=2*Math.atan2(a,l),r=Math.PI/2,i=0):(t=Math.atan2(2*(l*a+s*n),1-2*(a*a+s*s)),r=Math.asin(h),i=Math.atan2(2*(l*n+a*s),1-2*(s*s+n*n))),e.set(t,r,i).scaleBy(Gr)}normalize(e=1){var t=e/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=t,this.y*=t,this.z*=t,this.w*=t}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(e){var t=e.decompose(qt.QUATERNION)[1];this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w}inverse(e=null){e||=new Y;var t=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(t>0){var r=1/t;e.w=this.w*r,e.x=-this.x*r,e.y=-this.y*r,e.z=-this.z*r}return e}clone(){return new Y(this.x,this.y,this.z,this.w)}transformVector(e,t=null){var r,i,a,s,n=e.x,l=e.y,h=e.z;return t||=new d,s=-this.x*n-this.y*l-this.z*h,r=this.w*n+this.y*h-this.z*l,i=this.w*l-this.x*h+this.z*n,a=this.w*h+this.x*l-this.y*n,t.x=-s*this.x+r*this.w-i*this.z+a*this.y,t.y=-s*this.y+r*this.z+i*this.w-a*this.x,t.z=-s*this.z-r*this.y+i*this.x+a*this.w,t}copyFrom(e){var t=this;return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,this}mul(e,t,r){let i=r||new Y;return i.x=e.w*t.x+e.x*t.w+e.y*t.z-e.z*t.y,i.y=e.w*t.y+e.y*t.w+e.z*t.x-e.x*t.z,i.z=e.w*t.z+e.z*t.w+e.x*t.y-e.y*t.x,i.w=e.w*t.w-e.x*t.x-e.y*t.y-e.z*t.z,i}clampf(e,t,r){if(t>r){var i=t;t=r,r=i}return e<t?t:e<r?e:r}static serialize(e){return new Y(e.x,e.y,e.z,e.w)}}function _f(o,e,t){let r=o.x*2,i=o.y*2,a=o.z*2,s=o.x*r,n=o.y*i,l=o.z*a,h=o.x*i,u=o.x*a,f=o.y*a,g=o.w*r,p=o.w*i,A=o.w*a,v=t||new d;return v.x=(1-(n+l))*e.x+(h-A)*e.y+(u+p)*e.z,v.y=(h+A)*e.x+(1-(s+l))*e.y+(f-g)*e.z,v.z=(u-p)*e.x+(f+g)*e.y+(1-(s+n))*e.z,v}class oi{_x=0;_y=0;_z=0;_w=0;constructor(e=0){this.seed=e}get seed(){return this._x}set seed(e){this._x=e,this._y=this._x*1812433253+1,this._z=this._y*1812433253+1,this._w=this._z*1812433253+1}static getFloatFromInt(e){return Math.floor((e&8388607)*(1/8388607))}static getByteFromInt(e){return e>>15}clone(){let e=new oi;return e._x=this._x,e._y=this._y,e._z=this._z,e._w=this._w,e}get(){let e=this._x^this._x<<11;return this._x=this._y,this._y=this._z,this._z=this._w,this._w=this._w^this._w>>19^(e^e>>8)}getFloat(){return Fn(this.get())}getSignedFloat(){return this.getFloat()*2-1}}let Gr=180/Math.PI,ge=Math.PI/180,xf=2147483647,Cf=-2147483647;function j(o,e,t){return Math.max(e,Math.min(t,o))}class Ye{static gaussFunction(e,t,r,i){let a=Math.pow(e-r,2),s=2*Math.pow(i,2),n=-1*(a/s),l=Math.pow(Math.E,n);return Math.round(l*t)}static computeGaussian(e,t){return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(e*e)/(2*t*t))}static gaussCoef(e){e<.5&&(e=.5);let t=Math.exp(.726*.726)/e,r=Math.exp(-t),i=Math.exp(-2*t),a=(1-r)*(1-r)/(1+2*t*r-i),s=a,n=a*(t-1)*r,l=a*(t+1)*r,h=-a*i,u=2*r,f=-i,g=(s+n)/(1-u-f),p=(l+h)/(1-u-f);return new Float32Array([s,n,l,h,u,f,g,p])}static clampf(e,t,r){if(t>r){let i=t;t=r,r=i}return e<t?t:e<r?e:r}static normalizeAngle(e){for(;e>180;)e-=360;for(;e<-180;)e+=360;return e}static fract(e){return e-Math.floor(e)}static getRandDirXZ(e){let t=e*Math.random(),r=360*Math.random()*ge,i=Math.cos(r)*t,a=Math.sin(r)*t;return{x:i,z:a}}static getRandDirXYZ(e){let t=e*Math.random(),r=360*Math.random()*ge,i=Math.cos(r)*t,a=Math.tan(r)*t,s=Math.sin(r)*t;return new d(i,a,s)}static getCycleXYZ(e){let t=e*Math.random(),r=360*Math.random()*ge,i=Math.cos(r)*t,a=e*Math.random()-e*.5,s=Math.sin(r)*t;return new d(i,a,s)}static angle(e,t){let r=V.HELP_0,i=V.HELP_1;return r.set(e.x,e.z),i.set(t.x,t.z),Math.acos((r.x*i.x+r.y*i.y)/(r.abs()*i.abs()))}static angle_360(e,t){let r=d.HELP_0;return e.crossProduct(t,r),r.z>0?Ye.angle(e,t):360-Ye.angle(e,t)}getRotationY(e){return Ye.normalizeAngle(Math.atan2(e.z,e.x)*Gr)}static fromToRotation(e,t,r=null){r||=new Y;let i=R.help_matrix_2;return R.fromToRotation(e,t,i),r.fromMatrix(i),r}static getEularDir_yUp(e){let t=Y.HELP_0;return t.fromEulerAngles(0,e,0),t.transformVector(d.Z_AXIS,d.HELP_5),d.HELP_5}static transformVector(e,t,r=null){r||=new d;let i=e.rawData,a=i[0],s=i[1],n=i[2],l=i[3],h=i[4],u=i[5],f=i[6],g=i[7],p=i[8],A=i[9],v=i[10],C=i[11],x=i[12],S=i[13],y=i[14],b=i[15],D=t.x,B=t.y,T=t.z;return r.x=a*D+h*B+p*T+x,r.y=s*D+u*B+A*T+S,r.z=n*D+f*B+v*T+y,r.w=l*D+g*B+C*T+b,r}}let wr=function(o,e,t){return o*(1-t)+e*t};function Sf(o,e,t){let r=new d,i=o.x,a=o.y,s=o.z,n=o.w,l=e.x,h=e.y,u=e.z,f=e.w;return r.x=(l-i)*t+i,r.y=(h-a)*t+a,r.z=(u-s)*t+s,r.w=(f-n)*t+n,r}function yf(o,e,t){let r=new P;return r.r=(1-t)*o.r+t*e.r,r.g=(1-t)*o.g+t*e.g,r.b=(1-t)*o.b+t*e.b,r.a=(1-t)*o.a+t*e.a,r}function wf(o,e,t){return o+((e-o)*t>>8)&255}let Za=function(o,e,t){let r=t-e;return Math.floor(o/r)%2==0?o%r+e:t-o%r+e},$a=function(o,e,t){let r=t-e;return o%r+e},If=function(o,e){let t=0;for(let r in o)r==e&&t++;return t};class bf{x=0;y=0;z=0;w=0;randSeedList;constructor(){this.randSeedList=[]}reset(){this.x=Math.random()*1,this.y=Math.random()*1,this.z=Math.random()*1,this.w=Math.random()*1,this.randSeedList.length=0;for(let e=0;e<20;e++)this.randSeedList.push(Math.random()*1)}}function Xe(o,e){return o instanceof d&&e instanceof d||o instanceof Y&&e instanceof Y?o.x*e.x+o.y*e.y+o.z*e.z:o.x*e.x+o.y*e.y}function es(o,e){return new d(o.x*e.x,o.y*e.y,o.z*e.z)}function Ln(o){return Math.sqrt(o)}function ts(o){return Ln(Xe(o,o))}function On(o,e){if(ts(o)>d.EPSILON)return o.divide(ts(o));if(o instanceof V)return new V;if(o instanceof d)return new d;if(o instanceof Y)return new Y}function Fn(o){return(o&8388607)*(1/8388607)}function Qr(o){return o.getFloat()}function ze(o,e,t){let r=o.getFloat();return r=e*r+(1-r)*t,r}function Bf(o,e,t){let r;if(e<t){r=t-e;let i=o.get()%r;return i+=e,i}else if(e>t){r=e-t;let i=o.get()%r;return i=e-i,i}else return e}function ia(o){let e=ze(o,-1,1),t=ze(o,0,2*Math.PI),r=Math.sqrt(1-e*e),i=r*Math.cos(t),a=r*Math.sin(t);return new d(i,a,e)}function Nn(o){let e=ze(o,0,2*Math.PI),t=Math.cos(e),r=Math.sin(e);return new V(t,r)}function Ef(o){let e=new Y;return e.x=ze(o,-1,1),e.y=ze(o,-1,1),e.z=ze(o,-1,1),e.w=ze(o,-1,1),e=On(e),Xe(e,Y.identity())<0?-e:e}function Tf(o){const e=2*Math.PI;let t=ze(o,0,1),r=ze(o,0,e),i=ze(o,0,e),a=Math.sqrt(1-t),s=Math.sqrt(t),n=new Y(a*Math.sin(r),a*Math.cos(r),s*Math.sin(i),s*Math.cos(i));return Xe(n,Y.identity())<0?-n:n}function Df(o,e){return new d(ze(o,-e.x,e.x),ze(o,-e.y,e.y),ze(o,-e.z,e.z))}function zn(o){let e=ia(o);return e.scaleBy(Math.pow(Qr(o),1/3)),e}function Pf(o,e){return es(zn(o),e)}function Mf(o,e,t){let r=ia(o),i=Math.pow(ze(o,0,1),1/3);return r.scaleBy(e+(t-e)*i),r}function Rf(o){let e=Nn(o);return e.multiply(Math.pow(ze(o,0,1),1/2),e),e}function Uf(o,e,t){let r=es(ia(o),e),i=Math.pow(ze(o,t,1),1/3);return r.scaleBy(i),r}function Lf(o){let e=o.getFloat(),t=o.getFloat();e+t>1&&(e=1-e,t=1-t);let r=1-e-t;return new d(e,t,r)}function Of(o){return o/360*2*Math.PI}function Ff(o){return 180*o/Math.PI}function Nf(o){return Math.sin(o)}function zf(o){return Math.cos(o)}c.randomSeed=4919;function kf(){return++c.randomSeed}function Gf(o,e,t){let r=o[e],i=o[t];o[e]=i,o[t]=r}function kn(o){return Math.floor(o)}function rs(o){return kn(o+.5)}function Qf(o){return o=Math.max(o,0),o=Math.min(o,1),rs(o*65535)}function Vf(o){return o=Math.max(o,0),o=Math.min(o,1),rs(o*255)}function Gn(o){return Math.abs(o)==0?o:1/Math.sqrt(o)}function Hf(o){let e=is(o);return o.scaleBy(Gn(e))}function Yf(o,e){return o.crossProduct(e)}function is(o){return Xe(o,o)}function Xf(o){let e=new oi(o);return Qr(e)}function jf(o,e){let t=new oi(e);o.x=Qr(t),o.y=Qr(t),o.z=Qr(t)}function Wf(o,e,t){return o<e?t:o>t?e:o}function as(o,e){return o-Math.floor(o/e)*e}const qf=1e-6;class R{static blockBytes=16*4;static block=16;static allocCount=1e3;static allocOnceCount=1e3;static maxCount=50*1e4;static useCount=0;static buffer;static wasmMatrixPtr=0;static dynamicMatrixBytes;static dynamicGlobalMatrixRef;static wasm;static help_matrix_0;static help_matrix_1;static help_matrix_2;static helpMatrix;static helpMatrix2;static _getEulerMatrix;static _zero=new d(0,0,0);static _one=new d(1,1,1);static _prs=[new d,new d,new d];index=0;offset=0;rawData;_position;static allocMatrix(e){this.allocCount=e,R.dynamicMatrixBytes=$.matrixBuffer,R.buffer=R.dynamicMatrixBytes.buffer,R.wasmMatrixPtr=$.matrixBufferPtr,this.dynamicGlobalMatrixRef||=[],this.dynamicGlobalMatrixRef.forEach(t=>{t.offset=R.wasmMatrixPtr+t.index*R.blockBytes,t.rawData=new Float32Array(R.dynamicMatrixBytes.buffer,t.offset,16)}),R.help_matrix_0||=new R,R.help_matrix_1||=new R,R.help_matrix_2||=new R,R.helpMatrix||=new R,R.helpMatrix2||=new R,R._getEulerMatrix||=new R,R._getEulerMatrix.identity()}static fromToRotation(e,t,r){return r||=new R,r.transformDir(e,t),r}static getAxisRotation(e,t,r,i){let a=new R,s=i*(Math.PI/180),n=Math.cos(s),l=Math.sin(s),h=1-n,u,f;return a.rawData[0]=n+e*e*h,a.rawData[5]=n+t*t*h,a.rawData[10]=n+r*r*h,u=e*t*h,f=r*l,a.rawData[1]=u+f,a.rawData[4]=u-f,u=e*r*h,f=t*l,a.rawData[8]=u+f,a.rawData[2]=u-f,u=t*r*h,f=e*l,a.rawData[9]=u-f,a.rawData[6]=u+f,a}static sanitizeEuler(e){R.makePositive(e)}static makePositive(e){let t=-1e-4,r=Math.PI*2-1e-4;e.x<t?e.x+=2*Math.PI:e.x>r&&(e.x-=2*Math.PI),e.y<t?e.y+=2*Math.PI:e.y>r&&(e.y-=2*Math.PI),e.z<t?e.z+=2*Math.PI:e.z>r&&(e.z-=2*Math.PI)}static matrixToEuler(e,t){return e.get(1,2)<.999?e.get(1,2)>-.999?(t.x=Math.asin(-e.get(1,2)),t.y=Math.atan2(e.get(0,2),e.get(2,2)),t.z=Math.atan2(e.get(1,0),e.get(1,1)),R.sanitizeEuler(t),!0):(t.x=Math.PI*.5,t.y=Math.atan2(e.get(0,1),e.get(0,0)),t.z=0,R.sanitizeEuler(t),!1):(t.x=-Math.PI*.5,t.y=Math.atan2(-e.get(0,1),e.get(0,0)),t.z=0,R.sanitizeEuler(t),!1)}static matrixMultiply(e,t,r){R.wasm.Matrix_Multiply(e.index,t.index,r.index)}static matrixAppend(e,t,r){R.wasm.Matrix_Append(e.index,t.index,r.index)}static matrixRotateY(e,t){R.wasm.Matrix_Append(e,t.index)}static matrixRotate(e,t,r){R.wasm.Matrix_Rotate(e,t,r.index)}constructor(e=!1){if(R.useCount>=R.allocCount){let t=R.allocCount+R.allocOnceCount;$.allocMatrix(t)}this.index=R.useCount,this.offset=R.wasmMatrixPtr+this.index*R.blockBytes,R.dynamicGlobalMatrixRef[this.index]=this,R.useCount++,this.rawData=new Float32Array(R.dynamicMatrixBytes.buffer,this.offset,16),this._position=new d,this.identity()}lookAt(e,t,r=d.Y_AXIS){let i=this.rawData,a=t.subtract(e,d.HELP_0);a.length<1e-4&&(a.z=1),a.normalize();let s=r.crossProduct(a,d.HELP_1);s.length<1e-4&&(Math.abs(r.z)>.9999?a.x+=1e-4:a.z+=1e-4,a.normalize()),s=r.crossProduct(a,s).normalize();let n=a.crossProduct(s,d.HELP_2).normalize();i[0]=s.x,i[1]=n.x,i[2]=a.x,i[3]=0,i[4]=s.y,i[5]=n.y,i[6]=a.y,i[7]=0,i[8]=s.z,i[9]=n.z,i[10]=a.z,i[11]=0,i[12]=-s.dotProduct(e),i[13]=-n.dotProduct(e),i[14]=-a.dotProduct(e),i[15]=1}static float32Array=new Float32Array(16).fill(0);multiply(e){let t=this.rawData,r=e.rawData,i=R.float32Array;i[0]=t[0]*r[0]+t[1]*r[4]+t[2]*r[8]+t[3]*r[12],i[1]=t[0]*r[1]+t[1]*r[5]+t[2]*r[9]+t[3]*r[13],i[2]=t[0]*r[2]+t[1]*r[6]+t[2]*r[10]+t[3]*r[14],i[3]=t[0]*r[3]+t[1]*r[7]+t[2]*r[11]+t[3]*r[15],i[4]=t[4]*r[0]+t[5]*r[4]+t[6]*r[8]+t[7]*r[12],i[5]=t[4]*r[1]+t[5]*r[5]+t[6]*r[9]+t[7]*r[13],i[6]=t[4]*r[2]+t[5]*r[6]+t[6]*r[10]+t[7]*r[14],i[7]=t[4]*r[3]+t[5]*r[7]+t[6]*r[11]+t[7]*r[15],i[8]=t[8]*r[0]+t[9]*r[4]+t[10]*r[8]+t[11]*r[12],i[9]=t[8]*r[1]+t[9]*r[5]+t[10]*r[9]+t[11]*r[13],i[10]=t[8]*r[2]+t[9]*r[6]+t[10]*r[10]+t[11]*r[14],i[11]=t[8]*r[3]+t[9]*r[7]+t[10]*r[11]+t[11]*r[15],i[12]=t[12]*r[0]+t[13]*r[4]+t[14]*r[8]+t[15]*r[12],i[13]=t[12]*r[1]+t[13]*r[5]+t[14]*r[9]+t[15]*r[13],i[14]=t[12]*r[2]+t[13]*r[6]+t[14]*r[10]+t[15]*r[14],i[15]=t[12]*r[3]+t[13]*r[7]+t[14]*r[11]+t[15]*r[15],t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15]}multiplyMatrices(e,t){const r=e.rawData,i=t.rawData,a=this.rawData,s=r[0],n=r[4],l=r[8],h=r[12],u=r[1],f=r[5],g=r[9],p=r[13],A=r[2],v=r[6],C=r[10],x=r[14],S=r[3],y=r[7],b=r[11],D=r[15],B=i[0],T=i[4],U=i[8],E=i[12],N=i[1],Q=i[5],H=i[9],q=i[13],re=i[2],pe=i[6],le=i[10],be=i[14],Fe=i[3],se=i[7],Re=i[11],he=i[15];return a[0]=s*B+n*N+l*re+h*Fe,a[4]=s*T+n*Q+l*pe+h*se,a[8]=s*U+n*H+l*le+h*Re,a[12]=s*E+n*q+l*be+h*he,a[1]=u*B+f*N+g*re+p*Fe,a[5]=u*T+f*Q+g*pe+p*se,a[9]=u*U+f*H+g*le+p*Re,a[13]=u*E+f*q+g*be+p*he,a[2]=A*B+v*N+C*re+x*Fe,a[6]=A*T+v*Q+C*pe+x*se,a[10]=A*U+v*H+C*le+x*Re,a[14]=A*E+v*q+C*be+x*he,a[3]=S*B+y*N+b*re+D*Fe,a[7]=S*T+y*Q+b*pe+D*se,a[11]=S*U+y*H+b*le+D*Re,a[15]=S*E+y*q+b*be+D*he,this}multiplyPoint3(e,t){t||=new d;let r=this.rawData;return t.x=r[0]*e.x+r[4]*e.y+r[8]*e.z+r[12],t.y=r[1]*e.x+r[5]*e.y+r[9]*e.z+r[13],t.z=r[2]*e.x+r[6]*e.y+r[10]*e.z+r[14],t}multiplyVector4(e,t){t||=new d;let r=this.rawData,i=e.x,a=e.y,s=e.z,n=r[3]*i+r[7]*a+r[11]*s+r[15];return n=n||1,t.x=(r[0]*i+r[4]*a+r[8]*s+r[12])/n,t.y=(r[1]*i+r[5]*a+r[9]*s+r[13])/n,t.z=(r[2]*i+r[6]*a+r[10]*s+r[14])/n,t.w=1,t}transformVector4(e,t){let r=this.rawData;t||=new d;let i=e.x,a=e.y,s=e.z,n=e.w;return t.x=i*r[0]+a*r[4]+s*r[8]+n*r[12],t.y=i*r[1]+a*r[5]+s*r[9]+n*r[13],t.z=i*r[2]+a*r[6]+s*r[10]+n*r[14],t.w=i*r[3]+a*r[7]+s*r[11]+n*r[15],t}perspectiveMultiplyPoint3(e,t){let r=d.HELP_2,i,a=this.rawData;if(r.x=a[0]*e.x+a[4]*e.y+a[8]*e.z+a[12],r.y=a[1]*e.x+a[5]*e.y+a[9]*e.z+a[13],r.z=a[2]*e.x+a[6]*e.y+a[10]*e.z+a[14],i=a[3]*e.x+a[7]*e.y+a[11]*e.z+a[15],Math.abs(i)>1e-7){let s=1/i;return t.x=r.x*s,t.y=r.y*s,t.z=r.z*s,!0}else return t.x=0,t.y=0,t.z=0,!1}perspective(e,t,r,i){let a=this.rawData,s=e*ge/2,n=Math.cos(s)/Math.sin(s);a[0]=-n/t,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=n,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=i/(i-r),a[11]=1,a[12]=0,a[13]=0,a[14]=-r*i/(i-r),a[15]=0}perspective3(e,t,r,i){var a=Math.tan(e*Math.PI/360)*r,s=a*t;this.frustum(-s,s,-a,a,r,i)}frustum(e,t,r,i,a,s){var n=this.rawData;n[0]=-2*a/(t-e),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2*a/(i-r),n[6]=0,n[7]=0,n[8]=(t+e)/(t-e),n[9]=(i+r)/(i-r),n[10]=s/(s-a),n[11]=1,n[12]=0,n[13]=0,n[14]=-s*a/(s-a),n[15]=0}ortho(e,t,r,i){let a=this.rawData;return a[0]=2/e,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/t,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(i-r),a[11]=0,a[12]=0,a[13]=0,a[14]=r/(r-i),a[15]=1,this}orthoZO(e,t,r,i,a,s){let n=this.rawData,l=1/(e-t),h=1/(r-i),u=1/(a-s);return n[0]=-2*l,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=-2*h,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=u,n[11]=0,n[12]=(e+t)*l,n[13]=(i+r)*h,n[14]=a*u,n[15]=1,this}orthoOffCenter(e,t,r,i,a,s){let n=this.rawData;n[0]=2/(t-e),n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=2/(i-r),n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1/(s-a),n[11]=0,n[12]=(e+t)/(e-t),n[13]=(i+r)/(r-i),n[14]=a/(a-s),n[15]=1}transformDir(e,t){let r=this.rawData,i=1e-6,a=d.ZERO;t.crossProduct(e,a);let s=t.dotProduct(e);if(s>1-i)this.identity();else{let n,l,h,u,f,g=a.dotProduct(a),p=(1-s)/g;n=p*a.x,l=p*a.z,h=n*a.y,u=n*a.z,f=l*a.y,r[0]=s+n*a.x,r[1]=h-a.z,r[2]=u+a.y,r[4]=h+a.z,r[5]=s+p*a.y*a.y,r[6]=f-a.x,r[8]=u-a.y,r[9]=f+a.x,r[10]=s+l*a.z,r[3]=0,r[7]=0,r[11]=0,r[15]=1}}append(e){let t=this.rawData,r=t[0],i=t[4],a=t[8],s=t[12],n=t[1],l=t[5],h=t[9],u=t[13],f=t[2],g=t[6],p=t[10],A=t[14],v=t[3],C=t[7],x=t[11],S=t[15];t[0]=r*e.rawData[0]+n*e.rawData[4]+f*e.rawData[8]+v*e.rawData[12],t[1]=r*e.rawData[1]+n*e.rawData[5]+f*e.rawData[9]+v*e.rawData[13],t[2]=r*e.rawData[2]+n*e.rawData[6]+f*e.rawData[10]+v*e.rawData[14],t[3]=r*e.rawData[3]+n*e.rawData[7]+f*e.rawData[11]+v*e.rawData[15],t[4]=i*e.rawData[0]+l*e.rawData[4]+g*e.rawData[8]+C*e.rawData[12],t[5]=i*e.rawData[1]+l*e.rawData[5]+g*e.rawData[9]+C*e.rawData[13],t[6]=i*e.rawData[2]+l*e.rawData[6]+g*e.rawData[10]+C*e.rawData[14],t[7]=i*e.rawData[3]+l*e.rawData[7]+g*e.rawData[11]+C*e.rawData[15],t[8]=a*e.rawData[0]+h*e.rawData[4]+p*e.rawData[8]+x*e.rawData[12],t[9]=a*e.rawData[1]+h*e.rawData[5]+p*e.rawData[9]+x*e.rawData[13],t[10]=a*e.rawData[2]+h*e.rawData[6]+p*e.rawData[10]+x*e.rawData[14],t[11]=a*e.rawData[3]+h*e.rawData[7]+p*e.rawData[11]+x*e.rawData[15],t[12]=s*e.rawData[0]+u*e.rawData[4]+A*e.rawData[8]+S*e.rawData[12],t[13]=s*e.rawData[1]+u*e.rawData[5]+A*e.rawData[9]+S*e.rawData[13],t[14]=s*e.rawData[2]+u*e.rawData[6]+A*e.rawData[10]+S*e.rawData[14],t[15]=s*e.rawData[3]+u*e.rawData[7]+A*e.rawData[11]+S*e.rawData[15]}add(e){let t=this.rawData,r=t[0],i=t[4],a=t[8],s=t[12],n=t[1],l=t[5],h=t[9],u=t[13],f=t[2],g=t[6],p=t[10],A=t[14],v=t[3],C=t[7],x=t[11],S=t[15],y=e.rawData[0],b=e.rawData[4],D=e.rawData[8],B=e.rawData[12],T=e.rawData[1],U=e.rawData[5],E=e.rawData[9],N=e.rawData[13],Q=e.rawData[2],H=e.rawData[6],q=e.rawData[10],re=e.rawData[14],pe=e.rawData[3],le=e.rawData[7],be=e.rawData[11],Fe=e.rawData[15];return t[0]=r+y,t[1]=n+T,t[2]=f+Q,t[3]=v+pe,t[4]=i+b,t[5]=l+U,t[6]=g+H,t[7]=C+le,t[8]=a+D,t[9]=h+E,t[10]=p+q,t[11]=x+be,t[12]=s+B,t[13]=u+N,t[14]=A+re,t[15]=S+Fe,this}sub(e){let t=this.rawData,r=t[0],i=t[4],a=t[8],s=t[12],n=t[1],l=t[5],h=t[9],u=t[13],f=t[2],g=t[6],p=t[10],A=t[14],v=t[3],C=t[7],x=t[11],S=t[15],y=e.rawData[0],b=e.rawData[4],D=e.rawData[8],B=e.rawData[12],T=e.rawData[1],U=e.rawData[5],E=e.rawData[9],N=e.rawData[13],Q=e.rawData[2],H=e.rawData[6],q=e.rawData[10],re=e.rawData[14],pe=e.rawData[3],le=e.rawData[7],be=e.rawData[11],Fe=e.rawData[15];return t[0]=r-y,t[1]=n-T,t[2]=f-Q,t[3]=v-pe,t[4]=i-b,t[5]=l-U,t[6]=g-H,t[7]=C-le,t[8]=a-D,t[9]=h-E,t[10]=p-q,t[11]=x-be,t[12]=s-B,t[13]=u-N,t[14]=A-re,t[15]=S-Fe,this}mult(e){let t=this.rawData;return t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e,t[4]*=e,t[5]*=e,t[6]*=e,t[7]*=e,t[8]*=e,t[9]*=e,t[10]*=e,t[11]*=e,t[12]*=e,t[13]*=e,t[14]*=e,t[15]*=e,this}appendRotation(e,t){let r=R.getAxisRotation(t.x,t.y,t.z,e);this.append(r)}createByRotation(e,t){let r=R.helpMatrix,i,a,s=e*ge;return i=Math.sin(s),a=Math.cos(s),t.x==1&&(r.rawData[0]=1,r.rawData[1]=0,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=a,r.rawData[6]=i,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=-i,r.rawData[10]=a,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),t.y==1&&(r.rawData[0]=a,r.rawData[1]=0,r.rawData[2]=-i,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=1,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=i,r.rawData[9]=0,r.rawData[10]=a,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),t.z==1&&(r.rawData[0]=a,r.rawData[1]=i,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=-i,r.rawData[5]=a,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=0,r.rawData[10]=1,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),this.append(r),this}appendScale(e,t,r){R.helpMatrix.createByScale(e,t,r),this.append(R.helpMatrix)}createByScale(e,t,r){let i=this.rawData;i[0]=e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=t,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=r,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1}appendTranslation(e,t,r){let i=this.rawData;i[12]+=e,i[13]+=t,i[14]+=r}clone(){let e=new R;return e.copyFrom(this),e}copyRowFrom(e,t){let r=this.rawData;switch(e){case 0:r[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=t.w;break;case 1:r[4]=t.x,r[5]=t.y,r[6]=t.z,r[7]=t.w;break;case 2:r[8]=t.x,r[9]=t.y,r[10]=t.z,r[11]=t.w;break;case 3:r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=t.w;break}}copyRowTo(e,t){let r=this.rawData;switch(e){case 0:t.x=r[0],t.y=r[1],t.z=r[2],t.w=r[3];break;case 1:t.x=r[4],t.y=r[5],t.z=r[6],t.w=r[7];break;case 2:t.x=r[8],t.y=r[9],t.z=r[10],t.w=r[11];break;case 3:t.x=r[12],t.y=r[13],t.z=r[14],t.w=r[15];break}}copyFrom(e){let t=this.rawData;return t[0]=e.rawData[0],t[1]=e.rawData[1],t[2]=e.rawData[2],t[3]=e.rawData[3],t[4]=e.rawData[4],t[5]=e.rawData[5],t[6]=e.rawData[6],t[7]=e.rawData[7],t[8]=e.rawData[8],t[9]=e.rawData[9],t[10]=e.rawData[10],t[11]=e.rawData[11],t[12]=e.rawData[12],t[13]=e.rawData[13],t[14]=e.rawData[14],t[15]=e.rawData[15],this}copyRawDataTo(e,t=0,r=!1){let i=this.rawData;e[0+t]=i[0],e[1+t]=i[1],e[2+t]=i[2],e[3+t]=i[3],e[4+t]=i[4],e[5+t]=i[5],e[6+t]=i[6],e[7+t]=i[7],e[8+t]=i[8],e[9+t]=i[9],e[10+t]=i[10],e[11+t]=i[11],e[12+t]=i[12],e[13+t]=i[13],e[14+t]=i[14],e[15+t]=i[15]}copyColFrom(e,t){let r=this.rawData;switch(e){case 0:r[0]=t.x,r[4]=t.y,r[8]=t.z,r[12]=t.w;break;case 1:r[1]=t.x,r[5]=t.y,r[9]=t.z,r[13]=t.w;break;case 2:r[2]=t.x,r[6]=t.y,r[10]=t.z,r[14]=t.w;break;case 3:r[3]=t.x,r[7]=t.y,r[11]=t.z,r[15]=t.w;break}}copyColTo(e,t){let r=this.rawData;switch(e){case 0:t.x=r[0],t.y=r[4],t.z=r[8],t.w=r[12];break;case 1:t.x=r[1],t.y=r[5],t.z=r[9],t.w=r[13];break;case 2:t.x=r[2],t.y=r[6],t.z=r[10],t.w=r[14];break;case 3:t.x=r[3],t.y=r[7],t.z=r[11],t.w=r[15];break}}copyToMatrix3D(e){e.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(e){return this.compose(R._zero,e,R._one),this}static decomposeRawData=new Float32Array(16).fill(0);decompose(e="eulerAngles",t){let r=Y.CALCULATION_QUATERNION,i=t||R._prs;this.copyRawDataTo(R.decomposeRawData);let a=R.decomposeRawData,s=i[0];s.x=a[12],s.y=a[13],s.z=a[14],a[12]=0,a[13]=0,a[14]=0;let n=i[2];n.x=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]),n.y=Math.sqrt(a[4]*a[4]+a[5]*a[5]+a[6]*a[6]),n.z=Math.sqrt(a[8]*a[8]+a[9]*a[9]+a[10]*a[10]),a[0]*(a[5]*a[10]-a[6]*a[9])-a[1]*(a[4]*a[10]-a[6]*a[8])+a[2]*(a[4]*a[9]-a[5]*a[8])<0&&(n.z=-n.z),a[0]/=n.x,a[1]/=n.x,a[2]/=n.x,a[4]/=n.y,a[5]/=n.y,a[6]/=n.y,a[8]/=n.z,a[9]/=n.z,a[10]/=n.z;let l=i[1],h;switch(e){case qt.AXIS_ANGLE:l.w=Math.acos((a[0]+a[5]+a[10]-1)/2);let u=Math.sqrt((a[6]-a[9])*(a[6]-a[9])+(a[8]-a[2])*(a[8]-a[2])+(a[1]-a[4])*(a[1]-a[4]));l.x=(a[6]-a[9])/u,l.y=(a[8]-a[2])/u,l.z=(a[1]-a[4])/u;break;case qt.QUATERNION:h=a[0]+a[5]+a[10],h>0?(l.w=Math.sqrt(1+h)/2,l.x=(a[6]-a[9])/(4*l.w),l.y=(a[8]-a[2])/(4*l.w),l.z=(a[1]-a[4])/(4*l.w)):a[0]>a[5]&&a[0]>a[10]?(l.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,l.w=(a[6]-a[9])/(4*l.x),l.y=(a[1]+a[4])/(4*l.x),l.z=(a[8]+a[2])/(4*l.x)):a[5]>a[10]?(l.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,l.x=(a[1]+a[4])/(4*l.y),l.w=(a[8]-a[2])/(4*l.y),l.z=(a[6]+a[9])/(4*l.y)):(l.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,l.x=(a[8]+a[2])/(4*l.z),l.y=(a[6]+a[9])/(4*l.z),l.w=(a[1]-a[4])/(4*l.z));break;case qt.EULER_ANGLES:h=a[0]+a[5]+a[10],h>0?(r.w=Math.sqrt(1+h)/2,r.x=(a[6]-a[9])/(4*r.w),r.y=(a[8]-a[2])/(4*r.w),r.z=(a[1]-a[4])/(4*r.w)):a[0]>a[5]&&a[0]>a[10]?(r.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,r.w=(a[6]-a[9])/(4*r.x),r.y=(a[1]+a[4])/(4*r.x),r.z=(a[8]+a[2])/(4*r.x)):a[5]>a[10]?(l.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,r.x=(a[1]+a[4])/(4*r.y),r.w=(a[8]-a[2])/(4*r.y),r.z=(a[6]+a[9])/(4*r.y)):(r.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,r.x=(a[8]+a[2])/(4*r.z),r.y=(a[6]+a[9])/(4*r.z),r.w=(a[1]-a[4])/(4*r.z)),r.getEulerAngles(l);break}return i[0]=s,i[1]=l,i[2]=n,i}static getEuler(e,t,r=!0,i){return e||=new d,R._getEulerMatrix.makeRotationFromQuaternion(t).makeEuler(e,r,i),e}compose(e,t,r){const i=this.rawData,a=t.x,s=t.y,n=t.z,l=t.w,h=a+a,u=s+s,f=n+n,g=a*h,p=a*u,A=a*f,v=s*u,C=s*f,x=n*f,S=l*h,y=l*u,b=l*f,D=r.x,B=r.y,T=r.z;return i[0]=(1-(v+x))*D,i[1]=(p+b)*D,i[2]=(A-y)*D,i[3]=0,i[4]=(p-b)*B,i[5]=(1-(g+x))*B,i[6]=(C+S)*B,i[7]=0,i[8]=(A+y)*T,i[9]=(C-S)*T,i[10]=(1-(g+v))*T,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}deltaTransformVector(e,t){t||=new d;let r=this.rawData,i=e.x,a=e.y,s=e.z;return t.x=i*r[0]+a*r[4]+s*r[8],t.y=i*r[1]+a*r[5]+s*r[9],t.z=i*r[2]+a*r[6]+s*r[10],t.w=i*r[3]+a*r[7]+s*r[11],t}identity(){let e=this.rawData;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}fill(e){let t=this.rawData;t[1]=e,t[2]=e,t[3]=e,t[4]=e,t[6]=e,t[7]=e,t[8]=e,t[9]=e,t[11]=e,t[12]=e,t[13]=e,t[14]=e,t[0]=e,t[5]=e,t[10]=e,t[15]=e}invers33(){let e=this.rawData,t=e[5]*e[10]-e[9]*e[6],r=e[8]*e[6]-e[4]*e[10],i=e[4]*e[9]-e[8]*e[5],a=e[9]*e[2]-e[1]*e[10],s=e[0]*e[10]-e[8]*e[2],n=e[8]*e[1]-e[0]*e[9],l=e[1]*e[6]-e[5]*e[2],h=e[4]*e[2]-e[0]*e[6],u=e[0]*e[5]-e[4]*e[1],f=e[0]*t+e[4]*a+e[8]*l;if(Math.abs(f)>1e-11){let g=1/f;e[0]=g*t,e[4]=g*r,e[8]=g*i,e[1]=g*a,e[5]=g*s,e[9]=g*n,e[2]=g*l,e[6]=g*h,e[10]=g*u}}invert(){let e=this.determinant,t=Math.abs(e)>1e-11,r=this.rawData;if(t){e=1/e;let i=r[0],a=r[4],s=r[8],n=r[12],l=r[1],h=r[5],u=r[9],f=r[13],g=r[2],p=r[6],A=r[10],v=r[14],C=r[3],x=r[7],S=r[11],y=r[15];r[0]=e*(h*(A*y-v*S)-u*(p*y-v*x)+f*(p*S-A*x)),r[1]=-e*(l*(A*y-v*S)-u*(g*y-v*C)+f*(g*S-A*C)),r[2]=e*(l*(p*y-v*x)-h*(g*y-v*C)+f*(g*x-p*C)),r[3]=-e*(l*(p*S-A*x)-h*(g*S-A*C)+u*(g*x-p*C)),r[4]=-e*(a*(A*y-v*S)-s*(p*y-v*x)+n*(p*S-A*x)),r[5]=e*(i*(A*y-v*S)-s*(g*y-v*C)+n*(g*S-A*C)),r[6]=-e*(i*(p*y-v*x)-a*(g*y-v*C)+n*(g*x-p*C)),r[7]=e*(i*(p*S-A*x)-a*(g*S-A*C)+s*(g*x-p*C)),r[8]=e*(a*(u*y-f*S)-s*(h*y-f*x)+n*(h*S-u*x)),r[9]=-e*(i*(u*y-f*S)-s*(l*y-f*C)+n*(l*S-u*C)),r[10]=e*(i*(h*y-f*x)-a*(l*y-f*C)+n*(l*x-h*C)),r[11]=-e*(i*(h*S-u*x)-a*(l*S-u*C)+s*(l*x-h*C)),r[12]=-e*(a*(u*v-f*A)-s*(h*v-f*p)+n*(h*A-u*p)),r[13]=e*(i*(u*v-f*A)-s*(l*v-f*g)+n*(l*A-u*g)),r[14]=-e*(i*(h*v-f*p)-a*(l*v-f*g)+n*(l*p-h*g)),r[15]=e*(i*(h*A-u*p)-a*(l*A-u*g)+s*(l*p-h*g))}return t}transformPoint(e,t){let r=this.rawData;t||=new d;let i=e.x,a=e.y,s=e.z;return t.x=i*r[0]+a*r[4]+s*r[8]+r[12],t.y=i*r[1]+a*r[5]+s*r[9]+r[13],t.z=i*r[2]+a*r[6]+s*r[10]+r[14],t}transformVector(e,t){let r=this.rawData;t||=new d;let i=e.x,a=e.y,s=e.z;return t.x=i*r[0]+a*r[4]+s*r[8],t.y=i*r[1]+a*r[5]+s*r[9],t.z=i*r[2]+a*r[6]+s*r[10],t}transpose(){let e=this.rawData;for(let t=0;t<R.helpMatrix.rawData.length;t++)R.helpMatrix.rawData[t]=e[t];e[1]=R.helpMatrix.rawData[4],e[2]=R.helpMatrix.rawData[8],e[3]=R.helpMatrix.rawData[12],e[4]=R.helpMatrix.rawData[1],e[6]=R.helpMatrix.rawData[9],e[7]=R.helpMatrix.rawData[13],e[8]=R.helpMatrix.rawData[2],e[9]=R.helpMatrix.rawData[6],e[11]=R.helpMatrix.rawData[14],e[12]=R.helpMatrix.rawData[3],e[13]=R.helpMatrix.rawData[7],e[14]=R.helpMatrix.rawData[11]}get determinant(){let e=this.rawData;return(e[0]*e[5]-e[4]*e[1])*(e[10]*e[15]-e[14]*e[11])-(e[0]*e[9]-e[8]*e[1])*(e[6]*e[15]-e[14]*e[7])+(e[0]*e[13]-e[12]*e[1])*(e[6]*e[11]-e[10]*e[7])+(e[4]*e[9]-e[8]*e[5])*(e[2]*e[15]-e[14]*e[3])-(e[4]*e[13]-e[12]*e[5])*(e[2]*e[11]-e[10]*e[3])+(e[8]*e[13]-e[12]*e[9])*(e[2]*e[7]-e[6]*e[3])}getPosition(e){e||=new d;let t=this.rawData;return e.x=t[12],e.y=t[13],e.z=t[14],e}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(e){let t=this.rawData;t[12]=e.x,t[13]=e.y,t[14]=e.z}get scale(){let e=this.rawData;return new d(e[0],e[5],e[10])}set scale(e){let t=this.rawData;t[0]=e.x,t[5]=e.y,t[10]=e.z}toString(){let e=this.rawData;return"matrix3d("+Math.round(e[0]*1e3)/1e3+","+Math.round(e[1]*1e3)/1e3+","+Math.round(e[2]*1e3)/1e3+","+Math.round(e[3]*1e3)/1e3+","+Math.round(e[4]*1e3)/1e3+","+Math.round(e[5]*1e3)/1e3+","+Math.round(e[6]*1e3)/1e3+","+Math.round(e[7]*1e3)/1e3+","+Math.round(e[8]*1e3)/1e3+","+Math.round(e[9]*1e3)/1e3+","+Math.round(e[10]*1e3)/1e3+","+Math.round(e[11]*1e3)/1e3+","+Math.round(e[12]*1e3)/1e3+","+Math.round(e[13]*1e3)/1e3+","+Math.round(e[14]*1e3)/1e3+","+Math.round(e[15]*1e3)/1e3+")"}lerp(e,t,r){this.copyFrom(t).sub(e).mult(r).add(e)}get(e,t){return this.rawData[e+t*4]}set(e,t,r){this.rawData[e+t*4]=r}getMaxScaleOnAxis(){let e=this.rawData,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,i))}translate(e){let t=this.get(0,0)*e.x+this.get(0,1)*e.y+this.get(0,2)*e.z+this.get(0,3),r=this.get(1,0)*e.x+this.get(1,1)*e.y+this.get(1,2)*e.z+this.get(1,3),i=this.get(2,0)*e.x+this.get(2,1)*e.y+this.get(2,2)*e.z+this.get(2,3),a=this.get(3,0)*e.x+this.get(3,1)*e.y+this.get(3,2)*e.z+this.get(3,3);return this.set(0,3,t),this.set(1,3,r),this.set(2,3,i),this.set(3,3,a),this}setTRInverse(e,t){t=t.inverse(),Y.quaternionToMatrix(t,this),this.translate(new d(-e.x,-e.y,-e.z))}setScale(e){return this.set(0,0,e.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,e.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,e.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(e,t,r){return this.setElements(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),i=Math.sin(t),a=1-r,s=e.x,n=e.y,l=e.z,h=a*s,u=a*n;return this.setElements(h*s+r,h*n-i*l,h*l+i*n,0,h*n+i*l,u*n+r,u*l-i*s,0,h*l-i*n,u*l+i*s,a*l*l+r,0,0,0,0,1),this}static transpose(e,t){t||=new R;let r=e.rawData,i=t.rawData;return i[0]=r[0],i[1]=r[4],i[2]=r[8],i[3]=r[12],i[4]=r[1],i[5]=r[5],i[6]=r[9],i[7]=r[13],i[8]=r[2],i[9]=r[6],i[10]=r[10],i[11]=r[14],i[12]=r[3],i[13]=r[7],i[14]=r[11],i[15]=r[15],t}static inverse(e,t){t||=new R;let r=e.rawData,i=t.rawData;i[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],i[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],i[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],i[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],i[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],i[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],i[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],i[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],i[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],i[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],i[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],i[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],i[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],i[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],i[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],i[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];let a=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12];for(let s=0;s<16;s++)i[s]/=a;return t}makeEuler(e,t,r="XYZ"){const i=this.rawData,a=i[0],s=i[4],n=i[8],l=i[1],h=i[5],u=i[9],f=i[2],g=i[6],p=i[10];switch(r){case"XYZ":e.y=Math.asin(j(n,-1,1)),Math.abs(n)<.9999999?(e.x=Math.atan2(-u,p),e.z=Math.atan2(-s,a)):(e.x=Math.atan2(g,h),e.z=0);break;case"YXZ":e.x=Math.asin(-j(u,-1,1)),Math.abs(u)<.9999999?(e.y=Math.atan2(n,p),e.z=Math.atan2(l,h)):(e.y=Math.atan2(-f,a),e.z=0);break;case"ZXY":e.x=Math.asin(j(g,-1,1)),Math.abs(g)<.9999999?(e.y=Math.atan2(-f,p),e.z=Math.atan2(-s,h)):(e.y=0,e.z=Math.atan2(l,a));break;case"ZYX":e.y=Math.asin(-j(f,-1,1)),Math.abs(f)<.9999999?(e.x=Math.atan2(g,p),e.z=Math.atan2(l,a)):(e.x=0,e.z=Math.atan2(-s,h));break;case"YZX":e.z=Math.asin(j(l,-1,1)),Math.abs(l)<.9999999?(e.x=Math.atan2(-u,h),e.y=Math.atan2(-f,a)):(e.x=0,e.y=Math.atan2(n,p));break;case"XZY":e.z=Math.asin(-j(s,-1,1)),Math.abs(s)<.9999999?(e.x=Math.atan2(g,h),e.y=Math.atan2(n,a)):(e.x=Math.atan2(-u,p),e.y=0);break}return t&&e.multiplyScalar(Gr),e}setElements(e,t,r,i,a,s,n,l,h,u,f,g,p,A,v,C){const x=this.rawData;return x[0]=e,x[4]=t,x[8]=r,x[12]=i,x[1]=a,x[5]=s,x[9]=n,x[13]=l,x[2]=h,x[6]=u,x[10]=f,x[14]=g,x[3]=p,x[7]=A,x[11]=v,x[15]=C,this}makeMatrix44ByQuaternion(e,t,r){this.identity(),Y.quaternionToMatrix(r,this),this.appendTranslation(e.x,e.y,e.z),this.appendScale(t.x,t.y,t.z)}}function Qn(o,e,t){for(let r=0;r<4;r++)t.rawData[r]=o.rawData[r]*e.rawData[0]+o.rawData[r+4]*e.rawData[1]+o.rawData[r+8]*e.rawData[2]+o.rawData[r+12]*e.rawData[3],t.rawData[r+4]=o.rawData[r]*e.rawData[4]+o.rawData[r+4]*e.rawData[5]+o.rawData[r+8]*e.rawData[6]+o.rawData[r+12]*e.rawData[7],t.rawData[r+8]=o.rawData[r]*e.rawData[8]+o.rawData[r+4]*e.rawData[9]+o.rawData[r+8]*e.rawData[10]+o.rawData[r+12]*e.rawData[11],t.rawData[r+12]=o.rawData[r]*e.rawData[12]+o.rawData[r+4]*e.rawData[13]+o.rawData[r+8]*e.rawData[14]+o.rawData[r+12]*e.rawData[15]}function aa(o,e,t,r){let i=r.rawData,a=o.x*ge,s=o.y*ge,n=o.z*ge,l=0,h=a*.5,u=s*.5,f=n*.5,g=Math.cos(h),p=Math.sin(h),A=Math.cos(u),v=Math.sin(u),C=Math.cos(f),x=Math.sin(f);l=g*A*C+p*v*x,a=p*A*C-g*v*x,s=g*v*C+p*A*x,n=g*A*x-p*v*C;let S=a+a,y=s+s,b=n+n,D=a*S,B=a*y,T=a*b,U=s*y,E=s*b,N=n*b,Q=l*S,H=l*y,q=l*b,re=t.x,pe=t.y,le=t.z;i[0]=(1-(U+N))*re,i[1]=(B+q)*re,i[2]=(T-H)*re,i[3]=0,i[4]=(B-q)*pe,i[5]=(1-(D+N))*pe,i[6]=(E+Q)*pe,i[7]=0,i[8]=(T+H)*le,i[9]=(E-Q)*le,i[10]=(1-(D+U))*le,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1}function Vn(o,e,t){let r=o.rawData,i=t.rawData,a=r[0],s=r[4],n=r[8],l=r[12],h=r[1],u=r[5],f=r[9],g=r[13],p=r[2],A=r[6],v=r[10],C=r[14],x=r[3],S=r[7],y=r[11],b=r[15];i[0]=a*e.rawData[0]+h*e.rawData[4]+p*e.rawData[8]+x*e.rawData[12],i[1]=a*e.rawData[1]+h*e.rawData[5]+p*e.rawData[9]+x*e.rawData[13],i[2]=a*e.rawData[2]+h*e.rawData[6]+p*e.rawData[10]+x*e.rawData[14],i[3]=a*e.rawData[3]+h*e.rawData[7]+p*e.rawData[11]+x*e.rawData[15],i[4]=s*e.rawData[0]+u*e.rawData[4]+A*e.rawData[8]+S*e.rawData[12],i[5]=s*e.rawData[1]+u*e.rawData[5]+A*e.rawData[9]+S*e.rawData[13],i[6]=s*e.rawData[2]+u*e.rawData[6]+A*e.rawData[10]+S*e.rawData[14],i[7]=s*e.rawData[3]+u*e.rawData[7]+A*e.rawData[11]+S*e.rawData[15],i[8]=n*e.rawData[0]+f*e.rawData[4]+v*e.rawData[8]+y*e.rawData[12],i[9]=n*e.rawData[1]+f*e.rawData[5]+v*e.rawData[9]+y*e.rawData[13],i[10]=n*e.rawData[2]+f*e.rawData[6]+v*e.rawData[10]+y*e.rawData[14],i[11]=n*e.rawData[3]+f*e.rawData[7]+v*e.rawData[11]+y*e.rawData[15],i[12]=l*e.rawData[0]+g*e.rawData[4]+C*e.rawData[8]+b*e.rawData[12],i[13]=l*e.rawData[1]+g*e.rawData[5]+C*e.rawData[9]+b*e.rawData[13],i[14]=l*e.rawData[2]+g*e.rawData[6]+C*e.rawData[10]+b*e.rawData[14],i[15]=l*e.rawData[3]+g*e.rawData[7]+C*e.rawData[11]+b*e.rawData[15]}function Kf(o,e){let t=e.x,r=e.y,i=e.z,a=e.w,s=o.rawData,n=2*t*r,l=2*t*i,h=2*t*a,u=2*r*i,f=2*r*a,g=2*i*a,p=t*t,A=r*r,v=i*i,C=a*a;return s[0]=p-A-v+C,s[4]=n-g,s[8]=l+f,s[12]=0,s[1]=n+g,s[5]=-p+A-v+C,s[9]=u-h,s[13]=0,s[2]=l-f,s[6]=u+h,s[10]=-p-A+v+C,s[14]=0,s[3]=0,s[7]=0,s[11]=0,s[15]=1,o}function Jf(o,e){let t=e.rawData,r=Math.sin(o),i=Math.cos(o);return t[0]=i,t[1]=0,t[2]=-r,t[3]=0,t[8]=r,t[9]=0,t[10]=i,t[11]=0,t}function Zf(o,e,t){let r=e.x,i=e.y,a=e.z,s=Math.hypot(r,i,a),n,l,h,u,f,g,p,A,v,C,x,S;if(s<qf)return null;s=1/s,r*=s,i*=s,a*=s,n=Math.sin(o),l=Math.cos(o),h=1-l,u=r*r*h+l,f=i*r*h+a*n,g=a*r*h-i*n,p=r*i*h-a*n,A=i*i*h+l,v=a*i*h+r*n,C=r*a*h+i*n,x=i*a*h-r*n,S=a*a*h+l;let y=t.rawData;return y[0]=u,y[1]=f,y[2]=g,y[3]=0,y[4]=p,y[5]=A,y[6]=v,y[7]=0,y[8]=C,y[9]=x,y[10]=S,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,y}function ss(o,e,t){let r=o.rawData,i=r[0],a=r[1],s=r[2],n=r[3],l=r[4],h=r[5],u=r[6],f=r[7],g=r[8],p=r[9],A=r[10],v=r[11],C=r[12],x=r[13],S=r[14],y=r[15],b=e.rawData,D=t.rawData,B=b[0],T=b[1],U=b[2],E=b[3];return D[0]=B*i+T*l+U*g+E*C,D[1]=B*a+T*h+U*p+E*x,D[2]=B*s+T*u+U*A+E*S,D[3]=B*n+T*f+U*v+E*y,B=b[4],T=b[5],U=b[6],E=b[7],D[4]=B*i+T*l+U*g+E*C,D[5]=B*a+T*h+U*p+E*x,D[6]=B*s+T*u+U*A+E*S,D[7]=B*n+T*f+U*v+E*y,B=b[8],T=b[9],U=b[10],E=b[11],D[8]=B*i+T*l+U*g+E*C,D[9]=B*a+T*h+U*p+E*x,D[10]=B*s+T*u+U*A+E*S,D[11]=B*n+T*f+U*v+E*y,B=b[12],T=b[13],U=b[14],E=b[15],D[12]=B*i+T*l+U*g+E*C,D[13]=B*a+T*h+U*p+E*x,D[14]=B*s+T*u+U*A+E*S,D[15]=B*n+T*f+U*v+E*y,D}var Ee=(o=>(o[o.None=0]="None",o[o.PointLight=1]="PointLight",o[o.DirectionLight=2]="DirectionLight",o[o.SpotLight=3]="SpotLight",o[o.SkyLight=4]="SkyLight",o))(Ee||{});class sa extends Bt{static lightSize=24;index=-1;lightType=-1;radius=.5;linear=1;lightPosition=new d;lightMatrixIndex=-1;direction=new d;quadratic=.032;lightColor=new P(1,1,1,1);intensity=1;innerAngle=0;outerAngle=1;range=100;castShadowIndex=-1;lightTangent=d.FORWARD;iesIndex=-1}class oe{static componentsUpdateList;static componentsLateUpdateList;static componentsBeforeUpdateList;static componentsComputeList;static componentsEnablePickerList;static graphicComponent;static waitStartComponent;static _init=!1;static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(e,t,r){this.init();let i=this.componentsUpdateList.get(e);i||(i=new Map,this.componentsUpdateList.set(e,i)),i.set(t,r)}static unBindUpdate(e,t){this.init();let r=this.componentsUpdateList.get(e);r&&r.delete(t)}static bindLateUpdate(e,t,r){this.init();let i=this.componentsLateUpdateList.get(e);i||(i=new Map,this.componentsLateUpdateList.set(e,i)),i.set(t,r)}static unBindLateUpdate(e,t){this.init();let r=this.componentsLateUpdateList.get(e);r&&r.delete(t)}static bindBeforeUpdate(e,t,r){this.init();let i=this.componentsBeforeUpdateList.get(e);i||(i=new Map,this.componentsBeforeUpdateList.set(e,i)),i.set(t,r)}static unBindBeforeUpdate(e,t){this.init();let r=this.componentsBeforeUpdateList.get(e);r&&r.delete(t)}static bindCompute(e,t,r){this.init();let i=this.componentsComputeList.get(e);i||(i=new Map,this.componentsComputeList.set(e,i)),i.set(t,r)}static unBindCompute(e,t){this.init();let r=this.componentsComputeList.get(e);r&&r.delete(t)}static bindGraphic(e,t,r){this.init();let i=this.graphicComponent.get(e);i||(i=new Map,this.graphicComponent.set(e,i)),i.set(t,r)}static unBindGraphic(e,t){this.init();let r=this.graphicComponent.get(e);r&&r.delete(t)}static appendWaitStart(e){this.init();let t=this.waitStartComponent.get(e.object3D);t?t.indexOf(e)==-1&&t.push(e):this.waitStartComponent.set(e.object3D,[e])}static removeWaitStart(e,t){this.init();let r=oe.waitStartComponent.get(e);if(r){let i=r.indexOf(t);i!=-1&&r.splice(i)}}static bindEnablePick(e,t,r){this.init();let i=this.componentsEnablePickerList.get(e);i||(i=new Map,this.componentsEnablePickerList.set(e,i)),i.set(t,r)}static unBindEnablePick(e,t){this.init();let r=this.componentsEnablePickerList.get(e);r&&r.delete(t)}}class _e{object3D=null;_eventDispatcher;get eventDispatcher(){return this._eventDispatcher||=new Xt,this._eventDispatcher}set eventDispatcher(e){console.error("The eventDispatcher should not be set externally!")}_enable=!0;__isStart=!1;isDestroyed;get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(e){this._enable!=e&&(this._enable=e,this._enable?this.onEnable?.(this.transform.view3D):this.onDisable?.(this.transform.view3D))}get enable(){return this._enable}__init(e){this.init(e)}__start(){this.transform&&this.transform.scene3D&&this._enable&&this.onEnable?.(this.transform.view3D),this.transform&&this.transform.scene3D&&this.__isStart==!1&&(this.start?.(),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){this.transform&&this.transform.scene3D&&this.onDisable?.(this.transform.view3D),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(e){}start(){}stop(){}cloneTo(e){}copyComponent(e){return this}_onUpdate(e){e!=null?oe.bindUpdate(this.transform.view3D,this,e):oe.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(e){e!=null?oe.bindLateUpdate(this.transform.view3D,this,e):oe.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(e){e!=null?oe.bindBeforeUpdate(this.transform.view3D,this,e):oe.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(e){e!=null?oe.bindCompute(this.transform.view3D,this,e):oe.unBindCompute(this.transform.view3D,this)}_onGraphic(e){e!=null?oe.bindGraphic(this.transform.view3D,this,e):oe.unBindGraphic(this.transform.view3D,this)}beforeDestroy(e){oe.removeWaitStart(this.object3D,this)}destroy(e){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class oa{value=0;inv_base=0;static get(e,t){let r=0,i=1/t;for(;e>0;)r+=e%t*i,e/=t,i/=t;return r}getBase(e,t){let r=this.inv_base=1/t;for(;e>0;)this.value+=r*(e%t),e/=t,r*=this.inv_base}next(){let e=1-this.value-1e-7;if(this.inv_base<e)this.value+=this.inv_base;else{let t=this.inv_base,r;do r=t,t*=this.inv_base;while(t>=e);this.value+=r+t-1}}get(){return this.value}}class _t{origin=new d;length=Number.MAX_VALUE;static _rayl=1e9;static _smallnum=1e-8;_vector=new d;_dir=new d;constructor(e,t){this.origin.copyFrom(e||new d),this._dir.copyFrom(t||new d),this._dir.normalize()}get direction(){return this._dir}set direction(e){this._dir.copyFrom(e),this._dir.normalize()}clone(){return new _t(this.origin,this.direction)}intersectBox(e,t){let r=this.direction,i=this.origin,a,s,n,l,h,u;const f=1/r.x,g=1/r.y,p=1/r.z,A=e.min,v=e.max;return a=((f>=0?A.x:v.x)-i.x)*f,s=((f>=0?v.x:A.x)-i.x)*f,n=((g>=0?A.y:v.y)-i.y)*g,l=((g>=0?v.y:A.y)-i.y)*g,a>l||n>s||(n>a&&(a=n),l<s&&(s=l),h=((p>=0?A.z:v.z)-i.z)*p,u=((p>=0?v.z:A.z)-i.z)*p,a>u||h>s)||(h>a&&(a=h),u<s&&(s=u),s<0)?null:(t||=new d,this.pointAt(a>=0?a:s,t))}pointAt(e,t){return t||=new d,t.copy(this.direction),t.multiplyScalar(e),t.add(this.origin,t),t}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this._dir.copy(e._dir),this.length=e.length,this}setApproxDirection(e){this._dir=e.normalize()}setOrigin(e){this.origin.copyFrom(e)}getOrigin(){return this.origin}getPoint(e){return this._dir.scaleBy(e),this.origin.add(this._dir)}sqrDistToPoint(e){let t=this._dir,r=e.subtract(this.origin),i=Xe(r,t),a=Xe(t,t),s=i/a,n=this.getPoint(s);return is(e.subtract(n))}applyMatrix(e){this.origin=e.transformPoint(this.origin),this._dir=e.transformVector(this._dir)}_v0=new d;_v1=new d;_v2=new d;pointInTriangle(e,t,r,i){let a=this._v0,s=this._v1,n=this._v2;i.subtract(t,a),r.subtract(t,s),e.subtract(t,n);let l=d.dot(a,a),h=d.dot(a,s),u=d.dot(a,n),f=d.dot(s,s),g=d.dot(s,n),p=1/(l*f-h*h),A=(f*u-h*g)*p,v=(l*g-h*u)*p;return A>=0&&v>=0&&A+v<1}_E1=new d;_E2=new d;_P=new d;_T=new d;_Q=new d;intersectTriangle(e,t,r){let i=r.v1,a=r.v2,s=r.v3;a.subtract(i,this._E1),s.subtract(i,this._E2),t.crossProduct(this._E2,this._P);let n=this._E1.dotProduct(this._P);if(n>0?e.subtract(i,this._T):(i.subtract(e,this._T),n=-n),n<1e-4||(r.u=this._T.dotProduct(this._P),r.u<0||r.u>n)||(this._T.crossProduct(this._E1,this._Q),r.v=t.dotProduct(this._Q),r.v<0||r.u+r.v>n))return null;let l=new d;r.t0=r.t=this._E2.dotProduct(this._Q);let h=1/n;return r.t*=h,r.u*=h,r.v*=h,l.x=e.x+r.t*t.x,l.y=e.y+r.t*t.y,l.z=e.z+r.t*t.z,l}intersectSphere(e,t,r,i){let a=e.subtract(r),s=d.dot(t,t),n=2*d.dot(a,t),l=d.dot(a,a)-i*i,h=n*n-4*s*l,u=d.HELP_3;if(h<0)return null;{let f=(-n-Math.sqrt(h))/(s*2);return f<0?null:(u.x=e.x+f*t.x,u.y=e.y+f*t.y,u.z=e.z+f*t.z,u)}}intersectionSegment(e,t,r){const i=this.origin,a=d.HELP_0,s=d.HELP_1,n=d.HELP_2,l=d.HELP_3;t.subtract(e,a),this._dir.scaleToRef(_t._rayl,n),i.add(n,s),e.subtract(i,l);var h=d.dot(a,a),u=d.dot(a,n),f=d.dot(n,n),g=d.dot(a,l),p=d.dot(n,l),A=h*f-u*u,v,C,x=A,S,y,b=A;A<_t._smallnum?(C=0,x=1,y=p,b=f):(C=u*p-f*g,y=h*p-u*g,C<0?(C=0,y=p,b=f):C>x&&(C=x,y=p+u,b=f)),y<0?(y=0,-g<0?C=0:-g>h?C=x:(C=-g,x=h)):y>b&&(y=b,-g+u<0?C=0:-g+u>h?C=x:(C=-g+u,x=h)),v=Math.abs(C)<_t._smallnum?0:C/x,S=Math.abs(y)<_t._smallnum?0:y/b;const D=d.HELP_4;n.scaleToRef(S,D);const B=d.HELP_5;a.scaleToRef(v,B),B.add(l,B);const T=d.HELP_6;B.subtract(D,T);var U=S>0&&S<=this._dir.length&&T.lengthSquared<r*r;if(U){let E=new d;return E.copyFrom(t.subtract(e)),E.scaleBy(v),E.add(e,E),{out:E,length:B.length}}return{out:null,length:-1}}get_vec(e,t){let r=d.HELP_1;return r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}}class ni{x;y;w;h;constructor(e=0,t=0,r=0,i=0){this.x=e,this.y=t,this.w=r,this.h=i}get width(){return this.w}set width(e){this.w=e}get height(){return this.h}set height(e){this.h=e}static pointInRect(e,t,r,i,a,s){return!(e<r||e>a||t<i||t>s)}clone(){return new ni(this.x,this.y,this.w,this.h)}copyFrom(e){this.x=e.x,this.y=e.y,this.w=e.w,this.h=e.h}copyTo(e){e.copyFrom(this)}inner(e,t){return!(e<this.x||e>this.x+this.width||t<this.y||t>this.y+this.height)}equal(e){return!(this.x!=e.x||this.y!=e.y||this.width!=e.width||this.height!=e.height)}equalArea(e,t,r,i){return!(this.x!=e||this.y!=t||this.width!=r||this.height!=i)}equalInnerArea(e){var t=this.x,r=this.y,i=this.x+this.width,a=this.y+this.height,s=e.x,n=e.y,l=e.x+e.width,h=e.y+e.height;return Math.max(t,s)<=Math.min(i,l)&&Math.max(r,n)<=Math.min(a,h)}innerArea(e,t){t=t||new ni;var r=this.x,i=this.y,a=this.x+this.width,s=this.y+this.height,n=e.x,l=e.y,h=e.x+e.width,u=e.y+e.height,f=Math.max(i,l),g=Math.min(s,u),p=Math.max(r,n),A=Math.min(h,a);return f>=0&&g>=0&&g-f>=0&&A-p>0?(t.x=p,t.y=f,t.width=A-p,t.height=g-f):(t.x=0,t.y=0,t.width=0,t.height=0),t}setTo(e,t,r,i){this.x=e,this.y=t,this.width=r,this.height=i}}class de{center;extents;max;min;size;static maxVector3=new d(1,1,1).multiplyScalar(Number.MAX_VALUE*.1);static minVector3=new d(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1);constructor(e,t){e||=d.ZERO.clone(),t||=d.ZERO.clone(),this.setFromCenterAndSize(e,t)}makeEmpty(){return this.setFromMinMax(de.maxVector3,de.minVector3),this}setFromMinMax(e,t){return this.init(),t.subtract(e,this.size),e.add(t,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(e),this.max.copyFrom(t),this}init(){return this.min||=new d,this.max||=new d,this.size||=new d,this.center||=new d,this.extents||=new d,this}setFromCenterAndSize(e,t){return this.size=t,this.center=e,this.init(),this.extents.copy(t).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(e,t){return t.containsBox(e.bound)}merge(e){e.min.x<this.min.x&&(this.min.x=e.min.x),e.min.y<this.min.y&&(this.min.y=e.min.y),e.min.z<this.min.z&&(this.min.z=e.min.z),e.max.x>this.max.x&&(this.max.x=e.max.x),e.max.y>this.max.y&&(this.max.y=e.max.y),e.max.z>this.max.z&&(this.max.z=e.max.z),this.size.x=e.max.x-e.min.x,this.size.y=e.max.y-e.min.y,this.size.z=e.max.z-e.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+e.min.x,this.center.y=this.extents.y+e.min.y,this.center.z=this.extents.z+e.min.z}intersects(e){return this.min.x<=e.max.x&&this.max.x>=e.min.x&&this.min.y<=e.max.y&&this.max.y>=e.min.y&&this.min.z<=e.max.z&&this.max.z>=e.min.z}intersectsSphere(e){return this.min.x<=e.max.x&&this.max.x>=e.min.x&&this.min.y<=e.max.y&&this.max.y>=e.min.y&&this.min.z<=e.max.z&&this.max.z>=e.min.z}intersectsBox(e){return this.min.x<=e.max.x&&this.max.x>=e.min.x&&this.min.y<=e.max.y&&this.max.y>=e.min.y&&this.min.z<=e.max.z&&this.max.z>=e.min.z}equals(e){return this.center.equals(e.center)&&this.extents.equals(e.extents)}expandByPoint(e){e.x<this.min.x&&(this.min.x=e.x),e.x>this.max.x&&(this.max.x=e.x),e.y<this.min.y&&(this.min.y=e.y),e.y>this.max.y&&(this.max.y=e.y),e.z<this.min.z&&(this.min.z=e.z),e.z>this.max.z&&(this.max.z=e.z)}static fromPoints(e){for(var t=new de(new d,new d),r=0;r<e.length;r++)t.expandByPoint(e[r]);return t}calculateTransform(e){}clone(){var e=new de(this.center.clone(),this.size.clone());return e}intersectsRay(e,t){throw new Error("Method not implemented.")}containsPoint(e){return this.min.x<=e.x&&this.max.x>=e.x&&this.min.y<=e.y&&this.max.y>=e.y&&this.min.z<=e.z&&this.max.z>=e.z}containsBox(e){let t=this.min,r=this.max;return t.x<=e.min.x&&t.y<=e.min.y&&t.z<=e.min.z&&r.x>=e.max.x&&r.y>=e.max.y&&r.z>=e.max.z}updateBound(){}destroy(e){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}}class Hn{planes;corners;boundingBox=new de;constructor(){this.planes=[],this.corners=[];for(var e=0;e<6;e++)this.planes[e]=new d;for(var e=0;e<2*2*2;e++)this.corners[e]=new d}updateBoundBox(e){this.boundingBox.makeEmpty();let t=this.boundingBox.min,r=this.boundingBox.max,i=0;for(let a=0;a<2;++a)for(let s=0;s<2;++s)for(let n=0;n<2;++n){let l=this.corners[i];i++,l.set(2*a-1,2*s-1,n,1),e.transformVector4(l,l),l.div(l.w,l),t.x=Math.min(l.x,t.x),t.y=Math.min(l.y,t.y),t.z=Math.min(l.z,t.z),r.x=Math.max(l.x,r.x),r.y=Math.max(l.y,r.y),r.z=Math.max(l.z,r.z)}return this.boundingBox.setFromMinMax(t,r),this}setFrustumCorners(e){let t=0;for(let r=0;r<2;++r)for(let i=0;i<2;++i)for(let a=0;a<2;++a){let s=this.corners[t];s.set(2*r-1,2*i-1,a,1),e.transformVector4(s,s),s.div(s.w,s),t++}}update(e){var t=e.rawData;this.planes[0].x=t[3]-t[0],this.planes[0].y=t[7]-t[4],this.planes[0].z=t[11]-t[8],this.planes[0].w=t[15]-t[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=t[3]+t[0],this.planes[1].y=t[7]+t[4],this.planes[1].z=t[11]+t[8],this.planes[1].w=t[15]+t[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=t[3]+t[1],this.planes[2].y=t[7]+t[5],this.planes[2].z=t[11]+t[9],this.planes[2].w=t[15]+t[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=t[3]-t[1],this.planes[3].y=t[7]-t[5],this.planes[3].z=t[11]-t[9],this.planes[3].w=t[15]-t[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=t[3]-t[2],this.planes[4].y=t[7]-t[6],this.planes[4].z=t[11]-t[10],this.planes[4].w=t[15]-t[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=t[3]+t[2],this.planes[5].y=t[7]+t[6],this.planes[5].z=t[11]+t[10],this.planes[5].w=t[15]+t[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(e){for(var t=0;t<6;t++)if(this.planes[t].x*e.x+this.planes[t].y*e.y+this.planes[t].z*e.z+this.planes[t].w<=0)return!1;return!0}containsSphere(e){let t=e.bound,r=0,i,a=e.transform.worldPosition,s=t.radius,n=t.center.x+a.x,l=t.center.y+a.y,h=t.center.z+a.z;for(let u of this.planes){if(i=u.x*n+u.y*l+u.z*h+u.w,i<=-s)return 0;i>s&&r++}return r===6?2:1}containsBox(e){let t=0,r,a=Math.max(e.size.x,e.size.y,e.size.z)*2,s=e.center.x,n=e.center.y,l=e.center.z;for(let h of this.planes){if(r=h.x*s+h.y*n+h.z*l+h.w,r<=-a)return 0;r>a&&t++}return t===6?2:1}containsBox2(e){let t=0,r,i=1.74*Math.max(e.extents.x,e.extents.y,e.extents.z);for(let a of this.planes){if(r=a.x*e.center.x+a.y*e.center.y+a.z*e.center.z+a.w,r<=-i)return 0;r>i&&t++}return t===6?2:1}}var me=(o=>(o[o.ortho=0]="ortho",o[o.perspective=1]="perspective",o[o.shadow=2]="shadow",o))(me||{});class $f{corners;index;constructor(e){this.index=e,this.corners=[];for(let t=0;t<4;t++)this.corners.push(new d)}}class ed{bound;twoSections;name;color;shadowCamera;index;constructor(e,t,r){this.bound=new de,this.shadowCamera=Te.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[e,t],this.index=r,r==0?this.color=new P(1,0,0,1):r==1?this.color=new P(0,1,0,1):r==2?this.color=new P(0,0,1,1):r==3&&(this.color=new P(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let e=this.bound.min,t=this.bound.max;for(let r of this.twoSections)for(let i of r.corners)e.x=Math.min(i.x,e.x),e.y=Math.min(i.y,e.y),e.z=Math.min(i.z,e.z),t.x=Math.max(i.x,t.x),t.y=Math.max(i.y,t.y),t.z=Math.max(i.z,t.z);return this.bound.setFromMinMax(e,t),this}}class Yn{sections;children;name;constructor(e){this.sections=[];let t=e+1;for(let r=0;r<t;r++)this.sections.push(new $f(r));this.children=[];for(let r=0;r<e;r++)this.children.push(new ed(this.sections[r],this.sections[r+1],r))}update(e,t,r,i,a){let s=this.sections.length-1;for(let n=0;n<=s;++n){let l=this.sections[n],h=0,u=this.logSplit(r,i,n,this.sections.length);{let g=(u-r)/i;g=g**a.csmScatteringExp,u=(i-r)*g+r}u*=a.csmAreaScale;let f=(e.rawData[10]*u+e.rawData[14])/u;for(let g=0;g<2;++g)for(let p=0;p<2;++p){let A=l.corners[h];h++,A.set(2*g-1,2*p-1,f,1),t.transformVector4(A,A),A.div(A.w,A)}}for(let n of this.children)n.updateBound();return this}squareSplit(e,t,r,i){return(r/(i-1))**4*(t-e)+e}uniformSplit(e,t,r,i){return r/(i-1)*(t-e)+e}logSplit(e,t,r,i){return e*(t/e)**(r/(i-1))}}class Vr extends _e{fov=1;name;aspect=1;near=1;far=5e3;viewPort=new ni;frustum;isShadowCamera=!1;_projectionMatrixInv=new R;_projectionMatrix=new R;_viewMatrix=new R;_unprojection=new R;_pvMatrixInv=new R;_pvMatrix=new R;_halfw;_halfh;_ray;_enableCSM=!1;get projectionMatrix(){return this._projectionMatrix}lookTarget;type=me.perspective;csm;cubeShadowCameras=[];get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Yn(At.Cascades)),this._enableCSM=e}constructor(){super()}init(){super.init(),this._ray=new _t,this.frustum=new Hn,this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=I.presentationSize[0],this.viewPort.h=I.presentationSize[1],this.lookTarget=new d(0,0,0)}getShadowBias(e){let t=2*this.getShadowWorldExtents()/e,r=this.far-this.near;return t/r-m.setting.shadow.shadowBias*.01}getShadowWorldExtents(){let e=m.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBias(e,t){let r=2*this.getCSMShadowWorldExtents(e)/t,i=this.far-this.near;return r/i}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,t,r,i){this.fov=e,this.aspect=t,this.near=r,this.far=i,this._projectionMatrix.perspective(e,t,r,i),this.type=me.perspective}resetPerspective(e){this.type==me.perspective&&this._projectionMatrix.perspective(this.fov,e,this.near,this.far)}ortho(e,t,r,i){this.near=Math.max(r,.1),this.far=i,this._projectionMatrix.ortho(e,t,r,i),this.type=me.ortho}orthoOffCenter(e,t,r,i,a,s){this.near=Math.max(a,.01),this.far=s,this._projectionMatrix.orthoOffCenter(e,t,r,i,a,s),this.type=me.ortho}orthoZo(e,t,r,i,a,s){this.near=Math.max(a,.01),this.far=s,this._projectionMatrix.orthoZO(e,t,r,i,a,s),this.type=me.ortho}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,t=null){return t||(t=new d(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,Ye.transformVector(this.viewMatrix,e,t),this.project(t,t),t.x=this._halfw+t.x*this._halfw,t.y=this.viewPort.height-(this._halfh-t.y*this._halfh),t}screenRayToObject3D(e,t=null){t||(t=new d),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let r=e.x,i=e.y;return t.x=r/this.viewPort.width-.25,t.y=i/this.viewPort.height-.25,this.unProject(t.x,t.y,e.z,t),t}get pvMatrix(){return ss(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){ss(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,t,r,i){return i||(i=new d),i.x=e,i.y=-t,i.z=r,i.w=1,i.x*=r,i.y*=r,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),Ye.transformVector(this._unprojection,i,i),i.z=r,i}project(e,t){return this._projectionMatrix.perspectiveMultiplyPoint3(e,t),t.x=t.x/t.w,t.y=-t.y/t.w,t.z=e.z,t}screenPointToRay(e,t){let r=this._ray,i=Te.UnProjection(e,t,.01,this),a=Te.UnProjection(e,t,1,this);return a=a.subtract(i).normalize(),r.origin.copyFrom(i),r.direction=a,r}screenPointToWorld(e,t,r){return Te.UnProjection(e,t,r,this)}worldToScreenPoint(e,t){return Te.Projection(e,this,t)}lookAt(e,t,r=d.Y_AXIS){this.transform.lookAt(e,t,r),t&&this.lookTarget.copyFrom(t)}resetProjectMatrix(){this.perspective(this.fov,this.aspect,this.near,this.far)}onUpdate(){this.type==me.perspective&&(this.aspect=I.aspect,this.resetProjectMatrix()),this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let e=m.setting.shadow;this.enableCSM&&this.csm?.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,e)}_haltonSeq;_jitterOffsetList;_useJitterProjection=!1;_jitterFrameIndex=0;_sampleIndex=0;_jitterX=0;_jitterY=0;get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||=new oa,this._jitterOffsetList=[];for(let t=0;t<8;t++){let r=this.generateRandomOffset();this._jitterOffsetList.push(r)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new V(oa.get((this._sampleIndex&1023)+1,2)-.5,oa.get((this._sampleIndex&1023)+1,3)-.5);return++this._sampleIndex>=8&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=m.setting.render.postProcessing.taa,t=this._projectionMatrix,r=e.temporalJitterScale,i=this._jitterFrameIndex%e.jitterSeedCount,a=this._jitterOffsetList[i].x*r,s=this._jitterOffsetList[i].y*r,n=t.get(0,2),l=t.get(1,2);this._jitterX=a/this.viewPort.width,this._jitterY=s/this.viewPort.height,n+=this._jitterX,l+=this._jitterY,t.set(0,2,n),t.set(1,2,l),this._jitterFrameIndex++}getWorldDirection(e){e||=new d;const t=this.transform._worldMatrix.rawData;return e.set(-t[8],-t[9],-t[10]).normalize()}}class st extends _e{static LIMIT=1;static COMPONENT_NAME="UUTransform";static COMPONENT_TYPE="Transform";static POSITION_ONCHANGE="POSITION_ONCHANGE";static ROTATION_ONCHANGE="ROTATION_ONCHANGE";static SCALE_ONCHANGE="SCALE_ONCHANGE";static PARENT_ONCHANGE="PARENT_ONCHANGE";static CHILDREN_ONCHANGE="CHILDREN_ONCHANGE";static ADD_ONCHANGE="ADD_ONCHANGE";static LOCAL_ONCHANGE="LOCAL_ONCHANGE";eventPositionChange=new Ne(st.POSITION_ONCHANGE);eventRotationChange=new Ne(st.ROTATION_ONCHANGE);eventScaleChange=new Ne(st.SCALE_ONCHANGE);eventLocalChange=new Ne(st.LOCAL_ONCHANGE);onPositionChange;onRotationChange;onScaleChange;_scene3d;_parent;_localPos;_localRot;_localRotQuat;_localScale;_localDetailPos;_localDetailRot;_localDetailScale;index;index2;_forward=new d;_back=new d;_right=new d;_left=new d;_up=new d;_down=new d;_worldMatrix;_targetPos;static=!1;depthOrder=0;get localChange(){return $.matrixStateBuffer[this.index2]!=0}set localChange(e){$.matrixStateBuffer[this.index2]=e?1:0}get targetPos(){return this._targetPos}set targetPos(e){this._targetPos=e}get parent(){return this._parent}set parent(e){let t=this._parent?.object3D;if(this._parent=e,this.depthOrder=e?e.depthOrder+1:0,$.setParent(this.index,e?e.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let r=e?e.scene3D:null;r?(this._scene3d=r,this.object3D.components.forEach(i=>{oe.appendWaitStart(i)})):this.object3D.components.forEach(i=>{i.__stop()});for(let i of this.object3D.entityChildren)i.transform.parent=e?this:null;this.object3D.components.forEach(i=>{i.onParentChange?.(t,this._parent?.object3D)})}this.notifyLocalChange()}set enable(e){this.transform._scene3d&&e?super.enable=!0:super.enable=!1;for(let t of this.object3D.entityChildren)t.transform.enable=e}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(e){this._scene3d=e}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}constructor(){super(),this._worldMatrix=new R(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*$.stateStruct,this._localPos=new d,this._localRot=new d,this._localRotQuat=new Y,this._localScale=new d(1,1,1),$.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),$.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),$.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let e=this.object3D.entityChildren,t=0,r=e.length;for(t=0;t<r;t++)e[t].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(d.UP,this._up),this._up}set up(e){this._up.copyFrom(e),Ye.fromToRotation(d.UP,this._up,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0}get down(){return this.worldMatrix.transformVector(d.DOWN,this._down),this._down}set down(e){this._down.copyFrom(e),Ye.fromToRotation(d.DOWN,this._down,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0,this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(d.FORWARD,this._forward),this._forward}set forward(e){this._forward.copyFrom(e),Ye.fromToRotation(d.FORWARD,this._forward,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0,this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(d.BACK,this._back),this._back}set back(e){this._back.copyFrom(e),Ye.fromToRotation(d.BACK,this._back,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0}get left(){return this.worldMatrix.transformVector(d.neg_X_AXIS,this._left),this._left}set left(e){this._left.copyFrom(e),Ye.fromToRotation(d.LEFT,this._left,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0}get right(){return this.worldMatrix.transformVector(d.X_AXIS,this._right),this._right}set right(e){this._right.copyFrom(e),Ye.fromToRotation(d.RIGHT,this._right,Y.HELP_0),this.transform.localRotQuat=Y.HELP_0,this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this._localRotQuat}set localRotQuat(e){(e.x!=this._localRotQuat.x||e.y!=this._localRotQuat.y||e.z!=this._localRotQuat.z||e.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(e),this._localRotQuat.getEulerAngles(this._localRot),$.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){this.notifyLocalChange(),this.onRotationChange?.(),this.onScaleChange?.(),this.onPositionChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(e=!1){(this.localChange||e)&&(this.parent?(aa(this._localRot,this._localPos,this._localScale,this._worldMatrix),Vn(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):aa(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let e=this;if(e.localChange&&e.updateWorldMatrix(),e.object3D.numChildren>0)for(const t of e.object3D.entityChildren)t.transform.updateChildTransform()}lookTarget(e,t=d.UP){this.lookAt(this.transform.worldPosition,e,t)}lookAt(e,t,r=d.UP){this._targetPos||=new d,this._targetPos.copyFrom(t),this.localPosition=e,R.helpMatrix.lookAt(e,t,r),R.helpMatrix.invert();var i=R.helpMatrix.decompose(qt.QUATERNION);this.localRotQuat=Y.CALCULATION_QUATERNION.copyFrom(i[1])}decomposeFromMatrix(e,t="eulerAngles"){let r=e.decompose(t),i=this.transform;return i.localRotQuat.copyFrom(r[1]),i.localRotQuat=i.localRotQuat,i.localPosition.copyFrom(r[0]),i.localPosition=i.localPosition,i.localScale.copyFrom(r[2]),i.localScale=i.localScale,this}cloneTo(e){e.transform.localPosition=this.localPosition,e.transform.localRotation=this.localRotation,e.transform.localScale=this.localScale}set x(e){this._localPos.x!=e&&(this._localPos.x=e,$.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),this.onPositionChange?.(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(e){this._localPos.y!=e&&(this._localPos.y=e,$.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),this.onPositionChange?.(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(e){this._localPos.z!=e&&(this._localPos.z=e,$.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),this.onPositionChange?.(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(e){this._localScale.x!=e&&(this._localScale.x=e,$.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),this.onScaleChange?.(),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(e){this._localScale.y!=e&&(this._localScale.y=e,$.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),this.onScaleChange?.(),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(e){this._localScale.z!=e&&(this._localScale.z=e,$.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),this.onScaleChange?.(),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(e){this._localRot.x!=e&&(this._localRot.x=e,$.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(e){this._localRot.y!=e&&(this._localRot.y=e,$.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(e){this._localRot.z!=e&&(this._localRot.z=e,$.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(e){this._localPos.copyFrom(e),$.setTranslate(this.index,e.x,e.y,e.z),this.notifyLocalChange(),this.onPositionChange?.(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(e){$.setRotation(this.index,e.x,e.y,e.z),this._localRot.copyFrom(e),this.notifyLocalChange(),this.onRotationChange?.(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(e){$.setScale(this.index,e.x,e.y,e.z),this._localScale.copyFrom(e),this.notifyLocalChange(),this.onScaleChange?.(),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(e){this._localDetailScale=e,$.setContinueScale(this.index,e.x,e.y,e.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(e){this._localDetailRot=e,$.setContinueRotation(this.index,e.x,e.y,e.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(e){this._localDetailPos=e,$.setContinueTranslate(this.index,e.x,e.y,e.z)}beforeDestroy(e){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(e)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}}class na{static maxVector=new d(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1);static minVector=this.maxVector.clone().multiplyScalar(-1);static genMeshMaxVector=d.ZERO.clone();static genMeshMinVector=d.ZERO.clone();static genMeshVectorList8=[new d,new d,new d,new d,new d,new d,new d,new d];static genMeshBounds(e,t){let r=this.genMeshMinVector,i=this.genMeshMaxVector,a=this.genMeshVectorList8;t||=new de(d.ZERO,d.ZERO),t.setFromMinMax(this.maxVector,this.minVector);let s=e.getComponents(c.MeshRenderer);for(const n of s)if(n&&n.geometry){let l=n.object3D.transform.worldMatrix;r.copy(n.geometry.bounds.min),i.copy(n.geometry.bounds.max),a[0].set(r.x,r.y,r.z),a[1].set(r.x,r.y,i.z),a[2].set(r.x,i.y,r.z),a[3].set(r.x,i.y,i.z),a[4].set(i.x,r.y,r.z),a[5].set(i.x,r.y,i.z),a[6].set(i.x,i.y,r.z),a[7].set(i.x,i.y,i.z);for(const h of a)l.transformPoint(h,h),t.expandByPoint(h)}return i.copyFrom(t.max),r.copyFrom(t.min),t.setFromMinMax(r,i),t}static transformBound(e,t,r){let i=this.genMeshMinVector.copyFrom(t.min),a=this.genMeshMaxVector.copyFrom(t.max),s=this.genMeshVectorList8;r||=new de(d.ZERO,d.ZERO),r.setFromMinMax(this.maxVector,this.minVector),s[0].set(i.x,i.y,i.z),s[1].set(i.x,i.y,a.z),s[2].set(i.x,a.y,i.z),s[3].set(i.x,a.y,a.z),s[4].set(a.x,i.y,i.z),s[5].set(a.x,i.y,a.z),s[6].set(a.x,a.y,i.z),s[7].set(a.x,a.y,a.z);for(const n of s)e.transformPoint(n,n),r.expandByPoint(n);return a.copyFrom(r.max),i.copyFrom(r.min),r.setFromMinMax(i,a),r}}class Xn extends Xt{name="";_instanceID="";_numChildren;get instanceID(){return this._instanceID}transform;renderNode;entityChildren;components;waitDisposeComponents;_bound;_boundWorld;_isBoundChange=!0;_dispose=!1;getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),i=this;for(;r.length>0&&i;){let a=r.shift();if(i=i.getChildByName(a,!1),!i)return null}return i}else return this.getChildByName(e,!1)}constructor(){super(),this.entityChildren=[],this.components=new Map,this._instanceID=Ya().toString(),this.waitDisposeComponents=[]}get numChildren(){return this._numChildren}addChild(e){if(e==null)throw new Error("child is null!");if(e===this)throw new Error("child is self!");return this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,e):null}removeChild(e){if(e===null)return;if(e===this)throw new Error("add child is self!");let t=this.entityChildren.indexOf(e);t!=-1&&(this.entityChildren.splice(t,1),e.transform.parent=null,this._numChildren=this.entityChildren.length)}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let t=null;return e<this.entityChildren.length&&(t=this.entityChildren[e]),t}getChildByName(e,t=!0){let r=null;for(const i of this.entityChildren){if(i.name==e)return r=i,r;if(t&&(r=i.getChildByName(e,t),r))return r}return r}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new de,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(na.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,t)=>{e.enable=!1,e.beforeDestroy(),e.destroy()}),this.components.clear()):oe.waitStartComponent.forEach((e,t)=>{for(;e.length>0;){const r=e.shift();r.__start(),oe.waitStartComponent.delete(r.object3D)}})}destroy(e){this._dispose||(this.components.forEach(t=>{t.beforeDestroy(e)}),this.components.forEach(t=>{t.destroy(e)}),this.components.clear(),this.entityChildren.forEach(t=>{t.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var td=Object.defineProperty,rd=Object.getOwnPropertyDescriptor,id=(o,e,t,r)=>{for(var i=r>1?void 0:r?rd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&td(e,t,i),i};c.Object3D=class extends Xn{_isScene3D;prefabRef;serializeTag;constructor(){super(),this.transform=this.addComponent(st),this.transform.eventDispatcher.addEventListener(st.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(e){this.entityChildren.forEach(t=>{e(t),t.forChild(e)})}addComponent(e,t){if(!this.components.has(e)){let r=new e;return r.object3D=this,this.components.set(e,r),r.__init(t),oe.appendWaitStart(r),r}return null}getOrAddComponent(e){let t=this.components.get(e);return t||(t=this.addComponent(e)),t}removeComponent(e){if(this.components.has(e)){let t=this.components.get(e);oe.removeWaitStart(this,t),this.components.delete(e),t.__stop(),t.beforeDestroy(),t.destroy()}}hasComponent(e){return this.components.has(e)}getComponent(e){return this.components.get(e)}getComponentFromParent(e){if(!this.parent)return null;let t=this.parent.object3D.getComponent(e);return t||this.parent.object3D.getComponentFromParent(e)}getComponentsInChild(e){let t=[],r=this.components.get(e);r&&t.push(r);for(let i=0;i<this.entityChildren.length;i++){let s=this.entityChildren[i].getComponentsInChild(e);t.push(...s)}return t}getComponents(e,t,r){t||=[];let i=this.getComponent(e);i&&(i.enable||r)&&t.push(i);for(let a=0,s=this.entityChildren.length;a<s;a++){let n=this.entityChildren[a];n&&n instanceof c.Object3D&&n.getComponents(e,t,r)}return t}getComponentsExt(e,t,r){t||=[];let i=this.components.get(e);if(i&&(i.enable||r))t.push(i);else for(const a of this.entityChildren)a instanceof c.Object3D&&a.getComponentsExt(e,t,r);return t}getComponentsByProperty(e,t,r=!0,i,a){i||=[];let s;for(const n of this.components.values())n&&(n.enable||a)&&n[e]===t&&(i.push(n),s=!0);if(!(s&&r))for(const n of this.entityChildren)n instanceof c.Object3D&&n.getComponentsByProperty(e,t,r,i,a);return i}clone(){return this.instantiate()}instantiate(){let e=new c.Object3D;return e.name=this.name,e.serializeTag=this.serializeTag,e.prefabRef=this.prefabRef,this.entityChildren.forEach((t,r)=>{let i=t.instantiate();e.addChild(i)}),this.components.forEach((t,r)=>{t.cloneTo(e)}),e}get localPosition(){return this.transform.localPosition}set localPosition(e){this.transform.localPosition=e}get localRotation(){return this.transform.localRotation}set localRotation(e){this.transform.localRotation=e}get localScale(){return this.transform.localScale}set localScale(e){this.transform.localScale=e}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(e){this.transform.localRotQuat=e}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(e){this.transform.x=e}get x(){return this.transform.x}set y(e){this.transform.y=e}get y(){return this.transform.y}set z(e){this.transform.z=e}get z(){return this.transform.z}set scaleX(e){this.transform.scaleX=e}get scaleX(){return this.transform.scaleX}set scaleY(e){this.transform.scaleY=e}get scaleY(){return this.transform.scaleY}set scaleZ(e){this.transform.scaleZ=e}get scaleZ(){return this.transform.scaleZ}set rotationX(e){this.transform.rotationX=e}get rotationX(){return this.transform.rotationX}set rotationY(e){this.transform.rotationY=e}get rotationY(){return this.transform.rotationY}set rotationZ(e){this.transform.rotationZ=e}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(e){e(this);for(let t=0,r=this.entityChildren.length;t<r;t++){let i=this.entityChildren[t];i instanceof c.Object3D&&i.traverse(e)}}destroy(e){this.transform.eventDispatcher.removeEventListener(st.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(e)}},c.Object3D=id([ad],c.Object3D);function ad(o,e){return class extends c.Object3D{set active(t){this.transform.enable=t>0}get active(){return this.transform.enable?1:0}get materialColor(){return this.getComponent(c.MeshRenderer)?.material?.shader.getDefaultColorShader().baseColor}set materialColor(t){let r=this.getComponent(c.MeshRenderer)?.material;r&&(r.shader.getDefaultColorShader().baseColor=t)}notifyMaterialColorChange(t,r){this.getComponent(c.MeshRenderer).materials?.[t]?.shader.getDefaultColorShader().uniforms[r].onChange()}}}class Te{static createCamera3DObject(e,t){return this.createCamera3D(null,e,t)}static createCamera3D(e,t,r){return e||=new c.Object3D,t&&t.addChild(e),r&&(e.name=r),e.getOrAddComponent(Vr)}static UnProjection(e,t,r=1,i){let a=new d(e,t,0),s=1,n=d.HELP_0,l=I.canvas.offsetLeft,h=I.canvas.offsetTop,u=I.canvas.clientWidth,f=I.canvas.clientHeight;n.x=((a.x-l)*s/u-.5)*2,n.y=-((a.y-h)*s/f-.5)*2,n.z=r;let g=new d(0,0,0),p=R.helpMatrix2;p.copyFrom(i.projectionMatrix),p.invert();let A=R.helpMatrix;return A.identity(),A.multiply(p),A.multiply(i.transform.worldMatrix),A.perspectiveMultiplyPoint3(n,g),g}static Projection(e,t,r){let i=r||new d(0,0,0),a=R.helpMatrix;a.copyFrom(t.viewMatrix),a.multiply(t.projectionMatrix),a.perspectiveMultiplyPoint3(e,i);let s=I.canvas.clientWidth/2,n=I.canvas.clientHeight/2;return i.x=i.x*s+s,i.y=n-i.y*n,i}static UnProjection2(e,t,r,i,a){let s=a||new d(0,0,0),n=R.helpMatrix;n.copyFrom(i.pvMatrixInv);let l=I.canvas.clientWidth/2,h=I.canvas.clientHeight/2;return s.x=(e-l)/l,s.y=(h-t)/h,s.z=r,n.perspectiveMultiplyPoint3(s,s),s}}class ot{static maxNumDirectionShadow=8;static maxNumPointShadow=8;static directionLightList;static pointLightList;static shadowLights;static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowLights=new Map}static createBuffer(e){if(!this.shadowLights.has(e.scene)){let t=new Float32Array(16);this.shadowLights.set(e.scene,t)}}static getShadowLightList(e){if(!e.transform.view3D)return null;if(e.lightData.lightType==Ee.DirectionLight){let t=this.directionLightList.get(e.transform.view3D.scene);return t||(t=[],this.directionLightList.set(e.transform.view3D.scene,t)),t}else if(e.lightData.lightType==Ee.PointLight){let t=this.pointLightList.get(e.transform.view3D.scene);return t||(t=[],this.pointLightList.set(e.transform.view3D.scene,t)),t}else if(e.lightData.lightType==Ee.SpotLight){let t=this.pointLightList.get(e.transform.view3D.scene);return t||(t=[],this.pointLightList.set(e.transform.view3D.scene,t)),t}}static getShadowLightWhichScene(e,t){if(t==Ee.DirectionLight){let r=this.directionLightList.get(e);return r||(r=[],this.directionLightList.set(e,r)),r}else if(t==Ee.PointLight){let r=this.pointLightList.get(e);return r||(r=[],this.pointLightList.set(e,r)),r}}static getDirectShadowLightWhichScene(e){let t=this.directionLightList.get(e);return t||(t=[],this.directionLightList.set(e,t)),t}static getPointShadowLightWhichScene(e){let t=this.pointLightList.get(e);return t||(t=[],this.pointLightList.set(e,t)),t}static addShadowLight(e){if(!e.transform.view3D)return null;let t=e.transform.view3D.scene;if(e.lightData.lightType==Ee.DirectionLight){let r=this.directionLightList.get(t);if(r||(r=[],this.directionLightList.set(t,r)),!e.shadowCamera){e.shadowCamera=Te.createCamera3DObject(null,"shadowCamera"),e.shadowCamera.isShadowCamera=!0;let i=-1e3;e.shadowCamera.orthoOffCenter(i,-i,i,-i,1,1e4)}return r.indexOf(e)==-1&&r.push(e),r}else if(e.lightData.lightType==Ee.PointLight||e.lightData.lightType==Ee.SpotLight){let r=this.pointLightList.get(t);return r&&r.length>=8||(r||(r=[],this.pointLightList.set(t,r)),r.indexOf(e)==-1&&r.push(e)),r}}static removeShadowLight(e){if(e.lightData.castShadowIndex=-1,!e.transform.view3D)return null;if(e.lightData.lightType==Ee.DirectionLight){let t=this.directionLightList.get(e.transform.view3D.scene);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r,1)}return e.lightData.castShadowIndex=-1,t}else if(e.lightData.lightType==Ee.PointLight||e.lightData.lightType==Ee.SpotLight){let t=this.pointLightList.get(e.transform.view3D.scene);if(t){let r=t.indexOf(e);r!=-1&&t.splice(r,1)}return e.lightData.castShadowIndex=-1,t}}static update(e){let t=ae.getCameraGroup(e.camera),r=this.shadowLights.get(e.scene),i=ot.directionLightList.get(e.scene),a=ot.pointLightList.get(e.scene),s=0,n=0,l=0,h=0;if(r.fill(0),i){let u=0;for(let f=0;f<i.length;f++){const g=i[f];r[f]=g.lightData.index,g.lightData.castShadowIndex=u++}n=i.length}if(t.dirShadowStart=s,t.dirShadowEnd=n,a){l=n;let u=0;for(let f=l;f<a.length;f++){const g=a[f];r[f]=g.lightData.index,g.lightData.castShadowIndex=u++}h=l+a.length}t.pointShadowStart=l,t.pointShadowEnd=h,t.shadowLights=r}}class os{static _globalDataBindGroupLayout;static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let e=[];return e.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),e.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=I.device.createBindGroupLayout({entries:e}),this._globalDataBindGroupLayout}}class jn{uuid;usage;globalBindGroup;uniformGPUBuffer;matrixBindGroup;uniformByteLength;matrixesByteLength;shadowMatrixRaw=new Float32Array(8*16);csmMatrixRaw=new Float32Array(At.Cascades*16);csmShadowBias=new Float32Array(4);shadowLights=new Float32Array(16);dirShadowStart=0;dirShadowEnd=0;pointShadowStart=0;pointShadowEnd=0;constructor(e){this.uuid=dt(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new ct(8192),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=e,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=R.blockBytes*R.maxCount,this.globalBindGroup=I.device.createBindGroup({label:"global_bindGroupLayout",layout:os.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",e.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv);let t=ot.getDirectShadowLightWhichScene(e.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let s=0;s<8;s++)if(s<t.length){let n=t[s].shadowCamera;this.shadowMatrixRaw.set(n.pvMatrix.rawData,s*16)}else this.shadowMatrixRaw.set(e.transform.worldMatrix.rawData,s*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=m.setting.shadow.shadowSize;if(At.Cascades>1&&e.enableCSM&&t[0])for(let s=0;s<At.Cascades;s++){let n=e.csm.children[s].shadowCamera;this.csmMatrixRaw.set(n.pvMatrix.rawData,s*16),this.csmShadowBias[s]=e.getCSMShadowBias(s,r)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",ue.frame),this.uniformGPUBuffer.setFloat("time",ue.frame),this.uniformGPUBuffer.setFloat("delta",ue.delta),this.uniformGPUBuffer.setFloat("shadowBias",e.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",m.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",m.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",m.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",m.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",m.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",m.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",m.setting.render.renderState_split);let i=m.inputSystem.mouseX*I.pixelRatio,a=m.inputSystem.mouseY*I.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",i),this.uniformGPUBuffer.setFloat("mouseY",a),this.uniformGPUBuffer.setFloat("windowWidth",I.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",I.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",m.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",m.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",e.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",m.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.setInt32("empty1",0),this.uniformGPUBuffer.setInt32("empty2",0),this.uniformGPUBuffer.setInt32("empty3",0),this.uniformGPUBuffer.setVector4Array("frustumPlanes",e.frustum.planes),this.uniformGPUBuffer.apply()}setShadowCamera(e){this.uniformGPUBuffer.setMatrix("_projectionMatrix",e.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",e.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",e.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",e.projectionMatrixInv),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",e.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",ue.frame),this.uniformGPUBuffer.setFloat("time",ue.frame),this.uniformGPUBuffer.setFloat("delta",ue.delta),this.uniformGPUBuffer.setFloat("shadowBias",m.setting.shadow.shadowBias),this.uniformGPUBuffer.setFloat("skyExposure",m.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",m.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",m.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",m.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",m.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",m.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",m.setting.render.renderState_split);let t=m.inputSystem.mouseX*I.pixelRatio,r=m.inputSystem.mouseY*I.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",t),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",I.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",I.windowHeight),this.uniformGPUBuffer.setFloat("near",e.near),this.uniformGPUBuffer.setFloat("far",e.far),this.uniformGPUBuffer.setFloat("pointShadowBias",m.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",m.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",m.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",m.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.apply()}setShadowLight(){}}class dr{static _v1=new d;static _v2=new d;entities;box;subTrees=[];parent;level;static maxSplitLevel=6;static autoSplitLevel=3;index;uuid;constructor(e,t=0,r=null,i=0){this.parent=r,this.box=e.clone(),this.level=i,this.index=t,this.uuid=i+"_"+t,this.entities=new Map}tryInsertEntity(e){let t=e.renderer.object3D.bound;if(this.level==0||this.box.containsBox(t)){this.subTrees.length==0&&this.level<dr.maxSplitLevel&&this.splitTree();let r;if(this.subTrees.length>0){for(let i of this.subTrees)if(i.tryInsertEntity(e)){r=!0;break}}return r||e.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const e=dr._v1,t=this.box.extents.clone();let r=this.level+1,i=0;for(let a=0;a<2;a++)for(let s=0;s<2;s++)for(let n=0;n<2;n++){const l=new de;this.box.min.add(e.set(a,s,n).multiply(t),l.min),l.min.add(t,l.max),l.setFromMinMax(l.min,l.max);let h=new dr(l,i++,this,r);this.subTrees.push(h)}}}__rayCastTempVector=new d;rayCasts(e,t){if(this.level==0||e.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&t.push(...this.entities.values());for(let r of this.subTrees)r.rayCasts(e,t);return!0}return!1}frustumCasts(e,t){if(this.level==0||e.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>dr.autoSplitLevel||e.containsBox2(r.renderer.object3D.bound)>0)&&t.push(r);for(let r of this.subTrees)r.frustumCasts(e,t);return!0}return!1}getRenderNode(e,t){if(this.level==0||e.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>dr.autoSplitLevel||e.containsBox2(r.renderer.object3D.bound)>0)&&(r.renderer.renderOrder<3e3?t.opaqueList.push(r.renderer):r.renderer.renderOrder>=3e3&&t.transparentList.push(r.renderer));for(let r of this.subTrees)r.getRenderNode(e,t);return!0}return!1}boxCasts(e,t){if(e.intersectsBox(this.box)){this.entities.size>0&&t.push(...this.entities.values());for(let r of this.subTrees)r.boxCasts(e,t);return!0}return!1}clean(){for(let e of this.entities.values())e.leaveNode();return this.entities.clear(),this}}class Wn{_pool=[];_worldPosition=new d;_viewPosition=new d;_zSortList=[];pop(){return this._pool.pop()||{}}recycle(){for(let e of this._zSortList)e.z=0,e.userData=null,e.obj3d=null,this._pool.push(e);this._zSortList.length=0}sort(e,t,r,i){this._zSortList=[];for(let a of t){let s=this.pop();s.userData=a,s.obj3d=r(a),s.z=this.worldToCameraDepth(s.obj3d,e),this._zSortList.push(s)}this._zSortList.sort((a,s)=>a.z-s.z>0?1:-1),i||=[];for(let a of this._zSortList)i.push(a.userData);return this.recycle(),i}worldToCameraDepth(e,t){t||=e.transform.view3D.camera;let r=0;return t&&(this._worldPosition.copyFrom(e.transform.worldPosition),t.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let qn=new Wn;var li=(o=>(o[o.None=2]="None",o[o.StaticBatch=4]="StaticBatch",o[o.DynamicBatch=8]="DynamicBatch",o))(li||{});class ns{static addMask(e,t){return e|t}static removeMask(e,t){return e&~t}static hasMask(e,t){return(e&t)!=0}}var W=(o=>(o[o.COLOR=1]="COLOR",o[o.NORMAL=2]="NORMAL",o[o.POSITION=4]="POSITION",o[o.GRAPHIC=8]="GRAPHIC",o[o.GI=16]="GI",o[o.Cluster=32]="Cluster",o[o.SHADOW=64]="SHADOW",o[o.POINT_SHADOW=128]="POINT_SHADOW",o[o.POST=256]="POST",o[o.DEPTH=512]="DEPTH",o[o.REFLECTION=1024]="REFLECTION",o))(W||{});class Qt{static GLTF_NODE_INDEX_PROPERTY;static BASE_COLOR_UNIFORM="u_baseColorFactor";static BASE_COLOR_TEXTURE_UNIFORM="u_baseColorSampler";static METALROUGHNESS_UNIFORM="u_metallicRoughnessValues";static METALROUGHNESS_TEXTURE_UNIFORM="u_metallicRoughnessSampler";static NORMAL_TEXTURE_UNIFORM="u_normalSampler";static NORMAL_SCALE_UNIFORM="u_normalScale";static EMISSIVE_TEXTURE_UNIFORM="u_emissiveSampler";static EMISSIVE_FACTOR_UNIFORM="u_emissiveFactor";static OCCLUSION_TEXTURE_UNIFORM="u_occlusionSampler";static OCCLUSION_FACTOR_UNIFORM="u_occlusionFactor";static MAX_MORPH_TARGETS=8;static MORPH_POSITION_PREFIX="a_morphPositions_";static MORPH_NORMAL_PREFIX="a_morphNormals_";static MORPH_TANGENT_PREFIX="a_morphTangents_";static MORPH_WEIGHT_UNIFORM="u_morphWeights";static SCENE_ROOT_SKELETON="SCENE_ROOT";static IDENTITY_INVERSE_BIND_MATRICES="IDENTITY_IBM";static JOINT_MATRICES_UNIFORM="u_jointMatrix";static ALPHA_CUTOFF_UNIFORM="u_alphaCutoff"}var M=(o=>(o.position="position",o.normal="normal",o.uv="uv",o.TANGENT="TANGENT",o.TEXCOORD_1="TEXCOORD_1",o.TEXCOORD_2="TEXCOORD_2",o.TEXCOORD_3="TEXCOORD_3",o.TEXCOORD_4="TEXCOORD_4",o.TEXCOORD_5="TEXCOORD_5",o.TEXCOORD_6="TEXCOORD_6",o.TEXCOORD_7="TEXCOORD_7",o.color="color",o.joints0="joints0",o.joints1="joints1",o.weights0="weights0",o.weights1="weights1",o.weight="weight",o.indices="indices",o.vIndex="vIndex",o.a_morphPositions_0="a_morphPositions_0",o.all="all",o))(M||{}),ee=(o=>(o[o.NONE=0]="NONE",o[o.ABOVE=1]="ABOVE",o[o.ALPHA=2]="ALPHA",o[o.NORMAL=3]="NORMAL",o[o.ADD=4]="ADD",o[o.BELOW=5]="BELOW",o[o.ERASE=6]="ERASE",o[o.MUL=7]="MUL",o[o.SCREEN=8]="SCREEN",o[o.DIVD=9]="DIVD",o[o.SOFT_ADD=10]="SOFT_ADD",o))(ee||{}),Kn=(o=>(o[o.src_a=0]="src_a",o[o.dest_a=1]="dest_a",o))(Kn||{});class Jn{static getBlend(e){let t={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(e){case 0:t.color.srcFactor="one",t.color.dstFactor="zero",t.color.operation="add";break;case 1:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="dst-alpha",t.color.operation="add";break;case 4:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="add",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 2:t.color.srcFactor="src-alpha",t.color.dstFactor="one-minus-src-alpha";break;case 5:t.color.srcFactor="one-minus-src-alpha",t.color.dstFactor="one",t.color.operation="add";break;case 6:t.color.srcFactor="zero",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 7:t.color.srcFactor="dst",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 3:t.color.srcFactor="src-alpha",t.color.dstFactor="one-minus-src-alpha",t.color.operation="add";break;case 10:t.color.srcFactor="one",t.color.dstFactor="one",t.color.operation="max",t.alpha.srcFactor="one",t.alpha.dstFactor="one",t.alpha.operation="add";break;case 8:t.color.srcFactor="one",t.color.dstFactor="one-minus-src",t.color.operation="add";break}return t}}class $e{static mipmapShader=`
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`;static pipelineCache={};static pipeline;static getMipmapPipeline(e){let t=e.format,r=I.device,i=$e.pipelineCache[e.format],a;if(!i){a=r.createShaderModule({code:$e.mipmapShader});let s=r.createBindGroupLayout({entries:[{binding:0,visibility:e.visibility,sampler:e.samplerBindingLayout},{binding:1,visibility:e.visibility,texture:e.textureBindingLayout}]}),n=I.device.createPipelineLayout({bindGroupLayouts:[s]});i=w.createPipeline({layout:n,vertex:{module:a,entryPoint:"vertexMain"},fragment:{module:a,entryPoint:"fragmentMain",targets:[{format:t}]}}),$e.pipelineCache[t]=i}return i}static getMipmapCount(e){let t=e.width,r=e.height,i=Math.max(t,r);return 1+Math.log2(i)|0}static webGPUGenerateMipmap(e){let t=I.device,r=e.textureDescriptor;if(!$e.pipeline){const n=t.createShaderModule({code:`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
          return outColor;
        }
      `});$e.pipeline=t.createRenderPipeline({layout:"auto",vertex:{module:n,entryPoint:"vertexMain"},fragment:{module:n,entryPoint:"fragmentMain",targets:[{format:r.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}})}let i;e.format=="rgba16float"?i=t.createSampler({minFilter:"nearest",magFilter:"linear"}):i=t.createSampler({minFilter:kt.linear,magFilter:kt.linear});let a=e.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const s=w.beginCommandEncoder();for(let n=1;n<r.mipLevelCount;++n){const l=e.getGPUTexture().createView({baseMipLevel:n,mipLevelCount:1}),h=s.beginRenderPass({colorAttachments:[{view:l,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),u=t.createBindGroup({layout:$e.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:i},{binding:1,resource:a}]});h.setPipeline($e.pipeline),h.setBindGroup(0,u),h.draw(4),h.end(),a=l}w.endCommandEncoder(s)}}class De{name;url;gpuTexture;pid;view;gpuSampler;gpuSampler_comparison;format;usage;width=4;height=4;depthOrArrayLayers=1;numberLayer=1;viewDescriptor;textureDescriptor;visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT;textureBindingLayout={viewDimension:"2d",multisampled:!1};samplerBindingLayout={type:"filtering"};sampler_comparisonBindingLayout={type:"comparison"};flipY;isVideoTexture;isHDRTexture;_useMipmap=!1;_sourceImageData;_addressModeU;_addressModeV;_addressModeW;_magFilter;_minFilter;_mipmapFilter;_lodMinClamp;_lodMaxClamp;_compare;_maxAnisotropy;mipmapCount=1;_textureChange=!1;constructor(e=32,t=32,r=1){this.width=e,this.height=t,this.numberLayer=r,this.minFilter=kt.linear,this.magFilter=kt.linear,this.mipmapFilter=kt.linear,this.addressModeU=ut.repeat,this.addressModeV=ut.repeat}init(){let e=this;return e.internalCreateBindingLayoutDesc&&e.internalCreateBindingLayoutDesc(),e.internalCreateTexture&&e.internalCreateTexture(),e.internalCreateView&&e.internalCreateView(),e.internalCreateSampler&&e.internalCreateSampler(),this}createTextureDescriptor(e,t,r,i,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,s=1,n=0){this.width=e,this.height=t,this.format=i,this.usage=a,this.textureDescriptor={size:[e,t,s],mipLevelCount:r,format:i,usage:a,label:`${this.name+this.width+this.height+this.format}`},n>0&&(this.textureDescriptor.sampleCount=n),s>1?this.viewDescriptor={dimension:"2d-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension,mipLevelCount:r,baseMipLevel:0}}generate(e){let t=32,r=32;"width"in e&&(t=e.width,r=e.height),(t<32||r<32)&&console.log(e.name+"Size must be greater than 32!"),this.width=t,this.height=r,this.createTexture(e)}createTexture(e){this._sourceImageData=e,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&$e.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(e){if(e){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),$e.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let t=I.device;this.gpuTexture instanceof GPUTexture&&t.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=e,this.noticeChange()}get sourceImageData(){return this._sourceImageData}getMipmapCount(){let e=this.width,t=this.height,r=Math.max(e,t);return 1+Math.log2(r)|0}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?this.getMipmapCount():1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=I.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(e=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}_stateChangeRef=new Map;bindStateChange(e,t){this._stateChangeRef.set(t,e)}unBindStateChange(e){this._stateChangeRef.delete(e)}noticeChange(){this.gpuSampler=I.device.createSampler(this),this._stateChangeRef.forEach((e,t)=>{e()})}destroy(e){e&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(e){this._addressModeU!=e&&(this._addressModeU=e,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(e){this._addressModeV!=e&&(this._addressModeV=e,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(e){this._addressModeW!=e&&(this._addressModeW=e,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(e){this._magFilter!=e&&(this._magFilter=e,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(e){this._minFilter!=e&&(this._minFilter=e,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(e){this._mipmapFilter!=e&&(this._mipmapFilter=e,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(e){this._lodMinClamp!=e&&(this._lodMinClamp=e,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(e){this._lodMaxClamp!=e&&(this._lodMaxClamp=e,this.noticeChange())}get compare(){return this._compare}set compare(e){this._compare!=e&&(this._compare=e,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(e){this._maxAnisotropy!=e&&(this._maxAnisotropy=e,this.noticeChange())}static _texs=[];static delayDestroyTexture(e){this._texs.includes(e)||this._texs.push(e)}static destroyTexture(){if(this._texs.length>0)for(;this._texs.length>0;)this._texs.shift().destroy()}}class Zn extends De{_bitmapTextures;constructor(e,t,r){super(e,t,r),this.format=z.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let t=0;t<e.length;t++){const r=e[t];this.addTexture(r)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture must match bitmapTextureArray size!"),e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture()}removeTexture(e){let t=this._bitmapTextures.indexOf(e);if(t!=-1){this._bitmapTextures.splice(t,1);for(let r=0;r<this._bitmapTextures.length;r++){const i=this._bitmapTextures[r];i.pid=r}}}updateTexture(){let e=w.beginCommandEncoder();for(let t=0;t<this._bitmapTextures.length;t++){let r=this._bitmapTextures[t];e.copyTextureToTexture({texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:t}},{width:this.width,height:this.height,depthOrArrayLayers:1})}w.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=kt.linear,this.magFilter=kt.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=I.device.createSampler(this)}}class Dt{static use=!1;static iesTexture;static ies_list=[];_iesTexture;index=0;constructor(){}generateIES(e){}set IESTexture(e){this._iesTexture=e,e.addressModeU=ut.repeat,e.addressModeV=ut.repeat,e.addressModeW=ut.repeat,Dt.ies_list.indexOf(this)==-1&&(this.index=Dt.ies_list.length,Dt.ies_list.push(this),Dt.iesTexture||Dt.create(e.width,e.height),Dt.iesTexture.addTexture(e))}get IESTexture(){return this._iesTexture}static create(e,t){let r=48;this.iesTexture=new Zn(e,t,r)}}class hi{Type=0;Line=0;Colume=0;Literal="";constructor(e=0,t="\0"){this.Type=e,this.Literal=t}isTypeEqual(e){return this.Type==e}isLiteralEqual(e){return this.Literal==e}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var _=(o=>(o[o.EOF=0]="EOF",o[o.IDENT=1]="IDENT",o[o.VOID=2]="VOID",o[o.CONST=3]="CONST",o[o.LAYOUT=4]="LAYOUT",o[o.PRECISION=5]="PRECISION",o[o.ATTRIBUTE=6]="ATTRIBUTE",o[o.UNIFORM=7]="UNIFORM",o[o.VARYING=8]="VARYING",o[o.INVARIANT=9]="INVARIANT",o[o.IN=10]="IN",o[o.OUT=11]="OUT",o[o.INOUT=12]="INOUT",o[o.IF=13]="IF",o[o.ELSE=14]="ELSE",o[o.FOR=15]="FOR",o[o.WHILE=16]="WHILE",o[o.DO=17]="DO",o[o.BREAK=18]="BREAK",o[o.RETURN=19]="RETURN",o[o.CONTINUE=20]="CONTINUE",o[o.STRUCT=21]="STRUCT",o[o.COMMA=22]="COMMA",o[o.COLON=23]="COLON",o[o.QUEMARK=24]="QUEMARK",o[o.SEMICOLON=25]="SEMICOLON",o[o.LEFTSAMLL=26]="LEFTSAMLL",o[o.RIGHTSAMLL=27]="RIGHTSAMLL",o[o.LEFTMEDI=28]="LEFTMEDI",o[o.RIGHTMEDI=29]="RIGHTMEDI",o[o.LEFTBIG=30]="LEFTBIG",o[o.RIGHTBIG=31]="RIGHTBIG",o[o.LITERAL=32]="LITERAL",o[o.BeginBuiltinType=33]="BeginBuiltinType",o[o.INT=34]="INT",o[o.INT_ARRAY=35]="INT_ARRAY",o[o.UINT=36]="UINT",o[o.UINT_ARRAY=37]="UINT_ARRAY",o[o.BOOL=38]="BOOL",o[o.BOOL_ARRAY=39]="BOOL_ARRAY",o[o.FLOAT=40]="FLOAT",o[o.FLOAT_ARRAY=41]="FLOAT_ARRAY",o[o.DOUBLE=42]="DOUBLE",o[o.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",o[o.VEC2=44]="VEC2",o[o.VEC2_ARRAY=45]="VEC2_ARRAY",o[o.VEC3=46]="VEC3",o[o.VEC3_ARRAY=47]="VEC3_ARRAY",o[o.VEC4=48]="VEC4",o[o.VEC4_ARRAY=49]="VEC4_ARRAY",o[o.BVEC2=50]="BVEC2",o[o.BVEC2_ARRAY=51]="BVEC2_ARRAY",o[o.BVEC3=52]="BVEC3",o[o.BVEC3_ARRAY=53]="BVEC3_ARRAY",o[o.BVEC4=54]="BVEC4",o[o.BVEC4_ARRAY=55]="BVEC4_ARRAY",o[o.IVEC2=56]="IVEC2",o[o.IVEC2_ARRAY=57]="IVEC2_ARRAY",o[o.IVEC3=58]="IVEC3",o[o.IVEC3_ARRAY=59]="IVEC3_ARRAY",o[o.IVEC4=60]="IVEC4",o[o.IVEC4_ARRAY=61]="IVEC4_ARRAY",o[o.UVEC2=62]="UVEC2",o[o.UVEC2_ARRAY=63]="UVEC2_ARRAY",o[o.UVEC3=64]="UVEC3",o[o.UVEC3_ARRAY=65]="UVEC3_ARRAY",o[o.UVEC4=66]="UVEC4",o[o.UVEC4_ARRAY=67]="UVEC4_ARRAY",o[o.MAT2x2=68]="MAT2x2",o[o.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",o[o.MAT2x3=70]="MAT2x3",o[o.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",o[o.MAT2x4=72]="MAT2x4",o[o.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",o[o.MAT3x2=74]="MAT3x2",o[o.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",o[o.MAT3x3=76]="MAT3x3",o[o.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",o[o.MAT3x4=78]="MAT3x4",o[o.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",o[o.MAT4x2=80]="MAT4x2",o[o.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",o[o.MAT4x3=82]="MAT4x3",o[o.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",o[o.MAT4x4=84]="MAT4x4",o[o.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",o[o.SAMPLER=86]="SAMPLER",o[o.SAMPLER_1D=87]="SAMPLER_1D",o[o.SAMPLER_2D=88]="SAMPLER_2D",o[o.SAMPLER_3D=89]="SAMPLER_3D",o[o.SAMPLER_CUBE=90]="SAMPLER_CUBE",o[o.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",o[o.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",o[o.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",o[o.TEXTURE_1D=94]="TEXTURE_1D",o[o.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",o[o.TEXTURE_2D=96]="TEXTURE_2D",o[o.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",o[o.TEXTURE_3D=98]="TEXTURE_3D",o[o.TEXTURE_CUBE=99]="TEXTURE_CUBE",o[o.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",o[o.EndBuiltinType=101]="EndBuiltinType",o[o.BeginOperation=102]="BeginOperation",o[o.ADD=103]="ADD",o[o.SUB=104]="SUB",o[o.MUL=105]="MUL",o[o.DIV=106]="DIV",o[o.AND=107]="AND",o[o.OR=108]="OR",o[o.XOR=109]="XOR",o[o.NOT=110]="NOT",o[o.BITAND=111]="BITAND",o[o.BITOR=112]="BITOR",o[o.BITXOR=113]="BITXOR",o[o.BITNOT=114]="BITNOT",o[o.BITSHIFT_L=115]="BITSHIFT_L",o[o.BITSHIFT_R=116]="BITSHIFT_R",o[o.INC=117]="INC",o[o.DEC=118]="DEC",o[o.GREATER=119]="GREATER",o[o.GREATEREQUAL=120]="GREATEREQUAL",o[o.EQUAL=121]="EQUAL",o[o.LESS=122]="LESS",o[o.LESSEQUAL=123]="LESSEQUAL",o[o.NOTEQUAL=124]="NOTEQUAL",o[o.DOT=125]="DOT",o[o.ASSIGN=126]="ASSIGN",o[o.EndOperation=127]="EndOperation",o[o.BeginAssignOperation=128]="BeginAssignOperation",o[o.ADDASSIGN=129]="ADDASSIGN",o[o.SUBASSIGN=130]="SUBASSIGN",o[o.MULASSIGN=131]="MULASSIGN",o[o.DIVASSIGN=132]="DIVASSIGN",o[o.EndAssignOperation=133]="EndAssignOperation",o))(_||{});class Hr{_char;_line;_column;_source;_currPosition;_nextPosition;constructor(e){this.reset(e)}reset(e){this._char="",this._line=0,this._column=0,this._source=e,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var e=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}isIdentifier(e){var t=e.charCodeAt(0);return 97<=t&&t<=122||65<=t&&t<=90||48<=t&&t<=57||t==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(e){return e===" "||e==="	"||e==="\r"||e===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let e=1;e>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){e++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){e--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(e){var t=e.charCodeAt(0);return 48<=t&&t<=57}readNumber(){for(var e=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(e,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var e=this._currPosition,t=this._source.indexOf(`
`,this._currPosition);return t==-1&&(t=this._source.length),this._line++,this._column=0,this._currPosition=t,this._nextPosition=t+1,this._source.substring(e,t+1)}}class $n extends Hr{_tokenPosition=0;_tokens=[];constructor(e){super(e.source),this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new hi(_.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new hi(_.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=_.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new hi;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=_.EOF,e.Literal="EOF";break;case".":e.Type=_.DOT,e.Literal=".";break;case",":e.Type=_.COMMA,e.Literal=",";break;case":":e.Type=_.COLON,e.Literal=":";break;case"?":e.Type=_.QUEMARK,e.Literal="?";break;case";":e.Type=_.SEMICOLON,e.Literal=";";break;case"(":e.Type=_.LEFTSAMLL,e.Literal="(";break;case")":e.Type=_.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=_.LEFTMEDI,e.Literal="[";break;case"]":e.Type=_.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=_.LEFTBIG,e.Literal="{";break;case"}":e.Type=_.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=_.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=_.ADDASSIGN,e.Literal="+=";break}e.Type=_.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=_.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=_.SUBASSIGN,e.Literal="-=";break}e.Type=_.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=_.MULASSIGN,e.Literal="*=";break}e.Type=_.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=_.DIVASSIGN,e.Literal="/=";break}e.Type=_.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=_.AND,e.Literal="&&";break}e.Type=_.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=_.OR,e.Literal="||";break}e.Type=_.BITOR,e.Literal="&";break;case"^":e.Type=_.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=_.NOTEQUAL,e.Literal="!=";break}e.Type=_.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=_.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=_.BITSHIFT_R,e.Literal=">>";break}e.Type=_.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=_.EQUAL,e.Literal="==";break}e.Type=_.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=_.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=_.BITSHIFT_L,e.Literal="<<";break}e.Type=_.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new hi;e.Line=this._line,e.Colume=this._column,e.Type=_.LITERAL;var t=this.readNumber();return this._char==="e"?(e.Literal=t+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=_.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=_.LITERAL,e.Literal=t+"u",e):this._char==="f"?(this.readChar(),e.Type=_.LITERAL,e.Literal=t+"f",e):(e.Type=_.LITERAL,e.Literal=t,e)}lookupIdentifier(e){switch(e){case"void":return _.VOID;case"int":return _.INT;case"uint":return _.UINT;case"bool":return _.BOOL;case"true":return _.BOOL;case"false":return _.BOOL;case"float":return _.FLOAT;case"vec2":return _.VEC2;case"vec3":return _.VEC3;case"vec4":return _.VEC4;case"bvec2":return _.BVEC2;case"bvec3":return _.BVEC3;case"bvec4":return _.BVEC4;case"ivec2":return _.IVEC2;case"ivec3":return _.IVEC3;case"ivec4":return _.IVEC4;case"uvec2":return _.UVEC2;case"uvec3":return _.UVEC3;case"uvec4":return _.UVEC4;case"mat2":return _.MAT2x2;case"mat2x2":return _.MAT2x2;case"mat2x3":return _.MAT2x3;case"mat2x4":return _.MAT2x4;case"mat3":return _.MAT3x3;case"mat3x2":return _.MAT3x2;case"mat3x3":return _.MAT3x3;case"mat3x4":return _.MAT3x4;case"mat4":return _.MAT4x4;case"mat4x2":return _.MAT4x2;case"mat4x3":return _.MAT4x3;case"mat4x4":return _.MAT4x4;case"sampler":return _.SAMPLER;case"sampler1D":return _.SAMPLER_1D;case"sampler2D":return _.SAMPLER_2D;case"sampler3D":return _.SAMPLER_3D;case"samplerCube":return _.SAMPLER_CUBE;case"samplerShadow":return _.SAMPLER_SHADOW;case"sampler1DShadow":return _.SAMPLER_1D_SHADOW;case"sampler2DShadow":return _.SAMPLER_2D_SHADOW;case"texture1D":return _.TEXTURE_1D;case"texture2D":return _.TEXTURE_2D;case"texture3D":return _.TEXTURE_3D;case"textureCube":return _.TEXTURE_CUBE;case"texture1DArray":return _.TEXTURE_1D_ARRAY;case"texture2DArray":return _.TEXTURE_2D_ARRAY;case"textureCubeArray":return _.TEXTURE_CUBE_ARRAY;case"const":return _.CONST;case"layout":return _.LAYOUT;case"precision":return _.PRECISION;case"attribute":return _.ATTRIBUTE;case"uniform":return _.UNIFORM;case"varying":return _.VARYING;case"invariant":return _.INVARIANT;case"in":return _.IN;case"out":return _.OUT;case"inout":return _.INOUT;case"if":return _.IF;case"else":return _.ELSE;case"for":return _.FOR;case"while":return _.WHILE;case"do":return _.DO;case"break":return _.BREAK;case"return":return _.RETURN;case"continue":return _.CONTINUE;case"struct":return _.STRUCT}return _.IDENT}}class sd{name="";value="";args=[]}class el extends Hr{_result;_skipLine;_definitionTables;constructor(e){super(e),this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var t=this.readIdentifier();if(this.getChar()==="("){let n=new sd;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var r=this.readIdentifier();if(n.args.push(r),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),n.name=t,n.value=this.readLine().trim(),this._definitionTables.set(t,n),this.readCharAndSkipWhitespace()}else{let n=this.readLine().trim();n[0]=="="&&(n=n.substring(1)),this._definitionTables.set(t,n)}break;case"if":let s=this.readLine().trim();if(s=="0"||s=="false"){this._skipLine=!0;break}if(this._definitionTables.has(s)&&(s=this._definitionTables.get(s),s=="0"||s=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var i=this.readIdentifier();this._skipLine=!this._definitionTables.has(i);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var a=this.readLine();if(!this._skipLine){for(let s of this._definitionTables.keys()){let n=a.indexOf(s);if(n!=-1){let l=this._definitionTables.get(s);if(typeof l=="string")a=a.replace(s,l);else{let h=l,u=new Hr(a.substring(n+s.length));if(u.readCharAndSkipWhitespace(),u.getChar()==="("){u.readCharAndSkipWhitespace();for(let A=1;u.getChar()!=="\0"&&A>0;){switch(u.getChar()){case"(":A++;break;case")":A--;break}u.readCharAndSkipWhitespace()}}let f=n,g=f+s.length+u.currPosition,p=a.substring(f,g).trim();if(h.args.length>0){let A=[],v=p.substring(p.indexOf("(")+1,p.lastIndexOf(")")).trim();v.length>0&&(A=this.parseArgs(v));let C=h.value.substring(h.value.indexOf("("));for(let x=0;x<h.args.length;x++)C=C.replace(h.args[x],A[x]);C=h.value.substring(0,h.value.indexOf("("))+C,a=a.replace(p,C)}else a=a.replace(p,h.value)}}}this._result+=a}this.readChar()}}}get source(){return this._result}parseArgs(e){let t=[],r=0,i=new Hr(e),a=i.currPosition;if(i.readCharAndSkipWhitespace(),i.getChar()!=="\0")for(i.readCharAndSkipWhitespace();i.getChar()!=="\0";){switch(i.getChar()){case"(":r++;break;case")":r--;break;case",":if(r==0){let s=e.substring(a,i.currPosition);t.push(s),a=i.currPosition+1}break}i.readCharAndSkipWhitespace()}if(a<i.currPosition){let s=e.substring(a,i.currPosition);t.push(s)}return t}}class tl{result;ASTRoot;_syntax;constructor(e){this.result="",this._syntax=e,this.ASTRoot=e.ASTRoot}generateWGSL(){let e=new ls;var t=new ol;let r=[],i=[],a=[];for(let u of this.ASTRoot.nodes)if(u instanceof di)if(u.scope=="in")if(u.nodes[0]instanceof xe){e.layoutsIn.push(u);let f=new us;f.name=u.nodes[0].name,f.type=u.nodes[0].type,f.locationID=Number.parseInt(u.qualifier.get("location")),t.inputAttribute.push(f)}else if(u.qualifier.has("local_size_x"))e.workGroupSize=u;else throw"not impl";else if(u.scope=="out")if(e.layoutsOut.push(u),u.nodes[0]instanceof xe){let f=new us;f.name=u.nodes[0].name,f.type=u.nodes[0].type,f.locationID=Number.parseInt(u.qualifier.get("location")),t.outputAttribute.push(f)}else throw"not impl";else if(u.scope=="uniform")if(i.push(u),u.nodes[0]instanceof xe){let f=new hs;f.name=u.nodes[0].name,f.type=u.nodes[0].type,f.setID=Number.parseInt(u.qualifier.get("set")),f.bindingID=Number.parseInt(u.qualifier.get("binding")),t.uniformInfo.push(f)}else if(u.nodes[0]instanceof Kt){let f=new hs;f.name="unif"+t.uniformInfo.length.toString(),f.type=u.nodes[0].name,f.setID=Number.parseInt(u.qualifier.get("set")),f.bindingID=Number.parseInt(u.qualifier.get("binding")),t.uniformInfo.push(f)}else throw"not impl";else u.scope=="buffer"&&r.push(u);else a.push(u);e.stage="fragment";let s=0,n=new Hr(""),l=this._syntax.lexer.source,h=new Map;for(;(s=l.indexOf("gl_",s))!=-1;){n.reset(l.substring(s,s+32)),n.readChar();let u=n.readIdentifier();if(s+=u.length,!h.has(u))switch(h.set(u,u),u){case"gl_InstanceID":e.stage="vertex",e.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":e.stage="vertex",e.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),e.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":e.stage="vertex",e.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":e.stage="fragment",e.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":e.stage="fragment",e.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),e.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":e.stage="compute",e.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":e.stage="compute",e.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":e.stage="compute",e.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":e.stage="compute",e.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+u}}for(let u of i)u.nodes[0]instanceof Kt&&(t.sourceCode+=u.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let u of i)t.sourceCode+=u.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let u of r)u.nodes[0]instanceof Kt&&(t.sourceCode+=u.nodes[0].formatToWGSL(e,0),t.sourceCode+=`\r
`);for(let u of r)t.sourceCode+=u.formatToWGSL(e,0);t.sourceCode+=`\r
`;for(let u of a)t.sourceCode+=u.formatToWGSL(e,0),u instanceof xe&&(t.sourceCode+=`;\r
`);return t}}class ls{_stage="fragment";_builtinIn=[];_builtinOut=[];_layoutsIn=[];_layoutsOut=[];_layoutUniformCount=0;_workGroupSize=void 0;_parentContext;_identifierEnv=new Map;constructor(e){this._parentContext=e}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(e){this.parentContext!=null&&(this.parentContext.stage=e),this._stage=e}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(e){if(this.parentContext!=null){this.parentContext.layoutUniformCount=e;return}this._layoutUniformCount=e}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(e){this.parentContext!=null&&(this.parentContext.workGroupSize=e),this._workGroupSize=e}get parentContext(){return this._parentContext}findIdentifier(e){return this._identifierEnv.has(e)?this._identifierEnv.get(e):this._parentContext!=null?this._parentContext.findIdentifier(e):e}addIdentifier(e,t){this._identifierEnv.set(e,t)}hasIdentifier(e){return this._identifierEnv.has(e)}}class ne{nodes=[];constructor(){}addNode(e){this.nodes.push(e)}formatToWGSL(e,t){return""}}class Kt extends ne{name="";fields=[];constructor(e){super(),this.name=e}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTBIG){let t=new Kt(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=_.RIGHTBIG;){let r=xe.parse(e);t.fields.push(r)}return e.peekToken(0).Type==_.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),t}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);r+=i+"struct "+this.name+` {\r
`;for(let a of this.fields)a.arraySize.nodes.length<=0?r+=i+"  "+a.name+": "+xt(a.type)+`,\r
`:a.arraySize.nodes[0]instanceof Zt?r+=i+"  "+a.name+": array<"+xt(a.type)+", "+a.arraySize.nodes[0].value+`>,\r
`:r+=i+"  "+a.name+": array<"+xt(a.type)+", "+a.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return r+=i+`};\r
`,r}}class la extends ne{name;args;body;returnType;constructor(e,t,r,i){super(),this.name=e,this.args=t,this.body=r,this.returnType=i}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==_.VOID)&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.LEFTSAMLL){let t=e.peekToken(0).Literal,r=e.peekToken(1).Literal;e.skipToken(2);let i=new Array;if(e.peekToken(0).Type!=_.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=_.EOF;){if(e.peekToken(0).Type==_.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==_.INOUT||e.peekToken(0).Type==_.IN||e.peekToken(0).Type==_.OUT)&&e.skipToken(1);let s=xe.parse(e);i.push(s),e.peekToken(0).Type==_.COMMA&&e.skipToken(1)}let a=Pt.parse(e);return new la(r,i,a,t)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t),a,s=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":a="ComputeOutput";break;case"vertex":a="VertexOutput";break;case"fragment":a="FragmentOutput";break;default:a="StructOutput";break}if(this.name=="main"&&s){r+="struct "+a+` {\r
`;for(let u of e.layoutsOut)if(u.nodes[0]instanceof xe){let f=u.nodes[0];u.qualifier.size==1&&u.qualifier.has("location")&&(r+="  @location("+u.qualifier.get("location")+") "),r+=f.name+": "+xt(f.type)+`,\r
`,e.addIdentifier(f.name,"stout."+f.name)}let h=e.builtinOut;for(let u of h)r+="  "+u+`,\r
`;r+=`};\r
\r
`}let n="";if(this.name=="main"&&(e.workGroupSize!=null?n+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:n+="@"+e.stage+`\r
`),e=new ls(e),n+=i+"fn "+this.name+"(",this.name!="main"){for(let h=0;h<this.args.length;h++){let u=this.args[h];h>0&&(n+=", "),n+=u.name+": "+xt(u.type),e.addIdentifier(u.name,u.name)}n+=") -> "+xt(this.returnType)}else{let h=e.layoutsIn;for(let f=0;f<h.length;f++){let g=h[f];if(f>0?n+=`,\r
    `:n+=`\r
    `,g.nodes[0]instanceof xe){let p=g.nodes[0];g.qualifier.size==1&&g.qualifier.has("location")&&(n+="@location("+g.qualifier.get("location")+") "),n+=p.name+": "+xt(p.type),e.addIdentifier(p.name,p.name)}}h.length>0&&(n+=`,\r
    `);let u=e.builtinIn;for(let f of u)n+=f+`,\r
    `;s?n+=") -> "+a:n+=") "}let l="";this.name=="main"&&s&&(l+="    var stout: "+a+` ;\r
`);for(let h of this.body.nodes)l+=h.formatToWGSL(e,t+1),!(h instanceof Er)&&!(h instanceof Br)&&!(h instanceof br)&&(l+=`;\r
`);return this.name=="main"&&s&&(l+=`    return stout;\r
`),r+=n+` {\r
`,r+=l,r+=i+`}\r
`,r+=`\r
`,r}}class ha extends ne{args=[];constructor(){super()}static parse(e){if(e.peekToken(0).Type==_.LEFTSAMLL){e.skipToken(1);let t=new ha;for(;e.peekToken(0).Type!=_.EOF;){if(e.peekToken(0).Type==_.RIGHTSAMLL){e.skipToken(1);break}let r=J.parse(e);t.args.push(r),e.peekToken(0).Type==_.COMMA&&e.skipToken(1)}return t}throw"Error parsing function argument table: Unexpected character"}}class Ir extends ne{name;args;constructor(e,t){super(),this.name=e,this.args=t}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==_.LEFTSAMLL){let t=e.peekToken(0).Literal;e.skipToken(1);let r=ha.parse(e);return new Ir(t,r)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof Ir){let a=this.args.args[0].nodes[0];if(a.name=="sampler2D"){r+=i+"textureSample(";for(let s=0;s<a.args.args.length;s++){let n=a.args.args[s];s>0&&(r+=", "),r+=n.formatToWGSL(e,0)}for(let s=1;s<this.args.args.length;s++){let n=this.args.args[s];s>0&&(r+=", "),r+=n.formatToWGSL(e,0)}return r+=")",r}}r+=i+xt(this.name)+"(";for(let a=0;a<this.args.args.length;a++){let s=this.args.args[a];a>0&&(r+=", "),r+=s.formatToWGSL(e,0)}return r+=")",r}}class xe extends ne{type;name;arraySize;hasIn;hasOut;hasConst;constructor(e,t,r=new J){super(),this.type=e,this.name=t,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=r}static parse(e){let t=new xe("",""),r=e.peekToken(0);if(r.Type==_.CONST)e.skipToken(1),t.hasConst=!0;else if(r.Type==_.IN)e.skipToken(1),t.hasIn=!0;else if(r.Type==_.OUT)e.skipToken(1),t.hasOut=!0;else if(r.Type==_.INOUT)e.skipToken(1),t.hasIn=!0,t.hasOut=!0;else if(!r.isDataType())throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.isDataType()&&e.peekToken(1).Type==_.LEFTMEDI){if(t.type=r.Literal,e.skipToken(2),t.arraySize=J.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=_.IDENT)throw"Unexpected";t.name=e.peekToken(0).Literal,e.skipToken(1)}else if(r.isDataType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.LEFTMEDI)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==_.RIGHTMEDI?e.skipToken(1):(t.arraySize=J.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1));else if(r.isDataType()&&e.peekToken(1).Type==_.IDENT)t.type=e.peekToken(0).Literal,t.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+r.Literal+")";if(r=e.peekToken(0),r.Type==_.SEMICOLON)return e.skipToken(1),t;if(r.Type==_.RIGHTSAMLL)return t;if(r.Type==_.ASSIGN){let i=e.peekToken(0);e.skipToken(1);let a=new Jt(t.name),s=J.parse(e);return e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),t.addNode(new gr(i,a,s)),t}else if(r.Type==_.COMMA){for(;e.peekToken(0).Type==_.COMMA&&e.peekToken(1).Type==_.IDENT;){let i=new xe(t.type,e.peekToken(1).Literal);t.addNode(i),e.skipToken(2),e.peekToken(0).Type==_.ASSIGN&&(e.skipToken(-1),i.addNode(J.parse(e)))}return t}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);if(this.hasConst?r+=i+"let ":r+=i+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?r+=this.name+": "+xt(this.type):this.arraySize.nodes[0]instanceof Zt?r+=this.name+": array<"+xt(this.type)+", "+this.arraySize.nodes[0].value+">":r+=this.name+": array<"+xt(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof gr)r+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof J&&this.nodes[0].nodes[0]instanceof gr)r+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof xe){r+=`;\r
`;for(let a of this.nodes)r+=a.formatToWGSL(e,t)+`;\r
`}else r+=`;\r
`;return r}}class br extends ne{expression1;condition;expression2;loopBody;constructor(e,t,r,i){super(),this.expression1=e,this.condition=t,this.expression2=r,this.loopBody=i}static parse(e){if(e.peekToken(0).Type==_.FOR&&e.peekToken(1).Type==_.LEFTSAMLL){e.skipToken(2);let t;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),t=new J):e.peekToken(0).isDataType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.ASSIGN?(t=new xe(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),t.addNode(J.parse(e)),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1)):(t=J.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1));let r;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),r=new J):(r=J.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1));let i;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),i=new J):(i=J.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1);let a;return e.peekToken(0).Type==_.LEFTBIG?a=Pt.parse(e):a=new Pt,new br(t,r,i,a)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);r+=i+"for (",r+=this.expression1.formatToWGSL(e,0)+"; ",r+=this.condition.formatToWGSL(e,0)+"; ",r+=this.expression2.formatToWGSL(e,0)+")",r+=` { \r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Er)&&!(a instanceof Br)&&!(a instanceof br)&&(r+=`;\r
`);return r+=i+`} \r
`,r}}class Br extends ne{conditionExpr;loopBody;constructor(e,t){super(),this.conditionExpr=e,this.loopBody=t}static parse(e){if(e.peekToken(0).Type==_.WHILE){e.skipToken(1),e.peekToken(0).Type==_.LEFTSAMLL&&e.skipToken(1);let t=J.parse(e);e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1);let r=Pt.parse(e);return new Br(t,r)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);r+=i+`loop {\r
`,r+=i+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let a of this.loopBody.nodes)r+=a.formatToWGSL(e,t+1),!(a instanceof Er)&&!(a instanceof Br)&&!(a instanceof br)&&(r+=`;\r
`);return r+=i+`}\r
`,r}}class od extends ne{constructor(){super()}}class Er extends ne{conditionExpr;trueBranch;falseBranch;constructor(e,t,r){super(),this.conditionExpr=e,this.trueBranch=t,this.falseBranch=r}static parse(e){if(e.peekToken(0).Type==_.IF){e.skipToken(1),e.peekToken(0).Type==_.LEFTSAMLL&&e.skipToken(1);let t=J.parse(e),r,i=new Pt;if(e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==_.LEFTBIG?r=Pt.parse(e):(r=new Pt,e.peekToken(0).Type==_.RETURN?r.addNode(ci.parse(e)):r.addNode(J.parse(e))),e.peekToken(0).Type==_.ELSE)if(e.skipToken(1),e.peekToken(0).Type==_.LEFTBIG)i=Pt.parse(e);else throw"not impl";return new Er(t,r,i)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);r+=i+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let a of this.trueBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`;if(this.falseBranch.nodes.length>0){r+=i+`} else {\r
`;for(let a of this.falseBranch.nodes)r+=a.formatToWGSL(e,t+1)+`;\r
`}return r+=i+`}\r
`,r}}class J extends ne{constructor(){super()}static parse(e){let t=new Array,r=new Array,i=0;for(;e.peekToken(0).Type!=_.EOF;){let a=e.peekToken(0);if(a.Type==_.SEMICOLON||a.Type==_.RIGHTMEDI||a.Type==_.COMMA||a.Type==_.COLON||a.Type==_.RIGHTBIG)break;if(a.isOperation()){if(a.isOperation()){if(a.Type==_.INC||a.Type==_.DEC){let s=a;e.skipToken(1);let n=J.parse(e);r.push(new Yr(s,void 0,n));continue}else if(t.length>0){if(t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel)J.unionOperation(t,r);else if(t.length>0&&t[t.length-1].Literal=="-"){let n=t.pop(),l=r.pop();r.push(new Yr(n,void 0,l))}}t.push(a),e.skipToken(1)}}else if(a.Type==_.LITERAL){r.push(new Zt(a.Literal)),e.skipToken(1);continue}else if(a.Type==_.LEFTSAMLL){i++,t.push(a),e.skipToken(1);continue}else if(a.Type==_.RIGHTSAMLL){if(i<=0)break;for(i--;J.unionOperation(t,r););if(t[t.length-1].Type==_.LEFTSAMLL){t.pop();let s=new rl;s.addNode(r.pop()),r.push(s)}e.skipToken(1);continue}else if(a.Type==_.IDENT){if(e.peekToken(1).Type==_.INC||e.peekToken(1).Type==_.DEC){let s=e.peekToken(1),n=new Jt(a.Literal);r.push(new Yr(s,n,void 0)),e.skipToken(2);continue}else if(e.peekToken(1).Type==_.LEFTSAMLL){r.push(Ir.parse(e));continue}else if(e.peekToken(1).Type==_.DOT){r.push(fi.parse(e));continue}else if(e.peekToken(1).Type==_.LEFTMEDI){r.push(Tr.parse(e));continue}r.push(new Jt(a.Literal)),e.skipToken(1);continue}else{if(a.isBuiltinType()&&e.peekToken(1).Type==_.LEFTSAMLL){r.push(Ir.parse(e));continue}if(a.isAssignOperation()){let s=a;e.skipToken(1);let n=r.pop(),l=J.parse(e);r.push(new gr(s,n,l));continue}if(a.Type==_.LEFTBIG&&(e.peekToken(1).Type==_.LITERAL||e.peekToken(1).Type==_.SUB&&e.peekToken(2).Type==_.LITERAL)){r.push(ui.parse(e));continue}if(a.Type==_.QUEMARK){t.length>0&&t[t.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel&&J.unionOperation(t,r),e.skipToken(1);let s=r.pop(),n=J.parse(e);e.peekToken(0).Type==_.COLON&&e.skipToken(1);let l=J.parse(e);if(r.push(new il(s,n,l)),e.peekToken(-1).Type==_.SEMICOLON)break;continue}if(a.Type==_.LEFTMEDI){e.skipToken(1);let s=J.parse(e);e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1);let n=r.pop();r.push(new Tr(n,s));continue}throw"An unexpected character"}}for(;t.length>0&&J.unionOperation(t,r););if(t.length<=0&&r.length==1){let a=new J;return a.addNode(r.pop()),a}throw"Error parsing expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,t){return this.nodes[0].formatToWGSL(e,t)}static unionOperation(e,t){if(e.length<0||t.length<2){if(e.length>0&&e[e.length-1].Literal=="-"){let r=e.pop(),i=t.pop();return t.push(new Yr(r,void 0,i)),!0}return!1}if(e[e.length-1].isOperation()){let r=t.pop(),i=e.pop(),a=t.pop();return i.Type==_.DOT?t.push(new fi(a,r)):t.push(new gr(i,a,r)),!0}return!1}}class rl extends ne{constructor(){super()}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+"("+this.nodes[0].formatToWGSL(e,0)+")"}}class Jt extends ne{name;constructor(e){super(),this.name=e}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+e.findIdentifier(this.name)}}class Zt extends ne{value;constructor(e){super(),this.value=e}static parse(e){let t=e.peekToken(0);if(t.Type==_.SUB&&e.peekToken(1).Type==_.LITERAL){let r=new Zt("-"+e.peekToken(1).Literal);return e.skipToken(2),r}else if(t.Type==_.LITERAL){let r=new Zt(t.Literal);return e.skipToken(1),r}throw"Error parsing literal constants: Unexpected characters("+t.Literal+")"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.value}}class ui extends Zt{arrayValue;constructor(e){super(""),this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==_.LEFTBIG&&e.peekToken(1).Type==_.LITERAL||e.peekToken(0).Type==_.LEFTBIG&&e.peekToken(1).Type==_.SUB&&e.peekToken(2).Type==_.LITERAL){e.skipToken(1);let t=[];for(;e.peekToken(0).Type!=_.RIGHTBIG;){if(e.peekToken(0).Type==_.LEFTSAMLL){t.push(ui.parse(e));continue}if(t.push(Zt.parse(e)),e.peekToken(0).Type==_.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==_.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new ui(t)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);this.arrayValue[0].value.includes(".")?r+=i+"array<f32, "+this.arrayValue.length.toString()+">(":r+=i+"array<i32, "+this.arrayValue.length.toString()+">(";for(let a=0;a<this.arrayValue.length;a++)a>0&&(r+=", "),r+=this.arrayValue[a].formatToWGSL(e,0);return r+=")",r}}class nd extends ne{constructor(){super()}}class ld extends ne{constructor(){super()}}class ua extends ne{constructor(){super()}static parse(e){if(e.peekToken(0).Type==_.CONTINUE&&e.peekToken(1).Type==_.SEMICOLON)return e.skipToken(2),new ua;throw"Error parsing continue: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);return r+=i+"continue",r}}class ci extends ne{value;constructor(e){super(),this.value=e}static parse(e){if(e.peekToken(0).Type==_.RETURN){e.skipToken(1);let t=J.parse(e);return e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),new ci(t)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);return r+=i+"return "+this.value.formatToWGSL(e,0),r}}class Yr extends ne{op;leftValue;rightValue;constructor(e,t,r){super(),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let a=this.leftValue.formatToWGSL(e,0);r+=i+a+" = "+a+" "+this.op.Literal[0]+" 1"}else{let a=this.rightValue.formatToWGSL(e,0);r+=i+a+" = "+a+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?r+=i+this.leftValue.formatToWGSL(e,0)+this.op.Literal:r+=i+this.op.Literal+this.rightValue.formatToWGSL(e,0);return r}}class gr extends ne{op;leftValue;rightValue;constructor(e,t,r){super(),this.op=e,this.leftValue=t,this.rightValue=r}formatToWGSL(e,t){let r="",i=t<=0?"":"    ".repeat(t);return r+=i+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),r}}class il extends ne{condition;expression1;expression2;constructor(e,t,r){super(),this.condition=e,this.expression1=t,this.expression2=r}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,t){return""}}class fi extends ne{leftValue;rightValue;constructor(e,t){super(),this.leftValue=e,this.rightValue=t}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.DOT&&e.peekToken(2).Type==_.IDENT){let t=new Jt(e.peekToken(0).Literal),r=new Jt(e.peekToken(2).Literal);return e.skipToken(3),new fi(t,r)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Tr extends ne{leftValue;indexValue;constructor(e,t){super(),this.leftValue=e,this.indexValue=t}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTMEDI){let t=new Jt(e.peekToken(0).Literal);e.skipToken(2);let r=J.parse(e);e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1);let i=new Tr(t,r);for(;e.peekToken(0).Type==_.LEFTMEDI;)e.skipToken(1),r=J.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1),i=new Tr(i,r);return i}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,t){return(t<=0?"":"    ".repeat(t))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class Pt extends ne{constructor(){super()}static parse(e){if(e.peekToken(0).Type==_.LEFTBIG){e.skipToken(1);let t=new Pt;for(let r=1;r>0&&e.peekToken(0).Type!=_.EOF;){let i=e.peekToken(0);if(i.Type==_.LEFTBIG){r++,e.skipToken(1);continue}if(i.Type==_.RIGHTBIG){r--,e.skipToken(1);continue}if(i.Type==_.SEMICOLON){e.skipToken(1);continue}if(i.isDataType()&&e.peekToken(1).Type==_.IDENT){t.addNode(xe.parse(e));continue}if(i.Type==_.CONST&&e.peekToken(1).isDataType()&&e.peekToken(2).Type==_.IDENT){t.addNode(xe.parse(e));continue}else if(i.Type==_.IDENT&&e.peekToken(1).Type==_.ASSIGN){t.addNode(J.parse(e)),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1);continue}else if(i.Type==_.IDENT&&e.peekToken(1).Type==_.LEFTMEDI){let a=Tr.parse(e);if(e.peekToken(0).Type==_.ASSIGN){let s=e.peekToken(0);e.skipToken(1);let n=J.parse(e);e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1),t.addNode(new gr(s,a,n));continue}t.addNode(a);continue}else if(i.Type==_.IDENT&&e.peekToken(1).Type==_.DOT){let a=J.parse(e);t.addNode(a);continue}else if(i.Type==_.IDENT&&e.peekToken(1).isAssignOperation()){let a=e.peekToken(1),s=new Jt(i.Literal);e.skipToken(2);let n=J.parse(e);e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),t.addNode(new gr(a,s,n));continue}else if(i.Type==_.IDENT&&(e.peekToken(1).Type==_.INC||e.peekToken(1).Type==_.DEC)&&e.peekToken(2).Type==_.SEMICOLON){let a=e.peekToken(1);t.addNode(new Yr(a,new Jt(i.Literal),void 0)),e.skipToken(3);continue}else if(i.Type==_.RETURN){t.addNode(ci.parse(e));continue}else if(i.Type==_.CONTINUE){t.addNode(ua.parse(e));continue}else if(i.Type==_.WHILE){t.addNode(Br.parse(e));continue}else if(i.Type==_.FOR){t.addNode(br.parse(e));continue}else if(i.Type==_.IF){t.addNode(Er.parse(e));continue}else if(i.Type==_.IDENT&&e.peekToken(1).Type==_.LEFTSAMLL){t.addNode(Ir.parse(e)),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+i.Literal+")"}return t}throw"Error parsing block: Unexpected symbol"}}class ca extends ne{type;qualifier;constructor(e,t){super(),this.type=t,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==_.PRECISION&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).isBuiltinType()){let t=new ca(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),t}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,t){return""}}class di extends ne{scope="";qualifier=new Map;constructor(){super()}addQualifier(e,t=""){this.qualifier.set(e,t)}static parse(e){if(e.peekToken(0).Type==_.LAYOUT&&e.peekToken(1).Type==_.LEFTSAMLL){let t=new di;e.skipToken(2);do if(e.peekToken(0).Type==_.IDENT){if(e.peekToken(1).Type==_.ASSIGN&&e.peekToken(2).Type==_.LITERAL){let i=e.peekToken(0).Literal,a=e.peekToken(2).Literal;if(t.addQualifier(i,a),e.skipToken(3),e.peekToken(0).Type==_.COMMA){e.skipToken(1);continue}let s=e.peekToken(0);s.Line=0}else if(e.peekToken(1).Type==_.RIGHTSAMLL){let i=e.peekToken(0).Literal;t.addQualifier(i,""),e.skipToken(1);break}else if(e.peekToken(1).Type==_.COMMA){let i=e.peekToken(0).Literal;t.addQualifier(i,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=_.RIGHTSAMLL);if(e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1),t.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==_.SEMICOLON)return e.skipToken(1),t;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.SEMICOLON){let r=new xe(e.peekToken(0).Literal,e.peekToken(1).Literal);return t.addNode(r),e.skipToken(3),t}else if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTBIG){let r=Kt.parse(e);return t.addNode(r),e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.SEMICOLON&&(r.addNode(new xe(r.name,e.peekToken(0).Literal)),e.skipToken(2)),t}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,t){let r="";if(this.qualifier.size==1&&this.qualifier.has("location"))r+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))r+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))r+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))r+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))r+="@workgroup_size(",r+=this.qualifier.get("local_size_x")+", ",r+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",r+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",r+=")";else if(this.nodes.length<=0)return"";let i=this.nodes[0];if(i instanceof xe){switch(i.type){case"sampler":case"texture2D":r+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ";break}e.addIdentifier(i.name,i.name),r+=i.name+": "+xt(i.type)+`;\r
`}else if(i instanceof Kt){if(this.scope=="buffer"?e.stage=="compute"?r+="var<storage, read_write> ":r+="var<storage, read> ":r+="var<"+this.scope+"> ",i.nodes.length<=0){let a="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(a);)e.layoutUniformCount++,a="unif"+e.layoutUniformCount.toString();for(let s of i.fields)e.addIdentifier(s.name,a+"."+s.name);r+=a+": "+i.name+`;\r
`,e.layoutUniformCount++}else{let a=i.nodes[0];r+=a.name+": "+a.type+`;\r
`}return r}return r}}function xt(o){switch(o){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return o}class al{_lexer;_rootNode;constructor(e){this._lexer=e,this._rootNode=new ne,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==_.EOF;){if(this.peekToken(0).Type==_.SEMICOLON){this.skipToken(1);continue}let e=this.parseStatement();e!==null&&this._rootNode.addNode(e)}}parseStatement(){let e=this.peekToken();if(e.Type==_.LAYOUT&&this.peekToken(1).Type==_.LEFTSAMLL)return di.parse(this._lexer);if(e.Type==_.STRUCT)return this.skipToken(1),Kt.parse(this._lexer);if((e.isBuiltinType()||e.Type==_.VOID)&&this.peekToken(1).Type==_.IDENT&&this.peekToken(2).Type==_.LEFTSAMLL)return la.parse(this._lexer);if(e.Type==_.CONST&&this.peekToken(1).isDataType())return xe.parse(this._lexer);if(e.isDataType()&&this.peekToken(1).Type==_.IDENT)return xe.parse(this._lexer);if(e.Type==_.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==_.IDENT)return xe.parse(this._lexer);if(e.Type==_.PRECISION)return ca.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(e){this._lexer.skipToken(e)}peekToken(e=0){return this._lexer.peekToken(e)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class sl{static VertexShader="VertexShader";static FragmentShader="FragmentShader";static convertGLSL(e){var t=new el(e),r=new $n(t),i=new al(r),a=new tl(i);return a.generateWGSL()}}class hs{setID=0;bindingID=0;name="";type=""}class us{name="";type="";locationID=0;builtinName="";isBuiltinAttribute(){return this.builtinName!=""}}class ol{uniformInfo=[];inputAttribute=[];outputAttribute=[];sourceCode=""}var Mt=(o=>(o[o.vertex=0]="vertex",o[o.fragment=1]="fragment",o[o.computer=2]="computer",o))(Mt||{});class nl{blendMode=ee.NONE;depthCompare=zt.less;depthWriteEnabled=!0;frontFace="ccw";cullMode=at.back;topology=ii.triangle_list;depthBias=10;useLight=!1;useProbe=!1;acceptGI=!1;acceptShadow=!1;castShadow=!1;castReflection=!1;receiveEnv=!1;renderLayer=1e3;renderOrder=2e3;unclippedDepth=!1;transparent=!1;multisample=0;label;useZ=!0;splitTexture=!1;alphaCutoff;useFragDepth=!1;writeMasks=[];setFromMapValues(e){e.has("blendMode")&&(this.blendMode=this.convertBlendMode(e.get("blendMode"))),e.has("depthCompare")&&(this.depthCompare=e.get("depthCompare")),e.has("depthWriteEnabled")&&(this.depthWriteEnabled=e.get("depthWriteEnabled")),e.has("frontFace")&&(this.frontFace=e.get("frontFace")),e.has("cullMode")&&(this.cullMode=e.get("cullMode")),e.has("topology")&&(this.topology=e.get("topology")),e.has("depthBias")&&(this.depthBias=e.get("depthBias")),e.has("useLight")&&(this.useLight=e.get("useLight")),e.has("useProbe")&&(this.useProbe=e.get("useProbe")),e.has("acceptGI")&&(this.acceptGI=e.get("acceptGI")),e.has("acceptShadow")&&(this.acceptShadow=e.get("acceptShadow")),e.has("castShadow")&&(this.castShadow=e.get("castShadow")),e.has("receiveEnv")&&(this.receiveEnv=e.get("receiveEnv")),e.has("renderLayer")&&(this.renderLayer=e.get("renderLayer")),e.has("renderOrder")&&(this.renderOrder=e.get("renderOrder")),e.has("unclippedDepth")&&(this.unclippedDepth=e.get("unclippedDepth")),e.has("multisample")&&(this.multisample=e.get("multisample")),e.has("label")&&(this.label=e.get("label")),e.has("useZ")&&(this.useZ=e.get("useZ"))}convertBlendMode(e){switch(e){case"ABOVE":return ee.ABOVE;case"ALPHA":return ee.ALPHA;case"NORMAL":return ee.NORMAL;case"ADD":return ee.ADD;case"BELOW":return ee.BELOW;case"ERASE":return ee.ERASE;case"MUL":return ee.MUL;case"SCREEN":return ee.SCREEN;case"DIVD":return ee.DIVD;case"SOFT_ADD":return ee.SOFT_ADD}return ee.NONE}}class ll extends Wt{uniformNodes=[];_onChange=!0;constructor(){super(),this.bufferType=Et.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let t=0;for(const r in e){const i=e[r];i||console.error(r,"is empty"),t+=i.size*4}t=Math.floor(t/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,t/4,null,"MaterialDataUniformGPUBuffer");for(const r in e){const i=e[r];i||console.error(r,"is empty");let a=this.memory.allocation_node(i.size*4);i.memoryInfo=a,i.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class $t{static renderShaderModulePool;static renderShader;static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}class te{reference;static _ins;static getInstance(){return this._ins||=new te,this._ins}attached(e,t){this.reference||=new Map;let r=this.reference.get(e);r||=new Map,r.set(t,e),this.reference.set(e,r)}detached(e,t){let r=this.reference.get(e);r&&r.delete(t)}hasReference(e){let t=this.reference.get(e);return t?t.size>0:!1}getReferenceCount(e){let t=this.reference.get(e);return t?t.size:0}getReference(e){let t=this.reference.get(e);return t||null}}class cs{static pipelineMap=new Map;static getSharePipeline(e){let t=this.pipelineMap.get(e);return t||null}static setSharePipeline(e,t){this.pipelineMap.set(e,t)}}class Ae extends Xa{passType=W.COLOR;useRz=!1;vsName;fsName;shaderState;textures;pipeline;bindGroupLayouts;envMap;prefilterMap;_sourceVS;_sourceFS;_destVS;_destFS;_vsShaderModule;_fsShaderModule;_textureGroup=-1;_textureChange=!1;_groupsShaderReflectionVarInfos;outBufferMask;constructor(e,t){super(),this.vsName=e.toLowerCase(),this.fsName=t.toLowerCase(),this.vsName in F||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in F||console.error("Shader Not Register, Please Register Shader!",this.fsName),F[this.vsName]&&(this._sourceVS=F[this.vsName]),F[this.fsName]&&(this._sourceFS=F[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new nl,this.materialDataUniformBuffer=new ll,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==at.none}set doubleSide(e){let t=e?at.none:this.cullMode;this.shaderState.cullMode!=t&&(this._valueChange=!0),this.shaderState.cullMode=t}get depthWriteEnabled(){return this.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.shaderState.depthWriteEnabled!=e&&(this._valueChange=!0),this.shaderState.depthWriteEnabled=e}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=ee.NORMAL&&e!=ee.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",t=""){this.vsEntryPoint=e,this.fsEntryPoint=t}setUniform(e,t){super.setUniform(e,t),this.materialDataUniformBuffer.onChange()}setTexture(e,t){t&&this.textures[e]!=t&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=t,e=="envMap"?this.envMap=t:e=="prefilterMap"&&(this.prefilterMap=t),t.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,t){let r=this.createGroupLayouts();this.createPipeline(e,t,r)}reBuild(e,t){this.compileShader(Mt.vertex,this._destVS,t),this.compileShader(Mt.fragment,this._destFS,t),this.genRenderPipeline(e,t)}apply(e,t,r){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=He.genRenderShaderVariant(this),this.reBuild(e,t),this._valueChange=!1,r&&r())}preCompile(e){this.preDefine(e),this.preCompileShader(Mt.vertex,this._sourceVS.concat()),this.preCompileShader(Mt.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,t){return t.renderTargetTextures.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),Tt.parse(e,this.defineValue)}setBindGroup(e,t){this.bindGroups[e]=t}checkBuffer(e,t){}preCompileShader(e,t,r){let i=t;if(i.indexOf("version ")!=-1){var a=sl.convertGLSL(i);i=a.sourceCode}for(const s in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,s)){const n=this.constValues[s];i=i.replaceAll(`&${s}`,n.toString())}switch(e){case Mt.vertex:this._destVS=i;break;case Mt.fragment:this._destFS=i;break}}compileShader(e,t,r){let i=t;i=this.applyPostDefine(i,r);let a=t;for(let n in this.defineValue)a+=`${n}=${this.defineValue[n]},`;let s=$t.renderShaderModulePool.get(a);switch(s||(i=this.applyPostDefine(i,r),s=I.device.createShaderModule({label:e==Mt.vertex?this.vsName:this.fsName,code:i}),s.getCompilationInfo().then(n=>{n.messages.length>0&&(console.log(i),console.log(n))}),$t.renderShaderModulePool.set(a,s)),e){case Mt.vertex:this._vsShaderModule=s,this._destVS=i;break;case Mt.fragment:this._fsShaderModule=s,this._destFS=i;break}}getGroupLayout(e,t){let r=[];for(let i=0;i<t.length;i++){const a=t[i];if(a)if(a.varType=="uniform"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let s=this._bufferDic.get(a.varName).visibility,n={binding:a.binding,visibility:s,buffer:{type:"uniform"}};r.push(n)}else if(a.varType=="storage-read"){this._bufferDic.has(a.varName)||console.error(`not set ${a.varName} buffer`);let s=this._bufferDic.get(a.varName).visibility,n={binding:a.binding,visibility:s,buffer:{type:"read-only-storage"}};r.push(n)}else if(a.varType=="var")switch(a.dataType){case"sampler":{let s=a.varName.replace("Sampler",""),n=this.textures[s]?this.textures[s]:m.res.redTexture,l={binding:a.binding,visibility:n.visibility,sampler:n.samplerBindingLayout};r.push(l),this._textureGroup=e}break;case"sampler_comparison":{let s=a.varName.replace("Sampler",""),n=this.textures[s]?this.textures[s]:m.res.redTexture,l={binding:a.binding,visibility:n.visibility,sampler:n.sampler_comparisonBindingLayout};r.push(l),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let s=this.textures[a.varName]?this.textures[a.varName]:m.res.redTexture,n={binding:a.binding,visibility:s.visibility,texture:s.textureBindingLayout};r.push(n),this._textureGroup=e,te.getInstance().attached(s,this)}break;case"texture_external":{let s=this.textures[a.varName]?this.textures[a.varName]:m.res.redTexture,n={binding:a.binding,visibility:s.visibility,externalTexture:{}};r.push(n),this._textureGroup=e,te.getInstance().attached(s,this)}break;default:{let s=this.textures[a.varName]?this.textures[a.varName]:m.res.redTexture,n={binding:a.binding,visibility:s.visibility,texture:s.textureBindingLayout};r.push(n),this._textureGroup=e,te.getInstance().attached(s,this)}break}else{debugger;console.error("bind group can't empty")}}return r}_cacheEntries;genGroups(e,t,r=!1){if(!this.bindGroups[e]||r){const i=t[e];let a=[];for(let n=0;n<i.length;n++){const l=i[n];if(l){if(l.varType=="uniform"){let h=this._bufferDic.get(l.varName);if(h){if(h.bufferType==Et.MaterialDataUniformGPUBuffer){let f=[];for(let g=0;g<l.dataFields.length;g++){const p=l.dataFields[g];this.uniforms[p.name]||console.error(`shader-${this.vsName}:${this.fsName} ${p.name}is empty`),f.push(this.uniforms[p.name])}this.materialDataUniformBuffer.initDataUniform(f)}let u={binding:l.binding,resource:{buffer:h.buffer,offset:0,size:h.memory.shareDataBuffer.byteLength}};a.push(u),this.checkBuffer(l.varName,h)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${l.varName} is missing!`)}else if(l.varType=="storage-read"){let h=this._bufferDic.get(l.varName);if(h){let u={binding:l.binding,resource:{buffer:h.buffer,offset:0,size:h.memory.shareDataBuffer.byteLength}};a.push(u),this.checkBuffer(l.varName,h)}else console.error(`buffer ${l.varName} is missing!`)}else if(l.varType=="var")if(l.dataType=="sampler"){let h=l.varName.replace("Sampler",""),u=this.textures[h];if(u||(u=m.res.blackTexture,this.setTexture(h,u)),u){let f={binding:l.binding,resource:u.gpuSampler};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${l.varName} is missing! `)}else if(l.dataType=="sampler_comparison"){let h=l.varName.replace("Sampler",""),u=this.textures[h];if(u){let f={binding:l.binding,resource:u.gpuSampler_comparison};a.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${l.varName} is missing! `)}else{let h=this.textures[l.varName];if(h||(h=m.res.whiteTexture,this.setTexture(l.varName,h)),h){let u={binding:l.binding,resource:h.getGPUView()};a.push(u)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${l.varName} is missing! `)}}}let s=I.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:a});this.bindGroups[e]=s}}createPipeline(e,t,r){let i=e,a=this.shaderState,s=[];for(const h of t.renderTargetTextures)s.push({format:h.format});for(let h=0;h<s.length;h++){const u=s[h];a.writeMasks&&a.writeMasks.length>0&&(u.writeMask=a.writeMasks[h])}if(t.outColor!=-1){let h=s[t.outColor];a.blendMode!=ee.NONE?h.blend=Jn.getBlend(a.blendMode):delete h.blend}let n={label:this.vsName+"|"+this.fsName,layout:r,primitive:{topology:a.topology,cullMode:a.cullMode,frontFace:a.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(n.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:i.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(n.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:s}),a.multisample>0&&(n.multisample={count:a.multisample}),(t.zPreTexture||t.depthTexture)&&(a.blendMode!=ee.NONE,m.setting.render.zPrePass&&t.zPreTexture&&a.useZ?n.depthStencil={depthWriteEnabled:!1,depthCompare:zt.less,format:t.zPreTexture.format}:n.depthStencil={depthWriteEnabled:a.depthWriteEnabled,depthCompare:a.depthCompare,format:t.depthTexture.format});let l=cs.getSharePipeline(this.shaderVariant);l?this.pipeline=l:(this.pipeline=w.createPipeline(n),cs.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[os.getGlobalDataBindGroupLayout()];for(let r=1;r<e.groups.length;r++){let i=e.groups[r];if(i){let a=this.getGroupLayout(r,i);this._groupsShaderReflectionVarInfos[r]=i;let s=I.device.createBindGroupLayout({entries:a,label:`vs${this.vsName} fs${this.fsName} ${i.length}`});this.bindGroupLayouts[r]=s}else console.error("can't set empty group!",r)}let t=I.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),t}preDefine(e){let t=e.hasAttribute(M.TEXCOORD_1),r=e.hasAttribute(M.joints0),i=e.hasAttribute(M.a_morphPositions_0),a=e.hasAttribute(M.TANGENT),s=e.hasAttribute(M.color),n=this.shaderState.acceptGI,l=this.shaderState.useLight;t&&(this.defineValue.USE_SECONDUV=!0),r&&i?this.defineValue.USE_METAHUMAN=!0:(this.defineValue.USE_SKELETON=r,this.defineValue.USE_MORPHTARGETS=i),"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=a),this.defineValue.USE_GI=n,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=l,this.defineValue.USE_VERTXCOLOR=s,m.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),m.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,m.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,m.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=m.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=m.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=m.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=At.Cascades>1,this.defineValue.USE_IES_PROFILE=Dt.use}genReflection(){this.shaderVariant=He.genRenderShaderVariant(this);let e=He.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let t=Tt.parse(this._destVS,this.defineValue);t=Tt.parse(t,this.defineValue),He.getShaderReflection2(t,this);let r=Tt.parse(this._destFS,this.defineValue);r=Tt.parse(r,this.defineValue),He.getShaderReflection2(r,this),He.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const t in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,t)){const r=this.textures[t];if(te.getInstance().detached(r,this),e&&!te.getInstance().hasReference(r))r.destroy(e);else{r.destroy(!1);let i=te.getInstance().getReference(r);if(i){let a=[];i.forEach((s,n)=>{"name"in s?a.push(s.name):a.push("NaN")})}}}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(e),this.materialDataUniformBuffer=null}static destroyShader(e){$t.renderShader.has(e)&&($t.renderShader.get(e).destroy(),$t.renderShader.delete(e))}static getShader(e){return $t.renderShader.get(e)}static createShader(e,t){let r=new Ae(e,t);return $t.renderShader.set(r.instanceID,r),r.instanceID}}class hl extends Ae{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.passType=W.GI,this.setUniformVector3("eyesPos",new d),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let e=this.shaderState;e.frontFace="ccw",e.cullMode=at.front,e.depthWriteEnabled=!1,e.depthCompare=zt.less}}class ul extends Ae{transparency;constructor(){super("gbuffer_vs","gbuffer_fs"),this.setShaderEntry("VertMain","FragMain"),this.passType=W.GI,this.setUniformColor("baseColor",new P),this.setUniformColor("emissiveColor",new P),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=ee.NONE,this.setTexture("normalMap",m.res.normalTexture)}}class cl extends Ae{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.passType=W.SHADOW,this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",d.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class fl extends Ae{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.passType=W.POINT_SHADOW,this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",d.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class dl extends Ae{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.passType=W.DEPTH,this.setShaderEntry("main"),this.useRz=!1;let e=this.shaderState;e.receiveEnv=!1}}class gi{static createGIPass(e,t){if(bt.hasMask(e.rendererMask,Be.Sky)){if(!t.passShader.get(W.GI)){let i=t.getSubShaders(W.COLOR)[0],a=new hl;a.setTexture("baseMap",i.getTexture("baseMap")),a.cullMode=i.cullMode,a.frontFace=i.frontFace,t.addRenderPass(a,0),a.preCompile(e.geometry)}}else this.castGBufferPass(e,t)}static castGBufferPass(e,t){let r=t.getDefaultShaders();for(let i=0;i<r.length;i++){const a=r[i];let s=t.getSubShaders(W.GI);if(!s||s.length==0||s.length<i){let n=new ul;n.setTexture("baseMap",a.getTexture("baseMap")),n.setTexture("normalMap",a.getTexture("normalMap")),n.setTexture("emissiveMap",a.getTexture("emissiveMap")),n.setUniform("baseColor",a.getUniform("baseColor")),n.setUniform("envIntensity",a.getUniform("envIntensity")),n.setUniform("emissiveColor",a.getUniform("emissiveColor")),n.setUniform("emissiveIntensity",a.getUniform("emissiveIntensity")),n.setUniform("alphaCutoff",a.getUniform("alphaCutoff")),n.cullMode=a.cullMode,n.frontFace=a.frontFace,n.preCompile(e.geometry),t.addRenderPass(n)}}}static createShadowPass(e,t){let r=bt.hasMask(e.rendererMask,Be.SkinnedMesh),i=e.geometry.hasAttribute(M.TANGENT),a=e.geometry.hasAttribute(Qt.MORPH_POSITION_PREFIX+"0"),s=e.geometry.hasAttribute(Qt.MORPH_NORMAL_PREFIX+"0"),n=t.getSubShaders(W.COLOR);for(let l=0;l<n.length;l++){const h=n[l];let u=t.getSubShaders(W.SHADOW);if(!u||u.length<l+1){let g=new cl;g.setTexture("baseMap",h.getTexture("baseMap")),g.setUniform("alphaCutoff",h.getUniform("alphaCutoff")),i&&g.setDefine("USE_TANGENT",i),r&&g.setDefine("USE_SKELETON",r),a&&g.setDefine("USE_MORPHTARGETS",a),s&&g.setDefine("USE_MORPHNORMALS",s),h.cullMode=="none"?g.shaderState.cullMode="none":h.cullMode=="back"?g.shaderState.cullMode="front":h.cullMode=="front"&&(g.shaderState.cullMode="back"),g.preCompile(e.geometry),t.addRenderPass(g)}let f=t.getSubShaders(W.POINT_SHADOW);if(!f||f.length<l+1){let g=new fl;g.setTexture("baseMap",h.getTexture("baseMap")),g.setUniform("alphaCutoff",h.getUniform("alphaCutoff")),g.setDefine("USE_ALPHACUT",1);for(let p=0;p<1;p++)i&&g.setDefine("USE_TANGENT",i),r&&g.setDefine("USE_SKELETON",r),a&&g.setDefine("USE_MORPHTARGETS",a),s&&g.setDefine("USE_MORPHNORMALS",s),g.shaderState.cullMode="front",g.preCompile(e.geometry);t.addRenderPass(g)}}}static createDepthPass(e,t){let r=t.getSubShaders(W.COLOR),i=e.geometry.hasAttribute("TANGENT"),a=e.geometry.hasAttribute(Qt.MORPH_POSITION_PREFIX+"0"),s=e.geometry.hasAttribute(Qt.MORPH_NORMAL_PREFIX+"0"),n=bt.hasMask(e.rendererMask,Be.SkinnedMesh);for(let l=0;l<r.length;l++){const h=r[l];let u=t.getSubShaders(W.DEPTH);if(!u&&h.shaderState.useZ&&(!u||u.length<l)){let f=new dl;f.setTexture("baseMap",h.getTexture("baseMap")),i||f.setDefine("USE_TANGENT",i),n&&f.setDefine("USE_SKELETON",n),a&&f.setDefine("USE_MORPHTARGETS",a),s&&f.setDefine("USE_MORPHNORMALS",s),f.cullMode=h.cullMode,f.frontFace=h.frontFace,f.preCompile(e.geometry),t.addRenderPass(f)}}}}class gl{renderer;owner;uuid;constructor(e){this.renderer=e,this.uuid=e.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(e){this.owner&&this.leaveNode(),this.owner=e,e.entities.set(this.uuid,this)}update(e){return this.owner?.tryInsertEntity(this)||(this.leaveNode(),e.tryInsertEntity(this)),this.owner}}var hd=Object.defineProperty,ud=Object.getOwnPropertyDescriptor,pi=(o,e,t,r)=>{for(var i=r>1?void 0:r?ud(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&hd(e,t,i),i};class er extends _e{instanceCount=0;lodLevel=0;alwaysRender=!1;instanceID;drawType=0;_geometry;_materials=[];_castShadow=!0;_castReflection=!1;_castGI=!1;_rendererMask=Be.Default;_inRenderer=!1;_readyPipeline=!1;_combineShaderRefection;_ignoreEnvMap;_ignorePrefilterMap;__renderOrder=0;_renderOrder=0;isRenderOrderChange;needSortOnCameraZ;_octreeBinder;preInit=!1;_renderLayer=li.None;_computes;init(e){this.renderOrder=0,this.rendererMask=Be.Default,this.instanceID=Ya().toString(),this._computes=[]}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new gl(this)},this.transform.eventDispatcher.addEventListener(st.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){this._octreeBinder&&(this._octreeBinder.entity?.leaveNode(),this.transform.eventDispatcher.removeEventListener(st.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){this._octreeBinder?.entity?.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._geometry&&te.getInstance().detached(this._geometry,this),te.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=bt.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=bt.removeMask(this.rendererMask,e)}hasMask(e){return bt.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let r=0;r<this._materials.length;r++){let i=this._materials[r];te.getInstance().detached(i,this),i.shader&&i.shader.computes&&this.removeComputes(i.shader.computes)}for(let r=0;r<e.length;r++){let i=e[r];te.getInstance().attached(i,this),i.shader&&i.shader.computes&&this.addComputes(i.shader.computes)}this._materials=e;let t=0;for(let r=0;r<e.length;r++){const s=e[r].getPass(W.COLOR)[0];s.shaderState.transparent&&(t=t>s.renderOrder?t:s.renderOrder)}this.renderOrder=t,this._readyPipeline||this.initPipeline()}addComputes(e){this._computes.push(...e)}removeComputes(e){for(const t of e){let r=this._computes.indexOf(t);r!=-1&&this._computes.splice(r,1)}}addRendererMask(e){this._rendererMask=bt.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=bt.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),k.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){this._enable=!1,k.instance.removeRenderNode(this.transform.scene3D,this),super.onDisable?.()}selfCloneMaterials(e){let t=[];for(let r=0,i=this.materials.length;r<i;r++){const a=this.materials[r].clone();t.push(a)}return this.materials=t,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let t=0;t<this._materials.length;t++){let i=this._materials[t].getPass(W.COLOR);for(let a=0;a<i.length;a++){const s=i[a];s.shaderReflection||s.preCompile(this._geometry),this._geometry.generate(s.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let t=0;t<this.materials.length;t++){const a=this.materials[t].getPass(W.COLOR)[0];a.renderOrder>=3e3?e=e>a.renderOrder?e:a.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&k.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];gi.createGIPass(this,r.shader)}for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&gi.createShadowPass(this,r.shader)}if(this.castReflection)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];r.castShadow&&gi.createShadowPass(this,r.shader)}if(!bt.hasMask(this.rendererMask,Be.IgnoreDepthPass)&&m.setting.render.zPrePass)for(let t=0;t<this.materials.length;t++){const r=this.materials[t];gi.createDepthPass(this,r.shader)}else for(let t=0;t<this.materials.length;t++)this.materials[t].shader.removeShaderByIndex(W.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,t,r){let i=this,a=i.transform._worldMatrix;for(let s=0;s<i.materials.length;s++){const n=i.materials[s];if(!n||!n.enable)continue;let l=n.getPass(t);if(!(!l||l.length==0)){w.bindGeometryBuffer(r.encoder,i._geometry);for(let h=0;h<l.length;h++){if(!l||l.length==0)continue;const f=l[h];if(f.pipeline){f.shaderState.splitTexture&&(r.endRenderPass(),ye.WriteSplitColorTexture(i.instanceID),r.beginOpaqueRenderPass(),w.bindCamera(r.encoder,e.camera),w.bindGeometryBuffer(r.encoder,i._geometry)),w.bindPipeline(r.encoder,f);let A=i._geometry.subGeometries[s].lodLevels[i.lodLevel];i.instanceCount>0?w.drawIndexed(r.encoder,A.indexCount,i.instanceCount,A.indexStart,0,0):w.drawIndexed(r.encoder,A.indexCount,1,A.indexStart,0,a.index)}}}}}renderPass2(e,t,r,i,a,s=!1){if(!this.enable)return;let n=this,l=n.object3D.transform._worldMatrix;for(let h=0;h<this.materials.length;h++){const u=this.materials[h];if(!u.castShadow&&t==W.SHADOW)continue;let f=u.getPass(t);if(!f||f.length==0)return;if(this.drawType==2)for(let g of f)g.pipeline&&(w.bindPipeline(a,g),w.draw(a,6,1,0,l.index));else{w.bindGeometryBuffer(a,n._geometry);for(let g of f)if(g.pipeline){w.bindPipeline(a,g);let C=n._geometry.subGeometries[h].lodLevels[n.lodLevel];w.drawIndexed(a,C.indexCount,1,C.indexStart,0,l.index)}}}}recordRenderPass2(e,t,r,i,a,s=!1){if(!this.enable)return;let n=this;for(let l=0;l<this.materials.length;l++){let u=this.materials[l].getPass(t);if(!u||u.length==0)return;let f=n.object3D.transform._worldMatrix;for(let g=0;g<u.length;g++){const p=u[g];w.bindPipeline(a,p);let x=n._geometry.subGeometries[l].lodLevels[n.lodLevel];w.drawIndexed(a,x.indexCount,1,x.indexStart,0,f.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this.preInit=!1)}nodeUpdate(e,t,r,i){this.preInit=!0;let a=this,s=e.scene.envMap;for(let n=0;n<a.materials.length;n++){let h=a.materials[n].getPass(t);if(h)for(let u=0;u<h.length;u++){const g=h[u];if(g.shaderState.splitTexture){let S=ye.CreateSplitTexture(a.instanceID);g.setTexture("splitTexture_Map",S)}if(!a._ignoreEnvMap&&g.envMap!=s&&g.setTexture("envMap",s),g.setTexture("prefilterMap",s),g.pipeline){g.apply(a._geometry,r,()=>a.noticeShaderChange());continue}let p=m.res.getTexture("BRDFLUT");g.setTexture("brdflutMap",p);let A=m.getRenderJob(e).shadowMapPassRenderer;A&&A.depth2DArrayTexture&&g.setTexture("shadowMap",m.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture);let v=m.getRenderJob(e).pointLightShadowRenderer;v&&v.cubeArrayTexture&&g.setTexture("pointShadowMap",v.cubeArrayTexture);let C=Dt.iesTexture;C&&g.setTexture("iesTextureArrayMap",C),r.irradianceBuffer&&r.irradianceBuffer.length>0&&(g.setTexture("irradianceMap",r.irradianceBuffer[0]),g.setTexture("irradianceDepthMap",r.irradianceBuffer[1]));let x=ae.getLightEntries(e.scene);x&&(g.setStorageBuffer("lightBuffer",x.storageGPUBuffer),x.irradianceVolume&&g.setUniformBuffer("irradianceData",x.irradianceVolume.irradianceVolumeBuffer)),i&&(g.setStorageBuffer("clustersUniform",i.clustersUniformBuffer),g.setStorageBuffer("lightAssignBuffer",i.lightAssignBuffer),g.setStorageBuffer("assignTable",i.assignTableBuffer),g.setStorageBuffer("clusterBuffer",i.clusterBuffer)),g.apply(a._geometry,r)}}}beforeDestroy(e){te.getInstance().detached(this._geometry,this),te.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let t=0;t<this._materials.length;t++){const r=this._materials[t];te.getInstance().detached(r,this),te.getInstance().hasReference(r)||r.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=null,this._materials=null,this._combineShaderRefection=null}}pi([Gt],er.prototype,"materials",1),pi([Gt],er.prototype,"castShadow",1),pi([Gt],er.prototype,"castShadow",1),pi([Gt],er.prototype,"castGI",1),pi([Gt],er.prototype,"castGI",1);class fs{uuid;type;color;count=0;pointData;colorData;dirtyData=!1;memoryDataIndex=-1;transformIndex;constructor(e){this.transformIndex=e}buildAxis(e=new d(0,0,0),t=10){this.buildLines([e,new d(e.x+t,e.y,e.z)],P.hexRGBColor(P.RED)),this.buildLines([e,new d(e.x,e.y+t,e.z)],P.hexRGBColor(P.GREEN)),this.buildLines([e,new d(e.x,e.y,e.z+t)],P.hexRGBColor(P.BLUE))}buildLines(e,t=P.COLOR_WHITE){if(!(e.length<2)){if(e.length==2){this.fillShapeData(e,t);return}var r=new Array(e.length+e.length-2);for(let i=1,a=0;i<e.length;++i)r[a++]=e[i-1],r[a++]=e[i];this.fillShapeData(r,t)}}buildArcLine(e,t,r,i,a=16,s=d.Y_AXIS,n=P.COLOR_WHITE){const l=(i-r)*ge;r*=ge;var h=[];for(let p=0;p<=a;++p){p>1&&h.push(h[h.length-1]);var u=l*(p/a)+r,f=t*Math.cos(u),g=t*Math.sin(u);switch(s){case d.X_AXIS:h.push(e.add(new d(0,f,g)));break;case d.Y_AXIS:h.push(e.add(new d(f,0,g)));break;case d.Z_AXIS:h.push(e.add(new d(f,g,0)));break;default:h.push(e.add(new d(f,g,0)));break}}this.fillShapeData(h,n)}buildCircle(e,t,r=32,i=d.Y_AXIS,a=P.COLOR_WHITE){var s=[];for(let u=0;u<=r;++u){var n=2*Math.PI*u/r,l=t*Math.cos(n),h=t*Math.sin(n);switch(i){case d.X_AXIS:s.push(e.add(new d(0,l,h)));break;case d.Y_AXIS:s.push(e.add(new d(l,0,h)));break;case d.Z_AXIS:s.push(e.add(new d(l,h,0)));break;default:s.push(e.add(new d(l,h,0)));break}u>0&&s.push(s[s.length-1])}s.push(s[0]),this.fillShapeData(s,a)}fillShapeData(e,t,r=!1){if(!this.pointData)this.pointData=new Float32Array(4*e.length),this.colorData=new Float32Array(4*e.length);else if(this.count+4*e.length>=this.pointData.length){let i=new Float32Array(this.pointData.length+4*e.length);i.set(this.pointData),this.pointData=i,i=new Float32Array(this.colorData.length+4*e.length),i.set(this.colorData),this.colorData=i}if(r||this.dirtyData==!1){const i=this.pointData;let a=this.count;for(let n=0;n<e.length;++n){const l=e[n];i[this.count++]=l.x,i[this.count++]=l.y,i[this.count++]=l.z,i[this.count++]=this.transformIndex}const s=this.colorData;for(let n=0;n<e.length;++n)if(t instanceof P)s[a++]=t.r,s[a++]=t.g,s[a++]=t.b,s[a++]=t.a;else{const l=t[n];s[a++]=l.r,s[a++]=l.g,s[a++]=l.b,s[a++]=l.a}}this.dirtyData=!0}reset(){this.count=0}}class fa extends er{shapes;mDirtyData=!1;mBatchSize;mMinIndexCount;mGPUPrimitiveTopology;constructor(e,t){super(),this.alwaysRender=!0,this.mMinIndexCount=e,this.mBatchSize=Math.trunc(65536/this.mMinIndexCount),this.mGPUPrimitiveTopology=t,this.shapes=new Map}init(){super.init(),this.castGI=!1,this.castShadow=!1,this.geometry=new ve;let e=new Uint16Array((Math.trunc(this.mMinIndexCount*this.mBatchSize/4)+1)*4);for(let t=0;t<e.length;t++)e[t]=t;this.geometry.setIndices(e),this.geometry.setAttribute(M.position,new Float32Array(4*e.length)),this.geometry.setAttribute(M.color,new Float32Array(4*e.length)),this.geometry.addSubGeometry({indexStart:0,indexCount:0,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.materials=[new yc(this.mGPUPrimitiveTopology)]}fillShapeData(e,t,r,i){this.mDirtyData=!0;var a;this.shapes.has(e)?(a=this.shapes.get(e),a.pointData.length<4*i.length&&(a.pointData=new Float32Array(4*i.length),a.colorData=new Float32Array(4*i.length))):(a=new fs(this.transform._worldMatrix.index),a.type=t,a.color=r,a.pointData=new Float32Array(4*i.length),a.colorData=new Float32Array(4*i.length));const s=a.pointData,n=a.colorData,l=this.transform._worldMatrix.index;for(let h=0,u=0;h<i.length;++h){const f=i[h];s[u]=f.x,n[u++]=r.r,s[u]=f.y,n[u++]=r.g,s[u]=f.z,n[u++]=r.b,s[u]=l,n[u++]=r.a}this.shapes.set(e,a)}removeShape(e){this.shapes.has(e)&&(this.mDirtyData=!0,this.shapes.delete(e))}nodeUpdate(e,t,r,i){if(this.mDirtyData){let a=0,s=this.geometry.getAttribute(M.position),n=this.geometry.getAttribute(M.color);this.shapes.forEach((u,f)=>{s.data.set(u.pointData,a),n.data.set(u.colorData,a),a+=u.pointData.length}),this.geometry.vertexBuffer.upload(M.position,s),this.geometry.vertexBuffer.upload(M.color,n);let h=a/4;this.geometry.subGeometries[0].lodLevels[0].indexCount=h,this.mDirtyData=!1}super.nodeUpdate(e,t,r,i)}allocGraphics3DShape(e,t){let r;return this.shapes.has(e)?(r=this.shapes.get(e),r.reset()):(r=new fs(t),r.uuid=e,r.type="line",r.color=P.COLOR_WHITE,this.shapes.set(r.uuid,r)),this.mDirtyData=!0,r}}class pl{opaqueList=[];transparentList=[];sky;clean(){this.opaqueList.length=0,this.transparentList.length=0}}class ml{renderGroup;constructor(){this.renderGroup=new Map}collect_add(e){let t="",r="";t+=e.geometry.instanceID;for(let a=0;a<e.materials.length;a++){const s=e.materials[a];r+=s.shader.getDefaultColorShader().shaderVariant}let i=t+r;this.renderGroup.has(i)||this.renderGroup.set(i,{bundleMap:new Map,key:i,renderNodes:[]}),this.renderGroup.get(i).renderNodes.indexOf(e)==-1&&this.renderGroup.get(i).renderNodes.push(e)}}class Al{renderShaderUpdateList=new Map;renderNodeList=new Map;collect_add(e){let t=e.transform.view3D;t&&e.materials&&e.materials.forEach(r=>{let i=this.renderShaderUpdateList.get(t);i||(i=new Map,this.renderShaderUpdateList.set(t,i));let a=this.renderNodeList.get(t);a||(a=new Map,this.renderNodeList.set(t,a)),a.set(e.instanceID,e);let s=r.getAllPass();for(let n=0;n<s.length;n++){const l=s[n];let h=`${e.geometry.instanceID+l.instanceID}`,u=i.get(h);u||(u=new Map,i.set(h,u)),u.set(e.instanceID,e)}})}collect_remove(e){let t=e.transform.view3D;if(t&&e.materials){let r=this.renderShaderUpdateList.get(t);r&&e.materials.forEach(i=>{let a=i.getAllPass();for(let s=0;s<a.length;s++){const n=a[s];let l=`${e.geometry.instanceID+n.instanceID}`;r.delete(l)}})}}}class k{static _instance;_sceneLights;_sceneGIProbes;_op_RenderNodes;_tr_RenderNodes;_octreeRenderNodes;_graphics;_op_renderGroup;_tr_renderGroup;_renderShaderCollect;state={giLightingChange:!0};sky;_collectInfo;rendererOctree;static get instance(){return this._instance||(this._instance=new k),this._instance}constructor(){this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new pl,this._renderShaderCollect=new Al,this._octreeRenderNodes=new Map}getPashList(e,t){if(t.renderOrder<3e3)return this._op_RenderNodes.get(e);if(t.renderOrder>=3e3)return this._tr_RenderNodes.get(e)}sortRenderNode(e,t){for(let r=e.length-1;r>0;r--)if(e[r].renderOrder<t.renderOrder){e.push(t);return}e.push(t)}addRenderNode(e,t){if(!e)return;let r=t.renderOrder>=3e3;if(t.hasMask(Be.Sky))this.sky=t;else if(t instanceof fa)this._graphics.indexOf(t)==-1&&this._graphics.push(t);else if(ns.hasMask(t.renderLayer,li.None)){this.removeRenderNode(e,t);let i=r?this._tr_RenderNodes:this._op_RenderNodes;i.has(e)||i.set(e,[]),i.get(e).push(t),m.setting.occlusionQuery.octree&&t.attachSceneOctree(this.getOctree(e));let a=this.getPashList(e,t);a.indexOf(t)==-1&&this.sortRenderNode(a,t)}else{this.removeRenderNode(e,t);let i=r?this._tr_renderGroup:this._op_renderGroup;i.has(e)||i.set(e,new ml),i.get(e).collect_add(t)}t.object3D.renderNode=t,this._renderShaderCollect.collect_add(t)}getOctree(e){let t,r=m.setting.occlusionQuery.octree;if(r&&(t=this._octreeRenderNodes.get(e),!t)){let i=new d(r.x,r.y,r.z),a=new d(r.width,r.height,r.depth),s=new de(i,a);t=new dr(s),this._octreeRenderNodes.set(e,t)}return t}removeRenderNode(e,t){if(t.detachSceneOctree(),t.hasMask(Be.Sky))this.sky=null;else if(ns.hasMask(t.renderLayer,li.None)){let r=this.getPashList(e,t);if(r){let i=r.indexOf(t);i!=-1&&r.splice(i,1)}}this._renderShaderCollect.collect_remove(t)}addLight(e,t){if(!this._sceneLights.has(e))this._sceneLights.set(e,[t]);else{let r=this._sceneLights.get(e);if(r.length>=m.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",m.setting.light.maxLight);return}r.indexOf(t)!=-1||r.push(t)}}removeLight(e,t){if(this._sceneLights.has(e)){let r=this._sceneLights.get(e),i=r.indexOf(t);i!=-1&&r.splice(i,1)}}getLights(e){let t=this._sceneLights.get(e);return t||[]}addGIProbe(e,t){this._sceneGIProbes.has(e)?this._sceneGIProbes.get(e).push(t):this._sceneGIProbes.set(e,[t])}removeGIProbe(e,t){if(this._sceneGIProbes.has(e)){let r=this._sceneGIProbes.get(e),i=r.indexOf(t);i!=-1&&r.splice(i,1)}}getProbes(e){let t=this._sceneGIProbes.get(e);return t||[]}autoSortRenderNodes(e){let t=this._tr_RenderNodes.get(e);if(!t)return;let r=!1;for(const i of t)if(i.isRenderOrderChange||i.needSortOnCameraZ){r=!0;break}if(r){for(const i of t){let a=i.renderOrder;if(i.needSortOnCameraZ){let s=qn.worldToCameraDepth(i.object3D);s=1-Math.max(0,Math.min(1,s)),a+=s}i.__renderOrder=a,i.isRenderOrderChange=!1}t.sort((i,a)=>i.__renderOrder>a.__renderOrder?1:-1)}return this}getRenderNodes(e,t){if(this.autoSortRenderNodes(e),this._collectInfo.clean(),this._collectInfo.sky=this.sky,m.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(e),this.rendererOctree.getRenderNode(t.frustum,this._collectInfo);else{let r=this._op_RenderNodes.get(e);r&&(this._collectInfo.opaqueList=r.concat());let i=this._tr_RenderNodes.get(e);i&&(this._collectInfo.transparentList=i.concat())}return this._collectInfo}getOpRenderGroup(e){return this._op_renderGroup.get(e)}getTrRenderGroup(e){return this._tr_renderGroup.get(e)}getGraphicList(){return this._graphics}getRenderShaderCollect(e){return this._renderShaderCollect.renderShaderUpdateList.get(e)}}class vl{setting;probesBufferData;probesBuffer;isVolumeFrameChange=!0;randomOrientation;startPosition=new d;isVolumeChange=!0;irradianceVolumeBuffer;directionDistance=20;randomSeedCount=3;useRandomIndex=0;centerDirection=new d(0,0,this.directionDistance).normalize(1);arroundPositions=[];updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),R.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(e){this.setting=e,this.randomOrientation=new R(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new ct(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let t=0;t<this.randomSeedCount;t++){let r=Math.PI*2*t/this.randomSeedCount,i=new d(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(i)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(e){let t=this.probesBufferData;for(let r of e){let i=r.index*4;t[i+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let e=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(e*4),this.probesBufferData.fill(-1),this.probesBuffer=new Z(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(e,t,r,i){let a=this.setting,s=this.setting.probeSpace;return i=i||new d,i.x=e*s-s*(a.probeXCount-1)*.5+a.offsetX,i.y=t*s-s*(a.probeYCount-1)*.5+a.offsetY,i.z=r*s-s*(a.probeZCount-1)*.5+a.offsetZ,i}debugX=0;debugY=0;debugZ=0;fillIrradianceData(){let e=this.setting,t=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",e.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",e.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",e.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",t.x),this.irradianceVolumeBuffer.setFloat("startY",t.y),this.irradianceVolumeBuffer.setFloat("startZ",t.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",e.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",e.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",e.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",e.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",e.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",e.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",e.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",e.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",e.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",e.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",e.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",e.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",e.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",e.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",e.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",e.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",e.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class _l{storageGPUBuffer;irradianceVolume;_lightList=[];constructor(){this.storageGPUBuffer=new Z(sa.lightSize*m.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new vl,this.irradianceVolume.init(m.setting.gi);for(let e=0;e<m.setting.light.maxLight;e++){let t=this.storageGPUBuffer.memory.allocation_node(sa.lightSize*4);this._lightList.push(t)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e){this.storageGPUBuffer.clean();let t=k.instance.getLights(e.scene);for(let r=0;r<t.length;r++){const i=t[r].lightData;i.index=r,this.writeLightBytes(i,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(e,t){t.offset=0,t.writeFloat(e.index),t.writeInt32(e.lightType),t.writeFloat(e.radius),t.writeFloat(e.linear),t.writeVector3(e.lightPosition),t.writeFloat(e.lightMatrixIndex),t.writeVector3(e.direction),t.writeFloat(e.quadratic),t.writeRGBColor(e.lightColor),t.writeFloat(e.intensity),t.writeFloat(e.innerAngle),t.writeFloat(e.outerAngle),t.writeFloat(e.range),t.writeInt32(e.castShadowIndex),t.writeVector3(e.lightTangent),t.writeFloat(e.iesIndex)}}class xl{gpuBuffer;probes;memoryDo;_probeInfoList;initDataUniform(e){this.memoryDo=new ur,this.probes=e,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(e.length*17*4);for(let r=0;r<e.length;r++){var t=17;let i=this.memoryDo.allocation_node(t*4);this._probeInfoList.push(i);let a=e[r].transform.worldPosition;i.setArray(0,[a.x,a.y,a.z])}this.gpuBuffer=I.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const e=this.memoryDo.shareDataBuffer;let t=this.memoryDo.shareDataBuffer.byteLength,r=0;const i=5e3*64;for(;r<t;)I.device.queue.writeBuffer(this.gpuBuffer,r,e,r,Math.floor(Math.min(i,t-r))),r+=i}}class Cl extends Wt{size;constructor(e,t=0,r){super(),this.bufferType=Et.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|t,e,r,"MatrixGPUBuffer")}writeBufferByHeap(e,t){let r=I.device;if(e.length>0){let i=null;for(;this.mapAsyncReady.length&&(i=this.mapAsyncReady.shift(),i.usedSize!=e.byteLength);)i.destroy(),this.mapAsyncBuffersOutstanding--,i=null;i||(i=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),i.usedSize=e.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let a=new Float32Array(e.buffer,e.byteOffset,t);new Float32Array(i.getMappedRange(0,t*4)).set(a),i.unmap();const n=r.createCommandEncoder();n.copyBufferToBuffer(i,0,this.buffer,0,t*4),r.queue.submit([n.finish()]),i.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(i))}}}class Sl{uuid;index;usage;groupBufferSize;matrixBufferDst;constructor(){this.uuid=dt(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=R.maxCount*R.blockBytes,this.matrixBufferDst=new Cl(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(e){const t=R.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(t,e)}}class ae{static _cameraBindGroups;static _lightEntriesMap;static _probeEntries;static modelMatrixBindGroup;static init(){this.modelMatrixBindGroup=new Sl,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map}static getCameraGroup(e){let t=this._cameraBindGroups.get(e);return t||(t=new jn(this.modelMatrixBindGroup),this._cameraBindGroups.set(e,t)),e.isShadowCamera?t.setShadowCamera(e):t.setCamera(e),t}static getLightEntries(e){e||console.log("getLightEntries scene is null");let t=this._lightEntriesMap.get(e);return t||(t=new _l,this._lightEntriesMap.set(e,t)),this._lightEntriesMap.get(e)}static updateProbes(e){this._probeEntries||(this._probeEntries=new xl,this._probeEntries.initDataUniform(e))}}class w{static lastGeometry;static lastPipeline;static lastShader;static drawCount=0;static renderPassCount=0;static geometryCount=0;static pipelineCount=0;static matrixCount=0;static lastRenderPassState;static LastCommand;static bindPipeline(e,t){if(w.lastShader!=t)w.lastShader=t;else return;w.lastPipeline!=t.pipeline&&(w.lastPipeline=t.pipeline,e.setPipeline(t.pipeline));for(let r=1;r<t.bindGroups.length;r++){const i=t.bindGroups[r];i&&e.setBindGroup(r,i)}}static bindCamera(e,t){let r=ae.getCameraGroup(t);e.setBindGroup(0,r.globalBindGroup)}static bindGeometryBuffer(e,t){if(this.lastGeometry!=t){this.lastGeometry=t,t.indicesBuffer&&e.setIndexBuffer(t.indicesBuffer.indicesGPUBuffer.buffer,t.indicesBuffer.indicesFormat);let r=t.vertexBuffer.vertexGPUBuffer,i=t.vertexBuffer.vertexBufferLayouts;for(let a=0;a<i.length;a++){const s=i[a];e.setVertexBuffer(a,r.buffer,s.offset,s.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(e){return vt.countStart("GPUContext","pipeline"),I.device.createRenderPipeline(e)}static beginCommandEncoder(){return vt.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&I.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=I.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(e){this.LastCommand==e&&(I.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,vt.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(e){return I.device.createRenderBundleEncoder(e)}static beginRenderPass(e,t){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=t,t.renderTargets&&t.renderTargets.length>0){for(let r=0;r<t.renderTargets.length;++r){const i=t.renderTargets[r];let a=t.renderPassDescriptor.colorAttachments[r];t.multisample>0&&t.renderTargets.length==1?(a.view=t.multiTexture.createView(),a.resolveTarget=i.getGPUView()):a.view=i.getGPUTexture().createView()}return e.beginRenderPass(t.renderPassDescriptor)}else{let r=t.renderPassDescriptor.colorAttachments[0];return r&&(t.multisample>0?(r.view=t.multiTexture.createView(),r.resolveTarget=I.context.getCurrentTexture().createView()):r.view=I.context.getCurrentTexture().createView()),e.beginRenderPass(t.renderPassDescriptor)}}static drawIndexed(e,t,r,i,a,s){e.drawIndexed(t,r,i,a,s),this.drawCount++}static draw(e,t,r,i,a){e.draw(t,r,i,a),this.drawCount++}static endPass(e){e.insertDebugMarker("end"),e.end()}static computeCommand(e,t){let r=e.beginComputePass();for(let i=0;i<t.length;i++)t[i].compute(r);r.end()}}class yl{source;input;output;reset(e){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=e}apply(e){if(this.source){if(!this.input){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new Z(this.source.length,t,this.source),this.input.apply()}if(!this.output){let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new Z(e*3,t),this.output.apply()}}}}class wl{enable;morphTargetsRelative;MaxMorphTargetCount=64;_computeConfigArray;_computeConfigBuffer;_morphInfluenceArray;_morphInfluenceBuffer;_positionAttrDataGroup;_normalAttrDataGroup;_isInfluenceDirty;_morphTargetCount;_totalVertexCount;_computeShader;_computeShaders;_computeWorkGroupXY=1;_collectMorphTargetData;_blendTarget;constructor(){this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new yl,this._normalAttrDataGroup=new yl}initMorphTarget(e){this._collectMorphTargetData=this.collectMorphTargetList(e),this._computeShader&&this._computeShader.destroy();let t=ft.CsMain;this._computeShader=new ie(t),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(e){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),e.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),e.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&e.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(e){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,w.computeCommand(e,this._computeShaders)}updateInfluence(e,t){this._isInfluenceDirty=!0,this._morphInfluenceArray[e]=t}get blendShape(){return this._blendTarget}collectMorphTargetList(e){let t=this.collectAttribute("a_morphPositions_",e),r=t.length,i=t[0].data.length/3;if(this._blendTarget={},e.blendShapeData)for(let l=0;l<e.blendShapeData.shapeIndexs.length;l++){let h=e.blendShapeData.shapeIndexs[l],u=e.blendShapeData.shapeNames[l].split("."),f=u[u.length-1];this._blendTarget[f]=g=>this.updateInfluence(h,g)}let a=new Float32Array(i*r*3);{let l=0;for(let h=0;h<r;h++){let u=t[h];a.set(u.data,l),l+=u.data.length}}let s=this.collectAttribute("a_morphNormals_",e),n;if(s&&s.length>0){let l=0;n=new Float32Array(i*r*3);for(let h=0;h<r;h++){let u=s[h];n.set(u.data,l),l+=u.data.length}}return{mtCount:r,vCount:i,mergedPos:a,mergedNormal:n}}collectAttribute(e,t){let r=[];for(let i=0;i<this.MaxMorphTargetCount;i++){let a=e+i,s=t.getAttribute(a);if(s)r[i]=s;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let e=0;for(let t=0;t<this._morphTargetCount;t++)e+=this._morphInfluenceArray[t];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-e,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(e){let t=Math.ceil(Math.sqrt(e)),r=Math.ceil(Math.log2(t));return t=Math.pow(2,r),t}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new ct(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new Z(this.MaxMorphTargetCount,e)}}var cd=Object.defineProperty,fd=Object.getOwnPropertyDescriptor,mi=(o,e,t,r)=>{for(var i=r>1?void 0:r?fd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&cd(e,t,i),i};c.MeshRenderer=class extends er{receiveShadow;morphData;constructor(){super()}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(e){e.addComponent(c.MeshRenderer).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.receiveShadow=e.receiveShadow,this}get geometry(){return this._geometry}set geometry(e){super.geometry=e;let t=e.morphTargetDictionary!=null;t&&(this.morphData||=new wl,this.morphData.morphTargetsRelative=e.morphTargetsRelative,this.morphData.initMorphTarget(e)),this.morphData&&(this.morphData.enable=t),this.morphData&&this.morphData.enable?this.addRendererMask(Be.MorphTarget):this.removeRendererMask(Be.MorphTarget),this.object3D.bound=this._geometry.bounds.clone(),this._readyPipeline||(this.initPipeline(),this._computes&&this._computes&&(this.onCompute=Fo(this.onCompute,()=>{for(let r=0;r<this._computes.length;r++)this._computes[r].onUpdate()})))}get material(){return this._materials[0]}set material(e){this.materials=[e]}setMorphInfluence(e,t){if(this.morphData&&this.morphData.enable){let r=this._geometry.morphTargetDictionary[e];r>=0&&this.morphData.updateInfluence(r,t)}}setMorphInfluenceIndex(e,t){this.morphData&&this.morphData.enable&&e>=0&&this.morphData.updateInfluence(e,t)}onCompute(e,t){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(t)}nodeUpdate(e,t,r,i){if(this.morphData&&this.morphData.enable)for(let a=0;a<this.materials.length;a++){let n=this.materials[a].getPass(t);if(n)for(let l=0;l<n.length;l++)this.morphData.applyRenderShader(n[l])}super.nodeUpdate(e,t,r,i)}destroy(e){super.destroy(e)}},mi([Gt],c.MeshRenderer.prototype,"geometry",1),mi([Gt],c.MeshRenderer.prototype,"geometry",1),mi([Gt],c.MeshRenderer.prototype,"material",1),mi([Gt],c.MeshRenderer.prototype,"material",1),c.MeshRenderer=mi([mt(c.MeshRenderer,"MeshRenderer")],c.MeshRenderer);class Il{label="";customSize=!1;zPreTexture=null;depthTexture=null;renderTargetTextures;outColor=-1;renderTargets;rtTextureDescriptors;irradianceBuffer;multisample=0;multiTexture;depthViewIndex=0;depthCleanValue=0;isOutTarget=!0;camera3D;rtFrame;renderPassDescriptor;renderBundleEncoderDescriptor;depthLoadOp;getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:m.res.redTexture}}class Ce{static bindGroupDescriptorCount=0;static bindTextureDescriptorCount=0;static renderPassDescriptorCount=0;static pipelineDescriptorCount=0;static createRendererPassState(e,t=null){let r=new Il;if(r.label=e.label,r.customSize=e.customSize,r.rtFrame=e,r.zPreTexture=e.zPreTexture,r.depthTexture=e.depthTexture,r.depthViewIndex=e.depthViewIndex,r.isOutTarget=e.isOutTarget,r.depthCleanValue=e.depthCleanValue,r.depthLoadOp=e.depthLoadOp,e&&e.renderTargets.length>0){r.renderTargets=e.renderTargets,r.rtTextureDescriptors=e.rtDescriptors,r.renderPassDescriptor=Ce.getRenderPassDescriptor(r),r.renderBundleEncoderDescriptor=Ce.getRenderBundleDescriptor(r),r.renderTargetTextures=[];for(let i=0;i<e.renderTargets.length;i++){const a=e.renderTargets[i];r.renderTargetTextures[i]={format:a.format},a.name.indexOf(Le.colorBufferTex_NAME)!=-1&&(r.outColor=i)}}else r.renderPassDescriptor=Ce.getRenderPassDescriptor(r,t),r.renderBundleEncoderDescriptor=Ce.getRenderBundleDescriptor(r),r.renderTargetTextures=[{format:I.presentationFormat}],r.outColor=0;return r}static getRenderPassDescriptor(e,t=null){I.device,I.presentationSize;let r=[];if(e.renderTargets&&e.renderTargets.length>0){e.renderTargets[0].width,e.renderTargets[0].height;for(let a=0;a<e.renderTargets.length;a++){const s=e.renderTargets[a],n=e.rtTextureDescriptors[a];r.push({view:s.getGPUView(),resolveTarget:void 0,loadOp:n.loadOp,clearValue:n.clearValue,storeOp:n.storeOp})}}else if(!e.customSize){let a=I.canvasConfig&&I.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];e.isOutTarget==!0&&r.push({view:void 0,resolveTarget:void 0,loadOp:I.canvasConfig&&I.canvasConfig.alpha||t!=null?"load":"clear",clearValue:a,storeOp:"store"})}let i=null;return e.depthTexture||e.zPreTexture?(e.zPreTexture&&(e.depthTexture=e.zPreTexture),i={label:`${e.label} renderPassDescriptor zPreTexture${e.zPreTexture?"load":"clear"}`,colorAttachments:r,depthStencilAttachment:{view:e.depthTexture.getGPUView(),depthLoadOp:e.zPreTexture?"load":e.depthLoadOp,depthClearValue:e.zPreTexture?1:e.depthCleanValue,depthStoreOp:"store"}}):i={colorAttachments:r,label:"renderPassDescriptor not writeDepth"},this.renderPassDescriptorCount++,i}static getRenderBundleDescriptor(e){I.presentationSize;let t=[];if(e.renderTargets&&e.renderTargets.length>0){e.renderTargets[0].width,e.renderTargets[0].height;for(let i=0;i<e.renderTargets.length;i++){const a=e.renderTargets[i];t.push(a.format)}}let r=null;return e.depthTexture?r={colorFormats:t,depthStencilFormat:e.depthTexture.format}:r={colorFormats:t},this.renderPassDescriptorCount++,r}}class da extends Wt{node;constructor(e){super(),this.bufferType=Et.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,t){let r=I.device;this.byteSize=t*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({label:"VertexGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new ur,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var je=(o=>(o[o.split=0]="split",o[o.compose=1]="compose",o[o.compose_bin=2]="compose_bin",o))(je||{});class bl{vertexCount=0;vertexGPUBuffer;geometryType=je.compose;_vertexBufferLayouts;_attributeSlotLayouts;_attributeLocation;constructor(){this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(e,t){switch(this.geometryType){case je.split:this.createSplitVertexBuffer(e,t);break;case je.compose:this.createComposeVertexBuffer(e,t);break;case je.compose_bin:this.createComposBinVertexBuffer(e,t);break}}createSplitVertexBuffer(e,t){let r=0;for(let i=0;i<t.attributes.length;i++){const a=t.attributes[i];if(a.name=="index")continue;this._attributeLocation[a.name]=a.location;let s={name:a.name,format:a.format,offset:0,shaderLocation:a.location,stride:fr[a.format]};this._attributeSlotLayouts[a.location]=[s];let n=e.get(a.name);n||(n={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,n));let l=n.data.length/s.stride;this.vertexCount!=0&&this.vertexCount!=l&&console.error(" vertex count not match attribute count"),this.vertexCount=l,this._vertexBufferLayouts[a.location]={name:a.name,arrayStride:a.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[a.location],offset:r*4,size:this.vertexCount*a.size*4},r+=this.vertexCount*a.size}this.vertexGPUBuffer=new da(r)}createComposeVertexBuffer(e,t){this._attributeSlotLayouts[0]=[];let r=0;for(let i=0;i<t.attributes.length;i++){const a=t.attributes[i];if(a.name=="index"||a.type=="builtin")continue;this._attributeLocation[a.name]=a.location;let s={name:a.name,format:a.format,offset:r*4,shaderLocation:a.location,stride:fr[a.format]};this._attributeSlotLayouts[0][a.location]=s;let n=e.get(a.name);if(n||(n={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},e.set(a.name,n)),n.data){let l=n.data.length/s.stride;this.vertexCount!=0&&this.vertexCount!=l&&console.error(" vertex count not match attribute count"),this.vertexCount=l}r+=a.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new da(this.vertexCount*r)}createComposBinVertexBuffer(e,t){this._attributeSlotLayouts[0]=[];let r=0;for(let s=0;s<t.attributes.length;s++){const n=t.attributes[s];if(n.name=="index"||n.type=="builtin")continue;this._attributeLocation[n.name]=n.location;let l={name:n.name,format:n.format,offset:r*4,shaderLocation:n.location,stride:fr[n.format]};this._attributeSlotLayouts[0][n.location]=l;let h=e.get(n.name);if(h||(h={attribute:n.name,data:new Float32Array(n.size*this.vertexCount)},e.set(n.name,h)),h.data){let u=h.data.length/l.stride;this.vertexCount!=0&&this.vertexCount!=u&&console.error(" vertex count not match attribute count"),this.vertexCount=u}r+=n.size}let a=e.get(M.all).data.length/r;this.vertexCount=a,this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new da(this.vertexCount*r)}upload(e,t){if(this.vertexGPUBuffer){switch(this.geometryType){case je.split:{let r=this._attributeLocation[e],i=this._vertexBufferLayouts[r];this.vertexGPUBuffer.node.setFloat32Array(i.offset/4,t.data)}break;case je.compose:for(let r=0;r<this.vertexCount;r++){const i=this._attributeSlotLayouts[0][this._attributeLocation[e]];for(let a=0;a<i.stride;a++){let s=t.data[r*i.stride+a],n=r*(this._vertexBufferLayouts[0].arrayStride/4)+i.offset/4+a;this.vertexGPUBuffer.node.setFloat(s,n)}}break;case je.compose_bin:this.vertexGPUBuffer.node.setFloat32Array(0,t.data);break}this.vertexGPUBuffer?.apply()}}updateAttributes(e){switch(this.geometryType){case je.split:for(let t=0;t<this._vertexBufferLayouts.length;t++){const r=this._vertexBufferLayouts[t];let i=e.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,i.data)}break;case je.compose:for(let t=0;t<this.vertexCount;t++)this._attributeSlotLayouts.forEach(r=>{for(let i=0;i<r.length;i++){const a=r[i];let s=e.get(a.name);for(let n=0;n<a.stride;n++){let l=s.data[t*a.stride+n],h=t*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+n;this.vertexGPUBuffer.node.setFloat(l,h)}}});break;case je.compose_bin:{let t=e.get(M.all);this.vertexGPUBuffer.node.setFloat32Array(0,t.data)}break}this.vertexGPUBuffer.apply()}compute(){}destroy(e){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(e),this.vertexGPUBuffer=null}}class Bl extends Wt{indicesNode;constructor(e){super(),this.bufferType=Et.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,t){let r=I.device;this.byteSize=t.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=r.createBuffer({label:"IndicesGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new ur,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),t&&(this.indicesNode=this.memory.allocation_node(t.length*4),this.indicesNode.setArrayBuffer(0,t),this.apply())}}class El{uuid="";name;indicesGPUBuffer;indicesFormat="uint16";indicesCount=0;constructor(){}createIndicesBuffer(e){e.data instanceof Uint16Array?this.indicesFormat="uint16":e.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=e.data.length,this.indicesGPUBuffer=new Bl(e.data)}upload(e){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,e),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class Tl{lodLevels}class ve{instanceID;name;subGeometries=[];morphTargetsRelative;morphTargetDictionary;skinNames;bindPose;blendShapeData;vertexDim;_bounds;_attributeMap;_attributes;_indicesBuffer;_vertexBuffer;_onChange=!0;_wireframeLines;constructor(){this.instanceID=dt(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new bl}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(e){this._vertexBuffer.geometryType=e}get bounds(){if(!this._bounds){this._bounds=new de(new d,new d(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let e=this.getAttribute(M.position);if(e&&e.data)for(let t=0;t<e.data.length/3;t++){const r=e.data[t*3+0],i=e.data[t*3+1],a=e.data[t*3+2];this._bounds.min.x>r&&(this._bounds.min.x=r),this._bounds.min.y>i&&(this._bounds.min.y=i),this._bounds.min.z>a&&(this._bounds.min.z=a),this._bounds.max.x<r&&(this._bounds.max.x=r),this._bounds.max.y<i&&(this._bounds.max.y=i),this._bounds.max.z<a&&(this._bounds.max.z=a)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(e){this._bounds=e}addSubGeometry(...e){let t=new Tl;return t.lodLevels=e,this.subGeometries.push(t),t}generate(e){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(M.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,e),this._vertexBuffer.updateAttributes(this._attributeMap))}setIndices(e){if(!this._attributeMap.has(M.indices)){let t={attribute:M.indices,data:e};this._attributeMap.set(M.indices,t),this._indicesBuffer=new El,this._indicesBuffer.createIndicesBuffer(t)}}setAttribute(e,t){if(e==M.indices)this.setIndices(t);else{let r={attribute:e,data:t};this._attributeMap.set(e,r),this._attributes.push(e)}}getAttribute(e){return this._attributeMap.get(e)}hasAttribute(e){return this._attributeMap.has(e)}genWireframe(){if(this._wireframeLines)return this._wireframeLines;if(this.geometryType==je.split||this.geometryType==je.compose){let e=this.getAttribute(M.position),t=this.getAttribute(M.indices);if(t&&e&&t.data.length>0){let r=e.data,i=[];for(let a=0;a<t.data.length/3;a++){const s=t.data[a*3+0],n=t.data[a*3+1],l=t.data[a*3+2];let h=new d(r[s*3+0],r[s*3+1],r[s*3+2]),u=new d(r[n*3+0],r[n*3+1],r[n*3+2]),f=new d(r[l*3+0],r[l*3+1],r[l*3+2]);i.push(h,u),i.push(u,f),i.push(f,h)}return this._wireframeLines=i,i}}else if(this.geometryType==je.compose_bin){let e=this.getAttribute(M.all),t=this.vertexDim,r=this.getAttribute(M.indices);if(r&&e&&r.data.length>0){let i=e.data,a=[];for(let s=0;s<r.data.length/3;s++){const n=r.data[s*3+0],l=r.data[s*3+1],h=r.data[s*3+2];let u=new d(i[n*t+0],i[n*t+1],i[n*t+2]),f=new d(i[l*t+0],i[l*t+1],i[l*t+2]),g=new d(i[h*t+0],i[h*t+1],i[h*t+2]);a.push(u,f),a.push(f,g),a.push(g,u)}return this._wireframeLines=a,a}}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}static crossA=d.UP.clone();static crossB=d.UP.clone();static crossRet=d.UP.clone();static point1=d.UP.clone();static point2=d.UP.clone();static point3=d.UP.clone();computeNormals(){let e=this.getAttribute(M.position),t=this.getAttribute(M.normal),r=this.getAttribute(M.indices);if(!e||!t||!r)return this;let i=r.data.length/3,a=ve.point1,s=ve.point2,n=ve.point3,l=ve.crossA,h=ve.crossB,u=ve.crossRet;for(let f=0;f<i;f++){let g=r.data[f*3],p=r.data[f*3+1],A=r.data[f*3+2];a.set(e.data[g*3],e.data[g*3+1],e.data[g*3+2]),s.set(e.data[p*3],e.data[p*3+1],e.data[p*3+2]),n.set(e.data[A*3],e.data[A*3+1],e.data[A*3+2]),d.sub(a,s,l).normalize(),d.sub(a,n,h).normalize();let v=l.crossProduct(h,u).normalize();t.data[g*3]=t.data[p*3]=t.data[A*3]=v.x,t.data[g*3+1]=t.data[p*3+1]=t.data[A*3+1]=v.y,t.data[g*3+2]=t.data[p*3+2]=t.data[A*3+2]=v.z}return this._vertexBuffer.upload(M.normal,t),this}isPrimitive(){return!1}destroy(e){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}}class Dl extends ve{width;height;segmentW;segmentH;up;constructor(e,t,r=1,i=1,a=d.Y_AXIS){super(),this.width=e,this.height=t,this.segmentW=r,this.segmentH=i,this.up=a,this.buildGeometry(this.up)}buildGeometry(e){var t,r,i,a,s=this.segmentW+1;(this.segmentH+1)*s,this.bounds=new de(d.ZERO.clone(),new d(this.width,1,this.height)),i=this.segmentH*this.segmentW*6;let n=(this.segmentW+1)*(this.segmentH+1),l=new Float32Array(n*3),h=new Float32Array(n*3),u=new Float32Array(n*2),f;this.segmentW*this.segmentH*2*3>=Uint16Array.length?f=new Uint32Array(this.segmentW*this.segmentH*2*3):f=new Uint16Array(this.segmentW*this.segmentH*2*3),i=0;for(var p=0,A=0,v=0,C=0;C<=this.segmentH;++C)for(var x=0;x<=this.segmentW;++x){switch(t=(x/this.segmentW-.5)*this.width,r=(C/this.segmentH-.5)*this.height,e){case d.Y_AXIS:l[p++]=t,l[p++]=0,l[p++]=r,h[A++]=0,h[A++]=1,h[A++]=0;break;case d.Z_AXIS:l[p++]=t,l[p++]=-r,l[p++]=0,h[A++]=0,h[A++]=0,h[A++]=1;break;case d.X_AXIS:l[p++]=0,l[p++]=t,l[p++]=r,h[A++]=1,h[A++]=0,h[A++]=0;break;default:l[p++]=t,l[p++]=0,l[p++]=r,h[A++]=0,h[A++]=1,h[A++]=0;break}u[v++]=x/this.segmentW,u[v++]=C/this.segmentH,x!=this.segmentW&&C!=this.segmentH&&(a=x+C*s,f[i++]=a+1,f[i++]=a,f[i++]=a+s,f[i++]=a+1,f[i++]=a+s,f[i++]=a+s+1)}this.setIndices(f),this.setAttribute(M.position,l),this.setAttribute(M.normal,h),this.setAttribute(M.uv,u),this.setAttribute(M.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class We{instanceID;name;enable=!0;_defaultSubShader;_shader;constructor(){}set shader(e){this._shader=e,this._defaultSubShader=e.getDefaultShaders()[0]}get shader(){return this._shader}get doubleSide(){return this._defaultSubShader.doubleSide}set doubleSide(e){this._defaultSubShader.doubleSide=e}get castShadow(){return this._defaultSubShader.shaderState.castShadow}set castShadow(e){let t=this._defaultSubShader.shaderState;e!=t.castShadow&&(t.castShadow=e)}get acceptShadow(){return this._defaultSubShader.shaderState.acceptShadow}set acceptShadow(e){let t=this._defaultSubShader.shaderState;t.acceptShadow!=e&&(t.acceptShadow=e,this._defaultSubShader.noticeShaderChange(),this._defaultSubShader.noticeValueChange())}get blendMode(){return this._defaultSubShader.blendMode}set blendMode(e){this._defaultSubShader.blendMode=e}get depthCompare(){return this._defaultSubShader.depthCompare}set depthCompare(e){this._defaultSubShader.depthCompare=e}get transparent(){return this._defaultSubShader.shaderState.transparent}set transparent(e){this._defaultSubShader.shaderState.transparent=e,e&&(this._defaultSubShader.renderOrder=3e3)}get cullMode(){return this._defaultSubShader.cullMode}set cullMode(e){if(this._defaultSubShader.cullMode!=e){for(let t of this._shader.passShader.values())for(let r of t)r.cullMode=e;this._defaultSubShader.cullMode=e}}get depthWriteEnabled(){return this._defaultSubShader.depthWriteEnabled}set depthWriteEnabled(e){this._defaultSubShader.depthWriteEnabled=e}set useBillboard(e){this._defaultSubShader.setDefine("USE_BILLBOARD",e)}getPass(e){return this._shader.getSubShaders(e)}getAllPass(){return this._shader.getSubShaders(W.COLOR)}clone(){let e=new We;return e.shader=this.shader.clone(),e}destroy(e){this._shader.destroy(),this._shader=null}setDefine(e,t){this.shader.setDefine(e,t)}setTexture(e,t){this._shader.setTexture(e,t)}setStorageBuffer(e,t){this._shader.setStorageBuffer(e,t)}setUniformBuffer(e,t){this._shader.setStorageBuffer(e,t)}setUniformFloat(e,t){this._shader.setUniformFloat(e,t)}setUniformVector2(e,t){this._shader.setUniformVector2(e,t)}setUniformVector3(e,t){this._shader.setUniformVector3(e,t)}setUniformVector4(e,t){this._shader.setUniformVector4(e,t)}setUniformColor(e,t){this._shader.setUniformColor(e,t)}getUniformFloat(e){return this._shader.getUniform(e).data}getUniformV2(e){return this._shader.getUniformVector2(e)}getUniformV3(e){return this._shader.getUniformVector3(e)}getUniformV4(e){return this._shader.getUniformVector4(e)}getUniformColor(e){return this._shader.getUniformColor(e)}getTexture(e){return this._shader.getTexture(e)}getStorageBuffer(e){return this._shader.getStorageBuffer(e)}getStructStorageBuffer(e){return this._shader.getStructStorageBuffer(e)}getUniformBuffer(e){return this._shader.getUniformBuffer(e)}applyUniform(){this._shader.applyUniform()}}class ke{computes;passShader;constructor(){this.computes=[],this.passShader=new Map}addRenderPass(e,t=-1){let r=this.passShader.get(e.passType)||[];t==-1?r.push(e):r.splice(t,-1,e),this.passShader.set(e.passType,r)}removeShader(e,t=-1){let r=this.passShader.get(e.passType);if(r)if(t==-1){let i=r.indexOf(e);i!=-1&&r.splice(i)}else r.splice(t,1)}removeShaderByIndex(e,t=-1){let r=this.passShader.get(e);r&&(t==-1?this.passShader.delete(e):r.splice(t,1))}getSubShaders(e){return this.passShader.get(e)||[]}hasSubShaders(e){return this.passShader.get(e).length>0}getDefaultShaders(){return this.passShader.get(W.COLOR)}getDefaultColorShader(){return this.passShader.get(W.COLOR)[0]}setDefine(e,t){for(const r of this.passShader)for(const i of r[1])i.setDefine(e,t)}deleteDefine(e){for(const t of this.passShader)for(const r of t[1])r.deleteDefine(e)}setUniform(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniform(e,t)}setUniformFloat(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformFloat(e,t)}setUniformVector2(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformVector2(e,t)}setUniformVector3(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformVector3(e,t)}setUniformVector4(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformVector4(e,t)}setUniformColor(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformColor(e,t)}getUniform(e){return this.getDefaultColorShader().getUniform(e)}getUniformFloat(e){return this.getDefaultColorShader().getUniformFloat(e)}getUniformVector2(e){return this.getDefaultColorShader().getUniformVector2(e)}getUniformVector3(e){return this.getDefaultColorShader().getUniformVector3(e)}getUniformVector4(e){return this.getDefaultColorShader().getUniformVector4(e)}getUniformColor(e){return this.getDefaultColorShader().getUniformColor(e)}setTexture(e,t){for(const r of this.passShader)for(const i of r[1])i.setTexture(e,t);this.setDefine(`USE_${e.toLocaleUpperCase()}`,!0)}getTexture(e){return this.getDefaultColorShader().textures[e]}setUniformBuffer(e,t){for(const r of this.passShader)for(const i of r[1])i.setUniformBuffer(e,t)}getUniformBuffer(e){return this.getDefaultColorShader().getBuffer(e)}setStorageBuffer(e,t){for(const r of this.passShader)for(const i of r[1])i.setStorageBuffer(e,t)}getStorageBuffer(e){return this.getDefaultColorShader().getBuffer(e)}setStructStorageBuffer(e,t){for(const r of this.passShader)for(const i of r[1])i.setStructStorageBuffer(e,t)}getStructStorageBuffer(e){return this.getDefaultColorShader().getBuffer(e)}noticeValueChange(){for(const e of this.passShader)for(const t of e[1])t.noticeValueChange()}destroy(){this.getDefaultColorShader().destroy()}clone(){let e=new ke,t=this.getDefaultShaders();for(const r of t)e.addRenderPass(r);return e}applyUniform(){for(const e of this.passShader)for(const t of e[1])t.applyUniform()}}var dd=Object.defineProperty,gd=Object.getOwnPropertyDescriptor,pd=(o,e,t,r)=>{for(var i=r>1?void 0:r?gd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&dd(e,t,i),i};c.QuadShader=class extends ke{constructor(e="QuadGlsl_vs",t="QuadGlsl_fs"){super();let r=new Ae(e,t);this.addRenderPass(r);let i=r.shaderState;r.blendMode=ee.NONE,i.frontFace="cw",i.depthWriteEnabled=!1,i.depthCompare=zt.always,i.multisample=0,this.setTexture("baseMap",m.res.blackTexture),this.setUniformFloat("x",0),this.setUniformFloat("y",0),this.setUniformFloat("width",100),this.setUniformFloat("height",100)}},c.QuadShader=pd([jt],c.QuadShader);class ga extends c.Object3D{width=128;height=128;quadRenderer;material;rendererPassState;quadShader;constructor(e="QuadGlsl_vs",t="QuadGlsl_fs",r,i=0,a=!1){super();let s=r?r.renderTargets:[];this.material=new We,this.quadShader=new c.QuadShader(e,t),this.material.shader=this.quadShader,this.quadRenderer=this.addComponent(c.MeshRenderer),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=a?2:0,this.quadRenderer.geometry=new Dl(100,100,1,1),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=Ce.createRendererPassState(r,"load"),i>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=I.device.createTexture({size:{width:I.presentationSize[0],height:I.presentationSize[1]},sampleCount:i,format:s.length>0?s[0].format:I.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT})),I.addEventListener(yr.RESIZE,n=>{this.rendererPassState=Ce.createRendererPassState(r,"load"),i>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=I.device.createTexture({size:{width:I.presentationSize[0],height:I.presentationSize[1]},sampleCount:i,format:s.length>0?s[0].format:I.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))},this)}renderTarget(e,t,r){let i=e.camera,a=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(a,i),t.quadRenderer.nodeUpdate(e,W.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,W.COLOR,t.rendererPassState,null,a),w.endPass(a)}renderToViewQuad(e,t,r,i){let a=e.camera;t.quadShader.setTexture("baseMap",i);let s=w.beginRenderPass(r,t.rendererPassState);w.bindCamera(s,a),t.quadRenderer.nodeUpdate(e,W.COLOR,t.rendererPassState,null),t.quadRenderer.renderPass2(e,W.COLOR,t.rendererPassState,null,s),w.endPass(s)}}class ce{storeOp="store";loadOp="clear";clearValue=[0,0,0,0]}class Oe{label;customSize=!1;renderTargets;rtDescriptors;zPreTexture;depthTexture;depthViewIndex=0;depthCleanValue=1;depthLoadOp="clear";isOutTarget=!0;constructor(e,t,r,i,a=!0){this.renderTargets=e,this.rtDescriptors=t,this.depthTexture=r,this.zPreTexture=i,this.isOutTarget=a}clone2Frame(e){e.renderTargets.push(...this.renderTargets.concat());for(let t=0;t<this.rtDescriptors.length;t++){const r=this.rtDescriptors[t];let i=new ce;i.loadOp=r.loadOp,i.storeOp=r.storeOp,i.clearValue=r.clearValue,e.rtDescriptors.push(i)}e.depthTexture=this.depthTexture,e.zPreTexture=this.zPreTexture,e.customSize=this.customSize}clone(){let e=new Oe([],[]);return this.clone2Frame(e),e}}class et extends De{resolveTarget;sampleCount;autoResize;clear;constructor(e,t,r=z.rgba8unorm,i=!1,a,s=1,n=0,l=!0,h=!0){super(e,t,s),this.name=dt(),this.autoResize=h,this.useMipmap=i,this.sampleCount=n,this.format=r,this.numberLayer=s,this.clear=l,a!=null?this.usage=a:this.usage=a|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,t),h&&I.addEventListener(yr.RESIZE,u=>{let{width:f,height:g}=u.data;this.resize(f,g),this._textureChange=!0},this)}resize(e,t){let r=I.device;this.gpuTexture&&(De.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=t,this.createTextureDescriptor(e,t,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==z.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=r.createSampler({})):this.format==z.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==z.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=ut.clamp_to_edge,this.addressModeV=ut.clamp_to_edge,this.gpuSampler=r.createSampler(this)),this._textureChange=!0}create(e,t,r=!0){let i=I.device;const a=e*4;let s=new Float32Array(e*t*4);const n=i.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(n,0,s);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:n,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l)}clone(){let e=new et(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount,this.clear,this.autoResize);return e.name="clone_"+e.name,e}readTextureToImage(){let e=I.device,t=I.windowWidth,r=I.windowHeight,i=new Float32Array(t*r*4);const a=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return w.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[t,r]),a.getMappedRange(0,i.byteLength)}}class ye{static rtTextureMap;static rtViewQuad;static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(e,t,r,i,a=!1,s=0){let n=this.rtTextureMap.get(e);return n||(e==Le.colorBufferTex_NAME?n=new et(t,r,i,a,void 0,1,s,!1):n=new et(t,r,i,a,void 0,1,s,!0),n.name=e,ye.rtTextureMap.set(e,n)),n}static createRTTextureArray(e,t,r,i,a=1,s=!1,n=0){let l=this.rtTextureMap.get(e);return l||(l=new et(t,r,i,s,void 0,a,n),l.name=e,ye.rtTextureMap.set(e,l)),l}static createViewQuad(e,t,r,i,a=0){let s=new Oe([i],[new ce]),n=new ga(t,r,s,a);return ye.rtViewQuad.set(e,n),n}static getTexture(e){return this.rtTextureMap.get(e)}static CreateSplitTexture(e){let t=this.getTexture(Le.colorBufferTex_NAME),r=this.getTexture(e+"_split");return r||(r=this.createRTTexture(e+"_split",t.width,t.height,t.format,!1)),r}static WriteSplitColorTexture(e){let t=this.getTexture(Le.colorBufferTex_NAME),r=this.getTexture(e+"_split");const i=w.beginCommandEncoder();i.copyTextureToTexture({texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1}),w.endCommandEncoder(i)}}class Pl{command;encoder;rendererPassStates;rtFrame;constructor(e){this.rtFrame=e,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,w.cleanCache()}beginContinueRendererPassState(e="load",t="load"){if(this.rendererPassStates.length>0){let r=this.rtFrame.clone();for(const a of r.rtDescriptors)a.loadOp="load";r.depthLoadOp=t;let i=Ce.createRendererPassState(r,e);return this.rendererPassStates.push(i),i}else{this.rtFrame.depthLoadOp=t;let r=Ce.createRendererPassState(this.rtFrame,e);return this.rendererPassStates.push(r),r}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginOpaqueRenderPass(){this.beginContinueRendererPassState("clear","clear"),this.begineNewCommand(),this.beginNewEncoder()}beginTransparentRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=w.beginCommandEncoder(),this.command}endCommand(){w.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=w.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){w.endPass(this.encoder),this.encoder=null}}class pr extends Xt{rendererPassState;splitRendererPassState;useRenderBundle=!1;debugViewQuads;debugTextures;renderContext;_rendererType;_rtFrame;get passType(){return this._rendererType}set passType(e){this._rendererType=e}constructor(){super(),this.debugTextures=[],this.debugViewQuads=[]}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=Ce.createRendererPassState(e);let t=e.clone();t.depthLoadOp="load";for(const r of t.rtDescriptors)r.loadOp="load";this.splitRendererPassState=Ce.createRendererPassState(t)}this.renderContext=new Pl(e)}setIrradiance(e,t){this.rendererPassState.irradianceBuffer=[e,t]}compute(e,t){}render(e,t,r,i=!1){w.cleanCache();let a=e.camera,s=e.scene;this.rendererPassState.camera3D=a;let n=k.instance.getRenderNodes(s,a),l=this.renderBundleOp(e,n,t,r),h=i?[]:this.renderBundleTr(e,n,t,r);{let u=w.beginCommandEncoder(),f=w.beginRenderPass(u,this.rendererPassState);l.length>0&&f.executeBundles(l),!i&&k.instance.sky&&(w.bindCamera(f,a),k.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,f)),this.drawRenderNodes(e,f,u,n.opaqueList,t),w.endPass(f),w.endCommandEncoder(u)}{let u=w.beginCommandEncoder(),f=w.beginRenderPass(u,this.rendererPassState);h.length>0&&f.executeBundles(h),i||(w.bindCamera(f,a),this.drawRenderNodes(e,f,u,n.transparentList,t)),w.endPass(f),w.endCommandEncoder(u)}}nodeUpload(e,t,r){}occlusionRenderNodeTest(e,t,r){return r?r.occlusionRenderNodeTest(e)>0:!0}renderOp(e,t,r,i,a){}renderTr(e,t,r,i,a){}renderBundleOp(e,t,r,i){let a=k.instance.getOpRenderGroup(e.scene);if(a){let s=[];return a.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))s.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,l,n.renderNodes,i);let h=l.finish();n.bundleMap.set(this._rendererType,h),s.push(h)}}),s}return[]}renderBundleTr(e,t,r,i){let a=k.instance.getTrRenderGroup(e.scene);if(a){let s=[];return a.renderGroup.forEach(n=>{if(n.bundleMap.has(this._rendererType))s.push(n.bundleMap.get(this._rendererType));else{let l=w.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,l,n.renderNodes,i);let h=l.finish();n.bundleMap.set(this._rendererType,h),s.push(h)}}),s}return[]}recordRenderBundleNode(e,t,r,i){w.bindCamera(t,e.camera),w.bindGeometryBuffer(t,r[0].geometry);for(let a=0;a<r.length;++a){let s=r[a];s.transform.worldMatrix.index,s.transform.enable&&s.recordRenderPass2(e,this._rendererType,this.rendererPassState,i,t)}}drawRenderNodes(e,t,r,i,a,s){w.bindCamera(t,e.camera);for(let n=m.setting.render.drawOpMin;n<Math.min(i.length,m.setting.render.drawOpMax);++n){let l=i[n];l.transform.enable&&l.enable&&l.renderPass2(e,this._rendererType,this.rendererPassState,s,t)}}setDebugTexture(e){for(let t=0;t<e.length;t++){let r=e[t],i="Quad_vert_wgsl",a="Quad_frag_wgsl";switch(r.format){case z.rgba8sint:case z.rgba8uint:case z.rgba8unorm:case z.rgba16float:case z.rgba32float:a="Quad_frag_wgsl";break;case z.depth24plus:case z.depth32float:a="Quad_depth2d_frag_wgsl",r.textureBindingLayout.viewDimension=="cube"&&(a="Quad_depthCube_frag_wgsl");break}let s=new ga(i,a,new Oe([],[]));this.debugTextures.push(e[t]),this.debugViewQuads.push(s)}}}class Ml extends pr{constructor(){super(),this.passType=W.COLOR}render(e,t,r,i=!1){this.renderContext.clean();let a=e.scene,s=e.camera;this.rendererPassState.camera3D=s;let n=k.instance.getRenderNodes(a,s),l=this.renderBundleOp(e,n,t,r),h=i?[]:this.renderBundleTr(e,n,t,r);vt.start("colorPass Renderer");{vt.start("ColorPass Draw Opaque"),this.renderContext.beginOpaqueRenderPass(),this.renderContext.command;let u=this.renderContext.encoder;w.bindCamera(u,s),l.length>0&&(k.instance.getOpRenderGroup(a),u.executeBundles(l)),!i&&k.instance.sky&&(w.bindCamera(u,s),k.instance.sky.preInit||k.instance.sky.nodeUpdate(e,this._rendererType,this.rendererPassState,r),k.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,r,u)),n.opaqueList&&(w.bindCamera(u,s),this.drawNodes(e,this.renderContext,n.opaqueList,t,r),this.renderContext.endRenderPass(),vt.end("ColorPass Draw Opaque"))}{vt.start("ColorPass Draw Transparent"),this.renderContext.beginTransparentRenderPass(),this.renderContext.command;let u=this.renderContext.encoder;h.length>0&&u.executeBundles(h),!i&&n.transparentList&&(w.bindCamera(u,s),this.drawNodes(e,this.renderContext,n.transparentList,t,r));let f=k.instance.getGraphicList();for(let g=0;g<f.length;g++){const p=f[g];p.transform.worldMatrix.index,p.nodeUpdate(e,this._rendererType,this.splitRendererPassState,r),p.renderPass2(e,this._rendererType,this.splitRendererPassState,r,u)}this.renderContext.endRenderPass(),vt.end("ColorPass Draw Transparent")}vt.end("colorPass Renderer")}drawNodes(e,t,r,i,a){let s=k.instance.getRenderShaderCollect(e);if(s){for(const n of s){let l=n[1];for(const h of l){let u=h[1];if(u.preInit){u.nodeUpdate(e,this._rendererType,this.rendererPassState,a);break}}}for(let n=m.setting.render.drawOpMin;n<Math.min(r.length,m.setting.render.drawOpMax);++n){let l=r[n];l.transform.enable&&l.enable&&(l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState,a),l.renderPass(e,this.passType,this.renderContext))}}}occlusionRenderNodeTest(e,t,r){return r.zDepthRenderNodeTest(t)>0}}class we extends Oe{static gBufferMap=new Map;static bufferTexture=!1;constructor(){super([],[])}crateGBuffer(e,t,r){let i=this.renderTargets,a=this.rtDescriptors,s=ye.createRTTexture(e+Le.colorBufferTex_NAME,t,r,z.rgba16float,!1),n=ye.createRTTexture(e+Le.positionBufferTex_NAME,t,r,z.rgba16float,!1),l=ye.createRTTexture(e+Le.normalBufferTex_NAME,t,r,z.rgba8unorm,!1),h=ye.createRTTexture(e+Le.materialBufferTex_NAME,t,r,z.rgba8unorm,!1);we.bufferTexture&&(i.push(s),i.push(n),i.push(l),i.push(h));let u=new ce;u.loadOp="clear";let f=new et(t,r,z.depth24plus,!1);f.name="depthTexture";let g=new ce;g.loadOp="load",this.depthTexture=f,we.bufferTexture&&(a.push(u),a.push(new ce),a.push(new ce),a.push(new ce))}getColorMap(){return this.renderTargets[0]}getPositionMap(){return this.renderTargets[1]}getNormalMap(){return this.renderTargets[2]}getMaterialMap(){return this.renderTargets[3]}static getGBufferFrame(e){let t;if(we.gBufferMap.has(e))t=we.gBufferMap.get(e);else{t=new we;let r=I.presentationSize;t.crateGBuffer(e,r[0],r[1]),we.gBufferMap.set(e,t)}return t}clone(){let e=new we;return this.clone2Frame(e),e}}class ds{frustumCullingList;zVisibleList;_renderList;static enable=!0;constructor(){this._renderList=new Map}occlusionRenderNodeTest(e){return m.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[e]:0:1}zDepthRenderNodeTest(e){return this.zVisibleList?this.zVisibleList[e]:0}update(e,t){}collect(e,t){}renderCommitTesting(e,t){return!0}}class Xr extends Wt{constructor(e,t){super(),this.bufferType=Et.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,e,t,"ComputeGPUBuffer")}}class Rl{clusterBuffer;lightAssignBuffer;assignTableBuffer;clustersUniformBuffer;constructor(e,t){this.clusterBuffer=new Xr(e*2*4),this.clustersUniformBuffer=new ct(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new Xr(e*t),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new Xr(e*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(e,t,r,i,a,s,n,l,h,u){this.clustersUniformBuffer.setFloat("clusterTileX",i),this.clustersUniformBuffer.setFloat("clusterTileY",a),this.clustersUniformBuffer.setFloat("clusterTileZ",s),this.clustersUniformBuffer.setFloat("numLights",n),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",l),this.clustersUniformBuffer.setFloat("near",h),this.clustersUniformBuffer.setFloat("far",u),this.clustersUniformBuffer.setFloat("screenWidth",e),this.clustersUniformBuffer.setFloat("screenHeight",t),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class qe{static clusterTileX=16;static clusterTileY=16;static clusterTileZ=32}let Ul=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${qe.clusterTileX},${qe.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,Ll=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${qe.clusterTileX},${qe.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;class Ol extends pr{maxNumLightsPerCluster=64;clusterPix=1;clusterLightingBuffer;_currentLightCount=0;_clusterGenerateCompute;_clusterLightingCompute;_useCamera;resize=!1;constructor(e){super(),this.passType=W.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new ie(Ul),this._clusterLightingCompute=new ie(Ll);let t=I.presentationSize,r=qe.clusterTileX*qe.clusterTileY*qe.clusterTileZ,i=e.camera,a=i.near,s=i.far;this.clusterLightingBuffer=new Rl(r,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(t[0],t[1],this.clusterPix,qe.clusterTileX,qe.clusterTileY,qe.clusterTileZ,0,this.maxNumLightsPerCluster,a,s),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let n=ae.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",ae.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",n.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0}render(e,t){let r=e.scene,i=k.instance.getLights(r);if(this._useCamera!=e.camera){this._useCamera=e.camera;let n=ae.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",n.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",n.uniformGPUBuffer)}this._currentLightCount!=i.length&&(this._currentLightCount=i.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",i.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=qe.clusterTileZ,this._clusterLightingCompute.workerSizeX=qe.clusterTileZ);let a=I.presentationSize;this.clusterLightingBuffer.update(a[0],a[1],this.clusterPix,qe.clusterTileX,qe.clusterTileY,qe.clusterTileZ,i.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let s=w.beginCommandEncoder();w.computeCommand(s,[this._clusterGenerateCompute,this._clusterLightingCompute]),w.endCommandEncoder(s)}}class fe extends De{resolveTarget;sampleCount;clone(){let e=new fe(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount);return e.name="clone_"+e.name,e}constructor(e,t,r=z.rgba8unorm,i=!1,a,s=1,n=0,l=!0){super(e,t,s),I.device,this.name=dt(),this.useMipmap=i,this.sampleCount=n,this.format=r,this.numberLayer=s,a!=null?this.usage=a:this.usage=a|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,t)}resize(e,t){let r=I.device;this.gpuTexture&&(De.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=t,this.createTextureDescriptor(e,t,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==z.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=r.createSampler({})):this.format==z.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==z.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.maxAnisotropy=16,this.addressModeU=ut.clamp_to_edge,this.addressModeV=ut.clamp_to_edge,this.gpuSampler=r.createSampler(this)),this._textureChange=!0}create(e,t,r=!0){let i=I.device;const a=e*4;let s=new Float32Array(e*t*4);const n=i.createBuffer({size:s.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(n,0,s);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:n,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l)}readTextureToImage(){let e=I.device,t=I.windowWidth,r=I.windowHeight,i=new Float32Array(t*r*4);const a=e.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return w.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:a},[t,r]),a.getMappedRange(0,i.byteLength)}}class Fl extends c.Object3D{up_camera;down_camera;left_camera;right_camera;front_camera;back_camera;set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}constructor(e=.001,t=1e4,r=90,i=!1){super(),this.initCubeCamera(e,t,r,i)}initCubeCamera(e,t,r=90,i=!1){this.up_camera=Te.createCamera3DObject(this,"up"),this.down_camera=Te.createCamera3DObject(this,"down"),this.left_camera=Te.createCamera3DObject(this,"left"),this.right_camera=Te.createCamera3DObject(this,"right"),this.front_camera=Te.createCamera3DObject(this,"front"),this.back_camera=Te.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=i,this.down_camera.isShadowCamera=i,this.left_camera.isShadowCamera=i,this.right_camera.isShadowCamera=i,this.front_camera.isShadowCamera=i,this.back_camera.isShadowCamera=i;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(d.ZERO,d.UP,d.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(d.ZERO,d.DOWN,d.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(d.ZERO,d.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(d.ZERO,d.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(d.ZERO,d.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(d.ZERO,d.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=me.shadow,this.down_camera.type=me.shadow,this.left_camera.type=me.shadow,this.right_camera.type=me.shadow,this.front_camera.type=me.shadow,this.back_camera.type=me.shadow}}class Nl extends De{constructor(e,t,r){super(e,t,r),this.format=z.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=I.device.createSampler({minFilter:kt.linear,magFilter:kt.linear}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class zl extends pr{shadowPassCount;_forceUpdate=!1;_shadowCameraDic;shadowCamera;cubeArrayTexture;colorTexture;shadowSize=1024;constructor(){super(),this.passType=W.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new Nl(this.shadowSize,this.shadowSize,8),this.colorTexture=new fe(this.shadowSize,this.shadowSize,z.bgra8unorm,!1),te.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,t){let r;if(this._shadowCameraDic.has(t))r=this._shadowCameraDic.get(t);else{let i=new Fl(e.camera.near,e.camera.far,90,!0);i.label=t.name;let a=[],s=[];for(let n=0;n<6;n++){let l=new fe(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),h=new Oe([this.colorTexture],[new ce]);l.name="shadowDepthTexture_"+t.name+n+"_face",h.depthTexture=l,h.label="shadowRender",h.customSize=!0;let u=Ce.createRendererPassState(h);s[n]=u,a[n]=l,m.getRenderJob(e).postRenderer?.setDebugTexture([l])}r={cubeCamera:i,depthTexture:a,rendererPassState:s},this._shadowCameraDic.set(t,r)}return r}render(e,t){if(!m.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let r=e.scene,i=ot.getPointShadowLightWhichScene(r),a=i.length;for(let s=0;s<a;s++){let n=i[s];if(n.lightData.lightType!=Ee.DirectionLight&&n.lightData.castShadowIndex>-1&&(n.needUpdateShadow||this._forceUpdate||ue.frame<5||n.realTimeShadow)){n.needUpdateShadow=!1;let l=this.getShadowCamera(e,n),h=n.transform.worldPosition;l.cubeCamera.x=h.x,l.cubeCamera.y=h.y,l.cubeCamera.z=h.z;let u;l.cubeCamera.transform.updateWorldMatrix(!0),t.update(l.cubeCamera.right_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.right_camera),this.renderSceneOnce(0,l,e,l.cubeCamera.right_camera,u,t),t.update(l.cubeCamera.left_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.left_camera),this.renderSceneOnce(1,l,e,l.cubeCamera.left_camera,u,t),t.update(l.cubeCamera.up_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.up_camera),this.renderSceneOnce(2,l,e,l.cubeCamera.up_camera,u,t),t.update(l.cubeCamera.down_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.down_camera),this.renderSceneOnce(3,l,e,l.cubeCamera.down_camera,u,t),t.update(l.cubeCamera.front_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.front_camera),this.renderSceneOnce(4,l,e,l.cubeCamera.front_camera,u,t),t.update(l.cubeCamera.back_camera,r),u=k.instance.getRenderNodes(r,l.cubeCamera.back_camera),this.renderSceneOnce(5,l,e,l.cubeCamera.back_camera,u,t);let f=w.beginCommandEncoder();for(let g=0;g<6;g++)f.copyTextureToTexture({texture:l.depthTexture[g].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:n.shadowIndex*6+g}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});w.endCommandEncoder(f)}}this._forceUpdate=!1}renderSceneOnce(e,t,r,i,a,s){this.rendererPassState=t.rendererPassState[e];let n=w.beginCommandEncoder(),l=w.beginRenderPass(n,this.rendererPassState);l.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),l.setScissorRect(0,0,this.shadowSize,this.shadowSize),i.onUpdate(),i.transform.updateWorldMatrix(!0);let h=k.instance.getRenderShaderCollect(r);for(const u of h){let f=u[1];for(const g of f){let p=g[1];if(p.preInit){p.nodeUpdate(r,this._rendererType,this.rendererPassState,null);break}}}this.drawShadowRenderNodes(r,i,l,a.opaqueList,s),this.drawShadowRenderNodes(r,i,l,a.transparentList,s),w.endPass(l),w.endCommandEncoder(n)}drawShadowRenderNodes(e,t,r,i,a){if(w.bindCamera(r,t),i)for(let s=m.setting.render.drawOpMin;s<Math.min(i.length,m.setting.render.drawOpMax);++s){let n=i[s];if(n.transform.worldMatrix.index,!!n.transform.enable&&n.enable){n.preInit||n.nodeUpdate(e,this._rendererType,this.rendererPassState);for(let l of n.materials){let h=l.getPass(this._rendererType);if(!h||h.length==0)continue;w.bindGeometryBuffer(r,n.geometry);let u=n.object3D.transform._worldMatrix;for(let f of h){const g=f;if(g.pipeline){g.setUniformFloat("cameraFar",t.far),g.setUniformVector3("lightWorldPos",t.transform.worldPosition),g.materialDataUniformBuffer.apply(),w.bindPipeline(r,g);let p=n.geometry.subGeometries;for(const A of p){let C=A.lodLevels[n.lodLevel];w.drawIndexed(r,C.indexCount,1,C.indexStart,0,u.index)}}}}}}}}class kl extends De{constructor(e,t,r=z.depth32float,i=4){super(e,t,i),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Gl extends pr{shadowPassCount;depth2DArrayTexture;rendererPassStates;_forceUpdate=!1;constructor(){super(),this.setShadowMap(m.setting.shadow.shadowSize,At.Cascades),this.passType=W.SHADOW}setShadowMap(e,t){this.rendererPassStates=[],this.depth2DArrayTexture=new kl(e,e,z.depth32float,8),te.getInstance().attached(this.depth2DArrayTexture,this);for(let r=0;r<8;r++){let i=new Oe([],[]);const a=new fe(e,e,z.depth32float,!1);a.name=`shadowDepthTexture_${r}`,i.depthTexture=a,i.label="shadowRender",i.customSize=!0,i.depthCleanValue=1;let s=Ce.createRendererPassState(i);this.rendererPassStates[r]=s}}render(e,t){let r=m.setting.shadow;if(!r.enable)return;let i=e.camera,a=e.scene;if(this.shadowPassCount=0,!r.needUpdate||ue.frame%r.updateFrameRate!=0)return;let s=ot.getDirectShadowLightWhichScene(a),n=r.shadowSize;const l=At.Cascades;for(let h of s){const u=h;let f=u.shadowIndex;this.rendererPassState=this.rendererPassStates[f],n=this.rendererPassState.depthTexture.width;let g=k.instance.getRenderShaderCollect(e);for(const p of g){let A=p[1];for(const v of A){let C=v[1];if(C.preInit){C.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(u.castShadow&&u.needUpdateShadow||this._forceUpdate||u.castShadow&&r.autoUpdate)if(u.needUpdateShadow=!1,i.enableCSM&&f==0)for(let p=0;p<l;p++){this.rendererPassState=this.rendererPassStates[p];let A=i.csm.children[p],v=i.getCSMShadowWorldExtents(p);this.poseShadowCamera(i,u.direction,A.shadowCamera,v,A.bound.center),this.renderShadow(e,A.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,p,n)}else{i.enableCSM&&(f+=l-1);let p=i.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[f],this.poseShadowCamera(i,u.direction,u.shadowCamera,p,i.lookTarget),this.renderShadow(e,u.shadowCamera,t,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,f,n)}}this._forceUpdate=!1}copyDepthTexture(e,t,r,i){let a=w.beginCommandEncoder();a.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:t.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:i,height:i,depthOrArrayLayers:1}),w.endCommandEncoder(a)}_shadowPos=new d;_shadowCameraTarget=new d;poseShadowCamera(e,t,r,i,a){this._shadowPos.copy(t).normalize(e.far),a.add(this._shadowPos,this._shadowCameraTarget),a.subtract(this._shadowPos,this._shadowPos),r.transform.lookAt(this._shadowPos,this._shadowCameraTarget),r.orthoOffCenter(-i,i,-i,i,e.near,e.far*2)}compute(){}renderShadow(e,t,r,i){let a=k.instance.getRenderNodes(e.scene,t),s=w.beginCommandEncoder(),n=w.beginRenderPass(s,i);t.transform.updateWorldMatrix(),ds.enable&&(r.update(t,e.scene),r.collect(a,t)),w.bindCamera(n,t);let l=this.renderShadowBundleOp(e,t,i),h=this.renderShadowBundleTr(e,t,i);l.length>0&&n.executeBundles(l),this.drawShadowRenderNodes(e,t,n,a.opaqueList),h.length>0&&n.executeBundles(h),this.drawShadowRenderNodes(e,t,n,a.transparentList),w.endPass(n),w.endCommandEncoder(s)}renderShadowBundleOp(e,t,r){let i=k.instance.getOpRenderGroup(e.scene);if(i){let a=[];return i.renderGroup.forEach(s=>{if(s.bundleMap.has(this._rendererType))a.push(s.bundleMap.get(this._rendererType));else{let n=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,n,s.renderNodes);let l=n.finish();s.bundleMap.set(this._rendererType,l),a.push(l)}}),a}return[]}renderShadowBundleTr(e,t,r){let i=k.instance.getTrRenderGroup(e.scene);if(i){let a=[];return i.renderGroup.forEach(s=>{if(s.bundleMap.has(this._rendererType))a.push(s.bundleMap.get(this._rendererType));else{let n=w.recordBundleEncoder(r.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,t,n,s.renderNodes);let l=n.finish();s.bundleMap.set(this._rendererType,l),a.push(l)}}),a}return[]}recordShadowRenderBundleNode(e,t,r,i,a){if(w.bindCamera(r,t),i){w.bindGeometryBuffer(r,i[0].geometry);for(let s=0;s<i.length;++s){let n=i[s];n.transform.enable&&n.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}drawShadowRenderNodes(e,t,r,i,a){if(w.bindCamera(r,t),i)for(let s=m.setting.render.drawOpMin;s<Math.min(i.length,m.setting.render.drawOpMax);++s){let n=i[s];n.transform.enable&&n.enable&&n.castShadow&&n.renderPass2(e,this._rendererType,this.rendererPassState,a,r)}}}class Ql extends pr{zBufferTexture;useRenderBundle=!1;shadowPassCount;zCullingCompute;constructor(){super(),this.passType=W.DEPTH;let e=I.presentationSize,t=1;this.zBufferTexture=ye.createRTTexture(Le.zBufferTexture_NAME,Math.floor(e[0]*t),Math.floor(e[1]*t),z.rgba16float,!1);let r=new ce;r.clearValue=[0,0,0,0],r.loadOp="clear";let i=new Oe([],[],ye.createRTTexture(Le.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),z.depth32float,!1),null,!1);this.setRenderStates(i)}render(e,t){let r=e.camera,i=e.scene;w.cleanCache(),vt.start("DepthPass Renderer");let a=i;this.rendererPassState.camera3D=r;let s=k.instance.getRenderNodes(a,r);this.compute(e,t);let n=this.renderBundleOp(e,s,t),l=[],h=w.beginCommandEncoder(),u=w.beginRenderPass(h,this.rendererPassState);n.length>0&&u.executeBundles(n);let f=k.instance.getRenderShaderCollect(e);for(const g of f){let p=g[1];for(const A of p){let v=A[1];if(v.preInit){v.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,u,h,s.opaqueList,t),l.length>0&&u.executeBundles(l),w.endPass(u),w.endCommandEncoder(h),vt.end("DepthPass Renderer")}drawRenderNodes(e,t,r,i,a,s){w.bindCamera(t,e.camera);for(let n=m.setting.render.drawOpMin;n<Math.min(i.length,m.setting.render.drawOpMax);++n){let l=i[n];l.transform.enable&&l.enable&&(l.preInit||l.nodeUpdate(e,this._rendererType,this.rendererPassState),l.renderPass2(e,this._rendererType,this.rendererPassState,s,t))}}}class Vl{map;passRendererList;constructor(){this.map=new Map,this.passRendererList=[]}addRenderer(e){this.map.has(e.passType)?console.error("same renderer pass repeat!"):(this.map.set(e.passType,e),e.passType<=8&&this.addPassRenderer(e))}getRenderer(e){return this.map.get(e)}addPassRenderer(e){this.passRendererList.push(e)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Hl extends pr{finalQuadView;postList;constructor(){super(),this._rendererType=W.POST,this.postList=[],this.initRenderer()}initRenderer(){F.register("FullQuad_vert_wgsl",dn),this.finalQuadView=new ga("Quad_vert_wgsl","Quad_frag_wgsl",new Oe([],[]),0,!1)}attachPost(e,t){t.postRenderer=this,this.postList.indexOf(t)!=-1||(this.postList.push(t),t.onAttach(e))}detachPost(e,t){let r=this.postList.indexOf(t);return r>=0&&(this.postList.splice(r,1),t.onDetach(e),t.postRenderer=null),r>=0}render(e){let t=w.beginCommandEncoder();for(let i=0;i<this.postList.length;i++){const a=this.postList[i];a.enable&&a.render(e,t)}let r=w.lastRenderPassState.getLastRenderTexture();if(this.finalQuadView.renderToViewQuad(e,this.finalQuadView,t,r),this.debugViewQuads.length){let i=m.setting.render.debugQuad;i>=0&&this.debugViewQuads[i].renderToViewQuad(e,this.debugViewQuads[i],t,this.debugTextures[i])}w.endCommandEncoder(t)}}class Ct{enable=!0;postRenderer;rtViewQuad;virtualTexture;constructor(){this.rtViewQuad=new Map,this.virtualTexture=new Map,I.addEventListener(yr.RESIZE,this.onResize,this)}createRTTexture(e,t,r,i,a=!1,s=0){let n=ye.createRTTexture(e,t,r,i,a,s);return n.name=e,this.virtualTexture.set(e,n),te.getInstance().attached(n,this),n}createViewQuad(e,t,r,i=0){let a=ye.createViewQuad(e,"Quad_vert_wgsl",t,r,i);return this.rtViewQuad.set(e,a),a}getOutTexture(){let e,t=w.lastRenderPassState.renderTargets;return t.length>0?e=t[0]:e=ye.getTexture(Le.colorBufferTex_NAME),e}autoSetColorTexture(e,t){let r=this.getOutTexture();t.setSamplerTexture(e,r)}compute(e){}onAttach(e){}onDetach(e){}onResize(){}render(e,t){this.compute(e),this.rtViewQuad.forEach((r,i)=>{let a=w.lastRenderPassState.getLastRenderTexture();r.renderToViewQuad(e,r,t,a)})}destroy(e){this.postRenderer=null;for(let t=0;t<this.rtViewQuad.size;t++)this.rtViewQuad.values[t].destroy(e);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let t=0;t<this.virtualTexture.size;t++){const r=this.virtualTexture.values[t];te.getInstance().detached(r,this),r.destroy(e)}}}class Yl{rendererMap;shadowMapPassRenderer;pointLightShadowRenderer;ddgiProbeRenderer;postRenderer;clusterLightingRender;occlusionSystem;depthPassRenderer;colorPassRenderer;pauseRender=!1;pickFire;renderState=!1;_view;constructor(e){this._view=e,this.rendererMap=new Vl,this.occlusionSystem=new ds,this.clusterLightingRender=this.addRenderer(Ol,e),m.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Ql)),this.shadowMapPassRenderer=new Gl,this.pointLightShadowRenderer=new zl}addRenderer(e,t){let r;return t?r=new e(t):r=new e,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(e){this._view=e}start(){this.renderState=!0}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}enablePost(e){this.postRenderer=this.addRenderer(Hl),this.postRenderer.setRenderStates(e)}addPost(e){return this.postRenderer||(we.bufferTexture=!0,this.enablePost(we.getGBufferFrame("ColorPassGBuffer"))),e instanceof Ct&&this.postRenderer.attachPost(this.view,e),e}removePost(e){if(e instanceof Ct)this.postRenderer.detachPost(this.view,e);else for(let t=0;t<e.length;t++)this.postRenderer.detachPost(this.view,e[t])}renderFrame(){let e=this._view;ae.getLightEntries(e.scene).update(e),this.occlusionSystem.update(e.camera,e.scene),this.clusterLightingRender.render(e,this.occlusionSystem),this.shadowMapPassRenderer&&(ot.update(e),this.shadowMapPassRenderer.render(e,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(e,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(e,this.occlusionSystem),this.depthPassRenderer.render(e,this.occlusionSystem)),m.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(e,this.occlusionSystem),this.ddgiProbeRenderer.render(e,this.occlusionSystem));let t=this.rendererMap.getAllPassRenderer();for(let r=0;r<t.length;r++){const i=t[r];i.compute(e,this.occlusionSystem),i.render(e,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer)}this.postRenderer&&this.postRenderer.postList.length>0&&this.postRenderer.render(e)}debug(){}}class Xl extends c.Object3D{up_camera;down_camera;left_camera;right_camera;front_camera;back_camera;constructor(e=.001,t=1e4,r=90,i=!1){super(),this.initCubeCamera(e,t,r,i)}initCubeCamera(e,t,r=90,i=!1){this.up_camera=Te.createCamera3DObject(this,"up"),this.down_camera=Te.createCamera3DObject(this,"down"),this.left_camera=Te.createCamera3DObject(this,"left"),this.right_camera=Te.createCamera3DObject(this,"right"),this.front_camera=Te.createCamera3DObject(this,"front"),this.back_camera=Te.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=i,this.down_camera.isShadowCamera=i,this.left_camera.isShadowCamera=i,this.right_camera.isShadowCamera=i,this.front_camera.isShadowCamera=i,this.back_camera.isShadowCamera=i;let a=1;this.up_camera.perspective(r,a,e,t),this.up_camera.lookAt(d.ZERO,d.UP,d.DOWN),this.down_camera.perspective(r,a,e,t),this.down_camera.lookAt(d.ZERO,d.DOWN,d.DOWN),this.left_camera.perspective(r,a,e,t),this.left_camera.lookAt(d.ZERO,d.LEFT),this.right_camera.perspective(r,a,e,t),this.right_camera.lookAt(d.ZERO,d.RIGHT),this.front_camera.perspective(r,a,e,t),this.front_camera.lookAt(d.ZERO,d.FORWARD),this.back_camera.perspective(r,a,e,t),this.back_camera.lookAt(d.ZERO,d.BACK),this.up_camera.type=me.shadow,this.down_camera.type=me.shadow,this.left_camera.type=me.shadow,this.right_camera.type=me.shadow,this.front_camera.type=me.shadow,this.back_camera.type=me.shadow}}class jl extends Oe{constructor(e,t,r=!0){super([],[]),this.crateGBuffer(e,t,r)}crateGBuffer(e,t,r){let i=this.renderTargets,a=this.rtDescriptors,s=new et(e,t,z.rgba16float,!1,void 0,1,0,!0,r);s.name="positionMap";let n=new ce;n.loadOp="load";let l=new et(e,t,z.rgba16float,!1,void 0,1,0,!0,r);l.name="normalMap";let h=new ce;h.loadOp="load";let u=new et(e,t,z.rgba16float,!1,void 0,1,0,!0,r);u.name="colorMap";let f=new ce;f.loadOp="load";let g=new et(e,t,z.depth24plus,!1,void 0,1,0,!0,r);g.name="depthTexture";let p=new ce;p.loadOp="load",i.push(s),i.push(l),i.push(u),a.push(n),a.push(h),a.push(f),this.depthTexture=g}}let Wl=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //\u5DE6\u53F3
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u4E0A\u4E0B
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u8865\u89D2
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class ql{irradianceBuffer;depthBuffer;probeIrradianceMap;probeDepthMap;volume;computeShader;depthRaysBuffer;constructor(e){this.volume=e,this.initPipeline()}initPipeline(){this.computeShader=new ie(Wl);let e=m.setting.gi,t=e.octRTMaxSize*e.octRTMaxSize;this.irradianceBuffer=new Z(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new Z(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new Z(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",ae.modelMatrixBindGroup.matrixBufferDst)}setTextures(e,t,r){this.probeIrradianceMap=t,this.probeDepthMap=r;let i=e[0],a=e[1],s=e[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",i),this.computeShader.setSamplerTexture("normalMap",a),this.computeShader.setSamplerTexture("colorMap",s)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(e,t){let r=this.volume.setting,i=w.beginCommandEncoder(),a=k.instance.getProbes(e.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=a.length,w.computeCommand(i,[this.computeShader])}}let Kl=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Jl{blendTexture;volume;computerShader;constructor(e){this.volume=e,this.initPipeline()}initPipeline(){let e=m.setting.gi;this.blendTexture=new et(e.probeSourceTextureSize,e.probeSourceTextureSize,z.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new ie(Kl),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(e){let t=e[0],r=e[1],i=e[2],a=e[3];this.computerShader.setSamplerTexture("normalMap",t),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",i),this.computerShader.setSamplerTexture("irradianceMap",a)}compute(e,t){let r=w.beginCommandEncoder(),i=this.volume.setting,a=i.probeXCount*i.probeYCount*i.probeZCount,s=i.probeSize;this.computerShader.workerSizeX=s*6/8,this.computerShader.workerSizeY=s/8,this.computerShader.workerSizeZ=a,w.computeCommand(r,[this.computerShader])}}let Zl=`
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(auto) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(auto) var prefilterMapSampler: sampler;
@group(0) @binding(auto) var prefilterMap: texture_cube<f32>;

@group(1) @binding(auto) var positionMapSampler : sampler;
@group(1) @binding(auto) var positionMap : texture_2d<f32>;

@group(1) @binding(auto) var normalMapSampler : sampler;
@group(1) @binding(auto) var normalMap : texture_2d<f32>;

@group(1) @binding(auto) var colorMapSampler : sampler;
@group(1) @binding(auto) var colorMap : texture_2d<f32>;

@group(1) @binding(auto) var shadowMapSampler : sampler_comparison;
@group(1) @binding(auto) var shadowMap : texture_depth_2d_array;
@group(1) @binding(auto) var pointShadowMapSampler: sampler;
@group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${At.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
    var shadowIndex = i32(light.castShadow);
    if (shadowIndex >= 0 ) {
      var shadowMatrix:mat4x4<f32>;
      if(enableCSM && csmCount > 1){
        for(var csm:i32 = 0; csm < csmCount; csm ++){
          var csmShadowBias = globalUniform.csmShadowBias[csm];
          shadowMatrix = globalUniform.csmMatrix[csm];
          let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
          if(csmShadowResult.y < 0.5){
            visibility = csmShadowResult.x;
            break;
          }
        }
      }else{
        shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
        visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
      }
    }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`;class $l{computeShader;worldPosMap;worldNormalMap;colorMap;shadowMap;pointShadowMap;lightingTexture;constructor(){let e=m.setting.gi;this.lightingTexture=new et(e.probeSourceTextureSize,e.probeSourceTextureSize,z.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(e){let t=ae.getLightEntries(e.scene);this.computeShader=new ie(Zl);let r=ae.getCameraGroup(e.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",t.storageGPUBuffer),this.computeShader.setStorageBuffer("models",ae.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",m.res.defaultSky)}setInputs(e){this.worldPosMap=e[0],this.worldNormalMap=e[1],this.colorMap=e[2],this.shadowMap=e[3],this.pointShadowMap=e[4]}compute(e,t){this.computeShader||this.create(e);let r=w.beginCommandEncoder(),i=m.setting.gi;this.computeShader.workerSizeX=i.probeSourceTextureSize/8,this.computeShader.workerSizeY=i.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,w.computeCommand(r,[this.computeShader])}}let pa=new Ne("GIRenderStartEvent"),gs=new Ne("GIRenderCompleteEvent");class md{count;complete}class eh extends pr{cubeCamera;volume;probeCountPerFrame=1;nextProbeIndex=-1;tempProbeList=[];isRenderCloudGI;probeRenderResult;renderStatus="none";positionMap;normalMap;colorMap;probeNext=128;sizeW;sizeH;lightingPass;bouncePass;irradianceComputePass;irradianceDepthMap;irradianceColorMap;constructor(e){super(),this.passType=W.GI,this.volume=e;let t=e.setting;this.cubeCamera=new Xl(.01,5e3),this.sizeW=t.probeSourceTextureSize,this.sizeH=t.probeSourceTextureSize,this.probeNext=t.probeSourceTextureSize/t.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new md;let r=new jl(this.sizeW,this.sizeH,!1);this.positionMap=r.renderTargets[0],this.normalMap=r.renderTargets[1],this.colorMap=r.renderTargets[2],this.setRenderStates(r)}setInputTexture(e){this.lightingPass=new $l,this.bouncePass=new Jl(this.volume),this.irradianceComputePass=new ql(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,t,r,i){if(r!=this.irradianceColorMap.width||i!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,r,i),this.writeToTexture(this.irradianceDepthMap,t,r,i)}updateProbe(e,t,r){let i=k.instance.getLights(e.scene),a=this.volume.setting.probeSize;t.drawCallFrame+=1,this.cubeCamera.x=t.x,this.cubeCamera.y=t.y,this.cubeCamera.z=t.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=t.rotationX,this.cubeCamera.rotationY=t.rotationY,this.cubeCamera.rotationZ=t.rotationZ);let s=this.cubeCamera,n=Math.floor(t.index/this.probeNext)*(a*6),l=Math.floor(t.index%this.probeNext)*a;r.setViewport(0+n,l,a,a,0,1),this.renderSceneOnce(e,s.right_camera,r,i),r.setViewport(a+n,l,a,a,0,1),this.renderSceneOnce(e,s.left_camera,r,i),r.setViewport(a*2+n,l,a,a,0,1),this.renderSceneOnce(e,s.up_camera,r,i),r.setViewport(a*3+n,l,a,a,0,1),this.renderSceneOnce(e,s.down_camera,r,i),r.setViewport(a*4+n,l,a,a,0,1),this.renderSceneOnce(e,s.front_camera,r,i),r.setViewport(a*5+n,l,a,a,0,1),this.renderSceneOnce(e,s.back_camera,r,i)}renderSceneOnce(e,t,r,i){this.volume.uploadBuffer();let a=k.instance.getRenderNodes(e.scene,t);w.bindCamera(r,t);let s=Math.max(0,m.setting.render.drawOpMin),n=Math.min(m.setting.render.drawOpMax,a.opaqueList.length),l=k.instance.getRenderShaderCollect(e);for(const h of l){let u=h[1];for(const f of u){let g=f[1];if(g.preInit){g.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let h=s;h<n;++h){let u=a.opaqueList[h];u.enable&&u.transform.enable&&(u.preInit||u.nodeUpdate(e,this.passType,this.rendererPassState,null),u.renderPass2(e,this.passType,this.rendererPassState,null,r))}k.instance.sky&&(k.instance.sky.preInit||k.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),k.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,r)),s=Math.max(0,m.setting.render.drawTrMin),n=Math.min(m.setting.render.drawTrMax,a.transparentList.length);for(let h=s;h<n;++h){let u=a.transparentList[h];u.enable&&u.transform.enable&&(u.preInit||u.nodeUpdate(e,this.passType,this.rendererPassState,null),u.renderPass2(e,this.passType,this.rendererPassState,null,r))}}render(e,t){if(!m.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let r=this.probeRenderResult.count>0;(k.instance.state.giLightingChange||r||m.setting.gi.realTimeGI)&&(k.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(gs)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(pa),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(pa),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let t=m.setting.gi.autoRenderProbe,r=!1;if(t?(this.nextProbeIndex==-1&&this.startRenderGI(),r=!0):r=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,r){let i=k.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginOpaqueRenderPass(),this.tempProbeList.length=0;let a=Math.min(this.probeCountPerFrame,i.length);for(this.probeRenderResult.count=a;a>0;){const n=i[this.nextProbeIndex];this.updateProbe(e,n,this.renderContext.encoder),a--,this.nextProbeIndex++,n.drawCallFrame<3&&this.tempProbeList.push(n)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let s=this.nextProbeIndex>=i.length;this.nextProbeIndex>=i.length&&this.isRenderCloudGI&&this.updateProbe(e,i[0],this.renderContext.encoder),this.renderContext.endRenderPass(),s&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let t=e.setting,r=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new et(t.octRTMaxSize,t.octRTMaxSize,z.rgba16float,!1,r),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new et(t.octRTMaxSize,t.octRTMaxSize,z.rgba16float,!1,r),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,t,r,i){console.log(e.name);const a=I.device.createBuffer({size:t.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});I.device.queue.writeBuffer(a,0,t);const s=w.beginCommandEncoder();s.copyBufferToTexture({buffer:a,bytesPerRow:r*16},{texture:e.getGPUTexture()},{width:r,height:i,depthOrArrayLayers:1}),w.endCommandEncoder(s)}}class ps extends Yl{constructor(e){super(e)}start(){super.start();let e=we.getGBufferFrame("ColorPassGBuffer");{let t=[],r=new Ml;m.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),r.setRenderStates(e);for(let i=0;i<e.renderTargets.length;i++){const a=e.renderTargets[i];t.push(a)}if(m.setting.gi.enable){let i=ae.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new eh(i.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),r.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer),t.push(this.ddgiProbeRenderer.positionMap,this.ddgiProbeRenderer.normalMap,this.ddgiProbeRenderer.colorMap,this.ddgiProbeRenderer.lightingPass.lightingTexture,this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap)}this.postRenderer&&this.postRenderer.setDebugTexture(t),this.rendererMap.addRenderer(r)}m.setting.render.debug&&this.debug()}debug(){}}class th{_factor;_doubleFactor;constructor(){this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(e){this._factor=e,this._doubleFactor=2*this._factor}getInterpolation(e){return this._factor==1?e*e:Math.pow(e,this._doubleFactor)}}class rh{_factor=1;constructor(){}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(e){this._factor=e}getInterpolation(e){let t;return this._factor==1?t=1-(1-e)*(1-e):t=1-Math.pow(1-e,2*this._factor),t}}class ih{_factor=1;constructor(){}getInterpolation(e){return Math.cos((e+1)*Math.PI)/2+.5}}class ah{getInterpolation(e){return e}}class sh{getInterpolation(e){return 4.9*e+4.9*e}}class gt{constructor(){}static bounce(e){return e*e*9.8}getInterpolation(e){return e*=1.1226,e<.3535?gt.bounce(e):e<.7408?gt.bounce(e-.54719)+.7:e<.9644?gt.bounce(e-.8526)+.9:gt.bounce(e-1.0435)+.95}getBounceInterpolation(e){return e<.5?gt.bounce(e):gt.bounce(e-1)}geJumpUp(e,t){return t<.5?(t=t/.5,e*t-gt.bounce(t)):t<.8?(t=(t-.5)/(.8-.5),(e*t-gt.bounce(t))*.3):t<1?(t=(t-.8)/(1-.8),(e*t-gt.bounce(t))*.15):e*t-gt.bounce(t)}}class oh{_tension;constructor(){this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(e){this._tension=e}getInterpolation(e){return e*e*((this._tension+1)*e-this._tension)}}class Ai{_tension;constructor(){this._tension=1*1.5}anticipateOvershootInterpolator(e){this._tension=e*1.5}anticipateOvershootInterpolator2(e,t){this._tension=e*t}getInterpolation(e){return e<.5?.5*Ai.a(e*2,this._tension):.5*(Ai.o(e*2-2,this._tension)+2)}static a(e,t){return e*e*((t+1)*e-t)}static o(e,t){return e*e*((t+1)*e+t)}}class nh{_cycles;constructor(e){this._cycles=e}getInterpolation(e){return Math.sin(2*this._cycles*Math.PI*e)}}class lh{_tension;constructor(){this._tension=2}getInterpolation(e){return e-=1,e*e*((this._tension+1)*e+this._tension)+1}}var ms=(o=>(o[o.AccelerateInterpolator=0]="AccelerateInterpolator",o[o.DecelerateInterpolator=1]="DecelerateInterpolator",o[o.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",o[o.LinearInterpolator=3]="LinearInterpolator",o[o.BounceInterpolator=4]="BounceInterpolator",o[o.AnticipateInterpolator=5]="AnticipateInterpolator",o[o.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",o[o.CycleInterpolator=7]="CycleInterpolator",o[o.OvershootInterpolator=8]="OvershootInterpolator",o[o.JumperInterpolator=9]="JumperInterpolator",o))(ms||{});class mr{static interpolators=[];complete=!1;onComplete;onProgress;target;property;targetProperty;durtion;interpolatorEnum;delayTime=0;_interpolator;_ct=0;_p=0;static to(e,t,r,i=0){var a=new mr;return a.target=e,a.property=t,a.durtion=r,a.interpolatorEnum=i,a.start(),a.delayTime=t.delayTime?t.delayTime:0,t.onComplete&&(a.onComplete=t.onComplete),t.onProgress&&(a.onProgress=t.onProgress),this.interpolators.push(a),a}static tick(e){let t=mr.interpolators;for(let r of t)r.complete?mr.remove(r,!0):r.tick(e)}static remove(e,t){let r=mr.interpolators,i=r.indexOf(e);i!=-1&&r.splice(i,1),t&&e.dispose()}static removeList(e,t){e.forEach(r=>{this.remove(r,t)})}start(){window.AccelerateInterpolator=th,window.DecelerateInterpolator=rh,window.AccelerateDecelerateInterpolator=ih,window.LinearInterpolator=ah,window.BounceInterpolator=gt,window.AnticipateInterpolator=oh,window.AnticipateOvershootInterpolator=Ai,window.CycleInterpolator=nh,window.OvershootInterpolator=lh,window.JumperInterpolator=sh,this._interpolator=new window[ms[this.interpolatorEnum]],this.targetProperty={};for(let e in this.property)this.targetProperty[e]=this.target[e]}tick(e){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let t=this._interpolator.getInterpolation(this._p),r=this.property,i=this.target,a=this.targetProperty,s,n;for(let l in r)n=r[l],s=a[l],i[l]=s+(n-s)*t;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=e}else this.delayTime-=e}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,mr.remove(this)}}class tt{static _filterChar=[" ","  ",";",`
`,"\r","	",`
`,"\r","	"];static hasString(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}static getEllipsis(e,t=4){let r=e;return r.length>t&&(r=r.slice(0,t)+"..."),r}static getURLName(e){var t;t=e.split("/");let r=t[t.length-1];return r=r.split(".")[0],r}static getFileFormat(e){var t=e.lastIndexOf(".");t++;var r=e.length;e.indexOf("?",t)!==-1&&(r=e.indexOf("?",t));var i=e.substr(t,r-t);return i=i.toLowerCase(),i}static readLineProperty(e,t){e.trim().split(" ").forEach((r,i)=>{let a=r.split("=");if(a.length>1){let s=a[0],n=a[1];Object.prototype.hasOwnProperty.call(t,s)&&(n.indexOf('"')==-1?t[s]=parseFloat(a[1]):t[s]=n.replace('"',"").replace('"',""))}})}static getPath(e){var t=e.lastIndexOf("/");return t++,e.substring(0,t)}static normalizePath(e){var t=e.replaceAll("//","/");return t=t.replaceAll("\\","/"),t}static getStringList(e,t=";"){return e.split(t)}static formatTime(e){let r=e/1e3/60,i=Math.floor(r),a=Math.floor(r-i);return[i.toString(),a.toString()]}static trim(e){return e.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(e){return!e||typeof e>"u"||e==null||typeof e=="string"&&this.trim(e)===""||e==="null"}static strCut(e,t){if(e.length*2<=t)return e;for(var r=0,i="",a=0;a<e.length;a++)if(i=i+e.charAt(a),e.charCodeAt(a)>128){if(r=r+2,r>=t)return i.substring(0,i.length-1)+"..."}else if(r=r+1,r>=t)return i.substring(0,i.length-2)+"...";return i}static toQueryPair(e,t,r=!1){return e+"="+(r?encodeURIComponent(t):t)}static stringFormat(e,...t){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let i=new RegExp("({"+r+"})","g");e=e.replace(i,arguments[1][r])}else for(let r=0;r<t.length;r++){if(t[r]==null)return e;{let i=new RegExp("({["+r+"]})","g");e=e.replace(i,t[r])}}return e}static parseJson2String(e,t){let r=null,i="",a=0,s="    ";return t=t||{},t.newlineAfterColonIfBeforeBraceOrBracket=t.newlineAfterColonIfBeforeBraceOrBracket===!0,t.spaceAfterColon=t.spaceAfterColon!==!1,typeof e!="string"||(e=JSON.parse(e)),e=JSON.stringify(e),r=/([\{\}])/g,e=e.replace(r,`\r
$1\r
`),r=/([\[\]])/g,e=e.replace(r,`\r
$1\r
`),r=/(\,)/g,e=e.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,e=e.replace(r,`\r
`),r=/\r\n\,/g,e=e.replace(r,","),t.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,e=e.replace(r,":{"),r=/\:\r\n\[/g,e=e.replace(r,":[")),t.spaceAfterColon&&(r=/\:/g,e=e.replace(r,":")),e.split(`\r
`).forEach(function(n,l){let h=0,u=0,f="";for(n.match(/\{$/)||n.match(/\[$/)?u=1:n.match(/\}/)||n.match(/\]/)?a!==0&&(a-=1):u=0,h=0;h<a;h++)f+=s;i+=f+n+`\r
`,a+=u}),i}static compareVersion(e,t){e=e.split("."),t=t.split(".");let r=Math.max(e.length,t.length);for(;e.length<r;)e.push("0");for(;t.length<r;)t.push("0");for(let i=0;i<r;i++){let a=parseInt(e[i]),s=parseInt(t[i]);if(a>s)return 1;if(a<s)return-1}return 0}static buildRandomCode(){let e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",t=e.length,r="";for(let a=0;a<26;a++){let s=Math.floor(Math.random()*t);r+=e.charAt(s)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){var t=Math.random()*16|0,r=e=="x"?t:t&3|8;return r.toString(16)})}static stringToHash(e){let t=0;if(e.length==0)return t;for(let r=0;r<e.length;r++){const i=e.charCodeAt(r);t=(t<<5)-t+i,t=t&t}return t}static parseUrl(e,t){return t.match(/^(blob|http|https):/)?t:e+t}}class tr extends De{_source;premultiplyAlpha="none";constructor(e=!0){super(),this.useMipmap=e,this.lodMinClamp=0,this.lodMaxClamp=4}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(async()=>{if(this._source instanceof HTMLImageElement){const t=await createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.generate(t)}}):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}async load(e,t){if(this.name=tt.getURLName(e),e.indexOf(";base64")!=-1){const r=document.createElement("img");let i=e.indexOf("data:image"),a=e.substring(i,e.length);r.src=a,await r.decode(),r.width=Math.max(r.width,32),r.height=Math.max(r.height,32);const s=await createImageBitmap(r,{resizeWidth:r.width,resizeHeight:r.height,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.format=z.rgba8unorm,this.generate(s)}else return new Promise((r,i)=>{fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},t?.headers)}).then(a=>{Dr.read(e,a,t).then(s=>{let n=new Blob([s],{type:"image/jpeg"});s=null,this.loadFromBlob(n).then(()=>{r(!0)})})})});return!0}imageData;async loadFromBlob(e){this.imageData=e;let t=await createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});if(t.width<32||t.height<32){let r=Math.max(t.width,32),i=Math.max(t.height,32);t=await createImageBitmap(t,{resizeWidth:r,resizeHeight:i,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"})}return this.format=z.rgba8unorm,this.generate(t),!0}}class Dr{baseUrl="";initUrl;_progress=0;constructor(){}async loadBinData(e,t){return this.baseUrl=tt.getPath(e),this.initUrl=e,new Promise(async(r,i)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let s=await Dr.read(e,a,t),n=s.buffer;s=null,r(n)}else throw Error("request rejected with status "+a.status)}).catch(a=>{t.onError&&t.onError(a),i(a)})})}async loadAsyncBitmapTexture(e,t){this.baseUrl=tt.getPath(e),this.initUrl=e;let r=new tr;return r.url=e,r.name=tt.getURLName(e),await r.load(e,t),m.res.addTexture(e,r),r}async loadJson(e,t){return this.baseUrl=tt.getPath(e),this.initUrl=e,new Promise(async(r,i)=>{fetch(e,{headers:t?.headers}).then(async a=>{if(a.ok){let s=await Dr.read(e,a,t);const l=new TextDecoder("utf-8").decode(s);s=null,r(JSON.parse(l))}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),i(a)})})}async loadTxt(e,t){return this.baseUrl=tt.getPath(e),new Promise(async(r,i)=>{fetch(e).then(async a=>{if(a.ok){let s=await Dr.read(e,a,t);const l=new TextDecoder("utf-8").decode(s);s=null,r({data:l})}else throw Error("request rejected with status"+a.status)}).catch(a=>{t.onError&&t.onError(a),i(a)})})}static async read(e,t,r){const i=t.body.getReader(),a=+t.headers.get("Content-Length");let s=0,n=[],l=[];for(;;){const{done:f,value:g}=await i.read();if(f){a>0&&r&&r.onComplete&&r.onComplete.call(this,e);break}n.push(g),s+=g.length,a>0?r&&r.onProgress&&r.onProgress.call(this,s,a,e):l.push(g.length)}if(l.length>0)for(let f=0;f<n.length;f++)console.log(l[f]),r&&r.onProgress&&r.onProgress.call(this,l[f],s,e),l[f]==s&&r&&r.onComplete&&r.onComplete.call(this,e);let h=new Uint8Array(s),u=0;for(let f of n)h.set(f,u),u+=f.length;return h}}var Pe=(o=>(o[o.TEXT=0]="TEXT",o[o.BIN=1]="BIN",o[o.JSON=2]="JSON",o))(Pe||{});class rt extends Dr{async load(e,t,r,i){switch(t.format){case Pe.BIN:return new Promise(async(a,s)=>{this.loadBinData(e,r).then(async n=>{let l=new t;if(l.userData=i,l.baseUrl=this.baseUrl,l.initUrl=e,await l.parseBuffer(n),l.verification())a(l);else throw new Error("parser error")}).catch(n=>{s(n)})});case Pe.JSON:return new Promise((a,s)=>{this.loadJson(e,r).then(async n=>{let l=new t;l.userData=i,l.baseUrl=this.baseUrl,l.initUrl=e,l.loaderFunctions=r,await l.parseJson(n),a(l)}).catch(n=>{s(n)})});case Pe.TEXT:return new Promise((a,s)=>{this.loadTxt(e,r).then(async n=>{let l=new t;l.userData=i,l.baseUrl=this.baseUrl,l.initUrl=e,l.loaderFunctions=r,n.data?(await l.parseString(n.data),a(l)):s("text load is empty!")}).catch(n=>{s(n)})})}}}class it{static format=Pe.BIN;baseUrl;initUrl;loaderFunctions;userData;data;parseString(e){}parseJson(e){}parseBuffer(e){}parseTexture(e){throw this.parserError("Method not implemented.",-1)}parse(e){}verification(e){throw this.parserError("Method not implemented.",-1)}parserError(e,t){console.error(`error id:${t} ${e}`)}}class ma{asset;accessors;buffers;bufferViews;materials;meshes;nodes;scene=0;scenes;textures;cameras;skins;resources;images;samplers;animations;extensions}class Ad{nodes}class vd{name;type;color;intensity;range;spot;isParsed}class _d{name;rotation;scale;translation;children;matrix;mesh=-1;isParsed;dnode;camera;skin;nodeId;primitives;extensions;light}class xd{attributes;indices;material;mode;name;targets;extensions;morphTargetsRelative}class Cd{name;primitives;isParsed;dprimitives;weights;extras}class Sd{bufferView;componentType;count;type;max;min;isParsed;daccessor;normalized;sparse;byteOffset;computeResult}const yd=window.SharedArrayBuffer?function(e){return e&&e.buffer&&(e.buffer instanceof ArrayBuffer||e.buffer instanceof window.SharedArrayBuffer)}:function(e){return e&&e.buffer&&e.buffer instanceof ArrayBuffer},As=5120,vi=5121,vs=5122,_s=5123,xs=5124,Cs=5125,Ss=5126,wd=32819,Id=32820,bd=33635,Bd=5131,Ed=33640,Td=35899,Dd=35902,Pd=36269,Md=34042,hh={};{const o=hh;o[As]=Int8Array,o[vi]=Uint8Array,o[vs]=Int16Array,o[_s]=Uint16Array,o[xs]=Int32Array,o[Cs]=Uint32Array,o[Ss]=Float32Array,o[wd]=Uint16Array,o[Id]=Uint16Array,o[bd]=Uint16Array,o[Bd]=Uint16Array,o[Ed]=Uint32Array,o[Td]=Uint32Array,o[Dd]=Uint32Array,o[Pd]=Uint32Array,o[Md]=Uint32Array}function Rd(o){switch(o){case Int8Array:return As;case Uint8Array:return vi;case Uint8ClampedArray:return vi;case Int16Array:return vs;case Uint16Array:return _s;case Int32Array:return xs;case Uint32Array:return Cs;case Float32Array:return Ss;default:throw new Error("unsupported typed array type")}}function Ud(o){if(o instanceof Int8Array)return As;if(o instanceof Uint8Array||o instanceof Uint8ClampedArray)return vi;if(o instanceof Int16Array)return vs;if(o instanceof Uint16Array)return _s;if(o instanceof Int32Array)return xs;if(o instanceof Uint32Array)return Cs;if(o instanceof Float32Array)return Ss;throw new Error("unsupported typed array type")}function ys(o){const e=hh[o];if(!e)throw new Error("unkonw gl type");return e}function Ld(o,e=Float32Array){return yd(o)?o:new e(o)}class ws{static _workerCode;static _workers=new Map;static async apply(e,t){if(!t.extensions)return;const r=t.extensions.KHR_draco_mesh_compression;if(!r)return;let i=this._workers.get(e.gltf);i||(i=new Worker(await this.initDecoder()),this._workers.set(e.gltf,i)),i.postMessage({type:"init",decoderConfig:{}});let a=e.parseBufferView(r.bufferView);if(!a.result){let s=await new Promise((n,l)=>{i.onmessage=h=>{const u=h.data;u.type=="decode"?n(u.result):u.type=="error"&&l(u.error)},i.postMessage({type:"decoder",buffer:a,attributes:r.attributes},[a])});a.result=s}return a.result}static unload(e){let t=this._workers.get(e);t&&(t.terminate(),this._workers.delete(e))}static async initDecoder(){if(!this._workerCode){let e=await new rt().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const t=new Blob([e.data,"",`(${Od})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(t)}return this._workerCode}}function Od(){let o,e;onmessage=t=>{const r=t.data;switch(r.type){case"init":o=r.decoderConfig,e=new Promise((s,n)=>{o.onModuleLoaded=l=>{s({draco:l})},DracoDecoderModule(o)});break;case"decoder":const i=r.buffer,a=r.attributes;e.then(s=>{const n=s.draco;let l=new n.Decoder,h=new n.DecoderBuffer;h.Init(new Int8Array(i),i.byteLength);let u,f;try{const g=l.GetEncodedGeometryType(h);g==n.TRIANGULAR_MESH?(f=new n.Mesh,u=l.DecodeBufferToMesh(h,f)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+g)),u.ok()||self.postMessage(new Error("DracoDecode:"+u.error_msg()));let p={};for(const A in a){let v=l.GetAttributeByUniqueId(f,a[A]);const C=v.num_components(),S=f.num_points()*C,y=S*Float32Array.BYTES_PER_ELEMENT,b=n.DT_FLOAT32,D=n._malloc(y);l.GetAttributeDataArrayForAllPoints(f,v,b,y,D);const B=new Float32Array(n.HEAPF32.buffer,D,S).slice();n._free(D),p[A]={data:B,numComponents:C,normalize:!1}}{const v=f.num_faces()*3,C=v*4,x=n._malloc(C);l.GetTrianglesUInt32Array(f,C,x);const S=new Uint32Array(n.HEAPF32.buffer,x,v).slice();n._free(x),p.indices={data:S,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:p})}catch(g){self.postMessage({type:"error",error:g.message})}finally{n.destroy(f),n.destroy(l),n.destroy(h)}});break}}}class uh{gltf;constructor(e){this.gltf=e}parse(e){const t=this.gltf.cameras[e];if(!t)return this.errorMiss("camera",e);if(t.isParsed)return t.dcamera;t.isParsed=!0,t.dcamera=!1;const{name:r,type:i,perspective:a,orthographic:s}=t;if(i==="perspective"&&a){const{aspectRatio:n,yfov:l,zfar:h,znear:u}=a;t.dcamera=Object.assign({},{name:r,type:i,yfov:l,znear:u,aspectRatio:n,zfar:h})}else if(i==="orthographic"&&s){const{xmag:n,ymag:l,zfar:h,znear:u}=s;t.dcamera=Object.assign({},{name:r,type:i,xmag:n,ymag:l,zfar:h,znear:u})}return t.dcamera}errorMiss(e,t){throw new Error(e+t)}}class Ke extends it{static format=Pe.JSON;_gltf;async parseJson(e){this._gltf=new ma,this._gltf={...this._gltf,...e},this._gltf.resources={},await Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let t=new va,r=await t.parse(this.initUrl,this._gltf,this._gltf.scene);return t.destory(),t=null,r?(this.data=r.rootNode,r.rootNode):(this._gltf=null,null)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static _counter=0;static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Ke._counter++}`}}static getModelNameCounter(){let e=0;return function(){return`GLTF_NO_NAME_MESH_${e++}`}}static getTexCoordDefine(e){return`UV_NUM ${e}`}static getVertexColorDefine(e){return`HAS_VERTEXCOLOR ${e}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(e){return`MORPH_TARGET_NUM ${e}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(e){return`JOINTS_NUM ${e}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}static defaultMaterial={name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}};async load_gltf_bin(){if(this._gltf.buffers&&this._gltf.buffers.length>0){let e=[];for(let t=0;t<this._gltf.buffers.length;t++){const r=this._gltf.buffers[t];if(r.uri.substring(0,5)!=="data:"){let i=tt.parseUrl(this.baseUrl,r.uri);this.loaderFunctions?.onUrl&&(i=await this.loaderFunctions.onUrl(i));let a=new rt().loadBinData(i,this.loaderFunctions).then(s=>{this._gltf.resources[r.uri]=s});e.push(a)}}await Promise.all(e)}}async load_gltf_textures(){if(this._gltf,this._gltf.images){let e=[];for(let t=0;t<this._gltf.images.length;t++){const r=this._gltf.images[t];if(r.uri){let i=tt.parseUrl(this.baseUrl,r.uri);this.loaderFunctions?.onUrl&&(i=await this.loaderFunctions.onUrl(i));let a=new rt().loadAsyncBitmapTexture(i,this.loaderFunctions).then(s=>{s.name=tt.getURLName(r.uri),this._gltf.resources[s.name]=s});e.push(a)}}await Promise.all(e)}}}class ch{gltf;subParser;constructor(e){this.gltf=e.gltf,this.subParser=e}async parse(e){const t=this.gltf.meshes[e];if(!t)return this.errorMiss("mesh",e);if(t.isParsed)return t.dprimitives;const r=t.primitives,i=t.extras,a=[];for(let s=0;s<r.length;s++){const n=r[s],{attributes:l,indices:h,material:u,mode:f,name:g,targets:p,morphTargetsRelative:A,extensions:v}=n;let C=t.name;for(let T in l)C+=T;C+=`indices:${h}`,C+=`material:${u}`;const x={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:i?i.targetNames:null};let S=!1,y=0,b=!1,D;v&&v.KHR_draco_mesh_compression&&(D=await ws.apply(this.subParser,n));for(const T in l){const U=D?D[T]:this.parseAccessor(l[T]);if(U){let E;switch(T){case"POSITION":E=M.position;break;case"NORMAL":E=M.normal,S=!0;break;case"TEXCOORD_0":E=M.uv,y++;break;case"JOINTS_0":E=M.joints0;break;case"JOINTS_1":E=M.joints1,b=!0;break;case"WEIGHTS_0":E=M.weights0;break;case"WEIGHTS_1":E=M.weights1;break;default:E=T}x.attribArrays[E]=U}}if(S&&x.defines.push(Ke.getHasNormalDefine()),y&&x.defines.push(Ke.getTexCoordDefine(y)),b&&x.defines.push(Ke.getJointVec8Define()),h!==void 0){const T=D?D.indices:this.parseAccessor(h);T&&(x.attribArrays.indices=T)}const B=await this.parseMaterial(u);if(B&&(x.material=B,x.defines=x.defines.concat(B.defines)),x.drawMode=f===void 0?4:f,x.meshName=()=>C,x.modelName=t.name||Ke.getModelNameCounter(),p){x.defines.push(Ke.getMorphTargetsDefine(p.length)),x.morphTargetsRelative=!0;let T=!1,U=!1,E=!1;for(let N=0;N<p.length;N++){const Q=p[N];Object.keys(Q).forEach(H=>{const q=this.parseAccessor(Q[H]);if(q){let re;switch(H){case"POSITION":re=Qt.MORPH_POSITION_PREFIX+N,T=!0;break;case"NORMAL":re=Qt.MORPH_NORMAL_PREFIX+N,U=!0;break;case"TANGENT":re=Qt.MORPH_TANGENT_PREFIX+N,E=!0;break;default:re=!1}re?x.attribArrays[re]=q:console.error(`glTF has unsupported morph target attribute ${H}`)}})}T&&x.defines.push(Ke.getMorphtargetPositionDefine()),U&&x.defines.push(Ke.getMorphtargetNormalDefine()),E&&x.defines.push(Ke.getMorphtargetTangentDefine()),x.weights=t.weights||new Array(p.length).fill(0)}a.push(x)}return t.dprimitives=a,t.isParsed=!0,t.dprimitives}parseAccessor(e){return this.subParser.parseAccessor(e)}parseMaterial(e){return this.subParser.parseMaterial(e)}errorMiss(e,t){throw new Error(e+t)}}class fh{gltf;subParser;constructor(e){this.gltf=e.gltf,this.subParser=e}async parse(e){let t;if(e==null?t=Ke.defaultMaterial:t=this.gltf.materials[e],!t)return this.errorMiss("material",e);if(t.isParsed)return t.dmaterial;let{name:r,pbrMetallicRoughness:i,normalTexture:a,occlusionTexture:s,emissiveTexture:n,emissiveFactor:l,alphaMode:h,alphaCutoff:u,doubleSided:f,extensions:g}=t;const p={name:r,defines:[],doubleSided:!!f,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,transformUV1:null,transformUV2:null,extensions:null};if(i){const{baseColorFactor:A,metallicFactor:v,roughnessFactor:C,baseColorTexture:x,metallicRoughnessTexture:S}=i;if(Object.assign(p,{baseColorFactor:A||[1,1,1,1],metallicFactor:v===void 0?1:v,roughnessFactor:C===void 0?.5:C}),x){let y=x.extensions;if(y){let D=y.KHR_texture_transform;D&&(p.transformUV1=new G(D.offset?D.offset[0]:0,D.offset?D.offset[1]:0,D.scale?D.scale[0]:1,D.scale?D.scale[1]:1))}const b=await this.parseTexture(x.index);b?p.baseColorTexture=b:p.baseColorTexture=m.res.redTexture}if(S){const y=await this.parseTexture(S.index);y?p.metallicRoughnessTexture=y:p.metallicRoughnessTexture=m.res.blackTexture}}else Object.assign(p,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(p.baseColorFactor&&p.baseColorFactor[3]<1&&(h=h==="MASK"?"MASK":"BLEND"),h&&h!=="OPAQUE"&&(h==="MASK"&&(p.defines.push(Ke.getAlphaMaskDefine()),p.alphaCutoff=u===void 0?.5:u),h==="BLEND"&&(p.defines.push(Ke.getAlphaBlendDefine()),p.enableBlend=!0)),a){const A=await this.parseTexture(a.index);A?p.normalTexture=A:p.normalTexture=m.res.normalTexture}if(s){const A=await this.parseTexture(s.index);A&&(p.occlusionTexture=A)}if(l&&(p.emissiveFactor=l),n){const A=await this.parseTexture(n.index);A?p.emissiveTexture=A:p.emissiveTexture=m.res.blackTexture}return g&&(p.extensions=g),t.isParsed=!0,t.dmaterial=p,p}async parseTexture(e){return this.subParser.parseTexture(e)}errorMiss(e,t){throw new Error(e+t)}}class dh{gltf;subParser;constructor(e){this.gltf=e.gltf,this.subParser=e}parse(e){const t=this.gltf.skins[e];if(!t)return this.errorMiss("skin",e);if(t.isParsed)return t.dskin;const{name:r,joints:i,inverseBindMatrices:a,skeleton:s}=t;if(!i)return this.errorMiss("skin.joints",e);t.isParsed=!0,t.dskin=!1;let n={name:r,skeleton:null,inverseBindMatrices:null,joints:i,defines:[Ke.getJointsNumDefine(i.length)]};if(s)n.skeleton=s;else{var l=-1;for(let h=0;h<this.gltf.nodes.length;h++)if(this.gltf.nodes[h].name=="root"){l=h;break}if(l==-1){let h=this.gltf.scenes[this.gltf.scene];l=h.nodes[h.nodes.length-1]}n.skeleton=l}if(n.inverseBindMatrices=Qt.IDENTITY_INVERSE_BIND_MATRICES,a!==void 0){const h=this.parseAccessor(a);if(h){const u=h.data,f=[];for(let g=0;g<u.length;g+=16)f.push(u.slice(g,g+16));n.inverseBindMatrices=f}else n=null}return t.dskin=n,t.dskin}parseAccessor(e){return this.subParser.parseAccessor(e)}errorMiss(e,t){throw new Error(e+t)}}class gh{name="";index=0;instanceID="";parent=null;scale=new d;rotation=new Y;translation=new d;constructor(e=""){this.name=e}}class ph{joints;constructor(e=[]){this.joints=e}get numJoint(){return this.joints.length}addJoint(e){e.index=this.joints.push(e)-1}getJointName(e){return this.joints[e].name}getJointParentIndex(e){let t=this.joints[e];return t.parent?t.parent.index:-1}getJointByName(e){for(let t of this.joints)if(t.name==e)return t;return null}}class Is{index;worldMatrix;constructor(e,t=!1){this.index=e,this.worldMatrix=new R(!t)}}class _i{time;_skeleton;_jointsPose;mJointMatrixIndexTable;constructor(e,t=!1){this._skeleton=e,this._jointsPose=new Array(e.numJoint),this.mJointMatrixIndexTable=new Array(e.numJoint);for(let r=0;r<e.numJoint;r++){let i=new Is(r,t);this._jointsPose[r]=i,this.mJointMatrixIndexTable[r]=i.worldMatrix.index}}buildSkeletonPose(e){let t=new d,r=new Y,i=new d,a=new Array(this._skeleton.numJoint);this.time=e[11]>0?e[11]:e[24];for(let s=0;s<this._skeleton.numJoint;s++){let n=12*s*4,l=new Float32Array(e.buffer,e.byteOffset+n,12),h=new R;t.set(l[0],l[1],l[2]),r.set(l[4],l[5],l[6],l[7]),i.set(l[8],l[9],l[10]),aa(r.getEulerAngles(),i,t,h),a[s]=h;let u=new Is(s);const f=this._skeleton.getJointParentIndex(s);if(f<0)u.worldMatrix.copyFrom(h);else{let g=this._jointsPose[f];Qn(g.worldMatrix,h,u.worldMatrix)}this._jointsPose[s]=u}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(e,t,r){if(e&&t)for(let i=0;i<this._jointsPose.length;i++){let a=e._jointsPose[i],s=t._jointsPose[i];this._jointsPose[i].worldMatrix.lerp(a.worldMatrix,s.worldMatrix,r)}else for(let i=0;i<this._jointsPose.length;i++){let a=e._jointsPose[i];this._jointsPose[i].worldMatrix.copyFrom(a.worldMatrix)}}copyFrom(e){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.copyFrom(e._jointsPose[t].worldMatrix)}reset(){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.identity()}}class mh extends Ne{skeletonAnimation;constructor(e,t){super(),this.type=e,this.time=t}}class Aa{name="";_skeleton;_skeletonPoses;_animationClipData;_events;constructor(e,t,r,i){if(this.name=e,this._skeleton=t,this._animationClipData=i,r>0&&i){this._skeletonPoses=new Array(r);let a=12*t.numJoint;for(let s=0;s<r;s++){let n=a*s*4,l=new Float32Array(i.buffer,n,a),h=new _i(t);h.buildSkeletonPose(l),this._skeletonPoses[s]=h}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(e){return this._skeletonPoses[e]}getLerpSkeletonPose(e,t,r,i){let a=this.getSkeletonPose(e),s=this.getSkeletonPose(t);return i.lerp(a,s,r),i}createSubClip(e,t,r){var i=new Aa(e,this._skeleton,0,null);const a=Math.max(Math.floor(t/this.frameRate),0),s=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);i._skeletonPoses=this._skeletonPoses.slice(a,s);const n=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,a*n,(s-a)*n),i}addEvent(e,t){this._events||(this._events=new Array),this._events.push(new mh(e,t))}removeEvent(e){this._events&&(this._events=this._events.filter(t=>t.type!=e))}getEvents(){return this._events}}class bs{gltf;subParser;constructor(e){this.gltf=e.gltf,this.subParser=e}parse(e){let t=new ph;return this.buildSkeleton(t,void 0,e),t}parseSkeletonAnimation(e,t){let r=this.subParser.parseAccessor(t.samplers[0].input),i=r.data.length,a=r.data[1]-r.data[0];r.data[r.data.length-1];let s=12*e.numJoint,n=new Float32Array(s*i);for(var l=0;l<e.numJoint;l++)for(var h=0;h<i;h++){var u=s*h+12*l;n[u+0]=1,n[u+1]=1,n[u+2]=1,n[u+3]=1}for(let v of t.channels){let C=t.samplers[v.sampler];const x=this.subParser.parseAccessor(C.input),S=this.subParser.parseAccessor(C.output);let y=v.target.node,b=v.target.path,D=this.gltf.nodes[y];if(!D)continue;let B=e.getJointByName(D.name);if(B)switch(b){case"scale":if(i*S.numComponents==S.data.length)for(var h=0;h<i;h++){var f=h*S.numComponents,u=s*h+12*B.index;n[u+0]=S.data[f+0],n[u+1]=S.data[f+1],n[u+2]=S.data[f+2],n[u+3]=1}else if(x.data.length==2){let T=0;x.data[0];let U=x.data[1];var g=0*S.numComponents;d.HELP_0.set(S.data[g+0],S.data[g+1],S.data[g+2]);var p=1*S.numComponents;d.HELP_1.set(S.data[p+0],S.data[p+1],S.data[p+2]);for(var h=0;h<i;h++){let N=T/U;d.HELP_2.lerp(d.HELP_0,d.HELP_1,N);var u=s*h+12*B.index;n[u+0]=d.HELP_2.x,n[u+1]=d.HELP_2.y,n[u+2]=d.HELP_2.z,n[u+3]=1,T+=a}}else throw new Error("Unsupported animation sampler interpolation.");break;case"rotation":if(i*S.numComponents==S.data.length)for(var h=0;h<i;h++){var f=h*S.numComponents,u=s*h+12*B.index+4;n[u+0]=S.data[f+0],n[u+1]=S.data[f+1],n[u+2]=S.data[f+2],n[u+3]=S.data[f+3]}else if(x.data.length==2){let T=0;x.data[0];let U=x.data[1];var g=0*S.numComponents;d.HELP_0.set(S.data[g+0],S.data[g+1],S.data[g+2],S.data[g+3]);var p=1*S.numComponents;d.HELP_1.set(S.data[p+0],S.data[p+1],S.data[p+2],S.data[p+3]);for(var h=0;h<i;h++){let H=T/U;d.HELP_2.lerp(d.HELP_0,d.HELP_1,H);var u=s*h+12*B.index+4;n[u+0]=d.HELP_2.x,n[u+1]=d.HELP_2.y,n[u+2]=d.HELP_2.z,n[u+3]=d.HELP_2.w,T+=a}}else throw new Error("Unsupported animation sampler interpolation.");break;case"translation":if(i*S.numComponents==S.data.length)for(var h=0;h<i;h++){var f=h*S.numComponents,u=s*h+12*B.index+8;n[u+0]=S.data[f+0],n[u+1]=S.data[f+1],n[u+2]=S.data[f+2],n[u+3]=x.data[h*x.numComponents]}else if(x.data.length==2){let T=0;x.data[0];let U=x.data[1];var g=0*S.numComponents;d.HELP_0.set(S.data[g+0],S.data[g+1],S.data[g+2]);var p=1*S.numComponents;d.HELP_1.set(S.data[p+0],S.data[p+1],S.data[p+2]);for(var h=0;h<i;h++){let H=T/U;d.HELP_2.lerp(d.HELP_0,d.HELP_1,H);var u=s*h+12*B.index+8;n[u+0]=d.HELP_2.x,n[u+1]=d.HELP_2.y,n[u+2]=d.HELP_2.z,n[u+3]=T,T+=a}}else throw new Error("Unsupported animation sampler interpolation.");break}}return new Aa(t.name,e,i,n)}buildSkeleton(e,t,r,i=0){let a=this.gltf.nodes[r];a.name||(a.name="Node_"+r);let s=new gh(a.name);if(s.parent=t,a.scale&&s.scale.set(a.scale[0],a.scale[1],a.scale[2]),a.rotation&&s.rotation.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),a.translation&&s.translation.set(a.translation[0],a.translation[1],a.translation[2]),e.addJoint(s),a.children)for(let n of a.children)this.buildSkeleton(e,s,n,i+1)}}class Ah{loop=!0;speed=1;t=0;time=0;weight=0;currFrame=0;lastFrame=-1;nextFrame=0;clip;animation;_isEnd=!1;_currSkeletonPose;constructor(e){this.clip=e,this._currSkeletonPose=new _i(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(e){this.time=(this.time+e*this.speed)%this.clip.totalTime;let t=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(t),this.t=t-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let a=this.speed<0?0:this.clip.numFrame;this.currFrame==a&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let s of r){var i=Math.floor(s.time/this.clip.frameRate);if(i=Math.min(i,this.clip.numFrame),i=Math.max(i,0),i==this.currFrame){s.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(s);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}var Fd=Object.defineProperty,Nd=Object.getOwnPropertyDescriptor,zd=(o,e,t,r)=>{for(var i=r>1?void 0:r?Nd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Fd(e,t,i),i};c.SkeletonAnimationComponent=class extends _e{isPlaying=!0;timeScale=1;_skeleton;_clips=[];_clipStates=new Map;_mixSkeletonPose;_mixTempSkeletonPose;_currentClipState;_bindList=[];_jointMatrixIndexTableBuffer;_crossFadeState;constructor(){super()}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(e){this._skeleton=e,this._mixSkeletonPose=new _i(this._skeleton,!0),this._mixTempSkeletonPose=new _i(this._skeleton);const t=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new Z(this._skeleton.numJoint*4,0,t)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(e){let t=new Array;for(let r=0;r<e.length;r++){const i=e[r];let a=this._skeleton.getJointByName(i);t[r]=a?a.index:-1}return t}addAnimationClip(e){if(!this._clipStates.has(e.name)){this._clips.push(e);let t=new Ah(e);t.animation=this,this._clipStates.set(e.name,t),this._currentClipState||this.setCurrentClipState(t)}}getAnimationClip(e){var t=this.getAnimationClipState(e);return t?t.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(e){return this._clipStates.has(e)?this._clipStates.get(e):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(e,t=1,r=!1){if(this._currentClipState&&this._currentClipState.name==e)return r&&this._currentClipState.reset(),!1;let i=this.getAnimationClipState(e);return i?(i.speed=t,i.reset(),this._clipStates.forEach((a,s)=>{a.weight=0}),this.setCurrentClipState(i),!0):!1}crossFade(e,t){if(t<.01){this.play(e);return}if(this._currentClipState.name==e)return;let r=this.getAnimationClipState(e);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,t)):this._crossFadeState=new kd(r,this._currentClipState,t),this._currentClipState=r)}setAnimIsLoop(e,t){this._clipStates.has(e)&&(this._clipStates.get(e).loop=t)}addJointBind(e,t){this._bindList.push({jointName:e,obj:t})}removeJointBind(e){for(let t=0;t<this._bindList.length;t++)if(this._bindList[t].obj==e){this._bindList.splice(t,1);break}}onUpdate(){if(!this.isPlaying)return;let e=ue.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(e);var t=0,r=[];if(this._clipStates.forEach((a,s)=>{a.weight>0&&(a.update(e),t+=a.weight,r.push(a))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var i=1;i<r.length;++i){const a=r[i];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,a.currSkeletonPose,a.weight/t),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(e){let t=e.addComponent(c.SkeletonAnimationComponent);t.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)t.addAnimationClip(this._clips[r])}setCurrentClipState(e){this._currentClipState!=e&&(this._currentClipState=e,this._currentClipState.weight=1)}},c.SkeletonAnimationComponent=zd([mt(c.SkeletonAnimationComponent,"SkeletonAnimationComponent")],c.SkeletonAnimationComponent);class kd{inClip;outClip;currentTime;crossFadeTime;constructor(e,t,r){this.reset(e,t,r)}reset(e,t,r){this.inClip=e,this.outClip=t,this.currentTime=0,this.crossFadeTime=r}update(e){!this.inClip||!this.outClip||(this.currentTime+=e,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class Bs{static list=[];static add(e){this.list.indexOf(e)==-1&&this.list.push(e)}static remove(e){let t=this.list.indexOf(e);t!=-1&&this.list.splice(t,1)}}class xi extends _e{name;size=1;lightData;dirFix=1;bindOnChange;needUpdateShadow=!0;realTimeShadow=!0;_castGI=!1;_castShadow=!1;_iesProfiles;constructor(){super()}init(){this.transform.object3D.bound=new de(new d,new d),this.lightData=new sa,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new d(this.size,this.size,this.size)),this._castGI&&(k.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,ot.addShadowLight(this)):ot.removeShadowLight(this)}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onScaleChange=()=>this.onScaleChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange(),this.onScaleChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition)}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),k.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),k.instance.removeLight(this.transform.scene3D,this),ot.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,Dt.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get color(){return this.lightData.lightColor}set color(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?Bs.add(this):Bs.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,k.instance.removeLight(this.transform.scene3D,this),ot.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(st.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(st.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}var Gd=Object.defineProperty,Qd=Object.getOwnPropertyDescriptor,Vd=(o,e,t,r)=>{for(var i=r>1?void 0:r?Qd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Gd(e,t,i),i};c.DirectLight=class extends xi{shadowCamera;constructor(){super()}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+dt()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=Ee.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(e){this.lightData.range=e,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(e){this.lightData.quadratic=e,this.onChange()}debug(){}},c.DirectLight=Vd([mt(c.DirectLight,"DirectLight")],c.DirectLight);var Hd=Object.defineProperty,Yd=Object.getOwnPropertyDescriptor,Xd=(o,e,t,r)=>{for(var i=r>1?void 0:r?Yd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Hd(e,t,i),i};c.PointLight=class extends xi{constructor(){super()}init(){super.init(),this.lightData.lightType=Ee.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+dt())}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(e){this.lightData.quadratic=e,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(e){}debug(){}debugDraw(e){}},c.PointLight=Xd([mt(c.PointLight,"PointLight")],c.PointLight);var jd=Object.defineProperty,Wd=Object.getOwnPropertyDescriptor,qd=(o,e,t,r)=>{for(var i=r>1?void 0:r?Wd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&jd(e,t,i),i};c.SpotLight=class extends xi{constructor(){super()}init(){super.init(),this.lightData.lightType=Ee.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+dt())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(e){this.lightData.innerAngle=j(e,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*Gr*2}set outerAngle(e){this.lightData.outerAngle=j(e,1,179)*ge*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}start(){super.start(),this.lightData.lightType=Ee.SpotLight}onUpdate(){}onGraphic(e){}debug(){}debugDraw(e){}},c.SpotLight=qd([mt(c.SpotLight,"SpotLight")],c.SpotLight);var Kd=Object.defineProperty,Jd=Object.getOwnPropertyDescriptor,Zd=(o,e,t,r)=>{for(var i=r>1?void 0:r?Jd(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Kd(e,t,i),i};c.SkinnedMeshRenderer=class extends c.MeshRenderer{skinJointsName;mInverseBindMatrixData;mInverseBindMatrixBuffer;mSkeletonAnimation;mJointIndexTableBuffer;constructor(){super(),this.addRendererMask(Be.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(c.SkeletonAnimationComponent),!this.skeletonAnimation){let e=this.object3D.parentObject.parentObject.getComponentsInChild(c.SkeletonAnimationComponent);e.length>0&&(this.skeletonAnimation=e[0]);let t=this.object3D;for(;!this.skeletonAnimation&&t;)this.skeletonAnimation=t.getComponentFromParent(c.SkeletonAnimationComponent),t.parent&&(t=t.parent.object3D)}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(e){if(this.mSkeletonAnimation=e,!!e&&!this.mJointIndexTableBuffer){let t=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new Z(t.length*4,0,new Float32Array(t)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(e){this.mInverseBindMatrixData=e;var t=new Float32Array(e.length*16);for(let r=0;r<e.length;r++){let i=r*16,a=e[r];t.set(a,i)}this.mInverseBindMatrixBuffer=new Z(t.byteLength,0,t),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(e){let t=e.addComponent(c.SkinnedMeshRenderer);t.geometry=this.geometry,t.material=this.material.clone(),t.castShadow=this.castShadow,t.castGI=this.castGI,t.receiveShadow=this.receiveShadow,t.rendererMask=this.rendererMask,t.skinJointsName=this.skinJointsName,t.skinInverseBindMatrices=this.skinInverseBindMatrices,t.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(e,t,r,i){for(let a=0;a<this.materials.length;a++){let n=this.materials[a].getPass(t);if(n)for(let l=0;l<n.length;l++){const h=n[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(e,t,r,i)}},c.SkinnedMeshRenderer=Zd([mt(c.SkinnedMeshRenderer,"SkinnedMeshRenderer")],c.SkinnedMeshRenderer);class vh{static apply(e,t,r){let i=t.extensions;if(i&&i.KHR_materials_clearcoat){r.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0);let a=i.KHR_materials_clearcoat;"clearcoatFactor"in a&&(t.clearcoatFactor=a.clearcoatFactor,r.clearcoatFactor=t.clearcoatFactor),"clearcoatRoughnessFactor"in a&&(t.clearcoatRoughnessFactor=a.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=t.clearcoatRoughnessFactor)}}}class _h{static apply(e,t,r){let i=t.extensions;i&&i.KHR_materials_emissive_strength?(r.emissiveIntensity=i.KHR_materials_emissive_strength.emissiveStrength*.5,r.emissiveMap==m.res.blackTexture&&(r.emissiveMap=m.res.whiteTexture)):r.emissiveIntensity=1}}class xh{static apply(e,t,r){let i=t.extensions;i&&i.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class Ch{gltf;subParser;_testCount=8;_hasCastShadow=!1;constructor(e){this.gltf=e.gltf,this.subParser=e}async convertNodeToObject3D(e,t){const r=new c.Object3D;if(r.name=e.name,r[Qt.GLTF_NODE_INDEX_PROPERTY]=e.nodeId,e.nodeObj=r,e.matrix&&(e.translation=[0,0,0],e.rotation=[0,0,0,1],e.scale=[1,1,1]),e.translation&&(r.transform.x=e.translation[0],r.transform.y=e.translation[1],r.transform.z=e.translation[2]),e.rotation){let i=new Y;i.setFromArray(e.rotation),r.transform.localRotQuat=i}if(e.scale&&(r.transform.scaleX=e.scale[0],r.transform.scaleY=e.scale[1],r.transform.scaleZ=e.scale[2]),t.addChild(r),e.light&&this.convertLight(e,r),e.primitives&&this.convertprimitives(e,r),e.skeleton){let i=r.addComponent(c.SkeletonAnimationComponent);if(i){i.skeleton=this.subParser.parseSkeleton(e.skeleton.skeleton);for(let a=0;a<this.gltf.animations.length;a++){let s=this.gltf.animations[a];s.name||(s.name=a.toString());let n=this.subParser.parseSkeletonAnimation(i.skeleton,s);i.addAnimationClip(n)}}}return r}convertLight(e,t){switch(e.light.type){case"directional":let r=t.addComponent(c.DirectLight);t.name=e.light.name,r.intensity=e.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=e.light.color?new P(e.light.color[0],e.light.color[1],e.light.color[2]):new P(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let a=t.addComponent(c.PointLight);a.name=e.light.name,a.intensity=e.light.intensity?e.light.intensity*8*2:1,a.radius=8,a.at=2,a.range=e.light.range?e.light.range:8,a.lightColor=e.light.color?new P(e.light.color[0],e.light.color[1],e.light.color[2]):new P(1,1,1,1)}this._testCount--;break;case"spot":let i=t.addComponent(c.SpotLight);i.name=e.light.name,i.intensity=e.light.intensity*5,i.radius=1,i.dirFix=-1,i.at=2,i.range=e.light.range?e.light.range:8,i.outerAngle=e.light.spot.outerConeAngle*Gr,i.lightColor=e.light.color?new P(e.light.color[0],e.light.color[1],e.light.color[2]):new P(1,1,1,1);break}}convertprimitives(e,t){for(let r=0;r<e.primitives.length;r++){const i=e.primitives[r];i.modelName;let a=i.material;a.name==null&&(a.name=dt());let s,n=`matkey_${a.name}`;if(a&&this.gltf.resources[n])s=this.gltf.resources[n];else{let g=s=new rr;if(this.gltf.resources[n]=g,g.name=a.name,i.material){const{baseColorTexture:p,baseColorFactor:A,metallicFactor:v,roughnessFactor:C,doubleSided:x,metallicRoughnessTexture:S,normalTexture:y,occlusionTexture:b,emissiveTexture:D,emissiveFactor:B,enableBlend:T,alphaCutoff:U}=i.material;let E=g=this.applyMaterialExtensions(i.material,g);"enableBlend"in i.material&&(i.material.enableBlend?E.blendMode=ee.SOFT_ADD:E.blendMode=ee.NONE),"alphaCutoff"in i.material&&U>0&&U<1&&(E.setUniformFloat("alphaCutoff",U),E.blendMode=ee.NORMAL,E.transparent=!0),i.material.transformUV1&&E.setUniformVector4("uvTransform_1",i.material.transformUV1),i.material.transformUV2&&E.setUniformVector4("uvTransform_2",i.material.transformUV2),E.setUniformColor("baseColor",new P(A[0],A[1],A[2],A[3])),E.setUniformFloat("roughness",C),E.setUniformFloat("metallic",v),E.setUniformFloat("ao",1),E.doubleSide=x,p&&E.setTexture("baseMap",p),y&&E.setTexture("normalMap",y),S&&E.setTexture("maskMap",S),b&&S!=b&&E.setTexture("aoMap",b),D&&E.setTexture("emissiveMap",D),B&&(B[0]>0||B[1]>0||B[2]>0)&&(E.shader.getTexture("emissiveMap")||E.shader.setTexture("emissiveMap",m.res.whiteTexture),E.setUniformColor("emissiveColor",new P(B[0],B[1],B[2],B[3])))}}const{attribArrays:l,modelName:h,drawMode:u}=i;let f;if(!l.indices.data){let g=[],p=l.position.data.length/3/3;for(let A=0;A<p;A++){let v=A*3;g.push(v+2),g.push(v+0),g.push(v+1)}l.indices={data:new Uint8Array(g),normalize:!1,numComponents:1}}if(!l.normal){let g=[],p=l.position.data.length/3;for(let A=0;A<p;A++)g.push(0),g.push(0),g.push(0);l.normal={data:new Float32Array(g),normalize:!1,numComponents:3}}if(l.indices.data&&l.indices.data.length>3){let g=i.meshName();this.gltf.resources[g]?f=this.gltf.resources[g]:(f||=this.createGeometryBase(g,l,i),this.gltf.resources[g]=f);const p=new c.Object3D;if(p.name=h+r,this.gltf.animations&&l[M.joints0]!=null){f||=this.createGeometryBase(h,l,i),this.gltf.resources[g]=f;let A=this.gltf.nodes[e.skin.skeleton];if(A.dnode&&A.dnode.nodeObj){let x=A.dnode.nodeObj.addComponent(c.SkeletonAnimationComponent);if(x){x.skeleton=this.subParser.parseSkeleton(e.skin.skeleton);for(let S=0;S<this.gltf.animations.length;S++){let y=this.gltf.animations[S];y.name||(y.name=S.toString());let b=this.subParser.parseSkeletonAnimation(x.skeleton,y);x.addAnimationClip(b)}}}else A.dnode.skeleton=e.skin;let v=p.addComponent(c.SkinnedMeshRenderer);v.castShadow=!0,v.castGI=!0,v.geometry=f,v.material=s,v.skinJointsName=this.parseSkinJoints(e.skin),v.skinInverseBindMatrices=e.skin.inverseBindMatrices}else{f||=this.createGeometryBase(h,l,i),this.gltf.resources[g]=f,f.hasAttribute(M.joints0)&&f.vertexAttributeMap.delete(M.joints0);let A=p.addComponent(c.MeshRenderer);A.castShadow=!0,A.castGI=!0,A.geometry=f,A.material=s}e.skin&&e.skin.defines,t.addChild(p)}}}createGeometryBase(e,t,r){let i=new ve;i.name=e,"indices"in t&&(t.indices.data.length>65535?t.indices.data=new Uint32Array(t.indices.data):t.indices.data=new Uint16Array(t.indices.data)),i.morphTargetsRelative=r.morphTargetsRelative;let a=r.targetNames;if(a&&a.length>0){let n=i.morphTargetDictionary={};for(let l=0;l<a.length;l++)n[a[l]]=l}if(i.morphTargetDictionary){let n=t.position.data.length/3,l=new Float32Array(n);for(let h=0;h<n;h++)l[h]=h;t.vIndex={data:l,normalize:!1,numComponents:1}}for(const n in t){let l=t[n];i.setAttribute(n,l.data)}let s=i.getAttribute(M.indices);return i.addSubGeometry({indexStart:0,indexCount:s.data.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),i}applyMaterialExtensions(e,t){return vh.apply(this.gltf,e,t),xh.apply(this.gltf,e,t),_h.apply(this.gltf,e,t),t}parseSkinJoints(e){let t=[];for(let r of e.joints){let i=this.gltf.nodes[r];t.push(i.name)}return t}}class va{currentSceneName;gltf;initUrl;_generator;_version;_BASE64_MARKER=";base64,";_cameraParser=null;_meshParser=null;_materialParser=null;_skinParser=null;_skeletonParser=null;_converter=null;constructor(){}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}async parse(e,t,r){this.gltf=t,this.initUrl=e;const{version:i,generator:a}=this.gltf.asset;if(this._generator=a,i!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const s={nodes:await this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return await this.convertToNode(s)}destory(){ws.unload(this.gltf),this.gltf=null}async parseScene(e){const t=e||this.gltf.scene||0,r=this.gltf.scenes[t];if(typeof r>"u")return this.errorMiss("scene",t);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const i=[],a=r.nodes;for(let s=0;s<a.length;s++){const n=await this.parseNode(a[s]);n&&i.push(n)}return i}async parseNode(e){const t=this.gltf.nodes[e];if(!t)return this.errorMiss("node",e);if(t.isParsed)return t.dnode;const{name:r,matrix:i,translation:a,rotation:s,scale:n}=t,l={name:r,matrix:i,translation:a,rotation:s,scale:n,nodeId:e,camera:null,primitives:null,skin:null,children:null,light:null};if(t.camera!==void 0&&(l.camera=this.parseCamera(t.camera)),t.mesh!==void 0&&(l.primitives=await this.parseMesh(t.mesh)),t.extensions!==void 0&&this.applyNodeExtensions(t,l),t.skin!==void 0){const h=this.parseSkin(t.skin);h&&(l.skin=h)}if(l.children=[],t.children)for(let h=0;h<t.children.length;h++)l.children.push(await this.parseNode(t.children[h]));return t.dnode=l,t.isParsed=!0,t.dnode}errorMiss(e,t){throw new Error(e+t)}parseCamera(e){return this._cameraParser||(this._cameraParser=new uh(this.gltf)),this._cameraParser.parse(e)}async parseMesh(e){return this._meshParser||(this._meshParser=new ch(this)),this._meshParser.parse(e)}async parseTexture(e){let t=this.gltf.textures[e];if(t&&!t.dtexture){if(t&&t.source!=null){let r=this.gltf.images[t.source];if(r.uri){let i=r.uri;i=tt.getURLName(i),t.dtexture=this.gltf.resources[i]}else if(r.bufferView){let i=this.parseBufferView(r.bufferView),a=new tr,s=new Blob([i],{type:r.mimeType});await a.loadFromBlob(s),t.dtexture=a}else t.dtexture=this.gltf.resources[r.name]}else if(t.name){let r=tt.getURLName(t.name);t.dtexture=this.gltf.resources[r]}}return t.dtexture||console.log("miss texture , please check texture!",e,t),t.dtexture}async parseMaterial(e){return this._materialParser||(this._materialParser=new fh(this)),this._materialParser.parse(e)}parseAnimations(){return[]}async parseObject3D(e,t){return this._converter||(this._converter=new Ch(this)),this._converter.convertNodeToObject3D(e,t)}parseSkeleton(e){return this._skeletonParser||(this._skeletonParser=new bs(this)),this._skeletonParser.parse(e)}parseSkeletonAnimation(e,t){return this._skeletonParser||(this._skeletonParser=new bs(this)),this._skeletonParser.parseSkeletonAnimation(e,t)}async traverse(e,t){for(let r=0;r<t.length;r++){const i=await this.parseObject3D(t[r],e);await this.traverse(i,t[r].children)}}async convertToNode(e){const t=new c.Object3D;t.name=e.name;const r=e.nodes;e.animations;const i=[],a=[];return await this.traverse(t,r),{rootNode:t,textures:i,animations:void 0,cameras:a}}parseSkin(e){return this._skinParser||(this._skinParser=new dh(this)),this._skinParser.parse(e)}parseAccessor(e){const t=this.gltf.accessors[e];if(!t)return this.errorMiss("accessor",e);if(t.isParsed)return t.daccessor;t.isParsed=!0,t.daccessor=!1;const r=!!t.normalized,i=this.gltf.bufferViews[t.bufferView],a=i&&i.byteStride,s=ys(t.componentType);let n=1;switch(t.type){case"SCALAR":n=1;break;case"VEC2":n=2;break;case"VEC3":n=3;break;case"VEC4":case"MAT2":n=4;break;case"MAT3":n=9;break;case"MAT4":n=16;break;default:n=0;break}if(n===0)return console.error(`glTF has unknown data type in accessor: ${t.type}`),!1;const l=n*s.BYTES_PER_ELEMENT;let h;if(i!==void 0){if(h=this.parseBufferView(t.bufferView),!h)return t.daccessor}else h=new Uint8Array(l*t.count).buffer;let u=this.getTypedArrayFromArrayBuffer(h,a,t.byteOffset||0,s,n,t.count);if(t.sparse){const{count:f,indices:g,values:p}=t.sparse;u=new s(u);const A=g.byteOffset||0,v=this.gltf.bufferViews[g.bufferView],C=ys(g.componentType),x=this.parseBufferView(g.bufferView),S=this.getTypedArrayFromArrayBuffer(x,v.byteStride,A,C,1,f),y=p.byteOffset||0,b=this.gltf.bufferViews[p.bufferView],D=this.parseBufferView(p.bufferView),B=this.getTypedArrayFromArrayBuffer(D,b.byteStride,y,s,n,f);for(let T=0;T<S.length;T++)u.set(B.slice(T*n,T*n+n),S[T]*n)}return t.computeResult={typedArray:u,arrayType:s,numComponents:n},t.daccessor={data:u,numComponents:n,normalize:r},t.daccessor}getTypedArrayFromArrayBuffer(e,t,r,i,a,s){let n;const l=a*i.BYTES_PER_ELEMENT;if(t&&l!==t){const h=a*s;n=new i(h);for(let u=0;u<s;u++){const f=new i(e,r+u*t,a);for(let g=0;g<a;g++)n[u*a+g]=f[g]}}else n=new i(e,r,s*a);return n}parseBufferView(e){const t=this.gltf.bufferViews[e];if(!t)return this.errorMiss("bufferView",e);if(t.isParsed)return t.dbufferView;t.isParsed=!0,t.dbufferView=!1;const r=this.parseBuffer(t.buffer);if(r){const{byteOffset:i,byteLength:a}=t,s=new Uint8Array(r,i||0,a);t.dbufferView=new Uint8Array(s).buffer}return t.dbufferView}parseBuffer(e){const t=this.gltf.buffers[e];if(!t)return this.errorMiss("buffer",e);if(t.isParsed)return t.dbuffer;if(t.isParsed=!0,t.dbuffer=!1,t.uri.substring(0,5)!=="data:"){const r=t.uri,i=this.gltf.resources[r];i?i.byteLength===t.byteLength?t.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${e} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${e}] failed`)}else{const r=t.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,i=window.atob(t.uri.substring(r)),a=new Uint8Array(i.length);for(let s=0;s<i.length;s++)a[s]=i.charCodeAt(s);t.dbuffer=a.buffer}return t.dbuffer}getLight(e){return this.gltf.extensions.KHR_lights_punctual.lights[e]}applyNodeExtensions(e,t){let r=e.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(t.light=this.getLight(r.KHR_lights_punctual.light))}}class Sh{magic;version;length}class yh{chunkLength;chunkType;chunkData}class Es extends it{static format=Pe.BIN;_gltf;async parseBuffer(e){let t=new Uint8Array(e);t.pos=0;const r=this.parseHeader(t);if(r.magic!=1179937895)return console.error("invalid GLB file"),!1;if(r.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${r.version}`),!1;let i=[];for(;t.pos<t.length;){let f=this.parseChunk(t);i.push(f)}if(i[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let a="",s=65535,n=i[0].chunkData;for(let f=0;f<n.length;f+=s){let g=n.length-f;g=Math.min(g,s);let p=n.subarray(f,f+g);a+=String.fromCharCode(...p)}let l=JSON.parse(a);this._gltf=new ma,this._gltf={...this._gltf,...l},this._gltf.resources={};for(let f=0;f<this._gltf.buffers.length;f++){let g=this._gltf.buffers[f];g.isParsed=!0,g.dbuffer=i[f+1].chunkData.buffer}if(this._gltf.images)for(let f=0;f<this._gltf.images.length;f++){let g=this._gltf.images[f];g.name=g.name||"bufferView_"+g.bufferView.toString();const p=this._gltf.bufferViews[g.bufferView],A=this._gltf.buffers[p.buffer];let v=new Uint8Array(A.dbuffer,p.byteOffset,p.byteLength),C=new Blob([v],{type:g.mimeType}),x=new tr;await x.loadFromBlob(C),x.name=g.name,this._gltf.resources[g.name]=x}let u=await new va().parse(this.initUrl,this._gltf,this._gltf.scene);return u?(this.data=u.rootNode,u.rootNode):null}async parseJsonAndBuffer(e,t){this._gltf=new ma,this._gltf={...this._gltf,...e},this._gltf.resources={};let r=this._gltf.buffers[0];if(r.isParsed=!0,r.dbuffer=t,this._gltf.images)for(let s=0;s<this._gltf.images.length;s++){let n=this._gltf.images[s];n.name=n.name||"bufferView_"+n.bufferView.toString();const l=this._gltf.bufferViews[n.bufferView],h=this._gltf.buffers[l.buffer];let u=new Uint8Array(h.dbuffer,l.byteOffset,l.byteLength),f=new Blob([u],{type:n.mimeType}),g=new tr;await g.loadFromBlob(f),g.name=n.name,this._gltf.resources[n.name]=g}let a=await new va().parse(this.initUrl,this._gltf,this._gltf.scene);return a?(this.data=a.rootNode,a.rootNode):null}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let t=e.pos,r=new Sh,i=new Uint32Array(e.buffer,t,3);return e.pos+=i.byteLength,r.magic=i[0],r.version=i[1],r.length=i[2],r}parseChunk(e){let t=e.pos,r=new yh,i=new Uint32Array(e.buffer,t,2);t=e.pos+=i.byteLength,r.chunkLength=i[0],r.chunkType=i[1],r.chunkData=new Uint8Array(e.buffer,t,r.chunkLength);const a=new Uint8Array(r.chunkLength);for(let s=0;s<r.chunkLength;s++)a[s]=r.chunkData[s];return r.chunkData=a,e.pos+=r.chunkLength,r}}var $d=Object.defineProperty,eg=Object.getOwnPropertyDescriptor,tg=(o,e,t,r)=>{for(var i=r>1?void 0:r?eg(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&$d(e,t,i),i};c.StandShader=class extends ke{constructor(){super();let e=new Ae("PBRLItShader","PBRLItShader");e.setShaderEntry("VertMain","FragMain"),e.passType=W.COLOR,this.addRenderPass(e);let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor",new P(.75,.75,.75,1)),this.setUniformColor("emissiveColor",new P(0,0,0)),this.setUniformVector4("materialF0",new G(.04,.04,.04,1)),this.setUniformColor("specularColor",new P(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",1),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new P(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.baseMap=m.res.whiteTexture,this.normalMap=m.res.normalTexture,this.maskMap=m.res.maskTexture}get baseMap(){return this.getDefaultColorShader().getTexture("baseMap")}set baseMap(e){this.getDefaultColorShader().setTexture("baseMap",e)}get baseColor(){return this.getDefaultColorShader().getUniform("baseColor")}set baseColor(e){this.getDefaultColorShader().setUniformColor("baseColor",e)}get normalMap(){return this.getDefaultColorShader().getTexture("normalMap")}set normalMap(e){this.getDefaultColorShader().setTexture("normalMap",e)}get doubleSide(){return this.getDefaultColorShader().doubleSide}set doubleSide(e){this.getDefaultColorShader().doubleSide=e}get alphaCutoff(){return this.getDefaultColorShader().shaderState.alphaCutoff}set alphaCutoff(e){this.getDefaultColorShader().setDefine("USE_ALPHACUT",!0),this.getDefaultColorShader().shaderState.alphaCutoff=e,this.getDefaultColorShader().setUniform("alphaCutoff",e)}get emissiveColor(){return this.getDefaultColorShader().getUniform("emissiveColor")}set emissiveColor(e){this.getDefaultColorShader().setUniform("emissiveColor",e)}get emissiveIntensity(){return this.getDefaultColorShader().getUniform("emissiveIntensity")}set emissiveIntensity(e){this.getDefaultColorShader().setUniform("emissiveIntensity",e)}get uvTransform_1(){return this.getDefaultColorShader().uniforms.transformUV1.vector4}set uvTransform_1(e){this.getDefaultColorShader().setUniform("transformUV1",e)}get uvTransform_2(){return this.getDefaultColorShader().uniforms.transformUV2.vector4}set uvTransform_2(e){this.getDefaultColorShader().setUniform("transformUV2",e)}get depthWriteEnabled(){return this.getDefaultColorShader().shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.getDefaultColorShader().shaderState.depthWriteEnabled=e}get materialF0(){return this.getDefaultColorShader().uniforms.materialF0.vector4}set materialF0(e){this.getDefaultColorShader().setUniform("materialF0",e)}get specularColor(){return this.getDefaultColorShader().uniforms.specularColor.color}set specularColor(e){this.getDefaultColorShader().setUniform("specularColor",e)}get roughness(){return this.getDefaultColorShader().uniforms.roughness.value}set roughness(e){this.getDefaultColorShader().setUniform("roughness",e)}get metallic(){return this.getDefaultColorShader().uniforms.metallic.value}set metallic(e){this.getDefaultColorShader().setUniform("metallic",e)}get ao(){return this.getDefaultColorShader().uniforms.ao.value}set ao(e){this.getDefaultColorShader().setUniform("ao",e)}get metallic_min(){return this.getDefaultColorShader().uniforms.metallic_min.value}set metallic_min(e){this.getDefaultColorShader().setUniform("metallic_min",e)}get metallic_max(){return this.getDefaultColorShader().uniforms.metallic_max.value}set metallic_max(e){this.getDefaultColorShader().setUniform("metallic_max",e)}get roughness_min(){return this.getDefaultColorShader().uniforms.roughness_min.value}set roughness_min(e){this.getDefaultColorShader().setUniform("roughness_min",e)}get roughness_max(){return this.getDefaultColorShader().uniforms.roughness_max.value}set roughness_max(e){this.getDefaultColorShader().setUniform("roughness_max",e)}get normalScale(){return this.getDefaultColorShader().uniforms.normalScale.value}set normalScale(e){this.getDefaultColorShader().setUniform("normalScale",e)}get maskMap(){return this.getDefaultColorShader().textures.maskMap}set maskMap(e){this.getDefaultColorShader().setDefine("USE_MR",!0),this.getDefaultColorShader().setTexture("maskMap",e)}set aoMap(e){e&&(this.getDefaultColorShader().setTexture("aoMap",e),e!=m.res.whiteTexture&&this.getDefaultColorShader().setDefine("USE_AOTEX",!0))}get aoMap(){return this.getDefaultColorShader().textures.aoMap}set clearCoatRoughnessMap(e){e&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.getDefaultColorShader().setTexture("clearCoatRoughnessMap",e),this.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.getDefaultColorShader().textures.clearCoatRoughnessMap}get brdfLUT(){return this.getDefaultColorShader().textures.brdfLUT}set brdfLUT(e){this.getDefaultColorShader().setTexture("brdfLUT",e),this.getDefaultColorShader().setTexture("brdflutMap",e)}get emissiveMap(){return this.getDefaultColorShader().textures.emissiveMap}set emissiveMap(e){this.getDefaultColorShader().setTexture("emissiveMap",e)}set envIntensity(e){this.getDefaultColorShader().setUniformFloat("envIntensity",e)}get envIntensity(){return this.getDefaultColorShader().uniforms.envIntensity.value}set ior(e){this.getDefaultColorShader().setUniformFloat("ior",e)}get ior(){return this.getDefaultColorShader().uniforms.ior.value}useCleanCoat(){this.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(e){this.getDefaultColorShader().setUniformFloat("clearcoatFactor",e),this.useCleanCoat()}get clearcoatFactor(){return this.getDefaultColorShader().uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(e){this.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor",e),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(e){this.getDefaultColorShader().setUniformFloat("clearcoatWeight",e),this.useCleanCoat()}get clearcoatWeight(){return this.getDefaultColorShader().uniforms.clearcoatWeight.value}set clearcoatColor(e){this.getDefaultColorShader().setUniformColor("clearcoatColor",e),this.useCleanCoat()}get clearcoatColor(){return this.getDefaultColorShader().uniforms.clearcoatColor.color}},c.StandShader=tg([jt],c.StandShader);class rr extends We{constructor(){super();let e=new c.StandShader;this.shader=e}clone(){let e=new rr,t=e.shader.getDefaultColorShader(),r=this.shader.getDefaultColorShader();return t.defineValue={...r.defineValue},t.setUniform("shadowBias",r.getUniform("shadowBias")),t.setUniform("transformUV1",r.getUniform("transformUV1")),t.setUniform("transformUV2",r.getUniform("transformUV2")),t.setUniform("baseColor",r.getUniform("baseColor")),t.setUniform("specularColor",r.getUniform("specularColor")),t.setUniform("emissiveColor",r.getUniform("emissiveColor")),t.setUniform("materialF0",r.getUniform("materialF0")),t.setUniform("envIntensity",r.getUniform("envIntensity")),t.setUniform("normalScale",r.getUniform("normalScale")),t.setUniform("roughness",r.getUniform("roughness")),t.setUniform("metallic",r.getUniform("metallic")),t.setUniform("ao",r.getUniform("ao")),t.setUniform("roughness_min",r.getUniform("roughness_min")),t.setUniform("roughness_max",r.getUniform("roughness_max")),t.setUniform("metallic_min",r.getUniform("metallic_min")),t.setUniform("metallic_max",r.getUniform("metallic_max")),t.setUniform("emissiveIntensity",r.getUniform("emissiveIntensity")),t.setUniform("alphaCutoff",r.getUniform("alphaCutoff")),t.setUniform("ior",r.getUniform("ior")),t.setUniform("clearcoatFactor",r.getUniform("clearcoatFactor")),t.setUniform("clearcoatRoughnessFactor",r.getUniform("clearcoatRoughnessFactor")),t.setUniform("clearcoatColor",r.getUniform("clearcoatColor")),t.setUniform("clearcoatWeight",r.getUniform("clearcoatWeight")),t.setTexture("baseMap",r.getTexture("baseMap")),t.setTexture("normalMap",r.getTexture("normalMap")),t.setTexture("emissiveMap",r.getTexture("emissiveMap")),t.setTexture("aoMap",r.getTexture("aoMap")),t.setTexture("maskMap",r.getTexture("maskMap")),e}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set maskMap(e){this.shader.setTexture("maskMap",e)}get maskMap(){return this.shader.getTexture("maskMap")}set normalMap(e){this.shader.setTexture("normalMap",e)}get normalMap(){return this.shader.getTexture("normalMap")}set emissiveMap(e){this.shader.setTexture("emissiveMap",e)}get emissiveMap(){return this.shader.getTexture("emissiveMap")}set aoMap(e){this.shader.setTexture("aoMap",e)}get aoMap(){return this.shader.getTexture("aoMap")}set clearCoatRoughnessMap(e){this.shader.setTexture("clearCoatRoughnessMap",e),this.shader.setDefine("USE_CLEARCOAT",!0),this.shader.setDefine("USE_CLEARCOAT_ROUGHNESS",!0)}get clearCoatRoughnessMap(){return this.shader.getTexture("clearCoatRoughnessMap")}set clearcoatColor(e){this.shader.setUniformColor("clearcoatColor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatColor(){return this.shader.getUniformColor("clearcoatColor")}set clearcoatWeight(e){this.shader.setUniformFloat("clearcoatWeight",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatWeight(){return this.shader.getUniformFloat("clearcoatWeight")}set clearcoatFactor(e){this.shader.setUniformFloat("clearcoatFactor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatFactor(){return this.shader.getUniformFloat("clearcoatFactor")}set clearcoatRoughnessFactor(e){this.shader.setUniformFloat("clearcoatRoughnessFactor",e),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatRoughnessFactor(){return this.shader.getUniformFloat("clearcoatRoughnessFactor")}set alphaCutoff(e){this.shader.setUniform("alphaCutoff",e)}get alphaCutoff(){return this.shader.getUniform("alphaCutoff")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}get roughness(){return this.shader.getUniformFloat("roughness")}set roughness(e){this.shader.setUniformFloat("roughness",e)}get metallic(){return this.shader.getUniformFloat("metallic")}set metallic(e){this.shader.setUniformFloat("metallic",e)}get emissiveColor(){return this.shader.getUniformColor("emissiveColor")}set emissiveColor(e){this.shader.setUniformColor("emissiveColor",e)}get emissiveIntensity(){return this.shader.getUniformFloat("emissiveIntensity")}set emissiveIntensity(e){this.shader.setUniformFloat("emissiveIntensity",e)}get ao(){return this.shader.getUniform("ao")}set ao(e){this.shader.setUniform("ao",e)}}class wh extends it{static format=Pe.TEXT;textData="";source_vertices;source_normals;source_tangents;source_textureCoords;matLibs;geometrys;activeGeo;facesMaterialsIndex;mtl;mtlUrl;async parseString(e){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,await Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"}applyVector2(e,t,r){t[e]&&t[e].length>0?(r.push(t[e][0]),r.push(t[e][1])):(r.push(0),r.push(0))}applyVector3(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2])}applyVector4(e,t,r){r.push(t[e][0]),r.push(t[e][1]),r.push(t[e][2]),r.push(t[e][3])}async loadMTL(){let t=await new rt().loadTxt(this.baseUrl+this.mtlUrl),r=t.data,i,a=r.split(`\r
`);for(let l=0;l<a.length;l++){let h=a[l];var s=h.indexOf("#");s!=-1&&(h=h.substring(0,s)),h=h.trim();var n=h.split(/\s+/);n[0]==="newmtl"?(i={name:n[1]},this.matLibs[n[1]]=i):n[0].indexOf("map_")!=-1?(i[n[0]]=n[1],i.textures||(i.textures=[n[n.length-1]]),i.textures.push(n[n.length-1])):n.length==2?i[n[0]]=Number(n[1]):n.length==3?i[n[0]]=[Number(n[1]),Number(n[2])]:n.length==4&&(i[n[0]]=[Number(n[1]),Number(n[2]),Number(n[3])])}for(const l in this.matLibs){const h=this.matLibs[l];if(h.textures&&h.textures.length>0)for(let u=0;u<h.textures.length;u++){const f=tt.normalizePath(this.baseUrl+h.textures[u]);await m.res.loadTexture(f)}}return t=null,!0}async load_textures(){}parserLine(e){var t=e.indexOf("#");if(t!=-1){if(e.indexOf("# object")!=-1){var r=e.split(/\s+/);let g=r[1],p=r[2];this.activeGeo={type:g,name:p[1],source_mat:"",source_faces:[]},this.geometrys[p]=this.activeGeo}e=e.substring(0,t)}e=e.trim();var r=e.split(/\s+/);if(r[0]==="v"){var i=[Number(r[1]),Number(r[2]),Number(r[3]),r[4]?1:Number(r[4])];this.source_vertices.push(i)}else if(r[0]==="vt"){var a=[Number(r[1]),Number(r[2]),r[3]?1:Number(r[3])];this.source_textureCoords.push(a)}else if(r[0]==="vn"){var s=[Number(r[1]),Number(r[2]),Number(r[3])];this.source_normals.push(s)}else if(r[0]==="f"){for(var n={indices:[],texture:[],normal:[]},l=1;l<r.length;++l){var h=r[l].indexOf("//"),u=r[l].split(/\W+/);h>0?(n.indices.push(u[0]),n.normal.push(u[1])):u.length===1?n.indices.push(u[0]):u.length===2?(n.indices.push(u[0]),n.texture.push(u[1])):u.length===3&&(n.indices.push(u[0]),n.texture.push(u[1]),n.normal.push(u[2]))}this.activeGeo.source_faces.push(n)}else r[0]==="usemtl"?this.activeGeo.source_mat=r[1]:r[0]==="mtllib"&&(this.mtlUrl=r[1])}async parserOBJ(){let e=this.textData.split(`\r
`);for(let t=0;t<e.length;t++){const r=e[t];this.parserLine(r)}return this.textData="",!0}async parser_mesh(){for(const e in this.geometrys){const t=this.geometrys[e];t.vertex_arr=[],t.normal_arr=[],t.uv_arr=[],t.indeice_arr=[];let r=0;for(let a=0;a<t.source_faces.length;a++){const s=t.source_faces[a];let n=parseInt(s.indices[0])-1,l=parseInt(s.indices[1])-1,h=parseInt(s.indices[2])-1,u=parseInt(s.normal[0])-1,f=parseInt(s.normal[1])-1,g=parseInt(s.normal[2])-1,p=parseInt(s.texture[0])-1,A=parseInt(s.texture[1])-1,v=parseInt(s.texture[2])-1;if(this.applyVector3(n,this.source_vertices,t.vertex_arr),this.applyVector3(u,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(l,this.source_vertices,t.vertex_arr),this.applyVector3(f,this.source_normals,t.normal_arr),this.applyVector2(A,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,t.vertex_arr),this.applyVector3(g,this.source_normals,t.normal_arr),this.applyVector2(v,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,s.indices.length>3){let C=parseInt(s.indices[3])-1,x=parseInt(s.normal[3])-1,S=parseInt(s.texture[3])-1;this.applyVector3(n,this.source_vertices,t.vertex_arr),this.applyVector3(u,this.source_normals,t.normal_arr),this.applyVector2(p,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(h,this.source_vertices,t.vertex_arr),this.applyVector3(g,this.source_normals,t.normal_arr),this.applyVector2(v,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++,this.applyVector3(C,this.source_vertices,t.vertex_arr),this.applyVector3(x,this.source_normals,t.normal_arr),this.applyVector2(S,this.source_textureCoords,t.uv_arr),t.indeice_arr[r]=r++}}let i=new c.Object3D;for(const a in this.geometrys){const s=this.geometrys[a];let n=new ve;n.setIndices(new Uint32Array(s.indeice_arr)),n.setAttribute(M.position,new Float32Array(s.vertex_arr)),n.setAttribute(M.normal,new Float32Array(s.normal_arr)),n.setAttribute(M.uv,new Float32Array(s.uv_arr)),n.setAttribute(M.TEXCOORD_1,new Float32Array(s.uv_arr)),n.addSubGeometry({indexStart:0,indexCount:s.indeice_arr.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});let l=new rr,h=this.matLibs[s.source_mat];l.baseMap=m.res.getTexture(tt.normalizePath(this.baseUrl+h.map_Kd));let u=new c.Object3D,f=u.addComponent(c.MeshRenderer);f.geometry=n,f.material=l,i.addChild(u)}this.data=i}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}let Ih=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,bh=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Bh{static blurImageFromTexture(e,t,r,i){const a=I.device;let s=i?bh:Ih;const n=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:s}),entryPoint:"main"}}),l=4*4,h=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(h,0,new Uint32Array([e.width,e.height,t,r]));const u=a.createTexture({size:[t,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let f=[{binding:0,resource:{buffer:h,size:4*4}},{binding:1,resource:e.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:u.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const g=a.createBindGroup({layout:n.getBindGroupLayout(0),entries:f}),p=w.beginCommandEncoder(),A=p.beginComputePass();return A.setPipeline(n),A.setBindGroup(0,g),A.dispatchWorkgroups(Math.floor(t/8),Math.floor(r/8)),A.end(),w.endCommandEncoder(p),h.destroy(),u}}class _a extends De{width=4;height=4;depthOrArrayLayers=6;visibility=GPUShaderStage.FRAGMENT;textureBindingLayout={viewDimension:"cube",multisampled:!1};samplerBindingLayout={type:"filtering"};constructor(){super(4,4),this.addressModeU=ut.clamp_to_edge,this.addressModeV=ut.clamp_to_edge,this.addressModeW=ut.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,t,r,i,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,s=1){this.width=e,this.height=t,this.format=i,this.usage=a,this.textureDescriptor={size:{width:e,height:t,depthOrArrayLayers:6},mipLevelCount:r,format:i,usage:a,dimension:"2d"},s>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}class xa{static createCube=`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`;static configBuffer=null;static blurSettingBuffer=null;static pipeline;static createFace(e,t,r,i){const a=I.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:xa.createCube}),entryPoint:"main"}}));const s=this.pipeline,n=4*4;this.configBuffer||=a.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e,0,0,0])),this.blurSettingBuffer||=a.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let l=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:r.getGPUView()},{binding:2,resource:i.getGPUView()}];const h=a.createBindGroup({layout:s.getBindGroupLayout(0),entries:l}),u=w.beginCommandEncoder(),f=u.beginComputePass();f.setPipeline(s),f.setBindGroup(0,h),f.dispatchWorkgroups(t/8,t/8),f.end(),w.endCommandEncoder(u)}}class Ts extends _a{_images;_url;constructor(){super(),this.useMipmap=!0}generateImages(e){let t=I.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let r=Math.min(this.width,this.height);for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=this.getGPUTexture();let i=[],a=i,s=this.width,n=this.height;if(e[0]instanceof De){for(let l=0;l<6;l++){let h=e[l];i[l]=h.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,i)}else{this.uploadBaseImages(this.width,e);for(let l=0;l<6;l++){let h=new tr(!1);h.format=this.format,h.source=e[l],i[l]=h.getGPUTexture()}}for(let l=1;l<this.mipmapCount;l++){a=i,i=[];let h={width:s,height:n,gpuTexture:null};s=s/2,n=n/2;for(let u=0;u<6;u++)h.gpuTexture=a[u],i[u]=Bh.blurImageFromTexture(h,s,n,!1);this.uploadMipmapGPUTexture(l,s,n,i)}this.gpuSampler=t.createSampler(this)}uploadBaseImages(e,t){let r=I.device;const i=w.beginCommandEncoder();for(let a=0;a<6;a++)r.queue.copyExternalImageToTexture({source:t[a]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:a}},{width:e,height:e,depthOrArrayLayers:1});w.endCommandEncoder(i)}uploadMipmapGPUTexture(e,t,r,i){const a=w.beginCommandEncoder();for(let s=0;s<6;s++)a.copyTextureToTexture({texture:i[s],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:s}},{width:t,height:r,depthOrArrayLayers:1});w.endCommandEncoder(a)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let t=function(s,n){n.decode().then(async()=>{r[s]=await createImageBitmap(n),i--,i==0&&a.generateImages(r)})},r=[],i=6,a=this;for(let s=0;s<6;s++)t(s,this._images[s])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}async load(e){this._url=e;let t=6,r=[];this.format=z.rgba8unorm;let i=this;async function a(s,n){const l=document.createElement("img");if(l.src=n,l.setAttribute("crossOrigin",""),await l.decode(),r[s]=await createImageBitmap(l),t--,t==0)return i.generateImages(r),!0}for(let s=0;s<6;s++)await a(s,e[s]);return!0}async loadStd(e){this._url=e,this.format=z.rgba8unorm;const t=document.createElement("img");t.src=e,t.setAttribute("crossOrigin",""),await t.decode();let r=new tr(!1);r.name=tt.getURLName(e),r.format="rgba8unorm",r.source=await createImageBitmap(t);let i=Math.round(Math.log2(r.width/4));i=Math.pow(2,i),this.width=this.height=i;let a=[];for(let s=0;s<6;s++){let n=new fe(i,i,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);n.name="face "+s,a.push(n),xa.createFace(s,this.width,r,n)}return this.generateImages(a),!0}}var Eh=(o=>(o[o.Left=0]="Left",o[o.Right=1]="Right",o[o.Bottom=2]="Bottom",o[o.Top=3]="Top",o[o.Back=4]="Back",o[o.Front=5]="Front",o))(Eh||{});class Ds{static getRotationToFace(e){let t=Y.identity().clone(),r=new d,i=new R().identity(),a=new d;switch(e){case 3:r.set(0,-1,0),a.set(0,0,-1);break;case 2:r.set(0,1,0),a.set(0,0,1);break;case 1:r.set(1,0,0),a.set(0,1,0);break;case 0:r.set(-1,0,0),a.set(0,1,0);break;case 4:r.set(0,0,-1),a.set(0,1,0);break;case 5:return Y.identity()}return i.lookAt(new d,r,a),t.setFromRotationMatrix(i),t}}let Th=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Dh=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;class nt{static convertRGBE2RGBA(e,t){const r=I.device,i=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Dh}),entryPoint:"main"}}),a=r.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});r.queue.writeBuffer(a,0,new Uint32Array([e.width,e.height,e.width,e.height]));const s=r.createBuffer({size:t.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});r.queue.writeBuffer(s,0,t);let n=[{binding:0,resource:{buffer:a,size:4*4}},{binding:1,resource:{buffer:s,size:t.byteLength}},{binding:2,resource:e.getGPUView()}];const l=r.createBindGroup({layout:i.getBindGroupLayout(0),entries:n}),h=w.beginCommandEncoder(),u=h.beginComputePass();u.setPipeline(i),u.setBindGroup(0,l),u.dispatchWorkgroups(Math.floor(e.width/8),Math.floor(e.height/8)),u.end(),w.endCommandEncoder(h),a.destroy()}static makeFaceTexturePipeline;static configBuffer;static quaternionBuffer;static makeTextureCube(e,t,r){const i=I.device;nt.makeFaceTexturePipeline||=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:Th}),entryPoint:"main"}});const a=nt.makeFaceTexturePipeline,s=4*4;nt.configBuffer||=i.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),i.queue.writeBuffer(nt.configBuffer,0,new Uint32Array([e.width,e.height,t,t]));const n=4*6;if(!nt.quaternionBuffer){nt.quaternionBuffer=i.createBuffer({size:n*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let A=new Float32Array(4*6);for(let v=0;v<6;v++){let C=Ds.getRotationToFace(v);A[v*4+0]=C.x,A[v*4+1]=C.y,A[v*4+2]=C.z,A[v*4+3]=C.w}i.queue.writeBuffer(nt.quaternionBuffer,0,A)}let l=[{binding:0,resource:{buffer:nt.configBuffer,size:4*4}},{binding:1,resource:{buffer:nt.quaternionBuffer,size:n*4}},{binding:2,resource:e.gpuSampler},{binding:3,resource:e.getGPUView()}],h=[{binding:0,resource:r}];const u=i.createBindGroup({layout:a.getBindGroupLayout(0),entries:l}),f=i.createBindGroup({layout:a.getBindGroupLayout(1),entries:h}),g=w.beginCommandEncoder(),p=g.beginComputePass();p.setPipeline(a),p.setBindGroup(0,u),p.setBindGroup(1,f),p.dispatchWorkgroups(t/8,t/8,6),p.end(),w.endCommandEncoder(g)}}class Ps extends De{constructor(){super(32,32,null),this.isHDRTexture=!0}create(e=32,t=32,r=null,i=!0){this.width=e,this.height=t;let a=I.device;const n=e*4*2;let l=r;this.format=z.rgba16float,this.useMipmap=i,this.updateTextureDescription(),this.updateGPUTexture();const h=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=w.beginCommandEncoder();return u.copyBufferToTexture({buffer:h,bytesPerRow:n},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(u),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=a.createSampler(this),this}async load(e,t){return(await new rt().load(e,Rs,t)).getHDRTexture()}}const Ph=new Float32Array(1),rg=new Int32Array(Ph.buffer);let jr=function(o){Ph[0]=o;const e=rg[0];let t=e>>16&32768,r=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(i==255?1:0)&&e&8388607,t):i<114?(r|=2048,t|=(r>>114-i)+(r>>113-i&1),t):(t|=i-112<<10|r>>1,t+=r&1,t)};var Mh=(o=>(o[o.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",o[o.rgbe_read_error=1]="rgbe_read_error",o[o.rgbe_write_error=2]="rgbe_write_error",o[o.rgbe_format_error=3]="rgbe_format_error",o[o.rgbe_memory_error=4]="rgbe_memory_error",o))(Mh||{});class Ms{valid;string;comments;programtype;format;gamma;exposure;width;height}class Rs extends it{_rgbeArray;_width;_height;_RGBE_RETURN_FAILURE=-1;_parserType=z.rgba8uint;parseBuffer(e){let t,r=new Uint8Array(e);r.pos=0;const i=this.paserHeader(r);if(i instanceof Ms){const a=this._width=i.width,s=this._height=i.height;let n=this.parserPixel(r.subarray(r.pos),a,s);if(n instanceof Uint8Array){switch(this._rgbeArray=n,this._parserType){}return this.data=t,t}}return null}verification(){if(this.data&&this.data instanceof De)return!0;if(this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new Ca().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new Ps().create(this._width,this._height,this._rgbeArray)}parseError(e,t){switch(e){case 1:console.error("Read Error: "+(t||""));break;case 2:console.error("Write Error: "+(t||""));break;case 3:console.error("Bad File Format: "+(t||""));break;default:case 4:console.error("Error: "+(t||""))}return-1}parserBlock(e,t,r){t=t||1024;let a=e.pos,s=-1,n=0,l="",h=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));const u=`
`;for(;0>(s=h.indexOf(u))&&n<t&&a<e.byteLength;)l+=h,n+=h.length,a+=128,h+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<s?(r!==!1&&(e.pos+=n+s+1),l+h.slice(0,s)):!1}paserHeader(e){const t=/^#\?(\S+)/,r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,n=new Ms;let l,h;if(e.pos>=e.byteLength||!(l=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(h=l.match(t)))return this.parseError(3,"bad initial token");const u=1,f=2,g=4;for(n.valid|=u,n.programtype=h[1],n.string+=l+`
`;l=this.parserBlock(e),l!==!1;){if(n.string+=l+`
`,l.charAt(0)==="#"){n.comments+=l+`
`;continue}if((h=l.match(r))&&(n.gamma=Math.floor(parseFloat(h[1])*10)/10),(h=l.match(i))&&(n.exposure=Math.floor(parseFloat(h[1])*10)/10),(h=l.match(a))&&(n.valid|=f,n.format=h[1]),(h=l.match(s))&&(n.valid|=g,n.height=parseInt(h[1],10),n.width=parseInt(h[2],10)),n.valid&f&&n.valid&g)break}return n.valid&f?n.valid&g?n:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,t,r){const i=t;if(i<8||i>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(i!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const a=new Uint8Array(4*t*r);if(!a.length)return this.parseError(4,"unable to allocate buffer space");let s=0,n=0;const l=4*i,h=new Uint8Array(4),u=new Uint8Array(l);let f=r;for(;f>0&&n<e.byteLength;){if(n+4>e.byteLength)return this.parseError(1,"");if(h[0]=e[n++],h[1]=e[n++],h[2]=e[n++],h[3]=e[n++],h[0]!=2||h[1]!=2||(h[2]<<8|h[3])!=i)return this.parseError(3,"bad rgbe scanline format");let g=0,p;for(;g<l&&n<e.byteLength;){p=e[n++];const v=p>128;if(v&&(p-=128),p===0||g+p>l)return this.parseError(3,"bad scanline data");if(v){const C=e[n++];for(let x=0;x<p;x++)u[g++]=C}else u.set(e.subarray(n,n+p),g),g+=p,n+=p}const A=i;for(let v=0;v<A;v++){let C=0;a[s]=u[v+C],C+=i,a[s+1]=u[v+C],C+=i,a[s+2]=u[v+C],C+=i,a[s+3]=u[v+C],s+=4}f--}return a}rbgeToFloat(e,t,r,i){const a=e[t+3],s=Math.pow(2,a-128)/255;r[i+0]=e[t+0]*s,r[i+1]=e[t+1]*s,r[i+2]=e[t+2]*s,r[i+3]=1}rbgeToHalfFloat(e,t,r,i){const a=e[t+3],s=Math.pow(2,a-128)/255;r[i+0]=jr(e[t+0]*s),r[i+1]=jr(e[t+1]*s),r[i+2]=jr(e[t+2]*s),r[i+3]=jr(1)}}let Rh=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class Uh{static configBuffer=null;static quaternionBuffer=null;static blurSettingBuffer=null;static pipeline;static importantSample(e,t,r,i){const a=I.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:Rh}),entryPoint:"main"}}));const s=this.pipeline,n=4*4;this.configBuffer||=a.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([e.width,e.height,t,t]));const l=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=a.createBuffer({size:l*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let C=new Float32Array(4*6);for(let x=0;x<6;x++){let S=Ds.getRotationToFace(x);C[x*4+0]=S.x,C[x*4+1]=S.y,C[x*4+2]=S.z,C[x*4+3]=S.w}a.queue.writeBuffer(this.quaternionBuffer,0,C)}this.blurSettingBuffer||=a.createBuffer({size:n,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const h=e.erpTexture;let u=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:l*4}},{binding:2,resource:h.gpuSampler},{binding:3,resource:h.getGPUView()}],f=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:i}];const g=a.createBindGroup({layout:s.getBindGroupLayout(0),entries:u}),p=a.createBindGroup({layout:s.getBindGroupLayout(1),entries:f}),A=w.beginCommandEncoder(),v=A.beginComputePass();v.setPipeline(s),v.setBindGroup(0,g),v.setBindGroup(1,p),v.dispatchWorkgroups(t/8,t/8,6),v.end(),w.endCommandEncoder(A)}}class Us{faceTextureRef;_texture;constructor(e){this._texture=e,this.faceTextureRef={}}uploadTexture(e,t){let r=this.getGpuSource(e);return nt.makeTextureCube(t,this._texture.width,r.v),this}uploadErpTexture(e){let t=this.getGpuSource(0);return nt.makeTextureCube(e,this._texture.width,t.v),this.generateMipmap(e),this}getGpuSource(e){let t=this.faceTextureRef[e];return t||(t={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:e,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[e]=t),t}generateMipmap(e){let t=1;for(;t<this._texture.mipmapCount;)this.generateMipmapAtLevel(t,e),t++}generateMipmapAtLevel(e,t,r=3){let i=this._texture.width/Math.pow(2,e),a={width:i,height:i,erpTexture:t},s=(e+1)/this._texture.mipmapCount;s=Math.pow(s,r);let n=this.getGpuSource(e);Uh.importantSample(a,i,s,n.v)}}class Ca extends _a{_url;_faceData;constructor(){super(),this.useMipmap=!0,this.format=z.rgba16float,this.isHDRTexture=!0,this._faceData=new Us(this)}createFromHDRData(e,t){let r=new fe(t.width,t.height,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),i=new Float32Array(t.array);return nt.convertRGBE2RGBA(r,i),this.createFromTexture(e,r),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=I.device.createSampler(this),this._faceData.uploadErpTexture(t),this}async load(e,t){return this._url=e,(await new rt().load(e,Rs,t)).getCubeTexture()}}function Lh(o){return new TextDecoder().decode(o)}class Sa{buffer;binOffset;binLength;header;constructor(e,t,r,i){this.buffer=e,this.binOffset=t+r,this.binLength=i;let a=null;if(r!==0){const s=new Uint8Array(e,t,r);a=JSON.parse(Lh(s))}else a={};this.header=a}getKeys(){return Object.keys(this.header)}getData(e,t,r=null,i=null){const a=this.header;if(!(e in a))return null;const s=a[e];if(s instanceof Object){if(Array.isArray(s))return s;{const{buffer:n,binOffset:l,binLength:h}=this,u=s.byteOffset||0,f=s.type||i,g=s.componentType||r;if("type"in s&&i&&s.type!==i)throw new Error("FeatureTable: Specified type does not match expected type.");let p;switch(f){case"SCALAR":p=1;break;case"VEC2":p=2;break;case"VEC3":p=3;break;case"VEC4":p=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${e}".`)}let A;const v=l+u,C=t*p;switch(g){case"BYTE":A=new Int8Array(n,v,C);break;case"UNSIGNED_BYTE":A=new Uint8Array(n,v,C);break;case"SHORT":A=new Int16Array(n,v,C);break;case"UNSIGNED_SHORT":A=new Uint16Array(n,v,C);break;case"INT":A=new Int32Array(n,v,C);break;case"UNSIGNED_INT":A=new Uint32Array(n,v,C);break;case"FLOAT":A=new Float32Array(n,v,C);break;case"DOUBLE":A=new Float64Array(n,v,C);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${e}".`)}if(v+C*A.BYTES_PER_ELEMENT>l+h)throw new Error("FeatureTable: Feature data read outside binary body length.");return A}}else return s}}class Ls extends Sa{batchSize;constructor(e,t,r,i,a){super(e,r,i,a),this.batchSize=t}getData(e,t=null,r=null){return super.getData(e,this.batchSize,t,r)}}function Os(o){let e;if(o instanceof DataView?e=o:e=new DataView(o),String.fromCharCode(e.getUint8(0))==="{")return null;let t="";for(let r=0;r<4;r++)t+=String.fromCharCode(e.getUint8(r));return t}class Oh{async parse(e){const t=new DataView(e),r=Os(t);console.assert(r==="b3dm");const i=t.getUint32(4,!0);console.assert(i===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const s=t.getUint32(12,!0),n=t.getUint32(16,!0),l=t.getUint32(20,!0),h=t.getUint32(24,!0),u=28,f=new Sa(e,u,s,n),g=u+s+n,p=new Ls(e,f.getData("BATCH_LENGTH"),g,l,h),A=g+l+h,v=new Uint8Array(e,A,a-A);return{version:i,featureTable:f,batchTable:p,glbBytes:v}}}class ir extends Oh{adjustmentTransform;gltfBuffer;static tempMatrix;constructor(){super(),this.adjustmentTransform=new R().identity(),ir.tempMatrix||=new R().identity()}async parse(e){const t=await super.parse(e);this.gltfBuffer=t.glbBytes.slice().buffer;let i=await new Ns().parseBinary(this.gltfBuffer),{batchTable:a,featureTable:s}=t;const n=s.getData("RTC_CENTER");n&&(i.x+=n[0],i.y+=n[1],i.z+=n[2]);let l=i.getComponent(st);l.updateWorldMatrix();let h=ir.tempMatrix;h.compose(l.localPosition,l.localRotQuat,l.localScale),h.multiply(this.adjustmentTransform);let u=h.decompose(qt.QUATERNION);return l.localRotQuat.copyFrom(u[1]),l.localRotQuat=l.localRotQuat,l.localPosition.copyFrom(u[0]),l.localPosition=l.localPosition,l.localScale.copyFrom(u[2]),l.localScale=l.localScale,l.updateWorldMatrix(),i.batchTable=a,i.featureTable=s,i}static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let r=0,i=e.length;r<i;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch{return t}}}class Fh extends it{static format=Pe.JSON;async parseBuffer(e){let t=new ir;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}const Nh="glTF",Ci=12,zh={JSON:1313821514,BIN:5130562},Fs={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class kh{name;content;body;header;constructor(e){this.name=Fs.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Ci);if(this.header={magic:ir.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Nh)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-Ci,i=new DataView(e,Ci);let a=0;for(;a<r;){const s=i.getUint32(a,!0);a+=4;const n=i.getUint32(a,!0);if(a+=4,n===zh.JSON){const l=new Uint8Array(e,Ci+a,s);this.content=ir.decodeText(l)}else if(n===zh.BIN){const l=Ci+a;this.body=e.slice(l,l+s)}a+=s}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class Ns{_binary;async parseBinary(e){this._binary=e;const t=ir.decodeText(new Uint8Array(this._binary,0,4)),r={};let i,a;if(t===Nh){try{a=r[Fs.KHR_BINARY_GLTF]=new kh(this._binary)}catch{return}i=r[Fs.KHR_BINARY_GLTF].content}else i=ir.decodeText(new Uint8Array(this._binary));const s=JSON.parse(i);return await this.parseGLB(s,a.body)}async parseGLB(e,t){return await new Es().parseJsonAndBuffer(e,t)}}class Gh{async parse(e){const t=new DataView(e),r=Os(t);console.assert(r==="i3dm");const i=t.getUint32(4,!0);console.assert(i===1);const a=t.getUint32(8,!0);console.assert(a===e.byteLength);const s=t.getUint32(12,!0),n=t.getUint32(16,!0),l=t.getUint32(20,!0),h=t.getUint32(24,!0);t.getUint32(28,!0);const u=32,f=new Sa(e,u,s,n),g=u+s+n,p=new Ls(e,f.getData("INSTANCES_LENGTH"),g,l,h),A=g+l+h,v=new Uint8Array(e,A,a-A);return{version:i,featureTable:f,batchTable:p,glbBytes:v}}}class Qh extends c.Object3D{_geometry;_material;_instanceList;constructor(e,t,r){super(),this._geometry=e,this._material=t,this._instanceList=[];for(let i=0;i<r;i++){let a,s=new c.Object3D;a=s.addComponent(c.MeshRenderer),a.geometry=this._geometry,a.material=this._material,this.addChild(s),this._instanceList.push(s)}}setMatrixAt(e,t){let r=this._instanceList[e],i=t.decompose(qt.QUATERNION),a=r.transform;return a.localRotQuat.copyFrom(i[1]),a.localRotQuat=a.localRotQuat,a.localPosition.copyFrom(i[0]),a.localPosition=a.localPosition,a.localScale.copyFrom(i[2]),a.localScale=a.localScale,this}}class Rt extends Gh{static tempFwd;static tempUp;static tempRight;static tempPos;static tempQuat;static tempSca;static tempMat;adjustmentTransform;_gltfBuffer;constructor(){super(),Rt.tempFwd||=new d,Rt.tempUp||=new d,Rt.tempRight||=new d,Rt.tempPos||=new d,Rt.tempQuat||=new Y,Rt.tempSca||=new d,Rt.tempMat||=new R,this.adjustmentTransform=new R().identity()}async parse(e){const t=await super.parse(e);this._gltfBuffer=t.glbBytes.slice().buffer;let i=await new Ns().parseBinary(this._gltfBuffer),{batchTable:a,featureTable:s}=t;const n=this.adjustmentTransform,l=s.getData("INSTANCES_LENGTH"),h=s.getData("POSITION",l,"FLOAT","VEC3"),u=s.getData("NORMAL_UP",l,"FLOAT","VEC3"),f=s.getData("NORMAL_RIGHT",l,"FLOAT","VEC3"),g=s.getData("SCALE_NON_UNIFORM",l,"FLOAT","VEC3"),p=s.getData("SCALE",l,"FLOAT","SCALAR"),A=new Map,v=[];i.traverse(S=>{let y;if(y=S?S.getComponent(c.MeshRenderer):null,y){const{geometry:b,material:D}=y,B=new Qh(b,D,l);B.localPosition=B.localPosition.copy(S.localPosition),B.localRotation=B.localRotation.copy(S.localRotation),B.localScale=B.localScale.copy(S.localScale),v.push(B),A.set(S,B)}});const C=new d;for(let S=0;S<l;S++)C.x+=h[S*3+0]/l,C.y+=h[S*3+1]/l,C.z+=h[S*3+2]/l;A.forEach((S,y)=>{const b=y.parent?y.parentObject:null;b&&(b.removeChild(y),b.addChild(S),S.transform.updateWorldMatrix(),S.transform.worldMatrix.transformVector4(C,S.localPosition))});const x=Rt;for(let S=0;S<l;S++){x.tempMat.identity(),x.tempPos.set(h[S*3+0]-C.x,h[S*3+1]-C.y,h[S*3+2]-C.z),u?(x.tempUp.set(u[S*3+0],u[S*3+1],u[S*3+2]),x.tempRight.set(f[S*3+0],f[S*3+1],f[S*3+2]),x.tempRight.crossProduct(x.tempUp,x.tempFwd).normalize(),x.tempMat.makeBasis(x.tempRight,x.tempUp,x.tempFwd),x.tempQuat.setFromRotationMatrix(x.tempMat)):x.tempQuat.set(0,0,0,1),p?x.tempSca.setScalar(p[S]):g?x.tempSca.set(g[S*3+0],g[S*3+1],g[S*3+2]):x.tempSca.set(1,1,1),x.tempMat.compose(x.tempPos,x.tempQuat,x.tempSca),x.tempMat.multiplyMatrices(x.tempMat,n);for(let y=0,b=v.length;y<b;y++)v[y].setMatrixAt(S,x.tempMat)}return i.batchTable=a,i.featureTable=s,i}}class Vh extends it{static format=Pe.BIN;async parseBuffer(e){let t=new Rt;t.adjustmentTransform=this.userData,this.data=await t.parse(e)}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}class ya extends _a{_faceData;_url;get ldrImageUrl(){return this._url}constructor(){super(),this.useMipmap=!0,this.format=z.rgba16float,this._faceData=new Us(this)}async load(e,t){this._url=e;let r=new tr(!1);return await r.load(e,t),this.createFromLDRTexture(r),this}createFromLDRTexture(e){let t=Math.log2(e.width/4);return t=Math.pow(2,Math.round(t)),this.createFromTexture(t,e),this}createFromTexture(e,t){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let r=this.width;for(this.mipmapCount=1;r>16;)r/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=I.device.createSampler(this),this._faceData.uploadErpTexture(t),this}}let Hh=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class Yh{compute;constructor(){this.compute=new ie(Hh)}generateBRDFLUTTexture(){let e=new fe(256,256,z.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",e),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=w.beginCommandEncoder();return w.computeCommand(t,[this.compute]),w.endCommandEncoder(t),e}}class Xh extends De{_dataBuffer;create(e,t,r,i=!1){let a=I.device;const s=Math.ceil(e*4/256)*256;this.format=z.rgba8unorm,this.mipmapCount=Math.floor(i?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const n=this._dataBuffer=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(n,0,r);const l=w.beginCommandEncoder();return l.copyBufferToTexture({buffer:n,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l),i&&$e.webGPUGenerateMipmap(this),this}updateTexture(e,t,r){let i=I.device;const a=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const s=this._dataBuffer=i.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});i.queue.writeBuffer(s,0,r);const n=w.beginCommandEncoder();n.copyBufferToTexture({buffer:s,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(n),this.gpuSampler=i.createSampler(this),this.mipmapCount>1&&$e.webGPUGenerateMipmap(this)}}class Wr{id;guiTexture;uvRec=new G(0,0,1,1);uvBorder=new G(0,0,0,0);offsetSize=new G(0,0,4,4);borderSize=new G(0,0,0,0);trimSize=new V;isSliced=!1;height=4;width=4;xadvance=0;xoffset=0;yoffset=0;constructor(e){this.guiTexture=e||m.res.defaultGUITexture}}class Ar{static _maxUid=-1;_staticId=-1;dynamicId=-1;texture;width=1;height=1;get staticId(){return this._staticId}constructor(e){e||=m.res.whiteTexture,this.texture=e,Ar._maxUid++,this._staticId=Ar._maxUid,this.init()}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}}class ig{fntCache={};fntData={};addFontData(e,t,r){this.fntData[`${e}${t}`]=r}getFontData(e,t){return this.fntData[`${e}${t}`]}addFnt(e,t,r,i){let a=`${e}${t}`;this.fntCache[a]||(this.fntCache[a]={}),this.fntCache[a][r]=i}getFnt(e,t,r){let i=`${e}${t}`,a=this.fntCache[i];return a?a[r]:this.fntCache[" "]}}let qr=new ig;class jh{face="";size=0;bold=!1;italic=!1;stretchH=0;spacing="";outline=0;lineHeight=0;base=0;scaleW=0;scaleH=0;pages=0;packed=0;alphaChnl=0;redChnl=0;greenChnl=0;blueChnl=0;count=0;fontPage=[];fontChar={};constructor(){}}class Wh{id=0;file=""}class qh{id=-1;x=0;y=0;width=0;height=0;xoffset=0;yoffset=0;xadvance=0;page=0;chnl=0}class ar extends it{static format=Pe.TEXT;static parseSprite(e,t){for(const r in t.fontChar)if(Object.prototype.hasOwnProperty.call(t.fontChar,r)){const i=t.fontChar[r];let a=new Wr;a.id=i.id.toString(),a.offsetSize.set(0,0,i.width,i.height),a.trimSize.set(i.width,i.height),a.width=i.width,a.height=i.height,a.xadvance=i.xadvance,a.xoffset=i.xoffset,a.yoffset=i.yoffset,a.guiTexture=e[i.page],a.uvRec.set(i.x/t.scaleW,(t.scaleH-(i.y+i.height))/t.scaleH,i.width/t.scaleW,i.height/t.scaleH),qr.addFnt(t.face,t.size,a.id,a)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}async parseString(e){let t=this.getNewLine(e),r=e,i=new jh;r.trim().split(t).forEach((a,s)=>{if(s<2)ar.readLineProperty(a,i);else if(s<i.pages+2){let n=new Wh;ar.readLineProperty(a,n),i.fontPage.push(n)}else if(s<i.pages+3)ar.readLineProperty(a,i);else if(i.count>0){let n=new qh;ar.readLineProperty(a,n),i.fontChar[n.id]=n,i.count--}}),r="",this.data=i,await this.loadFontTextures()}getNewLine(e){return e.indexOf(`\r
`)!=-1?`\r
`:e.indexOf("\r")!=-1?"\r":`
`}async loadFontTextures(){let e=[],t=this.data;for(const r of t.fontPage){let i=this.baseUrl+r.file;await m.res.loadTexture(i,null,!0);let a=m.res.getTexture(i),s=new Ar(a);e.push(s)}ar.parseSprite(e,t),t.fontChar[" "]||ar.insertSpaceChar(t,e[0])}static insertSpaceChar(e,t){let r=new Wr,i=e.size*.5,a=e.lineHeight*.5;r.id=" ",r.offsetSize.set(0,0,e.size,e.size),r.trimSize.set(i,a),r.width=i,r.height=a,r.xadvance=0,r.xoffset=0,r.yoffset=0,r.guiTexture=t,r.uvRec.set(0,0,1e-6,1e-6),qr.addFnt(e.face,e.size,r.id,r)}static readLineProperty(e,t){e.trim().split(" ").forEach((r,i)=>{let a=r.split("=");if(a.length>1){let s=a[0],n=a[1];Object.prototype.hasOwnProperty.call(t,s)&&(n.indexOf('"')==-1?t[s]=parseFloat(a[1]):t[s]=n.replace('"',"").replace('"',""))}})}}function ag(o,e){let t=new Wr;return t.id=o,t.offsetSize.set(0,0,e.width,e.height),t.trimSize.set(e.width,e.height),t.width=e.width,t.height=e.height,t.xadvance=0,t.xoffset=0,t.yoffset=0,t.guiTexture=new Ar(e),t.uvRec.set(0,0,1,1),e.isVideoTexture||(e.flipY=!0),t}function Kh(o,e,t){let r=new Wr;r.guiTexture=o,r.id=e,r.uvRec.copyFrom(t.textureRect),r.trimSize.x=t.textureRect.z,r.trimSize.y=t.textureRect.w,r.offsetSize.x=t.textureRectOffset.x,r.offsetSize.y=t.textureRectOffset.y,r.offsetSize.z=t.size.x,r.offsetSize.w=t.size.y,r.width=t.size.x,r.height=t.size.y;let i=1/o.width,a=1/o.height;r.uvRec.set(r.uvRec.x*i,r.uvRec.y*a,r.uvRec.z*i,r.uvRec.w*a);let s=.1;return t.border.x<=s&&t.border.y<=s&&t.border.z<=s&&t.border.x<=s?r.isSliced=!1:(r.borderSize.copyFrom(t.border),r.uvBorder.copyFrom(t.border),r.uvBorder.x-=t.textureRectOffset.x,r.uvBorder.y-=t.textureRectOffset.y,r.uvBorder.z=t.border.z-(t.size.x-t.textureRect.z-t.textureRectOffset.x),r.uvBorder.w=t.border.w-(t.size.y-t.textureRect.w-t.textureRectOffset.y),r.uvBorder.x/=t.textureRect.z,r.uvBorder.z/=t.textureRect.z,r.uvBorder.y/=t.textureRect.w,r.uvBorder.w/=t.textureRect.w,r.isSliced=!0),r}class Jh{_spriteMap=new Map;_spriteList=[];textureSize=new V;name;constructor(e){this.textureSize.set(e.x,e.y)}setTexture(e,t,r){let i=Kh(e,t,r);return this._spriteMap.set(i.id,i),this._spriteList.push(i),i}getSprite(e){return this._spriteMap.get(e)}get spriteList(){return this._spriteList}}class Zh extends it{static format=Pe.TEXT;_json;_texture;async parseString(e){this._json=JSON.parse(e);let t=this.userData.replace(".json",".png");this._texture=await m.res.loadTexture(t,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new Jh(this._json.size),t=new Ar(this._texture),r=this._json.atlas;for(const i in r)e.setTexture(t,i,r[i]);m.res.addAtlas(this.baseUrl,e),this.data=e}}class $h{_texturePool;_materialPool;_prefabPool;_gltfPool;_geometryPool;_atlasList;_obj;constructor(){this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._geometryPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this._obj=new Map}getGltf(e){return this._gltfPool.get(e)}addObj(e,t){this._obj.set(e,t)}getObj(e){return this._obj.get(e)}addTexture(e,t){this._texturePool.set(e,t)}getTexture(e){return this._texturePool.get(e)}addGeometry(e,t){this._geometryPool.set(e,t)}getGeometry(e){return this._geometryPool.get(e)}addMat(e,t){return this._materialPool.set(e,t)}getMat(e){return this._materialPool.get(e)}addPrefab(e,t){this._prefabPool.set(e,t)}getPrefab(e){return this._prefabPool.get(e).instantiate()}addAtlas(e,t){t.name=e,this._atlasList.set(e,t)}getAtlas(e){return this._atlasList.get(e)}getGUISprite(e){for(let t of this._atlasList.values()){let r=t.getSprite(e);if(r)return r}return null}async load(e,t,r){return(await new rt().load(e,t,r)).data}async loadGltf(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,i=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new rt;i==".gltf"?r=await a.load(e,Ke,t):r=await a.load(e,Es,t);let s=r.data;return this._prefabPool.set(e,s),this._gltfPool.set(e,r.gltf),s}async loadObj(e,t){if(this._prefabPool.has(e))return this._prefabPool.get(e);let r,i=e.substring(e.lastIndexOf(".")).toLowerCase(),a=new rt;i==".obj"&&(r=await a.load(e,wh,t));let s=r.data;return this._prefabPool.set(e,s),s}async loadB3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let s=(await new rt().load(e,Fh,t,r)).data;return this._prefabPool.set(e,s),s}async loadI3DM(e,t,r){if(this._prefabPool.has(e))return this._prefabPool.get(e);let s=(await new rt().load(e,Vh,t,r)).data;return this._prefabPool.set(e,s),s}async loadTexture(e,t,r){if(this._texturePool.has(e))return this._texturePool.get(e);let i=new tr;return i.flipY=r,await i.load(e,t),this._texturePool.set(e,i),i}async loadTextureCount(e,t,r,i){return new Promise(async(a,s)=>{let n=0,l=[];t==0&&a(l);for(let h=0;h<t;h++){const u=e.shift();this.loadTexture(u,r,i).then(f=>{l.push(f),n++,n==t&&a(l)})}})}async loadBitmapTextures(e,t=5,r,i){let a=[],s=Math.floor(e.length/t)+1,n=Math.floor(e.length%t);for(let l=0;l<s;l++){let h=await this.loadTextureCount(e,l==s-1?n:t,r,i);a.push(...h)}return a}async loadHDRTexture(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Ps;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadHDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Ca;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadLDRTextureCube(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new ya;return r=await r.load(e,t),this._texturePool.set(e,r),r}async loadTextureCubeMaps(e){let t=e[0];if(this._texturePool.has(t))return this._texturePool.get(t);let r=new Ts;return await r.load(e),this._texturePool.set(e[0],r),r}async loadTextureCubeStd(e,t){if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Ts;return await r.loadStd(e),r}async loadJSON(e,t){return await new rt().loadJson(e,t).then(async r=>r).catch(r=>{console.log(r)})}async loadFont(e,t,r){let a=await new rt().load(e,ar,t,r),s=a.data;return qr.addFontData(s.face,s.size,s),a.data}async loadAtlas(e,t){return(await new rt().load(e,Zh,t,e)).data}normalTexture;maskTexture;whiteTexture;blackTexture;redTexture;blueTexture;greenTexture;yellowTexture;grayTexture;defaultSky;defaultGUITexture;defaultGUISprite;defaultMaterial;createTexture(e,t,r,i,a,s,n){let l=32,h=32,u=new Uint8Array(l*h*4);this.fillColor(u,e,t,r,i,a,s);let f=new Xh;return f.name=n,f.create(16,16,u,!0),n&&this.addTexture(n,f),f}fillColor(e,t,r,i,a,s,n){for(let l=0;l<t;l++)for(let h=0;h<r;h++){let u=h*t+l;e[u*4+0]=i,e[u*4+1]=a,e[u*4+2]=s,e[u*4+3]=n}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,255,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new Yh().generateBRDFLUTTexture(),r=t.name="BRDFLUT";this.addTexture(r,t),this.defaultSky=new Ca,this.defaultSky.createFromTexture(128,this.blackTexture),te.getInstance().attached(this.defaultSky,this),te.getInstance().attached(t,this),te.getInstance().attached(this.normalTexture,this),te.getInstance().attached(this.maskTexture,this),te.getInstance().attached(this.whiteTexture,this),te.getInstance().attached(this.blackTexture,this),te.getInstance().attached(this.redTexture,this),te.getInstance().attached(this.blueTexture,this),te.getInstance().attached(this.greenTexture,this),te.getInstance().attached(this.yellowTexture,this),te.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new Ar(this.whiteTexture),this.defaultGUISprite=new Wr(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4),this.defaultMaterial=new rr}}class Pr extends Ct{constructor(){super();let e=I.presentationSize;F.register("FXAA_Shader",Pu);let t=this.createRTTexture("FXAAPost",e[0],e[1],z.rgba16float),r=this.createViewQuad("fxaa","FXAA_Shader",t);r.quadShader.setUniform("u_texel",new V(1/e[0],1/e[1])),r.quadShader.setUniform("u_strength",4)}onAttach(e){m.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){m.setting.render.postProcessing.fxaa.enable=!1}}class zs extends _e{_postList;init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,t=m.getRenderJob(e);this._postList.forEach(r=>{t.addPost(r)})}unActivePost(){let e=this.transform.view3D,t=m.getRenderJob(e);this._postList.forEach(r=>{t.removePost(r)})}addPost(e){if(this._postList.has(e))return;if(!this._postList.has(Pr)){let r=new Pr;if(this._postList.set(Pr,r),this._enable&&this.activePost(),e===Pr)return r}let t=new e;return this._postList.set(e,t),this._enable&&this.activePost(),t}removePost(e){if(!this._postList.has(e))return;let t=this._postList.get(e);this._postList.delete(e);let r=this.transform.view3D;m.getRenderJob(r).removePost(t)}getPost(e){return this._postList.has(e)?this._postList.get(e):null}}class m{static res;static inputSystem;static views;static _frameRateValue=0;static _frameRate=360;static _frameTimeCount=0;static _deltaTime=0;static _time=0;static _beforeRender;static _renderLoop;static _lateRender;static _requestAnimationFrameID=0;static Engine3D;static divB;static get frameRate(){return this._frameRate}static set frameRate(e){this._frameRate=e,this._frameRateValue=1/e,e>=360&&(this._frameRateValue=0)}static get size(){return I.presentationSize}static get aspect(){return I.aspect}static get width(){return I.windowWidth}static get height(){return I.windowHeight}static setting={occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,gi:!1,postProcessing:{bloom:{downSampleStep:5,downSampleBlurSize:5,downSampleBlurSigma:1,upSampleBlurSize:5,upSampleBlurSigma:1,luminanceThreshole:1,bloomIntensity:1},globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new P(96/255,117/255,133/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},godRay:{blendColor:!0,rayMarchCount:16,scatteringExponent:5,intensity:.5},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:.7,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:.002,shadowSize:1024,pointShadowSize:1024,shadowSoft:.005,shadowBias:1e-4,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1},loader:{numConcurrent:20}};static renderJobs;static async init(e={}){console.log("Engine Version",of),this.setting={...this.setting,...e.engineSetting},await $.init(R.allocCount),await I.init(e.canvasConfig),F.init(),$t.init(),ae.init(),ye.init(),ot.init(),this.res=new $h,this.res.initDefault(),this._beforeRender=e.beforeRender,this._renderLoop=e.renderLoop,this._lateRender=e.lateRender,this.inputSystem=new Po,this.inputSystem.initCanvas(I.canvas)}static startRenderView(e){this.renderJobs||=new Map,this.views=[e];let t=new ps(e);return this.renderJobs.set(e,t),I.presentationSize,this.setting.pick.mode=="pixel"&&e.scene.getOrAddComponent(zs).addPost(Pr),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(e.enablePick=!0),this.resume(),t}static startRenderViews(e){this.renderJobs||=new Map,this.views=e;for(let t=0;t<e.length;t++){const r=e[t];let i=new ps(r);this.renderJobs.set(r,i);let a=I.presentationSize;this.setting.pick.mode=="pixel"?r.scene.addComponent(zs).addPost(Pr):ye.createRTTexture(Le.colorBufferTex_NAME,a[0],a[1],z.rgba16float,!1),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(r.enablePick=!0)}this.resume()}static getRenderJob(e){return this.renderJobs.get(e)}static pause(){this._requestAnimationFrameID!=0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID=requestAnimationFrame(e=>this.render(e))}static render(e){this._deltaTime=e-this._time,this._time=e,this._frameRateValue>0?(this._frameTimeCount+=this._deltaTime*.001,this._frameTimeCount>=this._frameRateValue*.95&&(this._frameTimeCount=0,this.updateFrame(e))):this.updateFrame(e),this.resume()}static updateFrame(e){ue.delta=e-ue.time,ue.time=e,ue.frame+=1,mr.tick(ue.delta);let t=this.views,r=0;for(r=0;r<t.length;r++){const s=t[r];s.scene.waitUpdate(),s.camera.resetPerspective(I.aspect)}this._beforeRender&&this._beforeRender();for(const s of oe.componentsBeforeUpdateList){let n=s[0],l=s[1];for(const h of l){let u=h[0],f=h[1];u.enable&&f(n)}}let i=I.device.createCommandEncoder();for(const s of oe.componentsComputeList){let n=s[0],l=s[1];for(const h of l){let u=h[0],f=h[1];u.enable&&f(n,i)}}I.device.queue.submit([i.finish()]);for(const s of oe.componentsUpdateList){let n=s[0],l=s[1];for(const h of l){let u=h[0],f=h[1];u.enable&&f(n)}}for(const s of oe.graphicComponent){let n=s[0],l=s[1];for(const h of l){let u=h[0],f=h[1];n&&u.enable&&f(n)}}this._renderLoop&&this._renderLoop(),$.updateAllContinueTransform(0,R.useCount,16),ae.modelMatrixBindGroup.writeBuffer(R.useCount*16),this.renderJobs.forEach((s,n)=>{s.renderState||s.start(),s.renderFrame()});for(const s of oe.componentsLateUpdateList){let n=s[0],l=s[1];for(const h of l){let u=h[0],f=h[1];u.enable&&f(n)}}this._lateRender&&this._lateRender()}}let sg=`
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`,wa=`
struct BloomCfg{
  downSampleStep: f32,
  downSampleBlurSize: f32,
  downSampleBlurSigma: f32,
  upSampleBlurSize: f32,
  upSampleBlurSigma: f32,
  luminanceThreshole: f32,
  bloomIntensity: f32,
  slot: f32,
}
@group(0) @binding(0) var<uniform> bloomCfg: BloomCfg;
`,ks=`
  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

`,eu=`
fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32
  {
      let PI = 3.14159265358;
      let E  = 2.71828182846;
      let sigma_2 = pow(sigma, 2);
  
      let a = -(x*x + y*y) / (2.0 * sigma_2);
      return pow(E, a) / (2.0 * PI * sigma_2);
  }
`,Gs=function(o,e,t){var r=`
  
  
  fn ${o}(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32>
  {
      var color = vec3<f32>(0.0);
      let r:i32 = n / 2;
      var weight:f32 = 0.0;
  
      for(var i:i32=-r; i<=r; i+=1)
      {
          for(var j=-r; j<=r; j+=1)
          {
              let w = GaussWeight2D(f32(i), f32(j), sigma);
              var coord:vec2<f32> = uv + vec2<f32>(f32(i), f32(j)) * stride;
              // color += tex2D(tex, coord).rgb * w;
              color += textureSampleLevel(${e}, ${t}, coord, 0.0).xyz * w;
              weight += w;
          }
      }
  
      color /= weight;
      return color;
  }`;return r},tu=`
${wa}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(inTex, fragCoord, 0);
  let lum = dot(vec3<f32>(0.2126, 0.7152, 0.0722), color.rgb);
  
  // if(lum<=bloomCfg.luminanceThreshole) {
  //   color = vec4<f32>(0,0,0,color.w);
  // }
  var ret = color.xyz;
  var brightness = lum;
  var contribution = max(0, brightness - bloomCfg.luminanceThreshole);
  contribution /=max(brightness, 0.00001);
  ret = ret * contribution;

  textureStore(outTex, fragCoord, vec4<f32>(ret, color.w));
}
`,ru=`
${wa}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var inTexSampler: sampler;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${eu}
${Gs("GaussNxN","inTex","inTexSampler")}
${ks}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  let stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));   //  texel size of last level
  let rgb = GaussNxN(uv, i32(bloomCfg.downSampleBlurSize), stride, bloomCfg.downSampleBlurSigma);
  color = vec4<f32>(rgb, color.w);
  textureStore(outTex, fragCoord, color);
}
`,Qs=`
${wa}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _MainTexSampler: sampler;
@group(0) @binding(3) var _PrevMip : texture_2d<f32>;
@group(0) @binding(4) var _PrevMipSampler: sampler;
@group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${eu}
${Gs("GaussNxN_0","_MainTex","_MainTexSampler")}
${Gs("GaussNxN_1","_PrevMip","_PrevMipSampler")}
${ks}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  
  // half stride
  let prev_stride = vec2<f32>(0.5) / vec2<f32>(f32(texSize.x), f32(texSize.y));
  let curr_stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));

  let rgb1 = GaussNxN_1(uv, i32(bloomCfg.upSampleBlurSize), prev_stride, bloomCfg.upSampleBlurSigma);
  let rgb2 = GaussNxN_0(uv, i32(bloomCfg.upSampleBlurSize), curr_stride, bloomCfg.upSampleBlurSigma);
  color = vec4<f32>(rgb1 + rgb2, color.w);
  textureStore(outTex, fragCoord, color);
}
`,iu=`
${wa}
${ks}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _BloomTex : texture_2d<f32>;
@group(0) @binding(3) var _BloomTexSampler :  sampler;
@group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
{
    let A = 2.51;
    let B = 0.03;
    let C = 2.43;
    let D = 0.59;
    let E = 0.14;

    var color2 = color * adapted_lum;
    color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
    return color2;
}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(_MainTex, fragCoord, 0);
  var uv = CalcUV_01(fragCoord, texSize);
  var bloom = textureSampleLevel(_BloomTex, _BloomTexSampler, uv, 0.0).xyz * bloomCfg.bloomIntensity;
  
  // tone map
  bloom = ACESToneMapping(bloom, 1.0);
  let g = 1.0 / 2.2;
  bloom = saturate(pow(bloom, vec3<f32>(g)));
 
  color = vec4<f32>(color.xyz + bloom.xyz, color.w);
  textureStore(outTex, fragCoord, color);
}
`,au=`
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }
 
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;
  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = globalUniform.CameraPos.xyz ;
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`,su=`
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      // textureStore(outTex, fragCoord , vec4<f32>(vec3f(newFactor), oc.w));
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyzw;
                if(samplePosition.w>0.0){
                  let distanceVec2 = samplePosition.xyz - wPosition;
                  let distance = length(distanceVec2);
                  if(distance < gtaoData.maxDistance ){
                    let sampleDir = normalize(distanceVec2);
                    var factor = saturate( dot(sampleDir, originNormal));
                    factor *= 1.0 - distance / gtaoData.maxDistance;
                    weight += factor;
                  }
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `,ou=`

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${At.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `,nu=`
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`,lu=`
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;


   fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
   {
      let u = (f32(coord.x) + 0.5) / f32(texSize.x);
      let v = (f32(coord.y) + 0.5) / f32(texSize.y);
      return vec2<f32>(u, v);
   }

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      let uv01 = CalcUV_01(fragCoord, texSize);
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`,hu=`
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`,uu=`
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`,cu=`

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`,fu=`
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`,og=`
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`,du=`
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = CalcUV_01(fragCoord, colorTexSize);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`,gu=`
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`,pu=`
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`,mu=`
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `,Au=`
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`,vu=`
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`,ng=`
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`,_u=`
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`,xu=`
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,
        @location(auto) vIndex: f32,
        @location(auto) index2: f32,
        
    }

    struct VertexOutput {
        @location(auto) index: f32,
        @location(auto) varying_UV0: vec2<f32>,
        @location(auto) varying_UV1: vec2<f32>,
        @location(auto) varying_ViewPos: vec4<f32>,
        @location(auto) varying_Clip: vec4<f32>,
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_WNormal: vec3<f32>,
        @location(auto) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(auto) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,

        fillRotation:f32,
        empty0:f32,
        empty1:f32,
        empty2:f32,

        baseColor:vec4f,
        lineColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
        uvRect2:vec4f,
        uvSpeed:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`,lg=`
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`,hg=`
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`,ug=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`,Cu=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(auto) position: vec4<f32>,
        @location(auto) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }

    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn FragMain(  
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`,cg=o=>`
    #include "GlobalUniform"
    #include "MatrixShader"

    ${o}

    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:u32,
        skipFace3:u32,
        skipFace4:u32,
    }

    var<private> uv0 = vec2f(0.0, 0.0);
    var<private> uv1 = vec2f(1.0, 0.0);
    var<private> uv2 = vec2f(1.0, 1.0);
    var<private> uv3 = vec2f(0.0, 1.0);

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read_write> drawBuffer : DrawInfo ;
    
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        compute(workgroup_id,local_invocation_id);
    }

    //* gID mesh vertex group id
    //* v1 face vertex 1 position 
    //* v2 face vertex 2 position 
    //* v3 face vertex 3 position 
    //* u1 face uv 1  
    //* u2 face uv 2  
    //* u3 face uv 3  
    fn drawFace(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawLine(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(1.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);  
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawFace2(gID:u32, fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f, uv2:vec2f){
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(gID , fID * 3u + 0u, v1, n, u1, uv2);
        writeVertexBuffer(gID , fID * 3u + 1u, v2, n, u2, uv2);
        writeVertexBuffer(gID , fID * 3u + 2u, v3, n, u3, uv2);
    }

    fn drawRect(gID:u32,center:vec3f,width:f32,height:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,0.0,1.0);
        let p1 = mat * vec4f(maxX,maxY,0.0,1.0);
        let p2 = mat * vec4f(maxX,minY,0.0,1.0);
        let p3 = mat * vec4f(minX,minY,0.0,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
    }

    fn drawCube(gID:u32,center:vec3f,width:f32,height:f32,depth:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;
        let minZ = -depth * 0.5;
        let maxZ = depth * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,minZ,1.0);
        let p1 = mat * vec4f(maxX,maxY,minZ,1.0);
        let p2 = mat * vec4f(maxX,minY,minZ,1.0);
        let p3 = mat * vec4f(minX,minY,minZ,1.0);

        let p4 = mat * vec4f(maxX,maxY,maxZ,1.0);
        let p5 = mat * vec4f(minX,maxY,maxZ,1.0);
        let p6 = mat * vec4f(minX,minY,maxZ,1.0);
        let p7 = mat * vec4f(maxX,minY,maxZ,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p4.xyz,p7.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p7.xyz,p2.xyz,uv0,uv2,uv3);
        drawFace(gID,p4.xyz,p5.xyz,p6.xyz,uv0,uv1,uv2);
        drawFace(gID,p4.xyz,p6.xyz,p7.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p0.xyz,p5.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p5.xyz,p4.xyz,uv0,uv2,uv3);
        drawFace(gID,p0.xyz,p3.xyz,p6.xyz,uv1,uv2,uv3);
        drawFace(gID,p0.xyz,p6.xyz,p5.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p6.xyz,p3.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p7.xyz,p6.xyz,uv1,uv2,uv3);
    }

    //** compute face normal */
    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    //** write vertice data to geometry */
    fn writeVertexBuffer( gID:u32, vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(gID) ;
    }

    fn GetDistance( pos: vec3f,  plane : vec4f ) -> f32 {
        return plane.x * pos.x + plane.y * pos.y + plane.z * pos.z + plane.w;
     }
  
     fn IsOutofFrustum( pos:vec3f , radius: f32) -> bool {
        var c: i32 = 0;
        var d: f32 = 0.0;
        for(var i :i32 = 0; i < 6; i++){
           d = GetDistance(pos, globalUniform.frustumPlanes[i]);
           if (d <= -radius) {
              return false;
           }
           if (d > radius) {
              c++;
           }
       }
       return c > 0;
     }

    `,fg=o=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${o}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                genDir(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                genDir2(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn genDir(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = lc * dc + p1 ;
        // let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;
        // let end_r = lc * dc * 2.0 + p1;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    
    fn genDir2(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * neg;

        let right = cross( normalize(d1) , up );
        let first_l = lc * dc + p1;
        let first_r = right * shapeInfo.width + p1;

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l1 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace( fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `,dg=o=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${o}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }else if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else{
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                let l3 = segi + 2u;
                drawLineBody(l0,l1,l2,l3,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(l0:u32,l1:u32,l2:u32,l3:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 
        let p3 = shapeInfo.paths[l3].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;
        let right1 = cross(d2 , d1) ;

        let dir0 = normalize(d1 - d0) ;
        let dir1 = normalize(d2 - d1) ;

        // let lOr0 = dot(d0 , d3);
        // let lOr1 = dot(d1 , d4);

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(d1,dir1)) ;

        if(angle0<0.0){
            angle0 *= -1.0 ;
        }
        if(angle1<0.0){
            angle1 *= -1.0 ;
        }

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;

        let d1Right = cross(d1,up);
        let d2Right = cross(d2,up);

        newP0 = dir0 * lc0 + p1 ;
        newP1 = -dir0 * lc0 + p1 ;
        newP2 = dir1 * lc1 + p2 ;
        newP3 = -dir1 * lc1 + p2 ;

        newP4 = -d2Right * shapeInfo.width + p2 ;
        newP5 = -lc1 * dir1 + p2 ;

        let uScale = 1.0 ;
        let lVScale = length(newP2 - newP0);
        let rVScale = length(newP3 - newP1);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 4u + 0u,newP0,newP1,newP2,u0,u1,u3);
        // drawFace(l1 * 4u + 1u,newP0,newP2,newP3,u0,u1,u3);

        // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u1,u2,u3);
        // drawFace(l1 * 4u + 3u,newP3,newP4,newP5,u1,u2,u3);
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let nextRight = cross( normalize(d1) , up );
        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
        var next:vec3f;
        var outer:vec3f = p1 - lc * dc;
    
        if(lOr < 0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
            next = -nextRight * shapeInfo.width + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
            next = nextRight * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 4u + 0u,end_l,end_r,next,u0,u1,u3);

        if(lOr < 0.0){
            drawFace(l0 * 4u + 1u,outer,end_l,next,u0,u1,u3);
        }else{
            drawFace(l0 * 4u + 1u,next,end_r,outer,u0,u1,u3);
        }

        drawFace(l0 * 4u + 2u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 4u + 3u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        // drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 4u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 4u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `,gg=o=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${o}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
    
        if(lOr<0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 3u + 0u,end_l,end_r,p1,u0,u1,u3);
        drawFace(l0 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);

        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `,Su=()=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        lineCap:f32,
        
        pathCount:f32,
        uScale:f32,
        vScale:f32,
        lineJoin:f32,

        startPath:f32,
        endPath:f32,
        uSpeed:f32,
        vSpeed:f32,
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:atomic<u32>,
        skipFace3:atomic<u32>,
        skipFace4:atomic<u32>,
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    @group(0) @binding(3) var<storage, read> pathBuffer : array<vec4f>;
    @group(0) @binding(4) var<storage, read_write> drawBuffer : DrawInfo ;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> pathOffset:u32 ;
    var<private> faceOffset:u32 ;
    // var<private> faceStrip:u32 = 1u ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        shape = shapeBuffer[workgroup_id.x];
        pathOffset = u32(shape.startPath) ;
        segCount = u32(shape.pathCount - 1.0);
        segIndex = workgroup_id.y * 256u + local_invocation_id.x ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            switch (u32(shape.shapeType)) {
                case 0u:{
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                case 3u:{
                    drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    break;
                }
                default:
                {
                    break;
                }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount - 1u)){
                drawLineEnd(segi,shapeInfo,up);
            }else if(segi == 0u){
                drawLineStart(segi,shapeInfo,up);
            }else{
                drawLineBody(segi,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = segi + 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p1,d1)) ;
        let len1 = (dot(newP1 - p1,d1)) ;
        let len2 = (dot(newP2 - p1,d1)) ;
        let len3 = (dot(newP3 - p1,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawLineStart(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = 0u;
        let l1 = 0u ;
        let l2 = 1u;
        let l3 = 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p0 = normalize(p1 - p2) * 10.0 + p1 ; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);
        
        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
        }
    }

    fn drawLineEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = 0u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = normalize(p2 - p1) * 10.0 + p2 ; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1 < 0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            // newP2 = dir1 * lc1 + p2 ;
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    // drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = pathBuffer[firstSegi+pathOffset].xyz; 
        let p1 = pathBuffer[endSegi+pathOffset].xyz; 
        // let p2 = pathBuffer[nextSegi+pathOffset].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let u0 = vec2f(0.0,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
        let u1 = vec2f(uScale,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u2 = vec2f(uScale,vScale) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u3 = vec2f(0.0,vScale) * uvScale ;//+ vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;

        drawFace(first_l,first_r,end_l,u0,u1,u3);
        drawFace(first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        var fID = atomicAdd(&drawBuffer.skipFace,1u); 
        writeVertexBuffer(fID * 3u + 0u, v1,n,u1,uv2);
        writeVertexBuffer(fID * 3u + 1u,v2,n,u2,uv2);
        writeVertexBuffer(fID * 3u + 2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    `,yu=o=>`
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        // px:f32,
        // py:f32,
        // pz:f32,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct TrailInfo{
        index : f32 ,
        segment : f32 ,
        visible : f32 ,
        width: f32,

        uv: vec4f,

        uvSpeed: vec2f,
        smoothLine: f32,
        faceMode: f32,
        up: vec4f,
        ids:array<f32,${o}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read> trailBuffer : array<TrailInfo>;
    @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;

    var<private> time:f32;
    var<private> viewDir:vec3f;

    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        let rID = workgroup_id.x ;
        let trailInfo = trailBuffer[rID];
        let vLen = u32(trailInfo.segment+1.0) ;
        let vID = global_invocation_id.x ;

        // if(vID < vLen ){
            time = globalUniform.time * 0.001;
            var right:vec3f ;
            
            switch (u32(trailInfo.faceMode)) {
                case 0u:{
                    right = getRightByMode(vID,vLen,viewDir,trailInfo) ;
                    break;
                }
                case 1u:{
                    right = vec3f(0.0,0.0,1.0) ;
                    break;
                }
                case 2u:{
                    right = getRightByMode(vID,vLen,trailInfo.up.xyz,trailInfo) ;
                    break;
                }
                default:{
                    break;
                }
            }
            writeTOBuffer(rID,vID,vLen,right,trailInfo);
        // }
    }

 

    fn writeTOBuffer(rID:u32, vID:u32 , vLen:u32, right:vec3f , trailInfo:TrailInfo ){
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;

        let worldPos = models[i32(trailInfo.ids[vID])][3].xyz ;
        let leftPos = worldPos - right.xyz * trailInfo.width ;
        let rightPos = worldPos + right.xyz * trailInfo.width ;

        vertexBuffer[li].position = leftPos ;
        vertexBuffer[ri].position = rightPos ;

        let uvS = time * trailInfo.uvSpeed ;

        vertexBuffer[li].uv_x = (trailInfo.uv.x) + uvS.x ;
        vertexBuffer[ri].uv_x = (trailInfo.uv.z + trailInfo.uv.x) + uvS.x ;

        // var ld = 0.0 ;
        // var rd = 0.0 ;
        // if(vID>0u){
        //     let vid0 = getVID(vID,vLen,rID);
        //     let vid1 = getVID(vID-1u,vLen,rID);
        
        //     ld = distance( vertexBuffer[li].position , vertexBuffer[vid1.x].position ) ;
        //     rd = distance( vertexBuffer[ri].position , vertexBuffer[vid1.y].position ) ;

        //     vertexBuffer[li].uv_y = vertexBuffer[vid1.x].uv_y + 1.0 / ld * 100.0 ;//+ uvS.y ;
        //     vertexBuffer[ri].uv_y = vertexBuffer[vid1.y].uv_y + 1.0 / rd * 100.0 ;//+ uvS.y ;
        // }else{
            let v = (1.0 - f32(vID) / trailInfo.segment) * trailInfo.uv.w + trailInfo.uv.y;
            vertexBuffer[li].uv_y = v + uvS.y ;
            vertexBuffer[ri].uv_y = v + uvS.y ;
        // }
    }

    fn getRight(p0:vec3f,p1:vec3f,p2:vec3f,up:vec3f) -> vec3f {
        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        // var a = dot(d0,d1) ;
        // var ep = 0.0 ;
        // if(a<0.0){
        //     a = -a ;
        //     ep = 1.0/sin(a*0.25) ;
        // }else if(a == 0.0){
        //     ep = 1.414 ;
        // }else{
        //     ep = 1.0 ;
        // }
        let forward = normalize((d0 + d1)+ vec3f(0.000001,0.000001,0.000001)) ;
        return normalize(cross(forward,up)) ;//* ep ;
    }

    fn getVID(vID:u32,vLen:u32,rID:u32) -> vec2<u32> {
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;
        return vec2<u32>(li,ri);
    }

    fn getRightByMode( vID:u32 , vLen:u32, up:vec3f, trailInfo:TrailInfo ) -> vec3f{
        var right:vec3f;
        if(vID==0u){
            // first
            let sp0 = models[i32(trailInfo.ids[ 0 ])][3].xyz ;
            let sp1 = models[i32(trailInfo.ids[ 1 ])][3].xyz ;
            let firstFront = normalize(sp1 - sp0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - sp0) ;
            right = normalize(cross(firstFront,viewDir));
        }else if( vID < (vLen-1) ){
            // body
            let bp0 = models[i32(trailInfo.ids[vID-1])][3].xyz ;
            let bp1 = models[i32(trailInfo.ids[vID])][3].xyz ;
            let bp2 = models[i32(trailInfo.ids[vID+1])][3].xyz ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - bp1) ;
            right = getRight(bp0,bp1,bp2,viewDir) ;
        }else{
            // last
            let ep0 = models[i32(trailInfo.ids[u32(trailInfo.segment)-1u])][3].xyz ;
            let ep1 = models[i32(trailInfo.ids[u32(trailInfo.segment)])][3].xyz ;
            let endFront = normalize(ep1 - ep0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - ep1) ;
            right = normalize(cross(endFront,viewDir));
        }
        return normalize(right) ; 
    }
    `,wu=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = 1.0 ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            useShadow();

            BxDFShading();
        }
    `,Iu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `,bu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`,Bu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        useShadow();

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`,Eu=`
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`,pg=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`,Tu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        useShadow();

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity / LUMEN)  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`,mg=`
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `,Ag=`
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `,Du=`
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy;
        //The fragUV1.x is 1.0 when the vertex belongs to line.
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            uv = graphicNode.uvRect2.zw * uv.xy + graphicNode.uvRect2.xy;
            uv += graphicNode.uvSpeed.zw * globalUniform.time;
        }else{
            uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy;
            uv += graphicNode.uvSpeed.xy * globalUniform.time;
            let rad = graphicNode.fillRotation;
            if(rad != 0.0){
                let zrot = mat3x3<f32>(
                    cos(rad),-sin(rad),0.0,
                    sin(rad), cos(rad),0.0,
                    0.0,0.0,1.0
                );
                uv = (zrot * vec3f(uv, 0.0)).xy;
            }
        }
        var graphicTextureID = graphicNode.texIndex;
        var graphicNodeColor = graphicNode.baseColor;
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            graphicTextureID = graphicNode.tex2Index;
            graphicNodeColor = graphicNode.lineColor;
        }
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicTextureID)) ) * materialUniform.baseColor * graphicNodeColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < 0.5){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`,vg=`
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`,Pu=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`,Mu=`
var<private> PI: f32 = 3.14159265359;

struct FragmentOutput {
    @location(auto) o_Target: vec4<f32>
};

${ra}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`;class Ru{static cs=`
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `}class Uu{sunRadius=500;sunRadiance=11;mieG=.76;mieHeight=1200;eyePos=1500;sunX=.71;sunY=.56;sunBrightness=1;displaySun=!0;defaultTextureCubeSize=512;defaultTexture2DSize=1024;skyColor=new P(1,1,1,1)}class Lu extends ya{_internalTexture;_cubeSize;setting;constructor(e){return super(),this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new _g(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class _g extends fe{_computeShader;_uniformBuffer;constructor(e,t){super(e,t,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.initCompute(e,t)}initCompute(e,t){this._uniformBuffer=new ct(16*4),this._uniformBuffer.apply(),this._computeShader=new ie(Ru.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=t/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let t=w.beginCommandEncoder();return w.computeCommand(t,[this._computeShader]),w.endCommandEncoder(t),this}}var xg=Object.defineProperty,Cg=Object.getOwnPropertyDescriptor,Sg=(o,e,t,r)=>{for(var i=r>1?void 0:r?Cg(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&xg(e,t,i),i};c.SkyShader=class extends ke{constructor(){super();let e=new Ae("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.addRenderPass(e),e.setUniformVector3("eyesPos",new d),e.setUniformFloat("exposure",1),e.setUniformFloat("roughness",0);let t=e.shaderState;t.frontFace="cw",t.cullMode=at.back,t.depthWriteEnabled=!1,t.depthCompare=zt.less}},c.SkyShader=Sg([jt],c.SkyShader);class Ou extends We{constructor(){super(),this.shader=new c.SkyShader,this.shader.setUniformVector3("eyesPos",new d),this.shader.setUniformFloat("exposure",1),this.shader.setUniformFloat("roughness",0)}set baseMap(e){this.setTexture("baseMap",e);const t="IS_HDR_SKY";this._shader.getDefaultShaders()[0].defineValue[t]!=e?.isHDRTexture&&this._shader.setDefine(t,!!e?.isHDRTexture)}get baseMap(){return this._shader.getDefaultColorShader().getTexture("baseMap")}set envMap(e){}set shadowMap(e){}get exposure(){return m.setting.sky.skyExposure}set exposure(e){m.setting.sky.skyExposure=e}get roughness(){return this._shader.getDefaultColorShader().uniforms.roughness.value}set roughness(e){let t=this._shader.getDefaultColorShader();"roughness"in t.uniforms&&(t.uniforms.roughness.value=e)}}class Si extends ve{shape_vertices=[];shape_indices=[];radius;widthSegments;heightSegments;phiStart;phiLength;thetaStart;thetaLength;constructor(e,t,r,i,a,s,n){super(),this.radius=e,this.widthSegments=t,this.heightSegments=r,this.phiStart=i,this.phiLength=a,this.thetaStart=s,this.thetaLength=n,this.buildGeometry()}buildGeometry(){var e,t,r=0;let i=this.heightSegments,a=this.widthSegments,s=this.radius;var n=(i+1)*(a+1);let l=new Float32Array(n*3),h=new Float32Array(n*3),u=new Float32Array(n*2),f=new Uint16Array(a*i*2*3),g=0,p=0,A=0;for(t=0;t<=i;++t){var v=Math.PI*t/i,C=-s*Math.cos(v),x=s*Math.sin(v);for(e=0;e<=a;++e){var S=2*Math.PI*e/a,y=x*Math.cos(S),b=x*Math.sin(S),D=1/Math.sqrt(y*y+b*b+C*C);if(l[g++]=y,l[g++]=b,l[g++]=C,h[p++]=y*D,h[p++]=b*D,h[p++]=C*D,u[A++]=e/a,u[A++]=1-t/i,e>0&&t>0){var B=(a+1)*t+e,T=(a+1)*t+e-1,U=(a+1)*(t-1)+e-1,E=(a+1)*(t-1)+e;t==i?(f[r++]=B,f[r++]=U,f[r++]=E):t==1?(f[r++]=B,f[r++]=T,f[r++]=U):(f[r++]=B,f[r++]=T,f[r++]=U,f[r++]=B,f[r++]=U,f[r++]=E)}}}this.setIndices(f),this.setAttribute(M.position,l),this.setAttribute(M.normal,h),this.setAttribute(M.uv,u),this.setAttribute(M.TEXCOORD_1,u),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.bounds=new de(d.ZERO,new d(this.radius*2,this.radius*2,this.radius*2))}}class Ia extends c.MeshRenderer{skyMaterial;init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(Be.Sky),this.alwaysRender=!0,this.object3D.bound=new de(d.ZERO.clone(),d.MAX),this.geometry=new Si(m.setting.sky.defaultFar,20,20),this.skyMaterial||=new Ou}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(k.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,k.instance.sky=null),super.onDisable()}renderPass2(e,t,r,i,a,s=!1){super.renderPass2(e,t,r,i,a,s)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}}class yg{rotateX;rotateY;sunX;sunY;constructor(){this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(e,t){return Math.abs(this.rotateX-e)>=.001||Math.abs(this.rotateY-t)>=.001}isSkyChange(e,t){return Math.abs(this.sunX-e)>=.001||Math.abs(this.sunY-t)>=.001}save(e,t,r,i){return this.sunX=e,this.sunY=t,this.rotateX=r,this.rotateY=i,this}}class wg extends Ia{_atmosphericScatteringSky;_onChange=!0;_relatedTransform;_historyData;get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new yg,this._atmosphericScatteringSky=new Lu(new Uu);let e=this.transform.view3D,t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let t=this.transform.scene3D;this.map=this._atmosphericScatteringSky,t.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class Mr{static panelRatio=1;static quadMaxCountForWorld=256;static quadMaxCountForView=2048;static SortOrderStartWorld=7e3;static SortOrderStartView=8e3;static SortOrderCanvasSpan=1e4}var St=(o=>(o[o.View=0]="View",o[o.World=2]="World",o))(St||{}),Kr=(o=>(o[o.Simple=0]="Simple",o[o.Sliced=1]="Sliced",o[o.Tiled=2]="Tiled",o[o.Filled=3]="Filled",o))(Kr||{}),vr=(o=>(o[o.None=0]="None",o[o.BillboardY=9]="BillboardY",o[o.BillboardXYZ=10]="BillboardXYZ",o))(vr||{});class yi extends _e{type;camera;_cameraPosition;constructor(){super(),this._cameraPosition=new d}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==vr.BillboardXYZ||this.type==vr.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let t=e.addComponent(yi);t.type=this.type}}var Jr=(o=>(o[o.None=0]="None",o[o.Box=1]="Box",o[o.Capsule=2]="Capsule",o[o.Sphere=3]="Sphere",o[o.Mesh=4]="Mesh",o))(Jr||{});class Me{_center;_size;_halfSize;_shapeType=0;static v3_help_0;static helpMatrix;static helpRay;constructor(){Me.v3_help_0||=new d,Me.helpMatrix||=new R,Me.helpRay||=new _t,this._center=new d,this._size=new d,this._halfSize=new d}get shapeType(){return this._shapeType}setFromCenterAndSize(e,t){return e&&this._center.copy(e),t&&this._size.copy(t),this}get center(){return this._center}set center(e){this._center.copy(e)}get size(){return this._size}set size(e){this._size.copy(e),this._halfSize.copy(e).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(e,t){return null}}class Fu extends Me{_pickRet;box;constructor(){super(),this._shapeType=Jr.Box,this.box=new de(new d,new d)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.size);let i=Me.helpMatrix;i.copyFrom(t).invert();let a=Me.helpRay.copy(e);a.applyMatrix(i);let s=a.intersectBox(this.box,Me.v3_help_0);return s?(this._pickRet||(this._pickRet={intersectPoint:new d,distance:0}),this._pickRet.intersectPoint=s,this._pickRet.distance=d.distance(a.origin,Me.v3_help_0),this._pickRet):null}}class Ig extends _e{_shape;constructor(){super(),this._shape=new Fu}start(){m.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index,this)}onEnable(e){oe.bindEnablePick(e,this,null)}onDisable(e){oe.unBindEnablePick(e,this)}get shape(){return this._shape}set shape(e){this._shape=e}rayPick(e){return this._enable?this._shape.rayPick(e,this.transform.worldMatrix):null}beforeDestroy(e){m.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index),super.beforeDestroy(e)}}var bg=Object.defineProperty,Bg=Object.getOwnPropertyDescriptor,Eg=(o,e,t,r)=>{for(var i=r>1?void 0:r?Bg(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&bg(e,t,i),i};c.AnimatorComponent=class extends _e{jointMatrixIndexTableBuffer;playBlendShapeLoop=!1;inverseBindMatrices;_avatar;_rendererList;propertyCache;_clips;_clipsMap;_currentSkeletonClip;_currentBlendAnimClip;_skeletonTime=0;_blendShapeTime=0;_skeletonSpeed=1;_blendShapeSpeed=1;_skeletonStart=!0;_blendShapeStart=!0;root;_avatarName;init(e){this.propertyCache=new Map,this._clipsMap=new Map,this._clips=[]}start(){this._rendererList=this.object3D.getComponentsInChild(c.SkinnedMeshRenderer2)}debug(){}playAnim(e,t=0,r=1){this._clipsMap.has(e)?(this._currentSkeletonClip=this._clipsMap.get(e),this._skeletonTime=t,this._skeletonSpeed=r,this._skeletonStart=!0):console.warn(`not has anim ${e}`)}playBlendShape(e,t=0,r=1){this._clipsMap.has(e)?(this._currentBlendAnimClip=this._clipsMap.get(e),this._blendShapeTime=t,this._blendShapeSpeed=r,this._blendShapeStart=!0):console.warn(`not has blendShape ${e}`)}set avatar(e){this._avatarName=e,this.inverseBindMatrices=[],this._avatar=m.res.getObj(e);let t=this.buildSkeletonPose();const r=new Float32Array(t);this.jointMatrixIndexTableBuffer=new Z(this._avatar.count,0,r)}getJointIndexTable(e){let t=new Array;for(let r=0;r<e.length;r++){let i=this._avatar.boneMap.get(e[r]);t[r]=i?i.boneID:-1}return t}skeltonPoseObject3D={};skeltonTPoseObject3D={};buildSkeletonPose(){let e=[];for(const t of this._avatar.boneData){let r=new c.Object3D;R.getEuler(d.HELP_6,t.q,!0,"ZYX"),r.localPosition=t.t.clone(),r.localRotation=d.HELP_6.clone(),r.localScale=d.ONE,t.s.clone(),this.skeltonPoseObject3D[t.boneName]=r,this.skeltonTPoseObject3D[t.bonePath]=r.clone(),t.parentBoneName&&t.parentBoneName!=""?this.skeltonPoseObject3D[t.parentBoneName].addChild(r):(this.object3D.transform.scene3D&&this.object3D.transform.scene3D.addChild(r),this.root=r),e.push(r.transform.worldMatrix.index);let i=new R;i.copyFrom(r.transform.worldMatrix),i.invert(),this.inverseBindMatrices.push(i.rawData)}return e}set clips(e){this._clips=e;for(const t of e)this._clipsMap.set(t.clipName,t)}get clips(){return this._clips}cloneTo(e){let t=e.addComponent(c.AnimatorComponent);t.avatar=this._avatarName,t.clips=this._clips}updateTime(){this._skeletonStart&&(this._skeletonTime+=ue.delta*.001*this._skeletonSpeed,this._currentSkeletonClip&&this._currentSkeletonClip.loopTime&&(this._skeletonTime=this._skeletonTime%this._currentSkeletonClip.stopTime)),this._blendShapeStart&&(this._blendShapeTime+=ue.delta*.001*this._blendShapeSpeed,this._currentBlendAnimClip&&(this._currentBlendAnimClip.loopTime&&this.playBlendShapeLoop?this._blendShapeTime=this._blendShapeTime%this._currentBlendAnimClip.stopTime:this._blendShapeTime=Math.min(this._blendShapeTime,this._currentBlendAnimClip.stopTime)-1e-4))}onUpdate(e){this.transform.worldMatrix,this.updateTime(),this.updateSkeletonAnim(),this.updateMorphAnim()}updateSkeletonAnim(){if(this._currentSkeletonClip){let e=this._avatar.boneData,t=0,r=e.length;for(t=0;t<r;t++){const i=e[t];let a=this.skeltonPoseObject3D[i.boneName];if(this._currentSkeletonClip.useSkeletonPos){let n=this.getPosition(i.bonePath,this._skeletonTime);a.transform.localPosition=n}let s=this.getRotation(i.bonePath,this._skeletonTime);if(a.transform.localRotation=s,this._currentSkeletonClip.useSkeletonScale){let n=this.getScale(i.bonePath,this._skeletonTime);a.transform.localScale=n}}}}updateMorphAnim(){if(this._currentBlendAnimClip&&this._currentBlendAnimClip.floatCurves&&this._currentBlendAnimClip.floatCurves.size>0&&this._rendererList)for(const e of this._currentBlendAnimClip.floatCurves){let t=e[0],i=e[1].propertys,s=this._currentBlendAnimClip.floatCurves.get(t).getValue(this._blendShapeTime)/100;for(const n of this._rendererList)if(n.blendShape){let l=this.propertyCache.get(n);if(l&&t in l)l[t](s);else{l=n;for(const h of i){if(!l[h])break;l=l[h]}if(!l||l==n)break;this.propertyCache.get(n)||this.propertyCache.set(n,{}),this.propertyCache.get(n)[t]=l,l(s)}}}}updateBlendShape(e,t,r){for(const i of this._rendererList)if(i.blendShape){let a=this.propertyCache.get(i);if(a&&t in a)a[t](r);else{a=i;for(const s of e){if(!a[s])break;a=a[s]}if(!a||a==i)break;this.propertyCache.get(i)||this.propertyCache.set(i,{}),this.propertyCache.get(i)[t]=a,a(r)}}}getPosition(e,t){return this._currentSkeletonClip.positionCurves.has(e)?this._currentSkeletonClip.positionCurves.get(e).getValue(t):this.skeltonTPoseObject3D[e].localPosition}getRotation(e,t){if(this._currentSkeletonClip.rotationCurves.has(e)){let r=this._currentSkeletonClip.rotationCurves.get(e).getValue(t);return Y.HELP_2.set(r.x,r.y,r.z,r.w),R.getEuler(d.HELP_6,Y.HELP_2,!0,"ZYX"),d.HELP_6}return this.skeltonTPoseObject3D[e].localRotation}getScale(e,t){return this._currentSkeletonClip.scaleCurves.has(e)?this._currentSkeletonClip.scaleCurves.get(e).getValue(t):this.skeltonTPoseObject3D[e].localScale}getFloat(e,t){return this._currentSkeletonClip.floatCurves.get(e).getValue(t)}},c.AnimatorComponent=Eg([mt(c.AnimatorComponent,"AnimatorComponent")],c.AnimatorComponent);class Vs{index;time;timeEnd;coeff=[]}var _r=(o=>(o[o.PingPong=0]="PingPong",o[o.Repeat=1]="Repeat",o[o.Clamp=2]="Clamp",o))(_r||{});class ba{serializedVersion="2";time;value;inSlope=0;outSlope=0;tangentMode=0;weightedMode=0;inWeight;outWeight;constructor(e=0,t=0){this.time=e,this.value=t}unSerialized(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inSlope=="Infinity"?NaN:e.inSlope,this.outSlope=e.outSlope=="Infinity"?NaN:e.outSlope}unSerialized2(e){this.serializedVersion=e.serializedVersion,this.time=e.time,this.value=e.value,this.tangentMode=e.tangentMode,this.inSlope=e.inTangent=="Infinity"?NaN:e.inTangent,this.outSlope=e.outTangent=="Infinity"?NaN:e.outTangent}}class wi{_totalTime=1;_cache=new Vs;_cacheOut={lhsIndex:0,rhsIndex:0};_InvalidateCache=!1;curve=[];serializedVersion;preWarpMode;postWarpMode;rotationOrder;constructor(e,t=_r.Repeat,r=_r.Repeat){if(e)for(let i=0;i<e.length;i++){const a=e[i];this.addKeyFrame(a)}this.preWarpMode=t,this.postWarpMode=r}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(e){this.curve.indexOf(e)==-1&&this.curve.push(e),this.calcTotalTime()}removeKeyFrame(e){let t=this.curve.indexOf(e);t!=-1&&this.curve.splice(t,1),this.calcTotalTime()}calculateCacheData(e,t,r,i=0){let a=this.curve,s=a[t],n=a[r];e.index=t,e.time=s.time+i,e.timeEnd=n.time+i,e.index=t;let l,h,u,f,g,p,A;l=n.time-s.time,l=Math.max(l,1e-4),u=n.value-s.value,h=1/(l*l),f=s.outSlope,g=n.inSlope,p=f*l,A=g*l,e.coeff[0]=(p+A-u-u)*h/l,e.coeff[1]=(u+u+u-p-p-A)*h,e.coeff[2]=f,e.coeff[3]=s.value,this.setupStepped(e.coeff,s,n)}getValue(e){return e=this.wrapTime(e),this.findCurve(e,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,e)}getKeyCount(){return this.curve.length}getKey(e){return this.curve[e]}unSerialized(e){this.preWarpMode=e.m_PreInfinity,this.postWarpMode=e.m_PostInfinity,this.rotationOrder=e.m_RotationOrder;let t=e.m_Curve.length;for(let r=0;r<t;r++)this.curve[r]=new ba,this.curve[r].unSerialized(e.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(e){this.preWarpMode=e.preWrapMode,this.postWarpMode=e.postWrapMode;let t=e.keyFrames||e.keys,r=t.length;for(let i=0;i<r;i++)this.curve[i]=new ba,this.curve[i].unSerialized2(t[i.toString()]);return this.calcTotalTime(),this}wrapTime(e){let t=this.curve,r=t[0].time,i=t[t.length-1].time;return e<r?this.preWarpMode==_r.Clamp?e=r:this.preWarpMode==_r.PingPong?e=Za(e,r,i):e=$a(e,r,i):e>i&&(this.postWarpMode==_r.Clamp?e=i:this.postWarpMode==_r.PingPong?e=Za(e,r,i):e=$a(e,r,i)),e}evaluateCache(e,t){let r=t-e.time;return r*(r*(r*e.coeff[0]+e.coeff[1])+e.coeff[2])+e.coeff[3]}findCurve(e,t){let r=this.curve;for(let i=1;i<r.length;i++){let a=r[i-1],s=r[i];a.time<=e&&s.time>e&&(t.lhsIndex=i-1,t.rhsIndex=i)}}setupStepped(e,t,r){(isNaN(t.outSlope)||isNaN(r.inSlope))&&(e[0]=0,e[1]=0,e[2]=0,e[3]=t.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let e=0;for(let t of this.curve)t?e=Math.max(e,t.time):console.error(t);this._totalTime=e}static scaleCurveValue(e,t){if(!e._InvalidateCache)for(let r=0;r<e.curve.length;r++){let i=e.curve[r];i.value*=t,i.inSlope*=t,i.outSlope*=t}e.invalidateCache()}}class Nu extends wi{attribute="";propertyList;path;constructor(){super()}unSerialized(e){let{attribute:t,path:r}=e;return this.attribute=t,this.path=r,this.propertyList=t.split("."),super.unSerialized(e.curve),this}}class zu{curve={}}var Zr=(o=>(o[o.Default=0]="Default",o[o.Clamp=1]="Clamp",o[o.Once=1]="Once",o[o.Loop=2]="Loop",o[o.PingPong=4]="PingPong",o[o.ClampForever=8]="ClampForever",o))(Zr||{});class Tg{name;objAnimClip;totalTime=0;time=0;_stopTime=0;_loopTime;_wrapMode;_sampleRate;get wrapMode(){return this._wrapMode||(this._wrapMode=0),this._wrapMode}set wrapMode(e){this._wrapMode=e}parse(e){this.objAnimClip={};let t=e.AnimationClip,{m_Name:r,m_AnimationClipSettings:i,m_WrapMode:a,m_SampleRate:s}=t;this.name=r,this._wrapMode=a,this._sampleRate=s,this._loopTime=i.m_LoopTime;for(const n in t.m_EditorCurves)if(Object.prototype.hasOwnProperty.call(t.m_EditorCurves,n)){const l=t.m_EditorCurves[n];let h=l.attribute,u=new Nu;u.unSerialized(l),this.totalTime=Math.max(this.totalTime,u.totalTime);let f=this.objAnimClip[l.path];f||(f=new zu,this.objAnimClip[l.path]=f),f.curve[h]=u}}}class ku{transform;quaternion;materialColor}class Ii{static Property={"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"};static Scale={"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1};static updatePropertyTag(e,t){e.quaternion||=this.tag_quaternion[t],e.transform||=this.tag_transform[t],e.materialColor||=this.tag_materialColor[t]}static tag_quaternion={"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0};static tag_materialColor={"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0};static tag_transform={"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0}}class Rr{static Complete=0;static Seek=1;_rootObject3D;_animation;_propertyCache;_currentClip;_frame=0;_time=0;_isPlaying=!0;speed=1;_propertyTagDic;constructor(e){this._rootObject3D=e.object3D,this._animation=e,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(e,t=!0){this._isPlaying=!0,t&&(this._time=0),e!=this._currentClip&&e&&this.parseAnimClip(e),this._currentClip=e,this.validProperty()}parseAnimClip(e){this.reset();for(const t in e.objAnimClip){let r=e.objAnimClip[t],i=this._rootObject3D,a={};if(t==""?i=this._rootObject3D:i=this._rootObject3D.getObjectByName(t),!i)continue;let s=new ku;this._propertyTagDic.set(i,s);let n=r.curve;for(const l in n){Ii.updatePropertyTag(s,l);let h=this._propertyCache[t]||={},u=Ii.Property[l].split("."),f=u[0];if(u.length>1){let g=a[f];g||(g=a[f]=i[f]),h[l]={value:g,property:u[1]}}else h[l]={value:i,property:u[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(e,t){if(e=e*.001,t=t*.001,!this._currentClip||this._frame==e||!this._isPlaying)return;this._frame=e;let r=this._time;this._time=this.calcTime(r+t*this.speed),this.validProperty(),this._currentClip.wrapMode!=Zr.Loop&&this._currentClip.wrapMode!=Zr.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall(Rr.Complete,r,this._time)),this._animation.statusCall(Rr.Seek,r,this._time)}seek(e){return this._time=this.calcTime(e),this._rootObject3D&&this.validProperty(),this}calcTime(e){return this._currentClip.wrapMode==Zr.Loop||this._currentClip.wrapMode==Zr.Default?e=as(e,this._currentClip.totalTime):e=j(e,0,this._currentClip.totalTime),e}validProperty(){for(const e in this._currentClip.objAnimClip){let r=this._currentClip.objAnimClip[e].curve;for(const i in r){const a=r[i];let s=this._propertyCache[e][i],n=a.getValue(this._time);i in Ii.Scale&&(n*=Ii.Scale[i]),s.value[s.property]=n}}this._propertyTagDic.forEach((e,t)=>{this.applyProperty(e,t)})}applyProperty(e,t){e.quaternion&&R.getEuler(t.transform.localRotation,t.transform.localRotQuat,!0,"ZYX"),e.transform&&(t.transform.localPosition=t.transform.localPosition,t.transform.localRotation=t.transform.localRotation,t.transform.localScale=t.transform.localScale);let r=t;e.materialColor&&r.notifyMaterialColorChange(0,"baseColor")}}class Dg{clipName;data;time}class bi extends Ne{static SEEK="SEEK";static COMPLETE="COMPLETE";animation;frame;constructor(e,t){super(t),this.animation=e}}class Hs extends _e{_animator;_clips=[];defaultClip;autoPlay;_seekEvent;_completeEvent;_keyFrameList;constructor(){super(),this._seekEvent=new bi(this,bi.SEEK),this._completeEvent=new bi(this,bi.COMPLETE),this._keyFrameList={}}registerEventKeyFrame(e){let t=this._keyFrameList[e.clipName];t==null&&(this._keyFrameList[e.clipName]=t=[]),t.push(e)}init(){this._animator=new Rr(this)}onUpdate(){this.enable&&this._animator.update(ue.time,ue.delta)}appendClip(e){this._clips.push(e),this.play(e.name)}statusCall(e,t,r){if(e==Rr.Complete)this.eventDispatcher.dispatchEvent(this._completeEvent);else if(e==Rr.Seek&&t!=r){let i=this._keyFrameList[this.currentClip.name];if(i)for(let a of i)a.time>t&&a.time<=r&&(this._seekEvent.data=this._seekEvent.frame=a,this.eventDispatcher.dispatchEvent(this._seekEvent))}}set speed(e){this._animator.speed=e}get speed(){return this._animator.speed}stop(){this._animator.stop()}toggle(){this._animator.toggle()}getClip(e){let t;for(let r of this._clips)if(r.name==e){t=r;break}return t}get currentClip(){return this._animator.currentClip}get time(){return this._animator.time}seek(e){this._animator.seek(e)}play(e,t=!0){let r=this.getClip(e);return r?(this._animator.play(r,t),r):null}start(){this.autoPlay&&this.play(this.defaultClip)}copyComponent(e){this.autoPlay=e.autoPlay,this.defaultClip=e.defaultClip;let t=e._clips;for(let r=0,i=t.length;r<i;r++)this.appendClip(t[r]);return this}cloneTo(e){e.addComponent(Hs).copyComponent(this)}}var Pg=Object.defineProperty,Mg=Object.getOwnPropertyDescriptor,Rg=(o,e,t,r)=>{for(var i=r>1?void 0:r?Mg(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Pg(e,t,i),i};c.SkinnedMeshRenderer2=class extends c.MeshRenderer{skinJointsName;mInverseBindMatrixData;mInverseBindMatrixBuffer;mSkeletonAnimation;mJointIndexTableBuffer;constructor(){super(),this.addRendererMask(Be.SkinnedMesh)}get geometry(){return this._geometry}set geometry(e){this.skinJointsName=e.skinNames;let t=[];for(let r=0;r<e.bindPose.length;r++)t.push(e.bindPose[r].rawData.slice(0,16));this.skinInverseBindMatrices=t,super.geometry=e}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(c.AnimatorComponent),!this.skeletonAnimation){let e=this.object3D.parentObject.parentObject.getComponentsInChild(c.AnimatorComponent);e.length>0&&(this.skeletonAnimation=e[0]);let t=this.object3D;for(;!this.skeletonAnimation&&t;)this.skeletonAnimation=t.getComponentFromParent(c.AnimatorComponent),t.parent&&(t=t.parent.object3D)}}get blendShape(){return this.morphData}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(e){if(this.mSkeletonAnimation=e,!!e&&!this.mJointIndexTableBuffer){let t=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new Z(t.length,0,new Float32Array(t)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(e){this.mInverseBindMatrixData=e;var t=new Float32Array(e.length*16);for(let r=0;r<e.length;r++){let i=r*16,a=e[r];t.set(a,i)}this.mInverseBindMatrixBuffer=new Z(t.byteLength,0,t),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(e){let t=e.addComponent(c.SkinnedMeshRenderer2),r=[];for(const i of this.materials)r.push(i.clone());t.materials=r,t.geometry=this.geometry,t.castShadow=this.castShadow,t.castGI=this.castGI,t.receiveShadow=this.receiveShadow,t.rendererMask=this.rendererMask,t.skinJointsName=this.skinJointsName,t.skinInverseBindMatrices=this.skinInverseBindMatrices,t.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(e,t,r,i){for(let a=0;a<this.materials.length;a++){let n=this.materials[a].getPass(t);if(n)for(let l=0;l<n.length;l++){const h=n[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(e,t,r,i)}},c.SkinnedMeshRenderer2=Rg([mt(c.SkinnedMeshRenderer2,"SkinnedMeshRenderer2")],c.SkinnedMeshRenderer2);class Ug extends _e{_targetRenderers={};_vec3=new d;_matrix4=new R;_quaternion=new Y;init(e){let t=this.fetchMorphRenderers(this.object3D,c.SkinnedMeshRenderer2),r=this.fetchMorphRenderers(this.object3D,c.MeshRenderer);t.push(...r);for(const i of t){bt.hasMask(i.rendererMask,Be.MorphTarget)&&i.selfCloneMaterials("MORPH_TARGET_UUID");for(const s in i.geometry.morphTargetDictionary){let n=this._targetRenderers[s]||[];n.push(i),this._targetRenderers[s]=n}}}getMorphRenderersByKey(e){return this._targetRenderers[e]}cloneMorphRenderers(){let e={};for(let t in this._targetRenderers)e[t]=this._targetRenderers[t];return e}applyBlendShape(e,t,r=1){if(!e){console.warn("blendShape is null");return}this._vec3.setFromArray(e.transform.transform[3]),this._vec3.multiplyScalar(r),this.object3D.transform.localPosition=this._vec3,this._vec3.setFromArray(e.transform.transform[2]),this._matrix4.copyColFrom(2,this._vec3),this._vec3.setFromArray(e.transform.transform[1]),this._matrix4.copyColFrom(1,this._vec3),this._vec3.setFromArray(e.transform.transform[0]),this._matrix4.copyColFrom(0,this._vec3),this._matrix4.transpose(),this._quaternion.fromMatrix(this._matrix4),this.object3D.localQuaternion=this._quaternion;for(let i in t){let a=this._targetRenderers[i],s=t[i],n=e.texture[s];this.applyMorphTargetInfluence(i,n,a)}}applyMorphTargetInfluence(e,t,r){for(let i of r)i.setMorphInfluence(e,t)}fetchMorphRenderers(e,t){let r=e.getComponentsInChild(t),i=[];for(let a of r)a.hasMask(Be.MorphTarget)&&i.push(a);return i}}class Lg{texture;transform}var Gu=(o=>(o.mouthRollLower="mouthRollLower",o.browOuterUp_L="browOuterUpLeft",o.mouthSmile_L="mouthSmileLeft",o.jawRight="jawRight",o.eyeLookOut_L="eyeLookOutLeft",o.mouthFunnel="mouthFunnel",o.mouthUpperUp_R="mouthUpperUpRight",o.browDown_L="browDownLeft",o.jawLeft="jawLeft",o.mouthLowerDown_L="mouthLowerDownLeft",o.noseSneer_R="noseSneerRight",o.jawForward="jawForward",o.mouthLowerDown_R="mouthLowerDownRight",o.browInnerUp="browInnerUp",o.mouthRollUpper="mouthRollUpper",o.mouthStretch_R="mouthStretchRight",o.mouthPucker="mouthPucker",o.eyeBlink_L="eyeBlinkLeft",o.mouthUpperUp_L="mouthUpperUpLeft",o.mouthShrugUpper="mouthShrugUpper",o.eyeLookIn_R="eyeLookInRight",o.noseSneer_L="noseSneerLeft",o.mouthFrown_L="mouthFrownLeft",o.cheekSquint_L="cheekSquintLeft",o.eyeLookDown_L="eyeLookDownLeft",o.mouthDimple_L="mouthDimpleLeft",o.mouthFrown_R="mouthFrownRight",o.eyeLookIn_L="eyeLookInLeft",o.eyeLookOut_R="eyeLookOutRight",o.mouthLeft="mouthLeft",o.mouthStretch_L="mouthStretchLeft",o.mouthPress_L="mouthPressLeft",o.mouthDimple_R="mouthDimpleRight",o.eyeWide_R="eyeWideRight",o.browDown_R="browDownRight",o.eyeLookUp_R="eyeLookUpRight",o.eyeBlink_R="eyeBlinkRight",o.cheekSquint_R="cheekSquintRight",o.mouthRight="mouthDimpleRight",o.eyeLookDown_R="eyeLookDownRight",o.eyeLookUp_L="eyeLookUpLeft",o.eyeSquint_L="eyeSquintLeft",o.jawOpen="jawOpen",o.browOuterUp_R="browOuterUpRight",o.mouthClose="mouthClose",o.mouthShrugLower="mouthShrugLower",o.eyeWide_L="eyeWideLeft",o.tongueOut="tongueOut",o.eyeSquint_R="eyeSquintRight",o.cheekPuff="cheekPuff",o.mouthPress_R="mouthPressRight",o.mouthSmile_R="mouthSmileRight",o))(Gu||{});class Og{_computePipeline;_computeBindGroup;constructor(e,t){let r=I.device;this._computePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:e}),entryPoint:"CsMain"}}),this._computeBindGroup=r.createBindGroup({layout:this._computePipeline.getBindGroupLayout(0),entries:t})}compute(e,t,r,i){let a=e.beginComputePass();return a.setPipeline(this._computePipeline),a.setBindGroup(0,this._computeBindGroup),a.dispatchWorkgroups(t,r,i),a.end(),this}}class Fg extends ur{numJoint;numState;time;weight;argumentsData;_isDirty=!1;_argumentsBuffer;_argumentsBufferEntries;constructor(){super(),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numState",data:[0]},{name:"retain1",data:[0]},{name:"retain2",data:[0]},{name:"time",data:[0,0]},{name:"weight",data:[0,0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){return this._isDirty&&(this._isDirty=!1,I.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer)),this}allocationMemorySet(e){this.argumentsData={};let t=0;for(let i=0;i<e.length;i++){const a=e[i];t+=a.data.length}this.allocation(t*4);let r=this;for(let i=0;i<e.length;i++){const a=e[i],s=a.name;this.argumentsData[s]=this.allocation_node(a.data.length*4),r[s]=this.argumentsData[s]}}generateGPUBuffer(){let e=I.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}class Ng extends ur{numJoint;numFrame;retain0;retain1;argumentsData;_isDirty=!1;_argumentsBuffer;_argumentsBufferEntries;constructor(){super(),this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numFrame",data:[0]},{name:"retain0",data:[0]},{name:"retain1",data:[0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){this._isDirty&&(this._isDirty=!1,I.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer))}allocationMemorySet(e){this.argumentsData={};let t=0;for(let i=0;i<e.length;i++){const a=e[i];t+=a.data.length}this.allocation(t*4);let r=this;for(let i=0;i<e.length;i++){const a=e[i],s=a.name;this.argumentsData[s]=this.allocation_node(a.data.length*4),r[s]=this.argumentsData[s]}}generateGPUBuffer(){let e=I.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}let zg=`
  ${ta}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`,kg=`
  ${ta}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`;class Gg{_autoUpdate=!0;_target;_lookAtObject;_origin=new d(0,0,0);_speed=300;constructor(e=null,t=null){this._target=e,this._lookAtObject=t}get target(){return this._target}set target(e){this._target!=e&&(this._target=e)}get lookAtObject(){return this._lookAtObject}set lookAtObject(e){this._lookAtObject!=e&&(this._lookAtObject=e)}get speed(){return this._speed}set speed(e){this._speed=e}update(){}}class Qg extends _e{focus;distance=5;_camera;constructor(){super()}start(){if(this._camera=this.object3D.getOrAddComponent(Vr),!this._camera){console.error("FirstPersonCameraController need camera");return}if(!this.focus){console.error("FirstPersonCameraController need target");return}m.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){m.inputSystem.addEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){m.inputSystem.removeEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){let t=this.transform.localRotation;t.y+=e.movementX*.01,t.x+=e.movementY*.01,this.transform.localRotation=t}mouseWheel(e){this.distance+=m.inputSystem.wheelDelta*.1}onUpdate(){let e=new d;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t}destroy(e){m.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Ge=(o=>(o[o.Key_BackSpace=8]="Key_BackSpace",o[o.Key_Tab=9]="Key_Tab",o[o.Key_Clear=12]="Key_Clear",o[o.Key_Enter=13]="Key_Enter",o[o.Key_Shift_L=16]="Key_Shift_L",o[o.Key_Control_L=17]="Key_Control_L",o[o.Key_Alt_L=18]="Key_Alt_L",o[o.Key_Pause=19]="Key_Pause",o[o.Key_CapsLock=20]="Key_CapsLock",o[o.Key_Escape=21]="Key_Escape",o[o.Key_Esc=27]="Key_Esc",o[o.Key_Space=32]="Key_Space",o[o.Key_Prior=33]="Key_Prior",o[o.Key_Next=34]="Key_Next",o[o.Key_End=35]="Key_End",o[o.Key_Home=36]="Key_Home",o[o.Key_Left=37]="Key_Left",o[o.Key_Up=38]="Key_Up",o[o.Key_Right=39]="Key_Right",o[o.Key_Down=40]="Key_Down",o[o.Key_Select=41]="Key_Select",o[o.Key_Print=42]="Key_Print",o[o.Key_Execute=43]="Key_Execute",o[o.Key_Insert=45]="Key_Insert",o[o.Key_Delete=46]="Key_Delete",o[o.Key_Help=47]="Key_Help",o[o.Key_0=48]="Key_0",o[o.Key_1=49]="Key_1",o[o.Key_2=50]="Key_2",o[o.Key_3=51]="Key_3",o[o.Key_4=52]="Key_4",o[o.Key_5=53]="Key_5",o[o.Key_6=54]="Key_6",o[o.Key_7=55]="Key_7",o[o.Key_8=56]="Key_8",o[o.Key_9=57]="Key_9",o[o.Key_A=65]="Key_A",o[o.Key_B=66]="Key_B",o[o.Key_C=67]="Key_C",o[o.Key_D=68]="Key_D",o[o.Key_E=69]="Key_E",o[o.Key_F=70]="Key_F",o[o.Key_G=71]="Key_G",o[o.Key_H=72]="Key_H",o[o.Key_I=73]="Key_I",o[o.Key_J=74]="Key_J",o[o.Key_K=75]="Key_K",o[o.Key_L=76]="Key_L",o[o.Key_M=77]="Key_M",o[o.Key_N=78]="Key_N",o[o.Key_O=79]="Key_O",o[o.Key_P=80]="Key_P",o[o.Key_Q=81]="Key_Q",o[o.Key_R=82]="Key_R",o[o.Key_S=83]="Key_S",o[o.Key_T=84]="Key_T",o[o.Key_U=85]="Key_U",o[o.Key_V=86]="Key_V",o[o.Key_W=87]="Key_W",o[o.Key_X=88]="Key_X",o[o.Key_Y=89]="Key_Y",o[o.Key_Z=90]="Key_Z",o[o.Key_KP_0=96]="Key_KP_0",o[o.Key_KP_1=97]="Key_KP_1",o[o.Key_KP_2=98]="Key_KP_2",o[o.Key_KP_3=99]="Key_KP_3",o[o.Key_KP_4=100]="Key_KP_4",o[o.Key_KP_5=101]="Key_KP_5",o[o.Key_KP_6=102]="Key_KP_6",o[o.Key_KP_7=103]="Key_KP_7",o[o.Key_KP_8=104]="Key_KP_8",o[o.Key_KP_9=105]="Key_KP_9",o[o.Key_Multiply=106]="Key_Multiply",o[o.Key_Add=107]="Key_Add",o[o.Key_Separator=108]="Key_Separator",o[o.Key_Subtract=109]="Key_Subtract",o[o.Key_Decimal=110]="Key_Decimal",o[o.Key_Divide=111]="Key_Divide",o[o.Key_F1=112]="Key_F1",o[o.Key_F2=113]="Key_F2",o[o.Key_F3=114]="Key_F3",o[o.Key_F4=115]="Key_F4",o[o.Key_F5=116]="Key_F5",o[o.Key_F6=117]="Key_F6",o[o.Key_F7=118]="Key_F7",o[o.Key_F8=119]="Key_F8",o[o.Key_F9=120]="Key_F9",o[o.Key_F10=121]="Key_F10",o[o.Key_F11=122]="Key_F11",o[o.Key_F12=123]="Key_F12",o[o.Key_F13=124]="Key_F13",o[o.Key_F14=125]="Key_F14",o[o.Key_F15=126]="Key_F15",o[o.Key_F16=127]="Key_F16",o[o.Key_F17=128]="Key_F17",o[o.Key_F18=129]="Key_F18",o[o.Key_F19=130]="Key_F19",o[o.Key_F20=131]="Key_F20",o[o.Key_F21=132]="Key_F21",o[o.Key_F22=133]="Key_F22",o[o.Key_F23=134]="Key_F23",o[o.Key_F24=135]="Key_F24",o[o.Key_Num_Lock=136]="Key_Num_Lock",o[o.Key_Scroll_Lock=137]="Key_Scroll_Lock",o))(Ge||{});class Vg extends _e{moveSpeed=2;targetPos=new d(0,0,10);lookAtPos=new d(0,0,0);config={shiftMoveScale:20};_moveScale=1;_dir;_mouseFactory=25;_factory=1.5;_mouseDown=!1;_lastPos;_keyState;constructor(){super(),this._lastPos=new d,this._keyState={front:!1,back:!1,left:!1,right:!1,q:!1,e:!1},this.setCamera(new d(0,0,100),new d(0,0,0))}setCamera(e,t){this.targetPos.copyFrom(e),this.lookAtPos.copyFrom(t),this.Reset()}start(){m.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this),m.inputSystem.addEventListener(hr.KEY_UP,this.keyUp,this),m.inputSystem.addEventListener(hr.KEY_DOWN,this.keyDown,this),this.transform.lookAt(this.targetPos,this.lookAtPos)}mouseWheel(e){}keyUp(e){switch(e.keyCode){case Ge.Key_W:this._keyState.front=!1;break;case Ge.Key_S:this._keyState.back=!1;break;case Ge.Key_A:this._keyState.left=!1;break;case Ge.Key_D:this._keyState.right=!1;break;case Ge.Key_Shift_L:this._moveScale=1;break;case Ge.Key_Q:this._keyState.q=!1;break;case Ge.Key_E:this._keyState.e=!1;break;case Ge.Key_F:this.transform.lookAt(this.targetPos,this.lookAtPos);break}}keyDown(e){switch(e.keyCode){case Ge.Key_W:this._keyState.front=!0;break;case Ge.Key_S:this._keyState.back=!0;break;case Ge.Key_A:this._keyState.left=!0;break;case Ge.Key_D:this._keyState.right=!0;break;case Ge.Key_Q:this._keyState.q=!0;break;case Ge.Key_E:this._keyState.e=!0;break;case Ge.Key_Shift_L:this._moveScale=this.config.shiftMoveScale}}Reset(){this._lastPos.x=m.inputSystem.mouseLastX,this._lastPos.y=m.inputSystem.mouseLastY}mouseDown(e){this.Reset(),this._mouseDown=!0}mouseUp(e){this.Reset(),this._mouseDown=!1}get factory(){return this._factory}set factory(e){this._factory=e}get mouseFactory(){return this._mouseFactory}set mouseFactory(e){this._mouseFactory=e}internal(e,t,r){return(t-e)*r}onUpdate(){let e=this.transform,t=j(ue.delta,0,.016);if(this._mouseDown&&(e.rotationY-=this.internal(e.rotationY+(m.inputSystem.mouseLastX-this._lastPos.x)*.25,e.rotationY,t*this._mouseFactory),e.rotationX-=this.internal(e.rotationX+(m.inputSystem.mouseLastY-this._lastPos.y)*.25,e.rotationX,t*this._mouseFactory),this.Reset()),this._keyState.front){let r=e.forward;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.back){let r=e.forward;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.left){let r=e.left;e.x+=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y+=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z+=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}if(this._keyState.right){let r=e.left;e.x-=this.internal(e.x+r.x*this.moveSpeed*this._moveScale,e.x,t*this._factory),e.y-=this.internal(e.y+r.y*this.moveSpeed*this._moveScale,e.y,t*this._factory),e.z-=this.internal(e.z+r.z*this.moveSpeed*this._moveScale,e.z,t*this._factory)}this._keyState.q&&(e.y=wr(e.y,e.y-this.moveSpeed*this._moveScale,t*this._factory)),this._keyState.e&&(e.y=wr(e.y,e.y+this.moveSpeed*this._moveScale,t*this._factory))}destroy(e){m.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),m.inputSystem.removeEventListener(hr.KEY_UP,this.keyUp,this),m.inputSystem.removeEventListener(hr.KEY_DOWN,this.keyDown,this),super.destroy(e)}}class Ur{static add(e,t,r){return r||(r=new d),r.x=e.x+t.x,r.y=e.y+t.y,r.z=e.z+t.z,r}static sub(e,t,r){return r||(r=new d),r.x=e.x-t.x,r.y=e.y-t.y,r.z=e.z-t.z,r}static mul(e,t,r){return r||(r=new d),r.x=e.x*t.x,r.y=e.y*t.y,r.z=e.z*t.z,r}static mulScale(e,t,r){return r||(r=new d),r.x=e.x*t,r.y=e.y*t,r.z=e.z*t,r}static div(e,t,r){return r||(r=new d),r.x=e.x/t.x,r.y=e.y/t.y,r.z=e.z/t.z,r}static normalize(e){return e.clone().normalize()}static dot(e,t){let r=d.HELP_0;return r.copyFrom(e),r.dotProduct(t)}static calculateVectorAngle_xz(e,t){return Math.acos((e.x*t.x+e.y*t.y)/Math.sqrt((e.x*e.x+e.y*e.y)*(t.x*t.x+t.y*t.y)))}static distance(e,t){return d.distance(e,t)}static getRandomXYZ(e=-100,t=100){return new d(Math.random()*(t-e)+e,Math.random()*(t-e)+e,Math.random()*(t-e)+e)}static getRandomV3(e=-100,t=100,r,i){return new d(Math.random()*t+e,Math.random()*i+r,Math.random()*t+e)}static sphere(e){let t=e*Math.random(),r=new d(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(t),r}static sphereXYZ(e,t,r=1,i=1,a=1){let s=e+(t-e)*Math.random(),n=new d(Math.random()*r-r*.5,Math.random()*i-i*.5,Math.random()*a-a*.5);return n.normalize(),n.scaleBy(s),n}}class Hg extends _e{camera;minDistance=.1;maxDistance=500;rollSmooth=15;dragSmooth=20;wheelSmooth=10;wheelStep=.002;mouseRightFactor=.5;mouseLeftFactor=20;smooth=!0;_wheelStep=.002;_distance=0;distance=10;_roll=0;roll=0;_pitch=0;pitch=0;_currentPos;_targetPos;_flowTarget;_flowOffset;_mouseLeftDown=!1;_mouseRightDown=!1;_bottomClamp=89.99;_topClamp=-89.99;_tempDir=new d;_tempPos=new d;constructor(){super(),this._currentPos=new c.Object3D,this._targetPos=new c.Object3D}start(){this.camera=this.object3D.getOrAddComponent(Vr),m.inputSystem.addEventListener(L.POINTER_DOWN,this.onMouseDown,this),m.inputSystem.addEventListener(L.POINTER_MOVE,this.onMouseMove,this),m.inputSystem.addEventListener(L.POINTER_UP,this.onMouseUp,this),m.inputSystem.addEventListener(L.POINTER_WHEEL,this.onMouseWheel,this)}flowTarget(e,t=d.ZERO){this._flowTarget=e,this._flowOffset||=new d,this._flowOffset.copyFrom(t)}getFlowTarget(){return this._flowTarget}setCamera(e,t,r,i){this.roll=e,this.pitch=t,this.distance=r,this.maxDistance<r*1.5&&(this.maxDistance=r*1.5),i&&this._targetPos.transform.localPosition.copy(i)}focusByBounds(e){let t=na.genMeshBounds(e);this.target=t.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*Ur.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=m.inputSystem.wheelDelta*this._wheelStep,this.distance=j(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){if(this.enable){if(this._mouseRightDown){let t=.25,r=this.camera.transform.forward;Ur.mulScale(r,e.movementY*t*this.camera.aspect,d.HELP_1),this._targetPos.x+=d.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=d.HELP_1.z*this.mouseRightFactor;let i=this.camera.transform.right;Ur.mulScale(i,-e.movementX*t,d.HELP_1),this._targetPos.x-=d.HELP_1.x*this.mouseRightFactor,this._targetPos.z-=d.HELP_1.z*this.mouseRightFactor}this._mouseLeftDown&&(this.roll-=e.movementX*ue.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*ue.delta*.001*this.mouseLeftFactor,this.pitch=j(this.pitch,this._topClamp,this._bottomClamp))}}onBeforeUpdate(e){if(!this.enable)return;this._flowTarget&&(d.HELP_0.copyFrom(this._flowTarget.transform.worldPosition),d.HELP_0.add(this._flowOffset,d.HELP_0),this.target=d.HELP_0);let t=j(ue.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*t*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*t*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*t*this.dragSmooth,this._distance+=(this.distance-this._distance)*t*this.wheelSmooth,this._roll+=(this.roll-this._roll)*t*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*t*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let r=Y.HELP_0;r.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(r),this._tempPos=Ur.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.transform.lookAt(this._tempPos,this._currentPos.transform.localPosition,d.UP),this.camera.lookTarget.copy(this._currentPos.transform.localPosition)}destroy(e){m.inputSystem.removeEventListener(L.POINTER_DOWN,this.onMouseDown,this),m.inputSystem.removeEventListener(L.POINTER_MOVE,this.onMouseMove,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.onMouseUp,this),m.inputSystem.removeEventListener(L.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null,this._flowTarget=null}}class Yg extends _e{_camera;autoRotate=!1;autoRotateSpeed=.1;rotateFactor=.5;zoomFactor=.1;panFactor=.25;_smooth=5;_minDistance=1;_maxDistance=1e5;_maxPolarAngle=90;_minPolarAngle=-90;_target=new d(0,0,0);_cTarget=new d(0,0,0);_position=new d(0,0,0);_cPosition=new d(0,0,0);_spherical=new Xg;_isMouseDown=!1;_lastMouseX=-1;_lastMouseY=-1;_isPanning=!1;constructor(){super()}get target(){return this._target}set target(e){this._target=e}get smooth(){return this._smooth}set smooth(e){this._smooth=Math.max(e,1)}get minDistance(){return this._minDistance}set minDistance(e){this._minDistance=j(e,2e-6,this._maxDistance)}get maxDistance(){return this._maxDistance}set maxDistance(e){this._maxDistance=j(e,this._minDistance,1/0)}get minPolarAngle(){return this._minPolarAngle}set minPolarAngle(e){this._minPolarAngle=j(e,-90,this._maxPolarAngle)}get maxPolarAngle(){return this._maxPolarAngle}set maxPolarAngle(e){this._maxPolarAngle=j(e,this._minPolarAngle,90)}start(){this._camera=this.object3D.getComponent(Vr),this._position=this.object3D.transform.localPosition.clone(),this._cPosition=this._position.clone(),this._target=this._camera.lookTarget.clone(),this._cTarget=this._target.clone(),this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this._camera.lookAt(this._cPosition,this._cTarget,d.UP),this.addEventListener()}onEnable(){this.addEventListener()}onDisable(){this.removeEventListener()}onUpdate(){let e=this._isPanning?1:this.smooth,t=!1;this._cPosition.equals(this.object3D.transform.localPosition)||(this._position.copyFrom(this.object3D.transform.localPosition),e=1,t=!0),this._cTarget.equals(this._target)||(this._cTarget.copyFrom(this._target),e=1,t=!0),t?this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z):!this._isMouseDown&&this.autoRotate&&(this._spherical.theta-=this.autoRotateSpeed*Math.PI/180,this.updateCamera());let r=(this._position.x-this._cPosition.x)/e,i=(this._position.y-this._cPosition.y)/e,a=(this._position.z-this._cPosition.z)/e;this._cPosition.x=Math.abs(r)>1e-10?this._cPosition.x+r:this._position.x,this._cPosition.y=Math.abs(i)>1e-10?this._cPosition.y+i:this._position.y,this._cPosition.z=Math.abs(a)>1e-10?this._cPosition.z+a:this._position.z,this._camera.lookAt(this._cPosition,this._cTarget,d.UP)}onWheel(e){e.deltaY=j(e.deltaY,-this._spherical.radius,this._spherical.radius),this._spherical.radius+=e.deltaY*this.zoomFactor,this._spherical.radius=j(this._spherical.radius,this.minDistance,this.maxDistance),this.updateCamera()}onPointerDown(e){this._isMouseDown=!0,this._lastMouseX=e.mouseX,this._lastMouseY=e.mouseY,e.mouseCode===2&&(this._isPanning=!0)}onPointerMove(e){if(!this._isMouseDown||!this.enable)return;let t=e.mouseX,r=e.mouseY;if(e.mouseCode===0&&this._lastMouseX>0&&this._lastMouseY>0){const i=-(t-this._lastMouseX)*this.rotateFactor,a=(r-this._lastMouseY)*this.rotateFactor;this._spherical.theta+=i*Math.PI/180,this._spherical.phi-=a*Math.PI/180,this._spherical.phi=j(this._spherical.phi,this.minPolarAngle,this.maxPolarAngle),this.updateCamera()}else e.mouseCode===2&&(Ur.mulScale(this.object3D.transform.up,e.movementY*this.panFactor*this._camera.aspect,d.HELP_1),this._target.y+=d.HELP_1.y,Ur.mulScale(this.object3D.transform.right,-e.movementX*this.panFactor,d.HELP_1),this._target.x-=d.HELP_1.x,this._target.z-=d.HELP_1.z,this._cTarget.copyFrom(this._target),this.updateCamera());this._lastMouseX=t,this._lastMouseY=r}onPointerUp(e){this._isMouseDown=!1,e.mouseCode===2&&(this._isPanning=!1)}onPointerLeave(){this._isMouseDown=!1,this._isPanning=!1}updateCamera(){this._spherical.makeSafe();let e=this._spherical.getCoords();this._position.set(e.x+this._target.x,e.y+this._target.y,e.z+this._target.z)}addEventListener(){m.inputSystem.addEventListener(L.POINTER_WHEEL,this.onWheel,this),m.inputSystem.addEventListener(L.POINTER_DOWN,this.onPointerDown,this),m.inputSystem.addEventListener(L.POINTER_MOVE,this.onPointerMove,this),m.inputSystem.addEventListener(L.POINTER_UP,this.onPointerUp,this),m.inputSystem.addEventListener(L.POINTER_OUT,this.onPointerLeave,this)}removeEventListener(){m.inputSystem.removeEventListener(L.POINTER_WHEEL,this.onWheel,this),m.inputSystem.removeEventListener(L.POINTER_DOWN,this.onPointerDown,this),m.inputSystem.removeEventListener(L.POINTER_MOVE,this.onPointerMove,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.onPointerUp,this),m.inputSystem.removeEventListener(L.POINTER_OUT,this.onPointerLeave,this)}}class Xg{radius;phi;theta;coords;constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this.coords=new d,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}makeSafe(){return this.phi=Math.max(2e-4,Math.min(Math.PI-2e-4,this.phi)),this}setFromVector3(e){return this.setCoords(e.x,e.y,e.z)}setCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(j(t/this.radius,-1,1))),this}getCoords(){const e=Math.sin(this.phi)*this.radius;return this.coords.x=e*Math.sin(this.theta),this.coords.y=Math.cos(this.phi)*this.radius,this.coords.z=e*Math.cos(this.theta),this.coords}}class jg extends _e{focus;_rotation=new d(45,0,0);distance=5;_camera;constructor(){super()}start(){if(this._camera=this.object3D.getOrAddComponent(Vr),!this._camera){console.error("ThirdPersonCameraController need camera");return}if(!this.focus){console.error("ThirdPersonCameraController need target");return}m.inputSystem.addEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(L.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){m.inputSystem.addEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){m.inputSystem.removeEventListener(L.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){this._rotation.y+=e.movementX*.01,this._rotation.x+=e.movementY*.01}mouseWheel(e){this.distance+=m.inputSystem.wheelDelta*.1}onUpdate(){let e=new d;this._camera.transform.forward.scaleToRef(this.distance,e);var t=this.focus.transform.worldPosition;this._camera.transform.localPosition=t.subtract(e)}destroy(e){m.inputSystem.removeEventListener(L.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(L.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Se=(o=>(o[o.NORMAL=0]="NORMAL",o[o.DOWN=1]="DOWN",o[o.OVER=2]="OVER",o[o.DISABLE=3]="DISABLE",o))(Se||{});let Qu=Math.PI*2;class Lr{a;b;c;d;tx;ty;constructor(e=1,t=0,r=0,i=1,a=0,s=0){this.a=e,this.b=t,this.c=r,this.d=i,this.tx=a,this.ty=s}clone(){return new Lr(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(e){let t=this.a,r=this.c,i=this.tx;this.a=t*e.a+this.b*e.c,this.b=t*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d,this.tx=i*e.a+this.ty*e.c+e.tx,this.ty=i*e.b+this.ty*e.d+e.ty}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(e){if(e=+e,e!==0){e=e*ge;let t=Math.cos(e),r=Math.sin(e),i=this.a,a=this.b,s=this.c,n=this.d,l=this.tx,h=this.ty;this.a=i*t-a*r,this.b=i*r+a*t,this.c=s*t-n*r,this.d=s*r+n*t,this.tx=l*t-h*r,this.ty=l*r+h*t}}scale(e,t){e!==1&&(this.a*=e,this.c*=e,this.tx*=e),t!==1&&(this.b*=t,this.d*=t,this.ty*=t)}setTo(e,t,r,i,a,s){return this.a=e,this.b=t,this.c=r,this.d=i,this.tx=a,this.ty=s,this}transformPoint(e,t,r){let i=this.a*e+this.c*t+this.tx,a=this.b*e+this.d*t+this.ty;return r?(r.setTo(i,a,0,1),r):new d(i,a,0,1)}setTranslate(e,t){this.tx=e,this.ty=t}translate(e,t){this.tx+=e,this.ty+=t}mul(e){let t=this,r=e,i=t.a,a=t.b,s=t.c,n=t.d,l=t.tx,h=t.ty,u=r.a,f=r.b,g=r.c,p=r.d,A=r.tx,v=r.ty;f!==0||g!==0?(this.a=i*u+a*g,this.b=i*f+a*p,this.c=s*u+n*g,this.d=s*f+n*p,this.tx=u*l+g*h+A,this.ty=f*l+p*h+v):(this.a=i*u,this.b=a*p,this.c=s*u,this.d=n*p,this.tx=u*l+A,this.ty=p*h+v)}equals(e){return this.a==e.a&&this.b==e.b&&this.c==e.c&&this.d==e.d&&this.tx==e.tx&&this.ty==e.ty}prepend(e,t,r,i,a,s){let n=this.tx;if(e!=1||t!=0||r!=0||i!=1){let l=this.a,h=this.c;this.a=l*e+this.b*r,this.b=l*t+this.b*i,this.c=h*e+this.d*r,this.d=h*t+this.d*i}return this.tx=n*e+this.ty*r+a,this.ty=n*t+this.ty*i+s,this}append(e){let t=this.a,r=this.b,i=this.c,a=this.d;return(e.a!=1||e.b!=0||e.c!=0||e.d!=1)&&(this.a=e.a*t+e.b*i,this.b=e.a*r+e.b*a,this.c=e.c*t+e.d*i,this.d=e.c*r+e.d*a),this.tx=e.tx*t+e.ty*i+this.tx,this.ty=e.tx*r+e.ty*a+this.ty,this}deltaTransformPoint(e){let t=this,r=t.a*e.x+t.c*e.y,i=t.b*e.x+t.d*e.y;return new d(r,i)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(e,t,r=0,i=0,a=0){let s=this;if(r!==0){r=r*ge;let n=Math.cos(r),l=Math.sin(r);s.a=n*e,s.b=l*t,s.c=-l*e,s.d=n*t}else s.a=e,s.b=0,s.c=0,s.d=t;s.tx=i,s.ty=a}createGradientBox(e,t,r=0,i=0,a=0){this.createBox(e/1638.4,t/1638.4,r,i+e/2,a+t/2)}_invertInto(e){let t=this.a,r=this.b,i=this.c,a=this.d,s=this.tx,n=this.ty;if(r==0&&i==0){e.b=e.c=0,t==0||a==0?e.a=e.d=e.tx=e.ty=0:(t=e.a=1/t,a=e.d=1/a,e.tx=-t*s,e.ty=-a*n);return}let l=t*a-r*i;if(l==0){e.identity();return}l=1/l;let h=e.a=a*l;r=e.b=-r*l,i=e.c=-i*l,a=e.d=t*l,e.tx=-(h*s+i*n),e.ty=-(r*s+a*n)}getScaleX(){let e=this;if(e.a==1&&e.b==0)return 1;let t=Math.sqrt(e.a*e.a+e.b*e.b);return this.getDeterminant()<0?-t:t}getScaleY(){let e=this;if(e.c==0&&e.d==1)return 1;let t=Math.sqrt(e.c*e.c+e.d*e.d);return this.getDeterminant()<0?-t:t}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(e,t,r,i){if((r==0||r==Qu)&&(i==0||i==Qu)){this.a=e,this.b=this.c=0,this.d=t;return}r=r*ge,i=i*ge;let a=Math.cos(r),s=Math.sin(r);r==i?(this.a=a*e,this.b=s*e):(this.a=Math.cos(i)*e,this.b=Math.sin(i)*e),this.c=-s*t,this.d=a*t}preMultiplyInto(e,t){let r=e.a*this.a,i=0,a=0,s=e.d*this.d,n=e.tx*this.a+this.tx,l=e.ty*this.d+this.ty;(e.b!==0||e.c!==0||this.b!==0||this.c!==0)&&(r+=e.b*this.c,s+=e.c*this.b,i+=e.a*this.b+e.b*this.d,a+=e.c*this.a+e.d*this.c,n+=e.ty*this.c,l+=e.tx*this.b),t.a=r,t.b=i,t.c=a,t.d=s,t.tx=n,t.ty=l}$transformBounds(e){let t=this.a,r=this.b,i=this.c,a=this.d,s=this.tx,n=this.ty,l=e.x,h=e.y,u=l+e.width,f=h+e.height,g=t*l+i*h+s,p=r*l+a*h+n,A=t*u+i*h+s,v=r*u+a*h+n,C=t*u+i*f+s,x=r*u+a*f+n,S=t*l+i*f+s,y=r*l+a*f+n,b=0;g>A&&(b=g,g=A,A=b),C>S&&(b=C,C=S,S=b),e.x=Math.floor(g<C?g:C),e.width=Math.ceil((A>S?A:S)-e.x),p>v&&(b=p,p=v,v=b),x>y&&(b=x,x=y,y=b),e.y=Math.floor(p<x?p:x),e.height=Math.ceil((v>y?v:y)-e.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class Bi extends _e{isGUICanvas=!0;index=0;addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(Bi).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var Ie=(o=>(o[o.NONE=0]="NONE",o[o.POSITION=1]="POSITION",o[o.SPRITE=2]="SPRITE",o[o.COLOR=4]="COLOR",o[o.MAX=7]="MAX",o))(Ie||{});class Ys{array;buffer;constructor(e){this.buffer=new Z(e,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Vu extends ve{_attributeUV;_attributeVIndex;_faceIndexes;_uvSize=2;_vIndexSize=1;_posAttribute;_spriteAttribute;_colorAttribute;_onPositionChange=!0;_onSpriteChange=!0;_onColorChange=!0;maxQuadCount;constructor(e){super(),this.maxQuadCount=e}updateSubGeometry(e,t,r){let i=this.subGeometries[e];if(i){let a=i.lodLevels[0];a.indexStart=t,a.indexCount=r,a.index=e}else i=this.addSubGeometry({indexStart:t,indexCount:r,vertexStart:0,vertexCount:0,firstStart:0,index:e,topology:0});return i}resetSubGeometries(){for(let e of this.subGeometries){let t=e.lodLevels[0];t.indexStart=0,t.indexCount=0,t.index=0}}updateBounds(e,t){let r=Number.MAX_VALUE*.1;return e=new d(-r,-r,-r),t=new d(r,r,r),this.bounds.setFromMinMax(e,t),this}getPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}getSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}getColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,t=[],r=[];for(let a=0;a<e;a++)t.push(...$r.attUV);for(let a=0,s=this.maxQuadCount*$r.vertexCount;a<s;a++)r[a]=a;this._attributeUV=new Float32Array($r.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array($r.vertexCount*e*this._vIndexSize),this._attributeUV.set(t,0),this._attributeVIndex.set(r,0);let i=[];for(let a=0;a<e;a++)for(let s=0;s<$r.indecies.length;s++){const n=$r.indecies[s]+a*4;i.push(n)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(i,0),this.setIndices(this._faceIndexes),this.setAttribute(M.uv,this._attributeUV),this.setAttribute(M.vIndex,this._attributeVIndex),this.updateSubGeometry(0,0,this._faceIndexes.length),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new Ys(e*4),this._spriteAttribute=new Ys(e*12),this._colorAttribute=new Ys(e*4)}fillQuad(e,t){e.dirtyAttributes&Ie.POSITION&&this.fillQuadPosition(e,t),e.dirtyAttributes&Ie.COLOR&&this.fillQuadColor(e,t),e.dirtyAttributes&Ie.SPRITE&&this.fillQuadSprite(e,t)}fillQuadPosition(e,t){Hu.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,t){let r=e.color,i=this._colorAttribute.array;Hu.setXYZW(i,e.z,r.r,r.g,r.b,r.a),this._onColorChange=!0}fillQuadSprite(e,t){let r=e.sprite,i=0,a=0;r.isSliced&&e.imageType==Kr.Sliced&&(i=r.trimSize.x,i=(t.width-(r.offsetSize.z-r.trimSize.x))/i,a=r.trimSize.y,a=(t.height-(r.offsetSize.w-r.trimSize.y))/a);let s=r.guiTexture.dynamicId,n=r.uvRec,l=r.uvBorder,h=this._spriteAttribute.array,u=12*e.z;h[u+0]=n.x,h[u+1]=n.y,h[u+2]=n.z,h[u+3]=n.w,h[u+4]=l.x,h[u+5]=l.y,h[u+6]=l.z,h[u+7]=l.w,h[u+8]=i,h[u+9]=a,h[u+10]=s,h[u+11]=e.visible?1:0,this._onSpriteChange=!0}}class Wg{static set(e,t,r,i,...a){let s=t*i+r;for(let n=0,l=a.length;n<l;n++)e[s+n]=a[n]}}class Hu extends Wg{static setXYZW(e,t,r,i,a,s){this.set(e,t,0,4,r,i,a,s)}static setXYZ(e,t,r,i,a){this.set(e,t,0,4,r,i,a)}static setZ(e,t,r){this.set(e,t,3,4,r)}}class $r{static vertexCount=4;static attUV=[0,0,1,0,1,1,0,1];static indecies=[0,1,2,0,2,3]}class Yu{_textureMap=new Map;_textureList=[];build(e,t,r){let i=t._geometry;i.resetSubGeometries();let a=-1,s=0,n=0,l=0,h=0,u=this._textureList,f=this._textureMap;function g(){l>0&&(t.updateDrawCallSegment(h,n,l),t._uiRenderer.materials[h].setTextures(u),f.clear(),u.length=0,h++,n+=l,l=0,s=0)}f.clear(),u.length=0;let p=[],A=t.quadMaxCount-1;for(let v of e){let C=v.needUpdateQuads;p.length=0;const x=this.collectQuads(v.object3D,p);for(let S of x){let y=S.sprite.guiTexture;if(f.has(y.staticId)||(s==7&&g(),f.set(y.staticId,y),y.dynamicId=s,u[s]=y.texture,s+=1),S.z=++a,l+=6,S.cacheTextureId!=y.dynamicId&&(S.dirtyAttributes=Ie.MAX,S.cacheTextureId=y.dynamicId),(C||r)&&(S.dirtyAttributes=Ie.MAX),S.dirtyAttributes&Ie.POSITION&&S.applyTransform(v),S.dirtyAttributes&&S.writeToGeometry(i,v),a==A)return g(),!0}}return g(),!1}collectQuads(e,t){t||=[];let r=e.components.values();for(let i of r){let a=i;if(a.isUIShadow||!a.mainQuads)continue;let s=a.getShadowRender();s&&this.push(s.mainQuads,t),this.push(a.mainQuads,t)}return t}push(e,t){e&&e.length>0&&t.push(...e)}}class Xs{static bindTextureArray(){let e="";for(let t=0;t<7;t++)e+=`
        @group(1) @binding(auto)
        var tex_${t}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${t}
        var tex_${t}: texture_external;
#else
        var tex_${t}: texture_2d<f32>;
#endif
`;return e}static sampleTexture(e){return`
#if VideoTexture${e}
            let size = textureDimensions(tex_${e}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${e}, iuv) ;
#else
            color = textureSampleLevel(tex_${e}, tex_${e}Sampler, uv, 0.0);
#endif        `}static fs=`
        ${qa}
        ${this.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${this.sampleTexture(0)}
            }else if(texId == 1){
                ${this.sampleTexture(1)}
            }else if(texId == 2){
                ${this.sampleTexture(2)}
            }else if(texId == 3){            
                ${this.sampleTexture(3)}
            }else if(texId == 4){            
                ${this.sampleTexture(4)}
            }else if(texId == 5){            
                ${this.sampleTexture(5)}
            }else if(texId == 6){            
                ${this.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`;static GUI_common_vs=`
        ${Wa}
        ${ra}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,
            v3:vec3<f32>
        }
        
        struct VertexOutput {
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(auto) uv: vec2<f32>,
            @location(auto) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `;static GUI_shader_view=`
        ${this.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${this.fs}
        `;static GUI_shader_world=`
        ${this.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${this.fs}

        `}class js extends We{_scissorRect;_screenSize=new V(1024,768);_scissorEnable=!1;constructor(e){super(),F.register("GUI_shader_view",Xs.GUI_shader_view),F.register("GUI_shader_world",Xs.GUI_shader_world);let t=new ke,r=e==St.View?"GUI_shader_view":"GUI_shader_world",i=new Ae(r,r);i.passType=W.COLOR,i.setShaderEntry("VertMain","FragMain"),i.setUniformVector4("scissorRect",new G),i.setUniformVector2("screenSize",this._screenSize),i.setUniformFloat("scissorCornerRadius",0),i.setUniformFloat("scissorFadeOutSize",0),i.setUniformFloat("pixelRatio",1),i.setUniformVector3("v3",d.ZERO);let a=i.shaderState;a.depthWriteEnabled=!1,i.blendMode=ee.ALPHA,i.depthCompare=e==St.View?zt.always:zt.less_equal,i.cullMode=at.back,t.addRenderPass(i),this.shader=t}setPanelRatio(e){this.shader.setUniformFloat("pixelRatio",e)}setScissorRect(e,t,r,i){this._scissorRect||=new G,this._scissorRect.set(e,t,r,i),this.shader.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.shader.setDefine("SCISSOR_ENABLE",!0):this.shader.deleteDefine("SCISSOR_ENABLE"),this.shader.noticeValueChange())}setScissorCorner(e,t){this.shader.setUniformFloat("scissorCornerRadius",e),this.shader.setUniformFloat("scissorFadeOutSize",t)}setScreenSize(e,t){return this._screenSize.set(e,t),this.shader.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let t=0;t<7;t++){let r=e[t]||m.res.whiteTexture;this.shader.setTexture(`tex_${t}`,r),this.setVideoTextureDefine(t,r.isVideoTexture)}}_videoTextureFlags={};setVideoTextureDefine(e,t){let r=!1;t!=this._videoTextureFlags[e]&&(t?this.shader.setDefine(`VideoTexture${e}`,!0):this.shader.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=t,r=!0),r&&this.shader.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Xu extends c.MeshRenderer{_guiGeometry;init(e){super.init(),this.addRendererMask(Be.UI),this.removeRendererMask(Be.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,t,r,i){for(let a=0;a<this.materials.length;a++){let n=this.materials[a].getPass(t),l=this._guiGeometry.getPositionBuffer(),h=this._guiGeometry.getSpriteBuffer(),u=this._guiGeometry.getColorBuffer();if(n)for(let f=0;f<n.length;f++){const g=n[f];g.pipeline||(g.setStorageBuffer("vPositionBuffer",l),g.setStorageBuffer("vSpriteBuffer",h),g.setStorageBuffer("vColorBuffer",u))}}super.nodeUpdate(e,t,r,i)}onUpdate(e){}}class ju{_use;_unUse;constructor(){this._use=[],this._unUse=[]}pushBack(e){let t=this._use.indexOf(e);t!=-1&&(this._use.splice(t,1),this._unUse.push(e))}getUseList(){return this._use}getOne(e,t){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new e(t),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let Ei;class Vt{x=0;y=0;z=0;width=1;height=1;_globalX=0;_globalY=0;_globalWidth=0;_globalHeight=0;_visible=!0;_offsetX=0;_offsetY=0;_sprite=m.res.defaultGUISprite;_color=new P(1,1,1,1);_imageType=Kr.Simple;dirtyAttributes=Ie.MAX;cacheTextureId=-1;static textPool;static get quadPool(){return this.textPool||=new ju,this.textPool}static recycleQuad(e){e.sprite=null,e.dirtyAttributes=Ie.MAX,e.x=0,e.y=0,e.z=-1,e.cacheTextureId=-1,Vt.quadPool.pushBack(e)}static spawnQuad(){return Vt.quadPool.getOne(Vt)}get imageType(){return this._imageType}set imageType(e){this._imageType=e,this.setAttrChange(Ie.SPRITE|Ie.POSITION)}get color(){return this._color}set color(e){this._color.copyFrom(e),this.setAttrChange(Ie.COLOR)}get visible(){return this._visible}set visible(e){e!=this._visible&&(this._visible=e,this.setAttrChange(Ie.SPRITE))}get sprite(){return this._sprite}set sprite(e){this._sprite!=e&&(this._sprite=e,this.setAttrChange(Ie.SPRITE|Ie.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(e,t){this.width=e,this.height=t,this.setAttrChange(Ie.POSITION)}setXY(e,t){this.x=e,this.y=t,this.setAttrChange(Ie.POSITION)}setAttrChange(e){this.dirtyAttributes=this.dirtyAttributes|e}applyTransform(e){this.setAttrChange(Ie.POSITION);let t=this._sprite,r=e.getWorldMatrix();(this.x!=0||this.y!=0)&&(r=this.getQuadMatrix(r));let i=r.getScaleX(),a=r.getScaleY(),s=t.isSliced&&this._imageType==Kr.Sliced;if(this._offsetX=e.width*.5*i,this._offsetY=e.height*.5*a,s)this._globalWidth=i*(e.width-(t.offsetSize.z-t.trimSize.x)),this._globalHeight=a*(e.height-(t.offsetSize.w-t.trimSize.y)),this._globalX=r.tx+t.offsetSize.x*i,this._globalY=r.ty+t.offsetSize.y*a;else{let n=this.width/t.offsetSize.z,l=this.height/t.offsetSize.w;this._globalWidth=i*t.trimSize.x*n,this._globalHeight=a*t.trimSize.y*l,this._globalX=r.tx+t.offsetSize.x*n*i,this._globalY=r.ty+t.offsetSize.y*l*a}return this}getQuadMatrix(e){return Ei||=new Lr,Ei.identity(),Ei.setTranslate(this.x,this.y),Ei.mul(e),Ei}writeToGeometry(e,t){return e.fillQuad(this,t),this.dirtyAttributes=Ie.NONE,this}}class Ws extends _e{_uiTransform;_visible=!0;destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){this._visible!=e&&(this._visible=e,this.onUIComponentVisible?.(this._visible))}init(e){super.init?.(e),this._uiTransform=this.object3D.getOrAddComponent(sr),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class Ti extends Ws{_mainQuads;_shadowRender;_shadowSource;isUIShadow;isShadowless;needUpdateShadow;init(e){super.init?.(e),this._mainQuads=[]}destroy(){this.detachQuads(),this._shadowRender?.setShadowSource(null),this._shadowSource?.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){super.start?.(),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,t){let r=this.object3D.components.values();if(!e)for(let i of r){let a=i;if(!(a.isShadowless||a.isUIShadow)&&a.mainQuads){e=a;break}}if(!t)for(let i of r){let a=i;if(a.isUIShadow&&a.mainQuads){t=a;break}}return e&&t?(e.setShadowRenderer(t),t.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let t=this._mainQuads.indexOf(e);t>=0?(this._mainQuads.splice(t,1),Vt.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Or extends Ti{init(e){super.init?.(e),this.attachQuad(Vt.spawnQuad()),this.sprite=m.res.defaultGUISprite}cloneTo(e){e.getOrAddComponent(Or).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.sprite=e.sprite,this.color=e.color,this.imageType=e.imageType,this}set sprite(e){e||=m.res.defaultGUISprite;for(let t of this._mainQuads)t.sprite=e,t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let e of this._mainQuads)e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(e){for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(e){for(let t of this._mainQuads)t.imageType=e;this.setShadowDirty()}}class Di extends Or{space=St.World;needUpdateGeometry=!0;panelOrder=0;needSortOnCameraZ;_billboard;_rebuild;scissorEnable=!1;scissorCornerRadius=0;scissorFadeOutSize=0;_uiRenderer;_geometry;_maxCount=128;panelRatio=1;isUIPanel=!0;cloneTo(e){e.getOrAddComponent(Di).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this._uiTransform.resize(I.canvas.width,I.canvas.height),this.create(this.space),this.visible=!1}updateDrawCallSegment(e,t,r){this._geometry.updateSubGeometry(e,t,r);let i=this._uiRenderer.material,a=this._uiRenderer.materials[e];if(!a){a=new js(this.space);let s=this._uiRenderer.materials.slice();s.push(a),this._uiRenderer.materials=s,a.cullMode=i.cullMode,a.depthCompare=i.depthCompare}}create(e){this._maxCount=this.space==St.World?Mr.quadMaxCountForWorld:Mr.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Xu),this._geometry=this._uiRenderer.geometry=new Vu(this._maxCount).create(),this._uiRenderer.material=new js(e),this._uiRenderer.renderOrder=Mr.SortOrderStartWorld,this._rebuild=new Yu,this.object3D.bound=new de(new d,new d(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}set billboard(e){this.space==St.View?e=vr.None:console.warn("Cannot enable billboard in view space"),e==vr.BillboardXYZ||e==vr.BillboardY?(this._billboard=this.object3D.getOrAddComponent(yi),this._billboard.type=e):(this.object3D.removeComponent(yi),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:vr.None}set cullMode(e){if(this.space==St.World)for(let t of this._uiRenderer.materials)t.cullMode=e;else console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){super.onUpdate?.(e),this.rebuildGUIMesh(e)}_collectTransform=[];rebuildGUIMesh(e){let t=this,r=t._collectTransform;if(r.length=0,t.object3D.getComponents(sr,r),r.length>0){t._rebuild.build(r,t,t.needUpdateGeometry);for(const n of r)n.needUpdateQuads=!1}let i=t.object3D.getComponentFromParent(Bi),a=i?i.index:0;t._uiRenderer.enable=r.length>0;let s=t.isViewPanel?Mr.SortOrderStartView:Mr.SortOrderStartWorld;if(t._uiRenderer.renderOrder=a*Mr.SortOrderCanvasSpan+s+t.panelOrder,t._uiRenderer.needSortOnCameraZ=t.needSortOnCameraZ,this.space==St.View){let n=I.canvas.clientWidth,l=I.canvas.clientHeight,h=this._uiTransform.width,u=this._uiTransform.height;this.panelRatio=this.updateGUIPixelRatio(n,l,h,u)}else this.panelRatio=1;for(let n of t._uiRenderer.materials){let l=n;if(l.setPanelRatio(this.panelRatio),l.setScreenSize(I.canvas.clientWidth,I.canvas.clientHeight),l.setScissorEnable(t.scissorEnable),t.scissorEnable){let h=t.mainQuads[0];l.setScissorRect(h.left,h.bottom,h.right,h.top),l.setScissorCorner(t.scissorCornerRadius,t.scissorFadeOutSize)}}t.needUpdateGeometry=!1}updateGUIPixelRatio(e,t,r,i){let a=r/i,s=e/t,n=1;return a<s?n=t/i:n=e/r,n}}class Ba extends Di{isViewPanel=!0;space=St.View;constructor(){super()}cloneTo(e){e.getOrAddComponent(Ba).copyComponent(this)}}class Ea extends Di{isWorldPanel=!0;space=St.World;_depthTest=!0;constructor(){super()}cloneTo(e){e.getOrAddComponent(Ea).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let t=this.depthTest?zt.less_equal:zt.always;for(let r of this._uiRenderer.materials)r.depthCompare=t}}}let Wu;class sr extends _e{useParentPivot=!1;parent;pivotX=.5;pivotY=.5;_width=100;_height=100;_localVisible=!0;_globalVisible=!0;_uiInteractiveList;get uiInteractiveList(){return this._uiInteractiveList}constructor(){super(),this._localMatrix=new Lr,this._worldMatrix=new Lr}init(e){super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,this.object3D.parent?.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||=[],this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let t=this._uiInteractiveList.indexOf(e);if(t>=0)return this._uiInteractiveList.slice(t,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let t=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&t)}}get visible(){return this._localVisible}onUITransformVisible(e){let t=this._localVisible&&e;t!=this._globalVisible&&(this._globalVisible=t,this.object3D.components.forEach((r,i)=>{let a=r;if(a.onUITransformVisible)if(a==this)for(let s of this.object3D.entityChildren){let n=s.getComponent(sr);n&&n.onUITransformVisible(this._globalVisible)}else a.onUITransformVisible(this._globalVisible)}))}onParentChange(e,t){this.parent?.setNeedUpdateUIPanel(),this.parent=t?.getComponent(sr),this.parent?.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,t){if(this._width!=e||this._height!=t){this._width=e,this._height=t,this.onChange=!0;for(let r of this.object3D.components.values())r.onTransformResize?.();return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,t){let r=this.object3D.localPosition;r.set(e,t,r.z),this.object3D.localPosition=r,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}_localMatrix;_worldMatrix;_onChange=!0;needUpdateQuads=!0;get onChange(){return this._onChange}_tempTransforms=[];set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let t=this.object3D.getComponents(sr,this._tempTransforms,!0);for(let r of t)r._onChange=!0,r.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(Ea),e||(e=this.object3D.getComponentFromParent(Ba)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let t=e.getOrAddComponent(sr);t.visible=this.visible,t.x=this.x,t.y=this.y,t.z=this.z,t.resize(this.width,this.height),t.pivotX=this.pivotX,t.pivotY=this.pivotY,t.scaleX=this.scaleX,t.scaleY=this.scaleY}matrix(){let e=this._localMatrix,t=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,t,t),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(Wu||=new Lr().identity(),e.mul(Wu.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,t=e._worldMatrix;return this._onChange&&(t.copyFrom(e.matrix()),e.parent&&t.mul(e.parent.getWorldMatrix()),e._onChange=!1),t}beforeDestroy(e){this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),super.beforeDestroy?.(e)}}class qu{_ray;_mouseCode;_clickEvent;_outEvent;_overEvent;_upEvent;_downEvent;_view;init(e){this._view=e,this._ray=new _t,this._clickEvent=new L(L.PICK_CLICK_GUI),this._outEvent=new L(L.PICK_OUT_GUI),this._overEvent=new L(L.PICK_OVER_GUI),this._upEvent=new L(L.PICK_UP_GUI),this._downEvent=new L(L.PICK_DOWN_GUI),m.inputSystem.addEventListener(L.POINTER_DOWN,this.onTouchDown,this,null,1),m.inputSystem.addEventListener(L.POINTER_UP,this.onTouchUp,this,null,1),m.inputSystem.addEventListener(L.POINTER_MOVE,this.onTouchMove,this,null,1),m.inputSystem.addEventListener(L.POINTER_CLICK,this.onTouchClick,this,null,1)}_lastDownTarget;_lastOverTarget;onTouchClick(e){this._lastOverTarget&&e.stopImmediatePropagation()}onTouchMove(e){this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r!=this._lastOverTarget&&(this._lastOverTarget&&this._lastOverTarget.enable&&(this._lastOverTarget.mouseStyle=Se.NORMAL,this._outEvent.data=this._lastOverTarget,this._lastOverTarget.object3D.dispatchEvent(this._outEvent)),r&&(r.mouseStyle=Se.OVER,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastOverTarget=r)}_lastDownPosition=new V;_calcDistanceVec2=new V;_lastDownTime=0;_clickTimeSpan=200;_clickDistanceSpan=10;onTouchDown(e){this._lastDownTime=ue.time,this._lastDownPosition.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;r&&(r.mouseStyle=Se.DOWN,this._overEvent.data=r,r.object3D.dispatchEvent(this._overEvent)),this._lastDownTarget=r}onTouchUp(e){this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._mouseCode=e.mouseCode,this.collectEntities();let t=this.pick(this._colliderOut);t&&e.stopImmediatePropagation();let r=t?t.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=Se.NORMAL),r&&r==this._lastDownTarget&&ue.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(e.mouseX,e.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(this._clickEvent.data={pick:r,pickInfo:t,mouseCode:this._mouseCode},r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}_colliderOut=[];_transformList=[];_sortWorldPanelList=[];_iteractive2PanelDict=new Map;collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let r=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);r.sort((i,a)=>{let s=i._uiRenderer.__renderOrder,n=a._uiRenderer.__renderOrder;return s>n?-1:1});for(let i of r){this._transformList.length=0,i.object3D.getComponents(sr,this._transformList),this._transformList.reverse();for(const a of this._transformList){let s=a.uiInteractiveList;if(s&&s.length>0)for(let n of s)this._colliderOut.push(n),this._iteractive2PanelDict.set(n,i)}}}}),this._colliderOut}pick(e){this._ray=this._view.camera.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY);let t=new V(m.inputSystem.mouseX,m.inputSystem.mouseY),r=new V(I.canvas.clientWidth,I.canvas.clientHeight),i;for(const a of e)if(a.interactive&&a.enable&&a.interactiveVisible){let s=this._iteractive2PanelDict.get(a);if(i=a.rayPick(this._ray,s,t,r),i)return i.collider=a,i}return null}}var Ku=(o=>(o[o.COLLINEAR=0]="COLLINEAR",o[o.LINES_INTERSECT=1]="LINES_INTERSECT",o[o.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",o[o.A_BISECTS_B=3]="A_BISECTS_B",o[o.B_BISECTS_A=4]="B_BISECTS_A",o[o.PARALELL=5]="PARALELL",o))(Ku||{}),Ju=(o=>(o[o.ON_LINE=0]="ON_LINE",o[o.LEFT_SIDE=1]="LEFT_SIDE",o[o.RIGHT_SIDE=2]="RIGHT_SIDE",o))(Ju||{});class Qe{static cacluteLine0=new Qe(null,null);static cacluteLine1=new Qe(null,null);start;end;color=new P(1,1,1,1);_normal;_normalCalculated=!1;constructor(e,t){this.start=e,this.end=t}set(e,t){this.start=e,this.end=t}getCenter(){let e=d.HELP_0;return this.start.subtract(this.end,e),e.scaleBy(.5),e.add(this.end),e}inverse(){let e=this.start;this.start=this.end,this.end=e}equals(e){return this.start==e.start&&this.end==e.end||this.start==e.end&&this.end==e.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(e){let t=[];for(let r=0;r<e.length;r++){let i=r,a=as(r+1,e.length),s=e[i],n=e[a];t.push(new Qe(s,n))}return t}intersection(e,t=null){var r=(e.end.z-e.start.z)*(this.end.x-this.start.x)-(e.end.x-e.start.x)*(this.end.z-this.start.z),i=(e.end.x-e.start.x)*(this.start.z-e.start.z)-(e.end.z-e.start.z)*(this.start.x-e.start.x),a=(e.start.x-this.start.x)*(this.end.z-this.start.z)-(e.start.z-this.start.z)*(this.end.x-this.start.x);if(r==0)return i==0&&a==0?0:5;i=i/r,a=a/r;var s=this.start.x+i*(this.end.x-this.start.x),n=this.start.z+i*(this.end.z-this.start.z);return t!=null&&(t.x=s,t.y=0,t.z=n),i>=0&&i<=1&&a>=0&&a<=1?2:a>=0&&a<=1?3:i>=0&&i<=1?4:1}getDirection(){var e=this.end.subtract(this.start),t=new d(e.x,e.y);return t.normalize()}copyFrom(e){this.start||(this.start=new d),this.end||(this.end=new d),this.start.copyFrom(e.start),this.end.copyFrom(e.end)}static IsEqual(e,t){return Math.abs(e-t)<1e-7}static squreDistanceSegmentToSegment(e,t,r){let i=e.start,a=e.end,s=t.start,n=t.end,l=i.x,h=i.y,u=i.z,f=a.x,g=a.y,p=a.z,A=s.x,v=s.y,C=s.z,x=n.x,S=n.y,y=n.z,b=f-l,D=g-h,B=p-u,T=x-A,U=S-v,E=y-C,N=l-A,Q=h-v,H=u-C,q=b*b+D*D+B*B,re=b*T+D*U+B*E,pe=T*T+U*U+E*E,le=b*N+D*Q+B*H,be=T*N+U*Q+E*H,Fe=q*pe-re*re,se=Fe,Re=Fe,he=0,Ue=0;this.IsEqual(Fe,0)?(he=0,se=1,Ue=be,Re=pe):(he=re*be-pe*le,Ue=q*be-re*le,he<0?(he=0,Ue=be,Re=pe):he>se&&(he=se,Ue=be+re,Re=pe)),Ue<0?(Ue=0,-le<0?he=0:-le>q?he=se:(he=-le,se=q)):Ue>Re&&(Ue=Re,-le+re<0?he=0:-le+re>q?he=se:(he=-le+re,se=q));let lt=0,ht=0;this.IsEqual(he,0)?lt=0:lt=he/se,this.IsEqual(Ue,0)?ht=0:ht=Ue/Re;let yt=N+lt*b-ht*T,wt=Q+lt*D-ht*U,It=H+lt*B-ht*E;return yt*yt+wt*wt+It*It}isNear(e,t=0,r){let i=d.HELP_0,a=d.HELP_1;i.copyFrom(e.origin),a.copyFrom(e.direction),a.scaleBy(9999),a.add(i,a),Qe.cacluteLine0.set(i,a),Qe.cacluteLine1.copyFrom(this),r&&(r.perspectiveMultiplyPoint3(Qe.cacluteLine1.start,Qe.cacluteLine1.start),r.perspectiveMultiplyPoint3(Qe.cacluteLine1.end,Qe.cacluteLine1.end));let s=Qe.squreDistanceSegmentToSegment(Qe.cacluteLine0,Qe.cacluteLine1,r);return s+1e-4<=t?(e.length=s,!0):(e.length=-999999,!1)}}class Pi{static ID=-1;v1;v2;v3;u1;u2;u3;n1;n2;n3;t0;t;u;v;min=new d;max=new d;id=0;constructor(e,t,r){this.id=Pi.ID+++200,e&&t&&r&&this.set(e,t,r)}set(e,t,r){this.v1=e,this.v2=t,this.v3=r;let i=this.min,a=this.max;return i.x=Math.min(this.v1.x,this.v2.x,this.v3.x),i.y=Math.min(this.v1.y,this.v2.y,this.v3.y),i.z=Math.min(this.v1.z,this.v2.z,this.v3.z),a.x=Math.max(this.v1.x,this.v2.x,this.v3.x),a.y=Math.max(this.v1.y,this.v2.y,this.v3.y),a.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let e=this.v1,t=this.v2,r=this.v3,i=new d(t.x-e.x,t.y-e.y,t.z-e.z),s=new d(r.x-e.x,r.y-e.y,r.z-e.z).crossProduct(i);return s.normalize(),s}turnBack(){let e=this.v3;this.v3=this.v1,this.v1=e}getLines(){let e=this.v1,t=this.v2,r=this.v3;return[new Qe(e,t),new Qe(t,r),new Qe(r,e)]}equals(e){let t=this.getLines(),r=e.getLines(),i=0;for(let a=0;a<t.length;a++)for(let s=0;s<r.length;s++)t[a].equals(r[s])&&i++;return i==3}getCenter(){let e=this.min,t=this.max,r=new d;return r.x=(e.x+t.x)*.5,r.y=(e.y+t.y)*.5,r.z=(e.z+t.z)*.5,r}intersects(e){var t=this.max,r=this.min,i=e.max,a=e.min;return r.x<=i.x&&t.x>=a.x&&r.y<=i.y&&t.y>=a.y&&r.z<=i.z&&t.z>=a.z}sign2D(e,t,r){return(e.x-r.x)*(t.z-r.z)-(t.x-r.x)*(e.z-r.z)}pointInTriangle2D(e){let t=this.v1,r=this.v2,i=this.v3,a,s,n,l,h;return a=this.sign2D(e,t,r),s=this.sign2D(e,r,i),n=this.sign2D(e,i,t),l=a<0||s<0||n<0,h=a>0||s>0||n>0,!(l&&h)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}}class Zu{static _pt0;static _pt1;static _pt2;static _pt3;static _hitPoint;static _worldMatrix;static _ray;static _triangle;static _isInit;static init(){this._pt0=new d,this._pt1=new d,this._pt2=new d,this._pt3=new d,this._ray=new _t,this._triangle=new Pi,this._hitPoint=new d,this._worldMatrix=new R}static rayPick(e,t,r,i,a,s,n){this._isInit||(this.init(),this._isInit=!0);let l=this._worldMatrix;if(i==St.World){let h;this.calculateHotArea_World(s,this._pt0,this._pt1,this._pt2,this._pt3),l.copyFrom(n).invert();let u=this._ray;if(u.copy(e).applyMatrix(l),this._triangle.set(this._pt0,this._pt1,this._pt2),h=u.intersectTriangle(u.origin,u.direction,this._triangle),h||(this._triangle.set(this._pt1,this._pt2,this._pt3),h=u.intersectTriangle(u.origin,u.direction,this._triangle)),h)return{distance:0,intersectPoint:h}}else{this.calculateHotArea_View(s,a,this._pt0,this._pt1,this._pt2,this._pt3);let h=r.x,u=r.y,f=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,g=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5,p=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+h*.5,A=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+u*.5;return t.x<=p&&t.x>=f&&t.y<=A&&t.y>=g?(this._hitPoint.set(t.x,t.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(e,t,r,i,a,s){let n=e.getWorldMatrix(),l=n.getScaleX(),h=n.getScaleY(),u=e.width*.5*l,f=e.height*.5*h;r.set(-u,-f,0),i.set(u,-f,0),a.set(-u,f,0),s.set(u,f,0);let g=n.tx;r.x+=g,i.x+=g,a.x+=g,s.x+=g,g=n.ty,r.y-=g,i.y-=g,a.y-=g,s.y-=g,r.multiplyScalar(t),i.multiplyScalar(t),a.multiplyScalar(t),s.multiplyScalar(t)}static calculateHotArea_World(e,t,r,i,a){let s=e.getWorldMatrix(),n=s.getScaleX(),l=s.getScaleY(),h=e.width*.5*n,u=e.height*.5*l;t.set(-h,u,0),r.set(h,u,0),i.set(-h,-u,0),a.set(h,-u,0);let f=s.tx;t.x+=f,r.x+=f,i.x+=f,a.x+=f,f=s.ty,t.y+=f,r.y+=f,i.y+=f,a.y+=f}}var $u=(o=>(o[o.UpperLeft=0]="UpperLeft",o[o.UpperCenter=1]="UpperCenter",o[o.UpperRight=2]="UpperRight",o[o.MiddleLeft=3]="MiddleLeft",o[o.MiddleCenter=4]="MiddleCenter",o[o.MiddleRight=5]="MiddleRight",o[o.LowerLeft=6]="LowerLeft",o[o.LowerCenter=7]="LowerCenter",o[o.LowerRight=8]="LowerRight",o))($u||{}),ec=(o=>(o[o.Upper=0]="Upper",o[o.Middle=1]="Middle",o[o.Lower=2]="Lower",o))(ec||{}),tc=(o=>(o[o.Left=0]="Left",o[o.Center=1]="Center",o[o.Right=2]="Right",o))(tc||{});class rc{charList=[];quadList=[];width=0;index=0}class ic{layout(e){let t=[],r=e.originSize,i=qr.getFontData(e.font,r),a=e.fontSize/r;return this.makeTextLine(e.uiTransform,e.alignment,t,e.font,i,e.text,a,r,e.lineSpacing),t}makeTextLine(e,t,r,i,a,s,n,l,h){let u=-1,f=0,g=l*n,p=g*.5,A=e.width/n,v=e.height/n,C=0,x=e.height,S=()=>{f=0,u++;let B=new rc;return B.index=u,r.push(B),B},y=(B,T)=>{const U=B.charCodeAt(0).toString();let E=qr.getFnt(i,l,U),N=null;return E?(N=Vt.spawnQuad(),N.sprite=E,N.x=(f+E.xoffset)*n-C,N.y=(a.base-E.height-E.yoffset-a.base)*n+x,N.width=E.offsetSize.width*n,N.height=E.offsetSize.height*n,f+=E.xadvance):B==`
`||(B=="	"?f+=g:f+=p),T.width=f,T.quadList.push(N),T.charList.push(B),N},b=()=>{let B=this.getAlignment(t);switch(B.v){case 0:for(let T=0,U=r.length;T<U;T++){let E=r[T];if(T>0){let N=T*g*h;for(let Q=0,H=E.quadList.length;Q<H;Q++){let q=E.quadList[Q];q&&(q.y-=N)}}}break;case 1:for(let T=0,U=r.length;T<U;T++){let E=r[T],N=(v-U*l*h)*.5*n+T*g*h;for(let Q=0,H=E.quadList.length;Q<H;Q++){let q=E.quadList[Q];q&&(q.y-=N)}}break;case 2:for(let T=0,U=r.length;T<U;T++){let E=r[T],N=(v-U*l*h)*n+T*g*h;for(let Q=0,H=E.quadList.length;Q<H;Q++){let q=E.quadList[Q];q&&(q.y-=N)}}break}switch(B.h){case 0:break;case 1:for(let T=0,U=r.length;T<U;T++){let E=r[T],N=(A-E.width)*.5*n;for(let Q=0,H=E.quadList.length;Q<H;Q++){let q=E.quadList[Q];q&&(q.x+=N)}}break;case 2:for(let T=0,U=r.length;T<U;T++){let E=r[T],N=(A-E.width)*n;for(let Q=0,H=E.quadList.length;Q<H;Q++){let q=E.quadList[Q];q&&(q.x+=N)}}break}};(()=>{let B=null,T=s.length;for(let U=0;U<T;U++){B||=S();let E=s.charAt(U);E==`
`||E=="	"?B=null:(y(E,B),B.width+p>=A&&(B=S()))}})(),b()}getAlignment(e){let t={v:0,h:0};switch(e){case 1:t.v=0,t.h=1;break;case 0:t.v=0,t.h=0;break;case 2:t.v=0,t.h=2;break;case 4:t.v=1,t.h=1;break;case 3:t.v=1,t.h=0;break;case 5:t.v=1,t.h=2;break;case 7:t.v=2,t.h=1;break;case 6:t.v=2,t.h=0;break;case 8:t.v=2,t.h=2;break}return t}}class Ta extends Ws{_style=Se.NORMAL;_interactive=!1;set interactive(e){this._interactive=e}get interactive(){return this._interactive}set mouseStyle(e){this._style=e}get interactiveVisible(){return this._uiTransform.globalVisible&&this._visible}init(e){super.init(e),this._uiTransform.addUIInteractive(this)}destroy(){this._uiTransform.removeUIInteractive(this),super.destroy()}rayPick(e,t,r,i){return Zu.rayPick(e,r,i,t.space,t.panelRatio,this._uiTransform,t.transform.worldMatrix)}cloneTo(e){e.getOrAddComponent(Ta).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.enable=e._enable,this.interactive=e._interactive,this.mouseStyle=e._style,this}}var ac=(o=>(o[o.NONE=0]="NONE",o[o.COLOR=1]="COLOR",o[o.SPRITE=2]="SPRITE",o))(ac||{});class qs extends Ta{_spriteMap;_colorMap;_image;_isCreateImage;_transition=2;init(e){super.init(e),this._interactive=!0,this._spriteMap=new Map,this._colorMap=new Map,this._image=this.object3D.getComponent(Or),this._isCreateImage=this._image==null,this._image||(this._image=this.object3D.addComponent(Or)),this.imageType=Kr.Sliced}onEnable(){this.mouseStyle=Se.NORMAL}onDisable(){this.mouseStyle=Se.DISABLE}set transition(e){this._transition!=e&&(this._transition=e,this.validateStyle(this._style,!0))}get transition(){return this._transition}get imageType(){return this._image.imageType}set imageType(e){this._image.imageType=e}setStyleColor(e,t){return this._colorMap.set(e,t),this._style==e&&this.validateStyle(this._style,!0),this}getStyleColor(e){return this._colorMap.get(e)}set mouseStyle(e){super.mouseStyle=e,this.validateStyle(e,!0)}get normalSprite(){return this._spriteMap.get(Se.NORMAL)}set normalSprite(e){this._spriteMap.set(Se.NORMAL,e),this._style==Se.NORMAL&&this.validateStyle(this._style,!0)}get overSprite(){return this._spriteMap.get(Se.OVER)}set overSprite(e){this._spriteMap.set(Se.OVER,e),this._style==Se.OVER&&this.validateStyle(this._style,!0)}set downSprite(e){this._spriteMap.set(Se.DOWN,e),this._style==Se.DOWN&&this.validateStyle(this._style,!0)}get downSprite(){return this._spriteMap.get(Se.DOWN)}set disableSprite(e){this._spriteMap.set(Se.DISABLE,e),this._style==Se.DISABLE&&this.validateStyle(this._style,!0)}get disableSprite(){return this._spriteMap.get(Se.DISABLE)}validateStyle(e,t){if(this._transition&2){let r=this._spriteMap.get(e);this._image.sprite=r}if(this._transition&1){let r=this._colorMap.get(e);r&&(this._image.color=r)}}cloneTo(e){e.getOrAddComponent(qs).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.imageType=e.imageType,this.transition=e.transition,e._spriteMap.forEach((t,r)=>{t&&this._spriteMap.set(r,t)}),e._colorMap.forEach((t,r)=>{t&&this._colorMap.set(r,t.clone())}),this.mouseStyle=e.mouseStyle,this}destroy(){this._isCreateImage&&this._image&&(this.object3D.removeComponent(Or),this._image=null),super.destroy()}}class Ks extends Ti{_count=0;constructor(){super()}init(e){super.init?.(e),this._count=e?e.count:1;for(let t=0;t<this._count;t++)this.attachQuad(Vt.spawnQuad());this._uiTransform.resize(0,0)}getQuad(e){return this._mainQuads[e]}cloneTo(e){e.addComponent(Ks,{count:this._count}).copyComponent(this)}copyComponent(e){super.copyComponent(e);for(let t=0;t<e._count;t++)this.setSprite(t,e.getSprite(t)),this.setColor(t,e.getColor(t)),this.setImageType(t,e.getImageType(t));return this}setSprite(e,t){this._mainQuads[e].sprite=t||m.res.defaultGUISprite,this.setShadowDirty()}getSprite(e){return this._mainQuads[e].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t.visible=!e;this.setShadowDirty()}getColor(e){return this._mainQuads[e].color}setColor(e,t){this._mainQuads[e].color=t,this.setShadowDirty()}getImageType(e){return this._mainQuads[e].imageType}setImageType(e,t){this._mainQuads[e].imageType=t,this.setShadowDirty()}setSize(e,t,r){this._mainQuads[e].setSize(t,r),this.setShadowDirty()}setXY(e,t,r){this._mainQuads[e].setXY(t,r),this.setShadowDirty()}getXY(e,t){t||=new V;let r=this._mainQuads[e];return t.x=r.x,t.y=r.y,t}}class Js extends Ti{_shadowQuality=1;_shadowOffset;_shadowRadius;_shadowColor;_subShadowColor;needUpdateShadow=!1;init(e){super.init?.(e),this._shadowRadius=2,this._shadowQuality=1,this._shadowOffset=new V(4,-4),this._shadowColor=new P(.1,.1,.1,.8),this._subShadowColor=this._shadowColor.clone(),this.isUIShadow=!0}cloneTo(e){e.getOrAddComponent(Js).copyComponent(this)}copyComponent(e){return super.copyComponent(this),this._shadowColor=e._shadowColor,this._shadowOffset=e._shadowOffset,this._shadowRadius=e._shadowRadius,this._shadowQuality=e.shadowQuality,this}get shadowColor(){return this._shadowColor}set shadowColor(e){this._shadowColor.copyFrom(e),this.needUpdateShadow=!0}set shadowQuality(e){e=j(e,0,4),this._shadowQuality!=e&&(this._shadowQuality=e,this.needUpdateShadow=!0)}get shadowQuality(){return this._shadowQuality}set shadowOffset(e){this._shadowOffset=e,this.needUpdateShadow=!0}get shadowOffset(){return this._shadowOffset||=new V(4,-4),this._shadowOffset}set shadowRadius(e){this._shadowRadius!=e&&(this._shadowRadius=e,this.applyShadow())}get shadowRadius(){return this._shadowRadius}onUpdate(e){this.needUpdateShadow&&(this.applyShadow(),this.needUpdateShadow=!1)}applyShadow(){if(this.detachQuads(),this._shadowSource&&this._shadowQuality>0){let e=this._shadowSource.mainQuads;if(e.length>0)for(let t of e)this.createQuadShadow(t)}this._uiTransform.setNeedUpdateUIPanel()}createQuadShadow(e){let t=this._shadowQuality,r=Math.PI*2;this._subShadowColor.copyFrom(this._shadowColor),this._subShadowColor.a=1/Math.max(1,t);for(let i=0;i<t;i++){let a=Vt.spawnQuad(),s=0,n=0;if(i==0)a.color=this._shadowColor;else{let l=r*(i-1)/(t-1);s=Math.sin(l)*this._shadowRadius,n=Math.cos(l)*this._shadowRadius,a.color=this._subShadowColor}a.setXY(s+this._shadowOffset.x+e.x,n+this._shadowOffset.y+e.y),a.setSize(e.width,e.height),a.sprite=e.sprite,a.visible=e.visible,a.imageType=e.imageType,this.attachQuad(a)}}}class Zs extends Ti{_font="\u5FAE\u8F6F\u96C5\u9ED1";_fontSize=14;_originSize=42;_alignment=0;_lineSpacing=1;_text="";_color=new P(1,1,1,1);constructor(){super()}cloneTo(e){e.getOrAddComponent(Zs).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this._font=e._font,this._fontSize=e._fontSize,this._originSize=e._originSize,this._alignment=e._alignment,this._lineSpacing=e._lineSpacing,this._color.copyFrom(e._color),this.text=e.text,this}get originSize(){return this._originSize}get font(){return this._font}set font(e){this._font=e}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!=e&&(this._fontSize=e,this.layoutText())}get text(){return this._text}set text(e){this._text!=e&&(e||(e=""),this._text=e,this.layoutText())}textLine=null;layoutProxy=new ic;layoutText(){this.detachQuads(),this.textLine=this.layoutProxy.layout(this);for(let e=0,t=this.textLine.length;e<t;e++){let r=this.textLine[e];for(let i=0,a=r.quadList.length;i<a;i++){let s=r.quadList[i];s&&this.attachQuad(s)}}this.color=this._color,this._uiTransform.setNeedUpdateUIPanel(),this.onUIComponentVisible(this._visible),this.setShadowDirty()}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let t of this._mainQuads)t&&(t.visible=!e);this.setShadowDirty()}onTransformResize(){this.layoutText()}get color(){return this._color}set color(e){this._color.copyFrom(e);for(let t of this._mainQuads)t.color=e;this.setShadowDirty()}get alignment(){return this._alignment}set alignment(e){this._alignment!=e&&(this._alignment=e,this.layoutText())}get lineSpacing(){return this._lineSpacing}set lineSpacing(e){this._lineSpacing!=e&&(this._lineSpacing=e,this.layoutText())}}var qg=Object.defineProperty,Kg=Object.getOwnPropertyDescriptor,Jg=(o,e,t,r)=>{for(var i=r>1?void 0:r?Kg(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&qg(e,t,i),i};c.Light=class extends xi{constructor(){super()}init(){super.init(),this.lightData.lightType=Ee.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+dt())}get range(){return this.lightData.range}set range(e){this.lightData.range=e,this.onChange()}get at(){return this.lightData.linear}set at(e){this.lightData.linear=e,this.onChange()}get radius(){return this.lightData.radius}set radius(e){this.lightData.radius=e,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(e){this.lightData.quadratic=e,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(e){let t=e.graphic3D.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);t.buildAxis(),t.buildCircle(d.ZERO,this.range,32,d.X_AXIS),t.buildCircle(d.ZERO,this.range,32,d.Y_AXIS),t.buildCircle(d.ZERO,this.range,32,d.Z_AXIS)}debug(){}debugDraw(e){}},c.Light=Jg([mt(c.Light,"Light")],c.Light);class sc extends c.Object3D{index=0;drawCallFrame=-1;constructor(){super()}}var $s=(o=>(o[o.CastGI=0]="CastGI",o[o.ReceiveGI=1]="ReceiveGI",o[o.CastDepth=2]="CastDepth",o[o.Other=3]="Other",o))($s||{});class oc extends We{static count=0;constructor(e=0,t=0){super(),F.register("GIProbeShader",Iu);let r=new ke,i=new Ae("GIProbeShader","GIProbeShader");i.passType=W.COLOR,r.addRenderPass(i),i.setDefine("USE_BRDF",!0),i.setShaderEntry("VertMain","FragMain"),i.setUniformVector4("probeUniform",new G(t,e,0,0));let a=i.shaderState;a.acceptShadow=!1,a.castShadow=!1,a.receiveEnv=!1,a.acceptGI=!1,a.useLight=!1,r.setTexture("baseMap",m.res.whiteTexture),r.setTexture("normalMap",m.res.normalTexture),r.setTexture("emissiveMap",m.res.blackTexture),this.shader=r}}class Zg extends _e{_probes;_volume;_debugMr=[];init(){m.setting.gi.enable=!0}start(){this._volume=ae.getLightEntries(this.transform.scene3D).irradianceVolume,this.initProbe()}initProbe(){let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,i=new Si(4,16,16),a=new d;this._probes=[];for(let s=0;s<e;s++)for(let n=0;n<t;n++)for(let l=0;l<r;l++){let h=s+l*e+n*(e*r),u=new sc;u.index=h,u.name=`${s}_${n}_${l}`;let f=u.addComponent(c.MeshRenderer);f.material=new oc($s.CastGI,h),f.geometry=i,f.castGI=!1,f.castShadow=!1,this._debugMr.push(f),this.object3D.addChild(u),this._volume.calcPosition(s,n,l,a),u.x=a.x,u.y=a.y,u.z=a.z,this._probes[h]=u,this._debugMr.push(f)}for(let s=0;s<this._probes.length;s++)k.instance.addGIProbe(this.transform.scene3D,this._probes[s]);this.object3D.transform.enable=!1,this._volume.setting.debug&&this.debug()}debug(){}debugProbeRay(e,t){const r=m.setting.gi.rayNumber;let i=new Y(0,-.7071067811865475,.7071067811865475,0);for(let a=0;a<r;a++){let s=e*r+a,n=new d(-t[s*4+0],-t[s*4+1],-t[s*4+2],0);i.transformVector(n,n);let l=t[s*4+3],h=this._probes[e].transform.worldPosition.clone(),u=n.scaleBy(l);u.add(h,u)}}changeProbesVolumeData(){this._volume.setVolumeDataChange()}changeProbesPosition(){this._volume.setVolumeDataChange();let e=this._volume.setting.probeXCount,t=this._volume.setting.probeYCount,r=this._volume.setting.probeZCount,i=new d;for(let a=0;a<e;a++)for(let s=0;s<t;s++)for(let n=0;n<r;n++){let l=a+n*e+s*(e*r),h=this._probes[l];this._volume.calcPosition(a,s,n,i),h.x=i.x,h.y=i.y,h.z=i.z}}onUpdate(){m.setting.gi.maxDistance=m.setting.gi.probeSpace*1.5;let e=this.transform.scene3D.view.camera,t=d.distance(e.transform.worldPosition,e.transform.targetPos)/300;if(this._debugMr&&this._debugMr.length>0)for(let r=0;r<this._debugMr.length;r++){const i=this._debugMr[r].transform;i.scaleX=t,i.scaleY=t,i.scaleZ=t}}}class $g extends er{_keyRenderGroup;_keyBufferGroup;_keyIdsGroup;init(e){this._keyRenderGroup=new Map,this._keyBufferGroup=new Map,this._keyIdsGroup=new Map}start(){let e=[];this.object3D.getComponents(c.MeshRenderer,e,!0);for(let t=0;t<e.length;t++){const r=e[t];r.transform.updateWorldMatrix(!0),r.enable=!1;let i=r.geometry.instanceID;for(let a=0;a<r.materials.length;a++){const s=r.materials[a];i+=s.instanceID}if(this._keyRenderGroup.has(i))this._keyRenderGroup.get(i).push(r),this._keyIdsGroup.get(i).push(r.transform.worldMatrix.index);else{let a=new Z(e.length);a.visibility=GPUShaderStage.VERTEX,this._keyRenderGroup.set(i,[r]),this._keyBufferGroup.set(i,a),this._keyIdsGroup.set(i,[r.transform.worldMatrix.index])}}this._keyBufferGroup.forEach((t,r)=>{let i=this._keyIdsGroup.get(r),a=this._keyBufferGroup.get(r);a.setInt32Array("matrixIDs",new Int32Array(i)),a.apply()})}stop(){}nodeUpdate(e,t,r,i){this._keyRenderGroup.forEach((a,s)=>{let n=this._keyBufferGroup.get(s),l=a[0];for(let h=0;h<l.materials.length;h++){let f=l.materials[h].getPass(t);if(f)for(let g=0;g<f.length;g++){const p=f[g];p.setDefine("USE_INSTANCEDRAW",!0),p.setStorageBuffer("instanceDrawID",n)}}l.nodeUpdate(e,t,r,i)}),this.preInit=!1}renderPass(e,t,r){this._keyRenderGroup.forEach((i,a)=>{let s=i[0];s.instanceCount=i.length,this.renderItem(e,t,s,r)})}renderItem(e,t,r,i){let a=r.transform._worldMatrix;for(let s=0;s<r.materials.length;s++){let l=r.materials[s].getPass(t);if(!(!l||l.length==0))for(let h=0;h<l.length;h++){if(!l||l.length==0)continue;let u=l[h];w.bindGeometryBuffer(i.encoder,r.geometry);const f=u;f.shaderState.splitTexture&&(i.endRenderPass(),ye.WriteSplitColorTexture(r.instanceID),i.beginOpaqueRenderPass(),w.bindCamera(i.encoder,e.camera),w.bindGeometryBuffer(i.encoder,r.geometry)),w.bindPipeline(i.encoder,f);let v=r.geometry.subGeometries[s].lodLevels[r.lodLevel];r.instanceCount>0?w.drawIndexed(i.encoder,v.indexCount,r.instanceCount,v.indexStart,0,0):w.drawIndexed(i.encoder,v.indexCount,1,v.indexStart,0,a.index)}}}}var ep=Object.defineProperty,tp=Object.getOwnPropertyDescriptor,rp=(o,e,t,r)=>{for(var i=r>1?void 0:r?tp(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&ep(e,t,i),i};c.MeshFilter=class extends c.MeshRenderer{constructor(){super()}get geometry(){return null}set geometry(e){}cloneTo(e){}set meshURL(e){let t=m.res.getGeometry(e);t?this.geometry=t:console.error("no geometry set",e)}},c.MeshFilter=rp([mt(c.MeshFilter,"MeshFilter")],c.MeshFilter);class ip extends Me{radius=2.5;height=10;constructor(){super(),this._shapeType=Jr.Capsule}}class Da extends Me{mesh;static triangle;_pickRet;constructor(){super(),this._shapeType=Jr.Mesh}rayPick(e,t){if(this.mesh){Da.triangle||=new Pi(new d,new d,new d);let r=this.mesh.getAttribute("position"),i=this.mesh.getAttribute("indices"),a=Me.helpMatrix;a.copyFrom(t).invert();let s=Me.helpRay.copy(e);if(s.applyMatrix(a),s.intersectBox(this.mesh.bounds),!s.intersectBox(this.mesh.bounds,Me.v3_help_0))return null;if(i&&r&&i.data.length>0){let l=r.data;for(let h=0,u=i.data.length/3;h<u;h++){let f=h*3;const g=i.data[f+0]*3,p=i.data[f+1]*3,A=i.data[f+2]*3;let v=Da.triangle,C=v.v1.set(l[g+0],l[g+1],l[g+2]),x=v.v2.set(l[p+0],l[p+1],l[p+2]),S=v.v3.set(l[A+0],l[A+1],l[A+2]);v.set(C,x,S);let y=s.intersectTriangle(s.origin,s.direction,v);if(y)return this._pickRet||={intersectPoint:new d,distance:0},this._pickRet.intersectPoint=y,this._pickRet.distance=d.distance(s.origin,y),this._pickRet}}}return null}}class Pa{center=new d;extents;max;min;size;tmpVecA=new d;tmpVecB=new d;tmpVecC=new d;tmpVecD=new d;radius=0;diffBetweenPoints=new d;owner;forward=new d(0,0,1);worldCenter;worldSize;_center=new d;constructor(e,t){this.center=e||new d(0,0,0),this.radius=t===void 0?.5:t}updateBound(){throw new Error("Method not implemented.")}containsPoint(e){var t=this.tmpVecA.subtract(e,this.center).lengthSquared,r=this.radius;return t<r*r}intersectsRay(e,t){var r=this.tmpVecA.copyFrom(e.origin).subtract(this.center),i=r.dotProduct(this.tmpVecB.copyFrom(e.direction).normalize()),a=r.dotProduct(r)-this.radius*this.radius;if(a>0&&i>0)return null;var s=i*i-a;if(s<0)return!1;var n=Math.abs(-i-Math.sqrt(s));return t&&t.copyFrom(e.direction).scaleBy(n).add(e.origin),!0}intersectsBoundingSphere(e){this.tmpVecA.subtract(e.center,this.center);var t=e.radius+this.radius;return this.tmpVecA.lengthSquared<=t*t}calculateTransform(e){this.update(e)}inFrustum(e,t){return t.containsSphere(e)}clone(){return new Pa(this.center.clone(),this.radius)}update(e){this.owner=e,this._center.add(e.transform.worldMatrix.position,this.center),this.forward=e.transform.forward}merge(e){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(e,t){this.center.copy(e),this.radius=t}}class ap extends Me{_pickRet;box;radius=.5;constructor(e){super(),this._shapeType=Jr.Sphere,this.radius=e,this.box=new Pa(new d,1)}rayPick(e,t){this.box.setFromCenterAndSize(this.center,this.radius);let i=Me.helpMatrix;i.copyFrom(t).invert();let a=Me.helpRay.copy(e);a.applyMatrix(i);let s=a.intersectSphere(a.origin,a.direction,this.box.center,this.box.radius);return s?(this._pickRet||(this._pickRet={intersect:!1,intersectPoint:new d,distance:0}),this._pickRet.intersect=!0,this._pickRet.intersectPoint=s,this._pickRet.distance=d.distance(a.origin,Me.v3_help_0),this._pickRet):null}}class sp extends c.Object3D{_envMap;skyObject;envMapChange=!0;view;constructor(){super(),this.transform.scene3D=this,this.skyObject=new c.Object3D,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||=m.res.defaultSky}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,k.instance.sky&&"map"in k.instance.sky&&(k.instance.sky.map=e)}get exposure(){return k.instance.sky&&"exposure"in k.instance.sky?k.instance.sky.exposure:0}set exposure(e){k.instance.sky&&"exposure"in k.instance.sky&&(k.instance.sky.exposure=e,m.setting.sky.skyExposure=e)}get roughness(){if(k.instance.sky&&"roughness"in k.instance.sky)return k.instance.sky.roughness}set roughness(e){k.instance.sky&&"roughness"in k.instance.sky&&(k.instance.sky.roughness=e)}}class nc extends fa{constructor(){super(3,ii.triangle_list)}}class lc extends fa{constructor(){super(2,ii.line_list)}}class hc extends c.Object3D{mLineRender;mFillRender;constructor(){super(),this.mLineRender=this.addComponent(lc),this.mFillRender=this.addComponent(nc)}drawAxis(e,t=new d(0,0,0),r=10){this.createCustomShape(e).buildAxis(t,r)}drawLines(e,t,r=P.COLOR_WHITE){this.createCustomShape(e).buildLines(t,r)}drawCurve(e,t,r=10,i=.5,a=P.COLOR_WHITE){var s=[];let n=new d,l=new d;for(let h=0;h<t.length-1;++h){s.push(t[h]);const u=t[Math.max(h-1,0)],f=t[h],g=t[h+1],p=t[Math.min(h+2,t.length-1)];g.subtract(u,n).multiplyScalar(i/3).add(f,n),f.subtract(p,l).multiplyScalar(i/3).add(g,l),s.push(...this.calculateBezierCurve(f,n,l,g,r))}s.push(t[t.length-1]),this.drawLines(e,s,a)}calculateBezierCurve(e,t,r,i,a){var s=new Array(a);for(let n=0;n<a;++n){let l=(n+1)/(a+1),h=1-l,u=e.mul(h*h*h),f=t.mul(3*l*h*h),g=r.mul(3*l*l*h),p=i.mul(l*l*l);s[n]=u.add(f).add(g).add(p)}return s}drawRect(e,t,r,i,a=P.COLOR_WHITE){this.drawLines(e,[t,new d(t.x+r,t.y,t.z),new d(t.x+r,t.y+i,t.z),new d(t.x,t.y+i,t.z),t],a)}drawCircle(e,t,r,i=32,a=d.Y_AXIS,s=P.COLOR_WHITE){this.createCustomShape(e).buildCircle(t,r,i,a,s)}drawSector(e,t,r,i,a,s=16,n=d.Y_AXIS,l=P.COLOR_WHITE){const h=(a-i)*ge;i*=ge;var u=[];u.push(t);for(let A=0;A<=s;++A){A>0&&u.push(u[u.length-1]);var f=h*(A/s)+i,g=r*Math.cos(f),p=r*Math.sin(f);switch(n){case d.X_AXIS:u.push(t.add(new d(0,g,p)));break;case d.Y_AXIS:u.push(t.add(new d(g,0,p)));break;case d.Z_AXIS:u.push(t.add(new d(g,p,0)));break;default:u.push(t.add(new d(g,p,0)));break}}u.push(u[u.length-1]),u.push(t),this.mLineRender.fillShapeData(e,"line",l,u)}drawArcLine(e,t,r,i,a,s=16,n=d.Y_AXIS,l=P.COLOR_WHITE){this.mLineRender.allocGraphics3DShape(e,this.transform._worldMatrix.index).buildArcLine(t,r,i,a,s,n,l)}createCustomShape(e,t=this.transform){return this.mLineRender.allocGraphics3DShape(e,t._worldMatrix.index)}drawBox(e,t,r,i=P.COLOR_WHITE){var a=[];a.push(t),a.push(new d(r.x,t.y,t.z)),a.push(a[a.length-1]),a.push(new d(r.x,r.y,t.z)),a.push(a[a.length-1]),a.push(new d(t.x,r.y,t.z)),a.push(a[a.length-1]),a.push(t),a.push(a[a.length-1]),a.push(new d(t.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new d(r.x,t.y,r.z)),a.push(a[a.length-1]),a.push(new d(r.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new d(t.x,r.y,r.z)),a.push(a[a.length-1]),a.push(new d(t.x,t.y,r.z)),a.push(new d(t.x,r.y,t.z)),a.push(new d(t.x,r.y,r.z)),a.push(new d(r.x,r.y,t.z)),a.push(new d(r.x,r.y,r.z)),a.push(new d(r.x,t.y,t.z)),a.push(new d(r.x,t.y,r.z)),this.mLineRender.fillShapeData(e,"line",i,a)}drawFillRect(e,t,r,i,a=P.COLOR_WHITE){this.mFillRender.fillShapeData(e,"fill",a,[t,new d(t.x+r,t.y,t.z),new d(t.x+r,t.y,t.z+i),new d(t.x+r,t.y,t.z+i),new d(t.x,t.y,t.z+i),t])}drawFillCircle(e,t,r,i=32,a=d.Y_AXIS,s=P.COLOR_WHITE){var n=[];n.push(t);for(let f=0;f<=i;++f){f>=2&&(n.push(t),n.push(n[n.length-2]));var l=2*Math.PI*f/i,h=r*Math.cos(l),u=r*Math.sin(l);switch(a){case d.X_AXIS:n.push(t.add(new d(0,h,u)));break;case d.Y_AXIS:n.push(t.add(new d(h,0,u)));break;case d.Z_AXIS:n.push(t.add(new d(h,u,0)));break;default:n.push(t.add(new d(h,u,0)));break}}this.mFillRender.fillShapeData(e,"fill",s,n)}drawMeshWireframe(e,t,r,i=P.COLOR_WHITE,a=!1){t&&this.createCustomShape(e,r||this.transform).fillShapeData(t.genWireframe(),i,a)}drawFillSector(e,t,r,i,a,s=16,n=d.Y_AXIS,l=P.COLOR_WHITE){const h=(a-i)*ge;i*=ge;var u=[];u.push(t);for(let A=0;A<=s;++A){A>=2&&(u.push(t),u.push(u[u.length-2]));var f=h*(A/s)+i,g=r*Math.cos(f),p=r*Math.sin(f);switch(n){case d.X_AXIS:u.push(t.add(new d(0,g,p)));break;case d.Y_AXIS:u.push(t.add(new d(g,0,p)));break;case d.Z_AXIS:u.push(t.add(new d(g,p,0)));break;default:u.push(t.add(new d(g,p,0)));break}}this.mFillRender.fillShapeData(e,"fill",l,u)}drawBoundingBox(e,t,r=P.COLOR_WHITE){this.drawBox(e,t.min,t.max,r)}drawCameraFrustum(e,t=P.COLOR_WHITE){if(e.type==me.perspective){let r=Math.tan(e.fov/2*ge),i=r*e.aspect,a=e.transform._worldMatrix,s=a.transformVector(new d(-i,-r,1)),n=a.transformVector(new d(-i,r,1)),l=a.transformVector(new d(i,-r,1)),h=a.transformVector(new d(i,r,1)),u=e.far,f=e.near,g=e.transform.worldPosition,p=new d().copyFrom(s).multiplyScalar(u).add(g),A=new d().copyFrom(n).multiplyScalar(u).add(g),v=new d().copyFrom(l).multiplyScalar(u).add(g),C=new d().copyFrom(h).multiplyScalar(u).add(g),x=new d().copyFrom(s).multiplyScalar(f).add(g),S=new d().copyFrom(n).multiplyScalar(f).add(g),y=new d().copyFrom(l).multiplyScalar(f).add(g),b=new d().copyFrom(h).multiplyScalar(f).add(g),D=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);D.buildLines([S,A],t),D.buildLines([x,p],t),D.buildLines([b,C],t),D.buildLines([y,v],t),D.buildLines([A,C,v,p,A],t),D.buildLines([S,b,y,x,S],t)}else if(e.type==me.ortho){e.viewPort,e.viewPort.height;let r=e.transform.worldMatrix,i=r.transformVector(new d(e.viewPort.width*-.5,e.viewPort.height*.5,e.far)),a=r.transformVector(new d(e.viewPort.width*-.5,e.viewPort.height*-.5,e.far)),s=r.transformVector(new d(e.viewPort.width*.5,e.viewPort.height*.5,e.far)),n=r.transformVector(new d(e.viewPort.width*.5,e.viewPort.height*-.5,e.far)),l=r.transformVector(new d(e.viewPort.width*-.5,e.viewPort.height*.5,e.near)),h=r.transformVector(new d(e.viewPort.width*-.5,e.viewPort.height*-.5,e.near)),u=r.transformVector(new d(e.viewPort.width*.5,e.viewPort.height*.5,e.near)),f=r.transformVector(new d(e.viewPort.width*.5,e.viewPort.height*-.5,e.near)),g=this.createCustomShape(`CameraFrustum_${e.object3D.instanceID}`);g.buildLines([l,i],t),g.buildLines([h,a],t),g.buildLines([u,s],t),g.buildLines([f,n],t),g.buildLines([i,s,n,a,i],t),g.buildLines([l,u,f,h,l],t)}}drawObjectBoundingBox(e,t=P.COLOR_WHITE){let r=na.genMeshBounds(e);this.drawBox(`Bounds_${e.instanceID}`,r.min,r.max,t)}Clear(e){this.mLineRender.shapes.has(e)?this.mLineRender.removeShape(e):this.mFillRender.shapes.has(e)&&this.mFillRender.removeShape(e)}ClearAll(){this.mLineRender.shapes.clear(),this.mFillRender.shapes.clear()}ChangeColor(e,t){var r;if(this.mLineRender.shapes.has(e))r=this.mLineRender.shapes.get(e);else if(this.mFillRender.shapes.has(e))r=this.mFillRender.shapes.get(e);else return;const i=r.colorData;for(let a=0;a<i.length;a+=4)i[a+0]=t.r,i[a+1]=t.g,i[a+2]=t.b,i[a+3]=t.a}}class uc{_computeShader;_outBuffer;constructor(){}init(){let e=we.getGBufferFrame("ColorPassGBuffer");this._computeShader=new ie(cu),this._outBuffer=new Xr(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("visibleMap",e.getPositionMap())}compute(e){let t=ae.getCameraGroup(e.camera);this._computeShader.setStorageBuffer("globalUniform",t.uniformGPUBuffer);let r=w.beginCommandEncoder();w.computeCommand(r,[this._computeShader]),w.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var e=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(e)}getPickWorldPosition(e){e||=new d;var t=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],i=this._outBuffer.outFloat32Array[6];return e.set(t,r,i),e}getPickScreenUV(e){e||=new V;var t=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return e.set(t,r),e}}class cc extends Xt{ray;isTouching=!1;_mouseCode;_pickEvent;_outEvent;_overEvent;_upEvent;_downEvent;_mouseMove;_pickCompute;_lastDownTarget;mouseEnableMap;_view;constructor(e){super(),this._view=e,this.init()}init(){this.ray=new _t,this.mouseEnableMap=new Map,this._pickEvent=new L(L.PICK_CLICK),this._outEvent=new L(L.PICK_OUT),this._overEvent=new L(L.PICK_OVER),this._mouseMove=new L(L.PICK_MOVE),this._upEvent=new L(L.PICK_UP),this._downEvent=new L(L.PICK_DOWN)}start(){m.setting.pick.enable&&(m.inputSystem.addEventListener(L.POINTER_DOWN,this.onTouchStart,this),m.inputSystem.addEventListener(L.POINTER_UP,this.onTouchEnd,this),m.inputSystem.addEventListener(L.POINTER_CLICK,this.onTouchOnce,this),m.inputSystem.addEventListener(L.POINTER_MOVE,this.onTouchMove,this)),m.setting.pick.mode=="pixel"&&(this._pickCompute=new uc,this._pickCompute.init())}stop(){m.inputSystem.removeEventListener(L.POINTER_DOWN,this.onTouchStart,this),m.inputSystem.removeEventListener(L.POINTER_UP,this.onTouchEnd,this),m.inputSystem.removeEventListener(L.POINTER_CLICK,this.onTouchOnce,this),m.inputSystem.removeEventListener(L.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=t,t&&(this._downEvent.target=t.object3D,this._downEvent.ctrlKey=e.ctrlKey,this._downEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._downEvent),t.object3D.containEventListener(L.PICK_DOWN)&&t.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._upEvent.target=t.object3D,this._upEvent.ctrlKey=e.ctrlKey,this._upEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._upEvent),t.object3D.containEventListener(L.PICK_UP)&&t.object3D.dispatchEvent(this._upEvent))}_lastFocus;getPickInfo(){return{worldPos:this._pickCompute.getPickWorldPosition(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);t&&(this._mouseMove.target=t.object3D,this._mouseMove.ctrlKey=e.ctrlKey,this._mouseMove.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._mouseMove),t.object3D.containEventListener(L.PICK_MOVE)&&t.object3D.dispatchEvent(this._mouseMove)),t!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(this._outEvent.target=this._lastFocus.object3D,this._outEvent.data={pick:this._lastFocus,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this._outEvent.ctrlKey=e.ctrlKey,this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(L.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),t&&(this._overEvent.target=t.object3D,this._overEvent.ctrlKey=e.ctrlKey,this._overEvent.data={pick:t,pickInfo:this.getPickInfo(),mouseCode:this._mouseCode},this.dispatchEvent(this._overEvent),t.object3D.containEventListener(L.PICK_OVER)&&t.object3D.dispatchEvent(this._overEvent))),this._lastFocus=t}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let t=this.findNearestObj(this._interestList,this._view.camera);if(t){let r=m.setting.pick.mode=="pixel"?this.getPickInfo():null;this._pickEvent.target=t.object3D,this._pickEvent.ctrlKey=e.ctrlKey,this._pickEvent.data={pick:t,pickInfo:r,mouseCode:this._mouseCode},this.dispatchEvent(this._pickEvent),t===this._lastDownTarget&&t.object3D.containEventListener(L.PICK_CLICK)&&t.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,t){return e.sort((r,i)=>r.distance>i.distance?1:-1),e[0]?.collider}_interestList=[];pick(e){if(this._interestList.length=0,m.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let t=this._pickCompute.getPickMeshID(),r=this.mouseEnableMap.get(t);if(r){let i=this._pickCompute.getPickWorldPosition(),a=d.distance(i,this.ray.origin);this._interestList.push({distance:a,collider:r,intersectPoint:i})}}else if(m.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY);let t,r=oe.componentsEnablePickerList.get(this._view);if(r)for(const i of r){let a=i[0];a.enable&&(t=a.rayPick(this.ray),t&&(t.collider=a,this._interestList.push(t)))}}}}class op extends ea{_camera;_scene;_viewPort;_enablePick=!1;_enable=!0;pickFire;guiPick;canvasList;graphic3D;constructor(e=0,t=0,r=0,i=0){super(),this.canvasList=[],this._viewPort=new G(e,t,r,i),this.graphic3D=new hc}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new cc(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,ot.createBuffer(this),this.graphic3D&&e.addChild(this.graphic3D),e&&this.canvasList.forEach(t=>{t&&e.addChild(t.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let t=this.canvasList[e];if(!t){let r=new c.Object3D;r.name="Canvas "+e,t=r.addComponent(Bi),t.index=e,this.canvasList[e]=t}return this.scene.addChild(t.object3D),this.guiPick||(this.guiPick=new qu,this.guiPick.init(this)),t}disableUICanvas(e=0){let t=this.canvasList[e];t&&t.object3D&&t.object3D.removeFromParent()}}class np{normal;fixNormal;center;rotateShape;distance=0;index;constructor(e){this.index=e,this.rotateShape=[]}}class lp extends ve{vScale;uNegate;sections;build(e,t,r,i=1,a=!0){if(r.length<2)throw new Error("path length is not enough");return this.vScale=i,this.uNegate=a,e=e.slice(),t&&e.push(e[0]),this.sections=this.buildSections(e,r),this.buildGeometry(e,this.sections),this.bounds=new de(d.ZERO.clone(),new d(100,100,100)),this}buildSections(e,t){let r,i,a,s=[],n=t.length;for(let h=0;h<n;h++){let u=new np(h);r=t[h],i=t[h+1],u.center=r.clone(),i==null?(u.normal=a.clone(),u.distance=0):(a=i.subtract(r),u.distance=a.length,u.normal=a.normalize()),s.push(u)}s[0].fixNormal=s[0].normal.clone();for(let h=1;h<n;h++){let u=s[h-1],f=s[h];f.fixNormal=f.normal.add(u.normal).normalize()}let l=new R().identity();for(let h=0;h<n;h++){let u=s[h],f,g;if(h==0)f=d.UP,g=e;else{let p=s[h-1];f=p.fixNormal,g=p.rotateShape}R.fromToRotation(f,u.fixNormal,l);for(let p=0,A=e.length;p<A;p++){let v=l.multiplyPoint3(g[p]);u.rotateShape.push(v)}}return s}buildGeometry(e,t){let r=t.length,i=e.length,a=r*i,s=r-1,n=new Float32Array(a*3),l=new Float32Array(a*3),h=new Float32Array(a*2),u=new Uint32Array(s*(i-1)*6),f=i-1,g=0,p=0,A=[0];for(let C=1;C<i;C++)p+=e[C-1].subtract(e[C]).length,A.push(p);for(let C=0;C<r;C++){let x=t[C];for(let S=0;S<i;S++){let y=(C*i+S)*3,b=x.rotateShape[S].add(x.center);n[y]=b.x,n[y+1]=b.y,n[y+2]=b.z,l[y+1]=1;let D=(C*i+S)*2,B=A[S]/p;h[D]=this.uNegate?1-B:B,h[D+1]=g*this.vScale}g+=x.distance}let v=0;for(let C=0;C<s;C++){let x=C*i;for(let S=0;S<f;S++){let y=S,b=S+1,D=y+i,B=b+i;u[v++]=y+x,u[v++]=b+x,u[v++]=D+x,u[v++]=b+x,u[v++]=B+x,u[v++]=D+x}}return this.setIndices(u),this.setAttribute(M.position,n),this.setAttribute(M.normal,l),this.setAttribute(M.uv,h),this.setAttribute(M.TEXCOORD_1,h),this.addSubGeometry({indexStart:0,indexCount:u.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.computeNormals(),this}}class hp{name;offset;size;arrayStride;stepMode;attributes}class up{name;format;offset;shaderLocation;stride}var fc=(o=>(o[o.position=3]="position",o[o.normal=3]="normal",o[o.TANGENT=4]="TANGENT",o[o.uv=2]="uv",o[o.TEXCOORD_1=2]="TEXCOORD_1",o[o.color=4]="color",o[o.joints0=4]="joints0",o[o.weights0=4]="weights0",o[o.joints1=4]="joints1",o[o.weights1=4]="weights1",o[o.vIndex=1]="vIndex",o[o.weight=1]="weight",o[o.a_morphPositions_0=3]="a_morphPositions_0",o))(fc||{});class cp{constructor(){}}class fp{get data(){return null}entity}class dc{min=0;max=0;set(e,t){return this.max=t,this.min=e,this}copy(e){return this.max=e.max,this.min=e.min,this}isInterestRange(e){return!(this.max>e.min||e.max<this.min)}}class gc{_spaceDesc;getRange(e){return this._spaceDesc[e]}initSpace(e){this._spaceDesc={};for(let t of e)(this._spaceDesc[t]=new dc).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(e,t){let r=this._spaceDesc[e];return t>=r.min&&t<r.max}isInterestRange(e,t){let r=this._spaceDesc[e];return r?t.isInterestRange(r):!1}splitSpace(e,t,r){let i=this._spaceDesc[e];return t?i.max=r:i.min=r,this}copySpace(e){for(let t in e._spaceDesc){let r=e._spaceDesc[t];this._spaceDesc[t].copy(r)}return this}}class Mi{static MaxEntityCountInLeaf=4;static MaxLayer=10;static ClearLeafLayer=Mi.MaxLayer-4}class Ri{static UUID=0;uuid="0";constructor(){this.uuid=(Ri.UUID++).toString()}}class dp{map={};_count=0;get count(){return this._count}push(e){return this.map[e.uuid]?!1:(this.map[e.uuid]=e,this._count++,!0)}remove(e){return this.map[e]?(delete this.map[e],this._count--,!0):!1}}class xr extends Ri{_dimensionIndex=0;_dimensions;_dimension;_left;_right;_space;_parent;_entities;layer;get dimension(){return this._dimension}constructor(e=0){super(),this.layer=e,xr.nodeCount++}initNode(e,t,r){return this._dimensions=t,this._dimensionIndex=r,this._dimension=t[r],this._space=new gc().initSpace(t),e&&this._space.copySpace(e._space),this._parent=e,this._entities=new dp,this}updateEntity(e){if(e.isInNode(this,this._dimension)&&(e.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let t=(this._dimensionIndex+1)%this._dimensions.length,r=this._dimensions[t];e.isInNode(this._right,r)?this._right.updateEntity(e):e.isInNode(this._left,r)&&this._left.updateEntity(e)}}buildRoot(e){for(const t of e)t.entity.attachTreeNode(this);this.autoSplit()}_splitEntityList=[];autoSplit(){if(this._entities.count>Mi.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<Mi.MaxLayer){let e=this._splitEntityList,t=(this._dimensionIndex+1)%this._dimensions.length,r=this._dimensions[t],i=0;for(const a in this._entities.map){let s=this._entities.map[a];i+=s.centerValue(r),e.push(s)}i/=this._entities.count,this._left=new xr(this.layer+1),this._right=new xr(this.layer+1),this._left.initNode(this,this._dimensions,t),this._right.initNode(this,this._dimensions,t),this._left.setSpace(!0,i),this._right.setSpace(!1,i);for(let a of e)a.isInNode(this._right,r)?a.attachTreeNode(this._right):a.isInNode(this._left,r)&&a.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(e,t){return this._parent&&this._space.splitSpace(this._dimension,e,t),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(e){return this._entities.push(e)}removeEntity(e){return this._entities.remove(e.uuid)}static nodeCount=0;autoClear(){let e=this;for(;e&&e.layer>Mi.ClearLeafLayer&&e.clearLeaf();)e=e._parent}clearLeaf(){let e=!this._left&&!this._right,t=!e&&this._left.isEmpty()&&this._right.isEmpty();return t&&(this._left=this._right=null,xr.nodeCount-=2),e||t}isContain(e){return this._space.isContain(this._dimension,e)}static rangeBox=new de(new d(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new d(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE));nodeIntersectsBox(e){let t=this._space.getRange("x"),r=this._space.getRange("y"),i=this._space.getRange("z"),a=xr.rangeBox;return a.min.set(t.min,r.min,i.min),a.max.set(t.max,r.max,i.max),a.intersectsBox(e)}nodeIntersectsRay(e){let t=this._space.getRange("x"),r=this._space.getRange("y"),i=this._space.getRange("z"),a=xr.rangeBox;return a.min.set(t.min,r.min,i.min),a.max.set(t.max,r.max,i.max),!0}pointCast(e,t=0,r){if(r=r||[],this._entities.count>0){let i=this._entities.map;for(let a in i){let s=i[a],n=s.entityContainPoint(e);!n&&t>0&&(n=s.squareDistanceTo(e,this._dimensions)<=t),n&&r.push(s)}}this._left&&this._left.isContain(e[this._left.dimension])&&this._left.pointCast(e,t,r),this._right&&this._right.isContain(e[this._right.dimension])&&this._right.pointCast(e,t,r)}boxCast(e,t){if(t=t||[],this._entities.count>0){let r=this._entities.map;for(let i in r){let a=r[i];a.entityIntersectsBox(e)&&t.push(a)}}this._left&&this._left.nodeIntersectsBox(e)&&this._left.boxCast(e,t),this._right&&this._right.nodeIntersectsBox(e)&&this._right.boxCast(e,t)}pointIntersect=new d;rayCast(e,t,r){t=t||[],r=r||[];let i=this.pointIntersect;if(this._entities.count>0){let a=this._entities.map;for(let s in a){let n=a[s];n.entityIntersectsRay(e,i)&&(r.push(new d().copyFrom(i)),t.push(n))}}this._left&&this._left.nodeIntersectsRay(e)&&this._left.rayCast(e,t,r),this._right&&this._right.nodeIntersectsRay(e)&&this._right.rayCast(e,t,r)}}class gp extends Ri{userData;node;constructor(e){super(),this.userData=e}centerValue(e){return 0}isInNode(e,t){return!1}entityContainPoint(e){return!1}squareDistanceTo(e,t){return Number.MAX_VALUE}entityIntersectsBox(e){return!1}entityIntersectsRay(e,t){return!1}attachTreeNode(e){return this.node&&this.detachTreeNode(),this.node=e,this.node.pushEntity(this)}detachTreeNode(){let e=this.node.removeEntity(this);return this.node=null,e}updateNode(e){let t=this.node;t&&this.detachTreeNode(),e.updateEntity(this),t&&t.autoClear()}}class Je{minPosX=0;minPosY=0;maxPosX=0;maxPosY=0;testID=0;points;offsetPosition;static TINY=1e-6;constructor(){this.points=new Array,this.offsetPosition=new d(0,0,0,0),this.clear()}setAABox(e,t,r,i){this.minPosX=e-r/2-Je.TINY,this.maxPosX=e+r/2+Je.TINY,this.minPosY=t-i/2-Je.TINY,this.maxPosY=t+i/2+Je.TINY,this.offsetPosition.setTo(0,0,0)}setOffset(e){this.maxPosX+=e.x-this.offsetPosition.x,this.minPosX+=e.x-this.offsetPosition.x,this.minPosY+=e.z-this.offsetPosition.z,this.maxPosY+=e.z-this.offsetPosition.z,this.offsetPosition.copyFrom(e)}setContainRect(e,t,r,i){this.minPosX>e&&(this.minPosX=e),this.minPosY>t&&(this.minPosY=t),this.maxPosX<r&&(this.maxPosX=r),this.maxPosY<i&&(this.maxPosY=i)}clear(){var e=1e9;this.minPosX=this.minPosY=e,this.maxPosX=this.maxPosY=-e,this.points.length=0,this.testID=0,this.offsetPosition.setTo(0,0,0)}addPoint(e){this.points.indexOf(e)==-1&&(e.x<this.minPosX&&(this.minPosX=e.x-Je.TINY),e.x>this.maxPosX&&(this.maxPosX=e.x+Je.TINY),e.z<this.minPosY&&(this.minPosY=e.z-Je.TINY),e.z>this.maxPosY&&(this.maxPosY=e.z+Je.TINY),this.points.push(e))}clone(){var e=new Je;return e.minPosX=this.minPosX,e.minPosY=this.minPosY,e.maxPosX=this.maxPosX,e.maxPosY=this.maxPosY,e}get radius(){return Math.sqrt((this.maxPosY-this.minPosY)*(this.maxPosY-this.minPosY)+(this.maxPosX-this.minPosX)*(this.maxPosX-this.minPosX))}get sideX(){return this.maxPosX-this.minPosX}get sideY(){return this.maxPosY-this.minPosY}get centreX(){return(this.maxPosX-this.minPosX)*.5+this.minPosX}get centreY(){return(this.maxPosY-this.minPosY)*.5+this.minPosY}overlapTest(e){return!(this.minPosY>=e.maxPosY||this.maxPosY<=e.minPosY||this.minPosX>=e.maxPosX||this.maxPosX<=e.minPosX)}isPointInside(e){return e.x>=this.minPosX&&e.x<=this.maxPosX&&e.z>=this.minPosY&&e.z<=this.maxPosY}isIntersectLineSegment(e,t,r,i){var a=!1,s=t-i,n=r-e,l=e*i-r*t,h=(-l-s*this.minPosX)/n;h<=this.maxPosY&&h>=this.minPosY&&(a=!0),h=(-l-s*this.maxPosX)/n,h<=this.maxPosY&&h>=this.minPosY&&(a=!0);var u=(-l-n*this.minPosY)/s;return u<=this.maxPosX&&u>=this.minPosX&&(a=!0),u=(-l-n*this.maxPosY)/s,u<=this.maxPosX&&u>=this.minPosX&&(a=!0),a}}class Cr{static NUM_CHILDREN=4;childCellIndices;nodeIndices;aabb;points;constructor(e){this.childCellIndices=new Array,this.childCellIndices.length=Cr.NUM_CHILDREN,this.nodeIndices=new Array,this.clear(),e?this.aabb=e.clone():this.aabb=new Je}isLeaf(){return this.childCellIndices[0]==-1}clear(){for(var e=0;e<Cr.NUM_CHILDREN;e++)this.childCellIndices[e]=-1;this.nodeIndices.splice(0,this.nodeIndices.length)}}class pc{_cells;_rootCell;_quadNodes;_aabb;_cellsToTest;_testID;constructor(){this._testID=0,this._cells=new Array,this._quadNodes=new Array,this._cellsToTest=new Array,this._aabb=new Je}getQuadNode(e){return this._quadNodes[e]}clear(){this._cells.length=0,this._quadNodes.length=0}initNodes(e){this.clear();for(var t=0,r=e.length;t<r;)e[t].calcGlobalQuadAABB(),this._quadNodes.push(e[t]),t++}buildQuadTree(e,t){this._aabb.clear();for(var r of this._quadNodes)if(r.isTriangle)for(var i of r.aabb.points)this._aabb.addPoint(i);else this._aabb.setContainRect(r.aabb.minPosX,r.aabb.minPosY,r.aabb.maxPosX,r.aabb.maxPosY);this._cells.length=0,this._rootCell=new Cr(this._aabb),this._cells.push(this._rootCell);for(var a=this._quadNodes.length,s=0;s<a;s++)this._cells[0].nodeIndices[s]=s;var n=new Array;n.push(0);for(var l,h,u;n.length!=0;)if(h=n.pop(),!(this._cells[h].nodeIndices.length<=e||this._cells[h].aabb.radius<t)){for(s=0;s<Cr.NUM_CHILDREN;s++){this._cells[h].childCellIndices[s]=this._cells.length,n.push(this._cells.length),this._cells.push(new Cr(this.createAABox(this._cells[h].aabb,s))),u=this._cells[this._cells.length-1],a=this._cells[h].nodeIndices.length;for(var f=0;f<a;f++)l=this._cells[h].nodeIndices[f],this.doesNodeIntersectCell(this._quadNodes[l],u)&&u.nodeIndices.push(l)}this._cells[h].nodeIndices.length=0}}createAABox(e,t){var r=e.centreX,i=e.centreY,a=e.sideX,s=e.sideY,n=new Je;switch(t){case 0:n.setAABox(r+a/4,i+s/4,a/2,s/2);break;case 1:n.setAABox(r-a/4,i+s/4,a/2,s/2);break;case 2:n.setAABox(r-a/4,i-s/4,a/2,s/2);break;case 3:n.setAABox(r+a/4,i-s/4,a/2,s/2);break;default:n.setAABox(r+a/4,i-s/4,a/2,s/2);break}return n}doesNodeIntersectCell(e,t){var r=e.aabb;if(!r.overlapTest(t.aabb))return!1;if(!e.isTriangle)return!0;var i=r.points,a=i[0],s=i[1],n=i[2];if(t.aabb.isPointInside(a)||t.aabb.isPointInside(s)||t.aabb.isPointInside(n))return!0;var l=this.pointInTriangle(t.aabb.minPosX,t.aabb.minPosY,a,s,n)||this.pointInTriangle(t.aabb.minPosX,t.aabb.maxPosY,a,s,n)||this.pointInTriangle(t.aabb.maxPosX,t.aabb.maxPosY,a,s,n)||this.pointInTriangle(t.aabb.maxPosX,t.aabb.minPosY,a,s,n);return l?!0:(l=t.aabb.isIntersectLineSegment(a.x,a.z,s.x,s.z)||t.aabb.isIntersectLineSegment(a.x,a.z,n.x,n.z)||t.aabb.isIntersectLineSegment(s.x,s.z,n.x,n.z),l)}getNodesIntersectingtAABox(e,t){if(this._cells.length==0)return 0;this._cellsToTest.length=0,this._cellsToTest.push(0),this.incrementTestCounter();for(var r,i,a,s,n=0;this._cellsToTest.length!=0;)if(r=this._cellsToTest.pop(),a=this._cells[r],!!t.overlapTest(a.aabb))if(a.isLeaf())for(i=a.nodeIndices.length,n=0;n<i;n++)s=this.getQuadNode(a.nodeIndices[n]).aabb,s.testID!=this._testID&&(s.testID=this._testID,t.overlapTest(s)&&e.push(a.nodeIndices[n]));else for(n=0;n<Cr.NUM_CHILDREN;n++)this._cellsToTest.push(a.childCellIndices[n]);return e.length}pointInTriangle(e,t,r,i,a){var s=r,n=i,l=a,h=s.z-n.z,u=n.x-s.x,f=s.x*n.z-n.x*s.z,g=n.z-l.z,p=l.x-n.x,A=n.x*l.z-l.x*n.z,v=l.z-s.z,C=s.x-l.x,x=l.x*s.z-s.x*l.z,S=!1,y=h*e+u*t+f,b=g*e+p*t+A,D=v*e+C*t+x;const B=.01;return(y>=-B&&b>=-B&&D>=-B||y<=B&&b<=B&&D<=B)&&(S=!0),S}incrementTestCounter(){if(++this._testID,this._testID==0){for(var e=this._quadNodes.length,t=0;t<e;t++)this._quadNodes[t].aabb.testID=0;this._testID=1}}logDeep=0;logTree(e){if(!(e<0)){this.logDeep++;for(var t=this._cells[e],r="",i=0;i<this.logDeep-1;i++)r+="-|";console.log(r+"i="+e+" "+t.aabb.minPosX.toFixed(2)+" "+t.aabb.maxPosX.toFixed(2)+" "+t.aabb.minPosY.toFixed(2)+" "+t.aabb.maxPosY.toFixed(2));var a;for(a=0;a<t.nodeIndices.length;a++)if(t.nodeIndices[a]>=0){var s=this._quadNodes[t.nodeIndices[a]];console.log(r+" t="+t.nodeIndices[a]+" "+s.aabb.minPosX.toFixed(2)+" "+s.aabb.maxPosX.toFixed(2)+" "+s.aabb.minPosY.toFixed(2)+" "+s.aabb.maxPosY.toFixed(2))}for(a=0;a<t.childCellIndices.length;a++)t.childCellIndices[a]>=0&&this.logTree(t.childCellIndices[a]);this.logDeep--}}}class mc{_maxNodesPerCell;_minCellSize;_quadTree;_collisionNodesIdx;_segBox;_collisionNodes;constructor(e=10,t=500){this._maxNodesPerCell=e,this._minCellSize=t,this._segBox=new Je,this._collisionNodesIdx=new Array,this._collisionNodes=new Array}createQuadTree(e){this._quadTree=new pc,this._quadTree.initNodes(e),this._quadTree.buildQuadTree(this._maxNodesPerCell,this._minCellSize)}getNodesByAABB(e,t,r,i){this._segBox.clear(),this._segBox.maxPosX=r,this._segBox.maxPosY=i,this._segBox.minPosX=e,this._segBox.minPosY=t,this._collisionNodesIdx.length=0,this._collisionNodes.length=0,this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx,this._segBox);for(var a,s=0;s<this._collisionNodesIdx.length;s++)a=this._quadTree.getQuadNode(this._collisionNodesIdx[s]),this._collisionNodes.push(a);return this._collisionNodes}getTriangleAtPoint(e,t=5){this._segBox.clear(),this._segBox.setAABox(e.x,e.z,1,1),this._collisionNodesIdx.length=0,this._collisionNodes.length=0,this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx,this._segBox);for(var r=4294967295,i=0,a,s,n,l,h=0;h<this._collisionNodesIdx.length;h++)s=this._quadTree.getQuadNode(this._collisionNodesIdx[h]),l=s.aabb,d.pointInsideTriangle(e,l.points[0],l.points[1],l.points[2])&&(n=s,i=Math.abs(n.plane.distance(e)),!(i>t)&&(s==null||i<=r)&&(a=n,r=i));return a}}var Ac=(o=>(o[o.MOUSE_LEFT=0]="MOUSE_LEFT",o[o.MOUSE_MID=1]="MOUSE_MID",o[o.MOUSE_RIGHT=2]="MOUSE_RIGHT",o))(Ac||{});class pp extends Ne{static LOADER_PROGRESS="loaderProgress";static LOADER_COMPLETE="loaderComplete"}class mp extends Ne{static ADDED="added";static REMOVED="removed";static CHILD_ADD_EVENT="childAddEvent";static CHILD_REMOVED="childRemoved"}class Ap extends Ne{static SHOW="show";static HIDE="hide";static UPDATE="update"}class vp{static merge(e,t,r,i){let a=0,s=0;a=Math.max(e.width,a),a=Math.max(t.width,a),a=Math.max(r.width,a),a=Math.max(i.width,a),s=Math.max(e.height,s),s=Math.max(t.height,s),s=Math.max(r.height,s),s=Math.max(i.height,s);let n=new fe(a,s,z.rgba8unorm),l=new ie(nu);l.setSamplerTexture("textureR",e),l.setSamplerTexture("textureG",t),l.setSamplerTexture("textureB",r),l.setSamplerTexture("textureA",i),l.setStorageTexture("outTex",n),l.workerSizeX=Math.ceil(a/8),l.workerSizeY=Math.ceil(s/8);let h=w.beginCommandEncoder();return w.computeCommand(h,[l]),w.endCommandEncoder(h),n}}class vc{sourceShader;compute;needUpdate=!0;constructor(e,t){this.sourceShader=t,this.compute=new ie(e),this.init()}init(){}onUpdate(){this.onFrame&&this.onFrame(),this.onOnce&&this.needUpdate&&(this.needUpdate=!1,this.onFrame())}}class _c extends vc{constructor(e){super(fu,e)}init(){let e=new fe(256,256,z.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);return this.compute.setStorageTexture("sssMap",e),this.sourceShader.setTexture("lutMap",e),e}onFrame(){this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let e=w.beginCommandEncoder();w.computeCommand(e,[this.compute]),w.endCommandEncoder(e)}}class Ui extends Wt{constructor(e,t,r=0){super(),this.bufferType=Et.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,t)}}class _p{static codeMax=`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `;static codeMin=`
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `;static _pipelineMax;static _pipelineMin;static createMipmap(e,t){const r=I.device;this._pipelineMax||=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}}),this._pipelineMin||=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}});let i=Math.ceil(e.width*.5),a=Math.ceil(e.height*.5),s={mipmapCount:t,texture:e,srcView:null,mipLevel:1,dstHeight:a,dstWidth:i};s.srcView=e.getGPUTexture().createView({format:e.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),e.width>1024&&e.height>1024?this.mipmap(this._pipelineMax,s):this.mipmap(this._pipelineMin,s)}static mipmap(e,t){const r=I.device,i=w.beginCommandEncoder();let a=e==this._pipelineMax,s,n;for(let l=t.mipLevel;l<t.mipmapCount;l++){let h=[],u=0;h.push({binding:u++,resource:t.srcView}),h.push({binding:u++,resource:t.texture.gpuSampler}),s=t.texture.getGPUTexture().createView({format:t.texture.format,dimension:"2d",baseMipLevel:l,mipLevelCount:1}),h.push({binding:u++,resource:s});const f=r.createBindGroup({layout:e.getBindGroupLayout(0),entries:h}),g=i.beginComputePass();g.setPipeline(e),g.setBindGroup(0,f);let p=t.dstWidth,A=t.dstHeight;if(a&&(p=Math.max(1,Math.floor(t.dstWidth/8)),A=Math.max(1,Math.floor(t.dstHeight/8))),g.dispatchWorkgroups(p,A),t.dstHeight*=.5,t.dstWidth*=.5,t.srcView=s,t.mipLevel=l+1,n=a&&(t.dstWidth<8||t.dstHeight<8),g.end(),n)break}w.endCommandEncoder(i),n&&this.mipmap(this._pipelineMin,t)}}class xc{name="";passMap=new Map}class Cc{passType="";shaderState=new Map;vertexShader="";fragmentShader=""}class xp{static passKeyword="pass";static shaderKeyword="Shader";static vertexKeyword="vertex";static fragmentKeyword="fragment";static passTypeKeyword="PassType";static parser(e,t){e=Tt.filterComment(e);let r=new xc,i=e.indexOf(this.shaderKeyword),a=e.indexOf("{",i),s=e.substring(i+this.shaderKeyword.length,a).trim();r.name=s.substring(1,s.length-1),s=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));let n=this.splitPassBlock(s);for(let l of n){let h=this.parserPassBlock(l),u;r.passMap.has(h.passType)?u=r.passMap.get(h.passType):(u=[],r.passMap.set(h.passType,u)),u.push(h),h.vertexShader.length>0&&(h.vertexShader=Tt.parse(h.vertexShader,t)),h.fragmentShader.length>0&&(h.fragmentShader=Tt.parse(h.fragmentShader,t))}return r}static splitPassBlock(e){let t=0,r=[];for(;t<e.length;){let i=e.indexOf(this.passKeyword,t);if(i==-1){r.push(e.substring(t));break}t!=0&&r.push(e.substring(t,i)),t=i+this.passKeyword.length}return r}static parserPassBlock(e){let t=new Cc,r=e.indexOf(this.passTypeKeyword),i=e.indexOf('"',r);return r=e.indexOf('"',i+1),t.passType=e.substring(r+1,i).trim(),this.parserShaderState(t,e),r=e.indexOf(this.vertexKeyword),r!=-1&&(t.vertexShader=this.extractBlock(e.substring(r+this.vertexKeyword.length),"{","}")),r=e.indexOf(this.fragmentKeyword),r!=-1&&(t.fragmentShader=this.extractBlock(e.substring(r+this.fragmentKeyword.length),"{","}")),t}static parserShaderState(e,t){let r=t.indexOf("ShaderState");if(r==-1)return!1;r=t.indexOf("{",r);let i=t.indexOf("}",r),s=t.substring(r+1,i).split(",");for(let n of s){let l=n.split(":"),h=l[0].trim(),u=this.convertValue(l[1].trim());e.shaderState.set(h,u)}return!0}static convertValue(e){return e.length==4&&e.toLowerCase()=="true"?!0:e.length==5&&e.toLowerCase()=="false"?!1:e[0]=='"'?e.substring(1,e.length-1):Number.parseInt(e)}static extractBlock(e,t,r){let i=e.indexOf(t);if(i==-1)return"";let a=0,s=0;e=e.substring(i);for(let l of e){if(l==t?a++:l==r&&a--,a<=0)break;s++}return e.substring(1,s).trim()}}let Sc=new Ne("IrradianceDataReaderCompleteEvent");class Li extends Xt{readFlag=!1;probeRenderer;opColorBuffer;opDepthBuffer;srcColorMap;srcDepthMap;opDepthArray;opColorArray;initReader(e,t,r){this.probeRenderer=e,this.srcColorMap=t,this.srcDepthMap=r;let i=m.setting.gi,a=i.octRTMaxSize*i.octRTMaxSize;this.opColorBuffer=I.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(a*4),this.opDepthBuffer=I.device.createBuffer({size:a*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(a*4),this.probeRenderer.addEventListener(gs.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(pa.type,()=>{console.log("GIRenderStartEvent")},this)}async onProbeRenderComplete(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),await Li.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),await Li.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(Sc)}}static async read(e,t,r){let i=w.beginCommandEncoder();i.copyTextureToBuffer({texture:e},{buffer:t,bytesPerRow:e.width*16},[e.width,e.height]),w.endCommandEncoder(i),await t.mapAsync(GPUMapMode.READ);const a=t.getMappedRange();r.set(new Float32Array(a),0),t.unmap()}}let Cp=new Li;class yc extends We{constructor(e=ii.triangle_list){super(),F.register("Graphic3DShader",Cu);let t=new Ae("Graphic3DShader","Graphic3DShader");t.setShaderEntry("VertMain","FragMain"),t.noticeValueChange();let r=new ke;r.addRenderPass(t),this.shader=r;let i=t.shaderState;i.acceptShadow=!1,i.castShadow=!1,i.receiveEnv=!1,i.acceptGI=!1,i.useLight=!1,i.topology=e}}class Sp extends Bt{}class yp extends c.MeshRenderer{texture;transformBuffer;nodeStructBuffer;drawAtomicBuffer;object3Ds;nodes;_initCompute=!1;_needCompute=!1;_onBufferChange=!1;_onStartKernel;_onChangeKernelGroup;_onFrameKernelGroup;nodeMat;maxFaceCount;maxNodeCount;_nodeStruct;init(e){super.init(e);let{maxFaceCount:t,maxNodeCount:r}=e;this.maxFaceCount=t,this.maxNodeCount=r,this._onStartKernel=[],this._onChangeKernelGroup=[],this._onFrameKernelGroup=[],this.initGeometryBuffer(),this.initMaterial(),this.initBaseBuffer(),this.createComputeKernel()}initGeometryBuffer(){let e=new eo(this.maxFaceCount);this.geometry=e}initMaterial(){this.material=this.nodeMat=new Oi,this.transformBuffer=new Z(this.maxNodeCount*(8*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer)}initBaseBuffer(){this.drawAtomicBuffer=new Z(4),this.drawAtomicBuffer.setUint32("skipFace",0),this.drawAtomicBuffer.setUint32("skipFace2",this.maxNodeCount),this.drawAtomicBuffer.setUint32("skipFace3",this.maxFaceCount),this.drawAtomicBuffer.setUint32("skipFace4",0)}createComputeKernel(){}set(e,t,r){this._nodeStruct=e,this.nodeMat.baseMap=t,this.nodes=[],this.nodeStructBuffer=new Ui(e,this.maxNodeCount);for(let u=0;u<this.maxNodeCount;u++)this.nodes.push(new e);this.nodeStructBuffer.setStructArray(e,this.nodes),this.nodeStructBuffer.apply(),this.object3Ds=[];let i,a=new P(1,1,1,1),s=new P(0,0,0,0),n=new G(0,0,.1,.1),l=new G(0,0,0,0),h=new d(0,0,0);for(let u=0;u<this.maxNodeCount;u++){if(r){const f=new c.Object3D;this.object3Ds.push(f),this.object3D.addChild(f),i=f}else i=this.object3D;this.transformBuffer.setFloat("matrix_"+u,i.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+u,0),this.transformBuffer.setFloat("texId2_"+u,0),this.transformBuffer.setFloat("texId3_"+u,0),this.transformBuffer.setFloat("fillRotation_"+u,0),this.transformBuffer.setVector3("empty_"+u,h),this.transformBuffer.setColor("baseColor_"+u,a),this.transformBuffer.setColor("lineColor_"+u,a),this.transformBuffer.setColor("emissiveColor_"+u,s),this.transformBuffer.setVector4("uvRect_"+u,n),this.transformBuffer.setVector4("uvRect2_"+u,n),this.transformBuffer.setVector4("uvSpeed_"+u,l)}this.transformBuffer.apply(),this.start=()=>{for(const u of this._onStartKernel)u.setStorageBuffer("globalUniform",ae.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer),u.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),u.setStorageBuffer("drawBuffer",this.drawAtomicBuffer),u.setStructStorageBuffer("nodeBuffer",this.nodeStructBuffer);for(const u of this._onChangeKernelGroup)u.setStorageBuffer("globalUniform",ae.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer),u.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),u.setStorageBuffer("drawBuffer",this.drawAtomicBuffer),u.setStructStorageBuffer("nodeBuffer",this.nodeStructBuffer);for(const u of this._onFrameKernelGroup)u.setStorageBuffer("globalUniform",ae.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer),u.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),u.setStorageBuffer("drawBuffer",this.drawAtomicBuffer),u.setStructStorageBuffer("nodeBuffer",this.nodeStructBuffer)}}setNodeStruct(e,t){this.nodeStructBuffer.setStruct(this._nodeStruct,e,t),this.nodes||=[],this.nodes[e]=t,this.nodeStructBuffer.apply()}updateShape(){for(let e=0;e<this.nodes.length;e++){const t=this.nodes[e];this.nodeStructBuffer.setStruct(this._nodeStruct,e,t)}this.nodeStructBuffer.apply(),this._needCompute=!0}setTextureID(e,t){this.transformBuffer.setFloat("texId_"+e,t),this._onBufferChange=!0}setLineTextureID(e,t){this.transformBuffer.setFloat("texId2_"+e,t),this._onBufferChange=!0}setBaseColor(e,t){this.transformBuffer.setColor("baseColor_"+e,t),this._onBufferChange=!0}setLineColor(e,t){this.transformBuffer.setColor("lineColor_"+e,t),this._onBufferChange=!0}setEmissiveColor(e,t){this.transformBuffer.setColor("emissiveColor_"+e,t),this._onBufferChange=!0}setFillRotation(e,t){this.transformBuffer.setFloat("fillRotation_"+e,t),this._onBufferChange=!0}setUVRect(e,t){this.transformBuffer.setVector4("uvRect_"+e,t),this._onBufferChange=!0}setUVRect2(e,t){this.transformBuffer.setVector4("uvRect2_"+e,t),this._onBufferChange=!0}setUVSpeed(e,t){this.transformBuffer.setVector4("uvSpeed_"+e,t),this._onBufferChange=!0}onUpdate(e){this._onBufferChange&&(this._onBufferChange=!1,this.transformBuffer.apply())}onCompute(e,t){this.drawAtomicBuffer.apply(),this._initCompute||(this._initCompute=!0,this.onStartCompute(e,t)),this._needCompute&&(this._needCompute=!1,this.onChangeCompute(e,t)),this.onFrameCompute(e,t)}onStartCompute(e,t){w.computeCommand(t,this._onStartKernel)}onChangeCompute(e,t){w.computeCommand(t,this._onChangeKernelGroup)}onFrameCompute(e,t){w.computeCommand(t,this._onFrameKernelGroup)}}class wp{static wirteVec4(e,t,r){e[t*4+0]=r.x,e[t*4+1]=r.y,e[t*4+2]=r.z,e[t*4+3]=r.w}}var Ip=Object.defineProperty,bp=Object.getOwnPropertyDescriptor,Bp=(o,e,t,r)=>{for(var i=r>1?void 0:r?bp(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Ip(e,t,i),i};c.UnLitTexArrayShader=class extends ke{constructor(){super(),F.register("VertexAttributeIndexShader",xu),F.register("UnLitTextureArray",Du);let e=new Ae("UnLitTextureArray","UnLitTextureArray");e.setShaderEntry("VertMain","FragMain"),this.addRenderPass(e);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor",new P),this.setUniformFloat("alphaCutoff",0)}set _MainTex(e){this.setTexture("baseMap",e)}set _BumpMap(e){this.setTexture("normalMap",e)}set _MaskTex(e){this.setTexture("maskMap",e)}set _UVTransform(e){this.setUniformVector4("transformUV1",e)}set _Metallic(e){this.setUniformFloat("metallic",e)}set _Roughness(e){this.setUniformFloat("roughness",e)}set _MainColor(e){this.setUniformColor("baseColor",e)}set _AlphaCutoff(e){this.setUniformFloat("alphaCutoff",e)}set _DoubleSidedEnable(e){let t=this.getDefaultColorShader();t.shaderState.cullMode=e?at.none:t.shaderState.cullMode}set _SurfaceType(e){let t=this.getDefaultColorShader();e==0?t.blendMode=ee.NONE:t.blendMode=ee.ALPHA}set _AlphaCutoffEnable(e){e==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}},c.UnLitTexArrayShader=Bp([jt],c.UnLitTexArrayShader);class Oi extends We{constructor(){super(),this.shader=new c.UnLitTexArrayShader,this.baseMap=m.res.whiteTexture}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}set shadowMap(e){}}class eo extends ve{faceCount=0;constructor(e){super(),this.faceCount=e,this.buildGeometry()}buildGeometry(){let e=new Uint32Array(this.faceCount*3),t=new Float32Array(this.faceCount*3*3),r=new Float32Array(this.faceCount*3*3),i=new Float32Array(this.faceCount*3*2),a=new Float32Array(this.faceCount*3*1);for(let s=0;s<this.faceCount;s++){let n=s*3+0,l=s*3+1,h=s*3+2;e[n]=n,e[l]=l,e[h]=h}this.setIndices(e),this.setAttribute(M.position,t),this.setAttribute(M.normal,r),this.setAttribute(M.uv,i),this.setAttribute(M.TEXCOORD_1,i),this.setAttribute(M.vIndex,a),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}var Ep=Object.defineProperty,Tp=Object.getOwnPropertyDescriptor,Dp=(o,e,t,r)=>{for(var i=r>1?void 0:r?Tp(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Ep(e,t,i),i};class Fr extends Bt{shapeIndex=0;shapeType=0;width=0;lineCap=0;pathCount=0;uScale=0;vScale=0;lineJoin=0;startPath=0;endPath=0;uSpeed=0;vSpeed=0;paths=[]}Dp([si],Fr.prototype,"paths",2);var wc=(o=>(o[o.bevel=0]="bevel",o[o.miter=1]="miter",o[o.round=2]="round",o))(wc||{}),Ic=(o=>(o[o.butt=0]="butt",o[o.square=1]="square",o[o.round=2]="round",o))(Ic||{});class Pp extends Bt{skipFace=0;skipFace2=0;skipFace3=0;skipFace4=0}class Ma extends Bt{index=0;faceStart=0;faceEnd=0;faceCount=0}class Ut extends c.MeshRenderer{static maxFaceCount=1e6;static maxGeometryCount=1;static maxPathPointCount=1e5;static maxShapeCount=1024;texture;transformBuffer;_onChange=!1;_computeGeoShader;geometryInfoBuffer;shapeBuffer;pathBuffer;drawBuffer;object3Ds;shapes;realDrawShape;needUpdate=!1;init(){super.init()}create(e,t){this._computeGeoShader=new ie(Su()),this.geometryInfoBuffer=new Ui(Ma,Ut.maxGeometryCount),this.shapeBuffer=new Ui(Fr,Ut.maxShapeCount),this.pathBuffer=new Z(Ut.maxPathPointCount*4),this.drawBuffer=new Z(4);let r=new eo(Ut.maxFaceCount),i=new Oi;i.baseMap=e,this.material=i,this.transformBuffer=new Z(t*(7*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer),this.object3Ds=[];for(let a=0;a<t;a++){const s=new c.Object3D;this.object3Ds.push(s),this.object3D.addChild(s),this.transformBuffer.setFloat("matrix_"+a,s.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+a,1),this.transformBuffer.setFloat("texId2_"+a,1),this.transformBuffer.setFloat("texId3_"+a,1),this.transformBuffer.setColor("baseColor_"+a,new P),this.transformBuffer.setColor("lineColor_"+a,new P),this.transformBuffer.setColor("emissiveColor_"+a,new P(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+a,new G(0,0,1,1)),this.transformBuffer.setVector4("uvRect2_"+a,new G(0,0,1,1)),this.transformBuffer.setVector4("uvSpeed_"+a,new G(0,0,0,0)),console.log("create dynamic geometry",a)}this.transformBuffer.apply(),this.geometry=r}startShape(e){this.create(e,Ut.maxGeometryCount);let t=[];for(let r=0;r<Ut.maxGeometryCount;r++){const i=new Ma;t.push(i)}this.geometryInfoBuffer.setStructArray(Ma,t),this.geometryInfoBuffer.apply(),this.shapes=[];for(let r=0;r<Ut.maxShapeCount;r++)this.shapes.push(new Fr);this.shapeBuffer.setStructArray(Fr,this.shapes),this.shapeBuffer.apply(),this.start=()=>{this._computeGeoShader.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),this._computeGeoShader.setStructStorageBuffer("geometryInfoBuffer",this.geometryInfoBuffer),this._computeGeoShader.setStructStorageBuffer("shapeBuffer",this.shapeBuffer),this._computeGeoShader.setStorageBuffer("pathBuffer",this.pathBuffer),this._computeGeoShader.setStorageBuffer("drawBuffer",this.drawBuffer),this._computeGeoShader.setStorageBuffer("globalUniform",ae.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer)}}setShape(e,t){this.shapeBuffer.setStruct(Fr,e,t),this.shapes||=[],this.shapes[e]=t,this.shapeBuffer.apply()}updateShape(){let e=0;this.realDrawShape=0;for(let t=0;t<this.shapes.length;t++){const r=this.shapes[t];r.pathCount=r.paths.length,r.pathCount>0&&this.realDrawShape++,r.startPath=e,e+=r.paths.length;for(let i=0;i<r.pathCount;i++)this.pathBuffer.setVector4(`${t}_path_${i}`,r.paths[i]);this.shapeBuffer.setStruct(Fr,t,r)}this.shapeBuffer.apply(),this.pathBuffer.apply(),this.needUpdate=!0}setTextureID(e,t){this.transformBuffer.setFloat("texId_"+e,t),this._onChange=!0}setBaseColor(e,t){this.transformBuffer.setColor("baseColor_"+e,t),this._onChange=!0}setEmissiveColor(e,t){this.transformBuffer.setColor("emissiveColor_"+e,t),this._onChange=!0}setUVRect(e,t){this.transformBuffer.setVector4("uvRect_"+e,t),this._onChange=!0}onUpdate(e){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}onCompute(e,t){this.needUpdate&&(this.needUpdate=!1,this.computeTrail(e,t))}computeTrail(e,t){this._computeGeoShader.workerSizeX=this.realDrawShape,this._computeGeoShader.workerSizeY=Math.floor(Ut.maxPathPointCount/256+1),this._computeGeoShader.workerSizeZ=1,w.computeCommand(t,[this._computeGeoShader])}}class to{static merge(e,t,r){}static mergeNumber(e,t,r){let i=r||new ve,a=e.getAttribute(M.position).data.length/3,s=new Float32Array(a*t);for(const u of e.vertexAttributeMap){let f=u[1].attribute;if(f==M.indices)continue;let g=e.getAttribute(f).data,p=g.length,A=new Float32Array(p*t);for(let v=0;v<t;v++){A.set(g,p*v);for(let C=0;C<a;C++)s[a*v+C]=v}i.setAttribute(f,A)}i.setAttribute(M.vIndex,s);let n=e.getAttribute(M.indices).data,l=n.length,h=new Uint32Array(n.length*t);for(let u=0;u<t;u++)for(let f=0;f<l;f++){let g=u*a,p=u*l;const A=n[f]+g;h[p+f]=A}return i.setIndices(h),i.addSubGeometry({indexStart:0,indexCount:h.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),i}static generateNormal(){}static generateTangent(){}static packUV(){}}class bc extends c.MeshRenderer{transformBuffer;sourceGeometry;texture;object3Ds;_onChange=!1;_computeShader;init(){super.init()}create(e,t,r){let i=new Oi;i.baseMap=t,this.material=i,this.transformBuffer=new Z(r*(8*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer);let a=new d(0,0,0);this.object3Ds=[];for(let s=0;s<r;s++){const n=new c.Object3D;this.object3Ds.push(n),this.object3D.addChild(n),this.transformBuffer.setFloat("matrix_"+s,n.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+s,1),this.transformBuffer.setFloat("texId2_"+s,1),this.transformBuffer.setFloat("texId3_"+s,1),this.transformBuffer.setFloat("texId3_"+s,1),this.transformBuffer.setFloat("fillRotation_"+s,0),this.transformBuffer.setVector3("empty_"+s,a),this.transformBuffer.setColor("baseColor_"+s,new P),this.transformBuffer.setColor("lineColor_"+s,new P),this.transformBuffer.setColor("emissiveColor_"+s,new P(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+s,new G(0,0,1,1)),this.transformBuffer.setVector4("uvRect2_"+s,new G(0,0,1,1)),this.transformBuffer.setVector4("uvSpeed_"+s,new G(0,0,0,0))}this.transformBuffer.apply(),this.geometry=to.mergeNumber(e,r)}setTextureID(e,t){this.transformBuffer.setFloat("texId_"+e,t),this._onChange=!0}setBaseColor(e,t){this.transformBuffer.setColor("baseColor_"+e,t),this._onChange=!0}setEmissiveColor(e,t){this.transformBuffer.setColor("emissiveColor_"+e,t),this._onChange=!0}setUVRect(e,t){this.transformBuffer.setVector4("uvRect_"+e,t),this._onChange=!0}onUpdate(e){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}computeTrail(e,t){w.computeCommand(t,[this._computeShader])}}class Bc extends ve{segment;row=0;constructor(e){super(),this.segment=e,this.buildGeometry()}buildGeometry(){this.row=this.segment+1;let e=new Uint32Array(this.segment*6),t=new Float32Array(this.row*3*2),r=new Float32Array(this.row*3*2),i=new Float32Array(this.row*2*2);for(let a=0;a<this.row;a++){t[a*3*2+0]=0,t[a*3*2+1]=0,t[a*3*2+2]=0,t[a*3*2+3]=0,t[a*3*2+4]=0,t[a*3*2+5]=0,r[a*3*2+0]=0,r[a*3*2+1]=0,r[a*3*2+2]=1,r[a*3*2+3]=0,r[a*3*2+4]=0,r[a*3*2+5]=1,i[a*2*2+0]=0,i[a*2*2+1]=a/this.segment,i[a*2*2+2]=1,i[a*2*2+3]=a/this.segment;let s=a*2,n=s,l=s+1,h=s+2,u=s+3;e[a*6+0]=n,e[a*6+1]=l,e[a*6+2]=h,e[a*6+3]=l,e[a*6+4]=u,e[a*6+5]=h}this.setIndices(e),this.setAttribute(M.position,t),this.setAttribute(M.normal,r),this.setAttribute(M.uv,i),this.setAttribute(M.TEXCOORD_1,i),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}var Mp=Object.defineProperty,Rp=Object.getOwnPropertyDescriptor,Up=(o,e,t,r)=>{for(var i=r>1?void 0:r?Rp(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&Mp(e,t,i),i},Ec=(o=>(o[o.FaceToCamera=0]="FaceToCamera",o[o.FaceToPath=1]="FaceToPath",o[o.FaceToUp=2]="FaceToUp",o))(Ec||{});class Fi extends Bt{index=1;segment=5;visible=1;width=.25;uv=new G(0,0,1,30);uvSpeed=new V(0,2.1);smooth=0;faceMode=0;up=new G(0,1,0);ids=new Float32Array(ei.maxRibbonSegment);ribbonPoint=[]}Up([si],Fi.prototype,"ribbonPoint",2);class ei extends c.MeshRenderer{static maxRibbonSegment=256;transformBuffer;sourceGeometry;texture;object3Ds;ribbons;ribbonCount=10;_onChange=!1;_computeShader;_ribbonBuffer;ribbonSegment;init(){super.init()}create(e,t,r){this.ribbons=[],this.ribbonSegment=e;for(let s=0;s<r;s++)this.ribbons[s]=new Fi,this.ribbons[s].index=s,this.ribbons[s].segment=e,this.ribbons[s].width=.5,this.ribbons[s].faceMode=0;let i=new Bc(e),a=new Oi;a.baseMap=t,this.material=a,this.transformBuffer=new Z(r*(7*4),0),this.material.setStorageBuffer("graphicBuffer",this.transformBuffer),this.object3Ds=[];for(let s=0;s<r;s++){const n=new c.Object3D;this.object3Ds.push(n),this.object3D.addChild(n),this.transformBuffer.setFloat("matrix_"+s,n.transform.worldMatrix.index),this.transformBuffer.setFloat("texId_"+s,1),this.transformBuffer.setFloat("texId2_"+s,1),this.transformBuffer.setFloat("texId3_"+s,1),this.transformBuffer.setColor("baseColor_"+s,new P),this.transformBuffer.setColor("lineColor_"+s,new P),this.transformBuffer.setColor("emissiveColor_"+s,new P(0,0,0,0)),this.transformBuffer.setVector4("uvRect_"+s,new G(0,0,1,1)),this.transformBuffer.setVector4("uvRect2_"+s,new G(0,0,1,1)),this.transformBuffer.setVector4("uvSpeed_"+s,new G(0,0,0,0))}this.transformBuffer.apply(),this.geometry=to.mergeNumber(i,r)}startRibbon(e,t,r){this.ribbonCount=r,this.create(t,e,r),this._computeShader=new ie(yu(ei.maxRibbonSegment)),this._ribbonBuffer=new Ui(Fi,r);for(let i=0;i<r;i++){this.ribbons[i].ribbonPoint=[];for(let a=0;a<ei.maxRibbonSegment;a++){const s=new c.Object3D;this.object3D.addChild(s),this.ribbons[i].ribbonPoint[a]=s,this.ribbons[i].ids[a]=s.transform.worldMatrix.index}}this._ribbonBuffer.setStructArray(Fi,this.ribbons),this._ribbonBuffer.apply(),this.start=()=>{this._computeShader.setStorageBuffer("vertexBuffer",this.geometry.vertexBuffer.vertexGPUBuffer),this._computeShader.setStorageBuffer("trailBuffer",this._ribbonBuffer),this._computeShader.setStorageBuffer("models",ae.modelMatrixBindGroup.matrixBufferDst),this._computeShader.setStorageBuffer("globalUniform",ae.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer)},this.onCompute=(i,a)=>this.computeTrail(i,a)}setTextureID(e,t){this.transformBuffer.setFloat("texId_"+e,t),this._onChange=!0}setBaseColor(e,t){this.transformBuffer.setColor("baseColor_"+e,t),this._onChange=!0}setEmissiveColor(e,t){this.transformBuffer.setColor("emissiveColor_"+e,t),this._onChange=!0}setUVRect(e,t){this.transformBuffer.setVector4("uvRect_"+e,t),this._onChange=!0}setLineUVRect(e,t){this.transformBuffer.setVector4("uvRect1_"+e,t),this._onChange=!0}onUpdate(e){this._onChange&&(this._onChange=!1,this.transformBuffer.apply())}computeTrail(e,t){this._computeShader.workerSizeX=this.ribbonCount,this._computeShader.workerSizeY=1,w.computeCommand(t,[this._computeShader])}}class Lp{static meshMap=new Map;static meshDrawGroup=new Map;static ribbonMap=new Map;static nodeMap=new Map;static faceMap=new Map;static draw(e,t,r,i){if(!this.meshMap.has(t)){let a=new c.Object3D,s=a.addComponent(bc);return s.create(t,r,i),this.meshMap.set(t,s),e.addChild(a),s}}static drawRibbon(e,t,r,i,a){if(!this.ribbonMap.has(e)){let s=new c.Object3D,n=s.addComponent(ei);return n.startRibbon(r,i,a),this.ribbonMap.set(e,n),t.addChild(s),n}}static drawShape(e,t,r){if(!this.faceMap.has(e)){let i=new c.Object3D,a=i.addComponent(Ut);return a.startShape(r),this.faceMap.set(e,a),t.addChild(i),a}}static drawNode(e,t,r,i,a,s,n,l){if(!this.nodeMap.has(e)){let h=new c.Object3D,u=h.addComponent(t,{maxFaceCount:n||4294967295/3,maxNodeCount:s});return u.set(r,a,l),this.nodeMap.set(e,u),i.addChild(h),u}}}class Op{computeShader;visibleBuffer;texture;constructor(){this.computeShader=new ie(_u),this.visibleBuffer=new Xr(8192*2),this.computeShader.setStorageBuffer("visibleBuffer",this.visibleBuffer),this.texture=ye.getTexture(Le.zBufferTexture_NAME),this.computeShader.setSamplerTexture("zBufferTexture",this.texture),this.computeShader.workerSizeX=Math.ceil(this.texture.width/8),this.computeShader.workerSizeY=Math.ceil(this.texture.height/8),this.computeShader.workerSizeZ=1}compute(e,t){this.visibleBuffer.reset(!0,0),this.visibleBuffer.apply();let r=w.beginCommandEncoder();w.computeCommand(r,[this.computeShader]),this.visibleBuffer.readBuffer(),t.zVisibleList=this.visibleBuffer.outFloat32Array}}class Fp extends Ct{RT_BloomUp;RT_BloomDown;RT_threshold;rendererPassState;thresholdCompute;downSampleComputes;upSampleComputes;postCompute;bloomSetting;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.bloom.enable=!0,this.createGUI()}Render;onDetach(e){m.setting.render.postProcessing.bloom.enable=!1,this.removeGUI()}createGUI(){}removeGUI(){}get downSampleBlurSize(){return m.setting.render.postProcessing.bloom.downSampleBlurSize}set downSampleBlurSize(e){m.setting.render.postProcessing.bloom.downSampleBlurSize=e}get downSampleBlurSigma(){return m.setting.render.postProcessing.bloom.downSampleBlurSigma}set downSampleBlurSigma(e){m.setting.render.postProcessing.bloom.downSampleBlurSigma=e}get upSampleBlurSize(){return m.setting.render.postProcessing.bloom.upSampleBlurSize}set upSampleBlurSize(e){m.setting.render.postProcessing.bloom.upSampleBlurSize=e}get upSampleBlurSigma(){return m.setting.render.postProcessing.bloom.upSampleBlurSigma}set upSampleBlurSigma(e){m.setting.render.postProcessing.bloom.upSampleBlurSigma=e}get luminanceThreshole(){return m.setting.render.postProcessing.bloom.luminanceThreshole}set luminanceThreshole(e){m.setting.render.postProcessing.bloom.luminanceThreshole=e}get bloomIntensity(){return m.setting.render.postProcessing.bloom.bloomIntensity}set bloomIntensity(e){m.setting.render.postProcessing.bloom.bloomIntensity=e}createThreshouldCompute(){this.thresholdCompute=new ie(tu),this.autoSetColorTexture("inTex",this.thresholdCompute),this.thresholdCompute.setStorageTexture("outTex",this.RT_threshold),this.thresholdCompute.setUniformBuffer("bloomCfg",this.bloomSetting),this.thresholdCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.thresholdCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.thresholdCompute.workerSizeZ=1}createDownSampleComputes(){const t=m.setting.render.postProcessing.bloom.downSampleStep;this.downSampleComputes=[];for(let r=0;r<t;r++){let i=new ie(ru),a=this.RT_BloomDown[r],s=r==0?this.RT_threshold:this.RT_BloomDown[r-1];i.setSamplerTexture("inTex",s),i.setStorageTexture("outTex",a),i.setUniformBuffer("bloomCfg",this.bloomSetting),i.workerSizeX=Math.ceil(a.width/8),i.workerSizeY=Math.ceil(a.height/8),i.workerSizeZ=1,this.downSampleComputes.push(i)}}createUpSampleComputes(){const t=m.setting.render.postProcessing.bloom.downSampleStep;this.upSampleComputes=[];{let r=new ie(Qs),i=this.RT_BloomUp[0],a=this.RT_BloomDown[t-2];r.setSamplerTexture("_MainTex",a),r.setSamplerTexture("_PrevMip",this.RT_BloomDown[t-1]),r.setStorageTexture("outTex",i),r.setUniformBuffer("bloomCfg",this.bloomSetting),r.workerSizeX=Math.ceil(i.width/8),r.workerSizeY=Math.ceil(i.height/8),r.workerSizeZ=1,this.upSampleComputes.push(r)}for(let r=1;r<t-1;r++){let i=new ie(Qs),a=this.RT_BloomUp[r],s=this.RT_BloomDown[t-2-r];i.setSamplerTexture("_MainTex",s),i.setSamplerTexture("_PrevMip",this.RT_BloomUp[r-1]),i.setStorageTexture("outTex",a),i.setUniformBuffer("bloomCfg",this.bloomSetting),i.workerSizeX=Math.ceil(a.width/8),i.workerSizeY=Math.ceil(a.height/8),i.workerSizeZ=1,this.upSampleComputes.push(i)}}createPostCompute(){const t=m.setting.render.postProcessing.bloom.downSampleStep;this.postCompute=new ie(iu),this.autoSetColorTexture("_MainTex",this.postCompute),this.postCompute.setSamplerTexture("_BloomTex",this.RT_BloomUp[t-2]),this.postCompute.setStorageTexture("outTex",this.RT_threshold),this.postCompute.setUniformBuffer("bloomCfg",this.bloomSetting),this.postCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.postCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.postCompute.workerSizeZ=1}createResource(){let e=m.setting.render.postProcessing.bloom;this.bloomSetting=new ct(4*2);let t=I.presentationSize,r=t[0],i=t[1];this.RT_threshold=new fe(r,i,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);const a=e.downSampleStep;{let n=2;this.RT_BloomDown=[];for(let l=0;l<a;l++){let h=Math.ceil(r/n),u=Math.ceil(i/n);this.RT_BloomDown[l]=new fe(h,u,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),n*=2}}{this.RT_BloomUp=[];for(let n=0;n<a-1;n++){let l=this.RT_BloomDown[a-2-n].width,h=this.RT_BloomDown[a-2-n].height;this.RT_BloomUp[n]=new fe(l,h,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING)}}let s=new ce;s.loadOp="load",this.rtFrame=new Oe([this.RT_threshold],[s])}render(e,t){this.thresholdCompute||(this.createResource(),this.createThreshouldCompute(),this.createDownSampleComputes(),this.createUpSampleComputes(),this.createPostCompute(),this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="Bloom");let r=m.setting.render.postProcessing.bloom;this.bloomSetting.setFloat("downSampleStep",r.downSampleStep),this.bloomSetting.setFloat("downSampleBlurSize",r.downSampleBlurSize),this.bloomSetting.setFloat("downSampleBlurSigma",r.downSampleBlurSigma),this.bloomSetting.setFloat("upSampleBlurSize",r.upSampleBlurSize),this.bloomSetting.setFloat("upSampleBlurSigma",r.upSampleBlurSigma),this.bloomSetting.setFloat("luminanceThreshole",r.luminanceThreshole),this.bloomSetting.setFloat("bloomIntensity",r.bloomIntensity),this.bloomSetting.apply(),w.computeCommand(t,[this.thresholdCompute,...this.downSampleComputes,...this.upSampleComputes,this.postCompute]),w.lastRenderPassState=this.rendererPassState}onResize(){let e=m.setting.render.postProcessing.bloom,t=I.presentationSize,r=t[0],i=t[1];this.RT_threshold.resize(r,i);const a=e.downSampleStep;let s=2;for(let n=0;n<a;n++){let l=Math.ceil(r/s),h=Math.ceil(i/s);this.RT_BloomDown[n].resize(l,h),s*=2}for(let n=0;n<a-1;n++){let l=this.RT_BloomDown[a-2-n].width,h=this.RT_BloomDown[a-2-n].height;this.RT_BloomUp[n].resize(l,h)}this.thresholdCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.thresholdCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.thresholdCompute.workerSizeZ=1;for(let n=0;n<a;n++){let l=this.downSampleComputes[n],h=this.RT_BloomDown[n];l.workerSizeX=Math.ceil(h.width/8),l.workerSizeY=Math.ceil(h.height/8),l.workerSizeZ=1}{let n=this.RT_BloomUp[0],l=this.upSampleComputes[0];l.workerSizeX=Math.ceil(n.width/8),l.workerSizeY=Math.ceil(n.height/8),l.workerSizeZ=1}for(let n=1;n<a-1;n++){let l=this.RT_BloomUp[n],h=this.upSampleComputes[n];h.workerSizeX=Math.ceil(l.width/8),h.workerSizeY=Math.ceil(l.height/8),h.workerSizeZ=1}this.postCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.postCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.postCompute.workerSizeZ=1}}class Np extends Ct{blurTexture1;blurTexture2;rendererPassState;blurComputes;blurSettings;outTexture;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.depthOfView.enable=!0}onDetach(e){m.setting.render.postProcessing.depthOfView.enable=!1}get pixelOffset(){return m.setting.render.postProcessing.depthOfView.pixelOffset}set pixelOffset(e){e=Math.max(0,e);let t=m.setting.render.postProcessing.depthOfView;t.pixelOffset=e}get near(){return m.setting.render.postProcessing.depthOfView.near}set near(e){e=Math.max(0,e);let t=m.setting.render.postProcessing.depthOfView;t.near=e}get far(){return m.setting.render.postProcessing.depthOfView.far}set far(e){e=Math.max(0,e);let t=m.setting.render.postProcessing.depthOfView;t.far=e}createBlurCompute(){this.blurSettings=[],this.blurComputes=[];let e=m.setting.render.postProcessing.depthOfView;for(let t=0;t<e.iterationCount;t++){let r=new ct(4),i=new ie(au);this.blurComputes.push(i),this.blurSettings.push(r),i.setUniformBuffer("blurSetting",r);let a=we.getGBufferFrame("ColorPassGBuffer");i.setSamplerTexture(Le.positionBufferTex_NAME,a.getPositionMap()),i.setSamplerTexture(Le.normalBufferTex_NAME,a.getNormalMap());let s=t%2==0?this.blurTexture1:this.blurTexture2,n=t%2==1?this.blurTexture1:this.blurTexture2;i.setSamplerTexture("inTex",s),i.setStorageTexture("outTex",n),i.workerSizeX=Math.ceil(this.blurTexture1.width/8),i.workerSizeY=Math.ceil(this.blurTexture1.height/8),i.workerSizeZ=1,this.outTexture=n}}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.blurTexture1=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture1.name="dof1";let i=new ce;i.clearValue=[0,0,0,1],i.loadOp="clear",this.blurTexture2=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture2.name="dof2";let a=new ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.rtFrame=new Oe([this.blurTexture1,this.blurTexture2],[i,a])}render(e,t){if(!this.blurComputes){this.createResource(),this.createBlurCompute();let i=ae.getCameraGroup(e.camera);for(let a=0;a<this.blurComputes.length;a++)this.blurComputes[a].setUniformBuffer("globalUniform",i.uniformGPUBuffer);this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null)}this.autoSetColorTexture("inTex",this.blurComputes[0]);let r=m.setting.render.postProcessing.depthOfView;r.far=Math.max(r.near,r.far)+1e-4;for(let i=0;i<r.iterationCount;i++){let a=this.blurComputes[i],s=this.blurSettings[i];s.setFloat("near",r.near),s.setFloat("far",r.far),s.setFloat("pixelOffset",(i+1)*r.pixelOffset),s.apply(),a.setStorageBuffer("blurSetting",s)}w.computeCommand(t,this.blurComputes),w.lastRenderPassState=this.rendererPassState}onResize(){let e=I.presentationSize,t=e[0],r=e[1],i=m.setting.render.postProcessing.depthOfView;i.far=Math.max(i.near,i.far)+1e-4,this.blurTexture1.resize(t,r),this.blurTexture2.resize(t,r);for(let a=0;a<i.iterationCount;a++){let s=this.blurComputes[a];s.workerSizeX=Math.ceil(this.blurTexture1.width/8),s.workerSizeY=Math.ceil(this.blurTexture1.height/8),s.workerSizeZ=1}}}class zp extends Ct{gtaoTexture;rendererPassState;gtaoCompute;gtaoSetting;aoBuffer;directionsBuffer;directionsArray;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.gtao.enable=!0}Render;onDetach(e){m.setting.render.postProcessing.gtao.enable=!1}get maxDistance(){return m.setting.render.postProcessing.gtao.maxDistance}set maxDistance(e){e=j(e,.1,50);let t=m.setting.render.postProcessing.gtao;t.maxDistance=e}get maxPixel(){return m.setting.render.postProcessing.gtao.maxPixel}set maxPixel(e){e=j(e,5,100);let t=m.setting.render.postProcessing.gtao;t.maxPixel=e}get darkFactor(){return m.setting.render.postProcessing.gtao.darkFactor}set darkFactor(e){e=j(e,.01,1);let t=m.setting.render.postProcessing.gtao;t.darkFactor=e}get rayMarchSegment(){return m.setting.render.postProcessing.gtao.rayMarchSegment}set rayMarchSegment(e){e=j(e,4,10);let t=m.setting.render.postProcessing.gtao;t.rayMarchSegment=e}get multiBounce(){return m.setting.render.postProcessing.gtao.multiBounce}set multiBounce(e){let t=m.setting.render.postProcessing.gtao;t.multiBounce=e}get blendColor(){return m.setting.render.postProcessing.gtao.blendColor}set blendColor(e){let t=m.setting.render.postProcessing.gtao;t.blendColor=e}get usePosFloat32(){return m.setting.render.postProcessing.gtao.usePosFloat32}set usePosFloat32(e){let t=m.setting.render.postProcessing.gtao;t.usePosFloat32=e}createCompute(){m.setting.render.postProcessing.gtao,this.gtaoCompute=new ie(su);let e=new ct(4*2);this.gtaoCompute.setUniformBuffer("gtaoData",e),this.directionsArray=new Float32Array(8*2),this.directionsBuffer=new Z(8*2),this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply(),this.gtaoCompute.setStorageBuffer("directions",this.directionsBuffer),this.aoBuffer=new Z(this.gtaoTexture.width*this.gtaoTexture.height),this.gtaoCompute.setStorageBuffer("aoBuffer",this.aoBuffer);let t=we.getGBufferFrame("ColorPassGBuffer"),r=t.getPositionMap();this.gtaoCompute.setSamplerTexture("posTex",r),this.gtaoCompute.setSamplerTexture("normalTex",t.renderTargets[2]),this.autoSetColorTexture("inTex",this.gtaoCompute),this.gtaoCompute.setStorageTexture("outTex",this.gtaoTexture),this.gtaoSetting=e}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.gtaoTexture=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.gtaoTexture.name="gtaoTex";let i=new ce;i.loadOp="load",this.rtFrame=new Oe([this.gtaoTexture],[i])}randomCount=0;randomDirection(){this.randomCount++,this.randomCount>1&&(this.randomCount=0);let e=Math.PI*2*this.randomCount/16,t=Math.PI*2/8;for(let r=0;r<8;r++){let i=e+r*t;this.directionsArray[r*2]=Math.sin(i),this.directionsArray[r*2+1]=Math.cos(i)}return this.directionsArray}render(e,t){if(!this.gtaoCompute){this.createResource(),this.createCompute(),this.onResize(),this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GTAO";let l=ae.getCameraGroup(e.camera);this.gtaoCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}let r=m.setting.render.postProcessing.gtao;this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply();let i=1-.2*(ue.frame%2),a=r.maxDistance*i,s=r.maxPixel*i;this.gtaoSetting.setFloat("maxDistance",a),this.gtaoSetting.setFloat("maxPixel",s),this.gtaoSetting.setFloat("darkFactor",r.darkFactor),this.gtaoSetting.setFloat("rayMarchSegment",r.rayMarchSegment);let n=e.camera;this.gtaoSetting.setFloat("cameraNear",n.near),this.gtaoSetting.setFloat("cameraFar",n.far),this.gtaoSetting.setFloat("multiBounce",r.multiBounce?1:0),this.gtaoSetting.setFloat("blendColor",r.blendColor?1:0),this.gtaoSetting.apply(),w.computeCommand(t,[this.gtaoCompute]),w.lastRenderPassState=this.rendererPassState}onResize(){let e=I.presentationSize,t=e[0],r=e[1];this.gtaoTexture.resize(t,r),this.gtaoCompute.workerSizeX=Math.ceil(this.gtaoTexture.width/8),this.gtaoCompute.workerSizeY=Math.ceil(this.gtaoTexture.height/8),this.gtaoCompute.workerSizeZ=1}}class kp extends Ct{viewQuad;rtTexture;_globalFog;constructor(){super();let e=this._globalFog=m.setting.render.postProcessing.globalFog,t=we.getGBufferFrame("ColorPassGBuffer"),r=I.presentationSize;F.register("GlobalFog_shader",Mu),this.rtTexture=this.createRTTexture("GlobalFog",r[0],r[1],z.rgba16float),this.viewQuad=this.createViewQuad("GlobalFog","GlobalFog_shader",this.rtTexture);let i=this.viewQuad.quadShader;i.setUniformColor("fogColor",new P(e.fogColor.r,e.fogColor.g,e.fogColor.b,e.fogColor.a)),i.setUniform("fogType",e.fogType),i.setUniform("fogHeightScale",e.fogHeightScale),i.setUniform("start",e.start),i.setUniform("end",e.end),i.setUniform("density",e.density),i.setUniform("ins",e.ins),i.setUniform("falloff",e.falloff),i.setUniform("rayLength",e.rayLength),i.setUniform("scatteringExponent",e.scatteringExponent),i.setUniform("dirHeightLine",e.dirHeightLine),i.setUniform("skyFactor",e.skyFactor),i.setUniform("skyRoughness",e.skyRoughness),i.setUniform("overrideSkyFactor",e.overrideSkyFactor),i.setUniform("isSkyHDR",0);let a=t.getPositionMap(),s=t.getNormalMap();this.setInputTexture(a,s)}onAttach(e){m.setting.render.postProcessing.globalFog.enable=!0}onDetach(e){m.setting.render.postProcessing.globalFog.enable=!1}set fogType(e){this._globalFog.fogType=e,this.viewQuad.quadShader.setUniform("fogType",e)}get fogType(){return this._globalFog.fogType}set fogHeightScale(e){this._globalFog.fogHeightScale=e,this.viewQuad.quadShader.setUniform("fogHeightScale",e)}get fogHeightScale(){return this.viewQuad.quadShader.getUniform("fogHeightScale")}set start(e){this._globalFog.start=e,this.viewQuad.quadShader.setUniform("start",e)}get start(){return this.viewQuad.quadShader.getUniform("start")}set end(e){this._globalFog.end=e,this.viewQuad.quadShader.setUniform("end",e)}get end(){return this.viewQuad.quadShader.getUniform("end")}set ins(e){this._globalFog.ins=e,this.viewQuad.quadShader.setUniform("ins",e)}get ins(){return this.viewQuad.quadShader.getUniform("ins")}set density(e){this._globalFog.density=e,this.viewQuad.quadShader.setUniform("density",e)}get density(){return this.viewQuad.quadShader.getUniform("density")}set skyRoughness(e){this._globalFog.skyRoughness=e,this.viewQuad.quadShader.setUniform("skyRoughness",e)}get skyRoughness(){return this._globalFog.skyRoughness}set skyFactor(e){this._globalFog.skyFactor=e,this.viewQuad.quadShader.setUniform("skyFactor",e)}get skyFactor(){return this._globalFog.skyFactor}set overrideSkyFactor(e){this._globalFog.overrideSkyFactor=e,this.viewQuad.quadShader.setUniform("overrideSkyFactor",e)}get overrideSkyFactor(){return this._globalFog.overrideSkyFactor}get fogColor(){return this._globalFog.fogColor}set fogColor(e){this._globalFog.fogColor.copyFrom(e),this.viewQuad.quadShader.setUniformColor("fogColor",e)}set falloff(e){this._globalFog.falloff=e,this.viewQuad.quadShader.setUniform("falloff",e)}get falloff(){return this.viewQuad.quadShader.getUniform("falloff")}set rayLength(e){this._globalFog.rayLength=e,this.viewQuad.quadShader.setUniform("rayLength",e)}get rayLength(){return this._globalFog.rayLength}set scatteringExponent(e){this._globalFog.scatteringExponent=e,this.viewQuad.quadShader.setUniform("scatteringExponent",e)}get scatteringExponent(){return this._globalFog.scatteringExponent}set dirHeightLine(e){this._globalFog.dirHeightLine=e,this.viewQuad.quadShader.setUniform("dirHeightLine",e)}get dirHeightLine(){return this._globalFog.dirHeightLine}setInputTexture(e,t){const r=this.viewQuad.quadShader;r.setTexture("positionMap",e),r.setTexture("normalMap",t),this._lastSkyTexture=this.getSkyTexture(),r.setTexture("prefilterMap",this._lastSkyTexture)}_lastSkyTexture;getSkyTexture(){let e=m.res.defaultSky;return k.instance.sky instanceof Ia&&(e=k.instance.sky.map),e}render(e,t){const r=this.viewQuad.quadShader;let i=this.getSkyTexture();i!=this._lastSkyTexture&&(this._lastSkyTexture=i,r.setTexture("prefilterMap",this._lastSkyTexture)),r.setTexture("colorMap",this.getOutTexture()),r.setUniformFloat("isSkyHDR",i.isHDRTexture?1:0),this.viewQuad.renderTarget(e,this.viewQuad,t)}}class Gp extends Ct{godRayTexture;rendererPassState;godRayCompute;historyGodRayData;godRaySetting;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.godRay.enable=!0,this.createGUI()}Render;onDetach(e){m.setting.render.postProcessing.godRay.enable=!1,this.removeGUI()}get blendColor(){return m.setting.render.postProcessing.godRay.blendColor}set blendColor(e){m.setting.render.postProcessing.godRay.blendColor=e}get rayMarchCount(){return m.setting.render.postProcessing.godRay.rayMarchCount}set rayMarchCount(e){e=j(e,8,20),m.setting.render.postProcessing.godRay.rayMarchCount=e}get scatteringExponent(){return m.setting.render.postProcessing.godRay.scatteringExponent}set scatteringExponent(e){e=j(e,1,40),m.setting.render.postProcessing.godRay.scatteringExponent=e}get intensity(){return m.setting.render.postProcessing.godRay.intensity}set intensity(e){e=j(e,.01,5),m.setting.render.postProcessing.godRay.intensity=e}createGUI(){}removeGUI(){}createCompute(e){m.setting.render.postProcessing.godRay,this.godRayCompute=new ie(ou);let t=new ct(4*3);this.godRayCompute.setUniformBuffer("godRayUniform",t),this.historyGodRayData=new Z(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData);let r=we.getGBufferFrame("ColorPassGBuffer");this.godRayCompute.setSamplerTexture("posTex",r.renderTargets[1]),this.godRayCompute.setSamplerTexture("normalTex",r.renderTargets[2]),this.autoSetColorTexture("inTex",this.godRayCompute),this.godRayCompute.setStorageTexture("outTex",this.godRayTexture);let i=m.getRenderJob(e).shadowMapPassRenderer;this.godRayCompute.setSamplerTexture("shadowMap",i.depth2DArrayTexture),this.godRaySetting=t,this.onResize()}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.godRayTexture=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.godRayTexture.name="godRayTexture";let i=new ce;i.loadOp="load",this.rtFrame=new Oe([this.godRayTexture],[i])}onResize(){let e=I.presentationSize,t=e[0],r=e[1];this.godRayTexture.resize(t,r),this.historyGodRayData.resizeBuffer(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData),this.godRayCompute.workerSizeX=Math.ceil(this.godRayTexture.width/8),this.godRayCompute.workerSizeY=Math.ceil(this.godRayTexture.height/8),this.godRayCompute.workerSizeZ=1}render(e,t){if(!this.godRayCompute){this.createResource(),this.createCompute(e);let n=ae.getLightEntries(e.scene);this.godRayCompute.setStorageBuffer("lightBuffer",n.storageGPUBuffer),this.godRayCompute.setStorageBuffer("models",ae.modelMatrixBindGroup.matrixBufferDst),this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GodRay";let l=ae.getCameraGroup(e.camera);this.godRayCompute.setUniformBuffer("globalUniform",l.uniformGPUBuffer)}let r=m.setting.render.postProcessing.godRay;this.godRaySetting.setFloat("intensity",r.intensity),this.godRaySetting.setFloat("rayMarchCount",r.rayMarchCount);let i=I.presentationSize,a=i[0],s=i[1];this.godRaySetting.setFloat("viewPortWidth",a),this.godRaySetting.setFloat("viewPortHeight",s),this.godRaySetting.setFloat("blendColor",r.blendColor?1:0),this.godRaySetting.setFloat("scatteringExponent",r.scatteringExponent),this.godRaySetting.apply(),w.computeCommand(t,[this.godRayCompute]),w.lastRenderPassState=this.rendererPassState}}class Tc{indexList;color;count}class Dc{SlotCount=8;MaxEntities=16;defaultColor=new P(.2,1,1,1);slots=[];dataDirty=!0;constructor(){let e=m.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(e,this.SlotCount));for(let t=0;t<this.SlotCount;t++){let r=this.slots[t]=new Tc;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let e=0;e<this.SlotCount;e++)this.clearAt(e)}clearAt(e){this.dataDirty=!0;let t=this.slots[e];return t.color.copyFrom(this.defaultColor),t.indexList.fill(-1),t.count=0,this}fillDataAt(e,t,r){this.dataDirty=!0;let i=this.slots[e];if(i){i.indexList.fill(-1);for(let a=0,s=t.length;a<s;a++)i.indexList[a]=t[a];i.count=t.length,i.color.copyFrom(r)}return this}fetchData(e){return e.dirty=this.dataDirty,e.slots=this.slots,this.dataDirty=!1,this}}let Lt=new Dc;class Qp extends Ct{outlineTex;lowTex;rendererPassState;calcWeightCompute;outlineCompute;blendCompute;outlineSetting;slotsBuffer;slotsArray;entitiesArray;entitiesBuffer;weightBuffer;lowTexSize;oldOutlineColor;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.outline.enable=!0}onDetach(e){m.setting.render.postProcessing.outline.enable=!1}set outlinePixel(e){e=j(e,0,8);let t=m.setting.render.postProcessing.outline;t.outlinePixel!=e&&(t.outlinePixel=e)}get outlinePixel(){return m.setting.render.postProcessing.outline.outlinePixel}set fadeOutlinePixel(e){let t=m.setting.render.postProcessing.outline;e=j(e,0,8),t.fadeOutlinePixel!=e&&(t.fadeOutlinePixel=e)}get fadeOutlinePixel(){return m.setting.render.postProcessing.outline.fadeOutlinePixel}set strength(e){e=j(e,0,1);let t=m.setting.render.postProcessing.outline;t.strength!=e&&(t.strength=e)}get strength(){return m.setting.render.postProcessing.outline.strength}set useAddMode(e){m.setting.render.postProcessing.outline.useAddMode=e}get useAddMode(){return m.setting.render.postProcessing.outline.useAddMode}createGUI(){}createCompute(){let t=we.getGBufferFrame("ColorPassGBuffer").getPositionMap();this.calcWeightCompute=new ie(hu),this.calcWeightCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.calcWeightCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.calcWeightCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.calcWeightCompute.setStorageBuffer("entitiesBuffer",this.entitiesBuffer),this.calcWeightCompute.setSamplerTexture("indexTexture",t),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute=new ie(uu),this.outlineCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.outlineCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.outlineCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.outlineCompute.setStorageBuffer("oldOutlineColor",this.oldOutlineColor),this.outlineCompute.setStorageTexture("lowTex",this.lowTex),this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute=new ie(lu),this.blendCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.autoSetColorTexture("inTex",this.blendCompute),this.blendCompute.setSamplerTexture("lowTex",this.lowTex),this.blendCompute.setStorageTexture("outlineTex",this.outlineTex),this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}createResource(){let e=I.presentationSize,t=e[0],r=e[1],i=m.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new V(Math.ceil(t*i),Math.ceil(r*i)),this.lowTex=new fe(this.lowTexSize.x,this.lowTexSize.y,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lowTex.name="lowTex";let a=new ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outlineTex=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outlineTex.name="outlineTex";let s=new ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.rtFrame=new Oe([this.outlineTex],[s]),this.outlineSetting=new ct(8),this.weightBuffer=new Z(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.oldOutlineColor=new Z(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.slotsArray=new Float32Array(Lt.SlotCount*4),this.slotsBuffer=new Z(this.slotsArray.length),this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesArray=new Float32Array(Lt.SlotCount*Lt.MaxEntities),this.entitiesBuffer=new Z(this.entitiesArray.length),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.slotsBuffer.apply(),this.fetchData||={}}fetchData;fetchOutlineData(){if(Lt.fetchData(this.fetchData),this.fetchData.dirty){let e=Lt.SlotCount,t=Lt.MaxEntities;for(let r=0;r<e;r++){let i=4*r,a=this.fetchData.slots[r];this.slotsArray[i+0]=a.color.r,this.slotsArray[i+1]=a.color.g,this.slotsArray[i+2]=a.color.b,this.slotsArray[i+3]=a.count,i=t*r,this.entitiesArray.set(a.indexList,i)}this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.entitiesBuffer.apply()}}computeList;render(e,t){this.calcWeightCompute||(this.createResource(),this.createCompute(),this.createGUI(),this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null)),this.computeList||=[this.calcWeightCompute,this.outlineCompute,this.blendCompute];let r=m.setting.render.postProcessing.outline;this.outlineSetting.setFloat("strength",r.strength),this.outlineSetting.setFloat("useAddMode",r.useAddMode?1:0),this.outlineSetting.setFloat("outlinePixel",r.outlinePixel),this.outlineSetting.setFloat("fadeOutlinePixel",r.fadeOutlinePixel),this.outlineSetting.setFloat("lowTexWidth",this.lowTexSize.x),this.outlineSetting.setFloat("lowTexHeight",this.lowTexSize.y),this.outlineSetting.apply(),this.fetchOutlineData(),w.computeCommand(t,this.computeList),w.lastRenderPassState=this.rendererPassState}onResize(){let e=I.presentationSize,t=e[0],r=e[1],i=m.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new V(Math.ceil(t*i),Math.ceil(r*i)),this.lowTex.resize(this.lowTexSize.x,this.lowTexSize.y),this.outlineTex.resize(t,r),this.weightBuffer.resizeBuffer(this.lowTexSize.x*this.lowTexSize.y*4),this.oldOutlineColor.resizeBuffer(this.lowTexSize.x*this.lowTexSize.y*4),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}}class Vp extends Ct{SSR_RayTraceCompute;SSR_IS_Compute;SSR_Blend_Compute;isRetTexture;finalTexture;rendererPassState;ssrUniformBuffer;rayTraceData;ssrColorData;isKernelFloat32Array;rtFrame;historyPosition;constructor(){super()}onAttach(e){m.setting.render.postProcessing.ssr.enable=!0,this.debug()}onDetach(e){m.setting.render.postProcessing.ssr.enable=!1}reflectionRatio=.5;get fadeEdgeRatio(){return m.setting.render.postProcessing.ssr.fadeEdgeRatio}set fadeEdgeRatio(e){e=j(e,0,1);let t=m.setting.render.postProcessing.ssr;t.fadeEdgeRatio=e}get rayMarchRatio(){return m.setting.render.postProcessing.ssr.rayMarchRatio}set rayMarchRatio(e){e=j(e,0,1);let t=m.setting.render.postProcessing.ssr;t.rayMarchRatio=e}get roughnessThreshold(){return m.setting.render.postProcessing.ssr.roughnessThreshold}set roughnessThreshold(e){e=j(e,0,1);let t=m.setting.render.postProcessing.ssr;t.roughnessThreshold=e}get fadeDistanceMin(){return m.setting.render.postProcessing.ssr.fadeDistanceMin}set fadeDistanceMin(e){e=j(e,0,1e4);let t=m.setting.render.postProcessing.ssr;t.fadeDistanceMin=e}get fadeDistanceMax(){return m.setting.render.postProcessing.ssr.fadeDistanceMax}set fadeDistanceMax(e){e=j(e,0,1e4);let t=m.setting.render.postProcessing.ssr;t.fadeDistanceMax=e}get powDotRN(){return m.setting.render.postProcessing.ssr.powDotRN}set powDotRN(e){e=j(e,0,1);let t=m.setting.render.postProcessing.ssr;t.powDotRN=e}debug(){}createRayTraceShader(){this.SSR_RayTraceCompute=new ie(pu),this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_RayTraceCompute.setStorageBuffer("historyPosition",this.historyPosition);let e=we.getGBufferFrame("ColorPassGBuffer");this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture",e.getPositionMap()),this.SSR_RayTraceCompute.setSamplerTexture(Le.normalBufferTex_NAME,e.renderTargets[2]),this.SSR_RayTraceCompute.setSamplerTexture(Le.materialBufferTex_NAME,e.renderTargets[3]),k.instance.sky instanceof Ia&&this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap",k.instance.sky.map),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1}createISShader(){this.SSR_IS_Compute=new ie(gu),this.SSR_IS_Compute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_IS_Compute.setStorageBuffer("ssrColorData",this.ssrColorData),this.SSR_IS_Compute.setStorageBuffer("historyPosition",this.historyPosition),this.autoSetColorTexture("colorMap",this.SSR_IS_Compute),this.SSR_IS_Compute.setStorageTexture("outTex",this.isRetTexture),this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1}createBlendShader(e){this.SSR_Blend_Compute=new ie(du),this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.autoSetColorTexture("colorMap",this.SSR_Blend_Compute),this.SSR_Blend_Compute.setSamplerTexture("ssrMap",e),this.SSR_Blend_Compute.setStorageTexture("outTex",this.finalTexture),this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}createResource(){let e=I.presentationSize,t=e[0],r=e[1];this.finalTexture=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.finalTexture.name="ssrOutTex";let i=new ce;i.clearValue=[0,0,0,0],i.loadOp="clear";let a=Math.ceil(t*m.setting.render.postProcessing.ssr.pixelRatio),s=Math.ceil(r*m.setting.render.postProcessing.ssr.pixelRatio);this.isRetTexture=new fe(a,s,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.isRetTexture.name="ssrTextureIn";let n=new ce;n.clearValue=[0,0,0,0],n.loadOp="clear",this.rtFrame=new Oe([this.finalTexture,this.isRetTexture],[i,n]),this.rayTraceData=new Z(a*s*8,GPUBufferUsage.COPY_SRC),this.ssrColorData=new Z(a*s*4,GPUBufferUsage.COPY_SRC),this.historyPosition=new Z(a*s*4,GPUBufferUsage.COPY_SRC),this.ssrUniformBuffer=new ct(4*8),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.ssrUniformBuffer.apply()}render(e,t){if(!this.SSR_RayTraceCompute){this.createResource(),this.createISShader(),this.createRayTraceShader(),this.createBlendShader(this.isRetTexture),this.finalTexture,this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null);let a=ae.getCameraGroup(e.camera);this.SSR_RayTraceCompute.setUniformBuffer("standUniform",a.uniformGPUBuffer)}let r=m.setting.render.postProcessing.ssr;this.ssrUniformBuffer.setFloat("fadeEdgeRatio",r.fadeEdgeRatio),this.ssrUniformBuffer.setFloat("rayMarchRatio",r.rayMarchRatio),this.ssrUniformBuffer.setFloat("fadeDistanceMin",r.fadeDistanceMin),this.ssrUniformBuffer.setFloat("fadeDistanceMax",r.fadeDistanceMax),this.ssrUniformBuffer.setFloat("mixThreshold",r.mixThreshold),this.ssrUniformBuffer.setFloat("roughnessThreshold",r.roughnessThreshold),this.ssrUniformBuffer.setFloat("reflectionRatio",this.reflectionRatio),this.ssrUniformBuffer.setFloat("powDotRN",r.powDotRN),this.ssrUniformBuffer.setFloat("randomSeedX",Math.random()),this.ssrUniformBuffer.setFloat("randomSeedY",Math.random()),this.ssrUniformBuffer.apply();let i=[this.SSR_RayTraceCompute,this.SSR_IS_Compute,this.SSR_Blend_Compute];w.computeCommand(t,i),w.lastRenderPassState=this.rendererPassState}onResize(){let e=I.presentationSize,t=e[0],r=e[1],i=Math.ceil(t*m.setting.render.postProcessing.ssr.pixelRatio),a=Math.ceil(r*m.setting.render.postProcessing.ssr.pixelRatio);this.finalTexture.resize(t,r),this.isRetTexture.resize(i,a),this.rayTraceData.resizeBuffer(i*a*8),this.ssrColorData.resizeBuffer(i*a*4),this.historyPosition.resizeBuffer(i*a*4),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1,this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1,this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}}class Hp{static createSeeds(){let e=20,t=32,r=[new d(0,0,e)],i=0,a=.02;for(let s=1;s<t;s++){let n=new d;r.push(n),i+=1-(1-.618)*s/t,a+=s*.01,n.x=Math.sin(i)*a,n.y=Math.cos(i)*a,n.z=1-s/t,n.multiplyScalar(e)}return r}}class Yp extends Ct{taaTexture;outTexture;rendererPassState;taaCompute;copyTexCompute;sharpCompute;taaSetting;preColorBuffer;preColorTex;preProjMatrix;preViewMatrix;rtFrame;constructor(){super()}onAttach(e){m.setting.render.postProcessing.taa.enable=!0,e.camera.enableJitterProjection(!0),this.createGUI()}onDetach(e){m.setting.render.postProcessing.taa.enable=!1,e.camera.enableJitterProjection(!1)}get jitterSeedCount(){return m.setting.render.postProcessing.taa.jitterSeedCount}set jitterSeedCount(e){e=j(e,2,8),e=Math.round(e);let t=m.setting.render.postProcessing.taa;t.jitterSeedCount=e}get blendFactor(){return m.setting.render.postProcessing.taa.blendFactor}set blendFactor(e){e=j(e,0,1);let t=m.setting.render.postProcessing.taa;t.blendFactor=e}get sharpFactor(){return m.setting.render.postProcessing.taa.sharpFactor}set sharpFactor(e){e=j(e,.1,.9);let t=m.setting.render.postProcessing.taa;t.sharpFactor=e}get sharpPreBlurFactor(){return m.setting.render.postProcessing.taa.sharpPreBlurFactor}set sharpPreBlurFactor(e){e=j(e,.1,.9);let t=m.setting.render.postProcessing.taa;t.sharpPreBlurFactor=e}get temporalJitterScale(){return m.setting.render.postProcessing.taa.temporalJitterScale}set temporalJitterScale(e){e=j(e,0,1);let t=m.setting.render.postProcessing.taa;t.temporalJitterScale=e}createGUI(){}createCompute(e){let t=new ie(vu);m.setting.render.postProcessing.taa;let r=new ct(16*2+4*3),i=ae.getCameraGroup(e.camera);t.setUniformBuffer("standUniform",i.uniformGPUBuffer),t.setUniformBuffer("taaData",r),t.setStorageBuffer("preColorBuffer",this.preColorBuffer);let a=we.getGBufferFrame("ColorPassGBuffer");t.setSamplerTexture("preColorTex",this.preColorTex),t.setSamplerTexture("posTex",a.getPositionMap()),this.autoSetColorTexture("inTex",t),t.setStorageTexture("outTex",this.taaTexture),t.workerSizeX=Math.ceil(this.taaTexture.width/8),t.workerSizeY=Math.ceil(this.taaTexture.height/8),t.workerSizeZ=1,this.taaCompute=t,this.taaSetting=r,this.copyTexCompute=new ie(mu),this.copyTexCompute.setStorageBuffer("preColor",this.preColorBuffer),this.copyTexCompute.setStorageTexture("preColorTex",this.preColorTex),this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute=new ie(Au),this.sharpCompute.setUniformBuffer("taaData",r),this.sharpCompute.setSamplerTexture("inTex",this.taaTexture),this.sharpCompute.setStorageTexture("outTex",this.outTexture),this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}createResource(){this.preProjMatrix=new R().identity(),this.preViewMatrix=new R().identity();let e=I.presentationSize,t=e[0],r=e[1];this.preColorBuffer=new Z(t*r*4,GPUBufferUsage.COPY_SRC),this.preColorTex=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.preColorTex.name="taaTex";let i=new ce;i.clearValue=[0,0,0,1],i.loadOp="clear",this.taaTexture=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.taaTexture.name="taaTex";let a=new ce;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outTexture=new fe(t,r,z.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="sharpTaaTex";let s=new ce;s.clearValue=[0,0,0,1],s.loadOp="clear",this.rtFrame=new Oe([this.preColorTex,this.taaTexture,this.outTexture],[i,a,s])}render(e,t){this.taaCompute||(this.createResource(),this.createCompute(e),this.rendererPassState=Ce.createRendererPassState(this.rtFrame,null));let r=m.setting.render.postProcessing.taa;this.taaSetting.setMatrix("preProjMatrix",this.preProjMatrix),this.taaSetting.setMatrix("preViewMatrix",this.preViewMatrix),this.taaSetting.setFloat("jitterFrameIndex",e.camera.jitterFrameIndex),this.taaSetting.setFloat("blendFactor",r.blendFactor),this.taaSetting.setFloat("sharpFactor",r.sharpFactor),this.taaSetting.setFloat("sharpPreBlurFactor",r.sharpPreBlurFactor),this.taaSetting.setFloat("jitterX",e.camera.jitterX),this.taaSetting.setFloat("jitterY",e.camera.jitterY),this.taaSetting.apply(),w.computeCommand(t,[this.copyTexCompute,this.taaCompute,this.sharpCompute]),w.lastRenderPassState=this.rendererPassState,this.preProjMatrix.copyFrom(e.camera.projectionMatrix),this.preViewMatrix.copyFrom(e.camera.viewMatrix)}onResize(){let e=I.presentationSize,t=e[0],r=e[1];this.preColorBuffer.resizeBuffer(t*r*4),this.taaTexture.resize(t,r),this.outTexture.resize(t,r),this.preColorTex.resize(t,r),this.taaCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.taaCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.taaCompute.workerSizeZ=1,this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}}class Pc{_tempIndexArray=[];setOutline(e,t){this.setOutlineList([e],t?[t]:null)}setOutlineList(e,t){e||=[];let r=Lt.defaultColor,i=Lt.SlotCount;for(let a=0;a<i;a++){this._tempIndexArray.length=0;let s=e[a],n=(t?t[a]:null)||r;if(s)for(const l of s)this.getEntityIdList(l,this._tempIndexArray);Lt.fillDataAt(a,this._tempIndexArray,n)}}clearOutline(){return Lt.clear(),this}_rendererList=[];getEntityIdList(e,t){this._rendererList.length=0;let r=e.getComponents(c.MeshRenderer,this._rendererList);for(const i of r)t.push(i.object3D.transform._worldMatrix.index)}}let Xp=new Pc;class Mc{localPosition=new d;worldPosition=new d;uv=new V;faceIndex;isIn=!1;t=0;u=0;v=0;triangle;v0;v1;v2;pickList;color}class ti{static EPS=1e-4;static FLT_MAX=3402823466e29;static distPtTri(e,t,r,i){let a=new d,s=new d,n=new d;i.subtract(t,a),r.subtract(t,s),e.subtract(t,n);let l=Xe(a,a),h=Xe(a,s),u=Xe(a,n),f=Xe(s,s),g=Xe(s,n),p=1/(l*f-h*h),A=(f*u-h*g)*p,v=(l*g-h*u)*p;if(A>=-ti.EPS&&v>=-ti.EPS&&A+v<=1+ti.EPS){let C=t[1]+a[1]*A+s[1]*v;return Math.abs(C-e[1])}return ti.FLT_MAX}static _info=new Mc;static IntersectTriangle(e,t,r){let i=t.v1,a=t.v2,s=t.v3,n=a.subtract(i,d.HELP_3),l=s.subtract(i,d.HELP_4),h=e.direction.crossProduct(l,d.HELP_5),u=Xe(n,h),f;if(u>0){if(r)return null;f=e.origin.subtract(i,d.HELP_2)}else f=i.subtract(e.origin,d.HELP_2),u=-u;if(u<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let g=Xe(f,h);if(g<0||g>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let p=f.crossProduct(n,d.HELP_1),A=Xe(e.direction,p);if(A<0||g+A>u)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let v=Xe(l,p),C=1/u;v*=C,g*=C,A*=C,this._info.isIn=!0,this._info.t=v,this._info.u=g,this._info.v=A;let x=1-g-A;return this._u0.copyFrom(t.u1),this._u0.scale(x),this._u1.copyFrom(t.u2),this._u1.scale(g),this._u2.copyFrom(t.u3),this._u2.scale(A),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(e.direction).multiplyScalar(v),this._info.localPosition.add(e.origin,this._info.localPosition),this._info}static _u0=new V;static _u1=new V;static _u2=new V}class Ra extends Xt{static _instance;_maxRetry=3;loadAll(e,t){return new Promise((r,i)=>{let a=e.length,s=[];e.forEach((n,l)=>{let h=new t;this.load(n,t).then(u=>{h.parse(u),s.push(h),a--,a===0&&r(s)})})})}constructor(){if(super(),Ra._instance)throw new Error("LoadManager is singleton class...")}static getInstance(){return this._instance||(this._instance=new Ra)}loadUrls(e,t){return new Promise((r,i)=>{let a=e.length,s=[];e.forEach((n,l)=>{this.load(n,t).then(h=>{s.push(h),a--,a===0&&r(s),a<0&&console.error(`loadUrls ${e} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(e){this._maxRetry=e}load(e,t){return new Promise((r,i)=>{switch(t.format){}})}}var Ua=(o=>(o.Point="Point",o.LineString="LineString",o.MultiPolygon="MultiPolygon",o))(Ua||{});class jp extends it{static format=Pe.JSON;json;async parseString(e){this.json=e,this.data=JSON.parse(e)}}class Wp{static getPath(e){let t=[];for(let r=0;r<e.features.length;r++){const i=e.features[r];switch(i.geometry.type){case Ua.LineString:break;case Ua.MultiPolygon:let a=[];for(let s=0;s<i.geometry.coordinates.length;s++){const n=i.geometry.coordinates[s];for(const l of n)for(const h of l){let u=new d(h[0],0,h[1]);a.push(u)}}t.push(a);break}}return t}}class qp{}class Kp{}class Jp{}class Zp{}class $p{}class em{}class tm{}class rm{}class im{}class am{}class Rc{boneName;bonePath;parentBoneName;boneID;parentBoneID;instanceID;parentInstanceID;t;q;s;formBytes(e){this.boneName=e.readUTF(),this.bonePath=e.readUTF(),this.parentBoneName=e.readUTF(),this.boneID=e.readInt32(),this.parentBoneID=e.readInt32(),this.instanceID=e.readUTF(),this.parentInstanceID=e.readUTF(),this.t=e.readVector3(),this.q=e.readQuaternion(),this.s=e.readVector3()}}class Uc{name;count;boneData;boneMap;formBytes(e){this.boneData=[],this.boneMap=new Map,this.name=e.readUTF(),this.count=e.readInt32();for(let t=0;t<this.count;t++){let r=new Rc;r.formBytes(e.readBytesArray()),this.boneData[t]=r,this.boneMap.set(r.boneName,r)}}}class Lc extends it{static format=Pe.BIN;static parser(e,t){let r=e.readInt32();for(let i=0;i<r;i++){let a=new Uc;a.formBytes(e.readBytesArray()),m.res.addObj(a.name,a)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}M.position,M.normal,M.color,M.TANGENT,M.uv,M.TEXCOORD_1,M.TEXCOORD_2,M.TEXCOORD_2,M.TEXCOORD_4,M.TEXCOORD_5,M.TEXCOORD_6,M.TEXCOORD_7,M.joints0,M.weights0;var O=(o=>(o[o.single=0]="single",o[o.boolean=1]="boolean",o[o.int=2]="int",o[o.int16=3]="int16",o[o.int32=4]="int32",o[o.float=5]="float",o[o.long=6]="long",o[o.uint=7]="uint",o[o.uint32=8]="uint32",o[o.uint64=9]="uint64",o[o.double=10]="double",o[o.string=11]="string",o[o.singleArray=12]="singleArray",o[o.stringArray=13]="stringArray",o[o.floatArray=14]="floatArray",o[o.vector2=15]="vector2",o[o.vector3=16]="vector3",o[o.vector4=17]="vector4",o[o.color=18]="color",o[o.color32=19]="color32",o[o.animationCurve=20]="animationCurve",o[o.quaternion=21]="quaternion",o[o.matrix4x4=22]="matrix4x4",o[o.mesh=23]="mesh",o[o.texture=24]="texture",o[o.material=25]="material",o[o.materials=26]="materials",o[o.skeleton=27]="skeleton",o[o.animClip=28]="animClip",o[o.vector2Int=29]="vector2Int",o[o.int32List=30]="int32List",o[o.colorList=31]="colorList",o[o.color32List=32]="color32List",o))(O||{});class La{static GetMaterial(e){let t=e,r=t.split("/");t=r[r.length-1],r=t.split("."),t=r[r.length-1];let i=Ro(t);if(i){let a=new We;return a.shader=new i,a}else throw new Error("not found shader, shader name is "+t)}static applyMaterialTexture(e,t){for(let r=0;r<t.length;r++){const i=t[r];i.property in e?e[i.property]=i.texture:i.property in e.shader?e.shader[i.property]=i.texture:e.setTexture(i.property,i.texture)}}static applyMaterialProperties(e,t){for(let r=0;r<t.length;r++){const i=t[r],a=i.key;switch(i.type){case O.color:case O.color32:{let s=i.getValue();a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformColor(a,s)}break;case O.single:case O.float:case O.int:case O.int16:case O.int32:case O.uint:case O.uint32:case O.uint64:{let s=i.getValue();a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformFloat(a,s)}break;case O.singleArray:{let s=i.getValue()[0];a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformFloat(a,s)}break;case O.vector2:case O.vector2Int:{let s=i.getValue();a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformVector2(a,s)}break;case O.vector3:{let s=i.getValue();a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformVector3(a,s)}break;case O.vector4:{let s=i.getValue();a in e?e[a]=s:a in e.shader?e.shader[a]=s:e.setUniformVector4(a,s)}break}}}}class Ht{static parser(e){switch(e.readInt32()){case O.single:return{t:O.single,v:e.readFloat32()};case O.boolean:return{t:O.boolean,v:e.readBoolean()};case O.int:return{t:O.int,v:e.readInt32()};case O.int16:return{t:O.int16,v:e.readInt16()};case O.int32:return{t:O.int32,v:e.readInt32()};case O.float:return{t:O.float,v:e.readFloat32()};case O.long:return{t:O.long,v:e.readFloat64()};case O.uint:return{t:O.uint,v:e.readUnit32()};case O.uint32:return{t:O.uint32,v:e.readUnit32()};case O.uint64:return{t:O.uint64,v:e.readUnit32()};case O.double:return{t:O.double,v:e.readFloat64()};case O.string:return{t:O.string,v:e.readUTF()};case O.singleArray:return{t:O.singleArray,v:e.readFloatArray()};case O.stringArray:return{t:O.stringArray,v:e.readStringArray()};case O.floatArray:return{t:O.floatArray,v:e.readFloatArray()};case O.vector2:return{t:O.vector2,v:e.readVector2()};case O.vector3:return{t:O.vector3,v:e.readVector3()};case O.vector4:return{t:O.vector4,v:e.readVector4()};case O.color:return{t:O.color,v:e.readColor()};case O.color32:return{t:O.color32,v:e.readColor()};case O.animationCurve:return{t:O.animationCurve,v:null};case O.quaternion:return{t:O.quaternion,v:e.readQuaternion()};case O.matrix4x4:return{t:O.matrix4x4,v:null};case O.mesh:{let n=e.readUTF(),l=m.res.getGeometry(n);return{t:O.mesh,v:l}}case O.texture:{let n=e.readUTF(),l=m.res.getTexture(n);return{t:O.texture,v:l}}case O.material:{let n=e.readUTF(),l=m.res.getMat(n);return{t:O.material,v:l}}case O.materials:{let n=e.readStringArray(),l=[];for(let h=0;h<n.length;h++){const u=n[h];let f=m.res.getMat(u);l.push(f)}return{t:O.materials,v:l}}case O.skeleton:break;case O.animClip:{let n=[],l=e.readInt32();for(let h=0;h<l;h++){let u=new Hc;u.formBytes(e),n.push(u)}return{t:O.animClip,v:n}}case O.vector2Int:return{t:O.vector2Int,v:e.readVector2int()};case O.int32List:return{t:O.int32List,v:e.readInt32List()};case O.colorList:let r=e.readInt32(),i=[];for(let n=0;n<r;n++){const l=Ht.parser(e).v;i.push(l)}return{t:O.colorList,v:i};case O.color32List:let a=e.readInt32(),s=[];for(let n=0;n<a;n++){const l=Ht.parser(e).v;s.push(l)}return{t:O.color32List,v:s}}}}class ro{key;type;_data;getValue(){return this._data}formBytes(e){this.key=e.readUTF();let{t,v:r}=Ht.parser(e);this.type=t,this._data=r}}class Oc{property;name;texture;texelSize;wrapModeU;wrapModeV;wrapModeW;wrapMode;anisoLevel;dimension;filterMode}class Fc extends it{static format=Pe.TEXT;static parserMaterial(e,t){let r=e.readInt32();for(let i=0;i<r;i++){let a=e.readBytesArray(),s=a.readUTF(),n=a.readUTF();a.readUTF();let l=a.readStringArray();a.readVector4(),a.readVector4();let h=a.readUTF(),u=[],f=[],g=a.readInt32();for(let v=0;v<g;v++){let C=new ro;C.formBytes(a),u.push(C)}let p=a.readInt32();for(let v=0;v<p;v++){let C=a.readBytesArray(),x=new Oc;x.property=C.readUTF(),x.name=C.readUTF(),x.texture=m.res.getTexture(x.name),x.texelSize=C.readVector2(),x.wrapModeU=C.readUnit32(),x.wrapModeV=C.readUnit32(),x.wrapModeW=C.readUnit32(),x.wrapMode=C.readUnit32(),x.anisoLevel=C.readUnit32(),x.dimension=C.readUnit32(),x.filterMode=C.readUnit32(),f.push(x)}let A=La.GetMaterial(h);A.name=s;for(let v=0;v<l.length;v++){const C=l[v];A.shader.setDefine(C,!0)}La.applyMaterialTexture(A,f),La.applyMaterialProperties(A,u),m.res.addMat(n,A)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}class Nc{shapeName;shapeIndex;frameCount;blendPositionList=new Float32Array;blendNormalList=new Float32Array;formBytes(e){let t=e.readBytesArray();this.shapeName=t.readUTF(),this.shapeIndex=t.readInt32(),this.frameCount=t.readInt32();let r=t.readInt32();this.blendPositionList=t.readFloat32Array(r*3);let i=t.readInt32();this.blendNormalList=t.readFloat32Array(i*3)}}class zc{vertexCount;shapeNames;shapeIndexs;blendCount;blendShapePropertyDatas;blendShapeMap;formBytes(e){this.blendShapeMap=new Map,this.blendShapePropertyDatas=[];let t=e.readBytesArray();this.vertexCount=t.readInt32(),this.shapeNames=t.readStringArray(),this.shapeIndexs=t.readIntArray(),this.blendCount=t.readInt32();for(let r=0;r<this.blendCount;r++){let i=new Nc;i.formBytes(t),this.blendShapePropertyDatas.push(i),this.blendShapeMap.set(i.shapeName,i)}return e}}class kc{name;meshName;meshID;vertexCount;vertexStrip;vertexBuffer;indices;attributes;bones;bindPose;blendShapeData}class Gc extends it{static format=Pe.BIN;async parseBuffer(e){}static parserMeshs(e,t){let r=e.readInt32();for(let i=0;i<r;i++){let a=new kc,s=e.readBytesArray();a.meshName=s.readUTF(),a.meshID=s.readUTF(),s.readFloat32()>0,s.readFloat32()>0,s.readFloat32()>0;let n=s.readFloat32()>0,l=s.readFloat32()>0;n&&(a.bones=s.readStringArray(),a.bindPose=s.readMatrix44Array()),l&&(a.blendShapeData=new zc,a.blendShapeData.formBytes(s));let h=s.readBytesArray(),u=s.readBytesArray(),f=h.readInt32(),g=0,p=[];for(let S=0;S<f;S++)p[S]={},p[S].att=sm[h.readUTF()],p[S].dim=h.readInt32(),g+=p[S].dim,p[S].format=h.readUTF();a.vertexCount=h.readInt32(),a.vertexBuffer=u.getFloat32Array();let A=s.readInt32Array(),v=[],C=s.readInt32();for(let S=0;S<C;S++){let y=s.readInt32(),b=s.readInt32(),D=s.readInt32(),B=s.readInt32(),T=s.readInt32(),U=s.readInt32();s.readVector3(),s.readVector3();let E={indexStart:b,indexCount:D,vertexStart:B,vertexCount:U,firstStart:T,topology:y,index:S};v.push(E)}A.length>65535?a.indices=new Uint32Array(A):a.indices=new Uint16Array(A);let x=new ve;if(x.vertexDim=g,x.geometryType=je.compose_bin,x.setIndices(a.indices),x.setAttribute(M.all,a.vertexBuffer),n&&(x.skinNames=a.bones,x.bindPose=a.bindPose),l){x.blendShapeData=a.blendShapeData,x.morphTargetsRelative=!0,x.morphTargetDictionary={};for(let S=0;S<a.blendShapeData.blendCount;S++){x.setAttribute("a_morphPositions_"+S,a.blendShapeData.blendShapePropertyDatas[S].blendPositionList),x.setAttribute("a_morphNormals_"+S,a.blendShapeData.blendShapePropertyDatas[S].blendNormalList);for(let y=0;y<a.blendShapeData.blendCount;y++){let b=a.blendShapeData.shapeNames[y],D=a.blendShapeData.shapeIndexs[y];x.morphTargetDictionary[b]=D}}}for(let S=0;S<p.length;S++){const y=p[S].att;x.setAttribute(y,null)}for(let S=0;S<v.length;S++){const y=v[S];x.addSubGeometry(y)}x.name=a.meshName,m.res.addGeometry(a.meshID,x)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}let sm={Position:M.position,Normal:M.normal,Color:M.color,Tangent:M.TANGENT,TexCoord0:M.uv,TexCoord1:M.TEXCOORD_1,TexCoord2:M.TEXCOORD_2,TexCoord3:M.TEXCOORD_2,TexCoord4:M.TEXCOORD_4,TexCoord5:M.TEXCOORD_5,TexCoord6:M.TEXCOORD_6,TexCoord7:M.vIndex,BlendIndices:M.joints0,BlendWeight:M.weights0};class Oa extends DataView{position=0;littleEndian=!0;constructor(e,t,r){super(e,t,r),this.position=0,this.position+=this.byteOffset}readUTF(){let e=this.readInt32(),t=e%4;t>0&&t<4&&(t=4-t);let r="",i=new Int8Array(this.buffer,this.position,e);return this.position+=e*Int8Array.BYTES_PER_ELEMENT,r+=String.fromCharCode.apply(null,i),this.position+=t*Int8Array.BYTES_PER_ELEMENT,r}readStringArray(){let e=[],t=this.readInt32();for(let r=0;r<t;r++)e.push(this.readUTF());return e}readByte(){let e=this.buffer[this.position];return this.position+=1,e}readBoolean(){let e=this.readInt32();return this.position+=4,e==1}readBytes(e){let t=new DataView(this.buffer,this.position,e);return this.position+=e,t.buffer}readBytesArray(){let e=this.readInt32(),t=new Oa(this.buffer.slice(this.position,this.position+e));return this.position+=e,t}readUnit8(){let e=this.getUint8(this.position);return this.position+=Uint8Array.BYTES_PER_ELEMENT,e}readUnit16(){let e=this.getUint16(this.position);return this.position+=Uint16Array.BYTES_PER_ELEMENT,e}readUnit32(){let e=this.getUint32(this.position);return this.position+=Uint32Array.BYTES_PER_ELEMENT,e}readInt8(){let e=this.getInt8(this.position);return this.position+=Int8Array.BYTES_PER_ELEMENT,e}readInt16(){let e=this.getInt16(this.position,this.littleEndian);return this.position+=Int16Array.BYTES_PER_ELEMENT,e}readInt32(){let e=this.getInt32(this.position,this.littleEndian);return this.position+=Int32Array.BYTES_PER_ELEMENT,e}readFloat32(){let e=this.getFloat32(this.position,this.littleEndian);return this.position+=Float32Array.BYTES_PER_ELEMENT,e}readFloat64(){let e=this.getFloat64(this.position,this.littleEndian);return this.position+=Float64Array.BYTES_PER_ELEMENT,e}readInt32Array(){let e=this.readInt32(),t=new Int32Array(this.buffer,this.position,e);return t=t.slice(0,e),this.position+=t.byteLength,t}readInt32List(){let e=this.readInt32(),t=[];for(let r=0;r<e;r++)t.push(this.readInt32());return t}readFloatArray(){let e=this.readInt32(),t=[];for(let r=0;r<e;r++){let i=this.readFloat32();t.push(i)}return t}readIntArray(){let e=this.readInt32(),t=[];for(let r=0;r<e;r++){let i=this.readInt32();t.push(i)}return t}readVector2int(){let e=new V;return e.x=this.readInt32(),e.y=this.readInt32(),e}readVector2(){let e=new V;return e.x=this.readFloat32(),e.y=this.readFloat32(),e}readVector3(){let e=new d;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e}readVector3Array(){let e=[],t=this.readInt32();for(let r=0;r<t;r++)e.push(this.readVector3());return e}readVector4(){let e=new G;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readVector4Array(){let e=[],t=this.readInt32();for(let r=0;r<t;r++)e.push(this.readVector4());return e}readColor(){let e=new P;return e.r=this.readFloat32(),e.g=this.readFloat32(),e.b=this.readFloat32(),e.a=this.readFloat32(),e}readColorArray(){let e=[],t=this.readInt32();for(let r=0;r<t;r++)e.push(this.readColor());return e}readQuaternion(){let e=new Y;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readQuaternionArray(){let e=[],t=this.readInt32();for(let r=0;r<t;r++)e.push(this.readQuaternion());return e}readMatrix44(){let e=new R,t=e.rawData;return t[0]=this.readFloat32(),t[1]=this.readFloat32(),t[2]=this.readFloat32(),t[3]=this.readFloat32(),t[4]=this.readFloat32(),t[5]=this.readFloat32(),t[6]=this.readFloat32(),t[7]=this.readFloat32(),t[8]=this.readFloat32(),t[9]=this.readFloat32(),t[10]=this.readFloat32(),t[11]=this.readFloat32(),t[12]=this.readFloat32(),t[13]=this.readFloat32(),t[14]=this.readFloat32(),t[15]=this.readFloat32(),e}readMatrix44Array(){let e=this.readInt32(),t=[];for(let r=0;r<e;r++){let i=this.readMatrix44();t.push(i)}return t}readFloat32Array(e){let t=new Float32Array(this.buffer,this.position,e);return t=t.slice(0,this.byteLength),this.position+=e*Float32Array.BYTES_PER_ELEMENT,t}getFloat32Array(){let e=new Float32Array(this.buffer,this.byteOffset,this.byteLength/Float32Array.BYTES_PER_ELEMENT);return e=e.slice(0,this.byteLength),e}}class Qc extends it{static format=Pe.TEXT;static async parserTexture(e,t,r){let i=e.readInt32(),a=[];for(let n=0;n<i;n++){let l=e.readUTF();Vc.useWebp?(l=l.replace("png","webp"),l=l.replace("jpb","webp"),a.push(t.baseUrl+"webp/"+l)):a.push(t.baseUrl+l)}let s=await m.res.loadBitmapTextures(a,m.setting.loader.numConcurrent,r,!0);for(const n of s)m.res.addTexture(n.name,n)}verification(){if(this.data)return!0;throw new Error("verify failed.")}}var om=Object.defineProperty,nm=Object.getOwnPropertyDescriptor,lm=(o,e,t,r)=>{for(var i=r>1?void 0:r?nm(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&om(e,t,i),i};c.LitSSSShader=class extends ke{constructor(){super(),F.register("PBRLitSSSShader",Tu);let e=new Ae("PBRLitSSSShader","PBRLitSSSShader");e.setShaderEntry("VertMain","FragMain"),this.addRenderPass(e);let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefault(),this.debug(),this.computes=[new _c(this)]}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor",new P),this.setUniformColor("emissiveColor",new P(1,1,1)),this.setUniformVector4("materialF0",new G(.04,.04,.04,1)),this.setUniformColor("specularColor",new P(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new P(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformColor("skinColor",new P(1,0,0)),this.setUniformFloat("skinPower",3.4),this.setUniformFloat("skinColorIns",.5),this.setUniformFloat("curveFactor",1)}set _MainTex(e){this.setTexture("baseMap",e)}set _BumpMap(e){this.setTexture("normalMap",e)}set _SSSMap(e){this.setTexture("sssMap",e)}set _MaskTex(e){this.setTexture("maskMap",e)}set _UVTransform(e){this.setUniformVector4("transformUV1",e)}set _Metallic(e){this.setUniformFloat("metallic",e)}set _Roughness(e){this.setUniformFloat("roughness",e)}set _MainColor(e){this.setUniformColor("baseColor",e)}set _AlphaCutoff(e){this.setUniformFloat("alphaCutoff",e)}set _DoubleSidedEnable(e){let t=this.getDefaultColorShader();t.shaderState.cullMode=e?at.none:t.shaderState.cullMode}set _SkinColor(e){this.setUniformColor("skinColor",e)}set _SkinPower(e){this.setUniformFloat("skinPower",e)}set _SkinColorIns(e){this.setUniformFloat("skinColorIns",e)}set curveFactor(e){this.setUniformFloat("curveFactor",e)}set _SurfaceType(e){let t=this.getDefaultColorShader();e==0?t.blendMode=ee.NONE:t.blendMode=ee.ALPHA}set _AlphaCutoffEnable(e){e==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}},c.LitSSSShader=lm([jt],c.LitSSSShader);var hm=Object.defineProperty,um=Object.getOwnPropertyDescriptor,cm=(o,e,t,r)=>{for(var i=r>1?void 0:r?um(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&hm(e,t,i),i};c.LitShader=class extends ke{constructor(){super();let e=new Ae("PBRLItShader","PBRLItShader");e.setShaderEntry("VertMain","FragMain"),this.addRenderPass(e);let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor",new P),this.setUniformColor("emissiveColor",new P(0,0,0)),this.setUniformVector4("materialF0",new G(.04,.04,.04,1)),this.setUniformColor("specularColor",new P(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new P(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this._MainTex=m.res.grayTexture,this._BumpMap=m.res.normalTexture,this._MaskTex=m.res.maskTexture}set _MainTex(e){this.setTexture("baseMap",e)}set _BumpMap(e){this.setTexture("normalMap",e)}set _MaskTex(e){this.setTexture("maskMap",e)}set _UVTransform(e){this.setUniformVector4("transformUV1",e)}set _Metallic(e){this.setUniformFloat("metallic",e)}set _Roughness(e){this.setUniformFloat("roughness",e)}set _MainColor(e){this.setUniformColor("baseColor",e)}set _AlphaCutoff(e){this.setUniformFloat("alphaCutoff",e)}set _DoubleSidedEnable(e){let t=this.getDefaultColorShader();t.shaderState.cullMode=e?at.none:t.shaderState.cullMode}set _SurfaceType(e){let t=this.getDefaultColorShader();e==0?t.blendMode=ee.NONE:t.blendMode=ee.ALPHA}set _AlphaCutoffEnable(e){e==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}},c.LitShader=cm([jt],c.LitShader);class Fa{comName;data;static parser(e){let t=e.readBytesArray(),r=new Fa;r.comName=t.readUTF(),r.data=[];let i=t.readInt32();for(let a=0;a<i;a++){let s=new ro;s.formBytes(t),r.data.push(s)}return r}}class Ni{name;parentName;position;rotation;scale;comDatas;child;static parser(e){let t=e.readBytesArray(),r=new Ni;r.name=t.readUTF(),r.parentName=t.readUTF(),r.position=t.readVector3(),r.rotation=t.readQuaternion(),r.scale=t.readVector3(),r.comDatas=[],r.child=[];let i=t.readInt32();for(let s=0;s<i;s++){const n=Fa.parser(t);r.comDatas.push(n)}let a=t.readInt32();for(let s=0;s<a;s++){const n=Ni.parser(t);r.child.push(n)}return r}}class Vc extends it{static useWebp=!0;static format=Pe.BIN;avatarDic;nodeData;async parseBuffer(e){this.avatarDic={};let t=new Oa(e,0);await Qc.parserTexture(t,this,this.loaderFunctions),Lc.parser(t,this),Gc.parserMeshs(t,this),Fc.parserMaterial(t,this),this.nodeData=this.parserPrefabNode(t),this.data=this.data=this.parserNodeTree(this.nodeData)}parserPrefabNode(e){return Ni.parser(e)}parserNodeTree(e){let t=new c.Object3D;if(t.localPosition=d.serialize(e.position),t.localQuaternion=Y.serialize(e.rotation),t.localScale=d.serialize(e.scale),t.name=e.name,e.comDatas)for(let r=0;r<e.comDatas.length;r++){const i=e.comDatas[r];let a=null,s=Mo(i.comName);if(s){a=t.getOrAddComponent(s);for(let n=0;n<i.data.length;n++){const l=i.data[n];l.key in a&&(a[l.key]=l.getValue())}}}if(e.child&&e.child.length>0)for(let r=0;r<e.child.length;r++){let i=this.parserNodeTree(e.child[r]);t.addChild(i)}return t}verification(){if(this.data)return!0;throw new Error("verify failed.")}}class fm{static getNumber(e){return parseFloat(e)}static getInt(e){return parseInt(e)}static getBoolean(e){return e=="true"}static getNumberArray(e){let t=e.replaceAll("[","");t=t.replaceAll("]","");let r=t.split(",");for(let i=0;i<r.length;i++)parseFloat(r[i]);return t}static getStringArray(e){let t=e.replaceAll("[","");t=t.replaceAll("]","");let r=t.split(","),i=[];for(let a=0;a<r.length;a++){const s=r[a];i.push(s)}return i}static getVector2(e){}static getVector3(e){}static getVector4(e){}static getQuaternion(e){}static getColor(e){}}var dm=Object.defineProperty,gm=Object.getOwnPropertyDescriptor,pm=(o,e,t,r)=>{for(var i=r>1?void 0:r?gm(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&dm(e,t,i),i};c.LitHairShader=class extends ke{constructor(){super(),this.create_opPass(),this.setDefine("USEC",!0),this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_HAIR",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefine("USE_HAIRCOLOR",!0),this.setDefault(),this.debug()}create_opPass(){F.register("HairShader_op",Bu);let e=new Ae("HairShader_op","HairShader_op");this.addRenderPass(e),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.blendMode=ee.NONE,t.cullMode=at.none,t.writeMasks[0]=GPUColorWrite.ALL}create_trPass(){F.register("HairShader_tr",Eu);let e=new Ae("HairShader_tr","HairShader_tr");this.addRenderPass(e),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.depthWriteEnabled=!1,t.blendMode=ee.NORMAL,t.cullMode=at.none,t.writeMasks[0]=GPUColorWrite.ALL,t.writeMasks[1]=0,t.writeMasks[2]=0,t.writeMasks[3]=0}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor0",new P(3/255,2/255,2/255)),this.setUniformColor("baseColor1",new P(2/255,2/255,2/255)),this.setUniformColor("emissiveColor",new P(1,1,1)),this.setUniformVector4("materialF0",new G(.04,.04,.04,1)),this.setUniformColor("specularColor",new P(36/255,36/255,36/255)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",.1),this.setUniformFloat("metallic",.3),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",.1),this.setUniformFloat("ior",1.5),this.setUniformFloat("backlit",.3987),this.setUniformFloat("area",.0615)}set _MainTex(e){this.setTexture("baseMap",e)}set _IDMap(e){this.setTexture("idMap",e)}set _DepthMap(e){this.setTexture("depthMap",e)}set _RootMap(e){this.setTexture("rootMap",e)}set _AlphaMap(e){this.setTexture("alphaMap",e)}set _UVTransform(e){this.setUniformVector4("transformUV1",e)}set _Metallic(e){this.setUniformFloat("metallic",e)}set _Roughness(e){this.setUniformFloat("roughness",e)}set _HairColor0(e){this.setUniformColor("baseColor0",e)}set _HairColor1(e){this.setUniformColor("baseColor1",e)}set _SpecularColor(e){this.setUniformColor("specularColor",e)}set _AlphaCutoff(e){this.setUniformFloat("alphaCutoff",e)}set _BackLit(e){this.setUniformFloat("backlit",e)}set _Area(e){this.setUniformFloat("area",e)}set _DoubleSidedEnable(e){let t=this.getSubShaders(W.COLOR)[0];t.shaderState.cullMode=e?at.none:t.shaderState.cullMode}set _SurfaceType(e){}set _AlphaCutoffEnable(e){e==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}},c.LitHairShader=pm([jt],c.LitHairShader);var mm=Object.defineProperty,Am=Object.getOwnPropertyDescriptor,vm=(o,e,t,r)=>{for(var i=r>1?void 0:r?Am(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&mm(e,t,i),i};c.UnLitShader=class extends ke{constructor(){super();let e=new Ae("UnLit","UnLit");e.setShaderEntry("VertMain","FragMain"),this.addRenderPass(e);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new G(0,0,1,1)),this.setUniformVector4("transformUV2",new G(0,0,1,1)),this.setUniformColor("baseColor",new P),this.setUniformFloat("alphaCutoff",0)}set _MainTex(e){this.setTexture("baseMap",e)}set _BumpMap(e){this.setTexture("normalMap",e)}set _MaskTex(e){this.setTexture("maskMap",e)}set _UVTransform(e){this.setUniformVector4("transformUV1",e)}set _Metallic(e){this.setUniformFloat("metallic",e)}set _Roughness(e){this.setUniformFloat("roughness",e)}set _MainColor(e){this.setUniformColor("baseColor",e)}set _AlphaCutoff(e){this.setUniformFloat("alphaCutoff",e)}set _DoubleSidedEnable(e){let t=this.getDefaultColorShader();t.shaderState.cullMode=e?at.none:t.shaderState.cullMode}set _SurfaceType(e){let t=this.getDefaultColorShader();e==0?t.blendMode=ee.NONE:t.blendMode=ee.ALPHA}set _AlphaCutoffEnable(e){e==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}},c.UnLitShader=vm([jt],c.UnLitShader);var _m=Object.defineProperty,xm=Object.getOwnPropertyDescriptor,Cm=(o,e,t,r)=>{for(var i=r>1?void 0:r?xm(e,t):e,a=o.length-1,s;a>=0;a--)(s=o[a])&&(i=(r?s(e,t,i):s(i))||i);return r&&i&&_m(e,t,i),i};c.APatch=class extends _e{size;blockSize;walk;obs;colors;aPaths;onGraphic(e){}},c.APatch=Cm([mt(c.APatch,"APatch")],c.APatch);class Sm{weight;deltaVertices;deltaNormals;deltaTangents;formBytes(e){let t=e.readBytesArray();this.weight=t.readFloat32();let r=0;r=t.readInt32(),this.deltaVertices=t.readFloat32Array(r*3),r=t.readInt32(),this.deltaNormals=t.readFloat32Array(r*3),r=t.readInt32(),this.deltaTangents=t.readFloat32Array(r*3)}}class ym{asset;extras;geometricError;properties;refine;root}class wm{boundingVolume;children;geometricError;transform}class Im{boundingVolume;geometricError;refine;content;contents}class bm{uri;group;metadata}class Bm{class;properties}class io{group;_modelList;_tileSet;_rootPath;constructor(){this.group=new c.Object3D}async loadTileSet(e,t){this._modelList=[],this._rootPath=e;let r=e+"/"+t;if(this._tileSet=await m.res.loadJSON(r),this._tileSet.root.transform){let n=new R;for(let l=0;l<16;l++)n.rawData[l]=this._tileSet.root.transform[l]}let i=new R;switch((this._tileSet.asset&&this._tileSet.asset.gltfUpAxis||"y").toLowerCase()){case"x":i.makeRotationAxis(d.Y_AXIS,-Math.PI/2);break;case"y":i.makeRotationAxis(d.X_AXIS,Math.PI/2);break;case"z":i.identity();break}let s=i.clone();s.invert(),this.applyTransform(this.group.transform,s);for(let n of this._tileSet.root.children){let l=[];if(n.content&&n.content.uri&&l.push(n.content.uri),n.contents)for(let h of n.contents)l.push(h.uri);for(let h of l){let u=this._rootPath+"/"+h,f={onProgress:p=>this.onLoadProgress(p),onComplete:p=>this.onComplete(p)},g;if(u.endsWith(".glb"))g=await m.res.loadGltf(u,f),this.applyTransform(g.transform,i);else if(u.endsWith("tileset.json")){let p=u.replace("/tileset.json",""),A=new io;await A.loadTileSet(p,"tileset.json"),g=A.group}else u.endsWith(".i3dm")?g=await m.res.loadI3DM(u,f,i):u.endsWith(".b3dm")&&(g=await m.res.loadB3DM(u,f,i));g&&(this._modelList.push(g),this.group.addChild(g))}}}onLoadProgress(e){}onComplete(e){}applyTransform(e,t){let r=t.decompose(qt.QUATERNION);e.localRotQuat.copyFrom(r[1]),e.localRotQuat=e.localRotQuat,e.localPosition.copyFrom(r[0]),e.localPosition=e.localPosition,e.localScale.copyFrom(r[2]),e.localScale=e.localScale}}class Em extends We{static count=0;constructor(){super(),F.register("ColorLitShader",wu),this.shader=new ke;let e=new Ae("ColorLitShader","ColorLitShader");e.passType=W.COLOR,this.shader.addRenderPass(e),e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain"),e.setUniformColor("baseColor",new P),e.setUniformColor("emissiveColor",new P),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",0),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("alphaCutoff",0);let t=e.shaderState;t.acceptShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,e.setTexture("normalMap",m.res.normalTexture),e.setTexture("emissiveMap",m.res.blackTexture)}clone(){return null}debug(){}}class Tm extends We{constructor(){super(),F.register("GlassShader",bu),this.shader=new ke;let e=new Ae("GlassShader","GlassShader");e.passType=W.COLOR,e.setDefine("USE_BRDF",!0),e.setShaderEntry("VertMain","FragMain");let t=e.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.shader.setTexture("baseMap",m.res.whiteTexture),this.shader.setTexture("normalMap",m.res.normalTexture),this.shader.setTexture("emissiveMap",m.res.blackTexture)}}class Dm extends We{constructor(){super();let e=new Ae("LambertShader","LambertShader");e.setShaderEntry("VertMain","FragMain"),e.passType=W.COLOR,e.setUniformVector4("transformUV1",new G(0,0,1,1)),e.setUniformVector4("transformUV2",new G(0,0,1,1)),e.setUniformColor("baseColor",new P(1,1,1,1)),e.setUniformFloat("alphaCutoff",.5);let t=e.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1;let r=new ke;r.addRenderPass(e),this.shader=r,this.baseMap=m.res.grayTexture}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(e){}set shadowMap(e){}}function Pm(o,e){}class Mm extends We{constructor(){super(),this.init()}init(){let e=m.res.getTexture("BRDFLUT");this.brdfLUT=e,this.setDefault(),this.baseMap=m.res.whiteTexture,this.normalMap=m.res.normalTexture,this.emissiveMap=m.res.blackTexture,this.alphaCutoff=.5}setDefault(){let e=this.shader.getDefaultColorShader();e.setUniformFloat("shadowBias",35e-5),e.setUniformVector4("transformUV1",new G(0,0,1,1)),e.setUniformVector4("transformUV2",new G(0,0,1,1)),e.setUniformColor("baseColor",new P),e.setUniformColor("emissiveColor",new P(1,1,1)),e.setUniformVector4("materialF0",new G(.04,.04,.04,1)),e.setUniformColor("specularColor",new P(.04,.04,.04)),e.setUniformFloat("envIntensity",1),e.setUniformFloat("normalScale",1),e.setUniformFloat("roughness",1),e.setUniformFloat("metallic",0),e.setUniformFloat("ao",1),e.setUniformFloat("roughness_min",0),e.setUniformFloat("roughness_max",1),e.setUniformFloat("metallic_min",0),e.setUniformFloat("metallic_max",1),e.setUniformFloat("emissiveIntensity",0),e.setUniformFloat("alphaCutoff",0),e.setUniformFloat("ior",1.5),e.setUniformFloat("clearcoatFactor",0),e.setUniformFloat("clearcoatRoughnessFactor",0),e.setUniformColor("clearcoatColor",new P(1,1,1)),e.setUniformFloat("clearcoatWeight",0)}get baseMap(){return this.shader.getDefaultColorShader().getTexture("baseMap")}set baseMap(e){this.shader.getDefaultColorShader().setTexture("baseMap",e)}get baseColor(){return this.shader.getDefaultColorShader().getUniform("baseColor")}set baseColor(e){this.shader.getDefaultColorShader().setUniformColor("baseColor",e)}get normalMap(){return this.shader.getDefaultColorShader().getTexture("normalMap")}set normalMap(e){this.shader.getDefaultColorShader().setTexture("normalMap",e)}get doubleSide(){return this.shader.getDefaultColorShader().doubleSide}set doubleSide(e){this.shader.getDefaultColorShader().doubleSide=e}get alphaCutoff(){return this.shader.getDefaultColorShader().shaderState.alphaCutoff}set alphaCutoff(e){this.shader.getDefaultColorShader().setDefine("USE_ALPHACUT",!0),this.shader.getDefaultColorShader().shaderState.alphaCutoff=e,this.shader.getDefaultColorShader().setUniform("alphaCutoff",e)}get emissiveColor(){return this.shader.getDefaultColorShader().getUniform("emissiveColor")}set emissiveColor(e){this.shader.getDefaultColorShader().setUniform("emissiveColor",e)}get emissiveIntensity(){return this.shader.getDefaultColorShader().getUniform("emissiveIntensity")}set emissiveIntensity(e){this.shader.getDefaultColorShader().setUniform("emissiveIntensity",e)}get uvTransform_1(){return this.shader.getDefaultColorShader().uniforms.transformUV1.vector4}set uvTransform_1(e){this.shader.getDefaultColorShader().setUniform("transformUV1",e)}get uvTransform_2(){return this.shader.getDefaultColorShader().uniforms.transformUV2.vector4}set uvTransform_2(e){this.shader.getDefaultColorShader().setUniform("transformUV2",e)}get depthWriteEnabled(){return this.shader.getDefaultColorShader().shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.shader.getDefaultColorShader().shaderState.depthWriteEnabled=e}get materialF0(){return this.shader.getDefaultColorShader().uniforms.materialF0.vector4}set materialF0(e){this.shader.getDefaultColorShader().setUniform("materialF0",e)}get specularColor(){return this.shader.getDefaultColorShader().uniforms.specularColor.color}set specularColor(e){this.shader.getDefaultColorShader().setUniform("specularColor",e)}get roughness(){return this.shader.getDefaultColorShader().uniforms.roughness.value}set roughness(e){this.shader.getDefaultColorShader().setUniform("roughness",e)}get metallic(){return this.shader.getDefaultColorShader().uniforms.metallic.value}set metallic(e){this.shader.getDefaultColorShader().setUniform("metallic",e)}get ao(){return this.shader.getDefaultColorShader().uniforms.ao.value}set ao(e){this.shader.getDefaultColorShader().setUniform("ao",e)}get metallic_min(){return this.shader.getDefaultColorShader().uniforms.metallic_min.value}set metallic_min(e){this.shader.getDefaultColorShader().setUniform("metallic_min",e)}get metallic_max(){return this.shader.getDefaultColorShader().uniforms.metallic_max.value}set metallic_max(e){this.shader.getDefaultColorShader().setUniform("metallic_max",e)}get roughness_min(){return this.shader.getDefaultColorShader().uniforms.roughness_min.value}set roughness_min(e){this.shader.getDefaultColorShader().setUniform("roughness_min",e)}get roughness_max(){return this.shader.getDefaultColorShader().uniforms.roughness_max.value}set roughness_max(e){this.shader.getDefaultColorShader().setUniform("roughness_max",e)}get normalScale(){return this.shader.getDefaultColorShader().uniforms.normalScale.value}set normalScale(e){this.shader.getDefaultColorShader().setUniform("normalScale",e)}get maskMap(){return this.shader.getDefaultColorShader().textures.maskMap}set maskMap(e){this.shader.getDefaultColorShader().setDefine("USE_MR",!0),this.shader.getDefaultColorShader().setTexture("maskMap",e)}set aoMap(e){e&&(this.shader.getDefaultColorShader().setTexture("aoMap",e),e!=m.res.whiteTexture&&this.shader.getDefaultColorShader().setDefine("USE_AOTEX",!0))}get aoMap(){return this.shader.getDefaultColorShader().textures.aoMap}set clearCoatRoughnessMap(e){e&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.shader.getDefaultColorShader().setTexture("clearCoatRoughnessMap",e),this.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.shader.getDefaultColorShader().textures.clearCoatRoughnessMap}get brdfLUT(){return this.shader.getDefaultColorShader().textures.brdfLUT}set brdfLUT(e){this.shader.getDefaultColorShader().setTexture("brdfLUT",e),this.shader.getDefaultColorShader().setTexture("brdflutMap",e)}get emissiveMap(){return this.shader.getDefaultColorShader().textures.emissiveMap}set emissiveMap(e){this.shader.getDefaultColorShader().setTexture("emissiveMap",e)}set envIntensity(e){this.shader.getDefaultColorShader().setUniformFloat("envIntensity",e)}get envIntensity(){return this.shader.getDefaultColorShader().uniforms.envIntensity.value}set ior(e){this.shader.getDefaultColorShader().setUniformFloat("ior",e)}get ior(){return this.shader.getDefaultColorShader().uniforms.ior.value}useCleanCoat(){this.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(e){this.shader.getDefaultColorShader().setUniformFloat("clearcoatFactor",e),this.useCleanCoat()}get clearcoatFactor(){return this.shader.getDefaultColorShader().uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(e){this.shader.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor",e),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.shader.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(e){this.shader.getDefaultColorShader().setUniformFloat("clearcoatWeight",e),this.useCleanCoat()}get clearcoatWeight(){return this.shader.getDefaultColorShader().uniforms.clearcoatWeight.value}set clearcoatColor(e){this.shader.getDefaultColorShader().setUniformColor("clearcoatColor",e),this.useCleanCoat()}get clearcoatColor(){return this.shader.getDefaultColorShader().uniforms.clearcoatColor.color}}class Na extends We{constructor(){super(),this.shader=new c.UnLitShader,this.baseMap=m.res.whiteTexture}set baseMap(e){this.shader.setTexture("baseMap",e)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(e){this.shader.setUniformColor("baseColor",e)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(e){}set shadowMap(e){}}class Hc{clipName;loopTime;startTime;stopTime;sampleRate;useSkeletonPos;useSkeletonScale;positionCurves=new Map;rotationCurves=new Map;scaleCurves=new Map;floatCurves=new Map;formBytes(e){if(this.clipName=e.readUTF(),this.loopTime=!e.readInt32(),this.startTime=e.readFloat32(),this.stopTime=e.readFloat32(),this.sampleRate=e.readInt32(),this.useSkeletonPos=e.readInt32()>0,this.useSkeletonScale=e.readInt32()>0,this.useSkeletonPos){let i=e.readInt32();for(let a=0;a<i;a++){let s=new zi;s.formBytes(e),this.positionCurves.set(s.path,s)}}let t=e.readInt32();for(let i=0;i<t;i++){let a=new zi;a.formBytes(e),this.rotationCurves.set(a.path,a)}if(this.useSkeletonScale){let i=e.readInt32();for(let a=0;a<i;a++){let s=new zi;s.formBytes(e),this.scaleCurves.set(s.path,s)}}let r=e.readInt32();for(let i=0;i<r;i++){let a=new zi;a.formBytes(e),this.floatCurves.set(a.attribute,a)}}}class zi{path;attribute;propertys;preInfinity;postInfinity;rotationOrder;m_curves;k=0;_cacheValue;_kValue;constructor(e=1){this.k=e,this.m_curves=[],this.check()}check(){for(let e=0;e<this.k;e++)this.m_curves[e]||=new wi;switch(this.k){case 1:this._cacheValue=0;break;case 2:this._cacheValue=new V;break;case 3:this._cacheValue=new d;break;case 4:this._cacheValue=new G;break}}get totalTime(){return this.m_curves[0].totalTime}addKeyFrame(e){for(let t=0;t<this.k;t++)this.m_curves[t].addKeyFrame(e.getK(t))}removeKeyFrame(e){for(let t=0;t<this.k;t++)this.m_curves[t].removeKeyFrame(e.getK(t))}getValue(e){switch(this.k){case 1:this._cacheValue=this.m_curves[0].getValue(e);break;case 2:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e);break;case 3:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e),this._cacheValue.z=this.m_curves[2].getValue(e);break;case 4:this._cacheValue.x=this.m_curves[0].getValue(e),this._cacheValue.y=this.m_curves[1].getValue(e),this._cacheValue.z=this.m_curves[2].getValue(e),this._cacheValue.w=this.m_curves[3].getValue(e);break}return this._cacheValue}getKeyCount(){return this.m_curves[0].getKeyCount()}getKey(e){let t=[];for(let r=0;r<this.k;r++)t.push(this.m_curves[r].getKey(e));return t}formBytes(e){this.path=e.readUTF(),this.k=e.readInt32(),this.check(),this.attribute=e.readUTF(),this.propertys=this.attribute.split("."),this.preInfinity=e.readInt32(),this.postInfinity=e.readInt32(),this.rotationOrder=e.readInt32();let t=e.readInt32();for(let r=0;r<t;r++){let i=new tf(0);i.formBytes(e),this.addKeyFrame(i)}}}class za{_points;_cacheValue;constructor(e=[]){this.points=e,this._cacheValue=new V}get points(){return this._points}set points(e){this._points=e}getValue(e){e<0&&(e=0),e>1&&(e=1);let t=this.points.length-1,r=Math.floor(t*e),i=r+1,a=Ye.fract((t+1)*e);return i>=t&&(i=r,a=0),this._cacheValue.x=this.points[r].x+(this.points[i].x-this.points[r].x)*a,this._cacheValue.y=this.points[r].y+(this.points[i].y-this.points[r].y)*a,this._cacheValue}static createBezierPoints(e,t){for(var r=new za,i=0;i<t;i++){var a=za.multiPointBezier(e,i/t);r.points.push(a)}return r}static multiPointBezier(e,t){for(var r=e.length,i=0,a=0,s=function(h,u){for(var f=1,g=1;u>0;)f*=h,g*=u,h--,u--;return f/g},n=0;n<r;n++){var l=e[n];i+=l.x*Math.pow(1-t,r-1-n)*Math.pow(t,n)*s(r-1,n),a+=l.y*Math.pow(1-t,r-1-n)*Math.pow(t,n)*s(r-1,n)}return new V(i,a)}}class Rm{static tmp_points=[];static calculateCubicBezierPoint(e,t,r,i,a){e>1&&(e=1),e<0&&(e=0);let s=1-e,n=s*s,l=s*s*s,h=e*e,u=e*e*e,f=t.mul(l),g=r.mul(3);g=g.mul(e),g=g.mul(n);let p=i.mul(3);p=p.mul(h),p=p.mul(s);let A=a.mul(u);return f=f.add(g),f=f.add(p),f=f.add(A),f}static bezierPoint(e,t,r,i){e>1&&(e=1),e<0&&(e=0);let a=1-e,s=a*a,n=e*e,l=t.mul(s),h=r.mul(2);h.scaleBy(a),h.scaleBy(e);let u=i.mul(n);return l=l.add(h),l=l.add(u),l}static calculateCubicBezierPoints(e,t,r){e>1&&(e=1),e<0&&(e=0);let i=1-e,a=i*i,s=i*i*i,n=e*e,l=e*e*e,h=t[r].mul(s),u=t[r+1].mul(3);u=u.mul(e),u=u.mul(a);let f=t[r+2].mul(3);f=f.mul(n),f=f.mul(i);let g=t[r+3].mul(l);return h=h.add(u),h=h.add(f),h=h.add(g),h}static bezierPathValue(e,t){e>1&&(e=1),e<0&&(e=0);let r=t.length,i=this.tmp_points;i.length=0;for(let a=1;a<r;++a)for(let s=0;s<r-a;++s){if(a==1){let l=new d;l.x=t[s].x*(1-e)+t[s+1].x*e,l.y=t[s].y*(1-e)+t[s+1].y*e,l.z=t[s].z*(1-e)+t[s+1].z*e,this.tmp_points.push(l);continue}let n=new d;n.x=i[s].x*(1-e)+i[s+1].x*e,n.y=i[s].y*(1-e)+i[s+1].y*e,n.z=i[s].z*(1-e)+i[s+1].z*e,i.push(n)}return i[0]}}class Um extends Map{negtive;constructor(e){if(super(e),this.negtive=new Map,e)for(let t of e)this.negtive.set(t[1],t[0])}delete(e){if(this.has(e)){let t=this.get(e);return this.negtive.delete(t),super.delete(e)}return!1}getKey(e){return this.negtive.get(e)}deleteValue(e){let t=this.negtive.get(e);return t&&this.delete(t),this.negtive.delete(e)}set(e,t){return super.set(e,t),this.negtive.set(t,e),this}clear(){this.negtive.clear(),super.clear()}}class ka{controlVertices;constructor(e){this.setControlVertices(e)}setControlVertices(e){e.length==4&&(this.controlVertices=e.concat())}getPoint(e){if(!(e>=0&&e<=1))return d.ZERO;let t=1-e,r=t*t*t,i=3*e*t*t,a=3*e*e*t,s=e*e*e;return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(i)).add(this.controlVertices[2].mul(a)).add(this.controlVertices[3].mul(s))}getTangent(e){if(!(e>=0&&e<=1))return d.ZERO;let t=this.controlVertices,r=t[0].add(t[1].add(t[0]).mul(e)),i=t[1].add(t[2].add(t[1]).mul(e)),a=t[2].add(t[3].add(t[2]).mul(e)),s=r.add(i.subtract(r).mul(e));return i.add(a.subtract(i).mul(e)).subtract(s)}getClosestParam(e,t=1e-6){return this.getClosestParamRec(e,0,1,t)}getClosestParamRec(e,t,r,i){let a=(t+r)/2;if(r-t<i)return a;let s=(t+a)/2,n=(a+r)/2,l=this.getPoint(s),h=this.getPoint(n),u=l.subtract(e).lengthSquared,f=h.subtract(e).lengthSquared;return u<f?r=a:t=a,this.getClosestParamRec(e,t,r,i)}}var Yc=(o=>(o[o.Open=0]="Open",o[o.Closed=1]="Closed",o))(Yc||{});class Lm{type=0;numCurveSegments=0;numControlVertices=0;controlVertices=[];constructor(e,t=0){this.setControlVertices(e,t)}getPathType(){return this.type}isClosed(){return this.type==1}isValid(){return this.numCurveSegments>0}clear(){this.controlVertices.length=0,this.type=0,this.numCurveSegments=0,this.numControlVertices=0}computeApproxLength(){if(!this.isValid())return 0;let e=this.numCurveSegments+1;if(e<2)return 0;let t=0,r=this.controlVertices;for(let i=1;i<e;i++){let a=r[(i-1)*3],s=r[i*3];t+=a.subtract(s).lengthSquared}return t==0?0:t}computeApproxParamPerUnitLength(){let e=this.computeApproxLength();return this.numCurveSegments/e}computeApproxNormParamPerUnitLength(){return 1/this.computeApproxLength()}interpolatePoints(e,t){let r=e.length;r<2&&console.error("point count must great 1"),this.clear(),this.type=t;let i=this.controlVertices;switch(t){case 0:{this.numCurveSegments=r-1,this.numControlVertices=3*r-2,i.length=this.numControlVertices;for(let n=0;n<r;n++)i[n*3]=e[n];let a=e[1].subtract(e[0]).mul(.25);i[1]=e[0].add(a);let s=e[r-2].subtract(e[r-1]).mul(.25);i[this.numControlVertices-2]=e[r-1].add(s);for(let n=1;n<this.numCurveSegments;n++){let l=e[n-1].subtract(e[n]),h=e[n+1].subtract(e[n]),u=l.lengthSquared,f=h.lengthSquared;if(u>0&&f>0){let g=(u+f)/8,p=h.div(f).subtract(l.div(u));p.normalize(),p=p.mul(g),i[n*3-1]=e[n].subtract(p),i[n*3+1]=e[n].add(p)}else i[n*3-1]=e[n],i[n*3+1]=e[n]}break}case 1:{this.numCurveSegments=r,this.numControlVertices=3*r+1,i.length=this.numControlVertices;for(let a=0;a<r;a++)i[a*3]=e[a];i[this.numControlVertices-1]=e[0];for(let a=1;a<=this.numCurveSegments;a++){let s=a-1,n=(a+1)%this.numCurveSegments,l=a%this.numCurveSegments,h=e[s].subtract(e[l]),u=e[n].subtract(e[l]),f=h.lengthSquared,g=u.lengthSquared,p=3*a-1,A=(3*a+1)%(this.numControlVertices-1);if(f>0&&g>0){let v=(f+g)/8,C=u.div(g).subtract(h.div(f));C.normalize(),C=C.mul(v),i[p]=e[l].subtract(C),i[A]=e[l].add(C)}else i[p]=e[l],i[A]=e[l]}break}}}setControlVertices(e,t){let r=e.length;r<=0||t==0&&r<4||t==1&&r<7||(r-1)%3==0&&(this.clear(),this.type=t,this.numControlVertices=r,this.numCurveSegments=(r-1)/3,this.controlVertices=e)}getPoint(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=Ye.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=[],i=this.controlVertices;return r[0]=i[3*t+0],r[1]=i[3*t+1],r[2]=i[3*t+2],r[3]=i[3*t+3],new ka(r).getPoint(e-t)}getPointNorm(e){return this.getPoint(e*this.numCurveSegments)}getTangent(e){if(this.type==1){for(;e<0;)e+=this.numCurveSegments;for(;e>this.numCurveSegments;)e-=this.numCurveSegments}else e=Ye.clampf(e,0,this.numCurveSegments);if(!(e>=0)&&e<=this.numCurveSegments)return;let t=Math.floor(e);t>=this.numCurveSegments&&(t=this.numCurveSegments-1);let r=this.controlVertices,i=[];return i[0]=r[3*t+0],i[1]=r[3*t+1],i[2]=r[3*t+2],i[3]=r[3*t+3],new ka(i).getTangent(e-t)}getTangentNorm(e){return this.getTangent(e*this.numCurveSegments)}computeClosestParam(e,t){let r=Number.MAX_SAFE_INTEGER,i=0,a=[],s=new ka(a);for(let n=0;n<this.controlVertices.length-1;n+=3){for(let f=0;f<4;f++)a[f]=this.controlVertices[n+f];s.setControlVertices(a);let l=s.getClosestParam(e,t),u=s.getPoint(l).subtract(e).lengthSquared;u<r&&(r=u,i=n/3+l)}return i}computeClosestNormParam(e,t){return this.computeClosestParam(e,t*this.numCurveSegments)}}class Om extends Map{valueList;keyList;isChange=!0;constructor(e,t,r){if(super(e),t&&(this.keyList=[]),r&&(this.valueList=[]),e)for(let i of e)this.valueList?.push(i[1]),this.keyList?.push(i[0])}delete(e){if(this.has(e)){let t=this.get(e);return this.valueList&&this.deleteValue(t),this.keyList&&this.deleteKey(e),this.isChange=!0,super.delete(e)}return!1}deleteValue(e){let t=this.valueList.indexOf(e);return t>=0&&this.valueList.splice(t,1),this}deleteKey(e){let t=this.keyList.indexOf(e);return t>=0&&this.keyList.splice(t,1),this}set(e,t){return this.delete(e),this.keyList?.push(e),this.valueList?.push(t),super.set(e,t),this.isChange=!0,this}clear(){this.valueList&&(this.valueList.length=0),this.keyList&&(this.keyList.length=0),this.isChange=!0,super.clear()}}var Xc=(o=>(o[o.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",o[o.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",o[o.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",o[o.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",o[o.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",o[o.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",o[o.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",o[o.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",o[o.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",o[o.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",o[o.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",o[o.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",o[o.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",o))(Xc||{});const Fm=3.141592653589793;class Nm{}function jc(o,e,t){let r=.3333333333333333,i=.5,a=o*r,s=a*a,l=s*a-a*e*i+t*i,h=-s+e*r,u=h*h*h,f=u+l*l;if(f>=0){let A=Math.sqrt(f)-l;return A=A>0?Math.pow(A,r):-Math.pow(-A,r),-a-h/A+A}let g=Math.sqrt(-u),p=Math.acos(-l/g);return g=Math.pow(g,r),g=g-h/g,p=-a+g*Math.cos(p*r),p}function Ga(o,e,t,r){let i=1e-5;if(Math.abs(o)<i)return Math.abs(e)>i?(r.r0=-t/e,1):0;let a=e*e-4*o*t;if(a<0)return 0;let s=.5/o,n=Math.sqrt(a);return r.r0=(n-e)*s,r.r1=(-n-e)*s,2}function Wc(o,e,t,r,i){let a=0;if(Math.abs(e)>=1e-4){let s=t/e,n=r/e,l=i/e;o[0]=jc(s,n,l),a++;let h=e,u=t+e*o[0],f=r+t*o[0]+e*o[0]*o[0];a+=Ga(h,u,f,{r0:o[1],r1:o[2]})}else a+=Ga(t,r,i,{r0:o[1],r1:o[2]});return a}class Yt{coeff=[];static EvalSegment(e,t){return e*(e*(e*t[0]+t[1])+t[2])+t[3]}}class or{static kMaxNumSegments=8;segments=[];integrationCache=[];doubleIntegrationCache=[];times=[];segmentCount;constructor(){this.segments[or.kMaxNumSegments]=new Yt,this.integrationCache[or.kMaxNumSegments]=0,this.doubleIntegrationCache[or.kMaxNumSegments]=0,this.times[or.kMaxNumSegments]=0}calculateMinMax(e,t){e.x=Math.min(e.x,t),e.y=Math.max(e.y,t)}findMinMaxDoubleIntegrated(){let e=V.ZERO.clone(),t=20,r=1/t,i=r;for(let a=0;a<t;a++)this.calculateMinMax(e,this.evaluateDoubleIntegrated(i)),i+=r;return e}findMinMaxIntegrated(){let e=V.ZERO.clone(),t=[],r=[];for(let i=0;i<this.segmentCount;i++){let a=4*this.segments[i].coeff[0],s=3*this.segments[i].coeff[1],n=2*this.segments[i].coeff[2],l=1*this.segments[i].coeff[3],h=[],u=Wc(h,a,s,n,l);for(let f=0;f<u;f++){let g=h[f]+t[i];g>=t[i]&&g<r[i]&&this.calculateMinMax(e,this.evaluateIntegrated(g))}this.calculateMinMax(e,this.evaluateIntegrated(r[i])),this.times[i]}return e}generateIntegrationCache(e){e.integrationCache[0]=0;let t=e.times[0],r=0;for(let i=1;i<e.segmentCount;i++){let a=e.segments[i-1].coeff;ao(a);let s=t-r;e.integrationCache[i]=e.integrationCache[i-1]+Yt.EvalSegment(s,a)*s,r=t,t=e.times[i]}}generateDoubleIntegrationCache(e){let t=0,r=0;for(let i=0;i<e.segmentCount;i++){e.doubleIntegrationCache[i]=t;let a=e.times[i]-r;a=Math.max(a,0),t+=Yt.EvalSegment(a,e.segments[i].coeff)*a*a+e.integrationCache[i]*a,r=e.times[i]}}integrate(){this.generateIntegrationCache(this);for(let e=0;e<this.segmentCount;e++)ao(this.segments[e].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let e=0;e<this.segmentCount;e++)qc(this.segments[e].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(e){let t=e.getKeyCount(),r=t-1;return e.getKey(0).time!=0&&r++,e.getKey(t-1).time!=1&&r++,r<=or.kMaxNumSegments}evaluateDoubleIntegrated(e){let t=0;for(let r=0;r<this.segmentCount;r++){if(e<=this.times[r]){let i=e-t;return this.doubleIntegrationCache[r]+this.integrationCache[r]*i+Yt.EvalSegment(i,this.segments[r].coeff)*i*i}t=this.times[r]}return 1}evaluateIntegrated(e){let t=0;for(let r=0;r<this.segmentCount;r++){if(e<=this.times[r]){let i=e-t;return this.integrationCache[r]+Yt.EvalSegment(i,this.segments[r].coeff)*i}t=this.times[r]}return 1}evaluate(e){let t=0;for(let r=0;r<this.segmentCount;r++){if(e<=this.times[r])return Yt.EvalSegment(e-t,this.segments[r].coeff);t=this.times[r]}return 1}buildCurve(e,t){let r=e.getKeyCount();this.segmentCount=1;let i=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=i,r!=0)if(r==1)this.segments[0]=new Yt,this.segments[0].coeff[3]=e.getKey(0).value*t;else{this.segmentCount=r-1;let a=0;e.getKey(0).time!=0&&(this.segments[0].coeff[3]=e.getKey(0).value,this.times[0]=e.getKey(0).time,a=1);for(let s=0;s<this.segmentCount;s++){let n;e.calculateCacheData(n,s,s+1,0),this.segments[s+a].coeff=n.coeff.concat(),this.times[s+a]=e.getKey(s+1).time}this.segmentCount+=a,e.getKey(r-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=e.getKey(r-1).value,this.segmentCount++),this.times[this.segmentCount-1]=i;for(let s=0;s<this.segmentCount;s++)this.segments[s].coeff[0]*=t,this.segments[s].coeff[1]*=t,this.segments[s].coeff[2]*=t,this.segments[s].coeff[3]*=t}return!0}}function qc(o){o[0]/=20,o[1]/=12,o[2]/=6,o[3]/=2}function ao(o){o[0]/=4,o[1]/=3,o[2]/=2,o[3]/=1}var Kc=(o=>(o[o.kEMScalar=0]="kEMScalar",o[o.kEMOptimized=1]="kEMOptimized",o[o.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",o[o.kEMSlow=3]="kEMSlow",o))(Kc||{}),Jc=(o=>(o[o.kMMCScalar=0]="kMMCScalar",o[o.kMMCCurve=1]="kMMCCurve",o[o.kMMCTwoCurves=2]="kMMCTwoCurves",o[o.kMMCTwoConstants=3]="kMMCTwoConstants",o))(Jc||{});class zm{max;min}class km{max;min;integrate(){this.max.integrate(),this.min.integrate()}doubleIntegrate(){this.max.doubleIntegrate(),this.min.doubleIntegrate()}findMinMaxIntegrated(){return null}findMinMaxDoubleIntegrated(){return null}}class Zc{minMaxState;minCurve;maxCurve;_scalar=1;_minScalar;constructor(e=1){this._scalar=e,this.minMaxState=0,this.minCurve=new wi,this.maxCurve=new wi}setScalar(e){this._scalar=e}getScalar(){return this._scalar}static evaluateSlow(e,t,r){let i=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==2?wr(e.minCurve.getValue(t)*e.getScalar(),i,r):i}static evaluate(e,t,r=1){if(e.minMaxState==0)return e.getScalar();let i=e.maxCurve.getValue(t)*e.getScalar();return e.minMaxState==1?wr(e.minCurve.getValue(t)*e.getScalar(),i,r):e.minMaxState==3?wr(e._minScalar,e._scalar,r):e.minMaxState==2?wr(e.minCurve.getValue(t)*e.getScalar(),i,1*Math.random()):this.evaluateSlow(e,t,1)}unSerialized(e){this.minMaxState=e.minMaxState,this._scalar=e.scalar,this._minScalar=e.minScalar,this.maxCurve.unSerialized(e.maxCurve),this.minCurve.unSerialized(e.minCurve)}}class Gm{value=0;mode=0;spread=0;speed=new Zc;unSerialized(e){this.value=e.value,this.mode=e.mode,this.spread=e.spread,this.speed.unSerialized(e.speed)}}function Qm(o,e){let t=or.isValidCurve(o.max);return e!=2&&e!=3?t:t&&or.isValidCurve(o.min)}function Vm(o,e,t,r){o.max.buildCurve(e.max,t),r!=2&&r!=3?o.min.buildCurve(e.max,t):o.min.buildCurve(e.min,t)}function Hm(o,e){let t=e.getKeyCount();if(t!=0)if(t==1)ki(o,e.getKey(0).value);else{let r=t-1;ki(o,e.getKey(0).value);for(let i=0;i<r;i++){let a=new Vs;e.calculateCacheData(a,i,i+1,0);let s=3*a.coeff[0],n=2*a.coeff[1],l=1*a.coeff[2],h=e.getKey(i).time,u=e.getKey(i+1).time,f=[],g=Ga(s,n,l,{r0:f[0],r1:f[1]});for(let p=0;p<g;p++)f[p]>=0&&f[p]+h<u&&ki(o,Yt.EvalSegment(f[p],a.coeff));ki(o,Yt.EvalSegment(u-h,a.coeff))}}}function ki(o,e){o.x=Math.min(o.x,e),o.y=Math.max(o.y,e)}class so{point=new d;normal=d.UP;_tmpVecA=new d;constructor(e,t){this.point=e,this.normal=t}clone(){return new so(this.point.clone(),this.normal.clone())}intersectsLine(e,t,r){var i=-this.normal.dotProduct(this.point),a=this.normal.dotProduct(e)+i,s=this.normal.dotProduct(t)+i,n=a/(a-s),l=n>=0&&n<=1;return l&&r&&r.lerp(e,t,n),l}intersectsRay(e,t){t||=this._tmpVecA,t.copy(this.point).subtract(e.origin,t);var r=this.normal.dotProduct(t)/this.normal.dotProduct(e.direction),i=r>=0;return i&&t.copyFrom(e.direction).multiplyScalar(r).add(e.origin,t),i}}class Nr{static BACK=0;static FRONT=1;static IN=0;static OUT=1;static INTERSECT=2}class $c{a;b;c;d;static ALIGN_ANY=0;static ALIGN_XY_AXIS=1;static ALIGN_YZ_AXIS=2;static ALIGN_XZ_AXIS=3;constructor(e=0,t=0,r=0,i=0){this.a=e,this.b=t,this.c=r,this.d=i}setTo(e=0,t=0,r=0,i=0){this.a=e,this.b=t,this.c=r,this.d=i}fromPoints(e,t,r){var i=t.x-e.x,a=t.y-e.y,s=t.z-e.z,n=r.x-e.x,l=r.y-e.y,h=r.z-e.z;this.a=a*h-s*l,this.b=s*n-i*h,this.c=i*l-a*n,this.d=-(this.a*e.x+this.b*e.y+this.c*e.z)}fromNormalAndPoint(e,t){this.a=e.x,this.b=e.y,this.c=e.z,this.d=-(this.a*t.x+this.b*t.y+this.c*t.z)}normalize(){var e=Math.sqrt(this.a*this.a+this.b*this.b+this.c*this.c);if(e>0){var t=1/e;this.a*=t,this.b*=t,this.c*=t,this.d*=t}return e}distance(e){return this.a*e.x+this.b*e.y+this.c*e.z+this.d}classifyPoint(e,t=.01){var r=this.distance(e);return r<-t?Nr.BACK:r>t?Nr.FRONT:Nr.INTERSECT}toString(){return"Plane3D [a:"+this.a+", b:"+this.b+", c:"+this.c+", d:"+this.d+"]"}}function Ym(o,e){return Math.random()*e+Math.random()*o+(e-o)*Math.random()}function Xm(o,e,t){let r=t*Math.random();return Math.random()*e*r+Math.random()*o*r+(e-o)*Math.random()*r}function ef(o,e,t){let r=0,i=0;for(;r===0;)r=Math.random();for(;i===0;)i=Math.random();let a=Math.sqrt(-2*Math.log(r))*Math.cos(2*Math.PI*i);return a=a/10+.5,(a>1||a<0)&&(a=ef(o,e,t)),a=Math.pow(a,t),a*=e-o,a+=o,a}function Ot(o){return o>0?Math.floor(o):Math.floor(o)-1}let K=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];function oo(o,e){let t=o&15,r=1+(t&7);return t&8&&(r=-r),r*e}function Qa(o,e,t){let r=o&7,i=r<4?e:t,a=r<4?t:e;return(r&1?-i:i)+(r&2?-2*a:2*a)}function Gi(o,e,t,r){let i=o&15,a=i<8?e:t,s=i<4?t:i==12||i==14?e:r;return(i&1?-a:a)+(i&2?-s:s)}function ri(o,e,t,r,i){let a=o&31,s=a<24?e:t,n=a<16?t:r,l=a<8?r:i;return(a&1?-s:s)+(a&2?-n:n)+(a&4?-l:l)}let pt=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]];function jm(o){let e=Ot(o),t=e+1,r=o-e,i=r-1,a,s,n=1-r*r;n*=n,a=n*n*oo(K[e&255],r);let l=1-i*i;return l*=l,s=l*l*oo(K[t&255],i),.25*(a+s)}function Wm(o,e){const t=.366025403,r=.211324865;let i,a,s,n=(o+e)*t,l=o+n,h=e+n,u=Ot(l),f=Ot(h),g=(u+f)*r,p=u-g,A=f-g,v=o-p,C=e-A,x,S;v>C?(x=1,S=0):(x=0,S=1);let y=v-x+r,b=C-S+r,D=v-1+2*r,B=C-1+2*r,T=u&255,U=f&255,E=.5-v*v-C*C;E<0?i=0:(E*=E,i=E*E*Qa(K[T+K[U]],v,C));let N=.5-y*y-b*b;N<0?a=0:(N*=N,a=N*N*Qa(K[T+x+K[U+S]],y,b));let Q=.5-D*D-B*B;return Q<0?s=0:(Q*=Q,s=Q*Q*Qa(K[T+1+K[U+1]],D,B)),40*(i+a+s)}function qm(o,e,t){const r=.333333333,i=.166666667;let a,s,n,l,h=(o+e+t)*r,u=o+h,f=e+h,g=t+h,p=Ot(u),A=Ot(f),v=Ot(g),C=(p+A+v)*i,x=p-C,S=A-C,y=v-C,b=o-x,D=e-S,B=t-y,T,U,E,N,Q,H;b>=D?D>=B?(T=1,U=0,E=0,N=1,Q=1,H=0):b>=B?(T=1,U=0,E=0,N=1,Q=0,H=1):(T=0,U=0,E=1,N=1,Q=0,H=1):D<B?(T=0,U=0,E=1,N=0,Q=1,H=1):b<B?(T=0,U=1,E=0,N=0,Q=1,H=1):(T=0,U=1,E=0,N=1,Q=1,H=0);let q=b-T+i,re=D-U+i,pe=B-E+i,le=b-N+2*i,be=D-Q+2*i,Fe=B-H+2*i,se=b-1+3*i,Re=D-1+3*i,he=B-1+3*i,Ue=p&255,lt=A&255,ht=v&255,yt=.6-b*b-D*D-B*B;yt<0?a=0:(yt*=yt,a=yt*yt*Gi(K[Ue+K[lt+K[ht]]],b,D,B));let wt=.6-q*q-re*re-pe*pe;wt<0?s=0:(wt*=wt,s=wt*wt*Gi(K[Ue+T+K[lt+U+K[ht+E]]],q,re,pe));let It=.6-le*le-be*be-Fe*Fe;It<0?n=0:(It*=It,n=It*It*Gi(K[Ue+N+K[lt+Q+K[ht+H]]],le,be,Fe));let lr=.6-se*se-Re*Re-he*he;return lr<0?l=0:(lr*=lr,l=lr*lr*Gi(K[Ue+1+K[lt+1+K[ht+1]]],se,Re,he)),32*(a+s+n+l)}function Km(o,e,t,r){const i=.309016994,a=.138196601;let s,n,l,h,u,f=(o+e+t+r)*i,g=o+f,p=e+f,A=t+f,v=r+f,C=Ot(g),x=Ot(p),S=Ot(A),y=Ot(v),b=(C+x+S+y)*a,D=C-b,B=x-b,T=S-b,U=y-b,E=o-D,N=e-B,Q=t-T,H=r-U,q=E>N?32:0,re=E>Q?16:0,pe=N>Q?8:0,le=E>H?4:0,be=N>H?2:0,Fe=Q>H?1:0,se=q+re+pe+le+be+Fe,Re,he,Ue,lt,ht,yt,wt,It,lr,uo,co,fo;Re=pt[se][0]>=3?1:0,he=pt[se][1]>=3?1:0,Ue=pt[se][2]>=3?1:0,lt=pt[se][3]>=3?1:0,ht=pt[se][0]>=2?1:0,yt=pt[se][1]>=2?1:0,wt=pt[se][2]>=2?1:0,It=pt[se][3]>=2?1:0,lr=pt[se][0]>=1?1:0,uo=pt[se][1]>=1?1:0,co=pt[se][2]>=1?1:0,fo=pt[se][3]>=1?1:0;let go=E-Re+a,po=N-he+a,mo=Q-Ue+a,Ao=H-lt+a,vo=E-ht+2*a,_o=N-yt+2*a,xo=Q-wt+2*a,Co=H-It+2*a,So=E-lr+3*a,yo=N-uo+3*a,wo=Q-co+3*a,Io=H-fo+3*a,bo=E-1+4*a,Bo=N-1+4*a,Eo=Q-1+4*a,To=H-1+4*a,Hi=C&255,Yi=x&255,Xi=S&255,ji=y&255,Wi=.6-E*E-N*N-Q*Q-H*H;Wi<0?s=0:(Wi*=Wi,s=Wi*Wi*ri(K[Hi+K[Yi+K[Xi+K[ji]]]],E,N,Q,H));let qi=.6-go*go-po*po-mo*mo-Ao*Ao;qi<0?n=0:(qi*=qi,n=qi*qi*ri(K[Hi+Re+K[Yi+he+K[Xi+Ue+K[ji+lt]]]],go,po,mo,Ao));let Ki=.6-vo*vo-_o*_o-xo*xo-Co*Co;Ki<0?l=0:(Ki*=Ki,l=Ki*Ki*ri(K[Hi+ht+K[Yi+yt+K[Xi+wt+K[ji+It]]]],vo,_o,xo,Co));let Ji=.6-So*So-yo*yo-wo*wo-Io*Io;Ji<0?h=0:(Ji*=Ji,h=Ji*Ji*ri(K[Hi+lr+K[Yi+uo+K[Xi+co+K[ji+fo]]]],So,yo,wo,Io));let Zi=.6-bo*bo-Bo*Bo-Eo*Eo-To*To;return Zi<0?u=0:(Zi*=Zi,u=Zi*Zi*ri(K[Hi+1+K[Yi+1+K[Xi+1+K[ji+1]]]],bo,Bo,Eo,To)),27*(s+n+l+h+u)}class no extends V{static uv_0=new no;u=0;v=0;constructor(e=0,t=0){super(e,t),this.u=e,this.v=t}length(){return 0}static getUVSheet(e,t,r){let i=Math.floor(e%(t*r)),a=Math.floor(i/t),s=i%t;return new G(a/t,s/r,1/t,1/r)}}class tf{serializedVersion="2";time;tangentMode=0;weightedMode=0;propertyKeyFrame;constructor(e=0){this.time=e,this.propertyKeyFrame={}}getK(e){return this.propertyKeyFrame[e]}split(e,t,r){switch(e){case O.single:{let i=this.getKeyFrame(0);i[r]=t}break;case O.float:{let i=this.getKeyFrame(0);i[r]=t}break;case O.vector2:{let i=t,a=this.getKeyFrame(0);a[r]=i.x;let s=this.getKeyFrame(1);s[r]=i.y}break;case O.vector3:{let i=t,a=this.getKeyFrame(0);a[r]=i.x;let s=this.getKeyFrame(1);s[r]=i.y;let n=this.getKeyFrame(2);n[r]=i.z}break;case O.vector4:{let i=t,a=this.getKeyFrame(0);a[r]=i.x;let s=this.getKeyFrame(1);s[r]=i.y;let n=this.getKeyFrame(2);n[r]=i.y;let l=this.getKeyFrame(3);l[r]=i.y}break;case O.quaternion:{let i=t,a=this.getKeyFrame(0);a[r]=i.x;let s=this.getKeyFrame(1);s[r]=i.y;let n=this.getKeyFrame(2);n[r]=i.z;let l=this.getKeyFrame(3);l[r]=i.w}break}}getKeyFrame(e){let t=this.propertyKeyFrame[e];return t||(t=new ba,t.time=this.time,t.tangentMode=this.tangentMode,t.weightedMode=this.weightedMode,this.propertyKeyFrame[e]=t),t}formBytes(e){this.time=e.readFloat32();{let{t,v:r}=Ht.parser(e);this.split(t,r,"value")}{let{t,v:r}=Ht.parser(e);this.split(t,r,"inSlope")}{let{t,v:r}=Ht.parser(e);this.split(t,r,"outSlope")}this.tangentMode=e.readInt32(),this.weightedMode=e.readInt32();{let{t,v:r}=Ht.parser(e);this.split(t,r,"inWeight")}{let{t,v:r}=Ht.parser(e);this.split(t,r,"outWeight")}}}class Jm{static sub(e,t){switch(e.constructor.name){case"number":return e-t;case"Vector2":{let i=e,a=t;return new V(i.x-a.x,i.y-a.y)}case"Vector3":{let i=e,a=t;return new d(i.x-a.x,i.y-a.y,i.z-a.z)}case"Vector4":{let i=e,a=t;return new G(i.x-a.x,i.y-a.y,i.z-a.z,i.w-a.w)}case"Quaternion":{let i=e,a=t;return new Y(i.x-a.x,i.y-a.y,i.z-a.z,i.w-a.w)}}}}class Qi{_keys=new Array;_values=new Array;getIndexByKey(e){return this._keys.indexOf(e)}getValueByKey(e){var t=this.getIndexByKey(e);return t>-1?this._values[t]:null}put(e,t){if(e==null)return null;var r=this.remove(e);return this._keys.push(e),this._values.push(t),r}remove(e){var t=this._keys.indexOf(e),r;return t>-1&&(r=this._values[t],this._keys.splice(t,1),this._values.splice(t,1)),r}getValues(){return this._values}getKeys(){return this._keys}clear(){this._values.length=0,this._keys.length=0}}class Sr{static WalkAble=1}class Vi{static SetConst(e){this.EPSILON=e,this.POWER_EPSILON=e*e}static EPSILON=.1;static POWER_EPSILON=this.EPSILON*this.EPSILON}class Ze extends d{static CALC_VECTOR3D1=new d;static CALC_VECTOR3D2=new d;static CALC_VECTOR3D3=new d;static CALC_VECTOR3D4=new d;static CALC_VECTOR3D5=new d;_pointId=0;constructor(e,t,r,i){super(t,r,i,0),this._pointId=e}get id(){return this._pointId}static equalPoint(e,t){return(e.x-t.x)*(e.x-t.x)+(e.y-t.y)*(e.y-t.y)+(e.z-t.z)*(e.z-t.z)<Vi.POWER_EPSILON}static calcDistance(e,t){return Ze.CALC_VECTOR3D3.setTo(e.x-t.x,e.y-t.y,e.z-t.z),Ze.CALC_VECTOR3D3.length}}class rf{_openedList;_closedList;_endNode;_startNode;_triangleChannel;_navMesh;_findIndex=0;constructor(){this._openedList=new Array,this._closedList=new Array}findPath(e,t,r){return this._findIndex++,this._navMesh=e,this._startNode=t,this._endNode=r,this._openedList.length=0,this._closedList.length=0,this._startNode&&this._endNode?(this._startNode.gg=0,this._startNode.h=0,this._startNode.f=0,this._startNode.parent=null,this.search()):!1}search(){for(var e=this._startNode,t=[],r;e!=this._endNode;){t=e.getNeibourTriangles(t,Sr.WalkAble,Sr.WalkAble);for(r of t)if(r.closeId!=this._findIndex&&!(r==e||!r.walkAble)){var i=e.gg+Ze.calcDistance(r,e)*r.costMultiplier,a=Ze.calcDistance(r,this._endNode),s=i+a;r.openId==this._findIndex?r.f>s&&(r.f=s,r.gg=i,r.h=a,r.parent=e):(r.f=s,r.gg=i,r.h=a,r.parent=e,r.openId=this._findIndex,this._openedList.push(r))}if(e.closeId=this._findIndex,this._closedList.push(e),this._openedList.length==0)return!1;this._openedList.sort(function(n,l){return n.f-l.f}),e=this._openedList.shift()}return this.buildPath(),!0}buildPath(){this._triangleChannel=[];var e=this._endNode;for(this._triangleChannel.push(e);e!=this._startNode;)e=e.parent,this._triangleChannel.unshift(e)}get channel(){return this._triangleChannel}}class Ft extends Ze{_ownerPoint;_ownerEdge;radius=0;constructor(e,t){super(e.id,0,0,0),this._ownerEdge=t,this._ownerPoint=e}get ownerPoint(){return this._ownerPoint}get ownerEdge(){return this._ownerEdge}scalePoint(e=.7){var t=new Ft(this._ownerPoint,this._ownerEdge);return t.copyFrom(this),t.decrementBy(this._ownerPoint),t.scaleBy(e),t.radius=t.length,t.incrementBy(this._ownerPoint),t}}class Nt{_edgeMask=0;_edgeSize=0;_pointA;_pointB;_triangleOwners;_centerPoint;_edgeDirA2B;crossPoint;fatPointA;fatPointB;static CALC_FAT_VECTOR=new d;constructor(e,t){if(this._pointA=e,this._pointB=t,e.id>=t.id)throw new Error("edge point order error!!!");this._triangleOwners=new Array,this._centerPoint=new d,this._edgeMask=Sr.WalkAble,Ze.CALC_VECTOR3D1.setTo(e.x-t.x,e.y-t.y,e.z-t.z),this._edgeSize=Ze.CALC_VECTOR3D1.length,this._centerPoint.setTo((e.x+t.x)/2,(e.y+t.y)/2,(e.z+t.z)/2)}get size(){return this._edgeSize}get triangleOwners(){return this._triangleOwners}get centerPoint(){return this._centerPoint}initFatPoints(e){this._edgeDirA2B=this._pointB.subtract(this._pointA),this._edgeDirA2B.normalize(),this.fatPointA=this.fatPointA||new Ft(this._pointA,this),this.fatPointB=this.fatPointB||new Ft(this._pointB,this),this.fatPointA.radius!=e&&(Nt.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),Nt.CALC_FAT_VECTOR.scaleBy(e),Nt.CALC_FAT_VECTOR.incrementBy(this._pointA),this.fatPointA.copyFrom(Nt.CALC_FAT_VECTOR),this.fatPointA.radius=e),this.fatPointB.radius!=e&&(Nt.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),Nt.CALC_FAT_VECTOR.scaleBy(-e),Nt.CALC_FAT_VECTOR.incrementBy(this._pointB),this.fatPointB.copyFrom(Nt.CALC_FAT_VECTOR),this.fatPointB.radius=e)}getFatPoint(e){return e==this._pointA?this.fatPointA:this.fatPointB}getAnotherFatPoint(e){return e==this._pointA?this.fatPointB:this.fatPointA}getAnotherPoint(e){return e==this._pointA?this._pointB:this._pointA}containsPoint(e){return Ze.equalPoint(e,this._pointA)?this._pointA:Ze.equalPoint(e,this._pointB)?this._pointB:null}addTriangleOwners(e){if(e.edges.indexOf(this)==-1)throw new Error("the edge is not belong triangle!!!");this._triangleOwners.indexOf(e)==-1&&this._triangleOwners.push(e)}getPublicPoint(e){return this._pointA==e._pointA||this._pointA==e._pointB?this._pointA:this._pointB==e._pointA||this._pointB==e._pointB?this._pointB:null}getEqualPoint(e){return Ze.equalPoint(e,this._pointA)?this._pointA:Ze.equalPoint(e,this._pointB)?this._pointB:null}get pointA(){return this._pointA}get pointB(){return this._pointB}get walkAble(){return(this._edgeMask&Sr.WalkAble)==Sr.WalkAble}testMask(e){return(this._edgeMask&e)==e}}class X{endPoint;curPoint;rayA;rayB;rayAPoint;rayBPoint;static RAY_1=new d;static RAY_2=new d;static TEST_RAY=new d;static TEST_RAY_1=new d;static TEST_RAY_2=new d;static CALC_CROSS_POINT=new d;static CALC_CROSS_TEST=new d;cornerPoint;cornerEdge;continuePass(e,t,r){this.resetData(),this.curPoint=e,this.endPoint=t,this.cornerEdge=r}passEdge(e,t,r,i){if((this.rayA==null||this.rayB==null)&&(this.rayA=X.RAY_1,this.rayB=X.RAY_2,this.rayAPoint=e.pointA,this.rayBPoint=e.pointB,this.rayA.setTo(this.rayAPoint.x-this.curPoint.x,0,this.rayAPoint.z-this.curPoint.z),this.rayB.setTo(this.rayBPoint.x-this.curPoint.x,0,this.rayBPoint.z-this.curPoint.z)),i)return this.checkEndPoint(r);if(X.TEST_RAY.setTo(r.x-this.curPoint.x,0,r.z-this.curPoint.z),this.isPointAtCenter(X.TEST_RAY,this.rayA,this.rayB)){this.hasCrossPoint(t.pointA,t.pointB,this.rayAPoint,this.rayA)?(this.rayB.copyFrom(X.TEST_RAY),r instanceof Ze?this.rayBPoint=r:this.rayBPoint=null):(this.rayA.copyFrom(X.TEST_RAY),r instanceof Ze?this.rayAPoint=r:this.rayAPoint=null);var a=t.getAnotherPoint(r);X.TEST_RAY.setTo(a.x-this.curPoint.x,0,a.z-this.curPoint.z),(a==this.rayAPoint||a==this.rayBPoint||this.isPointAtCenter(X.TEST_RAY,this.rayA,this.rayB))&&(this.cornerEdge=t)}else{var s;if(X.TEST_RAY_1.copyFrom(t.pointA),X.TEST_RAY_1.decrementBy(this.curPoint),X.TEST_RAY_2.copyFrom(t.pointB),X.TEST_RAY_2.decrementBy(this.curPoint),X.TEST_RAY_1.y=0,X.TEST_RAY_2.y=0,this.isPointAtCenter(this.rayA,X.TEST_RAY_1,X.TEST_RAY_2)||this.isPointAtCenter(this.rayB,X.TEST_RAY_1,X.TEST_RAY_2)?s=!1:s=!0,s)return this.isPointAtCenter(this.rayA,X.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1}return!0}checkEndPoint(e){return X.TEST_RAY.setTo(e.x-this.curPoint.x,0,e.z-this.curPoint.z),this.isPointAtCenter(X.TEST_RAY,this.rayA,this.rayB)?!0:(this.isPointAtCenter(this.rayA,X.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1)}calcCrossEdge(e,t,r){return this.calcCrossPoint(e.fatPointA,e.fatPointB,t,r)}calcCrossPoint(e,t,r,i){X.CALC_CROSS_POINT.copyFrom(t),X.CALC_CROSS_POINT.decrementBy(e);let a=X.CALC_CROSS_POINT.x*i.z-i.x*X.CALC_CROSS_POINT.z;var s=0;return a!=0&&(s=((e.z-r.z)*i.x-(e.x-r.x)*i.z)/a),s>1?s=1:s<0&&(s=0),X.CALC_CROSS_POINT.scaleBy(s),X.CALC_CROSS_POINT.incrementBy(e),X.CALC_CROSS_POINT.clone()}calcCrossPointOut(e,t,r,i){X.CALC_CROSS_POINT.copyFrom(t),X.CALC_CROSS_POINT.decrementBy(e);var a=((e.z-r.z)*i.x-(e.x-r.x)*i.z)/(X.CALC_CROSS_POINT.x*i.z-i.x*X.CALC_CROSS_POINT.z);return a<=1&&a>=0?null:(X.CALC_CROSS_POINT.scaleBy(a),X.CALC_CROSS_POINT.incrementBy(e),X.CALC_CROSS_POINT.clone())}hasCrossPoint(e,t,r,i){X.CALC_CROSS_TEST.copyFrom(t),X.CALC_CROSS_TEST.decrementBy(e);var a=((e.z-r.z)*i.x-(e.x-r.x)*i.z)/(X.CALC_CROSS_TEST.x*i.z-i.x*X.CALC_CROSS_TEST.z);return a<=1&&a>=0}isPointAtCenter(e,t,r){var i=t.crossProduct(e);if(i.length==0&&e.length<t.length)return!0;var a=r.crossProduct(e);return a.length==0&&e.length<r.length?!0:(i.normalize(),a.normalize(),i.incrementBy(a),i.length<.01)}resetData(){this.cornerEdge=null,this.cornerPoint=null,this.curPoint=null,this.rayA=this.rayB=null,this.rayAPoint=this.rayBPoint=null,X.RAY_1.setTo(0,0,0),X.RAY_2.setTo(0,0,0)}}class nr{_aiRadius=0;_router;_result;_tempPublicEdgeList=new Array;_tempSamePlaneList=new Array;static CROSS_TEST_DIRECTION=new d;constructor(){this._router=new X}searchPath(e,t,r,i=0){return i<=0&&(i=1),this._aiRadius=i*1.5,this.searchEnable(e,t,r)?(this.search(e,t,r),!0):!1}get path(){return this._result}searchEnable(e,t,r){return!(e==null||t==null||r==null||r[0].plane.classifyPoint(e,Vi.EPSILON)!=Nr.INTERSECT||r[r.length-1].plane.classifyPoint(t,Vi.EPSILON)!=Nr.INTERSECT)}search(e,t,r){this._tempPublicEdgeList.length=0,this._tempSamePlaneList.length=0;var i=0,a=r.length-1,s,n,l,h;for(i=0;i<a;i++)n=r[i].getPublicEdge(r[i+1]),n.crossPoint=null,n.initFatPoints(this._aiRadius),this._tempPublicEdgeList.push(n),s=r[i],h=s.plane,s=r[i+1],l=s.getEdgeAgainstPoint(n),this._tempSamePlaneList.push(h.classifyPoint(l,Vi.EPSILON)==Nr.INTERSECT);this._router.continuePass(e,t,this._tempPublicEdgeList[0]),a=this._tempPublicEdgeList.length;var u,f,g,p;for(i=0;i<a;i++)n=this._tempPublicEdgeList[i],s=r[i+1],p=i==a-1,p?l=t:l=s.getEdgeAgainstPoint(n),g=this._router.passEdge(n,this._tempPublicEdgeList[i+1],l,p),g||(u=this._router.cornerPoint,f=this._router.cornerEdge,i=this._tempPublicEdgeList.indexOf(f),this._router.continuePass(u,t,this._tempPublicEdgeList[i+1]));this.pushAllPathPoint2(e,t),this._result.length>=3&&(this.optimusTerminusFat(),this.optimusByRadius());let A=[];for(let v of this._result)A.push(new d().copyFrom(v));this._result=A}optimusTerminusFat(){var e,t,r;r=this._result[1],r instanceof Ft&&(e=r),r=this._result[this._result.length-2],r instanceof Ft&&(t=r),e&&(this._result[1]=e.scalePoint()),t&&e!=t&&(this._result[this._result.length-2]=t.scalePoint())}pushAllPathPoint2(e,t){var r=this._tempPublicEdgeList.length,i,a;this._result=new Array,this._result.push(e);for(var s=e,n,l,h,u=0;u<r;u++)if(i=this._tempPublicEdgeList[u],l=null,i.crossPoint)l=this.getFatPoint(i,i.crossPoint),l?this._result.push(l):this._result.push(i.crossPoint),s=i.crossPoint;else{a=null,n=null;for(var f=u+1;f<r&&(a=this._tempPublicEdgeList[f],n=a.crossPoint,!n);f++);n==null&&(n=t),l=this.getFatPoint(i,n),l?this._result.push(l):(n==s?h=n.clone():(nr.CROSS_TEST_DIRECTION.setTo(n.x-s.x,0,n.z-s.z),h=this._router.calcCrossEdge(i,s,nr.CROSS_TEST_DIRECTION)),this._result.push(h))}this._result.push(t)}optimusByRadius(){var e=new Array;e.length=this._result.length;var t=this._result.length-2,r,i,a,s,n,l,h,u,f,g,p,A,v;for(v=0;v<t;v++)h=u=f=null,s=n=l=null,p=!1,A=null,r=this._result[v],i=this._result[v+1],a=this._result[v+2],r instanceof Ft&&(s=r),i instanceof Ft&&(n=i),a instanceof Ft&&(l=a),s&&(h=s.ownerPoint),n&&(u=n.ownerPoint),l&&(f=l.ownerPoint),h&&u&&h==u&&u!=f&&(p=!0),f&&u&&f==u&&h!=u&&(p=!0),p&&(nr.CROSS_TEST_DIRECTION.copyFrom(r),nr.CROSS_TEST_DIRECTION.decrementBy(a),g=n.ownerEdge,p=this._router.hasCrossPoint(g.pointA,g.pointB,a,nr.CROSS_TEST_DIRECTION),p&&(A=this._router.calcCrossPointOut(u,i,a,nr.CROSS_TEST_DIRECTION)),A&&(e[v+1]=A))}getFatPoint(e,t){if(e==null)return null;var r;t instanceof Ft&&(r=t);var i;return r?i=r.ownerPoint:i=e.getEqualPoint(t),i==null?null:(r=e.getFatPoint(i),r)}}class Zm{vertex;indices;merge(e,t=.1){let r=e.getAttribute(M.position).data;this.makeOriginVertex(r);let i=new Map,a=[],s=0;for(let l=0,h=this.vertex.length;l<h;l++){let u=this.vertex[l],f=-1;i.forEach((g,p)=>{d.distance(g,u)<t&&(f=p)}),f>-1?(a[l]=f,s++):(i.set(l,u),a[l]=l)}console.log("mergePointCount\uFF1A",s),this.indices=[];let n=e.getAttribute(M.indices).data;for(const l of n)this.indices.push(a[l]);return this}parse(e){let t=e.getAttribute(M.position).data;this.makeOriginVertex(t),this.indices=[];let r=e.getAttribute(M.indices).data;for(const i of r)this.indices.push(i);return this}makeOriginVertex(e){this.vertex=[];for(let t=0,r=e.length/3;t<r;t++){let i=new d(e[t*3],e[t*3+1],e[t*3+2]);this.vertex.push(i)}}}class af extends d{_id=0;_plane;_points=new Array;_edges=new Array;_neibourTriangles=new Qi;_pointAgainstEdge=new Qi;_edgeAgainstPoint=new Qi;_mask=0;_aabbBox;f=0;gg=0;h=0;parent;costMultiplier=1;openId=0;closeId=0;get aabb(){return this._aabbBox}initAABB(){this._aabbBox=new Je,this._aabbBox.addPoint(this._points[0]),this._aabbBox.addPoint(this._points[1]),this._aabbBox.addPoint(this._points[2])}calcGlobalQuadAABB(){}get isTriangle(){return!0}constructor(e,t,r,i){super(0,0,0,0),this._id=e,this._mask=Sr.WalkAble,this._edges.push(t,r,i);var a;for(a of this._edges)this._points.indexOf(a.pointA)==-1&&this._points.push(a.pointA),this._points.indexOf(a.pointB)==-1&&this._points.push(a.pointB);this.x=(this._points[0].x+this._points[1].x+this._points[2].x)/3,this.y=(this._points[0].y+this._points[1].y+this._points[2].y)/3,this.z=(this._points[0].z+this._points[1].z+this._points[2].z)/3,this._plane=new $c,this._plane.fromPoints(this._points[0],this._points[1],this._points[2]),this._plane.normalize(),this.genarateAgainstData(),this.initAABB()}genarateAgainstData(){var e,t;for(e of this._edges)for(t of this._points)e.pointA!=t&&e.pointB!=t&&(this._edgeAgainstPoint.put(e,t),this._pointAgainstEdge.put(t,e))}get id(){return this._id}get plane(){return this._plane}get points(){return this._points}addNeibour(e,t){if(this._edges.indexOf(e)>=0)this._neibourTriangles.put(e,t);else throw new Error("the edge is not in triangle!!!")}getNeibourTriangles(e=null,t=1,r=1){e=e||new Array,e.length=0;var i,a,s=this._neibourTriangles.getKeys(),n;for(n of s)a=n,a.testMask(t)&&(i=this._neibourTriangles.getValueByKey(a),i.testMask(r)&&e.push(i));return e}getEdges(e=null,t=1){e=e||new Array,e.length=0;var r;for(r of this._edges)r.testMask(t)&&e.push(r);return e}get walkAble(){return this.testMask(Sr.WalkAble)}get edges(){return this._edges}testMask(e){return(this._mask&e)==e}getEdgeAgainstPoint(e){return this._edgeAgainstPoint.getValueByKey(e)}getPointAgainstEdge(e){return this._pointAgainstEdge.getValueByKey(e)}getPublicEdge(e){if(e&&e!=this){var t=this._neibourTriangles.getKeys(),r;for(r of t)if(this._neibourTriangles.getValueByKey(r)==e)return r}return null}loopPublicEdge(e){var t,r;if(e&&e!=this){for(t of this._edges)for(r of e._edges)if(t==r)return t}return null}randomPoint(){var e=this._points[2].subtract(this._points[0]);e.scaleBy(Math.random()),e.incrementBy(this._points[0]);var t=this._points[1].subtract(e);return t.scaleBy(Math.random()),t.incrementBy(e),t}}class $m{_nav3dPoints;_nav3dEdges;_nav3dTriangles;_path;_edgesDict;_nav3dAstar;_nav3dFunnel;_terrainQuad;_triangleList;get edges(){return this._nav3dEdges}get points(){return this._nav3dPoints}get path(){return this._path}get triangles(){return this._nav3dTriangles}constructor(e,t){this._nav3dPoints=new Array,this._nav3dEdges=new Array,this._nav3dTriangles=new Array,this._edgesDict=new Qi,this.initPoints(e),this.initEdgesAndTriangles(t),this.createConnections(),this._nav3dAstar=new rf,this._nav3dFunnel=new nr,this._terrainQuad=new mc(8,128),this._terrainQuad.createQuadTree(this._nav3dTriangles)}getTriangleAtPoint(e,t=5){return this._terrainQuad.getTriangleAtPoint(e,t)}findPath(e,t,r=5){this._path=null,this._triangleList=null;var i=this.getTriangleAtPoint(e,10),a=this.getTriangleAtPoint(t,10),s=this._nav3dAstar.findPath(this,i,a);return s?(this._triangleList=this._nav3dAstar.channel,s=this._nav3dFunnel.searchPath(e,t,this._triangleList,r),this._path=this._nav3dFunnel.path,s):!1}initPoints(e){for(var t,r,i=e.length,a=0;a<i;a++)t=e[a],r=new Ze(a,t.x,t.y,t.z),this._nav3dPoints.push(r)}initEdgesAndTriangles(e){for(var t,r,i,a,s,n=e.length,l=0;l<n;l++)t=e[l],r=this.tryCreateEdge(t[0],t[1]),i=this.tryCreateEdge(t[1],t[2]),a=this.tryCreateEdge(t[2],t[0]),!(r==null||i==null||a==null)&&(s=new af(l,r,i,a),this._nav3dTriangles.push(s))}tryCreateEdge(e,t){if(e==t)throw new Error("edge point index error!!!");if(e>t){var r=e;e=t,t=r}var i=this._edgesDict.getValueByKey(e+"_"+t);return i==null&&(i=new Nt(this._nav3dPoints[e],this._nav3dPoints[t]),this._nav3dEdges.push(i),this._edgesDict.put(e+"_"+t,i)),i}createConnections(){for(var e=this._nav3dTriangles.length,t=this._nav3dTriangles.length,r,i,a,s,n=0;n<e;n++){r=this._nav3dTriangles[n];for(a of r.edges)a.addTriangleOwners(r);for(var l=0;l<t;l++)i=this._nav3dTriangles[l],r!=i&&(s=r.loopPublicEdge(i),s&&(r.addNeibour(s,i),i.addNeibour(s,r)))}}}class lo{x;y;setTo(e,t){this.x=e,this.y=t}equals(e,t){return e==this.x&&t==this.y}equalPoint(e){return this.equals(e.x,e.y)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}clone(){var e=new lo;return e.setTo(this.x,this.y),e}normalize(){var e=length;e!=0&&this.setTo(this.x/e,this.y/e)}}class zr extends ve{width;height;depth;constructor(e=1,t=1,r=1){super(),this.width=e,this.height=t,this.depth=r,this.initVertex()}initVertex(){let e=this.width/2,t=this.height/2,r=this.depth/2;this.bounds=new de(d.ZERO.clone(),new d(this.width,this.height,this.depth));let i=new Float32Array([-e,t,r,e,t,r,e,t,-r,-e,t,-r,-e,t,r,e,t,-r,e,-t,r,-e,-t,r,-e,-t,-r,e,-t,-r,e,-t,r,-e,-t,-r,-e,-t,r,-e,t,r,-e,t,-r,-e,-t,-r,-e,-t,r,-e,t,-r,e,t,r,e,-t,r,e,-t,-r,e,t,-r,e,t,r,e,-t,-r,e,t,r,-e,t,r,-e,-t,r,-e,-t,r,e,-t,r,e,t,r,e,-t,-r,-e,-t,-r,-e,t,-r,e,t,-r,e,-t,-r,-e,t,-r]),a=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),s=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),n=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],l=new Uint16Array(n.reverse());this.setIndices(l),this.setAttribute(M.position,i),this.setAttribute(M.normal,a),this.setAttribute(M.uv,s),this.setAttribute(M.TEXCOORD_1,s),this.addSubGeometry({indexStart:0,indexCount:n.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class eA extends ve{radiusTop;radiusBottom;height;radialSegments;heightSegments;openEnded;thetaStart;thetaLength;constructor(e=1,t=1,r=1,i=8,a=8,s=!1,n=0,l=Math.PI*2){super(),this.radiusTop=e,this.radiusBottom=t,this.height=r,this.radialSegments=i,this.heightSegments=a,this.openEnded=s,this.thetaStart=n,this.thetaLength=l,this.instanceID=dt(),this.buildGeometry()}addGroup(e,t,r){this.addSubGeometry({indexStart:e,indexCount:t,vertexStart:e,vertexCount:0,firstStart:0,index:r,topology:0})}buildGeometry(){const e=this;this.radialSegments=Math.floor(this.radialSegments),this.heightSegments=Math.floor(this.heightSegments);const t=[],r=[],i=[],a=[];let s=0;const n=[],l=this.height/2;let h=0;A(),this.openEnded===!1&&(this.radiusTop>0&&v(!0),this.radiusBottom>0&&v(!1));let u=new Float32Array(t),f=new Float32Array(r),g=new Float32Array(i),p=new Uint16Array(a);this.setAttribute(M.position,u),this.setAttribute(M.normal,f),this.setAttribute(M.uv,g),this.setAttribute(M.TEXCOORD_1,g),this.setIndices(p);function A(){const C=new d,x=new d;let S=0;const y=(e.radiusBottom-e.radiusTop)/e.height;for(let b=0;b<=e.heightSegments;b++){const D=[],B=b/e.heightSegments,T=B*(e.radiusBottom-e.radiusTop)+e.radiusTop;for(let U=0;U<=e.radialSegments;U++){const E=U/e.radialSegments,N=E*e.thetaLength+e.thetaStart,Q=Math.sin(N),H=Math.cos(N);x.x=T*Q,x.y=-B*e.height+l,x.z=T*H,t.push(x.x,x.y,x.z),C.set(Q,y,H).normalize(),r.push(C.x,C.y,C.z),i.push(E,1-B),D.push(s++)}n.push(D)}for(let b=0;b<e.radialSegments;b++)for(let D=0;D<e.heightSegments;D++){const B=n[D][b],T=n[D+1][b],U=n[D+1][b+1],E=n[D][b+1];a.push(B,T,E),a.push(T,U,E),S+=6}e.addGroup(h,S,0),h+=S}function v(C){const x=s,S=new V,y=new d;let b=0;const D=C===!0?e.radiusTop:e.radiusBottom,B=C===!0?1:-1;for(let U=1;U<=e.radialSegments;U++)t.push(0,l*B,0),r.push(0,B,0),i.push(.5,.5),s++;const T=s;for(let U=0;U<=e.radialSegments;U++){const N=U/e.radialSegments*e.thetaLength+e.thetaStart,Q=Math.cos(N),H=Math.sin(N);y.x=D*H,y.y=l*B,y.z=D*Q,t.push(y.x,y.y,y.z),r.push(0,B,0),S.x=Q*.5+.5,S.y=H*.5*B+.5,i.push(S.x,S.y),s++}for(let U=0;U<e.radialSegments;U++){const E=x+U,N=T+U;C===!0?a.push(N,N+1,E):a.push(N+1,N,E),b+=3}e.addGroup(h,b,C===!0?1:2),h+=b}}}class tA extends ve{segments;constructor(e){super(),this.segments=e,this.buildGeometry()}buildGeometry(){this.bounds=new de;let e=(this.segments.length-1)*2*3,t=this.segments.length*2,r=new Float32Array(t*3),i=new Float32Array(t*3),a=new Float32Array(t*2),s=new Uint16Array(e),n=0;for(let h of this.segments)r[n++]=h[0].x,r[n++]=h[0].y,r[n++]=h[0].z,r[n++]=h[1].x,r[n++]=h[1].y,r[n++]=h[1].z;n=0;let l=0;for(;n<e;)s[n++]=2+l,s[n++]=1+l,s[n++]=0+l,s[n++]=1+l,s[n++]=2+l,s[n++]=3+l,l+=2;this.setIndices(s),this.setAttribute(M.position,r),this.setAttribute(M.normal,i),this.setAttribute(M.uv,a),this.setAttribute(M.TEXCOORD_1,a),this.addSubGeometry({indexStart:0,indexCount:s.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.computeNormals()}}class rA extends ve{radius;tube;radialSegments;tubularSegments;constructor(e=.4,t=.1,r=32,i=32){super(),this.radius=e,this.tube=t,this.radialSegments=r,this.tubularSegments=i,this.initVertex()}initVertex(){const e=2*Math.PI,t=this.radius,r=this.tube,i=this.radialSegments,a=this.tubularSegments;this.bounds=new de(d.ZERO.clone(),new d(t*2,r*2,t*2));var s=(i+1)*(a+1);let n=new Float32Array(s*3),l=new Float32Array(s*3),h=new Float32Array(s*2),u=new Uint16Array(i*a*2*3),f=0,g=0,p=0,A=0;for(let v=0;v<=i;v++)for(let C=0;C<=a;C++){const x=C/a,S=v/i,y=x*e,b=S*Math.PI*2;if(n[f++]=(t+r*Math.cos(b))*Math.sin(y),n[f++]=r*Math.sin(b),n[f++]=(t+r*Math.cos(b))*Math.cos(y),l[g++]=Math.sin(y)*Math.cos(b),l[g++]=Math.sin(b),l[g++]=Math.cos(y)*Math.cos(b),h[p++]=x,h[p++]=S,C<a&&v<i){const D=a+1,B=D*v+C,T=D*(v+1)+C,U=D*(v+1)+C+1,E=D*v+C+1;u[A++]=B,u[A++]=E,u[A++]=T,u[A++]=E,u[A++]=U,u[A++]=T}}this.setIndices(u),this.setAttribute(M.position,n),this.setAttribute(M.normal,l),this.setAttribute(M.uv,h),this.setAttribute(M.TEXCOORD_1,h),this.addSubGeometry({indexStart:0,indexCount:u.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class iA extends De{width=4;height=4;depthOrArrayLayers=6;visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE;constructor(e,t){super(e,t,6),this.format=z.depth24plus,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.textureBindingLayout.viewDimension="cube"}internalCreateTexture(){this.textureDescriptor={format:"depth24plus",size:{width:this.width,height:this.height,depthOrArrayLayers:6},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=I.device.createSampler({}),this.gpuSampler_comparison=I.device.createSampler({compare:"less",label:"sampler_comparison"})}}class sf extends De{uint16Array;floatArray;_dataBuffer;create(e,t,r=null,i=!0){if(r==null){r=[];for(let a=0,s=e*t*4;a<s;a++)r[a]=0}return this.updateTexture(e,t,r,i),this}updateTexture(e,t,r,i=!0){(e!=this.width||t!=this.height)&&(this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null,this.gpuTexture&&this.gpuTexture.destroy(),this.gpuTexture=null),this.floatArray=r;let a=I.device;const s=e*4*2;this.format=z.rgba16float,this.mipmapCount=Math.floor(i?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format),(!this.uint16Array||this.uint16Array.length!=r.length)&&(this.uint16Array=new Uint16Array(r.length));let n=this.uint16Array;for(let u=0,f=n.length;u<f;u++)n[u]=jr(r[u]);const l=this._dataBuffer=a.createBuffer({size:n.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,n);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),w.endCommandEncoder(h),this.gpuSampler=a.createSampler(this),this.gpuTexture=this.getGPUTexture(),this.mipmapCount>1&&$e.webGPUGenerateMipmap(this)}}class aA extends De{create(e,t,r,i=!0){let a=I.device;const s=e*4*4;this.format=z.rgba32float,this.createTextureDescriptor(e,t,1,this.format);const l=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=w.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(h),i&&(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float"),this.gpuSampler=a.createSampler({})}fromBuffer(e,t,r){let i=I.device;const a=e*4*4;this.format=z.rgba32float,this.mipmapCount=1,this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const s=w.beginCommandEncoder();return s.copyBufferToTexture({buffer:r,bytesPerRow:a},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(s),this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=i.createSampler({}),this}}class sA extends ya{_internalTexture;_minSize=32;_skyColor;constructor(e){super(),this._skyColor=e,this._internalTexture=new sf;let t=[];return m.res.fillColor(t,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.create(this._minSize,this._minSize,t,!1),this.createFromTexture(this._minSize,this._internalTexture),this}changeColor(e){return this._skyColor=e,m.res.fillColor(this._internalTexture.floatArray,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.updateTexture(this._minSize,this._minSize,this._internalTexture.floatArray,!1),this._faceData.uploadTexture(0,this._internalTexture),this}get color(){return this._skyColor}set color(e){this.changeColor(e)}}class oA extends De{create(e,t,r,i=!0){let a=I.device;const s=e*4*4;this.format=z.rgba16float,this.mipmapCount=Math.floor(i?Math.log2(e):1),this.createTextureDescriptor(e,t,this.mipmapCount,this.format);const n=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(n,0,r);const l=w.beginCommandEncoder();l.copyBufferToTexture({buffer:n,bytesPerRow:s},{texture:this.getGPUTexture()},{width:e,height:t,depthOrArrayLayers:1}),w.endCommandEncoder(l),this.minFilter="nearest",this.magFilter="nearest",this.mipmapFilter="nearest",this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&$e.webGPUGenerateMipmap(this)}}class nA extends c.Object3D{length=100;thickness=.1;constructor(e,t=.1){super(),this.length=e,this.thickness=t,this.init()}init(){let e=new c.Object3D,t=new c.Object3D,r=new c.Object3D,i=new zr(2,2,2),a=new zr(2,2,2),s=new zr(2,2,2),n=new Na;n.baseColor=new P(1,0,0);let l=new Na;l.baseColor=new P(0,1,0);let h=new Na;h.baseColor=new P(0,0,1);let u=e.addComponent(c.MeshRenderer),f=t.addComponent(c.MeshRenderer),g=r.addComponent(c.MeshRenderer);u.geometry=i,u.material=n,u.castShadow=!1,f.geometry=a,f.material=l,f.castShadow=!1,g.geometry=s,g.material=h,g.castShadow=!1,e.localScale=new d(this.length,this.thickness,this.thickness),e.x=this.length,t.localScale=new d(this.thickness,this.length,this.thickness),t.y=this.length,r.localScale=new d(this.thickness,this.thickness,this.length),r.z=this.length,this.addChild(e),this.addChild(t),this.addChild(r)}}class lA{static color_temperature_to_rgb(e){e<1e3?e=1e3:e>4e4&&(e=4e4);let t=e/100,r=this.get_red(t),i=this.get_green(t),a=this.get_blue(t);return new P(r/255,i/255,a/255,1)}static get_red(e){if(e<=66)return 255;let t=329.698727446*Math.pow(e-60,-.1332047592);return this.bound(t)}static get_green(e){let t=0;return e<=66?t=99.4708025861*Math.log(e)-161.1195681661:t=288.1221695283*Math.pow(e-60,-.0755148492),this.bound(t)}static get_blue(e){let t=0;return e>=66?255:e<=19?0:(t=138.5177312231*Math.log(e-10)-305.0447927307,this.bound(t))}static bound(e,t=0,r=255){let i=Math.max(e,t);return Math.min(i,r)}}class hA{static boxGeo;static sphere;static material;static initHeap(){this.boxGeo||(this.boxGeo=new zr),this.sphere||(this.sphere=new Si(1,35,35)),this.material||(this.material=new rr)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let e=new c.Object3D,t=e.addComponent(c.MeshRenderer);return t.geometry=this.boxGeo,t.material=this.material.clone(),t.castShadow=!0,e}static GetSingleCube(e,t,r,i,a,s){this.initHeap();let n=new rr;n.roughness=.5,n.metallic=.1,n.baseColor=new P(i,a,s,1);let l=new c.Object3D,h=l.addComponent(c.MeshRenderer);return h.castGI=!0,h.geometry=new zr(e,t,r),h.material=n,l}static GetSingleSphere(e,t,r,i){this.initHeap();let a=new rr;a.baseColor=new P(t,r,i,1);let s=new c.Object3D,n=s.addComponent(c.MeshRenderer);return n.castGI=!0,n.geometry=new Si(e,20,20),n.material=a,s}static get Sphere(){this.initHeap();let e=new c.Object3D,t=e.addComponent(c.MeshRenderer);return t.geometry=this.sphere,t.material=this.material,e}static GetSingleCube2(e,t=10){this.initHeap();let r=new c.Object3D,i=r.addComponent(c.MeshRenderer);return i.castShadow=!1,i.geometry=new zr(t,t,t),i.material=e,r}}class ho{static localData;static load(e){let t=localStorage.getItem(e);return t?this.localData=JSON.parse(t):(this.localData={},ho.save(e,this.localData)),this.localData}static save(e,t){let r=JSON.stringify(t);localStorage.setItem(e,r)}}class uA extends Number{}class cA extends Number{}class fA extends Number{}class dA extends Bt{x=0;y=0;z=0;w=0}c.AccelerateDecelerateInterpolator=ih,c.AccelerateInterpolator=th,c.AnimationCurve=wi,c.AnimationCurveT=zi,c.AnimationMonitor=Rr,c.AnimatorEventKeyframe=Dg,c.AnticipateInterpolator=oh,c.AnticipateOvershootInterpolator=Ai,c.ArrayHas=pf,c.ArrayItemIndex=mf,c.AtlasParser=Zh,c.AtmosphericComponent=wg,c.AtmosphericScatteringSky=Lu,c.AtmosphericScatteringSkySetting=Uu,c.AtmosphericScatteringSky_shader=Ru,c.AttributeAnimCurve=Nu,c.AxisObject=nA,c.B3DMLoader=ir,c.B3DMLoaderBase=Oh,c.B3DMParseUtil=Ns,c.B3DMParser=Fh,c.BLUR_CsShader=sg,c.BRDFLUT=Hh,c.BRDFLUTGenerate=Yh,c.BRDF_frag=nn,c.BatchTable=Ls,c.Bezier2D=za,c.Bezier3D=Rm,c.BiMap=Um,c.BillboardComponent=yi,c.BillboardType=vr,c.BitmapTexture2D=tr,c.BitmapTexture2DArray=Zn,c.BitmapTextureCube=Ts,c.Blend=Kn,c.BlendFactor=Jn,c.BlendMode=ee,c.BlendShapeData=zc,c.BlendShapeFrameData=Sm,c.BlendShapePropertyData=Nc,c.BloomPost=Fp,c.BlurEffectCreatorBlur_cs=bh,c.BlurEffectCreatorSample_cs=Ih,c.BlurTexture2DBufferCreator=Bh,c.BounceInterpolator=gt,c.BoundUtil=na,c.BoundingBox=de,c.BoundingSphere=Pa,c.BoxColliderShape=Fu,c.BoxGeometry=zr,c.BrdfLut_frag=Ko,c.BsDF_frag=Sn,c.BxDF_frag=ln,c.BxdfDebug_frag=fn,c.BytesArray=Oa,c.CEvent=Ne,c.CEventDispatcher=Xt,c.CEventListener=ea,c.CResizeEvent=yr,c.CSM=At,c.Camera3D=Vr,c.CameraControllerBase=Gg,c.CameraType=me,c.CameraUtil=Te,c.CapsuleColliderShape=ip,c.CastPointShadowMaterialPass=fl,c.CastShadowMaterialPass=cl,c.Clearcoat_frag=hn,c.ClusterBoundsSource_cs=Ul,c.ClusterConfig=qe,c.ClusterDebug_frag=zo,c.ClusterLight=xn,c.ClusterLightingBuffer=Rl,c.ClusterLightingRender=Ol,c.ClusterLighting_cs=Ll,c.CollectInfo=pl,c.ColliderComponent=Ig,c.ColliderShape=Me,c.ColliderShapeType=Jr,c.Color=P,c.ColorLitMaterial=Em,c.ColorLitShader=wu,c.ColorPassFragmentOutput=qa,c.ColorPassRenderer=Ml,c.ColorUtil=Ka,c.ComData=Fa,c.Common_frag=Wo,c.Common_vert=qo,c.ComponentBase=_e,c.ComponentCollect=oe,c.ComputeGPUBuffer=Xr,c.ComputeShader=ie,c.CubeCamera=Xl,c.CubeMapFaceEnum=Eh,c.CubeSky_Shader=ja,c.CubicBezierCurve=ka,c.CubicBezierPath=Lm,c.CubicBezierType=Yc,c.CycleInterpolator=nh,c.CylinderGeometry=eA,c.DDGIIrradianceComputePass=ql,c.DDGIIrradianceGPUBufferReader=Li,c.DDGIIrradianceVolume=vl,c.DDGIIrradiance_shader=Wl,c.DDGILightingPass=$l,c.DDGILighting_shader=Zl,c.DDGIMultiBouncePass=Jl,c.DDGIProbeRenderer=eh,c.DEGREES_TO_RADIANS=ge,c.DecelerateInterpolator=rh,c.Depth2DTextureArray=kl,c.DepthCubeArrayTexture=Nl,c.DepthCubeTexture=iA,c.DepthMaterialPass=dl,c.DepthOfFieldPost=Np,c.DepthOfView_cs=au,c.DoubleArray=Qi,c.DrawInfo=Pp,c.DynamicDrawStruct=Sp,c.DynamicFaceRenderer=yp,c.EditorInspector=Gt,c.Engine3D=m,c.Entity=Xn,c.EntityBatchCollect=ml,c.EntityCollect=k,c.EnvMap_frag=Jo,c.ErpImage2CubeMap=nt,c.ErpImage2CubeMapCreateCube_cs=Th,c.ErpImage2CubeMapRgbe2rgba_cs=Dh,c.ExtrudeGeometry=lp,c.FASTFLOOR=Ot,c.FXAAPost=Pr,c.FXAAShader=Pu,c.FaceMode=Ec,c.FastMathShader=$o,c.FeatureTable=Sa,c.FileLoader=rt,c.FirstPersonCameraController=Qg,c.Float16ArrayTexture=sf,c.Float32ArrayTexture=aA,c.Float32ArrayUtil=wp,c.FlyCameraController=Vg,c.FontChar=qh,c.FontInfo=jh,c.FontPage=Wh,c.FontParser=ar,c.ForwardRenderJob=ps,c.FragmentVarying=tn,c.FrameCache=Vs,c.Frustum=Hn,c.FrustumCSM=Yn,c.FrustumCulling_cs=ng,c.FullQuad_vert_wgsl=dn,c.GBufferFrame=we,c.GBufferPass=ul,c.GBuffer_pass=Ja,c.GILighting=Bs,c.GIProbeMaterial=oc,c.GIProbeMaterialType=$s,c.GIProbeShader=Iu,c.GIRenderCompleteEvent=gs,c.GIRenderStartEvent=pa,c.GLBChunk=yh,c.GLBHeader=Sh,c.GLBParser=Es,c.GLSLLexer=$n,c.GLSLLexerToken=hi,c.GLSLPreprocessor=el,c.GLSLSyntax=al,c.GLTFBinaryExtension=kh,c.GLTFParser=Ke,c.GLTFSubParser=va,c.GLTFSubParserCamera=uh,c.GLTFSubParserConverter=Ch,c.GLTFSubParserMaterial=fh,c.GLTFSubParserMesh=ch,c.GLTFSubParserSkeleton=bs,c.GLTFSubParserSkin=dh,c.GLTFType=Qt,c.GLTF_Accessors=Sd,c.GLTF_Info=ma,c.GLTF_Light=vd,c.GLTF_Mesh=Cd,c.GLTF_Node=_d,c.GLTF_Primitives=xd,c.GLTF_Scene=Ad,c.GPUAddressMode=ut,c.GPUBlendFactor=nf,c.GPUBufferBase=Wt,c.GPUBufferType=Et,c.GPUCompareFunction=zt,c.GPUContext=w,c.GPUCullMode=at,c.GPUFilterMode=kt,c.GPUPrimitiveTopology=ii,c.GPUTextureFormat=z,c.GPUVertexFormat=ai,c.GPUVertexStepMode=uf,c.GTAOPost=zp,c.GTAO_cs=su,c.GUIAtlasTexture=Jh,c.GUICanvas=Bi,c.GUIConfig=Mr,c.GUIGeometry=Vu,c.GUIGeometryRebuild=Yu,c.GUIMaterial=js,c.GUIPick=qu,c.GUIPickHelper=Zu,c.GUIQuad=Vt,c.GUIQuadAttrEnum=Ie,c.GUIRenderer=Xu,c.GUIShader=Xs,c.GUISpace=St,c.GUISprite=Wr,c.GUITexture=Ar,c.GenerayRandomDir=vn,c.GeoJsonParser=jp,c.GeoJsonUtil=Wp,c.GeoType=Ua,c.GeometryBase=ve,c.GeometryIndicesBuffer=El,c.GeometryInfo=Ma,c.GeometryUtil=to,c.GeometryVertexBuffer=bl,c.GeometryVertexType=je,c.GetComponentClass=Mo,c.GetCountInstanceID=Ya,c.GetRepeat=If,c.GetShader=Ro,c.GlassMaterial=Tm,c.GlassShader=bu,c.GlobalBindGroup=ae,c.GlobalBindGroupLayout=os,c.GlobalFog=kp,c.GlobalFog_shader=Mu,c.GlobalIlluminationComponent=Zg,c.GlobalUniform=ra,c.GlobalUniformGroup=jn,c.GodRayPost=Gp,c.GodRay_cs=ou,c.Graphic3D=hc,c.Graphic3DBatchRenderer=fa,c.Graphic3DFaceRenderer=Ut,c.Graphic3DFillRenderer=nc,c.Graphic3DFixedRenderMaterial=yc,c.Graphic3DLineRenderer=lc,c.Graphic3DMesh=Lp,c.Graphic3DMeshRenderer=bc,c.Graphic3DRibbonRenderer=ei,c.Graphic3DShader=Cu,c.GraphicFaceCompute3=gg,c.GraphicLineCompute=Su,c.Graphics3DShape=fs,c.HDRTexture=Ps,c.HDRTextureCube=Ca,c.Hair_frag=Cn,c.Hair_shader_op=Bu,c.Hair_shader_tr=Eu,c.HaltonSeq=oa,c.Horizontal=tc,c.HoverCameraController=Hg,c.I3DMLoader=Rt,c.I3DMLoaderBase=Gh,c.I3DMParser=Vh,c.IBLEnvMapCreator=Uh,c.IBLEnvMapCreator_cs=Rh,c.IESProfiles=Dt,c.IESProfiles_frag=an,c.IKDTreeUserData=fp,c.ImageType=Kr,c.IndicesGPUBuffer=Bl,c.Inline_vert=jo,c.InputSystem=Po,c.InstanceDrawComponent=$g,c.InstanceUniform=Zo,c.InstancedMesh=Qh,c.Interpolator=mr,c.InterpolatorEnum=ms,c.IrradianceDataReaderCompleteEvent=Sc,c.IrradianceVolumeData_frag=Xo,c.Irradiance_frag=on,c.IsEditorInspector=ff,c.IsNonSerialize=Va,c.Joint=gh,c.JointPose=Is,c.JumperInterpolator=sh,c.KDTreeEntity=gp,c.KDTreeNode=xr,c.KDTreeRange=dc,c.KDTreeSpace=gc,c.KDTreeUUID=Ri,c.KHR_draco_mesh_compression=ws,c.KHR_lights_punctual=qp,c.KHR_materials_clearcoat=vh,c.KHR_materials_emissive_strength=_h,c.KHR_materials_ior=Kp,c.KHR_materials_sheen=Jp,c.KHR_materials_specular=Zp,c.KHR_materials_transmission=$p,c.KHR_materials_unlit=xh,c.KHR_materials_variants=em,c.KHR_materials_volume=tm,c.KHR_mesh_quantization=rm,c.KHR_texture_basisu=im,c.KHR_texture_transform=am,c.KV=ro,c.KelvinUtil=lA,c.KeyCode=Ge,c.KeyEvent=hr,c.Keyframe=ba,c.KeyframeT=tf,c.LDRTextureCube=ya,c.LUT_glsl=ug,c.LambertMaterial=Dm,c.Lambert_shader=wn,c.LightBase=xi,c.LightData=sa,c.LightEntries=_l,c.LightType=Ee,c.LightingFunction_frag=ko,c.Line=Qe,c.LineCap=Ic,c.LineClassification=Ku,c.LineJoin=wc,c.LinearInterpolator=ah,c.LitMaterial=rr,c.Lit_shader=un,c.LoaderBase=Dr,c.LoaderEvent=pp,c.LoaderManager=Ra,c.MAX_VALUE=xf,c.MIN_VALUE=Cf,c.Material=We,c.MaterialDataUniformGPUBuffer=ll,c.MaterialUniform=vg,c.MaterialUtilities=La,c.MathShader=ta,c.MathUtil=Ye,c.Matrix3=Lr,c.Matrix4=R,c.MatrixBindGroup=Sl,c.MatrixDO=cp,c.MatrixGPUBuffer=Cl,c.MatrixShader=_n,c.MemoryDO=ur,c.MemoryInfo=Lo,c.MergeRGBACreator=vp,c.MergeRGBA_cs=nu,c.MeshColliderShape=Da,c.MinMaxAnimationCurves=zm,c.MinMaxCurve=Zc,c.MinMaxCurveState=Jc,c.MinMaxPolyCurves=km,c.MorePassParser=xp,c.MorePassShader=xc,c.MorphTargetBlender=Ug,c.MorphTargetData=wl,c.MorphTargetFrame=Lg,c.MorphTargetTransformKey=Gu,c.MorphTarget_shader=ft,c.MouseCode=Ac,c.MultiBouncePass_cs=Kl,c.Navi3DAstar=rf,c.Navi3DConst=Vi,c.Navi3DEdge=Nt,c.Navi3DFunnel=nr,c.Navi3DMaskType=Sr,c.Navi3DMergeVertex=Zm,c.Navi3DMesh=$m,c.Navi3DPoint=Ze,c.Navi3DPoint2D=lo,c.Navi3DPointFat=Ft,c.Navi3DRouter=X,c.Navi3DTriangle=af,c.NonSerialize=si,c.NormalMap_frag=en,c.OAnimationEvent=mh,c.OBJParser=wh,c.Object3DEvent=mp,c.Object3DUtil=hA,c.ObjectAnimClip=zu,c.OcclusionSystem=ds,c.Octree=dr,c.OctreeEntity=gl,c.OrbitController=Yg,c.OrderMap=Om,c.Orientation3D=qt,c.OutLineBlendColor_cs=lu,c.OutlineCalcOutline_cs=hu,c.OutlinePass=pg,c.OutlinePost=Qp,c.OutlinePostData=Dc,c.OutlinePostManager=Pc,c.OutlinePostSlot=Tc,c.Outline_cs=uu,c.OvershootInterpolator=lh,c.PBRLItShader=cn,c.PBRLitSSSShader=Tu,c.ParserBase=it,c.ParserFormat=Pe,c.ParticleSystemCurveEvalMode=Kc,c.ParticleSystemRandomnessIds=Xc,c.PassGenerate=gi,c.PassShader=Cc,c.PassType=W,c.PavementShader=mg,c.PhysicMaterial=Mm,c.PhysicMaterialUniform_frag=Go,c.PickCompute=uc,c.PickFire=cc,c.PickResult=Mc,c.Picker_cs=cu,c.PingPong=Za,c.PipelinePool=cs,c.Plane=so,c.Plane3D=$c,c.PlaneClassification=Nr,c.PlaneGeometry=Dl,c.PointClassification=Ju,c.PointLightShadowRenderer=zl,c.PointShadowCubeCamera=Fl,c.PointShadowDebug=Ag,c.PointerEvent3D=L,c.Polynomial=Yt,c.PolynomialCurve=or,c.Polynomials=Nm,c.PoolNode=ju,c.PostBase=Ct,c.PostProcessingComponent=zs,c.PostRenderer=Hl,c.PreDepthPassRenderer=Ql,c.PreIntegratedLut=fu,c.PreIntegratedLutCompute=_c,c.PrefabAvatarData=Uc,c.PrefabAvatarParser=Lc,c.PrefabBoneData=Rc,c.PrefabMaterialParser=Fc,c.PrefabMeshData=kc,c.PrefabMeshParser=Gc,c.PrefabNode=Ni,c.PrefabParser=Vc,c.PrefabStringUtil=fm,c.PrefabTextureData=Oc,c.PrefabTextureParser=Qc,c.Preprocessor=Tt,c.Probe=sc,c.ProbeEntries=xl,c.ProbeGBufferFrame=jl,c.ProfilerUtil=vt,c.PropertyAnimClip=Tg,c.PropertyAnimTag=ku,c.PropertyAnimation=Hs,c.PropertyAnimationClip=Hc,c.PropertyAnimationEvent=bi,c.PropertyHelp=Ii,c.QuadAABB=Je,c.QuadGlsl_fs=bn,c.QuadGlsl_vs=In,c.QuadRoot=mc,c.QuadTree=pc,c.QuadTreeCell=Cr,c.Quad_depth2dArray_frag_wgsl=Af,c.Quad_depth2d_frag_wgsl=mn,c.Quad_depthCube_frag_wgsl=An,c.Quad_frag_wgsl=pn,c.Quad_vert_wgsl=gn,c.Quaternion=Y,c.RADIANS_TO_DEGREES=Gr,c.RGBEErrorCode=Mh,c.RGBEHeader=Ms,c.RGBEParser=Rs,c.RTDescriptor=ce,c.RTFrame=Oe,c.RTResourceConfig=Le,c.RTResourceMap=ye,c.Rand=oi,c.RandomSeed=bf,c.Ray=_t,c.RayCastMeshDetail=ti,c.Reader=Hr,c.Rect=ni,c.Reference=te,c.RegisterComponent=mt,c.RegisterShader=jt,c.RenderContext=Pl,c.RenderLayer=li,c.RenderLayerUtil=ns,c.RenderNode=er,c.RenderShaderCollect=Al,c.RenderShaderCompute=vc,c.RenderShaderPass=Ae,c.RenderTexture=et,c.RendererBase=pr,c.RendererJob=Yl,c.RendererMap=Vl,c.RendererMask=Be,c.RendererMaskUtil=bt,c.RendererPassState=Il,c.RepeatSE=$a,c.Res=$h,c.RibbonStruct=Fi,c.SN_ArrayConstant=ui,c.SN_BinaryOperation=gr,c.SN_Break=nd,c.SN_CodeBlock=Pt,c.SN_Constant=Zt,c.SN_Continue=ua,c.SN_Declaration=xe,c.SN_Discard=ld,c.SN_DoWhileLoop=od,c.SN_Expression=J,c.SN_ForLoop=br,c.SN_Function=la,c.SN_FunctionArgs=ha,c.SN_FunctionCall=Ir,c.SN_IFBranch=Er,c.SN_Identifier=Jt,c.SN_IndexOperation=Tr,c.SN_Layout=di,c.SN_ParenExpression=rl,c.SN_Precision=ca,c.SN_Return=ci,c.SN_SelectOperation=fi,c.SN_Struct=Kt,c.SN_TernaryOperation=il,c.SN_UnaryOperation=Yr,c.SN_WhileLoop=Br,c.SSAO_cs=og,c.SSRPost=Vp,c.SSR_BlendColor_cs=du,c.SSR_IS_Kernel=Hp,c.SSR_IS_cs=gu,c.SSR_RayTrace_cs=pu,c.Scene3D=sp,c.Shader=ke,c.ShaderAttributeInfo=us,c.ShaderConverter=sl,c.ShaderConverterResult=ol,c.ShaderLib=F,c.ShaderPassBase=Xa,c.ShaderReflection=He,c.ShaderStage=Mt,c.ShaderState=nl,c.ShaderUniformInfo=hs,c.ShaderUtil=$t,c.ShadingInput=rn,c.ShadowLightsCollect=ot,c.ShadowMapPassRenderer=Gl,c.ShadowMapping_frag=sn,c.ShapeInfo=Fr,c.Skeleton=ph,c.SkeletonAnimationClip=Aa,c.SkeletonAnimationClipState=Ah,c.SkeletonAnimationCompute=Og,c.SkeletonAnimation_shader=kr,c.SkeletonBlendComputeArgs=Fg,c.SkeletonPose=_i,c.SkeletonTransformComputeArgs=Ng,c.SkyGBufferPass=hl,c.SkyGBuffer_pass=Bn,c.SkyMaterial=Ou,c.SkyRenderer=Ia,c.Sky_glsl_fs=hg,c.Sky_glsl_vs=lg,c.SolidColorSky=sA,c.SphereColliderShape=ap,c.SphereGeometry=Si,c.StatementNode=ne,c.StorageGPUBuffer=Z,c.StorageUtil=ho,c.StringUtil=tt,c.StripeGeometry=tA,c.Struct=Bt,c.StructStorageGPUBuffer=Ui,c.SubGeometry=Tl,c.TAACopyTex_cs=mu,c.TAAPost=Yp,c.TAASharpTex_cs=Au,c.TAA_cs=vu,c.TextAnchor=$u,c.TextFieldLayout=ic,c.TextFieldLine=rc,c.Texture=De,c.TextureCube=_a,c.TextureCubeFaceData=Us,c.TextureCubeStdCreator=xa,c.TextureCubeUtils=Ds,c.TextureMipmapCompute=_p,c.TextureMipmapGenerator=$e,c.ThirdPersonCameraController=jg,c.TileSet=ym,c.TileSetChild=Im,c.TileSetChildContent=bm,c.TileSetChildContentMetaData=Bm,c.TileSetRoot=wm,c.TilesRenderer=io,c.Time=ue,c.TokenType=_,c.TorusGeometry=rA,c.TouchData=Do,c.TrailGeometry=Bc,c.Transform=st,c.TranslatorContext=ls,c.TriGeometry=eo,c.Triangle=Pi,c.UIButton=qs,c.UIButtonTransition=ac,c.UIComponentBase=Ws,c.UIEvent=Ap,c.UIImage=Or,c.UIImageGroup=Ks,c.UIInteractive=Ta,c.UIInteractiveStyle=Se,c.UIPanel=Di,c.UIRenderAble=Ti,c.UIShadow=Js,c.UITextField=Zs,c.UITransform=sr,c.UUID=dt,c.UV=no,c.Uint16Texture=oA,c.Uint8ArrayTexture=Xh,c.UnLit=yn,c.UnLitMaterial=Na,c.UnLitMaterialUniform_frag=Qo,c.UnLitTexArrayMaterial=Oi,c.UnLitTextureArray=Du,c.UnLit_frag=Vo,c.UniformGPUBuffer=ct,c.UniformNode=cr,c.UniformType=Ve,c.ValueEnumType=O,c.ValueOp=Jm,c.ValueParser=Ht,c.ValueSpread=Gm,c.Vector2=V,c.Vector3=d,c.Vector3Ex=Ur,c.Vector3Struct=dA,c.Vector4=G,c.VertexAttribute=up,c.VertexAttributeIndexShader=xu,c.VertexAttributeName=M,c.VertexAttributeSize=fr,c.VertexAttributeStride=fc,c.VertexAttributes=Ho,c.VertexBufferLayout=hp,c.VertexFormat=No,c.VertexGPUBuffer=da,c.Vertical=ec,c.VideoUniform_frag=Yo,c.View3D=op,c.ViewPanel=Ba,c.ViewQuad=ga,c.VirtualTexture=fe,c.WGSLTranslator=tl,c.WebGPUDescriptorCreator=Ce,c.WorldMatrixUniform=Wa,c.WorldPanel=Ea,c.WrapMode=Zr,c.WrapTimeMode=_r,c.ZCullingCompute=Op,c.ZPassShader_cs=_u,c.ZPassShader_fs=Rn,c.ZPassShader_vs=Mn,c.ZSorterUtil=Wn,c.append=Vn,c.arrayToString=Lh,c.blendComponent=lf,c.buildCurves=Vm,c.calculateCurveRangesValue=Hm,c.calculateMinMax=ki,c.castPointShadowMap_vert=Tn,c.clamp=j,c.clampRepeat=Wf,c.compute_skeleton_blend=zg,c.compute_skeleton_transform=kg,c.cos=zf,c.crossProduct=Yf,c.cubicPolynomialRoot=jc,c.cubicPolynomialRootsGeneric=Wc,c.curvesSupportProcedural=Qm,c.deg2Rad=Of,c.directionShadowCastMap_frag=Pn,c.dot=Xe,c.doubleIntegrateSegment=qc,c.downSample=ru,c.f32=uA,c.fastInvSqrt=Gn,c.floorfToIntPos=kn,c.fonts=qr,c.generateRandom=Xf,c.generateRandom3=jf,c.getFloatFromInt=Fn,c.getGLTypeFromTypedArray=Ud,c.getGLTypeFromTypedArrayType=Rd,c.getGlobalRandomSeed=kf,c.getTypedArray=Ld,c.getTypedArrayTypeFromGLType=ys,c.grad1=oo,c.grad2=Qa,c.grad3=Gi,c.grad4=ri,c.graphicDynamicCompute=cg,c.graphicFaceCompute=dg,c.graphicFaceCompute2=fg,c.graphicTrailCompute=yu,c.i32=cA,c.integrateSegment=ao,c.irradianceDataReader=Cp,c.kPI=Fm,c.lerp=wr,c.lerpByte=wf,c.lerpColor=yf,c.lerpVector3=Sf,c.magnitude=ts,c.makeAloneSprite=ag,c.makeGUISprite=Kh,c.makeMatrix44=aa,c.matrixMultiply=ss,c.matrixRotate=Zf,c.matrixRotateY=Jf,c.mergeFunctions=Fo,c.multiplyMatrices4x4REF=Qn,c.normal_distribution=ef,c.normalizeFast=Hf,c.normalizeSafe=On,c.normalizedToByte=Vf,c.normalizedToWord=Qf,c.outlinePostData=Lt,c.outlinePostManager=Xp,c.perm=K,c.post=iu,c.quadraticPolynomialRootsGeneric=Ga,c.rad2Deg=Ff,c.random01=Qr,c.randomBarycentricCoord=Lf,c.randomPointBetweenEllipsoid=Uf,c.randomPointBetweenSphere=Mf,c.randomPointInsideCube=Df,c.randomPointInsideEllipsoid=Pf,c.randomPointInsideUnitCircle=Rf,c.randomPointInsideUnitSphere=zn,c.randomQuaternion=Ef,c.randomQuaternionUniformDistribution=Tf,c.randomUnitVector=ia,c.randomUnitVector2=Nn,c.rangedRandomFloat=ze,c.rangedRandomInt=Bf,c.readMagicBytes=Os,c.registerMaterial=Pm,c.repeat=as,c.rotMatrix=Kf,c.rotateVectorByQuat=_f,c.roundfToIntPos=rs,c.scale=es,c.shadowCastMap_frag=Dn,c.shadowCastMap_vert=En,c.simplex=pt,c.sin=Nf,c.snoise1=jm,c.snoise2=Wm,c.snoise3=qm,c.snoise4=Km,c.sqrMagnitude=is,c.sqrtImpl=Ln,c.stencilStateFace=hf,c.swap=Gf,c.threshold=tu,c.toHalfFloat=jr,c.u32=fA,c.uniform_real_distribution=Ym,c.uniform_real_distribution2=Xm,c.upSample=Qs,c.webGPUContext=I,c.zSorterUtil=qn,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
