import { Object3D } from '../core/entities/Object3D';
import { Texture } from '../gfx/graphics/webGpu/core/texture/Texture';
import { LoaderFunctions } from '../loader/LoaderFunctions';
import { BitmapTexture2D } from '../textures/BitmapTexture2D';
import { HDRTextureCube } from '../textures/HDRTextureCube';
import { GLTF_Info } from '../loader/parser/gltf/GLTFInfo';
import { Uint8ArrayTexture } from '../textures/Uint8ArrayTexture';
import { GUISprite } from '../components/gui/core/GUISprite';
import { GUITexture } from '../components/gui/core/GUITexture';
import { GUIAtlasTexture } from '../components/gui/core/GUIAtlasTexture';
import { FontInfo } from '../loader/parser/FontParser';
import { Material } from '../materials/Material';
import { Parser } from '../util/Global';
import { ParserBase } from '../loader/parser/ParserBase';
import { GeometryBase } from '../core/geometry/GeometryBase';
import { LitMaterial } from '../materials/LitMaterial';
/**
 * Resource management classes for textures, materials, models, and preset bodies.
 * @group Assets
 */
export declare class Res {
    private _texturePool;
    private _materialPool;
    private _prefabPool;
    private _gltfPool;
    private _geometryPool;
    private _atlasList;
    private _obj;
    /**
     * @constructor
     */
    constructor();
    getGltf(url: string): GLTF_Info;
    /**
   * add a obj with reference of url
   * @param url file path
   * @param texture source obj
   */
    addObj(url: string, obj: any): void;
    /**
     * get obj by url
     * @param url file path
     * @returns
     */
    getObj(url: string): any;
    /**
     * add a texture with reference of url
     * @param url file path
     * @param texture source texture
     */
    addTexture(url: string, texture: Texture): void;
    /**
     * get texture by url
     * @param url file path
     * @returns
     */
    getTexture(url: string): Texture;
    addGeometry(url: string, geo: GeometryBase): void;
    getGeometry(url: string): GeometryBase;
    /**
     * add a material with reference of name
     * @param name material name
     * @param mat  target material
     */
    addMat(name: string, mat: Material): Map<string, Material>;
    /**
     * get material by name
     * @param name material name
     * @returns
     */
    getMat(name: string): Material;
    /**
     * add prefab with reference name
     * @param name prefab name
     * @param rootScene root object of prefab
     */
    addPrefab(name: string, rootScene: Object3D): void;
    /**
     * get prefab by name
     * @param name prefab name
     * @returns
     */
    getPrefab(name: string): Object3D;
    addAtlas(name: string, atlas: GUIAtlasTexture): void;
    getAtlas(name: string): GUIAtlasTexture;
    getGUISprite(id: string): GUISprite;
    load<T extends ParserBase>(url: string, c: Parser<T>, loaderFunctions?: LoaderFunctions): Promise<any>;
    /**
     * load a gltf file
     * @param url the url of file
     * @param loaderFunctions callback
     * @returns
     */
    loadGltf(url: string, loaderFunctions?: LoaderFunctions): Promise<Object3D>;
    /**
     * load obj file
     * @param url obj file path
     * @param loaderFunctions callback
     * @returns
     */
    loadObj(url: string, loaderFunctions?: LoaderFunctions): Promise<Object3D>;
    /**
     * load b3dm file by url
     * @param url path of file
     * @param loaderFunctions callback
     * @returns
     */
    loadB3DM(url: string, loaderFunctions?: LoaderFunctions, userData?: any): Promise<Object3D>;
    /**
     * load i3dm file by url
     * @param url path of i3dm file
     * @param loaderFunctions callback
     * @returns
     */
    loadI3DM(url: string, loaderFunctions?: LoaderFunctions, userData?: any): Promise<Object3D>;
    /**
     * load texture by url
     * @param url texture path
     * @param loaderFunctions callback
     * @param flipY use flip y or not
     * @returns
     */
    loadTexture(url: string, loaderFunctions?: LoaderFunctions, flipY?: boolean): Promise<Texture>;
    private loadTextureCount;
    loadBitmapTextures(urls: string[], count?: number, loaderFunctions?: LoaderFunctions, flipY?: boolean): Promise<BitmapTexture2D[]>;
    /**
     * load a hdr texture
     * @param url texture url
     * @param loaderFunctions callback
     * @returns
     */
    loadHDRTexture(url: string, loaderFunctions?: LoaderFunctions): Promise<Texture>;
    /**
     * load hdr cube texture
     * @param url file url
     * @param loaderFunctions callback
     * @returns
     */
    loadHDRTextureCube(url: string, loaderFunctions?: LoaderFunctions): Promise<Texture>;
    /**
     * load ldr cube texture
     * @param url file path
     * @param loaderFunctions callback
     * @returns
     */
    loadLDRTextureCube(url: string, loaderFunctions?: LoaderFunctions): Promise<Texture>;
    /**
     * load texture data from array of web url.
     * make sure there are six images in a group,
     * and the order is: nx, px, py, ny, nz, pz
     * @param urls
     */
    loadTextureCubeMaps(urls: string[]): Promise<Texture>;
    /**
     * load texture data from url.
     * the image is assembled from six images into cross shaped image.
     * @param url the path of image
     */
    loadTextureCubeStd(url: string, loaderFunctions?: LoaderFunctions): Promise<Texture>;
    /**
     * load json data from url.
     * @param url the path of image
     */
    loadJSON(url: string, loaderFunctions?: LoaderFunctions): Promise<void | object>;
    /**
     * load font file by url
     * @param url font file url
     * @param loaderFunctions callback
     * @returns
     */
    loadFont(url: string, loaderFunctions?: LoaderFunctions, userData?: any): Promise<FontInfo>;
    /**
     * load a atlas file by url
     * @param url file path
     * @param loaderFunctions callback
     * @returns
     */
    loadAtlas(url: string, loaderFunctions?: LoaderFunctions): Promise<FontInfo>;
    /**
     * normal texture
     */
    normalTexture: Uint8ArrayTexture;
    maskTexture: Uint8ArrayTexture;
    whiteTexture: Uint8ArrayTexture;
    blackTexture: Uint8ArrayTexture;
    redTexture: Uint8ArrayTexture;
    blueTexture: Uint8ArrayTexture;
    greenTexture: Uint8ArrayTexture;
    yellowTexture: Uint8ArrayTexture;
    grayTexture: Uint8ArrayTexture;
    defaultSky: HDRTextureCube;
    defaultGUITexture: GUITexture;
    defaultGUISprite: GUISprite;
    defaultMaterial: LitMaterial;
    /**
     * create a texture
     * @param width width of texture
     * @param height height of texture
     * @param r component-red
     * @param g component-green
     * @param b component-blue
     * @param a component-alpha（0 for transparent，1 for opaque）
     * @param name name string
     * @returns
     */
    createTexture(width: number, height: number, r: number, g: number, b: number, a: number, name?: string): Uint8ArrayTexture;
    /**
     * fill slod color to this texture
     * @param array data of texture
     * @param w width of texture
     * @param h height of texture
     * @param r component-red
     * @param g component-green
     * @param b component-blue
     * @param a component-alpha（0 for transparent，1 for opaque）
     */
    fillColor(array: any, w: number, h: number, r: number, g: number, b: number, a: number): void;
    /**
     * Initialize a common texture object. Provide a universal solid color texture object.
     */
    initDefault(): void;
}
