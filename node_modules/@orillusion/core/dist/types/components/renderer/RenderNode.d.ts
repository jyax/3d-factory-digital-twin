/// <reference types="@webgpu/types" />
import { View3D } from "../../core/View3D";
import { GeometryBase } from "../../core/geometry/GeometryBase";
import { ShaderReflection } from "../../gfx/graphics/webGpu/shader/value/ShaderReflectionInfo";
import { RenderContext } from "../../gfx/renderJob/passRenderer/RenderContext";
import { ClusterLightingBuffer } from "../../gfx/renderJob/passRenderer/cluster/ClusterLightingBuffer";
import { RendererMask } from "../../gfx/renderJob/passRenderer/state/RendererMask";
import { RendererPassState } from "../../gfx/renderJob/passRenderer/state/RendererPassState";
import { PassType } from "../../gfx/renderJob/passRenderer/state/RendererType";
import { ComponentBase } from "../ComponentBase";
import { Octree } from "../../core/tree/octree/Octree";
import { OctreeEntity } from "../../core/tree/octree/OctreeEntity";
import { Material } from "../../materials/Material";
import { RenderLayer } from "../../gfx/renderJob/config/RenderLayer";
import { RenderShaderCompute } from "../..";
/**
 * @internal
 * @group Components
 */
export declare class RenderNode extends ComponentBase {
    instanceCount: number;
    lodLevel: number;
    alwaysRender: boolean;
    instanceID: string;
    drawType: number;
    protected _geometry: GeometryBase;
    protected _materials: Material[];
    protected _castShadow: boolean;
    protected _castReflection: boolean;
    protected _castGI: boolean;
    protected _rendererMask: number;
    protected _inRenderer: boolean;
    protected _readyPipeline: boolean;
    protected _combineShaderRefection: ShaderReflection;
    protected _ignoreEnvMap?: boolean;
    protected _ignorePrefilterMap?: boolean;
    protected __renderOrder: number;
    protected _renderOrder: number;
    isRenderOrderChange?: boolean;
    needSortOnCameraZ?: boolean;
    protected _octreeBinder: {
        octree: Octree;
        entity: OctreeEntity;
    };
    preInit: boolean;
    /**
     *
     * The layer membership of the object.
     *  The object is only visible when it has at least one common layer with the camera in use.
     * When using a ray projector, this attribute can also be used to filter out unwanted objects in ray intersection testing.
     */
    protected _renderLayer: RenderLayer;
    protected _computes: RenderShaderCompute[];
    init(param?: any): void;
    attachSceneOctree(octree: Octree): void;
    detachSceneOctree(): void;
    protected updateOctreeEntity(e?: any): void;
    copyComponent(from: this): this;
    get renderLayer(): RenderLayer;
    set renderLayer(value: RenderLayer);
    get geometry(): GeometryBase;
    set geometry(value: GeometryBase);
    addMask(mask: RendererMask): void;
    removeMask(mask: RendererMask): void;
    hasMask(mask: RendererMask): boolean;
    get rendererMask(): number;
    set rendererMask(value: number);
    get renderOrder(): number;
    set renderOrder(value: number);
    get materials(): Material[];
    set materials(value: Material[]);
    private addComputes;
    private removeComputes;
    addRendererMask(tag: RendererMask): void;
    removeRendererMask(tag: RendererMask): void;
    onEnable(): void;
    onDisable(): void;
    selfCloneMaterials(key: string): this;
    protected initPipeline(): void;
    protected castNeedPass(): void;
    get castShadow(): boolean;
    set castShadow(value: boolean);
    get castGI(): boolean;
    set castGI(value: boolean);
    get castReflection(): boolean;
    set castReflection(value: boolean);
    renderPass(view: View3D, passType: PassType, renderContext: RenderContext): void;
    /**
     * render pass at passType
     * @param pass
     * @param encoder
     * @returns
     */
    renderPass2(view: View3D, passType: PassType, rendererPassState: RendererPassState, clusterLightingBuffer: ClusterLightingBuffer, encoder: GPURenderPassEncoder, useBundle?: boolean): void;
    recordRenderPass2(view: View3D, passType: PassType, rendererPassState: RendererPassState, clusterLightingBuffer: ClusterLightingBuffer, encoder: GPURenderPassEncoder, useBundle?: boolean): void;
    private noticeShaderChange;
    nodeUpdate(view: View3D, passType: PassType, renderPassState: RendererPassState, clusterLightingBuffer?: ClusterLightingBuffer): void;
    beforeDestroy(force?: boolean): void;
    destroy(force?: boolean): void;
}
