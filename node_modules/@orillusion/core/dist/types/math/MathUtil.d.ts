import { Color } from './Color';
import { Matrix4 } from './Matrix4';
import { Quaternion } from './Quaternion';
import { Rand } from './Rand';
import { Vector2 } from './Vector2';
import { Vector3 } from './Vector3';
/**
 * This is a constant value used to convert radians to angles
 */
export declare let RADIANS_TO_DEGREES: number;
/**
 * This is a constant value used to convert angles to radians
 */
export declare let DEGREES_TO_RADIANS: number;
/**
 * @internal
 */
export declare let MAX_VALUE: number;
/**
 * @internal
 */
export declare let MIN_VALUE: number;
/**
 * value min max bound
 * @internal
 * @param value
 * @param min
 * @param max
 * @returns
 */
export declare function clamp(value: any, min: any, max: any): number;
/**
 * Built-in mathematical basic calculation factory function
 * @group Math
 */
export declare class MathUtil {
    /**
     * @private
     * The gaussian function to calculate the color value
     * @param {number} value the value (the x-value)
     * @param {number} amplitude the curve peak
     * @param {number} center the curve center
     * @param {number} rmsWidth the curve width
     * @returns {number} the color value (the y-value)
     */
    private static gaussFunction;
    /**
     * Calculate the Gaussian distribution function
     * @param n Function variable value
     * @param theta The degree of dispersion of the data distribution
     * @returns The result of the calculated Gaussian distribution value
     */
    private static computeGaussian;
    /**
     * Calculate Gaussian coefficient
     * @param sigma sigma value
     * @returns Return the calculation result
     */
    private static gaussCoef;
    /**
     * Limit the value to a certain range
     * @param value Original value
     * @param min_inclusive minimum value
     * @param max_inclusive maximum value
     * @returns Return the calculation result
     */
    static clampf(value: number, min_inclusive: number, max_inclusive: number): number;
    /**
     * Normalize the Angle so that it is limited to the range [-180, 180]
     * @param a Angle of input
     * @returns Return the processing result
     */
    static normalizeAngle(a: number): number;
    /**
     * Returns the fractional part of a number
     * @param v input value
     * @returns Return the result
     */
    static fract(v: number): number;
    /**
     * Generate a random pair of x and z coordinates that fall within the radius of the circle
     * @param r radius
     * @returns The generated x, z results
     */
    static getRandDirXZ(r: number): {
        x: number;
        z: number;
    };
    /**
     * Generate a random pair of x, y, and z coordinates that fall within the radius of the sphere
     * @param r radius
     * @returns The Vector3 vector formed by the generated x, y, and z coordinate values
     */
    static getRandDirXYZ(r: number): Vector3;
    /**
     * According to the radius, generate a random pair of x, y, z coordinates that fall within the sphere and the y value is between [-r/2, r/2]
     * @param r radius
     * @returns The Vector3 vector formed by the generated x, y, and z coordinate values
     */
    static getCycleXYZ(r: number): Vector3;
    /**
     * Calculate the Angle between two vectors
     * @param p1 Vector 1
     * @param p2 Vector 2
     * @returns Return the calculation result
     */
    static angle(p1: Vector3, p2: Vector3): number;
    /**
     * Calculate the Angle between two vectors
     * @param from Vector 1
     * @param to Vector 2
     * @returns The Angle between two vectors
     */
    static angle_360(from: Vector3, to: Vector3): number;
    /**
     * The rotation Angle around the Y-axis is obtained from the input vector
     * @param v input vector
     * @returns Return the calculation result
     */
    getRotationY(v: Vector3): number;
    /**
     * Calculate the quaternion from one direction to the other
     * @param fromDirection Initial direction
     * @param toDirection The transformed direction
     * @param target The calculated quaternion is null by default and the result is returned
     * @returns Quaternion The calculated quaternion returns a new instance created if target is null
     * @version Orillusion3D  0.5.1
     */
    static fromToRotation(fromDirection: Vector3, toDirection: Vector3, target?: Quaternion): Quaternion;
    /**
     * Get the Eular direction
     * @param v input value
     * @returns Return the calculation result
     */
    static getEularDir_yUp(v: number): Vector3;
    /**
     * Compute the vector transformation and assign the results to the input variables
     * @param matrix transformation matrix
     * @param vector Original vector
     * @param result output vector
     * @returns Returns the output vector
     */
    static transformVector(matrix: Matrix4, vector: Vector3, result?: Vector3): Vector3;
}
/**
 * @internal
 */
export declare let lerp: (v0: number, v1: number, t: number) => number;
/**
 * @internal
 */
export declare function lerpVector3(v0: Vector3, v1: Vector3, t: number): Vector3;
/**
 * @internal
 */
export declare function lerpColor(c0: Color, c1: Color, t: any): Color;
/**
 * @internal
 */
export declare function lerpByte(u0: any, u1: any, scale: any): number;
/**
 * @internal
 */
export declare let PingPong: (t: number, start: number, end: number) => number;
/**
 * @internal
 */
export declare let RepeatSE: (t: number, start: number, end: number) => number;
/**
 * @internal
 */
export declare let GetRepeat: (datas: any[], element: any) => number;
/**
 * @internal
 * @group Math
 */
export declare class RandomSeed {
    x: number;
    y: number;
    z: number;
    w: number;
    randSeedList: number[];
    constructor();
    reset(): void;
}
/**
 * @internal
 */
export declare function dot(lhs: Vector2 | Quaternion | Vector3, rhs: Vector2 | Quaternion | Vector3): number;
/**
 * @internal
 */
export declare function scale(lhs: Vector3, rhs: Vector3): Vector3;
/**
 * @internal
 */
export declare function sqrtImpl(f: number): number;
/**
 * @internal
 */
export declare function magnitude(inV: Vector2 | Vector3 | Quaternion): number;
/**
 * @internal
 */
export declare function normalizeSafe(inV: Vector2 | Vector3 | Quaternion, defaultV?: Vector2 | Vector3 | Quaternion): Vector2 | Vector3 | Quaternion;
/**
 * @internal
 */
export declare function getFloatFromInt(value: any): number;
/**
 * @internal
 */
export declare function random01(value: any): any;
/**
 * @internal
 */
export declare function rangedRandomFloat(r: Rand, min: number, max: number): number;
/**
 * @internal
 * @param r Rand
 * @param min int
 * @param max int
 */
export declare function rangedRandomInt(r: Rand, min: number, max: number): number;
/**
 * @internal
 */
export declare function randomUnitVector(rand: Rand): Vector3;
/**
 * @internal
 */
export declare function randomUnitVector2(rand: Rand): Vector2;
/**
 * @internal
 */
export declare function randomQuaternion(rand: Rand): number | Quaternion;
/**
 * @internal
 */
export declare function randomQuaternionUniformDistribution(rand: Rand): number | Quaternion;
/**
 * @internal
 */
export declare function randomPointInsideCube(r: Rand, extents: Vector3): Vector3;
/**
 * @internal
 */
export declare function randomPointInsideUnitSphere(r: Rand): Vector3;
/**
 * @internal
 */
export declare function randomPointInsideEllipsoid(r: Rand, extents: Vector3): Vector3;
/**
 * @internal
 */
export declare function randomPointBetweenSphere(r: Rand, minRadius: number, maxRadius: number): Vector3;
/**
 * @internal
 */
export declare function randomPointInsideUnitCircle(r: Rand): Vector2;
/**
 * @internal
 */
export declare function randomPointBetweenEllipsoid(r: Rand, maxExtents: Vector3, minRange: number): Vector3;
/**
 * @internal
 */
export declare function randomBarycentricCoord(rand: Rand): Vector3;
/**
 * @internal
 */
export declare function deg2Rad(deg: any): number;
/**
 * @internal
 */
export declare function rad2Deg(deg: any): number;
/**
 * @internal
 */
export declare function sin(v: number): number;
/**
 * @internal
 */
export declare function cos(v: number): number;
/**
 * @internal
 */
export declare let randomSeed: number;
/**
 * @internal
 */
export declare function getGlobalRandomSeed(): number;
/**
 * @internal
 */
export declare function swap(values: any[], i1: number, i2: number): void;
/**
 * @internal
 */
export declare function floorfToIntPos(f: any): number;
/**
 * @internal
 */
export declare function roundfToIntPos(f: any): number;
/**
 * @internal
 */
export declare function normalizedToWord(f: any): number;
/**
 * @internal
 */
export declare function normalizedToByte(f: any): number;
/**
 * @internal
 */
export declare function fastInvSqrt(f: any): any;
/**
 * @internal
 */
export declare function normalizeFast(inV: Vector3): Vector3;
/**
 * @internal
 */
export declare function crossProduct(lhs: Vector3, rhs: Vector3): Vector3;
/**
 * @internal
 */
export declare function sqrMagnitude(inV: Vector3): number;
/**
 * @internal
 */
export declare function generateRandom(randomIn: any): any;
/**
 * @internal
 */
export declare function generateRandom3(randomOut: Vector3, randomIn: number): void;
/**
 * @internal
 */
export declare function clampRepeat(t: any, t0: any, t1: any): any;
/**
 * @internal
 */
export declare function repeat(t: any, length: any): number;
