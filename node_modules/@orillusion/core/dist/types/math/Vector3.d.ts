/**
 * Vector 3D
 * @group Math
 */
export declare class Vector3 {
    /**
     * Vector maximum
     */
    static readonly MAX: Vector3;
    /**
     * Vector minimum
     */
    static readonly MIN: Vector3;
    /**
     * Vector maximum integer value
     */
    static readonly SAFE_MAX: Vector3;
    /**
     * Vector minimum integer value
     */
    static readonly SAFE_MIN: Vector3;
    /**
     * X axis positive axis coordinate (1, 0, 0).
     */
    static readonly X_AXIS: Vector3;
    /**
     * The X-axis is negative (-1, 0, 0).
     */
    static readonly neg_X_AXIS: Vector3;
    /**
     * The y axis defined as a Vector3 object with coordinates (0,1,0).
     */
    static readonly Y_AXIS: Vector3;
    /**
     * The z axis defined as a Vector3 object with coordinates (0,0,1).
     */
    static readonly Z_AXIS: Vector3;
    /**
     * @internal
     */
    static HELP_0: Vector3;
    /**
     * @internal
     */
    static HELP_1: Vector3;
    /**
     * @internal
     */
    static HELP_2: Vector3;
    /**
     * @internal
     */
    static readonly EPSILON: number;
    /**
     * @internal
     */
    static HELP_3: Vector3;
    /**
     * @internal
     */
    static HELP_4: Vector3;
    /**
     * @internal
     */
    static HELP_5: Vector3;
    /**
     * @internal
     */
    static HELP_6: Vector3;
    /**
     * Returns a new vector with zero x, y, and z components
     */
    static get ZERO(): Vector3;
    /**
     * Returns a new vector whose x, y, and z components are all 1
     */
    static get ONE(): Vector3;
    /**
     * Returns a new vector pointing to the left, x is -1, y is 0, and z is 0
     */
    static get LEFT(): Vector3;
    /**
     * Returns a new vector pointing in the right direction, where x is 1, y is 0, and z is 0
     */
    static get RIGHT(): Vector3;
    /**
     * Returns a new vector pointing upwards, that is, x equals 0, y equals 1, and z equals 0
     */
    static get UP(): Vector3;
    /**
     * Returns a new vector pointing down, where x is 0, y is -1, and z is 0
     */
    static get DOWN(): Vector3;
    /**
     * Returns a new backward vector, x equals 0, y equals 0, and z equals negative 1
     */
    static get BACK(): Vector3;
    /**
     * Returns a new forward-pointing vector, that is, x is 0, y is 0, and z is 1
     */
    static get FORWARD(): Vector3;
    /**
     * The first element of a Vector3 object, such as the x coordinate of
     * a point in the three-dimensional space. The default value is 0.
     */
    x: number;
    /**
     * The second element of a Vector3 object, such as the y coordinate of
     * a point in the three-dimensional space. The default value is 0.
     */
    y: number;
    /**
     * The third element of a Vector3 object, such as the y coordinate of
     * a point in the three-dimensional space. The default value is 0.
     */
    z: number;
    /**
     * The z component of the vector,
     * A three-dimensional position or projection that can be used as a perspective projection
     * We can also do w in the quaternion
     */
    w: number;
    /**
     * @internal
     */
    index: number;
    /**
     * @internal
     */
    private static _index;
    /**
     * Creates an instance of a Vector3 object. If you do not specify a.
     * parameter for the constructor, a Vector3 object is created with
     * the elements (0,0,0,0).
     *
     * @param x The first element, such as the x coordinate.
     * @param y The second element, such as the y coordinate.
     * @param z The third element, such as the z coordinate.
     * @param w An optional element for additional data such as the angle
     *          of rotation.
     */
    constructor(x?: number, y?: number, z?: number, w?: number);
    /**
     *  Set w component
     * @param value
     */
    set a(value: number);
    /**
     *  Set x component
     * @param value
     */
    set r(value: number);
    /**
     *  Set the y component
     * @param value
     */
    set g(value: number);
    /**
     *  Set z component
     * @param value
     */
    set b(value: number);
    /**
     *  get the w component
     * @returns value of w
     */
    get a(): number;
    /**
     *  get the x component
     * @returns value of x
     */
    get r(): number;
    /**
     *  get the y component
     * @returns value of y
     */
    get g(): number;
    /**
     *  get the z component
     * @returns value of z
     */
    get b(): number;
    /**
     * The length of the vector, the distance from the origin (0, 0, 0) to (x, y, z)
     */
    get length(): number;
    /**
     * You get the square of the length of the vector
     * @returns
     */
    get lengthSquared(): number;
    /**
     * Get the current vector
     */
    get position(): this;
    /**
     *  Obtain a vertical line segment with width through an orientation
     * @param dir
     * @param tp1
     * @param tp2
     * @param width
     */
    static getTowPointbyDir(dir: Vector3, tp1: Vector3, tp2: Vector3, width: number, aix: Vector3): void;
    /**
     * Calculate the distance from the point to the line
     * @param point1 Starting point of line segment
     * @param point2 End point of line segment
     * @param position Point position
     * @returns Distance from a point to a line segment
     */
    static pointToLine(point1: Vector3, point2: Vector3, position: Vector3): number;
    /**
     * Take the dot product of two vectors.
     * @param a Vector a
     * @param b Vector b
     * @returns
     */
    static dot(a: Vector3, b: Vector3): number;
    static getPoints(total: number, randSeed: number): any[];
    static getPointNumbers(total: number, randSeed: number): any[];
    /**
     * Returns the Angle, in degrees, between the source vector and the target vector.
     * @param from source vector.
     * @param to target vector.
     * @returns
     */
    static getAngle(from: Vector3, to: Vector3): number;
    static sqrMagnitude(arg0: Vector3): number;
    static getZYAngle(zd: Vector3, yd: Vector3): number;
    /**
     * Subtract two vectors
     * @param a Vector a
     * @param b Vector b
     * @param target output vector
     * @returns
     */
    static sub(a: Vector3, b: Vector3, target?: Vector3): Vector3;
    /**
     * Add two vectors
     * @param a Vector a
     * @param b Vector b
     * @param target output vector
     * @returns
     */
    static add(a: Vector3, b: Vector3, target?: Vector3): Vector3;
    /**
     * @internal
     * @param current
     * @param target
     * @param currentVelocity
     * @param smoothTime
     * @param maxSpeed
     * @param deltaTime
     * @returns
     */
    static smoothDamp(current: Vector3, target: Vector3, currentVelocity: Vector3, smoothTime: number, maxSpeed: number, deltaTime: number): any;
    /**
     * Calculate the distance between two vectors
     * @param pt1 Vector 1
     * @param pt2 Vector 2
     * @returns number The distance between two vectors
     */
    static distance(pt1: Vector3, pt2: Vector3): number;
    /**
     * Calculate the square distance between two vectors
     * @param pt1 Vector 1
     * @param pt2 Vector 2
     * @returns number The square distance between two vectors
     */
    static squareDistance(pt1: Vector3, pt2: Vector3): number;
    /**
     * Calculate the distance between two vectors XZ axes
     * @param pt1 Vector 1
     * @param pt2 Vector 2
     * @returns number The distance between two vectors
     */
    static distanceXZ(pt1: Vector3, pt2: Vector3): number;
    /**
     * Sets the current vector x, y, z, and w components
     * @param x
     * @param y
     * @param z
     * @param w
     * @returns
     */
    set(x: number, y: number, z: number, w?: number): this;
    /**
     * The vector is added to the vector
     * @param a Additive vector
     * @param target Return vector
     * @returns result
    */
    add(a: Vector3, target?: Vector3): Vector3;
    subVectors(a: Vector3, b: Vector3): this;
    distanceToSquared(v: Vector3): number;
    addXYZW(x: number, y: number, z: number, w: number, target?: Vector3): Vector3;
    /**
     * Clone a vector with the same components as the current vector
     */
    clone(): Vector3;
    /**
     * The components of the source vector are set to the current vector
     * @param src Original vector
     * @returns
     */
    copyFrom(src: Vector3): Vector3;
    /**
     * Subtract two vectors and assign the result to yourself
     * @param a Minus vector
     */
    decrementBy(a: Vector3): void;
    /**
     *
     * Calculate the dot product of two vectors and return the Angle relationship between the two vectors
     * @param a The vector that you need to compute
     * @returns number Returns the Angle relationship between two vectors
     */
    dotProduct(a: Vector3): number;
    /**
     *
     * Find whether the values of two vectors are identical
     * @param toCompare The vector to compare
     * @param allFour The default parameter is 1, whether to compare the w component
     * @returns A value of true if the specified Vector3 object is equal to the current Vector3 object; false if it is not equal.
     */
    equals(toCompare: Vector3, allFour?: boolean): boolean;
    /**
     * The current vector plus is equal to the vector, plus just the x, y, and z components
     * @param a vector
     */
    incrementBy(a: Vector3): void;
    /**
     * The current vector divided by the vector or component
     * @param v The vector or component that you want to divide
     * @returns Vector3 Returns the result of the calculation
     */
    divide(v: any): Vector3;
    /**
     * Sets the current Vector3 object to its inverse. The inverse object
     * is also considered the opposite of the original object. The value of
     * the x, y, and z properties of the current Vector3 object is changed
     * to -x, -y, and -z.
     */
    negate(): this;
    /**
     * Scales the line segment between(0,0) and the current point to a set
     * length.
     *
     * @param thickness The scaling value. For example, if the current
     * Vector3 object is (0,3,4), and you normalize it to
     * 1, the point returned is at(0,0.6,0.8).
     */
    normalize(thickness?: number): Vector3;
    /**
     * Apply the rotation quaternion
     * @param q quaternion
     * @returns
     */
    applyQuaternion(q: any): this;
    /**
     * Scales the current Vector3 object by a scalar, a magnitude. The
     * Vector3 object's x, y, and z elements are multiplied by the scalar
     * number specified in the parameter. For example, if the vector is
     * scaled by ten, the result is a vector that is ten times longer. The
     * scalar can also change the direction of the vector. Multiplying the
     * vector by a negative number reverses its direction.
     *
     * @param s A multiplier (scalar) used to scale a Vector3 object.
     */
    scaleBy(s: number): Vector3;
    /**
     * The current vector times the scalar s
     * @param s scalar s
     * @returns
     */
    mul(s: number): Vector3;
    scale(s: Vector3): Vector3;
    scaleToRef(s: number, ref: Vector3): Vector3;
    /**
     * @language en_US
     * Sets the members of Vector3 to the specified values
     *
     * @param xa The first element, such as the x coordinate.
     * @param ya The second element, such as the y coordinate.
     * @param za The third element, such as the z coordinate.
     */
    setTo(xa: number, ya: number, za: number, wa?: number): void;
    /**
     * Copy the components of the source vector to this vector
     * @param src Source vector
     * @returns
     */
    copy(src: Vector3): this;
    /**
     * @language en_US
     * Subtracts the value of the x, y, and z elements of the current
     * Vector3 object from the values of the x, y, and z elements of
     * another Vector3 object. The <code>subtract()</code> method does not
     * change the current Vector3 object. Instead, this method returns a
     * new Vector3 object with the new values.
     *
     * @param a The Vector3 object to be subtracted from the current
     *          Vector3 object.
     * @returns A new Vector3 object that is the difference between the
     *          current Vector3 and the specified Vector3 object.
     */
    subtract(a: Vector3, target?: Vector3): Vector3;
    /**
     * Let's multiply that vector times that vector.
     * @param other Multiplied vectors
     * @param target Returned vector
     * @returns
     */
    multiply(other: Vector3, target?: Vector3): Vector3;
    /**
     * Let's divide this vector by this vector.
     * @param other The vector that divides
     * @param target Returned vector
     * @returns
     */
    divided(other: Vector3, target?: Vector3): Vector3;
    /**
     * Divide that vector by the scalar
     * @param v The scalar that divides
     * @param target Output a Vector3 vector
     * @returns
     */
    div(v: number, target?: Vector3): Vector3;
    /**
    * Computes the linear interpolation between two Vector3, and the result is the current object
    * @param v0 Vector 1
    * @param v1 Vector 2
    * @param t Interpolation factor
    */
    lerp(v0: Vector3, v1: Vector3, t: number): void;
    /**
     * The x, y, and z components of this vector are rounded upward to the nearest integers.
     * @param min minimum value
     * @param max maximum value
     * @returns
     */
    clamp(min: Vector3, max: Vector3): Vector3;
    /**
     * Returns the string form of the current vector
     * @returns
     */
    toString(): string;
    normalizeToWay2D_XY(): void;
    toArray(): number[];
    copyToBytes(byte: DataView): void;
    /**
     * You take the cross product of two vectors,
     * The cross product is going to be the perpendicular vector between these two vectors
     * @param a Take the cross product of another vector
     * @returns Vector3 returns the cross product vector
     */
    crossProduct(a: Vector3, target?: Vector3): Vector3;
    crossVectors(a: Vector3, b: Vector3): this;
    multiplyScalar(scalar: number): this;
    setFromArray(array: number[], firstElementPos?: number): void;
    divideScalar(scalar: any): this;
    clampLength(min: number, max: number): this;
    setScalar(value: number): this;
    private static calAngle;
    static pointInsideTriangle(pt: Vector3, pt0: Vector3, pt1: Vector3, pt2: Vector3): boolean;
    private static pointInsideTriangle2d;
    private static productXY;
    static serialize(position: Vector3): Vector3;
}
