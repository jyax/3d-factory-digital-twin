import { ComponentBase } from '../components/ComponentBase';
import { Matrix4 } from '../math/Matrix4';
import { Ray } from '../math/Ray';
import { Rect } from '../math/Rect';
import { Vector3 } from '../math/Vector3';
import { Frustum } from './bound/Frustum';
import { CameraType } from './CameraType';
import { CubeCamera } from './CubeCamera';
import { FrustumCSM } from './csm/FrustumCSM';
/**
 * Camera components
 * @group Components
 */
export declare class Camera3D extends ComponentBase {
    /**
     * camera Perspective
     */
    fov: number;
    /**
     * camera use name
     */
    name: string;
    /**
     * Viewport width and height Scale
     */
    aspect: number;
    /**
     * camera near plane
     */
    near: number;
    /**
     * camera far plane
     */
    far: number;
    /**
     * camera view port size
     */
    viewPort: Rect;
    /**
     * camera frustum
     */
    frustum: Frustum;
    /**
     * this camera is shadow camera
     */
    isShadowCamera: boolean;
    /**
   * @internal
   */
    private _projectionMatrixInv;
    private _projectionMatrix;
    private _viewMatrix;
    private _unprojection;
    private _pvMatrixInv;
    private _pvMatrix;
    private _halfw;
    private _halfh;
    private _ray;
    private _enableCSM;
    /**
     * @internal
     */
    get projectionMatrix(): Matrix4;
    /**
     * camera look at from where point
     */
    lookTarget: Vector3;
    /**
     * camera type
     */
    type: CameraType;
    csm: FrustumCSM;
    /**
     * @internal
     */
    cubeShadowCameras: CubeCamera[];
    get enableCSM(): boolean;
    set enableCSM(value: boolean);
    constructor();
    init(): void;
    getShadowBias(depthTexSize: number): number;
    getShadowWorldExtents(): number;
    getCSMShadowBias(index: number, depthTexSize: number): number;
    getCSMShadowWorldExtents(index: number): number;
    /**
     * Create a perspective camera
     * @param fov
     * @param aspect
     * @param near
     * @param far
     */
    perspective(fov: number, aspect: number, near: number, far: number): void;
    resetPerspective(aspect: number): void;
    /**
     * Create an orthographic camera
     * @param width screen width
     * @param height screen height
     * @param znear camera near plane
     * @param zfar camera far plane
     */
    ortho(width: number, height: number, znear: number, zfar: number): void;
    /**
     *
     * Create an orthographic camera
     * @param l
     * @param r
     * @param b
     * @param t
     * @param zn camera near plane
     * @param zf camera far plane
     */
    orthoOffCenter(l: number, r: number, b: number, t: number, zn: number, zf: number): void;
    orthoZo(l: number, r: number, b: number, t: number, zn: number, zf: number): void;
    /**
     *
     * view invert matrix
     */
    get viewMatrix(): Matrix4;
    /**
     *
     * shadow camera view invert matrix
     */
    get shadowViewMatrix(): Matrix4;
    /**
     * world space object to screen
     * @param n world space
     * @param target Creating an orthogonal camera with 2D screen coordinates that default to null will return a new object
     */
    object3DToScreenRay(n: Vector3, target?: Vector3): Vector3;
    /**
     * Convert 2D screen coordinates to 3D coordinates as world space
     * @param n 2D screen coordinates
     * @param target 3D coordinates as world space
     */
    screenRayToObject3D(n: Vector3, target?: Vector3): Vector3;
    /**
     * get project * view matrix
     */
    get pvMatrix(): Matrix4;
    get pvMatrix2(): Matrix4;
    /**
     * get (project * view) invert matrix
     */
    get pvMatrixInv(): Matrix4;
    /**
     * get project invert matrix
     */
    get projectionMatrixInv(): Matrix4;
    /**
     * Enter a 3D coordinate point to obtain the projected coordinate point
     * @param nX 3D x
     * @param nY 3D y
     * @param sZ 3D z
     * @param target The projected coordinate point can be empty
     * @returns Coordinates after projection
     */
    unProject(nX: number, nY: number, sZ: number, target?: Vector3): Vector3;
    /**
     * Enter the projected coordinate points to obtain a 3D coordinate point.
     * @param n Coordinate points after photography
     * @param target 3D coordinate points
     * @returns 3D coordinate points
     */
    private project;
    /**
     * Enter the 2D coordinates of the screen to obtain a ray that starts from the camera position and passes through the corresponding 3D position of the screen.
     * @param viewPortPosX Screen x coordinate
     * @param viewPortPosY Screen y coordinate
     * @returns ray
     */
    screenPointToRay(viewPortPosX: number, viewPortPosY: number): Ray;
    /**
     * Convert screen coordinates to world coordinates
     * @param viewPortPosX Screen x coordinate
     * @param viewPortPosY Screen y coordinate
     * @param z Screen z coordinate
     * @returns World coordinates
     */
    screenPointToWorld(viewPortPosX: number, viewPortPosY: number, z: number): Vector3;
    /**
     * Convert world coordinates to screen coordinates
     * @param viewPortPosX Screen x coordinate
     * @param viewPortPosY Screen y coordinate
     * @param z Screen z coordinate
     * @returns World coordinates
     */
    worldToScreenPoint(point: Vector3, target?: Vector3): Vector3;
    /**
     * Current object's gaze position (global) (modified by its own global transformation)
     * @param pos Own position (global)
     * @param target Location of the target (global)
     * @param up Upward direction
     */
    lookAt(pos: Vector3, target: Vector3, up?: Vector3): void;
    /**
     * @internal
     */
    resetProjectMatrix(): void;
    /**
     * @internal
     */
    onUpdate(): void;
    private _haltonSeq;
    private _jitterOffsetList;
    private _useJitterProjection;
    private _jitterFrameIndex;
    private _sampleIndex;
    private _jitterX;
    private _jitterY;
    get jitterFrameIndex(): number;
    get jitterX(): number;
    get jitterY(): number;
    enableJitterProjection(value: boolean): void;
    private generateRandomOffset;
    private getJitteredProjectionMatrix;
    getWorldDirection(target?: Vector3): Vector3;
}
