/// <reference types="@webgpu/types" />
import { Camera3D } from "../../core/Camera3D";
import { GeometryBase } from "../../core/geometry/GeometryBase";
import { ComputeShader } from "../graphics/webGpu/shader/ComputeShader";
import { RenderShaderPass } from "../graphics/webGpu/shader/RenderShaderPass";
import { RendererPassState } from "./passRenderer/state/RendererPassState";
/**
 * WebGPU api use context
 */
export declare class GPUContext {
    static lastGeometry: GeometryBase;
    static lastPipeline: GPURenderPipeline;
    static lastShader: RenderShaderPass;
    static drawCount: number;
    static renderPassCount: number;
    static geometryCount: number;
    static pipelineCount: number;
    static matrixCount: number;
    static lastRenderPassState: RendererPassState;
    static LastCommand: GPUCommandEncoder;
    /**
     * renderPipeline before render need bind pipeline
     * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
     * @param renderShader render pass shader {@link RenderShaderPass }
     * @returns
     */
    static bindPipeline(encoder: GPURenderPassEncoder | GPURenderBundleEncoder, renderShader: RenderShaderPass): void;
    /**
     * render before need make sure use camera
     * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
     * @param camera use camera {@link Camera3D}
     */
    static bindCamera(encoder: GPURenderPassEncoder | GPURenderBundleEncoder, camera: Camera3D): void;
    /**
     * bind geometry vertex buffer to current render pipeline
     * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
     * @param geometry engine geometry
     * @param offset geometry buffer bytes offset
     * @param size geometry buffer bytes length
     */
    static bindGeometryBuffer(encoder: GPURenderPassEncoder | GPURenderBundleEncoder, geometry: GeometryBase): void;
    /**
     * begin or end clean all use cache
     */
    static cleanCache(): void;
    /**
     * create a render pipeline
     * @param gpuRenderPipeline {@link GPURenderPipelineDescriptor}
     * @returns
     */
    static createPipeline(gpuRenderPipeline: GPURenderPipelineDescriptor): GPURenderPipeline;
    /**
     * auto get webgpu commandEncoder and start a command encoder
     * @returns commandEncoder {@link GPUCommandEncoder}
     */
    static beginCommandEncoder(): GPUCommandEncoder;
    /**
     * end CommandEncoder record and submit
     * @param command {@link GPUCommandEncoder}
     */
    static endCommandEncoder(command: GPUCommandEncoder): void;
    /**
     * create a renderBundle gpu object by GPURenderBundleEncoderDescriptor
     * @param des {@link GPURenderBundleEncoderDescriptor}
     * @returns renderBundleEncoder {@link GPURenderBundleEncoder}
     */
    static recordBundleEncoder(des: GPURenderBundleEncoderDescriptor): GPURenderBundleEncoder;
    /**
     * render pass start return current use gpu renderPassEncoder
     * @param command {@link GPUCommandEncoder}
     * @param renderPassState {@link RendererPassState}
     * @returns encoder {@link GPURenderPassEncoder}
     */
    static beginRenderPass(command: GPUCommandEncoder, renderPassState: RendererPassState): GPURenderPassEncoder;
    /**
     * Start the rendering process to draw any pipes
     * @param encoder
     * @param indexCount
     * @param instanceCount
     * @param firstIndex
     * @param baseVertex
     * @param firstInstance
     */
    static drawIndexed(encoder: GPURenderPassEncoder, indexCount: GPUSize32, instanceCount?: GPUSize32, firstIndex?: GPUSize32, baseVertex?: GPUSignedOffset32, firstInstance?: GPUSize32): void;
    static draw(encoder: GPURenderPassEncoder, vertexCount: GPUSize32, instanceCount?: GPUSize32, firstVertex?: GPUSize32, firstInstance?: GPUSize32): void;
    /**
     * The GPU must be informed of the end of encoder recording
     * @param encoder
     */
    static endPass(encoder: GPURenderPassEncoder): void;
    /**
     * Perform the final calculation and submit the Shader to the GPU
     * @param command
     * @param computes
     */
    static computeCommand(command: GPUCommandEncoder, computes: ComputeShader[]): void;
}
