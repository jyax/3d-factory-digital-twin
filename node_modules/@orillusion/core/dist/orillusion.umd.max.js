(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Orillusion = {}));
})(this, (function (exports) { 'use strict';

    class Color {
      /**
       * red color
       */
      static COLOR_RED = new Color(1, 0, 0, 1);
      /**
       * green color
       */
      static COLOR_GREEN = new Color(0, 1, 0, 1);
      /**
       * blue color
       */
      static COLOR_BLUE = new Color(0, 0, 1, 1);
      /**
       * white color
       */
      static COLOR_WHITE = new Color(1, 1, 1, 1);
      /**
       * cache 
       * @internal
       */
      static COLOR_0 = new Color();
      /**
       * cache 
       * @internal
       */
      static COLOR_1 = new Color();
      /**
       * cache 
       * @internal
       */
      static COLOR_2 = new Color();
      /**
       * @internal
       */
      static HEX_CHARACTERS = "a-f\\d";
      /**
       * @internal
       */
      static MATCH_3OR4_HEX = `#?[${Color.HEX_CHARACTERS}]{3}[${Color.HEX_CHARACTERS}]?`;
      /**
       * @internal
       */
      static MATCH_6OR8_HEX = `#?[${Color.HEX_CHARACTERS}]{6}([${Color.HEX_CHARACTERS}]{2})?`;
      /**
       * @internal
       */
      static NON_HEX_CHARS = new RegExp(`[^#${Color.HEX_CHARACTERS}]`, "gi");
      /**
       * @internal
       */
      static VALID_HEX_SIZE = new RegExp(`^${Color.MATCH_3OR4_HEX}$|^${Color.MATCH_6OR8_HEX}$`, "i");
      /**
       * red channel
       */
      r = 0;
      /**
       * green channel
       */
      g = 0;
      /**
       * blue channel
       */
      b = 0;
      /**
       * alpha channel
       */
      a = 0;
      /**
       * create new color instance
       * @param r red channel
       * @param g green channel
       * @param b blue channel
       * @param a alpha channel
       */
      constructor(r = 1, g = 1, b = 1, a = 1) {
        this.setTo(r, g, b, a);
      }
      /***
       * convert to hdr color , channel a is intensity 
       */
      convertToHDRRGB() {
        this.r = this.r * Math.pow(2.4, this.a);
        this.g = this.g * Math.pow(2.4, this.a);
        this.b = this.b * Math.pow(2.4, this.a);
        return this;
      }
      /**
       * unSerialized color by data
       * @param data 
       * @returns 
       */
      unSerialized(data) {
        this.r = data["r"];
        this.g = data["g"];
        this.b = data["b"];
        this.a = data["a"];
        return this;
      }
      /**
       * update this color rgb from hexadecimal no alpha
       * @param value 
       */
      hexToRGB(value) {
        this.r = (value >> 16 & 255) / 255;
        this.g = (value >> 8 & 255) / 255;
        this.b = (value & 255) / 255;
        return this;
      }
      /**
       * update this color rgb from hexadecimal has alpha
       * @param value 
       */
      hexToRGBA(value) {
        this.a = (value >> 24 & 255) / 255;
        this.r = (value >> 16 & 255) / 255;
        this.g = (value >> 8 & 255) / 255;
        this.b = (value & 255) / 255;
        return this;
      }
      /**
       * random on color 
       * @returns 
       */
      static random(base = 1) {
        let color = new Color();
        color.a = base;
        color.r = base * Math.random();
        color.g = base * Math.random();
        color.b = base * Math.random();
        return color;
      }
      static randomRGB(seedR = 0.5, seedG = 0.5, seedB = 0.5, baseR = 0.5, baseG = 0.5, baseB = 0.5) {
        let color = new Color();
        color.a = 1;
        color.r = baseR + seedR * Math.random();
        color.g = baseG + seedG * Math.random();
        color.b = baseB + seedB * Math.random();
        return color;
      }
      /**
       * random on color 
       * @returns 
       */
      static randomGray(base = 0.5, random = 0.5) {
        let seed = Math.random() * random + base;
        let color = new Color();
        color.a = 1;
        color.r = seed;
        color.g = seed;
        color.b = seed;
        return color;
      }
      /**
       * set rgba to this color
       * @param r red channel
       * @param g green channel
       * @param b blue channel
       * @param a alpha channel
       */
      setTo(r, g, b, a) {
        this.r = Math.max(r, 0);
        this.g = Math.max(g, 0);
        this.b = Math.max(b, 0);
        this.a = Math.max(a, 0);
      }
      /**
       * update this color rgba from hexadecimal 
       * @param hex hex string.
       */
      setHex(hex) {
        if (typeof hex !== "string" || Color.NON_HEX_CHARS.test(hex) || !Color.VALID_HEX_SIZE.test(hex)) {
          throw new TypeError("Expected a valid hex string");
        }
        hex = hex.replace(/^#/, "");
        let alphaFromHex = 1;
        if (hex.length === 8) {
          alphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;
          hex = hex.slice(0, 6);
        }
        if (hex.length === 4) {
          alphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
          hex = hex.slice(0, 3);
        }
        if (hex.length === 3) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        const number = Number.parseInt(hex, 16);
        const red = number >> 16;
        const green = number >> 8 & 255;
        const blue = number & 255;
        const alpha = alphaFromHex;
        this.a = alpha;
        this.r = red / 255;
        this.g = green / 255;
        this.b = blue / 255;
      }
      /**
       * convert this color to hex string code 
       * @returns 
       */
      getHex() {
        let getHexStr = (n) => {
          n *= 255;
          let str = n.toString(16);
          if (str.length === 1) {
            str = "0" + str;
          }
          return str;
        };
        let hex = getHexStr(this.r) + getHexStr(this.g) + getHexStr(this.b) + getHexStr(this.a);
        return hex;
      }
      /**
       * get rgb to array
       */
      get rgb() {
        return [this.r * 255 >>> 0, this.g * 255 >>> 0, this.b * 255 >>> 0];
      }
      /**
       * set rgb by array
       */
      set rgb(c) {
        this.setTo(c[0] / 255, c[1] / 255, c[2] / 255, this.a);
      }
      /**
       * get rgba to array
       */
      get rgba() {
        return [this.r * 255 >>> 0, this.g * 255 >>> 0, this.b * 255 >>> 0, this.a * 255 >>> 0];
      }
      /**
       * set rgb by array
       */
      set rgba(c) {
        this.setTo(c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 255);
      }
      /**
       * clone this color
       * @returns 
       */
      clone() {
        return new Color().copyFrom(this);
      }
      /**
       * copy color from source color
       * @returns
       */
      copyFrom(src) {
        this.r = src.r;
        this.g = src.g;
        this.b = src.b;
        this.a = src.a;
        return this;
      }
      /**
       * copy color from array
       * @param arr [ 255 , 255 , 255 , 255 ]
       * @param scalar 
       * @returns 
       */
      copyFromArray(arr, scalar = 255) {
        this.r = arr[0] / scalar;
        this.g = arr[1] / scalar;
        this.b = arr[2] / scalar;
        this.a = arr[3] / scalar;
        return this;
      }
      /**
       * copy color from vector3 or vector4
       * @param value { x: number, y: number, z: number, w?: number }
       * @returns 
       */
      copyFromVector(value) {
        this.r = value.x;
        this.g = value.y;
        this.b = value.z;
        this.a = value.w;
        return this;
      }
      /**
       * update this color rgb from hexadecimal no alpha
       * @param hexColor rgb color
       * @param dst ref out color
       */
      static hexRGBColor(hexColor, dst = null) {
        dst = dst || new Color();
        dst.hexToRGB(hexColor);
        return dst;
      }
      /**
       * lerp two color 
       * @param v 
       * @param c1 
       * @param c2 
       * @param target 
       * @returns 
       */
      static lerp(v, c1, c2, target) {
        let ret = target ? target : new Color();
        ret.r = (c2.r - c1.r) * v + c1.r;
        ret.g = (c2.g - c1.g) * v + c1.g;
        ret.b = (c2.b - c1.b) * v + c1.b;
        ret.a = (c2.a - c1.a) * v + c1.a;
        return target;
      }
      static PRIMARY = 4149685;
      //
      static PRIMARYDARK = 3162015;
      //
      static ACCENT = 16728193;
      //
      static WHITE = 16777215;
      static IVORY = 16777200;
      static LIGHTYELLOW = 16777184;
      static YELLOW = 16776960;
      static SNOW = 16775930;
      static FLORALWHITE = 16775920;
      static LEMONCHIFFON = 16775885;
      static CORNSILK = 16775388;
      static SEASHELL = 16774638;
      static LAVENDERBLUSH = 16773365;
      static PAPAYAWHIP = 16773077;
      static BLANCHEDALMOND = 16772045;
      static MISTYROSE = 16770273;
      static BISQUE = 16770244;
      static MOCCASIN = 16770229;
      static NAVAJOWHITE = 16768685;
      static PEACHPUFF = 16767673;
      static GOLD = 16766720;
      static PINK = 16761035;
      static LIGHTPINK = 16758465;
      static ORANGE = 16753920;
      static LIGHTSALMON = 16752762;
      static DARKORANGE = 16747520;
      static CORAL = 16744272;
      static HOTPINK = 16738740;
      static TOMATO = 16737095;
      static ORANGERED = 16729344;
      static DEEPPINK = 16716947;
      static FUCHSIA = 16711935;
      static MAGENTA = 16711935;
      static RED = 16711680;
      static OLDLACE = 16643558;
      static LIGHTGOLDENRODYELLOW = 16448210;
      static LINEN = 16445670;
      static ANTIQUEWHITE = 16444375;
      static SALMON = 16416882;
      static GHOSTWHITE = 16316671;
      static MINTCREAM = 16121850;
      static WHITESMOKE = 16119285;
      static BEIGE = 16119260;
      static WHEAT = 16113331;
      static SANDYBROWN = 16032864;
      static AZURE = 15794175;
      static HONEYDEW = 15794160;
      static ALICEBLUE = 15792383;
      static KHAKI = 15787660;
      static LIGHTCORAL = 15761536;
      static PALEGOLDENROD = 15657130;
      static VIOLET = 15631086;
      static DARKSALMON = 15308410;
      static LAVENDER = 15132410;
      static LIGHTCYAN = 14745599;
      static BURLYWOOD = 14596231;
      static PLUM = 14524637;
      static GAINSBORO = 14474460;
      static CRIMSON = 14423100;
      static PALEVIOLETRED = 14381203;
      static GOLDENROD = 14329120;
      static ORCHID = 14315734;
      static THISTLE = 14204888;
      static LIGHTGREY = 13882323;
      static TAN = 13808780;
      static CHOCOLATE = 13789470;
      static PERU = 13468991;
      static INDIANRED = 13458524;
      static MEDIUMVIOLETRED = 13047173;
      static SILVER = 12632256;
      static DARKKHAKI = 12433259;
      static ROSYBROWN = 12357519;
      static MEDIUMORCHID = 12211667;
      static DARKGOLDENROD = 12092939;
      static FIREBRICK = 11674146;
      static POWDERBLUE = 11591910;
      static LIGHTSTEELBLUE = 11584734;
      static PALETURQUOISE = 11529966;
      static GREENYELLOW = 11403055;
      static LIGHTBLUE = 11393254;
      static DARKGRAY = 11119017;
      static BROWN = 10824234;
      static SIENNA = 10506797;
      static DARKORCHID = 10040012;
      static PALEGREEN = 10025880;
      static DARKVIOLET = 9699539;
      static MEDIUMPURPLE = 9662683;
      static LIGHTGREEN = 9498256;
      static DARKSEAGREEN = 9419919;
      static SADDLEBROWN = 9127187;
      static DARKMAGENTA = 9109643;
      static DARKRED = 9109504;
      static BLUEVIOLET = 9055202;
      static LIGHTSKYBLUE = 8900346;
      static SKYBLUE = 8900331;
      static GRAY = 8421504;
      static OLIVE = 8421376;
      static PURPLE = 8388736;
      static MAROON = 8388608;
      static AQUAMARINE = 8388564;
      static CHARTREUSE = 8388352;
      static LAWNGREEN = 8190976;
      static MEDIUMSLATEBLUE = 8087790;
      static LIGHTSLATEGRAY = 7833753;
      static SLATEGRAY = 7372944;
      static OLIVEDRAB = 7048739;
      static SLATEBLUE = 6970061;
      static DIMGRAY = 6908265;
      static MEDIUMAQUAMARINE = 6737322;
      static CORNFLOWERBLUE = 6591981;
      static CADETBLUE = 6266528;
      static DARKOLIVEGREEN = 5597999;
      static INDIGO = 4915330;
      static MEDIUMTURQUOISE = 4772300;
      static DARKSLATEBLUE = 4734347;
      static STEELBLUE = 4620980;
      static ROYALBLUE = 4286945;
      static TURQUOISE = 4251856;
      static MEDIUMSEAGREEN = 3978097;
      static LIMEGREEN = 3329330;
      static DARKSLATEGRAY = 3100495;
      static SEAGREEN = 3050327;
      static FORESTGREEN = 2263842;
      static LIGHTSEAGREEN = 2142890;
      static DODGERBLUE = 2003199;
      static MIDNIGHTBLUE = 1644912;
      static AQUA = 65535;
      static CYAN = 65535;
      static SPRINGGREEN = 65407;
      static LIME = 65280;
      static MEDIUMSPRINGGREEN = 64154;
      static DARKTURQUOISE = 52945;
      static DEEPSKYBLUE = 49151;
      static DARKCYAN = 35723;
      static TEAL = 32896;
      static GREEN = 32768;
      static DARKGREEN = 25600;
      static BLUE = 255;
      static MEDIUMBLUE = 205;
      static DARKBLUE = 139;
      static NAVY = 128;
      static BLACK = 0;
    }

    class Time {
      /**
       * The time the engine has been running
       */
      static time = 0;
      /**
       * the frame count engine is running
       */
      static frame = 0;
      /**
       * Time from previous frame to present
       */
      static delta = 0;
      static _startTime = 0;
      static _timeLabel = ``;
      /**
       * @internal
       * @param label
       */
      static start(label) {
        this._startTime = performance.now();
        this._timeLabel = label;
      }
      /**
       * @internal
       */
      static end() {
        console.log(this._timeLabel, performance.now() - this._startTime);
      }
    }

    class CEvent {
      /**
       * Event target, it's usually event dispatcher
       */
      target;
      /**
       * Current event target, it's current bubble object
       */
      currentTarget;
      /**
       * event type, it's registered string of key
       */
      type;
      /**
       * extra data.Used for the transmission process of events, carrying data
       */
      data;
      /**
       *
       * The param data when event is registered
       */
      param;
      /**
       *
       * the time when event is
       */
      time = 0;
      /**
       *
       *the delay time when event is dispatched.
       */
      delay = 0;
      /**
       *
       * mouse code, see @MouseCode {@link MouseCode}
       */
      mouseCode = 0;
      /**
       * Is Ctrl key pressed when the event occurs
       */
      ctrlKey;
      /**
       * Is Alt key pressed when the event occurs
       */
      altKey;
      /**
       * Is Shift key pressed when the event occurs
       */
      shiftKey;
      /**
       * Collection of finger touch points, which registered
       */
      targetTouches;
      /**
       * Collection of finger touch points changed
       */
      changedTouches;
      /**
       * Collection of finger touch points
       */
      touches;
      _stopImmediatePropagation = false;
      /**
       * binded view3D object in event.
       */
      view;
      /**
       *
       * Create a new event, with type and data
       * @param eventType {any} eventType
       * @param data {any} param
       */
      constructor(eventType = null, data = null) {
        this.type = eventType;
        this.data = data;
      }
      /**
       *
       * Prevent bubbling of all event listeners in subsequent nodes of the current node in the event flow.
       */
      stopImmediatePropagation() {
        this._stopImmediatePropagation = true;
      }
      /**
       * @internal
       * set stopImmediatePropagation as false
       */
      reset() {
        this._stopImmediatePropagation = false;
      }
      /**
       * Returns stopImmediatePropagation value
       */
      get isStopImmediatePropagation() {
        return this._stopImmediatePropagation;
      }
    }

    class CEventListener {
      /**
       *
       * @param type {string} event type
       * @param thisObject {any} the object is registerd
       * @param handler {Function} The callback function that handles events. 
       * @param param {any} Parameters bound when registering events
       * @param priority {number} The priority of callback function execution, with a larger set value having priority to call
       */
      constructor(type = null, thisObject = null, handler = null, param = null, priority = 0) {
        this.type = type;
        this.thisObject = thisObject;
        this.handler = handler;
        this.param = param;
        this.priority = priority;
      }
      /**
       * @private
       */
      static event_id_count = 0;
      /**
       *
       * Record a id. When registering a listening event, the value will increase automatically
       */
      id = 0;
      /**
       *
       * Returns current event dispatcher
       */
      current;
      /**
       *
       * Compare whether two events are the same
       * @param type {string} event type
       * @param handler {Function} The callback function that handles events. 
       * @param thisObject {any} the object is registerd
       * @param param {any} Parameters bound when registering events
       * @returns {boolean} Returns a boolean
       */
      equalCurrentListener(type, handler, thisObject, param) {
        if (this.type == type && this.thisObject == thisObject && this.handler == handler && this.param == param) {
          return true;
        }
        return false;
      }
      /**
       *
       * release all registered event.
       */
      dispose() {
        this.handler = null;
        this.thisObject = null;
        this.param = null;
        this.priority = 0;
      }
    }

    class CEventDispatcher {
      /**
       * @internal
       */
      listeners = {};
      /**
       * @internal
       */
      data;
      /**
       *
       * Dispatch an event to all registered objects with a specific type of listener.
       * @param event3D the event is dispatched.
       */
      dispatchEvent(event) {
        var list = this.listeners[event.type];
        if (list != null) {
          list = list.slice();
          for (var i = 0; i < list.length; i++) {
            var listener = list[i];
            if (listener.handler) {
              try {
                event.param = listener.param;
                event.currentTarget = listener;
                if (!listener.thisObject) {
                }
                listener.handler.call(listener.thisObject, event);
              } catch (error) {
              }
              if (event.isStopImmediatePropagation) {
                break;
              }
            }
          }
        }
      }
      /**
       *
       * release all registered event.
       */
      destroy() {
        for (var key in this.listeners) {
          var list = this.listeners[key];
          while (list.length > 0) {
            var listener = list[0];
            listener.handler = null;
            listener.thisObject = null;
            list.splice(0, 1);
          }
        }
      }
      /**
       *
       * register an event listener to event distancher.
       * @param type {string} event type.
       * @param callback {Function} The callback function that handles events. 
       * This function must accept an Event3D object as its unique parameter and cannot return any result.
       * for example: function(evt:Event3D):void.
       * @param thisObject {any} Current registration object, it'll call callback function.
       * @param param {any} the data binded to registered event, the default value is null.
       * @param priority {number} The priority of callback function execution, with a larger set value having priority to call
       * @returns {number} Returns register event id
       */
      addEventListener(type, callback, thisObject, param = null, priority = 0) {
        if (this.listeners[type] == null) {
          this.listeners[type] = [];
        }
        if (!this.hasEventListener(type, callback, thisObject)) {
          var listener = new CEventListener(type, thisObject, callback, param, priority);
          listener.id = ++CEventListener.event_id_count;
          listener.current = this;
          this.listeners[type].push(listener);
          this.listeners[type].sort(function(listener1, listener2) {
            return listener2.priority - listener1.priority;
          });
          return listener.id;
        }
        for (let i = 0; i < this.listeners[type].length; i++) {
          let listener2 = this.listeners[type][i];
          if (listener2.equalCurrentListener(type, callback, thisObject, param)) {
            return listener2.id;
          }
        }
        return 0;
      }
      /**
       *
       * Remove Event Listening
       * @param type {string} event type
       * @param callback {Function} callback function of event register
       * @param thisObject {any} The current registered object.
       */
      removeEventListener(type, callback, thisObject) {
        if (this.hasEventListener(type, callback, thisObject)) {
          for (var i = 0; i < this.listeners[type].length; i++) {
            var listener = this.listeners[type][i];
            if (listener.equalCurrentListener(type, callback, thisObject, listener.param)) {
              listener.handler = null;
              listener.thisObject = null;
              this.listeners[type].splice(i, 1);
              return;
            }
          }
        }
      }
      /**
       *
       * Remove an event Listening with id
       * @param register event id, see {@link addEventListener}
       * Returns true when removed success.
       */
      removeEventListenerAt(id) {
        for (var key in this.listeners) {
          for (var i = 0; i < this.listeners[key].length; i++) {
            var listener = this.listeners[key][i];
            if (listener.id == id) {
              listener.handler = null;
              listener.thisObject = null;
              this.listeners[key].splice(i, 1);
              return true;
            }
          }
        }
        return false;
      }
      /**
       *
       * Specify a event type to remove all related event listeners
       * eventType event type, set null to remove all event listeners
       */
      removeAllEventListener(eventType = null) {
        let listener;
        if (eventType) {
          if (this.listeners[eventType]) {
            for (var i = 0; i < this.listeners[eventType].length; i++) {
              listener = this.listeners[eventType][i];
              listener.dispose();
              this.listeners[eventType].splice(i, 1);
            }
            delete this.listeners[eventType];
          }
        } else {
          for (let key in this.listeners) {
            for (var i = 0; i < this.listeners[key].length; i++) {
              listener = this.listeners[key][i];
              listener.dispose();
              this.listeners[key].splice(i, 1);
            }
            delete this.listeners[key];
          }
        }
      }
      /**
       *
       * whether the target presence of a listener with event type.
       * @param type {string} event type.
       * @returns {boolean} Returns a boolean.
       */
      containEventListener(type) {
        if (this.listeners[type] == null)
          return false;
        return this.listeners[type].length > 0;
      }
      /**
       *
       * whether the target presence of a listener with event type. it associate more registration parameters.
       * @param type {string} event name.
       * @param callback {Function} callback function of event register.
       * @param thisObject {any} The registered object.
       * @returns {boolean} Returns a boolean.
       */
      hasEventListener(type, callback = null, thisObject = null) {
        if (this.listeners[type] == null)
          return false;
        if (thisObject && callback) {
          for (var i = 0; i < this.listeners[type].length; i++) {
            var listener = this.listeners[type][i];
            if (listener.equalCurrentListener(type, callback, thisObject, listener.param)) {
              return true;
            }
          }
        }
        return false;
      }
    }

    class KeyEvent extends CEvent {
      /**
       *
       * Constant Definition Key Press Event Identification
       * Event response status: Responds every time the keyboard is pressed.
       * Response event parameters: keyboard key
       * @platform Web,Native
       */
      static KEY_DOWN = "onKeyDown";
      /**
       *
       * Constant Definition Key up Event Identification
       * Event response status: Responds every time the keyboard is released.
       * Response event parameters: keyboard key
       * @platform Web,Native
       */
      static KEY_UP = "onKeyUp";
      /**
       *
       * Key code value, enumeration type see KeyCode {@link KeyCode}
       * @default 0
       * @platform Web,Native
       */
      keyCode = 0;
    }

    class PointerEvent3D extends CEvent {
      /**
       * Triggered when the touch point enters the collision
       */
      static PICK_OVER = "onPickOver";
      /**
       * Triggered when the touch point enters the interactive GUI
       */
      static PICK_OVER_GUI = "onPickOverGUI";
      /**
       * Triggered when the touch point clicked the collision
       */
      static PICK_CLICK = "onPickClick";
      /**
      * Triggered when the touch point clicked the interactive GUI
      */
      static PICK_CLICK_GUI = "onPickClickGUI";
      /**
      * Triggered when the touch point leave the collision
      */
      static PICK_OUT = "onPickOut";
      /**
       * Triggered when the touch point leave the interactive GUI
       */
      static PICK_OUT_GUI = "onPickOutGUI";
      /**
      * Triggered when the touch point move on the collision
      */
      static PICK_MOVE = "onPickMove";
      /**
       * Triggered when the touch point release from the collision
       */
      static PICK_UP = "onPickUp";
      /**
       * Triggered when the touch point release from the interactive GUI
       */
      static PICK_UP_GUI = "onPickUpGUI";
      /**
       * Triggered when the touch point pressed the collision
       */
      static PICK_DOWN = "onPickDown";
      /**
       * Triggered when the touch point pressed the interactive GUI
       */
      static PICK_DOWN_GUI = "onPickDownGUI";
      /**
       *
       * Triggered when the right pointer clicked
       */
      static POINTER_RIGHT_CLICK = "onPointerRightClick";
      /**
       *
       * Triggered when the middle pointer released
       */
      static POINTER_MID_UP = "onPointerMidUp";
      /**
       *
       * Triggered when the middle pointer pressed
       */
      static POINTER_MID_DOWN = "onPointerMidDown";
      /**
       * Triggered when the pointer clicked  
       */
      static POINTER_CLICK = "onPointerClick";
      /**
       *
       * Triggered when the pointer moved  
       */
      static POINTER_MOVE = "onPointerMove";
      /**
       *
       * Triggered when the pointer pressed  
       */
      static POINTER_DOWN = "onPointerDown";
      /**
       *
       * Triggered when the pointer released  
       */
      static POINTER_UP = "onPointerUp";
      /**
       *
       * Triggered when the pointer move out  
       */
      static POINTER_OUT = "onPointerOut";
      /**
       *
       * Triggered when the pointer move over  
       */
      static POINTER_OVER = "onPointerOver";
      /**
       *
       * Triggered when the wheel pointer is used
       */
      static POINTER_WHEEL = "onPointerWheel";
      /**
       * A unique identifier for an event caused by a pointer.
       */
      pointerId;
      /**
       * event type
       */
      pointerType;
      /**
       * whether it's the preferred pointer in this type of pointer.
       */
      isPrimary;
      /**
       * Normalize values
       */
      pressure;
      /**
       * coord x of mouse
       */
      mouseX;
      /**
       * coord y of mouse
       */
      mouseY;
      /**
       * delta of coord x of mouse
       */
      movementX;
      /**
       * delta of coord y of mouse
       */
      movementY;
      /**
       * Returns a negative value when scrolling left, 
       * a positive value when scrolling right, otherwise 0.
       */
      deltaX;
      /**
       * Returns a positive value when scrolling down,
       *  a negative value when scrolling up, otherwise 0.
       */
      deltaY;
      /**
       * @internal
       */
      deltaZ;
      /**
       * @internal
       */
      reset() {
        super.reset();
        this.mouseX = 0;
        this.mouseY = 0;
        this.movementX = 0;
        this.movementY = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.deltaZ = 0;
      }
    }

    class Vector3 {
      /**
       * Vector maximum
       */
      static MAX = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      /**
       * Vector minimum
       */
      static MIN = new Vector3(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      /**
       * Vector maximum integer value
       */
      static SAFE_MAX = new Vector3(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
      /**
       * Vector minimum integer value
       */
      static SAFE_MIN = new Vector3(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
      /**
       * X axis positive axis coordinate (1, 0, 0).
       */
      static X_AXIS = new Vector3(1, 0, 0);
      /**
       * The X-axis is negative (-1, 0, 0).
       */
      static neg_X_AXIS = new Vector3(-1, 0, 0);
      /**
       * The y axis defined as a Vector3 object with coordinates (0,1,0).
       */
      static Y_AXIS = new Vector3(0, 1, 0);
      /**
       * The z axis defined as a Vector3 object with coordinates (0,0,1).
       */
      static Z_AXIS = new Vector3(0, 0, 1);
      /**
       * @internal
       */
      static HELP_0 = new Vector3();
      /**
       * @internal
       */
      static HELP_1 = new Vector3();
      /**
       * @internal
       */
      static HELP_2 = new Vector3();
      /**
       * @internal
       */
      static EPSILON = 1e-5;
      /**
       * @internal
       */
      static HELP_3 = new Vector3();
      /**
       * @internal
       */
      static HELP_4 = new Vector3();
      /**
       * @internal
       */
      static HELP_5 = new Vector3();
      /**
       * @internal
       */
      static HELP_6 = new Vector3();
      /**
       * Returns a new vector with zero x, y, and z components
       */
      static get ZERO() {
        return new Vector3(0, 0, 0);
      }
      /**
       * Returns a new vector whose x, y, and z components are all 1
       */
      static get ONE() {
        return new Vector3(1, 1, 1);
      }
      /**
       * Returns a new vector pointing to the left, x is -1, y is 0, and z is 0
       */
      static get LEFT() {
        return new Vector3(-1, 0, 0);
      }
      /**
       * Returns a new vector pointing in the right direction, where x is 1, y is 0, and z is 0
       */
      static get RIGHT() {
        return new Vector3(1, 0, 0);
      }
      /**
       * Returns a new vector pointing upwards, that is, x equals 0, y equals 1, and z equals 0
       */
      static get UP() {
        return new Vector3(0, 1, 0);
      }
      /**
       * Returns a new vector pointing down, where x is 0, y is -1, and z is 0
       */
      static get DOWN() {
        return new Vector3(0, -1, 0);
      }
      /** 
       * Returns a new backward vector, x equals 0, y equals 0, and z equals negative 1
       */
      static get BACK() {
        return new Vector3(0, 0, -1);
      }
      /**
       * Returns a new forward-pointing vector, that is, x is 0, y is 0, and z is 1
       */
      static get FORWARD() {
        return new Vector3(0, 0, 1);
      }
      /**
       * The first element of a Vector3 object, such as the x coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      x = 0;
      /**
       * The second element of a Vector3 object, such as the y coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      y = 0;
      /**
       * The third element of a Vector3 object, such as the y coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      z = 0;
      /**
       * The z component of the vector,
       * A three-dimensional position or projection that can be used as a perspective projection
       * We can also do w in the quaternion
       */
      w = 1;
      /**
       * @internal
       */
      index = 0;
      /**
       * @internal
       */
      static _index = 0;
      /**
       * Creates an instance of a Vector3 object. If you do not specify a.
       * parameter for the constructor, a Vector3 object is created with
       * the elements (0,0,0,0).
       *
       * @param x The first element, such as the x coordinate.
       * @param y The second element, such as the y coordinate.
       * @param z The third element, such as the z coordinate.
       * @param w An optional element for additional data such as the angle
       *          of rotation.
       */
      constructor(x = 0, y = 0, z = 0, w = 0) {
        this.set(x, y, z, w);
        this.index = Vector3._index++;
      }
      /**
       *  Set w component
       * @param value
       */
      set a(value) {
        this.w = value;
      }
      /**
       *  Set x component
       * @param value 
       */
      set r(value) {
        this.x = value;
      }
      /**
       *  Set the y component
       * @param value 
       */
      set g(value) {
        this.y = value;
      }
      /**
       *  Set z component
       * @param value 
       */
      set b(value) {
        this.z = value;
      }
      /**
       *  get the w component
       * @returns value of w
       */
      get a() {
        return this.w;
      }
      /**
       *  get the x component
       * @returns value of x
       */
      get r() {
        return this.x;
      }
      /**
       *  get the y component
       * @returns value of y
       */
      get g() {
        return this.y;
      }
      /**
       *  get the z component
       * @returns value of z
       */
      get b() {
        return this.z;
      }
      /**
       * The length of the vector, the distance from the origin (0, 0, 0) to (x, y, z)
       */
      get length() {
        return Math.sqrt(this.lengthSquared);
      }
      /**
       * You get the square of the length of the vector
       * @returns 
       */
      get lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      /**
       * Get the current vector
       */
      get position() {
        return this;
      }
      /**
       *  Obtain a vertical line segment with width through an orientation
       * @param dir
       * @param tp1
       * @param tp2
       * @param width
       */
      static getTowPointbyDir(dir, tp1, tp2, width, aix) {
        if (aix == Vector3.Z_AXIS) {
          tp1.x = dir.y;
          tp1.y = -dir.x;
          tp2.x = -dir.y;
          tp2.y = dir.x;
          tp1.scaleBy(width * 0.5);
          tp2.scaleBy(width * 0.5);
        } else if (aix == Vector3.Y_AXIS) {
          tp1.x = dir.z;
          tp1.z = -dir.x;
          tp2.x = -dir.z;
          tp2.z = dir.x;
          tp1.scaleBy(width * 0.5);
          tp2.scaleBy(width * 0.5);
        }
      }
      /**
       * Calculate the distance from the point to the line
       * @param point1 Starting point of line segment
       * @param point2 End point of line segment
       * @param position Point position
       * @returns Distance from a point to a line segment
       */
      static pointToLine(point1, point2, position) {
        let space = 0;
        let a, b, c;
        a = Vector3.distance(point1, point2);
        b = Vector3.distance(point1, position);
        c = Vector3.distance(point2, position);
        if (c <= 1e-6 || b <= 1e-6) {
          space = 0;
          return space;
        }
        if (a <= 1e-6) {
          space = b;
          return space;
        }
        if (c * c >= a * a + b * b) {
          space = b;
          return space;
        }
        if (b * b >= a * a + c * c) {
          space = c;
          return space;
        }
        let p = (a + b + c) / 2;
        let s = Math.sqrt(p * (p - a) * (p - b) * (p - c));
        space = 2 * s / a;
        return space;
      }
      /**
       * Take the dot product of two vectors.
       * @param a Vector a
       * @param b Vector b
       * @returns 
       */
      static dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      }
      static getPoints(total, randSeed) {
        let points = [];
        for (let index = 0; index < total; index++) {
          const element = new Vector3(Math.random() * randSeed - randSeed * 0.5, Math.random() * randSeed - randSeed * 0.5, Math.random() * randSeed - randSeed * 0.5);
          points.push(element);
        }
        return points;
      }
      static getPointNumbers(total, randSeed) {
        let points = [];
        for (let index = 0; index < total; index++) {
          points.push(Math.random() * randSeed - randSeed * 0.5, Math.random() * randSeed - randSeed * 0.5, Math.random() * randSeed - randSeed * 0.5);
        }
        return points;
      }
      /**
       * Returns the Angle, in degrees, between the source vector and the target vector.
       * @param from source vector.
       * @param to target vector.
       * @returns 
       */
      static getAngle(from, to) {
        let t = from.dotProduct(to) / (from.length * to.length);
        return Math.acos(t) * 180 / Math.PI;
      }
      static sqrMagnitude(arg0) {
        return arg0.x * arg0.x + arg0.y * arg0.y + arg0.z * arg0.z;
      }
      static getZYAngle(zd, yd) {
        return this.calAngle(zd.y, zd.z, yd.y, yd.z);
      }
      /**
       * Subtract two vectors
       * @param a Vector a
       * @param b Vector b
       * @param target output vector
       * @returns 
       */
      static sub(a, b, target = null) {
        target = target || new Vector3();
        target.x = a.x - b.x;
        target.y = a.y - b.y;
        target.z = a.z - b.z;
        return target;
      }
      /**
       * Add two vectors
       * @param a Vector a
       * @param b Vector b
       * @param target output vector
       * @returns 
       */
      static add(a, b, target = null) {
        target = target || new Vector3();
        target.x = a.x + b.x;
        target.y = a.y + b.y;
        target.z = a.z + b.z;
        return target;
      }
      /**
       * @internal
       * @param current 
       * @param target 
       * @param currentVelocity 
       * @param smoothTime 
       * @param maxSpeed 
       * @param deltaTime 
       * @returns 
       */
      static smoothDamp(current, target, currentVelocity, smoothTime, maxSpeed, deltaTime) {
        return null;
      }
      /**
       * Calculate the distance between two vectors
       * @param pt1 Vector 1
       * @param pt2 Vector 2
       * @returns number The distance between two vectors
       */
      static distance(pt1, pt2) {
        var x = pt1.x - pt2.x;
        var y = pt1.y - pt2.y;
        var z = pt1.z - pt2.z;
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Calculate the square distance between two vectors
       * @param pt1 Vector 1
       * @param pt2 Vector 2
       * @returns number The square distance between two vectors
       */
      static squareDistance(pt1, pt2) {
        var x = pt1.x - pt2.x;
        var y = pt1.y - pt2.y;
        var z = pt1.z - pt2.z;
        return x * x + y * y + z * z;
      }
      /**
       * Calculate the distance between two vectors XZ axes
       * @param pt1 Vector 1
       * @param pt2 Vector 2
       * @returns number The distance between two vectors
       */
      static distanceXZ(pt1, pt2) {
        var x = pt1.x - pt2.x;
        var y = 0;
        var z = pt1.z - pt2.z;
        return Math.sqrt(x * x + y * y + z * z);
      }
      /**
       * Sets the current vector x, y, z, and w components
       * @param x 
       * @param y 
       * @param z 
       * @param w 
       * @returns 
       */
      set(x, y, z, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
      /**
       * The vector is added to the vector
       * @param a Additive vector
       * @param target Return vector
       * @returns result
      */
      add(a, target = null) {
        target ||= new Vector3();
        var a0x = this.x;
        var a0y = this.y;
        var a0z = this.z;
        var a0w = this.w;
        var a1x = a.x;
        var a1y = a.y;
        var a1z = a.z;
        var a1w = a.w;
        target.setTo(a0x + a1x, a0y + a1y, a0z + a1z, a0w + a1w);
        return target;
      }
      subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      }
      distanceToSquared(v) {
        let dx = this.x - v.x;
        let dy = this.y - v.y;
        let dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
      addXYZW(x, y, z, w, target = null) {
        target ||= new Vector3();
        var a0x = this.x;
        var a0y = this.y;
        var a0z = this.z;
        var a0w = this.w;
        var a1x = x;
        var a1y = y;
        var a1z = z;
        var a1w = w;
        target.setTo(a0x + a1x, a0y + a1y, a0z + a1z, a0w + a1w);
        return target;
      }
      /**
       * Clone a vector with the same components as the current vector
       */
      clone() {
        return new Vector3(this.x, this.y, this.z, this.w);
      }
      /**
       * The components of the source vector are set to the current vector
       * @param src Original vector
       * @returns 
       */
      copyFrom(src) {
        var v = this;
        v.x = src.x;
        v.y = src.y;
        v.z = src.z;
        v.w = src.w;
        return v;
      }
      /**
       * Subtract two vectors and assign the result to yourself
       * @param a Minus vector
       */
      decrementBy(a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
      }
      /**
       * 
       * Calculate the dot product of two vectors and return the Angle relationship between the two vectors
       * @param a The vector that you need to compute
       * @returns number Returns the Angle relationship between two vectors
       */
      dotProduct(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
      }
      // /**
      //  * @language en_US
      //  * @param toCompare The Vector3 object to be compared with the current
      //  *                  Vector3 object.
      //  * @param allFour   An optional parameter that specifies whether the w
      //  *                  property of the Vector3 objects is used in the
      //  *                  comparison.
      //  * @returns 
      //  *          to the current Vector3 object; false if it is not equal.
      //  */
      /**
       * 
       * Find whether the values of two vectors are identical
       * @param toCompare The vector to compare
       * @param allFour The default parameter is 1, whether to compare the w component
       * @returns A value of true if the specified Vector3 object is equal to the current Vector3 object; false if it is not equal.
       */
      equals(toCompare, allFour = false) {
        return this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w);
      }
      // /**
      //  * @language en_US
      //  * Increments the value of the x, y, and z elements of the current
      //  * Vector3 object by the values of the x, y, and z elements of a
      //  * specified Vector3 object. Unlike the <code>Vector3.add()</code>
      //  * method, the <code>incrementBy()</code> method changes the current
      //  * Vector3 object and does not return a new Vector3 object.
      //  *
      //  * @param a The Vector3 object to be added to the current Vector3
      //  *          object.
      //  */
      /**
       * The current vector plus is equal to the vector, plus just the x, y, and z components
       * @param a vector
       */
      incrementBy(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
      }
      /**
       * The current vector divided by the vector or component
       * @param v The vector or component that you want to divide
       * @returns Vector3 Returns the result of the calculation
       */
      divide(v) {
        if (v instanceof Vector3)
          return new Vector3(this.x / v.x, this.y / v.y, this.z / v.z);
        else {
          this.x = this.x / v;
          this.y = this.y / v;
          this.z = this.z / v;
        }
        return this;
      }
      /**
       * Sets the current Vector3 object to its inverse. The inverse object
       * is also considered the opposite of the original object. The value of
       * the x, y, and z properties of the current Vector3 object is changed
       * to -x, -y, and -z.
       */
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
      /**
       * Scales the line segment between(0,0) and the current point to a set
       * length.
       *
       * @param thickness The scaling value. For example, if the current
       * Vector3 object is (0,3,4), and you normalize it to
       * 1, the point returned is at(0,0.6,0.8).
       */
      normalize(thickness = 1) {
        let self = this;
        if (this.length != 0) {
          var invLength = thickness / this.length;
          this.x *= invLength;
          this.y *= invLength;
          this.z *= invLength;
          return self;
        }
        return self;
      }
      /**
       * Apply the rotation quaternion
       * @param q quaternion
       * @returns 
       */
      applyQuaternion(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      }
      /**
       * Scales the current Vector3 object by a scalar, a magnitude. The
       * Vector3 object's x, y, and z elements are multiplied by the scalar
       * number specified in the parameter. For example, if the vector is
       * scaled by ten, the result is a vector that is ten times longer. The
       * scalar can also change the direction of the vector. Multiplying the
       * vector by a negative number reverses its direction.
       *
       * @param s A multiplier (scalar) used to scale a Vector3 object.
       */
      scaleBy(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;
      }
      /**
       * The current vector times the scalar s
       * @param s scalar s
       * @returns 
       */
      mul(s) {
        let v = new Vector3();
        v.x = this.x * s;
        v.y = this.y * s;
        v.z = this.z * s;
        return v;
      }
      scale(s) {
        this.x *= s.x;
        this.y *= s.y;
        this.z *= s.z;
        return this;
      }
      scaleToRef(s, ref) {
        if (!ref) {
          ref = new Vector3();
        }
        ref.x = this.x * s;
        ref.y = this.y * s;
        ref.z = this.z * s;
        return ref;
      }
      /**
       * @language en_US
       * Sets the members of Vector3 to the specified values
       *
       * @param xa The first element, such as the x coordinate.
       * @param ya The second element, such as the y coordinate.
       * @param za The third element, such as the z coordinate.
       */
      setTo(xa, ya, za, wa = 1) {
        this.x = xa;
        this.y = ya;
        this.z = za;
        this.w = wa;
      }
      /**
       * Copy the components of the source vector to this vector
       * @param src Source vector
       * @returns 
       */
      copy(src) {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
        this.w = src.w;
        return this;
      }
      /**
       * @language en_US
       * Subtracts the value of the x, y, and z elements of the current
       * Vector3 object from the values of the x, y, and z elements of
       * another Vector3 object. The <code>subtract()</code> method does not
       * change the current Vector3 object. Instead, this method returns a
       * new Vector3 object with the new values.
       *
       * @param a The Vector3 object to be subtracted from the current
       *          Vector3 object.
       * @returns A new Vector3 object that is the difference between the
       *          current Vector3 and the specified Vector3 object.
       */
      subtract(a, target = null) {
        if (!target) {
          target = new Vector3();
        }
        target.setTo(this.x - a.x, this.y - a.y, this.z - a.z);
        return target;
      }
      /**
       * Let's multiply that vector times that vector.
       * @param other Multiplied vectors
       * @param target Returned vector
       * @returns 
       */
      multiply(other, target = null) {
        if (!target) {
          target = new Vector3();
        }
        var x0 = this.x;
        var y0 = this.y;
        var z0 = this.z;
        var x1 = other.x;
        var y1 = other.y;
        var z1 = other.z;
        target.setTo(x0 * x1, y0 * y1, z0 * z1);
        return target;
      }
      /**
       * Let's divide this vector by this vector.
       * @param other The vector that divides
       * @param target Returned vector
       * @returns 
       */
      divided(other, target = null) {
        if (!target) {
          target = new Vector3();
        }
        var x0 = this.x;
        var y0 = this.y;
        var z0 = this.z;
        var x1 = other.x;
        var y1 = other.y;
        var z1 = other.z;
        target.setTo(x0 / x1, y0 / y1, z0 / z1);
        return target;
      }
      /**
       * Divide that vector by the scalar
       * @param v The scalar that divides
       * @param target Output a Vector3 vector
       * @returns 
       */
      div(v, target) {
        if (!target) {
          target = new Vector3();
        }
        var x0 = this.x;
        var y0 = this.y;
        var z0 = this.z;
        var w0 = this.w;
        target.setTo(x0 / v, y0 / v, z0 / v, w0 / v);
        return target;
      }
      /**
      * Computes the linear interpolation between two Vector3, and the result is the current object
      * @param v0 Vector 1
      * @param v1 Vector 2
      * @param t Interpolation factor
      */
      lerp(v0, v1, t) {
        var v0x = v0.x, v0y = v0.y, v0z = v0.z, v0w = v0.w;
        var v1x = v1.x, v1y = v1.y, v1z = v1.z, v1w = v1.w;
        this.x = (v1x - v0x) * t + v0x;
        this.y = (v1y - v0y) * t + v0y;
        this.z = (v1z - v0z) * t + v0z;
        this.w = (v1w - v0w) * t + v0w;
      }
      /**
       * The x, y, and z components of this vector are rounded upward to the nearest integers.
       * @param min minimum value
       * @param max maximum value
       * @returns 
       */
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
      //     /**
      //    *
      //    * Computes the linear interpolation between two Vector3, and the result is the current object
      //    * @param lhs Vector3 1
      //    * @param rhs Vector3 2
      //    * @param t Interpolation factor
      //    */
      //     public slerp(lhs: Vector3, rhs: Vector3, t: number): void {
      //         var lhsMag: number = Math.sqrt(this.Dot(lhs, lhs));
      //         var rhsMag: number = Math.sqrt(this.Dot(rhs, rhs));
      //         if (lhsMag < 0.00001 || rhsMag < 0.00001) {
      //             return this.lerp(lhs, rhs, t);
      //         }
      //         var lerpedMagnitude: number = lhsMag + t * (rhsMag - lhsMag);
      //         var dot: number = this.Dot(lhs, rhs) / (lhsMag * rhsMag);
      //         // direction is almost the same
      //         if (dot > 1.0 - 0.00001) {
      //             return this.lerp(lhs, rhs, t);
      //         }
      //         // directions are almost opposite
      //         else if (dot < -1.0 + 0.00001) {
      //             Vector3.HELP_0.copyFrom(lhs);
      //             var lhsNorm: Vector3 = Vector3.HELP_0.divide(lhsMag);
      //             this.OrthoNormalVectorFast(lhsNorm, Vector3.HELP_1);
      //             var axis: Vector3 = Vector3.HELP_1;
      //             Quaternion.HELP_0.fromAxisAngle(Vector3.HELP_1, 3.1415926 * t * MathConfig.RADIANS_TO_DEGREES);
      //             var m: Matrix4 = Quaternion.HELP_0.toMatrix3D(Matrix4.helpMatrix);
      //             m.transformVector4(lhsNorm, this);
      //             this.scaleBy(lerpedMagnitude);
      //             return;
      //         }
      //         // normal case
      //         else {
      //             lhs.dotProduct;
      //             this.Cross(lhs, rhs, Vector3.HELP_0);
      //             var axis: Vector3 = Vector3.HELP_0;
      //             Vector3.HELP_1.copyFrom(lhs);
      //             var lhsNorm: Vector3 = Vector3.HELP_1.divide(lhsMag);
      //             axis.normalize();
      //             var angle: number = Math.acos(dot) * t;
      //             Quaternion.HELP_0.fromAxisAngle(axis, angle * MathConfig.RADIANS_TO_DEGREES);
      //             var m: Matrix4 = Quaternion.HELP_0.toMatrix3D(Matrix4.helpMatrix);
      //             m.transformVector4(lhsNorm, this);
      //             this.scaleBy(lerpedMagnitude);
      //             return;
      //         }
      //     }
      /**
       * Returns the string form of the current vector
       * @returns 
       */
      toString() {
        return "<" + this.x + ", " + this.y + ", " + this.z + ">";
      }
      //  */
      // public vertical(a: Vector3, dir: Vector3, target: Vector3) {
      //   let DoT = Vector3.dot(dir, target);
      //   if (DoT > 0) {
      //     target.x = a.y;
      //     target.y = -a.x;
      //   } else {
      //     target.x = -a.y;
      //     target.y = a.x;
      //   }
      // }
      normalizeToWay2D_XY() {
        let tx = Math.abs(this.x);
        let ty = Math.abs(this.y);
        if (tx > ty) {
          if (this.x > 0) {
            this.copyFrom(Vector3.RIGHT);
          } else {
            this.copyFrom(Vector3.LEFT);
          }
        } else {
          if (this.y > 0) {
            this.copyFrom(Vector3.DOWN);
          } else {
            this.copyFrom(Vector3.UP);
          }
        }
      }
      toArray() {
        return [this.x, this.y, this.z];
      }
      copyToBytes(byte) {
        byte.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, this.x, true);
        byte.setFloat32(1 * Float32Array.BYTES_PER_ELEMENT, this.y, true);
        byte.setFloat32(2 * Float32Array.BYTES_PER_ELEMENT, this.z, true);
      }
      /**
       * You take the cross product of two vectors,
       * The cross product is going to be the perpendicular vector between these two vectors
       * @param a Take the cross product of another vector
       * @returns Vector3 returns the cross product vector
       */
      crossProduct(a, target = null) {
        target = target || new Vector3();
        target.x = this.y * a.z - this.z * a.y;
        target.y = this.z * a.x - this.x * a.z;
        target.z = this.x * a.y - this.y * a.x;
        target.w = 1;
        return target;
      }
      crossVectors(a, b) {
        a.crossProduct(b, this);
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
      setFromArray(array, firstElementPos = 0) {
        this.x = array[firstElementPos];
        this.y = array[firstElementPos + 1];
        this.z = array[firstElementPos + 2];
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      clampLength(min, max) {
        let length = this.length;
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      setScalar(value) {
        this.x = value;
        this.y = value;
        this.z = value;
        return this;
      }
      static calAngle(cx, cy, x, y) {
        const radian = getCosBy2pt(x, y, cx, cy);
        let angle = Math.acos(radian) * 180 / Math.PI;
        if (x < cx)
          angle = -angle;
        return angle;
        function getCosBy2pt(x2, y2, cx2, cy2) {
          let a = [x2 - cx2, y2 - cy2];
          let b = [0, -1];
          return calCos(a, b);
        }
        function calCos(a, b) {
          let dotProduct = a[0] * b[0] + a[1] * b[1];
          let d = Math.sqrt(a[0] * a[0] + a[1] * a[1]) * Math.sqrt(b[0] * b[0] + b[1] * b[1]);
          return dotProduct / d;
        }
      }
      static pointInsideTriangle(pt, pt0, pt1, pt2) {
        Vector3.HELP_0.setTo(pt.x, pt.z, 0);
        Vector3.HELP_1.setTo(pt0.x, pt0.z, 0);
        Vector3.HELP_2.setTo(pt1.x, pt1.z, 0);
        Vector3.HELP_3.setTo(pt2.x, pt2.z, 0);
        return Vector3.pointInsideTriangle2d();
      }
      static pointInsideTriangle2d() {
        if (Vector3.productXY(Vector3.HELP_1, Vector3.HELP_2, Vector3.HELP_3) >= 0) {
          return Vector3.productXY(Vector3.HELP_1, Vector3.HELP_2, Vector3.HELP_0) >= 0 && Vector3.productXY(Vector3.HELP_2, Vector3.HELP_3, Vector3.HELP_0) >= 0 && Vector3.productXY(Vector3.HELP_3, Vector3.HELP_1, Vector3.HELP_0) >= 0;
        } else {
          return Vector3.productXY(Vector3.HELP_1, Vector3.HELP_2, Vector3.HELP_0) <= 0 && Vector3.productXY(Vector3.HELP_2, Vector3.HELP_3, Vector3.HELP_0) <= 0 && Vector3.productXY(Vector3.HELP_3, Vector3.HELP_1, Vector3.HELP_0) <= 0;
        }
      }
      static productXY(p1, p2, p3) {
        var val = (p1.x - p3.x) * (p2.y - p3.y) - (p1.y - p3.y) * (p2.x - p3.x);
        if (val > -1e-5 && val < 1e-5)
          val = 0;
        return val;
      }
      static serialize(position) {
        let v = new Vector3(position.x, position.y, position.z, position.w);
        return v;
      }
    }

    class TouchData {
      constructor(touch) {
        this.canvasX = touch.clientX;
        this.canvasY = touch.clientY;
        this.identifier = touch.identifier;
        this.clientX = touch.clientX;
        this.clientY = touch.clientY;
        this.pageX = touch.pageX;
        this.pageY = touch.pageY;
        this.screenX = touch.screenX;
        this.screenY = touch.screenY;
      }
      /**
       * The horizontal offset relative to the position of the upper left corner of Canvas.
       */
      canvasX;
      /**
       * The vertical offset relative to the position of the upper left corner of Canvas.
       */
      canvasY;
      /**
       * touch id
       */
      identifier;
      /**
       * The horizontal offset relative to the top left corner of the browser content area
       * It will change with the movement of the scroll bar.
       */
      clientX;
      /**
       * The ertical offset relative to the top left corner of the browser content area
       * It will change with the movement of the scroll bar.
       */
      clientY;
      /**
       * The horizontal offset relative to the top left corner of the browser content area
       * It won't change with the movement of the scroll bar.
       */
      pageX;
      /**
       * The ertical offset relative to the top left corner of the browser content area
       * It won't change with the movement of the scroll bar.
       */
      pageY;
      /**
       * The horizontal offset relative to the position of the top left corner of the user screen.
       */
      screenX;
      /**
       * The vertical offset relative to the position of the top left corner of the user screen.
       */
      screenY;
    }

    class InputSystem extends CEventDispatcher {
      /**
       * coord x of canvas
       */
      canvasX = 0;
      /**
       * coord y of canvas
       */
      canvasY = 0;
      /**
       *  whether the mouse is down now
       */
      isMouseDown = false;
      /**
       * whether the mouse right key is down now
       */
      isRightMouseDown = false;
      /**
       * reference of canvas
       */
      canvas;
      /**
       * current mouse coordinate x of Canvas
       */
      mouseX = 0;
      /**
       * current mouse coordinate y of Canvas
       */
      mouseY = 0;
      /**
       * the delta value when mouse wheeled
       */
      wheelDelta = 0;
      /**
       * the delta value of mouse x
       */
      mouseOffsetX = 0;
      /**
       * the delta value of mouse y
       */
      mouseOffsetY = 0;
      /**
       * the history value of mouse x
       */
      mouseLastX = 0;
      /**
       *
       * the history value of mouse y
       *
       */
      mouseLastY = 0;
      _time = 0;
      _keyStatus;
      _mouseStatus;
      _isTouchStart;
      _keyEvent3d;
      _pointerEvent3D;
      _windowsEvent3d;
      /**
       * init the input system
       * @param canvas the reference of canvas
       */
      initCanvas(canvas) {
        this.canvas = canvas;
        canvas.onpointerdown = (ev) => {
          if (ev.button == 0) {
            this.mouseStart(ev);
          } else if (ev.button == 1) {
            this.middleDown(ev);
          } else if (ev.button == 2) {
            this.mouseStart(ev);
          }
        };
        canvas.onpointerup = (ev) => {
          if (ev.button == 0) {
            this.mouseEnd(ev);
          } else if (ev.button == 1) {
            this.middleUp(ev);
          } else if (ev.button == 2) {
            this.mouseEnd(ev);
          }
        };
        canvas.onpointerenter = (ev) => {
          this.mouseOver(ev);
        };
        canvas.onpointermove = (ev) => {
          this.mouseMove(ev);
        };
        canvas.onpointercancel = (ev) => {
          this.mouseEnd(ev);
        };
        canvas.onpointerleave = (ev) => {
          this.mouseEnd(ev);
        };
        canvas.onpointerout = (ev) => {
          this.mouseEnd(ev);
        };
        canvas.addEventListener(
          "click",
          (e) => {
            if (e.button == 2) {
              this.isRightMouseDown = false;
              this.rightClick(e);
            } else if (e.button == 0) {
              this.isMouseDown = false;
              this.mouseClick(e);
            }
          },
          true
        );
        canvas.addEventListener(`wheel`, (e) => this.mouseWheel(e), { passive: false });
        window.addEventListener("keydown", (e) => this.keyDown(e), true);
        window.addEventListener("keyup", (e) => this.keyUp(e), true);
        canvas.oncontextmenu = function() {
          return false;
        };
        let rect = this.canvas.getBoundingClientRect();
        this.canvasX = rect.left;
        this.canvasY = rect.top;
        this._keyStatus = {};
        this._mouseStatus = {};
        this._isTouchStart = false;
        this._keyEvent3d = new KeyEvent();
        this._pointerEvent3D = new PointerEvent3D();
        this._windowsEvent3d = new CEvent();
      }
      _gp = false;
      onPinch(x1, y1, x2, y2) {
        this._oldPosition1 = new Vector3(x1, y1);
        this._oldPosition2 = new Vector3(x2, y2);
      }
      onSwipe(x, y) {
        this.mouseX = x;
        this.mouseY = y;
        this._oldPosition1 = null;
        this._oldPosition2 = null;
        this._time = (/* @__PURE__ */ new Date()).getTime();
      }
      _oldPosition1 = null;
      _oldPosition2 = null;
      GetTargetTouches(targetTouches) {
        var array = new Array();
        for (var i = 0; i < targetTouches.length; i++) {
          var touchData = new TouchData(targetTouches[i]);
          array.push(touchData);
        }
        return array;
      }
      rightClick(e) {
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._pointerEvent3D.mouseX = e.clientX - this.canvasX;
        this._pointerEvent3D.mouseY = e.clientY - this.canvasY;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_RIGHT_CLICK;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this.dispatchEvent(this._pointerEvent3D);
      }
      middleDown(e) {
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._pointerEvent3D.mouseX = e.clientX - this.canvasX;
        this._pointerEvent3D.mouseY = e.clientY - this.canvasY;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_MID_DOWN;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this.dispatchEvent(this._pointerEvent3D);
      }
      middleUp(e) {
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._pointerEvent3D.mouseX = e.clientX - this.canvasX;
        this._pointerEvent3D.mouseY = e.clientY - this.canvasY;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_MID_UP;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this.dispatchEvent(this._pointerEvent3D);
      }
      mouseClick(e) {
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._pointerEvent3D.mouseX = e.clientX - this.canvasX;
        this._pointerEvent3D.mouseY = e.clientY - this.canvasY;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_CLICK;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this.dispatchEvent(this._pointerEvent3D);
      }
      _downTime = 0;
      mouseEnd(e) {
        this.isMouseDown = false;
        this.mouseLastX = this.mouseX;
        this.mouseLastY = this.mouseY;
        this.mouseX = e.clientX - this.canvasX;
        this.mouseY = e.clientY - this.canvasY;
        this.mouseOffsetX = this.mouseX - this.mouseLastX;
        this.mouseOffsetY = this.mouseY - this.mouseLastY;
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._mouseStatus[this._pointerEvent3D.mouseCode] = false;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_UP;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this._pointerEvent3D.mouseX = this.mouseX;
        this._pointerEvent3D.mouseY = this.mouseY;
        this.dispatchEvent(this._pointerEvent3D);
      }
      mouseStart(e) {
        this.isMouseDown = true;
        this.mouseLastX = this.mouseX;
        this.mouseLastY = this.mouseY;
        this.mouseX = e.clientX - this.canvasX;
        this.mouseY = e.clientY - this.canvasY;
        this.mouseOffsetX = this.mouseX - this.mouseLastX;
        this.mouseOffsetY = this.mouseY - this.mouseLastY;
        this._pointerEvent3D.reset();
        this._pointerEvent3D.mouseCode = e.button;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this._pointerEvent3D.mouseX = this.mouseX;
        this._pointerEvent3D.mouseY = this.mouseY;
        this._pointerEvent3D.type = PointerEvent3D.POINTER_DOWN;
        this.dispatchEvent(this._pointerEvent3D);
      }
      mouseMove(e) {
        this.mouseLastX = this.mouseX;
        this.mouseLastY = this.mouseY;
        this.mouseX = e.clientX - this.canvasX;
        this.mouseY = e.clientY - this.canvasY;
        this.mouseOffsetX = this.mouseX - this.mouseLastX;
        this.mouseOffsetY = this.mouseY - this.mouseLastY;
        this._pointerEvent3D.reset();
        this._pointerEvent3D.type = PointerEvent3D.POINTER_MOVE;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this._pointerEvent3D.mouseX = this.mouseX;
        this._pointerEvent3D.mouseY = this.mouseY;
        this._pointerEvent3D.movementX = e.movementX;
        this._pointerEvent3D.movementY = e.movementY;
        this.dispatchEvent(this._pointerEvent3D);
      }
      mouseOver(e) {
        this.isMouseDown = false;
        this.mouseLastX = this.mouseX;
        this.mouseLastY = this.mouseY;
        this.mouseX = e.clientX - this.canvasX;
        this.mouseY = e.clientY - this.canvasY;
        this.mouseOffsetX = this.mouseX - this.mouseLastX;
        this.mouseOffsetY = this.mouseY - this.mouseLastY;
        this._pointerEvent3D.reset();
        this._pointerEvent3D.type = PointerEvent3D.POINTER_OVER;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.pointerId = e.pointerId;
        this._pointerEvent3D.pointerType = e.pointerType;
        this._pointerEvent3D.isPrimary = e.isPrimary;
        this._pointerEvent3D.pressure = e.pressure;
        this._pointerEvent3D.mouseX = this.mouseX;
        this._pointerEvent3D.mouseY = this.mouseY;
        this.dispatchEvent(this._pointerEvent3D);
      }
      mouseWheel(e) {
        e.preventDefault();
        this.mouseLastX = this.mouseX;
        this.mouseLastY = this.mouseY;
        this.mouseX = e.clientX - this.canvasX;
        this.mouseY = e.clientY - this.canvasY;
        this.mouseOffsetX = this.mouseX - this.mouseLastX;
        this.mouseOffsetY = this.mouseY - this.mouseLastY;
        if (`wheelDelta` in e) {
          this._pointerEvent3D.delay = e[`wheelDelta`];
          this.wheelDelta = e[`wheelDelta`];
        } else if (`delta` in e) {
          this.wheelDelta = e[`delta`];
        }
        this._pointerEvent3D.reset();
        this._pointerEvent3D.type = PointerEvent3D.POINTER_WHEEL;
        this._pointerEvent3D.ctrlKey = e.ctrlKey;
        this._pointerEvent3D.altKey = e.altKey;
        this._pointerEvent3D.shiftKey = e.shiftKey;
        this._pointerEvent3D.mouseX = this.mouseX;
        this._pointerEvent3D.mouseY = this.mouseY;
        this._pointerEvent3D.deltaX = e.deltaX;
        this._pointerEvent3D.deltaY = e.deltaY;
        this._pointerEvent3D.deltaZ = e.deltaZ;
        this.dispatchEvent(this._pointerEvent3D);
      }
      keyDown(e) {
        this._keyEvent3d.reset();
        this._keyEvent3d.keyCode = e.keyCode;
        this._keyEvent3d.ctrlKey = e.ctrlKey;
        this._keyEvent3d.altKey = e.altKey;
        this._keyEvent3d.shiftKey = e.shiftKey;
        if (!this._keyStatus[e.keyCode]) {
          this._keyStatus[e.keyCode] = true;
          this._keyEvent3d.type = KeyEvent.KEY_DOWN;
          this.dispatchEvent(this._keyEvent3d);
        }
      }
      keyUp(e) {
        this._keyEvent3d.reset();
        this._keyEvent3d.keyCode = e.keyCode;
        this._keyStatus[e.keyCode] = false;
        this._keyEvent3d.type = KeyEvent.KEY_UP;
        this.dispatchEvent(this._keyEvent3d);
      }
      GetSlideAngle(dx, dy) {
        return Math.atan2(dy, dx) * 180 / Math.PI;
      }
      /**
       *
       * @param  startX {Number} 
       * @param  startY {Number} 
       * @param  endX   {Number} 
       * @param  endY   {Number} 
       * @returns result {number} 1: up, 2: down, 3: left, 4: right, 0: not move
       */
      GetSlideDirection(startX, startY, endX, endY) {
        var dy = startY - endY;
        var dx = endX - startX;
        var result = 0;
        if (Math.abs(dx) < 2 && Math.abs(dy) < 2) {
          return result;
        }
        var angle = this.GetSlideAngle(dx, dy);
        if (angle >= -45 && angle < 45) {
          result = 4;
        } else if (angle >= 45 && angle < 135) {
          result = 1;
        } else if (angle >= -135 && angle < -45) {
          result = 2;
        } else if (angle >= 135 && angle <= 180 || angle >= -180 && angle < -135) {
          result = 3;
        }
        return result;
      }
    }

    const version = "0.7.2";

    let GPUAddressMode = {
      clamp_to_edge: "clamp-to-edge",
      repeat: "repeat",
      mirror_repeat: "mirror-repeat"
    };
    let GPUBlendFactor = {
      zero: "zero",
      one: "one",
      src: "src",
      one_minus_src: "one-minus-src",
      src_alpha: "src-alpha",
      one_minus_src_alpha: "one-minus-src-alpha",
      dst: "dst",
      one_minus_dst: "one-minus-dst",
      dst_alpha: "dst-alpha",
      one_minus_dst_alpha: "one-minus-dst-alpha",
      src_alpha_saturated: "src-alpha-saturated",
      constant: "constant",
      one_minus_constant: "one-minus-constant"
    };
    const blendComponent = {
      srcFactor: "one",
      dstFactor: "zero",
      operation: "add"
    };
    const stencilStateFace = {
      compare: "always",
      failOp: "keep",
      depthFailOp: "keep",
      passOp: "keep"
    };
    let GPUCompareFunction = {
      never: "never",
      less: "less",
      equal: "equal",
      less_equal: "less-equal",
      greater: "greater",
      not_equal: "not-equal",
      greater_equal: "greater-equal",
      always: "always"
    };
    let GPUCullMode = {
      none: "none",
      front: "front",
      back: "back"
    };
    let GPUFilterMode = {
      nearest: "nearest",
      linear: "linear"
    };
    let GPUPrimitiveTopology = {
      point_list: "point-list",
      line_list: "line-list",
      line_strip: "line-strip",
      triangle_list: "triangle-list",
      triangle_strip: "triangle-strip"
    };
    let GPUTextureFormat = {
      r8unorm: "r8unorm",
      r8snorm: "r8snorm",
      r8uint: "r8uint",
      r8sint: "r8sint",
      r16uint: "r16uint",
      r16sint: "r16sint",
      r16float: "r16float",
      rg8unorm: "rg8unorm",
      rg8snorm: "rg8snorm",
      rg8uint: "rg8uint",
      rg8sint: "rg8sint",
      r32uint: "r32uint",
      r32sint: "r32sint",
      r32float: "r32float",
      rg16uint: "rg16uint",
      rg16sint: "rg16sint",
      rg16float: "rg16float",
      rgba8unorm: "rgba8unorm",
      rgba8unorm_srgb: "rgba8unorm-srgb",
      rgba8snorm: "rgba8snorm",
      rgba8uint: "rgba8uint",
      rgba8sint: "rgba8sint",
      bgra8unorm: "bgra8unorm",
      bgra8unorm_srgb: "bgra8unorm-srgb",
      rgb9e5ufloat: "rgb9e5ufloat",
      rgb10a2unorm: "rgb10a2unorm",
      rg11b10ufloat: "rg11b10ufloat",
      rg32uint: "rg32uint",
      rg32sint: "rg32sint",
      rg32float: "rg32float",
      rgba16uint: "rgba16uint",
      rgba16sint: "rgba16sint",
      rgba16float: "rgba16float",
      rgba32uint: "rgba32uint",
      rgba32sint: "rgba32sint",
      rgba32float: "rgba32float",
      stencil8: "stencil8",
      depth16unorm: "depth16unorm",
      depth24plus: "depth24plus",
      depth24plus_stencil8: "depth24plus-stencil8",
      depth32float: "depth32float",
      bc1_rgba_unorm: "bc1-rgba-unorm",
      bc1_rgba_unorm_srgb: "bc1-rgba-unorm-srgb",
      bc2_rgba_unorm: "bc2-rgba-unorm",
      bc2_rgba_unorm_srgb: "bc2-rgba-unorm-srgb",
      bc3_rgba_unorm: "bc3-rgba-unorm",
      bc3_rgba_unorm_srgb: "bc3-rgba-unorm-srgb",
      bc4_r_unorm: "bc4-r-unorm",
      bc4_r_snorm: "bc4-r-snorm",
      bc5_rg_unorm: "bc5-rg-unorm",
      bc5_rg_snorm: "bc5-rg-snorm",
      bc6h_rgb_ufloat: "bc6h-rgb-ufloat",
      bc6h_rgb_float: "bc6h-rgb-float",
      bc7_rgba_unorm: "bc7-rgba-unorm",
      bc7_rgba_unorm_srgb: "bc7-rgba-unorm-srgb",
      depth24unorm_stencil8: "depth24unorm-stencil8",
      depth32float_stencil8: "depth32float-stencil8"
    };
    let GPUVertexFormat = {
      uint8x2: "uint8x2",
      uint8x4: "uint8x4",
      sint8x2: "sint8x2",
      sint8x4: "sint8x4",
      unorm8x2: "unorm8x2",
      unorm8x4: "unorm8x4",
      snorm8x2: "snorm8x2",
      snorm8x4: "snorm8x4",
      uint16x2: "uint16x2",
      uint16x4: "uint16x4",
      sint16x2: "sint16x2",
      sint16x4: "sint16x4",
      unorm16x2: "unorm16x2",
      unorm16x4: "unorm16x4",
      snorm16x2: "snorm16x2",
      snorm16x4: "snorm16x4",
      float16x2: "float16x2",
      float16x4: "float16x4",
      float32: "float32",
      float32x2: "float32x2",
      float32x3: "float32x3",
      float32x4: "float32x4",
      uint32: "uint32",
      uint32x2: "uint32x2",
      uint32x3: "uint32x3",
      uint32x4: "uint32x4",
      sint32: "sint32",
      sint32x2: "sint32x2",
      sint32x3: "sint32x3",
      sint32x4: "sint32x4"
    };
    let GPUVertexStepMode = {
      vertex: "vertex",
      instance: "instance"
    };

    class CResizeEvent extends CEvent {
      /**
       *
       * RESIZE:enum event type
       */
      static RESIZE = "resize";
    }

    class Context3D extends CEventDispatcher {
      adapter;
      device;
      context;
      aspect;
      presentationSize = [0, 0];
      presentationFormat;
      canvas;
      windowWidth;
      windowHeight;
      canvasConfig;
      super = 1;
      _pixelRatio = 1;
      _resizeEvent;
      // initSize: number[];
      get pixelRatio() {
        return this._pixelRatio;
      }
      /**
       * Configure canvas by CanvasConfig
       * @param canvasConfig
       * @returns
       */
      async init(canvasConfig) {
        this.canvasConfig = canvasConfig;
        if (canvasConfig && canvasConfig.canvas) {
          this.canvas = canvasConfig.canvas;
          if (this.canvas === null)
            throw new Error("no Canvas");
          const _width = this.canvas.clientWidth, _height = this.canvas.clientHeight;
          if (_width != this.canvas.clientWidth)
            this.canvas.style.width = _width + "px";
          if (_height != this.canvas.clientHeight)
            this.canvas.style.height = _height + "px";
        } else {
          this.canvas = document.createElement("canvas");
          this.canvas.style.position = `absolute`;
          this.canvas.style.top = "0px";
          this.canvas.style.left = "0px";
          this.canvas.style.width = "100%";
          this.canvas.style.height = "100%";
          this.canvas.style.zIndex = canvasConfig?.zIndex ? canvasConfig.zIndex.toString() : "0";
          document.body.appendChild(this.canvas);
        }
        if (canvasConfig && canvasConfig.backgroundImage) {
          this.canvas.style.background = `url(${canvasConfig.backgroundImage})`;
          this.canvas.style["background-size"] = "cover";
          this.canvas.style["background-position"] = "center";
        } else
          this.canvas.style.background = "transparent";
        this.canvas.style["touch-action"] = "none";
        this.canvas.style["object-fit"] = "cover";
        if (navigator.gpu === void 0) {
          throw new Error("Your browser does not support WebGPU!");
        }
        this.adapter = await navigator.gpu.requestAdapter({
          powerPreference: "high-performance"
          // powerPreference: 'low-power',
        });
        if (this.adapter == null) {
          throw new Error("Your browser does not support WebGPU!");
        }
        this.device = await this.adapter.requestDevice({
          requiredFeatures: [
            "bgra8unorm-storage",
            "depth-clip-control",
            "depth32float-stencil8",
            "indirect-first-instance",
            "rg11b10ufloat-renderable"
          ],
          requiredLimits: {
            minUniformBufferOffsetAlignment: 256,
            maxStorageBufferBindingSize: this.adapter.limits.maxStorageBufferBindingSize
          }
        });
        if (this.device == null) {
          throw new Error("Your browser does not support WebGPU!");
        }
        this._pixelRatio = this.canvasConfig?.devicePixelRatio || window.devicePixelRatio || 1;
        this._pixelRatio = Math.min(this._pixelRatio, 2);
        this.device.label = "device";
        this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        this.context = this.canvas.getContext("webgpu");
        this.context.configure({
          device: this.device,
          format: this.presentationFormat,
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
          alphaMode: "premultiplied",
          colorSpace: `srgb`
        });
        this._resizeEvent = new CResizeEvent(CResizeEvent.RESIZE, { width: this.windowWidth, height: this.windowHeight });
        const resizeObserver = new ResizeObserver(() => {
          this.updateSize();
          Texture.destroyTexture();
        });
        resizeObserver.observe(this.canvas);
        this.updateSize();
        return true;
      }
      updateSize() {
        let w = Math.floor(this.canvas.clientWidth * this.pixelRatio * this.super);
        let h = Math.floor(this.canvas.clientHeight * this.pixelRatio * this.super);
        if (w != this.windowWidth || h != this.windowHeight) {
          this.canvas.width = this.windowWidth = w;
          this.canvas.height = this.windowHeight = h;
          this.presentationSize[0] = this.windowWidth;
          this.presentationSize[1] = this.windowHeight;
          this.aspect = this.windowWidth / this.windowHeight;
          this._resizeEvent.data.width = this.windowWidth;
          this._resizeEvent.data.height = this.windowHeight;
          this.dispatchEvent(this._resizeEvent);
        }
      }
    }
    let webGPUContext = new Context3D();

    class RTResourceConfig {
      static colorBufferTex_NAME = "colorBufferTex";
      static positionBufferTex_NAME = "positionBufferTex";
      static normalBufferTex_NAME = "normalBufferTex";
      static materialBufferTex_NAME = "materialBufferTex";
      static zBufferTexture_NAME = "zBufferTexture";
      static zPreDepthTexture_NAME = "zPreDepthTexture";
      static outTex_NAME = "outTex";
    }

    var RendererMask = /* @__PURE__ */ ((RendererMask2) => {
      RendererMask2[RendererMask2["Default"] = 1] = "Default";
      RendererMask2[RendererMask2["IgnoreDepthPass"] = 2] = "IgnoreDepthPass";
      RendererMask2[RendererMask2["Sky"] = 6] = "Sky";
      RendererMask2[RendererMask2["Particle"] = 10] = "Particle";
      RendererMask2[RendererMask2["SkinnedMesh"] = 16] = "SkinnedMesh";
      RendererMask2[RendererMask2["MorphTarget"] = 32] = "MorphTarget";
      RendererMask2[RendererMask2["Terrain"] = 64] = "Terrain";
      RendererMask2[RendererMask2["UI"] = 128] = "UI";
      return RendererMask2;
    })(RendererMask || {});
    class RendererMaskUtil {
      static addMask(src, tag) {
        let value = src | tag;
        return value;
      }
      static removeMask(src, tag) {
        let value = src & ~tag;
        return value;
      }
      static hasMask(m1, m2) {
        return (m1 & m2) == m2;
      }
    }

    function NonSerialize(cls, key) {
      let dic = cls["__NonSerialize__"];
      if (!dic) {
        dic = cls["__NonSerialize__"] = {};
        dic["__NonSerialize__"] = true;
      }
      dic[key] = true;
    }
    function IsNonSerialize(instance, key) {
      let noSerializeDic;
      while (instance) {
        instance = instance["__proto__"];
        if (instance)
          noSerializeDic = instance["__NonSerialize__"];
        if (noSerializeDic)
          break;
      }
      return noSerializeDic && noSerializeDic[key];
    }
    function EditorInspector(cls, key, p1, p2, p3) {
      let dic = cls["__EditorInspector__"];
      if (!dic) {
        dic = cls["__EditorInspector__"] = /* @__PURE__ */ new Map();
      }
      let property = dic.get(cls.constructor.name);
      if (!property) {
        property = /* @__PURE__ */ new Map();
        dic.set(cls.constructor.name, property);
      }
      property.set(key, { p1, p2, p3 });
    }
    function IsEditorInspector(instance) {
      let propertyDic;
      let ins = instance;
      let list = [];
      while (ins) {
        if (list.indexOf(ins.constructor.name) != -1) {
          ins = ins["__proto__"];
          continue;
        }
        list.push(ins.constructor.name);
        ins = ins["__proto__"];
      }
      list = list.reverse();
      ins = instance;
      while (ins) {
        ins = ins["__proto__"];
        if (ins) {
          propertyDic = ins["__EditorInspector__"];
        }
        if (propertyDic)
          break;
      }
      let final = /* @__PURE__ */ new Map();
      if (propertyDic) {
        for (let i = 0; i < list.length; i++) {
          const c_name = list[i];
          let dic = propertyDic.get(c_name);
          if (dic) {
            dic.forEach((v, k) => {
              final.set(k, v);
            });
          }
        }
      }
      return final;
    }
    function RegisterComponent(cls, key, p1, p2, p3) {
      let dic = window["__Component__"];
      if (!dic) {
        dic = window["__Component__"] = {};
      }
      dic[key] = cls;
    }
    function GetComponentClass(name) {
      let coms = window["__Component__"];
      if (coms[name]) {
        return coms[name];
      }
      return null;
    }
    function RegisterShader(cls, key, p1, p2, p3) {
      let dic = window["__shader__"];
      if (!dic) {
        dic = window["__shader__"] = {};
      }
      dic[key] = cls;
    }
    function GetShader(name) {
      let coms = window["__shader__"];
      if (coms[name]) {
        return coms[name];
      }
      return null;
    }

    var __defProp$n = Object.defineProperty;
    var __getOwnPropDesc$n = Object.getOwnPropertyDescriptor;
    var __decorateClass$n = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$n(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$n(target, key, result);
      return result;
    };
    const _Struct = class _Struct {
      __refection;
      __size = 0;
      /**
       * get reflection name
       * @returns
       */
      getValueType() {
        if (!this.__refection) {
          let self = this;
          this.__refection = [];
          for (const key in self) {
            if (!IsNonSerialize(this, key)) {
              const element = self[key];
              let att = {
                name: key,
                type: element.constructor.name
              };
              this.__refection.push(att);
            }
          }
        }
        return this.__refection;
      }
      /**
       * get any type value memory size
       * @param value any type value
       * @returns
       */
      static getValueSize(value) {
        let type = value.constructor.name;
        switch (type) {
          case `Boolean`:
            return 1 * 4;
          case `Number`:
            return 1 * 4;
          case `f32`:
            return 1 * 4;
          case `i32`:
            return 1 * 4;
          case `u32`:
            return 1 * 4;
          case `Float32Array`:
            return value.byteLength;
          case `Vector2`:
            return 2 * 4;
          case `Vector3`:
            return 3 * 4;
          case `Vector4`:
            return 4 * 4;
          case `Color`:
            return 4 * 4;
          case `Array`:
            let singleSize = 0;
            for (let i = 0, c = value.length; i < c; i++) {
              singleSize += _Struct.getValueSize(value[i]);
            }
            return singleSize;
        }
        return 0;
      }
      static __cacheStruct = /* @__PURE__ */ new Map();
      static Ref(c) {
        let struct = this.Get(c);
        let ref = struct.getValueType();
        return ref;
      }
      static Get(c) {
        let struct = _Struct.__cacheStruct.get(c.prototype);
        if (!struct) {
          struct = new c();
          _Struct.__cacheStruct.set(c.prototype, struct);
        }
        return struct;
      }
      /**
       * get any struct memory size
       * @returns
       */
      static GetSize(c) {
        let struct = this.Get(c);
        if (struct.__size == 0) {
          for (const key in struct) {
            if (!IsNonSerialize(struct, key)) {
              const element = struct[key];
              struct.__size += _Struct.getValueSize(element);
            }
          }
          if (struct.__size > 4) {
            struct.__size = Math.ceil(struct.__size / 4) * 4;
          }
        }
        return struct.__size;
      }
    };
    __decorateClass$n([
      NonSerialize
    ], _Struct.prototype, "__refection", 2);
    __decorateClass$n([
      NonSerialize
    ], _Struct.prototype, "__size", 2);
    let Struct = _Struct;

    class MemoryInfo {
      byteOffset;
      byteSize;
      offset = 0;
      dataBytes;
      get x() {
        return this.dataBytes.getFloat32(0 * Float32Array.BYTES_PER_ELEMENT, true);
      }
      set x(v) {
        this.dataBytes.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, v, true);
      }
      get y() {
        return this.dataBytes.getFloat32(1 * Float32Array.BYTES_PER_ELEMENT, true);
      }
      set y(v) {
        this.dataBytes.setFloat32(1 * Float32Array.BYTES_PER_ELEMENT, v, true);
      }
      get z() {
        return this.dataBytes.getFloat32(2 * Float32Array.BYTES_PER_ELEMENT, true);
      }
      set z(v) {
        this.dataBytes.setFloat32(2 * Float32Array.BYTES_PER_ELEMENT, v, true);
      }
      get w() {
        return this.dataBytes.getFloat32(3 * Float32Array.BYTES_PER_ELEMENT, true);
      }
      set w(v) {
        this.dataBytes.setFloat32(3 * Float32Array.BYTES_PER_ELEMENT, v, true);
      }
      setX(x) {
        this.x = x;
      }
      setXY(x, y) {
        this.x = x;
        this.y = y;
      }
      setXYZ(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }
      setXYZW(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      setVector2Array(vs) {
        for (let i = 0; i < vs.length; i++) {
          const element = vs[i];
          this.dataBytes.setFloat32((i * 2 + 0) * Float32Array.BYTES_PER_ELEMENT, element.x, true);
          this.dataBytes.setFloat32((i * 2 + 1) * Float32Array.BYTES_PER_ELEMENT, element.y, true);
        }
      }
      setVector3Array(vs) {
        for (let i = 0; i < vs.length; i++) {
          const element = vs[i];
          this.dataBytes.setFloat32((i * 3 + 0) * Float32Array.BYTES_PER_ELEMENT, element.x, true);
          this.dataBytes.setFloat32((i * 3 + 1) * Float32Array.BYTES_PER_ELEMENT, element.y, true);
          this.dataBytes.setFloat32((i * 3 + 2) * Float32Array.BYTES_PER_ELEMENT, element.z, true);
        }
      }
      setVector4Array(vs) {
        for (let i = 0; i < vs.length; i++) {
          const element = vs[i];
          this.dataBytes.setFloat32((i * 4 + 0) * Float32Array.BYTES_PER_ELEMENT, element.x, true);
          this.dataBytes.setFloat32((i * 4 + 1) * Float32Array.BYTES_PER_ELEMENT, element.y, true);
          this.dataBytes.setFloat32((i * 4 + 2) * Float32Array.BYTES_PER_ELEMENT, element.z, true);
          this.dataBytes.setFloat32((i * 4 + 3) * Float32Array.BYTES_PER_ELEMENT, element.w, true);
        }
      }
      setColorArray(colorArray) {
        for (let i = 0; i < colorArray.length; i++) {
          const element = colorArray[i];
          this.dataBytes.setFloat32((i * 4 + 0) * Float32Array.BYTES_PER_ELEMENT, element.r, true);
          this.dataBytes.setFloat32((i * 4 + 1) * Float32Array.BYTES_PER_ELEMENT, element.g, true);
          this.dataBytes.setFloat32((i * 4 + 2) * Float32Array.BYTES_PER_ELEMENT, element.b, true);
          this.dataBytes.setFloat32((i * 4 + 3) * Float32Array.BYTES_PER_ELEMENT, element.a, true);
        }
      }
      setInt8(v, index = 0) {
        this.dataBytes.setInt8(index * Int8Array.BYTES_PER_ELEMENT, v);
      }
      getInt8(index = 0) {
        return this.dataBytes.getInt8(index * Int8Array.BYTES_PER_ELEMENT);
      }
      setInt16(v, index = 0) {
        this.dataBytes.setInt16(index * Int16Array.BYTES_PER_ELEMENT, v, true);
      }
      getInt16(index = 0) {
        return this.dataBytes.getInt16(index * Int16Array.BYTES_PER_ELEMENT, true);
      }
      setInt32(v, index = 0) {
        this.dataBytes.setInt32(index * Int32Array.BYTES_PER_ELEMENT, v, true);
      }
      getInt32(index = 0) {
        return this.dataBytes.getInt32(index * Int32Array.BYTES_PER_ELEMENT, true);
      }
      setFloat(v, index = 0) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, v, true);
      }
      getFloat(index = 0) {
        return this.dataBytes.getFloat32(index * Float32Array.BYTES_PER_ELEMENT, true);
      }
      setUint8(v, index = 0) {
        this.dataBytes.setUint8(index * Uint8Array.BYTES_PER_ELEMENT, v);
      }
      getUint8(index = 0) {
        return this.dataBytes.getUint8(index * Uint8Array.BYTES_PER_ELEMENT);
      }
      setUint16(v, index = 0) {
        this.dataBytes.setUint16(index * Uint16Array.BYTES_PER_ELEMENT, v, true);
      }
      getUint16(index = 0) {
        return this.dataBytes.getUint16(index * Uint16Array.BYTES_PER_ELEMENT, true);
      }
      setUint32(v, index = 0) {
        this.dataBytes.setUint32(index * Uint32Array.BYTES_PER_ELEMENT, v, true);
      }
      getUint32(index = 0) {
        return this.dataBytes.getUint32(index * Uint32Array.BYTES_PER_ELEMENT, true);
      }
      setArray(index, data) {
        for (let i = 0; i < data.length; i++) {
          const element = data[i];
          this.dataBytes.setFloat32((index + i) * Float32Array.BYTES_PER_ELEMENT, element, true);
        }
      }
      setFloat32Array(index, data) {
        let tmp = new Float32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Float32Array.BYTES_PER_ELEMENT, data.length);
        tmp.set(data);
      }
      setArrayBuffer(index, arrayBuffer) {
        if (arrayBuffer instanceof Uint8Array) {
          this.setUint8Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Uint16Array) {
          this.setUint16Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Uint32Array) {
          this.setUint32Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Int8Array) {
          this.setInt8Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Int16Array) {
          this.setInt16Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Int32Array) {
          this.setInt32Array(index, arrayBuffer);
        } else if (arrayBuffer instanceof Float32Array) {
          this.setFloat32Array(index, arrayBuffer);
        } else ;
      }
      setInt8Array(index, data) {
        let tmp = new Int8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Int8Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setInt16Array(index, data) {
        let tmp = new Int16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Int16Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setInt32Array(index, data) {
        let tmp = new Int32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Int32Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setUint8Array(index, data) {
        let tmp = new Uint8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Uint8Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setUint16Array(index, data) {
        let tmp = new Uint16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Uint16Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setUint32Array(index, data) {
        let tmp = new Uint32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + index * Uint32Array.BYTES_PER_ELEMENT);
        tmp.set(data);
      }
      setData(index, data) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, data, true);
      }
      setVector2(index, data) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, data.x, true);
        this.dataBytes.setFloat32((index + 1) * Float32Array.BYTES_PER_ELEMENT, data.y, true);
      }
      setVector3(index, data) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, data.x, true);
        this.dataBytes.setFloat32((index + 1) * Float32Array.BYTES_PER_ELEMENT, data.y, true);
        this.dataBytes.setFloat32((index + 2) * Float32Array.BYTES_PER_ELEMENT, data.z, true);
      }
      setVector4(index, data) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, data.x, true);
        this.dataBytes.setFloat32((index + 1) * Float32Array.BYTES_PER_ELEMENT, data.y, true);
        this.dataBytes.setFloat32((index + 2) * Float32Array.BYTES_PER_ELEMENT, data.z, true);
        this.dataBytes.setFloat32((index + 3) * Float32Array.BYTES_PER_ELEMENT, data.w, true);
      }
      setColor(index, data) {
        this.dataBytes.setFloat32(index * Float32Array.BYTES_PER_ELEMENT, data.r, true);
        this.dataBytes.setFloat32((index + 1) * Float32Array.BYTES_PER_ELEMENT, data.g, true);
        this.dataBytes.setFloat32((index + 2) * Float32Array.BYTES_PER_ELEMENT, data.b, true);
        this.dataBytes.setFloat32((index + 3) * Float32Array.BYTES_PER_ELEMENT, data.a, true);
      }
      getData(index) {
        return this.dataBytes.getFloat32(index * Float32Array.BYTES_PER_ELEMENT, true);
      }
      writeFloat(v) {
        this.dataBytes.setFloat32(this.offset, v, true);
        this.offset += Float32Array.BYTES_PER_ELEMENT;
      }
      writeInt8(v) {
        this.dataBytes.setInt8(this.offset, v);
        this.offset += Int8Array.BYTES_PER_ELEMENT;
      }
      writeInt16(v) {
        this.dataBytes.setInt16(this.offset, v, true);
        this.offset += Int16Array.BYTES_PER_ELEMENT;
      }
      writeInt32(v) {
        this.dataBytes.setInt32(this.offset, v, true);
        this.offset += Int32Array.BYTES_PER_ELEMENT;
      }
      writeUint8(v) {
        this.dataBytes.setUint8(this.offset, v);
        this.offset += Uint8Array.BYTES_PER_ELEMENT;
      }
      writeUint16(v) {
        this.dataBytes.setUint16(this.offset, v, true);
        this.offset += Uint16Array.BYTES_PER_ELEMENT;
      }
      writeUint32(v) {
        this.dataBytes.setUint32(this.offset, v, true);
        this.offset += Uint32Array.BYTES_PER_ELEMENT;
      }
      writeVector2(v) {
        this.writeFloat(v.x);
        this.writeFloat(v.y);
      }
      writeVector3(v) {
        this.writeFloat(v.x);
        this.writeFloat(v.y);
        this.writeFloat(v.z);
      }
      writeVector4(v) {
        this.writeFloat(v.x);
        this.writeFloat(v.y);
        this.writeFloat(v.z);
        this.writeFloat(v.w);
      }
      writeRGBColor(v) {
        this.writeFloat(v.r);
        this.writeFloat(v.g);
        this.writeFloat(v.b);
      }
      writeArray(v) {
        for (let i = 0; i < v.length; i++) {
          const d = v[i];
          this.writeFloat(d);
        }
      }
      writeFloat32Array(v) {
        new Float32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeInt8Array(v) {
        new Int8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeInt16Array(v) {
        new Int16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeInt32Array(v) {
        new Int32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeUint8Array(v) {
        new Uint8Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeUint16Array(v) {
        new Uint16Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      writeUint32Array(v) {
        new Uint32Array(this.dataBytes.buffer, this.dataBytes.byteOffset + this.offset).set(v);
        this.offset += v.byteLength;
      }
      reset() {
        this.offset = 0;
      }
      destroy() {
        this.byteOffset = null;
        this.byteSize = null;
        this.offset = null;
        this.dataBytes = null;
      }
    }

    class MemoryDO {
      shareDataBuffer;
      _byteOffset = 0;
      allocation(byteSize) {
        if (this.shareDataBuffer && this.shareDataBuffer.byteLength < byteSize) {
          this._byteOffset = 0;
        } else {
          this.shareDataBuffer = new ArrayBuffer(byteSize);
        }
      }
      allocation_node(byteSize) {
        if (this._byteOffset + byteSize > this.shareDataBuffer.byteLength) {
          console.error("memory not enough!", this._byteOffset, byteSize, this.shareDataBuffer.byteLength);
          return null;
        }
        let memoryInfo = new MemoryInfo();
        memoryInfo.byteOffset = this._byteOffset;
        memoryInfo.byteSize = byteSize;
        memoryInfo.dataBytes = new DataView(this.shareDataBuffer, this._byteOffset, memoryInfo.byteSize);
        this._byteOffset += memoryInfo.byteSize;
        return memoryInfo;
      }
      allocation_memory(memoryInfo) {
        if (this._byteOffset + memoryInfo.byteSize > this.shareDataBuffer.byteLength) {
          console.error("memory not enough!", this._byteOffset, memoryInfo.byteSize, this.shareDataBuffer.byteLength);
          return null;
        }
        memoryInfo.byteOffset = this._byteOffset;
        memoryInfo.dataBytes = new DataView(this.shareDataBuffer, this._byteOffset, memoryInfo.byteSize);
        this._byteOffset += memoryInfo.byteSize;
        return memoryInfo;
      }
      reset() {
        this._byteOffset = 0;
      }
      destroy(force) {
        this.shareDataBuffer = null;
        this._byteOffset = 0;
      }
    }

    class GPUBufferBase {
      bufferType;
      buffer;
      memory;
      memoryNodes;
      seek;
      outFloat32Array;
      byteSize;
      usage;
      visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
      mapAsyncBuffersOutstanding = 0;
      mapAsyncReady;
      _readBuffer;
      _dataView;
      constructor() {
        this.mapAsyncReady = [];
      }
      debug() {
      }
      reset(clean = false, size = 0, data) {
        this.seek = 0;
        this.memory.reset();
        if (clean) {
          this.createBuffer(this.usage, size, data);
        }
      }
      setBoolean(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setX(v ? 1 : 0);
      }
      setFloat(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setX(v);
      }
      setInt8(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 1);
          this.memoryNodes.set(name, node);
        }
        node.setInt8(v);
      }
      setInt16(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 2);
          this.memoryNodes.set(name, node);
        }
        node.setInt16(v);
      }
      setInt32(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setInt32(v);
      }
      setUint8(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 1);
          this.memoryNodes.set(name, node);
        }
        node.setUint8(v);
      }
      setUint16(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 2);
          this.memoryNodes.set(name, node);
        }
        node.setUint16(v);
      }
      setUint32(name, v) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(1 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setUint32(v);
      }
      setVector2(name, v2) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(2 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setXY(v2.x, v2.y);
      }
      setVector3(name, v3) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(3 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setXYZ(v3.x, v3.y, v3.z);
      }
      setVector4(name, v4) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(4 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setXYZW(v4.x, v4.y, v4.z, v4.w);
      }
      setVector4Array(name, v4Array) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(4 * 4 * v4Array.length);
          this.memoryNodes.set(name, node);
        }
        node.setVector4Array(v4Array);
      }
      setColor(name, color) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(4 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setXYZW(color.r, color.g, color.b, color.a);
      }
      setColorArray(name, colorArray) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(4 * 4 * colorArray.length);
          this.memoryNodes.set(name, node);
        }
        node.setColorArray(colorArray);
      }
      setMatrix(name, mat) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(16 * 4);
          this.memoryNodes.set(name, node);
        }
        node.setFloat32Array(0, mat.rawData);
      }
      setMatrixArray(name, mats) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(16 * 4 * mats.length);
          this.memoryNodes.set(name, node);
        }
        for (let i = 0; i < mats.length; i++) {
          const mat = mats[i];
          node.setFloat32Array(i * 16, mat.rawData);
        }
      }
      setArray(name, data) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(data.length * 4);
          this.memoryNodes.set(name, node);
        }
        node.setArray(0, data);
      }
      setFloat32Array(name, data) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(data.length * 4);
          this.memoryNodes.set(name, node);
        }
        node.setFloat32Array(0, data);
      }
      setInt32Array(name, data) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(data.length * 4);
          this.memoryNodes.set(name, node);
        }
        node.setInt32Array(0, data);
      }
      setUint32Array(name, data) {
        let node = this.memoryNodes.get(name);
        if (!node) {
          node = this.memory.allocation_node(data.length * 4);
          this.memoryNodes.set(name, node);
        }
        node.setUint32Array(0, data);
      }
      setStruct(c, index, data, property) {
        let ref = Struct.Ref(c);
        Struct.GetSize(c);
        let name = index;
        let node = this.memoryNodes.get(name);
        node.reset();
        let obj = data;
        if (property) {
          obj = obj[property];
        }
        for (let i = 0; i < ref.length; i++) {
          const att = ref[i];
          let value = obj[att.name];
          this.writeValue(node, att, value);
        }
      }
      writeValue(node, att, value) {
        switch (att.type) {
          case `Boolean`:
            node.writeFloat(value);
            break;
          case `Number`:
            node.writeFloat(value);
            break;
          case `Float32Array`:
            node.writeFloat32Array(value);
            break;
          case `Vector2`:
            node.writeVector2(value);
            break;
          case `Vector3`:
            node.writeVector3(value);
            break;
          case `Vector4`:
            node.writeVector4(value);
            break;
          case `Color`:
            node.writeRGBColor(value);
            break;
          case `Array`:
            node.writeArray(value);
            break;
        }
      }
      setStructArray(c, dataList, property) {
        let len = dataList.length;
        for (let i = 0; i < len; i++) {
          const data = dataList[i];
          this.setStruct(c, i, data, property);
        }
      }
      // public writeFloat(v: number) {
      //     this.memory.shareFloat32Array[this.seek] = v;
      //     this.seek += 1;
      // }
      clean() {
        this._dataView.fill(0, 0, this._dataView.length);
      }
      apply() {
        webGPUContext.device.queue.writeBuffer(this.buffer, 0, this.memory.shareDataBuffer);
      }
      mapAsyncWrite(mapAsyncArray, len) {
        let device = webGPUContext.device;
        if (mapAsyncArray.length > 0) {
          let tBuffer = null;
          while (this.mapAsyncReady.length) {
            tBuffer = this.mapAsyncReady.shift();
            if (tBuffer["usedSize"] == mapAsyncArray.byteLength)
              break;
            tBuffer.destroy();
            this.mapAsyncBuffersOutstanding--;
            tBuffer = null;
          }
          if (!tBuffer) {
            tBuffer = device.createBuffer({
              size: mapAsyncArray.byteLength,
              usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,
              mappedAtCreation: true
            });
            tBuffer["usedSize"] = mapAsyncArray.byteLength;
            this.mapAsyncBuffersOutstanding++;
            if (this.mapAsyncBuffersOutstanding > 10) {
              console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`);
            }
          }
          let a = new Float32Array(mapAsyncArray.buffer, mapAsyncArray.byteOffset, len);
          let b = new Float32Array(tBuffer.getMappedRange(0, len * 4));
          b.set(a);
          tBuffer.unmap();
          const commandEncoder = device.createCommandEncoder();
          commandEncoder.copyBufferToBuffer(tBuffer, 0, this.buffer, 0, len * 4);
          device.queue.submit([commandEncoder.finish()]);
          tBuffer.mapAsync(GPUMapMode.WRITE).then(() => this.mapAsyncReady.push(tBuffer));
        }
      }
      destroy(force) {
        if (this.memoryNodes) {
          this.memoryNodes.forEach((v) => {
            v.destroy();
          });
        }
        this.bufferType = null;
        this.seek = null;
        this.byteSize = null;
        this.usage = null;
        this.visibility = null;
        this.outFloat32Array = null;
        if (this.buffer) {
          this.buffer.destroy();
        }
        this.buffer = null;
        if (this.memory) {
          this.memory.destroy();
        }
        this.memory = null;
        if (this._readBuffer) {
          this._readBuffer.destroy();
        }
      }
      createBuffer(usage, size, data, debugLabel) {
        let device = webGPUContext.device;
        if (this.buffer) {
          this.destroy();
        }
        this.byteSize = size * 4;
        this.usage = usage;
        this.buffer = device.createBuffer({
          label: debugLabel,
          size: this.byteSize,
          usage,
          mappedAtCreation: false
        });
        this.memory = new MemoryDO();
        this.memoryNodes = /* @__PURE__ */ new Map();
        this._dataView = new Float32Array(this.memory.shareDataBuffer);
        this.memory.allocation(this.byteSize);
        if (data) {
          let m = this.memory.allocation_node(data.length * 4);
          m.setArrayBuffer(0, data);
          this.apply();
        }
      }
      resizeBuffer(size, data) {
        this.createBuffer(this.usage, size, data);
      }
      createNewBuffer(usage, size) {
        let device = webGPUContext.device;
        let tByteSize = size * 4;
        let tUsage = usage;
        if (this.buffer) {
          this.destroy();
        }
        let buffer = device.createBuffer({
          size: tByteSize,
          usage: tUsage,
          mappedAtCreation: false
        });
        return buffer;
      }
      createBufferByStruct(usage, struct, count) {
        let structSize = Struct.GetSize(struct);
        let totalLength = structSize * count;
        let device = webGPUContext.device;
        this.buffer = device.createBuffer({
          label: "StructStorageGPUBuffer",
          size: totalLength,
          // size: totalLength * 4,
          usage,
          mappedAtCreation: false
        });
        this.memory = new MemoryDO();
        this.memoryNodes = /* @__PURE__ */ new Map();
        this._dataView = new Float32Array(this.memory.shareDataBuffer);
        this.memory.allocation(totalLength);
        for (let i = 0; i < count; i++) {
          let name = i;
          let node = this.memoryNodes.get(name);
          if (!node) {
            node = this.memory.allocation_node(structSize);
            this.memoryNodes.set(name, node);
          }
        }
      }
      _readFlag = false;
      readBuffer() {
        this.outFloat32Array ||= new Float32Array(this.memory.shareDataBuffer.byteLength / 4);
        if (!this._readBuffer) {
          this._readBuffer = webGPUContext.device.createBuffer({
            size: this.memory.shareDataBuffer.byteLength,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
            mappedAtCreation: false
          });
        }
        if (!this._readFlag) {
          this.read();
        }
        return this.outFloat32Array;
      }
      async read() {
        this._readFlag = true;
        let command = webGPUContext.device.createCommandEncoder();
        command.copyBufferToBuffer(this.buffer, 0, this._readBuffer, 0, this.memory.shareDataBuffer.byteLength);
        webGPUContext.device.queue.submit([command.finish()]);
        await this._readBuffer.mapAsync(GPUMapMode.READ);
        const copyArrayBuffer = this._readBuffer.getMappedRange();
        this.outFloat32Array.set(new Float32Array(copyArrayBuffer), 0);
        this._readBuffer.unmap();
        this._readFlag = false;
      }
    }

    var GPUBufferType = /* @__PURE__ */ ((GPUBufferType2) => {
      GPUBufferType2[GPUBufferType2["IndicesGPUBuffer"] = 0] = "IndicesGPUBuffer";
      GPUBufferType2[GPUBufferType2["VertexGPUBuffer"] = 1] = "VertexGPUBuffer";
      GPUBufferType2[GPUBufferType2["UniformGPUBuffer"] = 2] = "UniformGPUBuffer";
      GPUBufferType2[GPUBufferType2["StorageGPUBuffer"] = 3] = "StorageGPUBuffer";
      GPUBufferType2[GPUBufferType2["ComputeGPUBuffer"] = 4] = "ComputeGPUBuffer";
      GPUBufferType2[GPUBufferType2["MaterialDataUniformGPUBuffer"] = 5] = "MaterialDataUniformGPUBuffer";
      GPUBufferType2[GPUBufferType2["StructStorageGPUBuffer"] = 6] = "StructStorageGPUBuffer";
      return GPUBufferType2;
    })(GPUBufferType || {});

    class StorageGPUBuffer extends GPUBufferBase {
      constructor(size, usage = 0, data) {
        super();
        this.bufferType = GPUBufferType.StorageGPUBuffer;
        this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | usage, size, data, "StorageGPUBuffer");
      }
    }

    class UniformGPUBuffer extends GPUBufferBase {
      constructor(size, data) {
        super();
        this.bufferType = GPUBufferType.UniformGPUBuffer;
        this.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC, size, data, "UniformGPUBuffer");
      }
      genUniformNodes() {
      }
    }

    class MorphTarget_shader {
      static getMorphTargetShaderBinding(group, beginBinding) {
        return (
          /* wgsl */
          `
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${group}) @binding(${beginBinding})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${group}) @binding(${beginBinding + 1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${group}) @binding(${beginBinding + 2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`
        );
      }
      // public static getMorphTargetAttr(beginLocation: number): string {
      //     let value = `@location(${beginLocation}) vIndex: f32,`;
      //     return value;
      // }
      static getMorphTargetCalcVertex() {
        return (
          /* wgsl */
          `
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `
        );
      }
      static CsMain = (
        /* wgsl */
        `
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`
      );
    }

    let UUID = function(len = 16, radix = 16) {
      var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");
      var uuid = [], i;
      radix = radix || chars.length;
      if (len) {
        for (i = 0; i < len; i++)
          uuid[i] = chars[0 | Math.random() * radix];
      } else {
        var r;
        uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
        uuid[14] = "4";
        for (i = 0; i < 36; i++) {
          if (!uuid[i]) {
            r = 0 | Math.random() * 16;
            uuid[i] = chars[i == 19 ? r & 3 | 8 : r];
          }
        }
      }
      return uuid.join("");
    };
    let _instanceID = 1e6;
    let GetCountInstanceID = function() {
      _instanceID++;
      return _instanceID;
    };
    let ArrayHas = function(array, item) {
      let i = 0;
      let len = array.length;
      for (i = 0; i < len; i++) {
        const element = array[i];
        if (element == item) {
          return true;
        }
      }
      return false;
    };
    let ArrayItemIndex = function(array, item) {
      let i = 0;
      let len = array.length;
      for (i = 0; i < len; i++) {
        const element = array[i];
        if (element == item) {
          return i;
        }
      }
      return -1;
    };
    let mergeFunctions = (...funcs) => {
      return function(...args) {
        funcs.forEach((func) => func.apply(this, args));
      };
    };

    class Vector2 {
      /**
       * @internal
       */
      static HELP_0 = new Vector2();
      /**
       * @internal
       */
      static HELP_1 = new Vector2();
      /**
       * @internal
       */
      static HELP_2 = new Vector2();
      static ZERO = new Vector2(0, 0);
      static SAFE_MAX = new Vector2(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
      static SAFE_MIN = new Vector2(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
      /**
       * The x component of the vector, the default value is 0.
      */
      x = 0;
      /**
       * The y component of the vector, the default value is 0.
       */
      y = 0;
      /**
       * Create a new Vector2.
       * @param x The x component of the vector, which defaults to 0.
       * @param y The y component of the vector, which defaults to 0.
       */
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      /**
       * Returns the Angle, in radians, between two vectors.
       * @param a Vector a
       * @param b Vector b
       * @returns result
       */
      static getAngle(a, b) {
        return Math.atan2(b.y - a.y, b.x - a.x);
      }
      /**
       * Computes linear interpolation between two vectors.
       * @param from starting vector
       * @param to The vector in which you interpolate
       * @param t 
       */
      static slerp(from, to, t) {
        let v = new Vector2();
        let dot = from.dot(to);
        if (dot < 0) {
          to.x = -to.x;
          to.y = -to.y;
          dot = -dot;
        }
        if (dot > 0.9995) {
          v.x = from.x + t * (to.x - from.x);
          v.y = from.y + t * (to.y - from.y);
          return v;
        }
        let theta = Math.acos(dot);
        let sinTheta = Math.sin(theta);
        let scale0 = Math.sin((1 - t) * theta) / sinTheta;
        let scale1 = Math.sin(t * theta) / sinTheta;
        v.x = scale0 * from.x + scale1 * to.x;
        v.y = scale0 * from.y + scale1 * to.y;
        return v;
      }
      /**
       * Linear interpolation between two vectors.
       * @param from starting vector
       * @param to  The vector in which you interpolate
       * @param t 
       * @returns 
       */
      static lerp(from, to, t) {
        Vector2.HELP_0.copyFrom(from);
        Vector2.HELP_1.copyFrom(to);
        Vector2.HELP_0.scale(t);
        Vector2.HELP_1.scale(1 - t);
        return new Vector2(Vector2.HELP_0.x + Vector2.HELP_1.x, Vector2.HELP_0.y + Vector2.HELP_1.y);
      }
      /**
       * Sets the x and y components of this vector.
       * @param x The x component of the vector, which defaults to 0.
       * @param y The y component of the vector, which defaults to 0.
       */
      set(x = 0, y = 0) {
        this.x = x;
        this.y = y;
        return this;
      }
      /**
       * Calculate the distance between this vector and the incoming vector.
       * @param a Target vector
       * @returns
       */
      distance(a) {
        return Math.sqrt(Math.pow(this.x - a.x, 2) + Math.pow(this.y - a.y, 2));
      }
      /**
       * Add the vectors.
       * @param a
       * @param target
       * @returns
       */
      add(a, target) {
        target = target || new Vector2();
        target.x = this.x + a.x;
        target.y = this.y + a.y;
        return target;
      }
      /**
       * Vector subtraction
       * @param a
       * @param target
       * 
       */
      sub(a, target) {
        target = target || new Vector2();
        target.x = this.x - a.x;
        target.y = this.y - a.y;
        return target;
      }
      /**
       * Let's multiply the x and y values of this vector times v.
       * @param v 
       */
      scale(v) {
        this.x = this.x * v;
        this.y = this.y * v;
        return this;
      }
      /**
       * Let's multiply the x and y values of this vector by a.
       * @param a 
       * @param target 
       * @returns 
       */
      multiply(a, target) {
        target = target || new Vector2();
        target.x = this.x * a;
        target.y = this.y * a;
        return target;
      }
      /**
       * Let's multiply the x and y values of this vector by a.
       * @param a 
       * @param target 
       * @returns 
       */
      multiplyScaler(a) {
        this.x *= a;
        this.y *= a;
        return this;
      }
      /**
       * We're going to divide the x and y values of this vector by v.
       * @param v 
       * @param target 
       * @returns 
       */
      divide(v, target) {
        target = target || new Vector2();
        target.x = this.x / v;
        target.y = this.y / v;
        return target;
      }
      /**
       * Vector inversion
       * @param target 
       * @returns 
       */
      neg(target) {
        if (!target)
          target = new Vector2();
        target.x = -target.x;
        target.y = -target.y;
        return target;
      }
      abs() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      /**
       * Length of vector
       * @returns 
       */
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      /**
       * Returns the Angle, in radians, between the current vector and the target vector.
       * @param target Target vector
       * @returns 
       */
      getAngle(target) {
        return Math.atan2(target.y - this.y, target.x - this.x);
      }
      unt(target) {
        target = target || new Vector2();
        let d = this.abs();
        target.x = this.x / d;
        target.y = this.y / d;
        return target;
      }
      angleTo(v) {
        let dx = v.x - this.x;
        let dy = v.y - this.y;
        return Math.atan2(dy, dx);
      }
      /**
       * Whether two vectors are equal
       * @param a Vector of comparison
       * @returns 
       */
      equals(a) {
        if (Math.abs(this.x - a.x) < 1e-6 && Math.abs(this.y - a.y) < 1e-6)
          return true;
        return false;
      }
      pal(a) {
        let u1 = this.unt();
        let u2 = a.unt();
        if (u1.equals(u2))
          return 1;
        if (u1.equals(u2.neg()))
          return -1;
        return 0;
      }
      /**
       * Returns a new vector that has the same x and y as the current vector.
       * @returns 
       */
      clone() {
        return new Vector2(this.x, this.y);
      }
      /**
       * Copy the x and y properties of the source vector to this vector
       * @param v Source vector
       * @returns 
       */
      copyFrom(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
      /**
       * Take the dot product of two vectors.
       * @param value Target vector
       * @returns 
       */
      dot(value) {
        return this.x * value.x + this.y * value.y;
      }
      /**
       * Convert this vector to a unit vector.
       */
      normalize() {
        let d = this.abs();
        this.x = this.x / d;
        this.y = this.y / d;
        return this;
      }
      /**
       * Add two vectors
       * @param otherVector Additive vector
       * @returns 
       */
      addInPlace(otherVector) {
        this.x += otherVector.x;
        this.y += otherVector.y;
        return this;
      }
      /**
       * Add the scalar to the x and y of this vector.
       * @param s Additive scalar
       * @returns 
       */
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      /**
       * 
       * @param minVal Component will be limited to the minimum value of
       * @param maxVal The component will be limited to the maximum value of
       * @returns 
       */
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
    }

    class Vector4 {
      /**
       * The x axis defined as a Vector4 object with coordinates (1,0,0).
       */
      static X_AXIS = new Vector4(1, 0, 0);
      /**
       * The y axis defined as a Vector4 object with coordinates (0,1,0).
       */
      static Y_AXIS = new Vector4(0, 1, 0);
      /**
       * The z axis defined as a Vector4 object with coordinates (0,0,1).
       */
      static Z_AXIS = new Vector4(0, 0, 1);
      /**
       * @internal
       */
      static HELP_0 = new Vector4();
      /**
       * @internal
       */
      static HELP_1 = new Vector4();
      /**
       * @internal
       */
      static HELP_2 = new Vector4();
      /**
       * @internal
       */
      static EPSILON = 1e-5;
      /**
       * @internal
       */
      static HELP_3 = new Vector4();
      /**
       * @internal
       */
      static HELP_4 = new Vector4();
      /**
       * @internal
       */
      static HELP_5 = new Vector4();
      /**
       * @internal
       */
      static HELP_6 = new Vector4();
      static ZERO = new Vector4();
      static ONE = new Vector4(1, 1, 1, 1);
      static LEFT = new Vector4(-1, 0, 0);
      static RIGHT = new Vector4(1, 0, 0);
      static UP = new Vector4(0, -1, 0);
      static DOWN = new Vector4(0, 1, 0);
      static BACK = new Vector4(0, 0, -1);
      static FORWARD = new Vector4(0, 0, 1);
      /**
       * @language en_US
       * The first element of a Vector4 object, such as the x coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      x = 0;
      /**
       * @language en_US
       * The second element of a Vector4 object, such as the y coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      y = 0;
      /**
       * @language en_US
       * The third element of a Vector4 object, such as the y coordinate of
       * a point in the three-dimensional space. The default value is 0.
       */
      z = 0;
      /**
       * A three-dimensional position or projection that can be used as 
       * a perspective projection can also be a w in a quaternion
       * @version Orillusion3D  0.5.1
       */
      w = 1;
      constructor(x = 0, y = 0, z = 0, w = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      get width() {
        return this.z;
      }
      get height() {
        return this.w;
      }
      static crossVectors(a, b, target) {
        target = target || new Vector4();
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        target.x = ay * bz - az * by;
        target.y = az * bx - ax * bz;
        target.z = ax * by - ay * bx;
        return target;
      }
      static distance(pt1, pt2) {
        let x = pt1.x - pt2.x;
        let y = pt1.y - pt2.y;
        let z = pt1.z - pt2.z;
        let w = pt1.w - pt2.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      }
      set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
      copyFrom(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
        return this;
      }
      clone() {
        return new Vector4(this.x, this.y, this.z, this.w);
      }
    }

    var UniformType = /* @__PURE__ */ ((UniformType2) => {
      UniformType2[UniformType2["Number"] = 0] = "Number";
      UniformType2[UniformType2["Vector2"] = 1] = "Vector2";
      UniformType2[UniformType2["Vector3"] = 2] = "Vector3";
      UniformType2[UniformType2["Vector4"] = 3] = "Vector4";
      UniformType2[UniformType2["Color"] = 4] = "Color";
      UniformType2[UniformType2["Float32Array"] = 5] = "Float32Array";
      return UniformType2;
    })(UniformType || {});

    class UniformNode {
      size;
      memoryInfo;
      bindOnChange;
      _data;
      _type = UniformType.Number;
      _x = 0;
      _y = 0;
      _z = 0;
      _w = 0;
      constructor(value) {
        this.data = value;
      }
      get data() {
        return this._data;
      }
      set data(value) {
        this._data = value;
        this._type = UniformType.Number;
        if (value instanceof Vector2) {
          this.size = 2;
          this._x = value.x;
          this._y = value.y;
          this._type = UniformType.Vector2;
        } else if (value instanceof Vector3) {
          this.size = 3;
          this._x = value.x;
          this._y = value.y;
          this._z = value.z;
          this._type = UniformType.Vector3;
        } else if (value instanceof Vector4) {
          this.size = 4;
          this._x = value.x;
          this._y = value.y;
          this._z = value.z;
          this._w = value.w;
          this._type = UniformType.Vector4;
        } else if (value instanceof Color) {
          this.size = 4;
          this._x = value.r;
          this._y = value.g;
          this._z = value.b;
          this._w = value.a;
          this._type = UniformType.Color;
        } else if (value instanceof Float32Array) {
          this.size = value.length;
          this._type = UniformType.Float32Array;
        } else {
          this.size = 1;
          this._x = value;
          this._data = value;
          this._type = UniformType.Number;
        }
      }
      getColor(ret) {
        if (ret) {
          ret.copyFrom(this._data);
        } else {
          ret = this._data;
        }
        return ret;
      }
      get color() {
        let c = new Color(this._data.r, this._data.g, this._data.b, this._data.a);
        return c;
      }
      set color(value) {
        if (this._x != value.r || this._y != value.g || this._z != value.b || this._w != value.a) {
          this._data.r = value.r;
          this._data.g = value.g;
          this._data.b = value.b;
          this._data.a = value.a;
          this._x = value.r;
          this._y = value.g;
          this._z = value.b;
          this._w = value.a;
          this.onChange();
        }
      }
      get value() {
        return this._x;
      }
      set value(value) {
        if (this._x != value) {
          this._data = value;
          this._x = value;
          this.onChange();
        }
      }
      get vector2() {
        return this._data;
      }
      set vector2(value) {
        if (this._x != value.x || this._y != value.y) {
          this._data.x = value.x;
          this._data.y = value.y;
          this._x = value.x;
          this._y = value.y;
          this.onChange();
        }
      }
      get vector3() {
        return this._data;
      }
      set vector3(value) {
        if (this._x != value.x || this._y != value.y || this._z != value.z) {
          this._data.x = value.x;
          this._data.y = value.y;
          this._data.z = value.z;
          this._x = value.x;
          this._y = value.y;
          this._z = value.z;
          this.onChange();
        }
      }
      get vector4() {
        return this._data;
      }
      set vector4(value) {
        if (this._x != value.x || this._y != value.y || this._z != value.z || this._w != value.w) {
          this._data.x = value.x;
          this._data.y = value.y;
          this._data.z = value.z;
          this._data.w = value.w;
          this._x = value.x;
          this._y = value.y;
          this._z = value.z;
          this._w = value.w;
          this.onChange();
        }
      }
      onChange() {
        if (this.bindOnChange) {
          this.bindOnChange();
        }
      }
      float32Array(value) {
        this._data.set(value);
        this.onChange();
      }
      update() {
        switch (this._type) {
          case UniformType.Number:
            this.memoryInfo.dataBytes.setFloat32(0 * Float32Array.BYTES_PER_ELEMENT, this._data, true);
            break;
          case UniformType.Vector2:
            this.memoryInfo.setVector2(0, this._data);
            break;
          case UniformType.Vector3:
            this.memoryInfo.setVector3(0, this._data);
            break;
          case UniformType.Vector4:
            this.memoryInfo.setVector4(0, this._data);
            break;
          case UniformType.Color:
            this.memoryInfo.setColor(0, this._data);
            break;
          case UniformType.Float32Array:
            this.memoryInfo.setFloat32Array(0, this._data);
            break;
        }
      }
    }

    class ShaderPassBase {
      /**
       * Shader Unique instance id
       */
      instanceID;
      /**
       * Shader variant value
       */
      shaderVariant;
      /**
       * Vertex stage entry point name
       */
      vsEntryPoint = `main`;
      /**
       * Fragment stage entry point name
       */
      fsEntryPoint = `main`;
      /**
       * BindGroup collection 
       */
      bindGroups;
      /**
       * Shader reflection info
       */
      shaderReflection;
      /**
       * The defined syntax value of the Shader when it is precompiled
       */
      defineValue;
      /**
       * The constant value of the Shader when it is precompiled
       */
      constValues;
      /**
       * Uniforms data collection
       */
      uniforms;
      /**
         * Uniform data for materials
         */
      materialDataUniformBuffer;
      _bufferDic;
      _shaderChange = true;
      _valueChange = false;
      constructor() {
        this.instanceID = UUID();
        this.defineValue = {};
        this.constValues = {};
        this.uniforms = {};
        this._bufferDic = /* @__PURE__ */ new Map();
      }
      /**
       * notice shader change
       */
      noticeShaderChange() {
        this._shaderChange = true;
      }
      /**
       * notice shader state change
       */
      noticeValueChange() {
        this._valueChange = true;
      }
      /**
      * set storage gpu buffer
      * @param name buffer name
      * @param buffer storage useAge gpu buffer
      */
      setStorageBuffer(name, buffer) {
        if (!this._bufferDic.has(name)) {
          this._bufferDic.set(name, buffer);
          this.noticeBufferChange(name);
        } else {
          this._bufferDic.set(name, buffer);
        }
      }
      /**
       * set struct storage gpu buffer
       * @param name buffer name
       * @param buffer struct storage useAge gpu buffer
       */
      setStructStorageBuffer(name, buffer) {
        if (this._bufferDic.has(name)) {
          this._bufferDic.set(name, buffer);
          this.noticeBufferChange(name);
        } else {
          this._bufferDic.set(name, buffer);
        }
      }
      /**
       * set uniform gpu buffer min size 256
       * @param name
       * @param buffer
       */
      setUniformBuffer(name, buffer) {
        if (this._bufferDic.has(name)) {
          this._bufferDic.set(name, buffer);
          this.noticeBufferChange(name);
        } else {
          this._bufferDic.set(name, buffer);
        }
      }
      /**
       * set define value
       * @param defineName 
       * @param value 
       */
      setDefine(defineName, value) {
        if (this.defineValue[defineName] == null || this.defineValue[defineName] != value) {
          this.defineValue[defineName] = value;
          this.noticeValueChange();
          this.noticeShaderChange();
        }
        this.defineValue[defineName] = value;
      }
      /**
       * Whether there is a define key
       * @param defineName 
       * @returns 
       */
      hasDefine(defineName) {
        return this.defineValue[defineName] != null;
      }
      /**
       * delete define value
       * @param defineName 
       */
      deleteDefine(defineName) {
        delete this.defineValue[defineName];
        this.noticeShaderChange();
      }
      /**
       * set uniform float value
       * @param name 
       * @param value 
       */
      setUniformFloat(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
          this.noticeValueChange();
        } else {
          this.uniforms[name].value = value;
        }
      }
      /**
       * set uniform vector2 value
       * @param name 
       * @param value 
       */
      setUniformVector2(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
          this.noticeValueChange();
        } else {
          this.uniforms[name].vector2 = value;
        }
      }
      /**
       * set uniform vector3 value
       * @param name 
       * @param value 
       */
      setUniformVector3(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
        } else {
          this.uniforms[name].vector3 = value;
        }
      }
      /**
       * set uniform vector4 value
       * @param name 
       * @param value 
       */
      setUniformVector4(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
        } else {
          this.uniforms[name].vector4 = value;
        }
      }
      /**
       * set uniform color value
       * @param name 
       * @param value 
       */
      setUniformColor(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
        } else {
          this.uniforms[name].color = value;
        }
      }
      /**
       * set uniform array value
       * @param name 
       * @param value 
       */
      setUniformArray(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
        } else {
          this.uniforms[name].float32Array(value);
        }
      }
      setUniform(name, value) {
        if (!this.uniforms[name]) {
          this.uniforms[name] = new UniformNode(value);
        } else {
          this.uniforms[name].data = value;
        }
      }
      getUniform(name) {
        return this.uniforms[name].data;
      }
      getUniformFloat(name) {
        return this.uniforms[name].data;
      }
      getUniformVector2(name) {
        return this.uniforms[name].data;
      }
      getUniformVector3(name) {
        return this.uniforms[name].data;
      }
      getUniformVector4(name) {
        return this.uniforms[name].data;
      }
      getUniformColor(name) {
        return this.uniforms[name].color;
      }
      getBuffer(name) {
        return this._bufferDic[name].data;
      }
      noticeBufferChange(name) {
      }
      applyUniform() {
        if (this.materialDataUniformBuffer && this._valueChange) {
          this.materialDataUniformBuffer.apply();
        }
      }
      /**
       * destroy
       */
      destroy(force) {
      }
    }

    var VertexAttributeSize = /* @__PURE__ */ ((VertexAttributeSize2) => {
      VertexAttributeSize2[VertexAttributeSize2["u32"] = 1] = "u32";
      VertexAttributeSize2[VertexAttributeSize2["f32"] = 1] = "f32";
      VertexAttributeSize2[VertexAttributeSize2["vec2<f32>"] = 2] = "vec2<f32>";
      VertexAttributeSize2[VertexAttributeSize2["vec3<f32>"] = 3] = "vec3<f32>";
      VertexAttributeSize2[VertexAttributeSize2["vec4<f32>"] = 4] = "vec4<f32>";
      VertexAttributeSize2[VertexAttributeSize2["float32"] = 1] = "float32";
      VertexAttributeSize2[VertexAttributeSize2["float32x2"] = 2] = "float32x2";
      VertexAttributeSize2[VertexAttributeSize2["float32x3"] = 3] = "float32x3";
      VertexAttributeSize2[VertexAttributeSize2["float32x4"] = 4] = "float32x4";
      return VertexAttributeSize2;
    })(VertexAttributeSize || {});

    let VertexFormat = [null, GPUVertexFormat.float32, GPUVertexFormat.float32x2, GPUVertexFormat.float32x3, GPUVertexFormat.float32x4];

    let ClusterDebug_frag = (
      /*wgsl*/
      `
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `
    );

    class CubeSky_Shader {
      static sky_vs_frag_wgsl = (
        /* wgsl */
        `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(auto) fragUV: vec2<f32>,
      @location(auto) vWorldPos: vec4<f32>,
      @location(auto) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(auto) position: vec3<f32>,
      @location(auto) normal: vec3<f32>,
      @location(auto) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = globalUniform.viewMat * modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;

      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `
      );
      static sky_fs_frag_wgsl = (
        /* wgsl */
        `
    #include "GlobalUniform"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        #if USE_WORLDPOS
          @location(auto) o_Position: vec4<f32>,
        #endif
        #if USEGBUFFER
          @location(auto) o_Normal: vec4<f32>,
          @location(auto) o_Material: vec4<f32>
        #endif
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
        textureColor = LinearToGammaSpace(textureColor);
        #endif
        let o_Target: vec4<f32> =vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        var normal_rgba8unorm = (vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));

        return FragmentOutput(
          o_Target,
          #if USE_WORLDPOS
              vWorldPos,
          #endif
          #if USEGBUFFER
              vec4<f32>(normal_rgba8unorm,0.0),
              vec4<f32>(0.0,1.0,0.0,0.0)
          #endif
        );
    }
    `
      );
    }

    let LightingFunction_frag = (
      /*wgsl*/
      `
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const LUMEN = 10.764;



fn calcAttenuation( d : f32 ,  falloffStart : f32 ,  falloffEnd : f32)-> f32
{
    // Linear falloff.
    return saturate((falloffEnd-d) / (falloffEnd - falloffStart));
}

fn directLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = -normalize(light.direction.xyz) ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var att = light.intensity / LUMEN ;
      if(light.castShadow>=0){
          #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  att *= shadowStrut.directShadowVisibility[j] ; 
                }
            }
          #endif
      }

      #if USE_LAMBERT
        color = vec3<f32>(1.0,1.0,1.0) ;
      #endif 
      
      #if USE_BRDF
        color = simpleBRDF(albedo,N,V,L,att,lightColor,roughness,metallic) ;
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity / LUMEN ;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= shadowStrut.directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) * light.intensity / LUMEN;
        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
              // atten *= shadowStrut.pointShadows[light.castShadow] ; 
              for (var j: i32 = 0; j < 8; j += 1) {
                  if(j == light.castShadow){
                    atten *= shadowStrut.pointShadows[j] ; 
                  }
              }
            #endif
        }

        #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
        #endif

        var lightColor = light.lightColor.rgb  ;
        lightColor = getHDRColor(lightColor , light.linear )  ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,1.0,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic))  ;
        #endif 
    } 
    return color ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, roughness:f32 , metallic:f32 ,light:LightData ) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.1) * light.intensity / LUMEN;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        if( light.castShadow >= 0 )
        {
            #if USE_SHADOWMAPING
            for (var j: i32 = 0; j < 8; j += 1) {
                if(j == light.castShadow){
                  atten *= shadowStrut.pointShadows[j] ; 
                }
            }
          #endif
        }

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        lightColor = getHDRColor(lightColor , light.linear ) ;

        #if USE_LAMBERT
          color = vec3<f32>(1.0,0.5,1.0) ;
        #endif 

        #if USE_BRDF
          color = (simpleBRDF(albedo,N,V,L,atten,lightColor,roughness,metallic)) ;
        #endif 
    }
    return  color ;
}
`
    );

    let MathShader = (
      /* wgsl */
      `


fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2<f32>
  {
    var dir = vec3<f32>(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2(u, v);
  }

    // Returns ±1
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth:f32, near:f32, far:f32) -> f32 {
      let Fcoef:f32 = 2.0 / log2(far + 1.0);
      var result:f32 = (log2(max(1e-6, 1.0 + depth)) * Fcoef - 1.0);
      result = (1.0 + result) / 2.0;
      return result * depth;
    }

    fn log2DepthFixPersp(depth:f32, near:f32, far:f32) -> f32 {
      let flogz:f32 = 1.0 + depth;
      let Fcoef_half:f32 = (2.0 / log2(far + 1.0)) * 0.5;
      var result:f32 = log2(flogz) * Fcoef_half;
      result = (1.0 + result) / 2.0;
      return result;
    }


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

`
    );

    let PhysicMaterialUniform_frag = (
      /* wgsl */
      `
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  transformUV1:vec4<f32>,
                  transformUV2:vec4<f32>,

                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,
                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,
                  ao: f32,

                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,
                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,
                  clearcoatColor: vec4<f32>,
                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `
    );

    let UnLitMaterialUniform_frag = (
      /* wgsl */
      `


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`
    );

    let UnLit_frag = (
      /*wgsl*/
      `
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;

        #if USE_WORLDPOS
            ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
        #endif

        #if USEGBUFFER
            var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
            normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
            ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
            ORI_FragmentOutput.material = vec4<f32>(1.0,1.0,0.0,1.0);
        #endif
    }

    fn debugFragmentOut(){

    }
`
    );

    class SkeletonAnimation_shader {
      static groupBindingAndFunctions(beginGroup, beginBinding) {
        return (
          /* wgsl */
          `
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${beginGroup}) @binding(${beginBinding})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${beginGroup}) @binding(${beginBinding + 1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${beginGroup}) @binding(${beginBinding + 2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `
        );
      }
    }

    let VertexAttributes = (
      /*wgsl*/
      `
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${MorphTarget_shader.getMorphTargetShaderBinding(3, 0)}
        ${SkeletonAnimation_shader.groupBindingAndFunctions(3, 2)} 
    #else
        #if USE_MORPHTARGETS
            ${MorphTarget_shader.getMorphTargetShaderBinding(3, 0)}
        #endif

        #if USE_SKELETON
            ${SkeletonAnimation_shader.groupBindingAndFunctions(3, 0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #else
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(auto) index: f32,
    @location(auto) varying_UV0: vec2<f32>,
    @location(auto) varying_UV1: vec2<f32>,
    @location(auto) varying_ViewPos: vec4<f32>,
    @location(auto) varying_Clip: vec4<f32>,
    @location(auto) varying_WPos: vec4<f32>,
    @location(auto) varying_WNormal: vec3<f32>,
    @location(auto) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(auto) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(auto) varying_Tangent: vec4<f32>,
    #endif
   

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${MorphTarget_shader.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${MorphTarget_shader.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    #if USE_LOGDEPTH
        clipPosition.z = log2Depth(clipPosition.w, globalUniform.near, globalUniform.far);
    #endif

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`
    );

    let VideoUniform_frag = (
      /* wgsl */
      `
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`
    );

    let IrradianceVolumeData_frag = (
      /*wgsl*/
      `
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`
    );

    let Inline_vert = (
      /*wgsl*/
      `
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    var<private> TIME: vec4<f32>;
    var<private> MOUSE: vec4<f32>;
    var<private> SCREEN: vec4<f32>;

    var<private> ProjectionParams: vec4<f32>;

    fn vertex_inline(vertex:VertexAttributes){
        TIME.x = globalUniform.frame;
        TIME.y = globalUniform.time;
        TIME.z = globalUniform.delta;

        MOUSE.x = globalUniform.mouseX;
        MOUSE.y = globalUniform.mouseY;

        SCREEN.x = globalUniform.windowWidth;
        SCREEN.y = globalUniform.windowHeight;

        ProjectionParams.x = globalUniform.near;
        ProjectionParams.y = globalUniform.far;
        ProjectionParams.z = 1.0 + 1.0 / globalUniform.far;

        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`
    );

    let Common_frag = (
      /*wgsl*/
      `
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "ColorPassFragmentOutput"
  #include "ShadingInput"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
    #if USE_WORLDPOS
      ORI_FragmentOutput.worldPos = ORI_VertexVarying.vWorldPos;
    #endif
    #if USEGBUFFER
      ORI_FragmentOutput.worldNormal = vec4<f32>(ORI_ShadingInput.Normal.rgb ,1.0); 
      ORI_FragmentOutput.material = vec4<f32>(0.0,1.0,0.0,0.0);
    #endif
    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2DepthFixPersp(ORI_VertexVarying.fragPosition.w, globalUniform.near, globalUniform.far);
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


`
    );

    let Common_vert = (
      /*wgsl*/
      `
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`
    );

    let BrdfLut_frag = (
      /*wgsl*/
      `
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`
    );

    let EnvMap_frag = (
      /*wgsl*/
      `
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`
    );

    class CSM {
      static Cascades = 4;
    }

    let GlobalUniform = (
      /*wgsl*/
      `

  struct GlobalUniform {
    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,
    csmShadowBias: vec4<f32>,
    csmMatrix: array<mat4x4<f32>,${CSM.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    CameraPos: vec3<f32>,
    frame: f32,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,

    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    empty1: i32,
    empty2: i32,
    empty3: i32,

    frustumPlanes: array<vec4f, 6u>,
  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;
`
    );

    let InstanceUniform = (
      /*wgsl*/
      `
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`
    );

    let WorldMatrixUniform = (
      /*wgsl*/
      `
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`
    );

    let FastMathShader = (
      /*wgsl*/
      `
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`
    );

    let NormalMap_frag = (
      /*wgsl*/
      `

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`
    );

    let FragmentVarying = (
      /*wgsl*/
      `
    struct FragmentVarying {
        @location(auto) index: f32,
        @location(auto) fragUV0: vec2<f32>,
        @location(auto) fragUV1: vec2<f32>,
        @location(auto) viewPosition: vec4<f32>,
        @location(auto) fragPosition: vec4<f32>,
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) vWorldNormal: vec3<f32>,
        @location(auto) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(auto) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`
    );

    let ColorPassFragmentOutput = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        #endif
        #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        #endif

        #if USE_OUTDEPTH
            @builtin(frag_depth) out_depth: f32
        #endif
    };
`
    );

    let ShadingInput = (
      /*wgsl*/
      `
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,
    }
`
    );

    let IESProfiles_frag = (
      /*wgsl*/
      `
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`
    );

    let ShadowMapping_frag = (
      /*wgsl*/
      `
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    struct ShadowStruct{
      directShadowVisibility: array<f32, 8>,
      pointShadows: array<f32, 8>,
    }
    var<private> shadowStrut: ShadowStruct ;

    fn useShadow(){
        shadowStrut.directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        shadowStrut.pointShadows = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        #if USE_SHADOWMAPING
          directShadowMaping(globalUniform.shadowBias);
          pointShadowMapCompare(globalUniform.pointShadowBias);
        #endif
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${CSM.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {

        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm];
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            shadowStrut.directShadowVisibility[i] = visibility;
          }
        }

    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        visibility = 0.0;
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var totalWeight = 0.0;
        var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
        let v = max(NoL, 0.0) ;
        var bias = shadowBias / v;
        for (var y = -1; y <= 1; y++) {
          for (var x = -1; x <= 1; x++) {
            var offset = vec2<f32>(f32(x), f32(y)) * uvOnePixel;
            
            // visibility += textureSampleCompare(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, shadowPos.z - bias);
            var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offset, depthTexIndex, 0);
            if ((shadowPos.z - bias ) < depth) {
              visibility += 1.0 ;
            }
            totalWeight += 1.0;
          }
        }
        visibility /= totalWeight;
        visibility += 0.001;
      }
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              let sampleOffset = offset / (samples * 0.5);
              for (var x: f32 = -offset; x < offset; x += sampleOffset) {
                for (var y: f32 = -offset; y < offset; y += sampleOffset) {
                  for (var z: f32 = -offset; z < offset; z += sampleOffset) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
                shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
            #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    shadowStrut.pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`
    );

    let Irradiance_frag = (
      /*wgsl*/
      `
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`
    );

    let BRDF_frag = (
      /*wgsl*/
      `
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness ;//pow(roughness,5.0) ;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo , metallic);
        let D = DistributionGGX( Context.NoH , alpha);
        let G = GeometrySmith(Context.NoV,Context.NoL, alpha );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return (col.rgb) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        // var prefilteredColor: vec3<f32> = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return fragData.EnvColor * (specularColor.rgb * envBRDF.x + saturate( 50.0 * specularColor.g ) * envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity / LUMEN ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let NdotV = max(dot(N,V),0.0);
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));

        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);

        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }
`
    );

    let BxDF_frag = (
      /*wgsl*/
      `
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;


      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * vec3f(kdLast) * fragData.Albedo.rgb ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      // ORI_FragmentOutput.color = vec4<f32>(ORI_FragmentOutput.color.xyz,fragData.Albedo.a) ;
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
          // ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,1.0,1.0);
      #endif
      
      var color = specColor + indirectResult ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      var retColor = (LinearToGammaSpace(color.rgb));
      retColor += fragData.Emissive.xyz ;
      ORI_FragmentOutput.color = vec4<f32>( retColor.rgb * fragData.Albedo.a ,fragData.Albedo.a) ;
  }

  `
    );

    let Clearcoat_frag = (
      /*wgsl*/
      `
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatRoughness;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , ior:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatStrength:f32, clearCoatPerceptualRoughness:f32 , att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor * factor;

        let H = normalize(-V + L);
        let R = 2.0 * dot( -V , N ) * N + V ;
        let LoH = dot(L,H);
        let NoV = max(dot(N,-V),0.0);
        let NoL = max(dot(N,L),0.0);
        let NoH = max(dot(N,H),0.00001);

        let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(0.0) , clearCoatRoughness ) ;
        var Fd = clearCoatColor / 3.1415926 ;
        let F0 = IORToF0(ior) ;
        // clear coat BRDF
        var Dc = D_GGX(NoH,clearCoatRoughness);
        var Vc = V_Kelemen(LoH) * NoL;
        var Fc = F_Schlick( vec3<f32>(F0) , 1.0, NoV) * materialUniform.clearcoatFactor;
        var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        let oneMinusFc  = 1.0 - Fc;
        let brdfSpecular = ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att ; 
        var iblSpecular = vec3<f32>(brdfSpecular);
        iblSpecular += approximateSpecularIBL(vec3<f32>(1.0),clearCoatRoughness,R, NoV) * Fc ;
        return vec3<f32>(mix(baseColor,iblSpecular,materialUniform.clearcoatWeight));
    }
    #endif
`
    );

    let Lit_shader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`
    );

    let PBRLItShader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = gammaToLiner(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb,ORI_ShadingInput.BaseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        useShadow();

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif


        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;

        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`
    );

    let BxdfDebug_frag = (
      /*wgsl*/
      `
#include "ClusterDebug_frag" 

        fn debugPosition(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
            // ORI_FragmentOutput.color = vec4<f32>(0.2,0.2,0.2,1.0);
        }

        fn debugAmbient(){
            ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`
    );

    let FullQuad_vert_wgsl = (
      /*wgsl*/
      `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`
    );
    let Quad_vert_wgsl = (
      /*wgsl*/
      `
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(auto) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`
    );
    let Quad_frag_wgsl = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`
    );
    let Quad_depth2d_frag_wgsl = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`
    );
    let Quad_depthCube_frag_wgsl = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`
    );
    let Quad_depth2dArray_frag_wgsl = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array ;

    struct MaterialData{
        index:f32;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
    
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`
    );

    let ColorUtil = (
      /*wgsl*/
      `
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        // var newColor = color * (  1.0 / 255.0 ) ;
        return color * pow(2.4, exposure) ;
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r, 0.416666667);
        linRGB.g = pow(linRGB.g, 0.416666667);
        linRGB.b = pow(linRGB.b, 0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }
`
    );

    let GenerayRandomDir = (
      /*wgsl*/
      `
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`
    );

    let MatrixShader = (
      /* wgsl */
      `
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildYRotateXMat4(radY:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            x,y,z,1.0,
        );
        return yRot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`
    );

    let ClusterLight = (
      /*wgsl*/
      `
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`
    );

    let Hair_frag = (
      /*wgsl*/
      `
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt / LUMEN) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              // var shadow = 0.0 ;
              // if(light.castShadow>=0){
              //     #if USE_SHADOWMAPING
              //       shadow = shadowStrut.directShadowVisibility[i32(light.castShadow)] ; 
              //     #endif
              // }

              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `
    );

    let BsDF_frag = (
      /*wgsl*/
      `
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity / LUMEN ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `
    );

    let UnLit = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < 0.5){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        
        UnLit();

        // ORI_FragmentOutput.color = vec4<f32>( 1.0,0.0,0.0,1.0) ;
    }
`
    );

    let Lambert_shader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < 0.5){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor ;
        ORI_ShadingInput.BaseColor.w = 1.0 ;
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`
    );

    let QuadGlsl_vs = (
      /* wgsl */
      `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`
    );
    let QuadGlsl_fs = (
      /* wgsl */
      `
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`
    );

    let SkyGBuffer_pass = (
      /*wgsl*/
      `
#include "GlobalUniform"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32>) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`
    );

    let GBuffer_pass = (
      /*wgsl*/
      `
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`
    );

    let shadowCastMap_vert = (
      /*wgsl*/
      `
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${MorphTarget_shader.getMorphTargetShaderBinding(2, 1)}
#endif

#if USE_SKELETON
    ${SkeletonAnimation_shader.groupBindingAndFunctions(2, 1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(auto) position: vec3<f32>,
    @location(auto) normal: vec3<f32>,
    @location(auto) uv: vec2<f32>,
    @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${MorphTarget_shader.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`
    );
    let castPointShadowMap_vert = (
      /*wgsl*/
      `
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @location(auto) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${MorphTarget_shader.getMorphTargetShaderBinding(2, 1)}
##endif
 
#if USE_SKELETON
    ${SkeletonAnimation_shader.groupBindingAndFunctions(2, 1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(auto) position: vec3<f32>,
  @location(auto) normal: vec3<f32>,
  @location(auto) uv: vec2<f32>,
  @location(auto) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #else
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #endif
    #else
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            @location(auto) vIndex: f32,
        #else
            @location(auto) vIndex: f32,
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${MorphTarget_shader.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${MorphTarget_shader.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`
    );
    let shadowCastMap_frag = (
      /*wgsl*/
      `
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`
    );
    let directionShadowCastMap_frag = (
      /*wgsl*/
      `
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`
    );

    let ZPassShader_vs = (
      /*wgsl*/
      `
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(auto) vID: f32 ,
        @location(auto) vPos: vec3<f32> ,
        @location(auto) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${MorphTarget_shader.getMorphTargetShaderBinding(1, 0)}
    #endif

    #if USE_SKELETON
        ${SkeletonAnimation_shader.groupBindingAndFunctions(1, 0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            @location(auto) vIndex: f32,
        #endif
    #elseif USE_SKELETON
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(auto) joints1: vec4<f32>,
            @location(auto) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        @location(auto) vIndex: f32,
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${MorphTarget_shader.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`
    );

    let ZPassShader_fs = (
      /*wgsl*/
      `
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(auto) vID: f32, @location(auto) vPos:vec3<f32> ,  @location(auto) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`
    );

    class ShaderLib {
      static init() {
        ShaderLib.register("MathShader", MathShader);
        ShaderLib.register("FastMathShader", FastMathShader);
        ShaderLib.register("MatrixShader", MatrixShader);
        ShaderLib.register("GlobalUniform", GlobalUniform);
        ShaderLib.register("WorldMatrixUniform", WorldMatrixUniform);
        ShaderLib.register("NormalMap_frag", NormalMap_frag);
        ShaderLib.register("LightingFunction_frag", LightingFunction_frag);
        ShaderLib.register("PhysicMaterialUniform_frag", PhysicMaterialUniform_frag);
        ShaderLib.register("UnLitMaterialUniform_frag", UnLitMaterialUniform_frag);
        ShaderLib.register("VideoUniform_frag", VideoUniform_frag);
        ShaderLib.register("InstanceUniform", InstanceUniform);
        ShaderLib.register("Inline_vert", Inline_vert);
        ShaderLib.register("VertexAttributes_vert", VertexAttributes);
        ShaderLib.register("Common_vert", Common_vert);
        ShaderLib.register("Common_frag", Common_frag);
        ShaderLib.register("FragmentVarying", FragmentVarying);
        ShaderLib.register("ColorPassFragmentOutput", ColorPassFragmentOutput);
        ShaderLib.register("ClusterLight", ClusterLight);
        ShaderLib.register("ShadingInput", ShadingInput);
        ShaderLib.register("IESProfiles_frag", IESProfiles_frag);
        ShaderLib.register("ShadowMapping_frag", ShadowMapping_frag);
        ShaderLib.register("Irradiance_frag", Irradiance_frag);
        ShaderLib.register("IrradianceVolumeData_frag", IrradianceVolumeData_frag);
        ShaderLib.register("BrdfLut_frag", BrdfLut_frag);
        ShaderLib.register("EnvMap_frag", EnvMap_frag);
        ShaderLib.register("ColorUtil_frag", ColorUtil);
        ShaderLib.register("ColorUtil", ColorUtil);
        ShaderLib.register("BRDF_frag", BRDF_frag);
        ShaderLib.register("Hair_frag", Hair_frag);
        ShaderLib.register("BxDF_frag", BxDF_frag);
        ShaderLib.register("BsDF_frag", BsDF_frag);
        ShaderLib.register("UnLit_frag", UnLit_frag);
        ShaderLib.register("UnLit", UnLit);
        ShaderLib.register("Clearcoat_frag", Clearcoat_frag);
        ShaderLib.register("LitShader", Lit_shader);
        ShaderLib.register("PBRLItShader", PBRLItShader);
        ShaderLib.register("ClusterDebug_frag", ClusterDebug_frag);
        ShaderLib.register("BxdfDebug_frag", BxdfDebug_frag);
        ShaderLib.register("GenerayRandomDir", GenerayRandomDir);
        ShaderLib.register("Quad_vert_wgsl", Quad_vert_wgsl);
        ShaderLib.register("Quad_frag_wgsl", Quad_frag_wgsl);
        ShaderLib.register("Quad_depth2d_frag_wgsl", Quad_depth2d_frag_wgsl);
        ShaderLib.register("Quad_depthCube_frag_wgsl", Quad_depthCube_frag_wgsl);
        ShaderLib.register("sky_vs_frag_wgsl", CubeSky_Shader.sky_vs_frag_wgsl);
        ShaderLib.register("sky_fs_frag_wgsl", CubeSky_Shader.sky_fs_frag_wgsl);
        ShaderLib.register("LambertShader", Lambert_shader);
        ShaderLib.register("QuadGlsl_vs", QuadGlsl_vs);
        ShaderLib.register("QuadGlsl_fs", QuadGlsl_fs);
        ShaderLib.register("SkyGBuffer_fs", SkyGBuffer_pass);
        ShaderLib.register("gbuffer_vs", GBuffer_pass);
        ShaderLib.register("gbuffer_fs", GBuffer_pass);
        ShaderLib.register("castPointShadowMap_vert", castPointShadowMap_vert);
        ShaderLib.register("shadowCastMap_frag", shadowCastMap_frag);
        ShaderLib.register("shadowCastMap_vert", shadowCastMap_vert);
        ShaderLib.register("directionShadowCastMap_frag", directionShadowCastMap_frag);
        ShaderLib.register("ZPass_shader_vs", ZPassShader_vs);
        ShaderLib.register("ZPass_shader_fs", ZPassShader_fs);
      }
      static register(keyName, code) {
        if (!ShaderLib[keyName.toLowerCase()]) {
          ShaderLib[keyName.toLowerCase()] = code;
        }
      }
      static getShader(keyName) {
        if (ShaderLib[keyName.toLowerCase()]) {
          return ShaderLib[keyName.toLowerCase()];
        }
        return ShaderLib[keyName.toLowerCase()];
      }
    }

    class Preprocessor {
      static parse(code, defineValue) {
        code = this.filterComment(code);
        code = this.parsePreprocess(new PreprocessorContext(), code, defineValue);
        code = this.parseAutoBindingForAllGroup(code);
        code = this.parseAutoLocationBlock(code);
        return code;
      }
      static parseComputeShader(code, defineValue) {
        code = this.filterComment(code);
        code = this.parsePreprocess(new PreprocessorContext(), code, defineValue);
        code = this.parseAutoBindingForAllGroup(code);
        return code;
      }
      static parsePreprocess(context, code, defineValue) {
        let begIndex = code.indexOf("#");
        if (begIndex == -1) {
          return code;
        }
        let header = code.substring(0, begIndex);
        let endIndex = code.indexOf("\n", code.lastIndexOf("#"));
        let codeBlock = code.substring(begIndex, endIndex);
        let tail = code.substring(endIndex);
        return header + this.parsePreprocessCommand(context, codeBlock, defineValue) + tail;
      }
      static parseAutoBindingForAllGroup(code) {
        let offset = 0;
        let result = "";
        let group = /* @__PURE__ */ new Map();
        while (offset < code.length) {
          let nLeftIndex = code.indexOf("@group(", offset);
          if (nLeftIndex == -1) {
            result += code.substring(offset);
            break;
          }
          let nRightIndex = code.indexOf(")", nLeftIndex);
          let groupID = Number.parseInt(code.substring(nLeftIndex + 7, nRightIndex));
          nLeftIndex = code.indexOf("@binding(", nRightIndex);
          nRightIndex = code.indexOf(")", nLeftIndex);
          let bindingID = code.substring(nLeftIndex + 9, nRightIndex);
          result += code.substring(offset, nLeftIndex);
          if (bindingID.includes(`auto`)) {
            if (group.has(groupID)) {
              let lastBindingId = group.get(groupID) + 1;
              result += `@binding(${lastBindingId})`;
              group.set(groupID, lastBindingId);
            } else {
              result += "@binding(0)";
              group.set(groupID, 0);
            }
          } else {
            let nBindingID = Number.parseInt(bindingID);
            if (!group.has(groupID) || group.get(groupID) < nBindingID) {
              group.set(groupID, nBindingID);
            }
            result += `@binding(${bindingID})`;
          }
          offset = nRightIndex + 1;
        }
        return result;
      }
      static parseAutoBindingForGroupX(code, nGroup) {
        let offset = 0;
        let result = "";
        let group = /* @__PURE__ */ new Map();
        while (offset < code.length) {
          let nLeftIndex = code.indexOf("@group(", offset);
          if (nLeftIndex == -1) {
            result += code.substring(offset);
            break;
          }
          let nRightIndex = code.indexOf(")", nLeftIndex);
          let groupID = Number.parseInt(code.substring(nLeftIndex + 7, nRightIndex));
          nLeftIndex = code.indexOf("@binding(", nRightIndex);
          nRightIndex = code.indexOf(")", nLeftIndex);
          result += code.substring(offset, nLeftIndex);
          if (groupID == nGroup) {
            if (group.has(groupID)) {
              let lastBindingId = group.get(groupID) + 1;
              result += `@binding(${lastBindingId})`;
              group.set(groupID, lastBindingId);
            } else {
              result += "@binding(0)";
              group.set(groupID, 0);
            }
          } else {
            result += code.substring(nLeftIndex, nRightIndex + 1);
          }
          offset = nRightIndex + 1;
        }
        return result;
      }
      static parseAutoLocation(code) {
        let offset = 0;
        let result = "";
        let lastBindingId = 0;
        while (offset < code.length) {
          let nLeftIndex = code.indexOf("@location(", offset);
          if (nLeftIndex == -1) {
            result += code.substring(offset);
            break;
          }
          let nRightIndex = code.indexOf(")", nLeftIndex);
          let id = code.substring(nLeftIndex + 10, nRightIndex);
          result += code.substring(offset, nLeftIndex);
          if (id === "auto") {
            result += `@location(${lastBindingId})`;
            lastBindingId++;
          } else {
            result += code.substring(nLeftIndex, nRightIndex + 1);
          }
          offset = nRightIndex + 1;
        }
        return result;
      }
      static parseAutoLocationBlock(code) {
        let offset = 0;
        let result = "";
        while (offset < code.length) {
          let nLeftIndex = code.indexOf("@location(", offset);
          if (nLeftIndex == -1) {
            result += code.substring(offset);
            break;
          }
          let nRightIndex = code.indexOf("}", nLeftIndex);
          let nRightIndex2 = code.indexOf("->", nLeftIndex);
          if (nRightIndex2 != -1 && nRightIndex2 < nRightIndex) {
            nRightIndex = nRightIndex2;
          }
          let block = code.substring(nLeftIndex, nRightIndex + 1);
          block = this.parseAutoLocation(block);
          result += code.substring(offset, nLeftIndex);
          result += block;
          offset = nRightIndex + 1;
        }
        return result;
      }
      static parsePreprocessCommand(context, code, defineValue) {
        let result = "";
        let lines = code.split("\n");
        let stack = [false];
        let stackElseif = [false];
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          let skip = stack[stack.length - 1];
          if (line.trim().indexOf("#") != 0) {
            if (!skip) {
              result += line + "\n";
            }
            continue;
          }
          let command = line.trim();
          if (command.indexOf("#if") != -1) {
            if (skip && stack.length > 1) {
              stack.push(skip);
              continue;
            }
            let condition = command.substring(3).trim();
            skip = !this.parseCondition(condition, defineValue);
            stack.push(skip);
            stackElseif.push(!skip);
            continue;
          } else if (command.indexOf("#elseif") != -1 || command.indexOf("#else") != -1 && command.indexOf(" if") != -1) {
            let skipElseif = stackElseif[stackElseif.length - 1];
            if (skipElseif) {
              stack.pop();
              skip = true;
              stack.push(skip);
              continue;
            }
            stack.pop();
            skip = stack[stack.length - 1];
            if (skip && stack.length > 1) {
              stack.push(skip);
              continue;
            }
            let condition = command.substring(command.indexOf("if") + 2).trim();
            if (condition == "") {
              console.error(`preprocess command error, conditions missing: ${command}`);
            }
            skip = !this.parseCondition(condition, defineValue);
            stack.push(skip);
            stackElseif.push(!skip);
            continue;
          } else if (command.indexOf("#else") != -1) {
            stack.pop();
            if (skip && (stack.length > 1 && stack[stack.length - 1])) {
              stack.push(skip);
            } else {
              stack.push(!skip);
            }
            continue;
          } else if (command.indexOf("#endif") != -1) {
            stack.pop();
            stackElseif.pop();
            continue;
          } else if (command.indexOf("#include") != -1) {
            let includeName = "";
            let char = command.charAt(command.length - 1);
            if (char == `>`) {
              includeName = this.extract(command, "<", ">");
            } else {
              includeName = this.extract(command, char, char);
            }
            if (!context.includeMap.has(includeName)) {
              context.includeMap.set(includeName, true);
              let code2 = ShaderLib.getShader(includeName);
              if (!code2) {
                throw `${command} error: '${includeName}' not found`;
              }
              code2 = this.filterComment(code2);
              code2 = this.parsePreprocess(context, code2, defineValue);
              result += code2 + "\r\n";
            }
            continue;
          } else if (command.indexOf("#define ") != -1) {
            let expression = command.substring(command.indexOf("#define ") + 8).trim();
            let index = expression.indexOf(" ");
            let name = expression;
            let value = "";
            if (index != -1) {
              name = expression.substring(0, index).trim();
              value = expression.substring(index + 1).trim();
            }
            defineValue[name] = value;
            continue;
          } else
            throw "nonsupport: " + command;
        }
        return result;
      }
      static parseCondition(condition, defineValue) {
        let value = defineValue[condition];
        if (value == void 0) {
          return false;
        }
        return value == true || value != 0;
      }
      static filterComment(code) {
        let result = "";
        let findSingleComment = true;
        let findMultiComment = true;
        for (let offset = 0; offset < code.length; ) {
          let index1 = findSingleComment ? code.indexOf("//", offset) : -1;
          let index2 = findMultiComment ? code.indexOf("/*", offset) : -1;
          if (index1 == -1 && index2 == -1) {
            result += code.substring(offset);
            break;
          }
          findSingleComment = index1 != -1;
          findMultiComment = index2 != -1;
          if (index1 != -1 && index2 != -1) {
            if (index1 < index2) {
              index2 = -1;
            } else {
              index1 = -1;
            }
          }
          if (index1 != -1) {
            index2 = code.indexOf("\n", index1);
            result += code.substring(offset, index1);
            offset = index2 != -1 ? index2 : code.length;
          } else if (index2 != -1) {
            index1 = code.indexOf("*/", index2);
            result += code.substring(offset, index2);
            offset = index1 + 2;
          }
        }
        return result;
      }
      static extract(str, leftStr, rightStr) {
        let indexL = str.indexOf(leftStr) + leftStr.length;
        let indexR = str.indexOf(rightStr, indexL);
        return str.substring(indexL, indexR).trim();
      }
    }
    class PreprocessorContext {
      includeMap = /* @__PURE__ */ new Map();
      constructor() {
      }
    }

    class ShaderReflection {
      static _shaderReflectionMap = /* @__PURE__ */ new Map();
      attributes = [];
      vs_variables = [];
      fs_variables = [];
      cs_variables = [];
      groups = [];
      variables = {};
      useSplit = false;
      /**
       *
       * @param wgsl
       * @param shaderReflection
       */
      static parser(wgsl, shaderValue) {
        if (!shaderValue.shaderReflection)
          shaderValue.shaderReflection = new ShaderReflection();
        if (wgsl.indexOf(`@vertex`) != -1) {
          shaderValue.shaderReflection.attributes = this.parserVertexOld(wgsl);
          shaderValue.shaderReflection.vs_variables = this.parserVariables(wgsl);
        } else if (wgsl.indexOf(`@fragment`) != -1) {
          shaderValue.shaderReflection.fs_variables = this.parserVariables(wgsl);
        } else if (wgsl.indexOf(`@compute`) != -1) {
          shaderValue.shaderReflection.cs_variables = this.parserVariables(wgsl);
        }
      }
      static parser2(wgsl, shaderBase) {
        if (!shaderBase.shaderReflection)
          shaderBase.shaderReflection = new ShaderReflection();
        let shaderReflection = shaderBase.shaderReflection;
        if (wgsl.indexOf(`@vertex`) != -1) {
          shaderReflection.attributes = this.parserVertex(shaderBase.vsEntryPoint, wgsl);
          shaderReflection.vs_variables = this.parserVariables(wgsl);
        } else if (wgsl.indexOf(`@fragment`) != -1) {
          shaderReflection.fs_variables = this.parserVariables(wgsl);
        } else if (wgsl.indexOf(`@compute`) != -1) {
          shaderReflection.cs_variables = this.parserVariables(wgsl);
        }
        if (wgsl.indexOf("splitTexture") != -1) {
          shaderReflection.useSplit = true;
        }
      }
      static combineShaderReflectionVarInfo(shaderReflection, shader_variables) {
        for (const iterator of shader_variables) {
          if (!shaderReflection.groups[iterator.group]) {
            shaderReflection.groups[iterator.group] = [];
          }
          let combineInfo = iterator;
          if (shaderReflection.groups[iterator.group][iterator.binding]) {
            let aInfo = shaderReflection.groups[iterator.group][iterator.binding];
            let bInfo = iterator;
            if (aInfo.dataFields) {
              for (let i = 0; i < aInfo.dataFields.length; i++) {
                aInfo.dataFields[i];
              }
            }
            if (bInfo.dataFields) {
              for (let i = 0; i < bInfo.dataFields.length; i++) {
                bInfo.dataFields[i];
              }
            }
          }
          shaderReflection.groups[iterator.group][iterator.binding] = combineInfo;
          shaderReflection.variables[iterator.varName] = combineInfo;
        }
      }
      static final(shaderBase) {
        let shaderReflection = shaderBase.shaderReflection;
        this._shaderReflectionMap.set(shaderBase.shaderVariant, shaderReflection);
        this.combineShaderReflectionVarInfo(shaderReflection, shaderReflection.vs_variables);
        this.combineShaderReflectionVarInfo(shaderReflection, shaderReflection.fs_variables);
      }
      static getShaderReflection2(code, shaderBase) {
        let preShader = Preprocessor.parse(code, shaderBase.defineValue);
        ShaderReflection.parser2(preShader, shaderBase);
      }
      /**
       * 
       * @param shaderVariant shader variant name 
       * @returns 
       */
      static poolGetReflection(shaderVariant) {
        let ref = this._shaderReflectionMap.get(shaderVariant);
        return ref;
      }
      static genShaderVar(shaderValue) {
        let shaderVariant = `${shaderValue.vs}${shaderValue.fs}${shaderValue.compute}`;
        shaderVariant += "|";
        for (const key in shaderValue.uniforms) {
          shaderVariant += key + ":";
        }
        shaderVariant += "|";
        for (const key in shaderValue.constValues) {
          shaderVariant += key + ":";
          shaderVariant += shaderValue.constValues[key];
        }
        shaderVariant += "|";
        for (const key in shaderValue.defines) {
          shaderVariant += key + ":";
          shaderVariant += shaderValue.defines[key];
        }
        shaderVariant += "|";
        for (const key in shaderValue.shaderState) {
          shaderVariant += key + ":";
          shaderVariant += shaderValue.shaderState[key] + ";";
        }
        return shaderVariant;
      }
      static genShaderVariant(shader) {
        let shaderVariant = "";
        for (const key in shader.uniforms) {
          shaderVariant += key + ":";
        }
        shaderVariant += "|";
        for (const key in shader.constValues) {
          shaderVariant += key + ":";
          shaderVariant += shader.constValues[key];
        }
        shaderVariant += "|";
        for (const key in shader.defineValue) {
          shaderVariant += key + ":";
          shaderVariant += shader.defineValue[key];
        }
        return shaderVariant;
      }
      static genRenderShaderVariant(renderShader) {
        let shaderVariant = `RenderShader(${renderShader.vsName},${renderShader.fsName})`;
        shaderVariant += "|";
        shaderVariant += this.genShaderVariant(renderShader);
        shaderVariant += "|";
        for (const key in renderShader.shaderState) {
          shaderVariant += key + ":";
          shaderVariant += renderShader.shaderState[key] + ";";
        }
        return shaderVariant;
      }
      static genComputeShaderVariant(computeShader) {
        let shaderVariant = `ComputeShader(${computeShader.instanceID})`;
        shaderVariant += "|";
        shaderVariant += this.genShaderVariant(computeShader);
        return shaderVariant;
      }
      combine(shaderValue) {
        let shaderReflection = shaderValue.shaderReflection;
        let defines = shaderValue.defines;
        let tmp = {};
        for (let i = 0; i < this.attributes.length; i++) {
          let att = this.attributes[i];
          if (defines[att.name])
            tmp[att.name] = att;
        }
        let len = shaderReflection.attributes.length;
        for (let j = 0; j < len; j++) {
          const newAtt = shaderReflection.attributes[j];
          if (!tmp[newAtt.name]) {
            this.attributes.push(newAtt);
          } else {
            let oldAtt = tmp[newAtt.name];
            if (oldAtt.location == newAtt.location && oldAtt.name != newAtt.name) {
              console.log("location must same!");
            }
          }
        }
      }
      static parserVariables(wgsl) {
        let position = 0;
        let variables = [];
        while (position < wgsl.length) {
          let nLeftIndex = wgsl.indexOf("@group(", position);
          if (nLeftIndex < 0)
            break;
          let nRightIndex = wgsl.indexOf(";", nLeftIndex);
          position = nRightIndex;
          let item = wgsl.substring(nLeftIndex, nRightIndex);
          let group = this.extract(item, "@group(", ")");
          let binding = this.extract(item, "@binding(", ")");
          let varName = "";
          let varType = "var";
          if (item.indexOf("var<") != -1) {
            varName = this.extract(item, ">", ":");
            varType = this.extract(item, "var<", ">").replace(",", "-").replaceAll(" ", "");
          } else {
            varName = this.extract(item, "var", ":");
          }
          let dataType = item.substring(item.lastIndexOf(":") + 1).trim();
          let info = {
            group: 0,
            binding: 0,
            varType: "",
            varName: "",
            dataType: "",
            dataIsBuiltinType: true,
            dataFields: null
          };
          info.group = Number.parseInt(group);
          info.binding = Number.parseInt(binding);
          info.varType = varType;
          info.varName = varName;
          info.dataType = dataType;
          info.dataIsBuiltinType = this.isBuiltinTypes(info.dataType);
          if (!info.dataIsBuiltinType) {
            info.dataFields = this.parserStructFields(wgsl, info.dataType);
          }
          variables.push(info);
        }
        return variables;
      }
      static extract(str, leftStr, rightStr) {
        let indexL = str.indexOf(leftStr) + leftStr.length;
        let indexR = str.indexOf(rightStr, indexL);
        return str.substring(indexL, indexR).trim();
      }
      static isBuiltinTypes(dataType) {
        switch (dataType) {
          case "i32":
            return true;
          case "u32":
            return true;
          case "f32":
            return true;
          default:
            let index = dataType.indexOf("<");
            if (index != -1) {
              let type = dataType.substring(0, index);
              switch (type) {
                case "vec2":
                  return true;
                case "vec3":
                  return true;
                case "vec4":
                  return true;
                case "mat3":
                  return true;
                case "mat4":
                  return true;
                case "array":
                  return this.isBuiltinTypes(dataType.substring(index + 1, dataType.lastIndexOf(">")));
              }
            }
            break;
        }
        return false;
      }
      static parserStructFields(wgsl, structName) {
        let result = [];
        let position = 0;
        while (position < wgsl.length) {
          let nLeftIndex = wgsl.indexOf("struct ", position);
          if (nLeftIndex < 0)
            break;
          let nRightIndex = wgsl.indexOf("{", nLeftIndex);
          position = nRightIndex;
          let name = wgsl.substring(nLeftIndex + 6, nRightIndex).trim();
          if (name === structName) {
            nLeftIndex = wgsl.indexOf("{", nLeftIndex);
            nRightIndex = wgsl.indexOf("}", nLeftIndex);
            let items = wgsl.substring(nLeftIndex + 1, nRightIndex);
            let fields = items.split(",");
            for (let field of fields) {
              let index = field.indexOf(":");
              if (index != -1) {
                let obj = {
                  name: field.substring(0, index).trim(),
                  type: field.substring(index + 1).trim()
                };
                result.push(obj);
              }
            }
            break;
          }
        }
        return result;
      }
      static parserVertexOld(wgsl) {
        let attributes = [];
        let list = wgsl.split(`fn main(`);
        let block = list[1].split("->")[0];
        let blockList = block.split("@");
        if (blockList && blockList.length > 1) {
          for (let i = 1; i < blockList.length; i++) {
            const element = blockList[i];
            let code2 = element.replace(/\s*$/g, "");
            code2 = code2.replaceAll(",", "");
            code2 = code2.replaceAll("\n", "");
            code2 = code2.replaceAll("  ", " ");
            this.parserAttribute(code2, attributes);
          }
        } else {
          let code1 = block.split(":");
          var code = code1[1];
          code = code.replaceAll("  ", "");
          code = code.replaceAll(" ", "");
          code = code.replaceAll(")", "");
          code = wgsl.split(`struct ${code}`)[1];
          let start = code.indexOf("{");
          let end = code.indexOf("}");
          code = code.slice(start, end);
          blockList = code.split("@");
          for (let i = 1; i < blockList.length; i++) {
            const element = blockList[i];
            let code2 = element.replace(/\s*$/g, "");
            code2 = code2.replaceAll("\n", "");
            code2 = code2.split(",")[0];
            code2 = code2.replaceAll("  ", " ");
            this.parserAttribute(code2, attributes);
          }
        }
        return attributes;
      }
      static parserVertex(entryPoint, wgsl) {
        let attributes = [];
        let list = wgsl.split(`fn ${entryPoint}(`);
        let block = list[1].split("->")[0];
        let blockList = block.split("@");
        if (blockList && blockList.length > 1) {
          for (let i = 1; i < blockList.length; i++) {
            const element = blockList[i];
            let code2 = element.replace(/\s*$/g, "");
            code2 = code2.replaceAll(",", "");
            code2 = code2.replaceAll("\n", "");
            code2 = code2.replaceAll("  ", " ");
            this.parserAttribute(code2, attributes);
          }
        } else {
          let code1 = block.split(":");
          var code = code1[1];
          code = code.replaceAll("  ", "");
          code = code.replaceAll(" ", "");
          code = code.replaceAll(")", "");
          code = wgsl.split(`struct ${code}`)[1];
          let start = code.indexOf("{");
          let end = code.indexOf("}");
          code = code.slice(start, end);
          blockList = code.split("@");
          for (let i = 1; i < blockList.length; i++) {
            const element = blockList[i];
            let code2 = element.replace(/\s*$/g, "");
            code2 = code2.replaceAll("\n", "");
            code2 = code2.split(",")[0];
            code2 = code2.replaceAll("  ", " ");
            this.parserAttribute(code2, attributes);
          }
        }
        return attributes;
      }
      /**
       * builtin(instance_index) index : u32
       * location(0) Vertex_Position : vec3<f32>
       * @param line
       * @param attributes
       */
      static parserAttribute(line, attributes) {
        let obj = {
          name: "",
          group: 0,
          location: 0,
          type: "",
          valueType: "",
          value: 0,
          size: 0,
          format: `float32`
        };
        if (line.indexOf("builtin") != -1) {
          obj.type = "builtin";
          var tmp = line.match(/\((.+?)\)/g)[0];
          tmp = line.match(/\((.+?)\)/g)[0];
          tmp = tmp.replace("(", "");
          tmp = tmp.replaceAll(")", "");
          obj.location = parseInt(tmp);
          let cc = line.split(":");
          obj.name = cc[0].split(" ")[1];
          obj.name = obj.name.replaceAll("  ", " ");
          obj.name = obj.name.replaceAll(" ", "");
          obj.valueType = cc[1];
          obj.valueType = obj.valueType.replaceAll("  ", " ");
          obj.valueType = obj.valueType.replaceAll(" ", "");
          obj.valueType = obj.valueType.replaceAll("\r", "");
          obj.valueType = obj.valueType.replaceAll(")", "");
          obj.valueType = obj.valueType.replaceAll(")", "");
          obj.size = VertexAttributeSize[obj.valueType];
          attributes.push(obj);
        } else if (line.indexOf("location") != -1) {
          obj.type = "location";
          var tmp = line.match(/\((.+?)\)/g)[0];
          tmp = line.match(/\((.+?)\)/g)[0];
          tmp = tmp.replace("(", "");
          tmp = tmp.replaceAll(")", "");
          obj.location = parseInt(tmp);
          let cc = line.split(":");
          obj.name = cc[0].split(" ")[1];
          obj.name = obj.name.replaceAll("  ", " ");
          obj.name = obj.name.replaceAll(" ", "");
          obj.valueType = cc[1];
          obj.valueType = obj.valueType.replaceAll("  ", " ");
          obj.valueType = obj.valueType.replaceAll(" ", "");
          obj.valueType = obj.valueType.replaceAll("\r", "");
          obj.valueType = obj.valueType.replaceAll(")", "");
          obj.valueType = obj.valueType.replaceAll(")", "");
          obj.size = VertexAttributeSize[obj.valueType];
          attributes.push(obj);
        }
        obj.format = VertexFormat[VertexAttributeSize[obj.valueType]];
      }
    }

    class ComputeShader extends ShaderPassBase {
      /**
       * Compute shader entry point name
       */
      entryPoint = `CsMain`;
      /**
       * Compute shader x worker number
       */
      workerSizeX = 1;
      /**
       * Compute shader y worker number
       */
      workerSizeY = 0;
      /**
       * Compute shader z worker number
       */
      workerSizeZ = 0;
      _computePipeline;
      _csShaderModule;
      _destCS;
      _sourceCS;
      _storageTextureDic;
      _sampleTextureDic;
      _groupsShaderReflectionVarInfos;
      _groupCache = {};
      /**
       *
       * @param computeShader wgsl compute shader
       */
      constructor(computeShader) {
        super();
        this._sourceCS = computeShader;
        ShaderReflection.getShaderReflection2(computeShader, this);
        this._storageTextureDic = /* @__PURE__ */ new Map();
        this._sampleTextureDic = /* @__PURE__ */ new Map();
      }
      /**
       * set write or read storage texture , use textureLod
       * @param name
       * @param texture
       */
      setStorageTexture(name, texture) {
        if (!this._storageTextureDic.has(name)) {
          this._storageTextureDic.set(name, texture);
        }
      }
      /**
       * set samplerTexture , use textureSample or other sample texture api
       * @param name
       * @param texture
       */
      setSamplerTexture(name, texture) {
        this._sampleTextureDic.set(name, texture);
      }
      /**
       * Record the compute shader distribution command
       * @param computePass Compute pass encoder
       */
      compute(computePass) {
        if (!this._computePipeline) {
          this.genComputePipeline();
        }
        computePass.setPipeline(this._computePipeline);
        for (let i = 0; i < this.bindGroups.length; ++i) {
          computePass.setBindGroup(i, this.bindGroups[i]);
        }
        if (this.workerSizeX && this.workerSizeY && this.workerSizeZ) {
          computePass.dispatchWorkgroups(this.workerSizeX, this.workerSizeY, this.workerSizeZ);
        } else if (this.workerSizeX && this.workerSizeY) {
          computePass.dispatchWorkgroups(this.workerSizeX, this.workerSizeY);
        } else {
          computePass.dispatchWorkgroups(this.workerSizeX);
        }
      }
      createBufferBindGroup(groupIndex, varName, binding, entries) {
        let buffer = this._bufferDic.get(varName);
        if (buffer) {
          let entry = {
            binding,
            resource: {
              buffer: buffer.buffer,
              offset: 0,
              //buffer.memory.shareFloat32Array.byteOffset,
              size: buffer.memory.shareDataBuffer.byteLength
            }
          };
          entries.push(entry);
        } else {
          console.error(`ComputeShader(${this.instanceID})`, `buffer ${varName} is missing!`);
        }
      }
      noticeBufferChange(name) {
        let bindGroupCache = this._groupCache[name];
        if (bindGroupCache) {
          this.genGroups(bindGroupCache.groupIndex, bindGroupCache.infos, true);
        }
      }
      genGroups(groupIndex, infos, force = false) {
        if (!this.bindGroups[groupIndex] || force) {
          const shaderRefs = infos[groupIndex];
          let entries = [];
          for (let j = 0; j < shaderRefs.length; ++j) {
            const refs = shaderRefs[j];
            if (!refs)
              continue;
            switch (refs.varType) {
              case `uniform`:
              case `storage-read`:
              case `storage-read_write`:
                {
                  this.createBufferBindGroup(groupIndex, refs.varName, refs.binding, entries);
                  this._groupCache[refs.varName] = { groupIndex, infos };
                }
                break;
              case `var`:
                {
                  if (refs.dataType == `sampler`) {
                    let textureName = refs.varName.replace(`Sampler`, ``);
                    let texture = this._sampleTextureDic.get(textureName);
                    if (texture) {
                      let entry = {
                        binding: refs.binding,
                        resource: texture.gpuSampler
                      };
                      entries.push(entry);
                    } else {
                      console.error(`ComputeShader(${this.instanceID})`, `texture ${refs.varName} is missing! `);
                    }
                  } else if (refs.dataType == `sampler_comparison`) {
                    let textureName = refs.varName.replace(`Sampler`, ``);
                    let texture = this._sampleTextureDic.get(textureName);
                    if (texture) {
                      let entry = {
                        binding: refs.binding,
                        resource: texture.gpuSampler_comparison
                      };
                      entries.push(entry);
                    } else {
                      console.error(`ComputeShader(${this.instanceID})`, `texture ${refs.varName} is missing! `);
                    }
                  } else if (refs.dataType.indexOf("texture_storage") != -1) {
                    let texture = this._storageTextureDic.get(refs.varName);
                    if (texture) {
                      let entry = {
                        binding: refs.binding,
                        resource: texture.getGPUView()
                      };
                      entries.push(entry);
                      Reference.getInstance().attached(texture, this);
                    } else {
                      console.error(`ComputeShader(${this.instanceID})`, `texture ${refs.varName} is missing! `);
                    }
                  } else if (refs.dataType.indexOf("texture") != -1) {
                    let texture = this._sampleTextureDic.get(refs.varName);
                    if (texture) {
                      let entry = {
                        binding: refs.binding,
                        resource: texture.getGPUView()
                      };
                      entries.push(entry);
                      Reference.getInstance().attached(texture, this);
                    } else {
                      console.error(`ComputeShader(${this.instanceID})`, `texture ${refs.varName} is missing! `);
                    }
                  }
                }
                break;
              default:
                console.error(`unprocessed type:`, refs.varType);
                break;
            }
          }
          let gpubindGroup = webGPUContext.device.createBindGroup({
            layout: this._computePipeline.getBindGroupLayout(groupIndex),
            entries
          });
          this.bindGroups[groupIndex] = gpubindGroup;
        }
      }
      genComputePipeline() {
        this.preCompileShader(this._sourceCS);
        this.genReflection();
        this._computePipeline = webGPUContext.device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: this.compileShader(),
            entryPoint: this.entryPoint
          }
        });
        this._groupsShaderReflectionVarInfos = [];
        let shaderReflection = this.shaderReflection;
        this.bindGroups = [];
        for (let i = 0; i < shaderReflection.groups.length; ++i) {
          let srvs = shaderReflection.groups[i];
          this._groupsShaderReflectionVarInfos[i] = srvs;
          this.genGroups(i, this._groupsShaderReflectionVarInfos);
        }
        webGPUContext.addEventListener(CResizeEvent.RESIZE, (e) => {
          for (let i = 0; i < shaderReflection.groups.length; ++i) {
            let srvs = shaderReflection.groups[i];
            this._groupsShaderReflectionVarInfos[i] = srvs;
            this.genGroups(i, this._groupsShaderReflectionVarInfos, true);
          }
        }, this);
      }
      preCompileShader(shader) {
        for (const key in this.constValues) {
          if (Object.prototype.hasOwnProperty.call(this.constValues, key)) {
            const value = this.constValues[key];
            shader = shader.replaceAll(`&${key}`, value.toString());
          }
        }
        this._destCS = Preprocessor.parseComputeShader(shader, this.defineValue);
      }
      compileShader() {
        let shaderModule = webGPUContext.device.createShaderModule({
          label: `ComputeShader(${this.instanceID})`,
          code: this._destCS
        });
        shaderModule.getCompilationInfo().then((e) => {
          if (e.messages.length > 0) {
            console.log(this._destCS);
          }
        });
        this._csShaderModule = shaderModule;
        return shaderModule;
      }
      genReflection() {
        this.shaderVariant += ShaderReflection.genComputeShaderVariant(this);
        let reflection = ShaderReflection.poolGetReflection(this.shaderVariant);
        if (!reflection) {
          ShaderReflection.getShaderReflection2(this._destCS, this);
          ShaderReflection.combineShaderReflectionVarInfo(this.shaderReflection, this.shaderReflection.cs_variables);
        } else {
          this.shaderReflection = reflection;
        }
      }
    }

    class ProfilerUtil {
      static profilerLabelMap = /* @__PURE__ */ new Map();
      static start(id) {
        let profilerLabel = this.profilerLabelMap.get(id);
        if (!profilerLabel) {
          profilerLabel = {
            lable: id,
            start: 0,
            end: 0,
            total: 0,
            count: 0,
            child: /* @__PURE__ */ new Map()
          };
          this.profilerLabelMap.set(id, profilerLabel);
        }
        profilerLabel.start = performance.now();
        profilerLabel.end = performance.now();
        profilerLabel.count = 0;
        profilerLabel.child.clear();
      }
      static end(id) {
        let profilerLabel = this.profilerLabelMap.get(id);
        if (profilerLabel) {
          profilerLabel.end = performance.now();
          profilerLabel.total = profilerLabel.end - profilerLabel.start;
        }
      }
      static countStart(id, id2 = "") {
        let profilerLabel = this.profilerLabelMap.get(id);
        if (profilerLabel) {
          profilerLabel.count++;
          if (id2 != "") {
            let node = profilerLabel.child.get(id2);
            if (!node) {
              node = {
                lable: id2,
                start: 0,
                end: 0,
                total: 0,
                count: 0
              };
            }
            node.start = performance.now();
            node.end = performance.now();
            node.count = 0;
            profilerLabel.child.set(id2, node);
          }
        }
      }
      static countEnd(id, id2) {
        let profilerLabel = this.profilerLabelMap.get(id);
        if (profilerLabel) {
          if (id2 != "") {
            let node = profilerLabel.child.get(id2);
            if (!node) {
              node = {
                lable: id2,
                start: 0,
                end: 0,
                total: 0,
                count: 0
              };
            }
            node.end = performance.now();
            node.total = node.end - node.start;
            node.count++;
          }
        }
      }
      static print(id) {
        let profilerLabel = this.profilerLabelMap.get(id);
        if (profilerLabel) {
          console.log("performance", id, profilerLabel.total + " ms");
        }
      }
    }

    const matrixjs = "var Module=typeof Module!=\"undefined\"?Module:{};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window==\"object\";var ENVIRONMENT_IS_WORKER=typeof importScripts==\"function\";var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;if(ENVIRONMENT_IS_NODE){var fs=require(\"fs\");var nodePath=require(\"path\");if(ENVIRONMENT_IS_WORKER){scriptDirectory=nodePath.dirname(scriptDirectory)+\"/\"}else{scriptDirectory=__dirname+\"/\"}read_=(filename,binary)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);return fs.readFileSync(filename,binary?undefined:\"utf8\")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror,binary=true)=>{filename=isFileURI(filename)?new URL(filename):nodePath.normalize(filename);fs.readFile(filename,binary?undefined:\"utf8\",((err,data)=>{if(err)onerror(err);else onload(binary?data.buffer:data)}))};if(!Module[\"thisProgram\"]&&process.argv.length>1){thisProgram=process.argv[1].replace(/\\\\/g,\"/\")}arguments_=process.argv.slice(2);if(typeof module!=\"undefined\"){module[\"exports\"]=Module}process.on(\"uncaughtException\",(ex=>{if(ex!==\"unwind\"&&!(ex instanceof ExitStatus)&&!(ex.context instanceof ExitStatus)){throw ex}}));quit_=(status,toThrow)=>{process.exitCode=status;throw toThrow};Module[\"inspect\"]=()=>\"[Emscripten Module object]\"}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=\"undefined\"&&document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf(\"blob:\")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1)}else{scriptDirectory=\"\"}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,true);xhr.responseType=\"arraybuffer\";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module[\"print\"]||console.log.bind(console);var err=Module[\"printErr\"]||console.error.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"quit\"])quit_=Module[\"quit\"];var wasmBinary;if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];var noExitRuntime=Module[\"noExitRuntime\"]||true;if(typeof WebAssembly!=\"object\"){abort(\"no native wasm support detected\")}var wasmMemory;var ABORT=false;var EXITSTATUS;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateMemoryViews(){var b=wasmMemory.buffer;Module[\"HEAP8\"]=HEAP8=new Int8Array(b);Module[\"HEAP16\"]=HEAP16=new Int16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);Module[\"HEAPU16\"]=HEAPU16=new Uint16Array(b);Module[\"HEAPU32\"]=HEAPU32=new Uint32Array(b);Module[\"HEAPF32\"]=HEAPF32=new Float32Array(b);Module[\"HEAPF64\"]=HEAPF64=new Float64Array(b)}var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module[\"monitorRunDependencies\"]){Module[\"monitorRunDependencies\"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(Module[\"onAbort\"]){Module[\"onAbort\"](what)}what=\"Aborted(\"+what+\")\";err(what);ABORT=true;EXITSTATUS=1;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);throw e}var dataURIPrefix=\"data:application/octet-stream;base64,\";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith(\"file://\")}var wasmBinaryFile;wasmBinaryFile=\"data:application/octet-stream;base64,AGFzbQEAAAABfBRgAX8Bf2ABfwBgA39/fwF/YAN/f38AYAAAYAV/f39/fwBgBH9/f38AYAZ/f39/f38AYAABf2ACf38Bf2AEf39/fwF/YAF8AX1gAnx/AXxgAn9/AGABfQF9YAN/f30AYAJ+fwF/YAZ/fH9/f38Bf2ACfX8Bf2ADf35/AX4CHwUBYQFhAAoBYQFiAAMBYQFjAAABYQFkAAQBYQFlAAMDSEcDBQsLAgEAEAEADAEDDQ4CAA4PBAQABAABAAYDCQAAAAkRAwAKDAACARINAQAAAQAAAAAHBwUFAQYGAgEBEwACCQ8BCAgICAQFAXABICAFBwEBgAKAgAIGCAF/AUHgtwQLBzUNAWYCAAFnABsBaAEAAWkAMAFqAEsBawBKAWwASQFtAEgBbgBHAW8ARgFwAEUBcQAxAXIANwklAQBBAQsfIh5BQDwzQ0RCJiINLS0/ODo+DTk7PQ01DTQNNh0yHQryvgFHFwAgAC0AAEEgcUUEQCABIAIgABAUGgsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgNBgAIgA0GAAkkiARsQESABRQRAA0AgACAFQYACEAUgA0GAAmsiA0H/AUsNAAsLIAAgBSADEAULIAVBgAJqJAALSwECfCAAIACiIgEgAKIiAiABIAGioiABRKdGO4yHzcY+okR058ri+QAqv6CiIAIgAUSy+26JEBGBP6JEd6zLVFVVxb+goiAAoKC2C08BAXwgACAAoiIAIAAgAKIiAaIgAERpUO7gQpP5PqJEJx4P6IfAVr+goiABREI6BeFTVaU/oiAARIFeDP3//9+/okQAAAAAAADwP6CgoLYLdAEBfyACRQRAIAAoAgQgASgCBEYPCyAAIAFGBEBBAQ8LIAEoAgQiAi0AACEBAkAgACgCBCIDLQAAIgBFDQAgACABRw0AA0AgAi0AASEBIAMtAAEiAEUNASACQQFqIQIgA0EBaiEDIAAgAUYNAAsLIAAgAUYL0gsBB38CQCAARQ0AIABBCGsiAiAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAIgAigCACIBayICQfgzKAIASQ0BIAAgAWohAAJAAkBB/DMoAgAgAkcEQCABQf8BTQRAIAFBA3YhBCACKAIMIgEgAigCCCIDRgRAQegzQegzKAIAQX4gBHdxNgIADAULIAMgATYCDCABIAM2AggMBAsgAigCGCEGIAIgAigCDCIBRwRAIAIoAggiAyABNgIMIAEgAzYCCAwDCyACQRRqIgQoAgAiA0UEQCACKAIQIgNFDQIgAkEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJB8DMgADYCACAFIAFBfnE2AgQgAiAAQQFyNgIEIAUgADYCAA8LQQAhAQsgBkUNAAJAIAIoAhwiA0ECdEGYNmoiBCgCACACRgRAIAQgATYCACABDQFB7DNB7DMoAgBBfiADd3E2AgAMAgsgBkEQQRQgBigCECACRhtqIAE2AgAgAUUNAQsgASAGNgIYIAIoAhAiAwRAIAEgAzYCECADIAE2AhgLIAIoAhQiA0UNACABIAM2AhQgAyABNgIYCyACIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGANCgCACAFRgRAQYA0IAI2AgBB9DNB9DMoAgAgAGoiADYCACACIABBAXI2AgQgAkH8MygCAEcNBkHwM0EANgIAQfwzQQA2AgAPC0H8MygCACAFRgRAQfwzIAI2AgBB8DNB8DMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAIAFB/wFNBEAgAUEDdiEEIAUoAgwiASAFKAIIIgNGBEBB6DNB6DMoAgBBfiAEd3E2AgAMBQsgAyABNgIMIAEgAzYCCAwECyAFKAIYIQYgBSAFKAIMIgFHBEBB+DMoAgAaIAUoAggiAyABNgIMIAEgAzYCCAwDCyAFQRRqIgQoAgAiA0UEQCAFKAIQIgNFDQIgBUEQaiEECwNAIAQhByADIgFBFGoiBCgCACIDDQAgAUEQaiEEIAEoAhAiAw0ACyAHQQA2AgAMAgsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgAMAwtBACEBCyAGRQ0AAkAgBSgCHCIDQQJ0QZg2aiIEKAIAIAVGBEAgBCABNgIAIAENAUHsM0HsMygCAEF+IAN3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogATYCACABRQ0BCyABIAY2AhggBSgCECIDBEAgASADNgIQIAMgATYCGAsgBSgCFCIDRQ0AIAEgAzYCFCADIAE2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkH8MygCAEcNAEHwMyAANgIADwsgAEH/AU0EQCAAQXhxQZA0aiEBAn9B6DMoAgAiA0EBIABBA3Z0IgBxRQRAQegzIAAgA3I2AgAgAQwBCyABKAIICyEAIAEgAjYCCCAAIAI2AgwgAiABNgIMIAIgADYCCA8LQR8hAyAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiEDCyACIAM2AhwgAkIANwIQIANBAnRBmDZqIQECQAJAAkBB7DMoAgAiBEEBIAN0IgdxRQRAQewzIAQgB3I2AgAgASACNgIAIAIgATYCGAwBCyAAQRkgA0EBdmtBACADQR9HG3QhAyABKAIAIQEDQCABIgQoAgRBeHEgAEYNAiADQR12IQEgA0EBdCEDIAQgAUEEcWoiB0EQaigCACIBDQALIAcgAjYCECACIAQ2AhgLIAIgAjYCDCACIAI2AggMAQsgBCgCCCIAIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiAANgIIC0GINEGINCgCAEEBayIAQX8gABs2AgALC08BAn9B2CkoAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABACRQ0BC0HYKSAANgIAIAEPC0GoMkEwNgIAQX8LgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABCwYAIAAQCgs1AQF/QQEgACAAQQFNGyEAAkADQCAAECQiAQ0BQdg3KAIAIgEEQCABEQQADAELCxADAAsgAQuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XThtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaEwbQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwYAIAAQCgvwAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiADYCACADIAIgBGtBfHEiAmoiAUEEayAANgIAIAJBCUkNACADIAA2AgggAyAANgIEIAFBCGsgADYCACABQQxrIAA2AgAgAkEZSQ0AIAMgADYCGCADIAA2AhQgAyAANgIQIAMgADYCDCABQRBrIAA2AgAgAUEUayAANgIAIAFBGGsgADYCACABQRxrIAA2AgAgAiADQQRxQRhyIgFrIgJBIEkNACAArUKBgICAEH4hBSABIANqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsLMgAgACABKgIAIAAqAgCSOAIAIAAgASoCBCAAKgIEkjgCBCAAIAEqAgggACoCCJI4AggL/gICA38BfCMAQRBrIgEkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAHIQAMAQsgAkHRp+2DBE0EQCAAuyEEIAJB45fbgARNBEAgA0EASARAIAREGC1EVPsh+T+gEAiMIQAMAwsgBEQYLURU+yH5v6AQCCEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIASgmhAHIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQQgA0EASARAIARE0iEzf3zZEkCgEAghAAwDCyAERNIhM3982RLAoBAIjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAHIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsCQAJAAkACQCAAIAFBCGoQLkEDcQ4DAAECAwsgASsDCBAHIQAMAwsgASsDCBAIIQAMAgsgASsDCJoQByEADAELIAErAwgQCIwhAAsgAUEQaiQAIAALwAEBA38CQCABIAIoAhAiAwR/IAMFIAIQFQ0BIAIoAhALIAIoAhQiBWtLBEAgAiAAIAEgAigCJBECAA8LAkAgAigCUEEASARAQQAhAwwBCyABIQQDQCAEIgNFBEBBACEDDAILIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQIAIgQgA0kNASAAIANqIQAgASADayEBIAIoAhQhBQsgBSAAIAEQLBogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAvoAgIDfwF8IwBBEGsiASQAAn0gALwiA0H/////B3EiAkHan6T6A00EQEMAAIA/IAJBgICAzANJDQEaIAC7EAgMAQsgAkHRp+2DBE0EQCACQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIANBAEgbIAC7oBAIjAwCCyAAuyEEIANBAEgEQCAERBgtRFT7Ifk/oBAHDAILRBgtRFT7Ifk/IAShEAcMAQsgAkHV44iHBE0EQCACQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIDAILIANBAEgEQETSITN/fNkSwCAAu6EQBwwCCyAAu0TSITN/fNkSwKAQBwwBCyAAIACTIAJBgICA/AdPDQAaAkACQAJAAkAgACABQQhqEC5BA3EOAwABAgMLIAErAwgQCAwDCyABKwMImhAHDAILIAErAwgQCIwMAQsgASsDCBAHCyEAIAFBEGokACAACzMBAn0gASoCACAClCEDIAEqAgQgApQhBCAAIAEqAgggApQ4AgggACAEOAIEIAAgAzgCAAsqAQF/QQQQIyIAQeQmNgIAIABBvCY2AgAgAEHQJjYCACAAQcAnQQEQAQALXwEDf0EIECMiAEHkJjYCACAAQdQnNgIAQZ0IECsiAUENahAOIgJBADYCCCACIAE2AgQgAiABNgIAIAAgAkEMakGdCCABQQFqECw2AgQgAEGEKDYCACAAQaQoQQIQAQALfwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAEGAgID8AzYCPCAAQYCAgPwDNgIAIABCADcCNCAAQYCAgPwDNgIoIABBgICA/AM2AhQgAAtTAEHsKUEANgIAQeQpQgA3AgBB+ClBADYCAEHwKUIANwIAQYQqQQA2AgBB/ClCADcCAEGQKkEANgIAQYgqQgA3AgBBxDNBzDI2AgBB/DJBKjYCAAv8BwMIfw59EHsjAEFAaiICJABB5CkoAgAgAEEGdGohAUH8KSgCACAAQQR0aiIFKAIABEAgBSgCBCEDIwBBEGsiBiQAIABBJGwiBEHwKSgCAGoiAEEYaiEHIABBDGohCCADBEAgBkEEaiIDQYgqKAIAIARqIgRB4CkqAgAQFyAAIAMQEiADIARBDGpB4CkqAgAQFyAIIAMQEiADIARBGGpB4CkqAgAQFyAHIAMQEgsgACoCFCEJIAAqAhAhCiAAKgIAIRIgACoCBCETIAAqAgghECAIKgIAIQwgAUEANgIsIAFBADYCHCABQQA2AgwgDEM1+o48lEMAAAA/lCIMEBMhDiAKQzX6jjyUQwAAAD+UIgoQEyERIAlDNfqOPJRDAAAAP5QiDRATIQkgDBAWIQsgChAWIQ8gASAQIAsgEZQiFCANEBYiCpQgCSAOIA+UIg2UkiIMIAkgCyAPlCILlCAKIA4gEZQiD5STIhEgEZIiDpQiFSALIAqUIA8gCZSSIgsgDSAKlCAJIBSUkyIJIAmSIg+UIg2TlDgCJCABIBAgCSAOlCIUIAsgDCAMkiIKlCIWkpQ4AiAgASATIBUgDZKUOAIYIAEgEyAJIAqUIg0gCyAOlCILk5Q4AhAgASASIBQgFpOUOAIIIAEgEiANIAuSlDgCBCABIBBDAACAPyAJIA+UIgkgDCAKlCIQkpOUOAIoIAEgE0MAAIA/IAkgESAOlCIJkpOUOAIUIAEgEkMAAIA/IBAgCZKTlDgCACABIAcqAgA4AjAgASAAKgIcOAI0IAAqAiAhCSABQYCAgPwDNgI8IAEgCTgCOCAGQRBqJAAgBSgCCCIAQX9HBEAgABAcIQAgAhAaGiAB/QkCDCEbIAH9CQIIIRwgAf0JAgAhHSAB/QkCBCEeIAH9CQIcIR8gAf0JAhghICAB/QkCECEhIAH9CQIUISIgAf0JAiwhIyAB/QkCKCEkIAH9CQIgISUgAf0JAiQhJiACIAD9AAIwIhcgAf0JAjz95gEgAP0AAiAiGCAB/QkCOP3mASAA/QACACIZIAH9CQIw/eYBIAD9AAIQIhogAf0JAjT95gH95AH95AH95AH9CwIwIAIgFyAj/eYBIBggJP3mASAZICX95gEgGiAm/eYB/eQB/eQB/eQB/QsCICACIBcgH/3mASAYICD95gEgGSAh/eYBIBogIv3mAf3kAf3kAf3kAf0LAhAgAiAXIBv95gEgGCAc/eYBIBkgHf3mASAeIBr95gH95AH95AH95AH9CwIAIAEgAv0AAjD9CwIwIAEgAv0AAiD9CwIgIAEgAv0AAhD9CwIQIAEgAv0AAgD9CwIACyAFQQA2AgALIAJBQGskACABCwsAIAAQHhogABAKCzEBAn8gAEHUJzYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBALIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC7kCAQN/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhAyACQgA3AiAgAkIANwIoIAJCADcCMCACQgA3ADcgAkIANwIYIAJBADYCFCACQZQkNgIQIAIgADYCDCACIAE2AgggACADaiEAQQAhAwJAIAQgAUEAEAkEQCACQQE2AjggBCACQQhqIAAgAEEBQQAgBCgCACgCFBEHACAAQQAgAigCIEEBRhshAwwBCyAEIAJBCGogAEEBQQAgBCgCACgCGBEFAAJAAkAgAigCLA4CAAECCyACKAIcQQAgAigCKEEBRhtBACACKAIkQQFGG0EAIAIoAjBBAUYbIQMMAQsgAigCIEEBRwRAIAIoAjANASACKAIkQQFHDQEgAigCKEEBRw0BCyACKAIYIQMLIAJBQGskACADCwQAIAALDgAgAEHQAGoQJEHQAGoLnCgBC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB6DMoAgAiBkEQIABBC2pBeHEgAEELSRsiBUEDdiIAdiIBQQNxBEACQCABQX9zQQFxIABqIgJBA3QiAUGQNGoiACABQZg0aigCACIBKAIIIgRGBEBB6DMgBkF+IAJ3cTYCAAwBCyAEIAA2AgwgACAENgIICyABQQhqIQAgASACQQN0IgJBA3I2AgQgASACaiIBIAEoAgRBAXI2AgQMDwsgBUHwMygCACIHTQ0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cSIAQQAgAGtxaCIBQQN0IgBBkDRqIgIgAEGYNGooAgAiACgCCCIERgRAQegzIAZBfiABd3EiBjYCAAwBCyAEIAI2AgwgAiAENgIICyAAIAVBA3I2AgQgACAFaiIIIAFBA3QiASAFayIEQQFyNgIEIAAgAWogBDYCACAHBEAgB0F4cUGQNGohAUH8MygCACECAn8gBkEBIAdBA3Z0IgNxRQRAQegzIAMgBnI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQfwzIAg2AgBB8DMgBDYCAAwPC0HsMygCACIKRQ0BIApBACAKa3FoQQJ0QZg2aigCACICKAIEQXhxIAVrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAVrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgRHBEBB+DMoAgAaIAIoAggiACAENgIMIAQgADYCCAwOCyACQRRqIgEoAgAiAEUEQCACKAIQIgBFDQMgAkEQaiEBCwNAIAEhCCAAIgRBFGoiASgCACIADQAgBEEQaiEBIAQoAhAiAA0ACyAIQQA2AgAMDQtBfyEFIABBv39LDQAgAEELaiIAQXhxIQVB7DMoAgAiCEUNAEEAIAVrIQMCQAJAAkACf0EAIAVBgAJJDQAaQR8gBUH///8HSw0AGiAFQSYgAEEIdmciAGt2QQFxIABBAXRrQT5qCyIHQQJ0QZg2aigCACIBRQRAQQAhAAwBC0EAIQAgBUEZIAdBAXZrQQAgB0EfRxt0IQIDQAJAIAEoAgRBeHEgBWsiBiADTw0AIAEhBCAGIgMNAEEAIQMgASEADAMLIAAgASgCFCIGIAYgASACQR12QQRxaigCECIBRhsgACAGGyEAIAJBAXQhAiABDQALCyAAIARyRQRAQQAhBEECIAd0IgBBACAAa3IgCHEiAEUNAyAAQQAgAGtxaEECdEGYNmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAVrIgIgA0khASACIAMgARshAyAAIAQgARshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANB8DMoAgAgBWtPDQAgBCgCGCEHIAQgBCgCDCICRwRAQfgzKAIAGiAEKAIIIgAgAjYCDCACIAA2AggMDAsgBEEUaiIBKAIAIgBFBEAgBCgCECIARQ0DIARBEGohAQsDQCABIQYgACICQRRqIgEoAgAiAA0AIAJBEGohASACKAIQIgANAAsgBkEANgIADAsLIAVB8DMoAgAiBE0EQEH8MygCACEAAkAgBCAFayIBQRBPBEAgACAFaiICIAFBAXI2AgQgACAEaiABNgIAIAAgBUEDcjYCBAwBCyAAIARBA3I2AgQgACAEaiIBIAEoAgRBAXI2AgRBACECQQAhAQtB8DMgATYCAEH8MyACNgIAIABBCGohAAwNCyAFQfQzKAIAIgJJBEBB9DMgAiAFayIBNgIAQYA0QYA0KAIAIgAgBWoiAjYCACACIAFBAXI2AgQgACAFQQNyNgIEIABBCGohAAwNC0EAIQAgBUEvaiIDAn9BwDcoAgAEQEHINygCAAwBC0HMN0J/NwIAQcQ3QoCggICAgAQ3AgBBwDcgC0EMakFwcUHYqtWqBXM2AgBB1DdBADYCAEGkN0EANgIAQYAgCyIBaiIGQQAgAWsiCHEiASAFTQ0MQaA3KAIAIgQEQEGYNygCACIHIAFqIgkgB00NDSAEIAlJDQ0LAkBBpDctAABBBHFFBEACQAJAAkACQEGANCgCACIEBEBBqDchAANAIAQgACgCACIHTwRAIAcgACgCBGogBEsNAwsgACgCCCIADQALC0EAEAsiAkF/Rg0DIAEhBkHENygCACIAQQFrIgQgAnEEQCABIAJrIAIgBGpBACAAa3FqIQYLIAUgBk8NA0GgNygCACIABEBBmDcoAgAiBCAGaiIIIARNDQQgACAISQ0ECyAGEAsiACACRw0BDAULIAYgAmsgCHEiBhALIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAFQTBqIAZNBEAgACECDAQLQcg3KAIAIgIgAyAGa2pBACACa3EiAhALQX9GDQEgAiAGaiEGIAAhAgwDCyACQX9HDQILQaQ3QaQ3KAIAQQRyNgIACyABEAshAkEAEAshACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgYgBUEoak0NBQtBmDdBmDcoAgAgBmoiADYCAEGcNygCACAASQRAQZw3IAA2AgALAkBBgDQoAgAiAwRAQag3IQADQCACIAAoAgAiASAAKAIEIgRqRg0CIAAoAggiAA0ACwwEC0H4MygCACIAQQAgACACTRtFBEBB+DMgAjYCAAtBACEAQaw3IAY2AgBBqDcgAjYCAEGINEF/NgIAQYw0QcA3KAIANgIAQbQ3QQA2AgADQCAAQQN0IgFBmDRqIAFBkDRqIgQ2AgAgAUGcNGogBDYCACAAQQFqIgBBIEcNAAtB9DMgBkEoayIAQXggAmtBB3FBACACQQhqQQdxGyIBayIENgIAQYA0IAEgAmoiATYCACABIARBAXI2AgQgACACakEoNgIEQYQ0QdA3KAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAGajYCBEGANCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQfQzQfQzKAIAIAZqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQYQ0QdA3KAIANgIADAMLQQAhBAwKC0EAIQIMCAtB+DMoAgAgAksEQEH4MyACNgIACyACIAZqIQFBqDchAAJAAkACQANAIAEgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBqDchAANAIAMgACgCACIBTwRAIAEgACgCBGoiBCADSw0DCyAAKAIIIQAMAAsACyAAIAI2AgAgACAAKAIEIAZqNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIHIAVBA3I2AgQgAUF4IAFrQQdxQQAgAUEIakEHcRtqIgYgBSAHaiIFayEAIAMgBkYEQEGANCAFNgIAQfQzQfQzKAIAIABqIgA2AgAgBSAAQQFyNgIEDAgLQfwzKAIAIAZGBEBB/DMgBTYCAEHwM0HwMygCACAAaiIANgIAIAUgAEEBcjYCBCAAIAVqIAA2AgAMCAsgBigCBCIDQQNxQQFHDQYgA0F4cSEJIANB/wFNBEAgBigCDCIBIAYoAggiAkYEQEHoM0HoMygCAEF+IANBA3Z3cTYCAAwHCyACIAE2AgwgASACNgIIDAYLIAYoAhghCCAGIAYoAgwiAkcEQCAGKAIIIgEgAjYCDCACIAE2AggMBQsgBkEUaiIBKAIAIgNFBEAgBigCECIDRQ0EIAZBEGohAQsDQCABIQQgAyICQRRqIgEoAgAiAw0AIAJBEGohASACKAIQIgMNAAsgBEEANgIADAQLQfQzIAZBKGsiAEF4IAJrQQdxQQAgAkEIakEHcRsiAWsiCDYCAEGANCABIAJqIgE2AgAgASAIQQFyNgIEIAAgAmpBKDYCBEGENEHQNygCADYCACADIARBJyAEa0EHcUEAIARBJ2tBB3EbakEvayIAIAAgA0EQakkbIgFBGzYCBCABQbA3KQIANwIQIAFBqDcpAgA3AghBsDcgAUEIajYCAEGsNyAGNgIAQag3IAI2AgBBtDdBADYCACABQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACACIARJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAIAJB/wFNBEAgAkF4cUGQNGohAAJ/QegzKAIAIgFBASACQQN2dCICcUUEQEHoMyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEGYNmohAQJAAkBB7DMoAgAiBEEBIAB0IgZxRQRAQewzIAQgBnI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBANAIAQiASgCBEF4cSACRg0CIABBHXYhBCAAQQF0IQAgASAEQQRxaiIGKAIQIgQNAAsgBiADNgIQCyADIAE2AhggAyADNgIMIAMgAzYCCAwBCyABKAIIIgAgAzYCDCABIAM2AgggA0EANgIYIAMgATYCDCADIAA2AggLQfQzKAIAIgAgBU0NAEH0MyAAIAVrIgE2AgBBgDRBgDQoAgAiACAFaiICNgIAIAIgAUEBcjYCBCAAIAVBA3I2AgQgAEEIaiEADAgLQagyQTA2AgBBACEADAcLQQAhAgsgCEUNAAJAIAYoAhwiAUECdEGYNmoiBCgCACAGRgRAIAQgAjYCACACDQFB7DNB7DMoAgBBfiABd3E2AgAMAgsgCEEQQRQgCCgCECAGRhtqIAI2AgAgAkUNAQsgAiAINgIYIAYoAhAiAQRAIAIgATYCECABIAI2AhgLIAYoAhQiAUUNACACIAE2AhQgASACNgIYCyAAIAlqIQAgBiAJaiIGKAIEIQMLIAYgA0F+cTYCBCAFIABBAXI2AgQgACAFaiAANgIAIABB/wFNBEAgAEF4cUGQNGohAQJ/QegzKAIAIgJBASAAQQN2dCIAcUUEQEHoMyAAIAJyNgIAIAEMAQsgASgCCAshACABIAU2AgggACAFNgIMIAUgATYCDCAFIAA2AggMAQtBHyEDIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQMLIAUgAzYCHCAFQgA3AhAgA0ECdEGYNmohAQJAAkBB7DMoAgAiAkEBIAN0IgRxRQRAQewzIAIgBHI2AgAgASAFNgIADAELIABBGSADQQF2a0EAIANBH0cbdCEDIAEoAgAhAgNAIAIiASgCBEF4cSAARg0CIANBHXYhAiADQQF0IQMgASACQQRxaiIEKAIQIgINAAsgBCAFNgIQCyAFIAE2AhggBSAFNgIMIAUgBTYCCAwBCyABKAIIIgAgBTYCDCABIAU2AgggBUEANgIYIAUgATYCDCAFIAA2AggLIAdBCGohAAwCCwJAIAdFDQACQCAEKAIcIgBBAnRBmDZqIgEoAgAgBEYEQCABIAI2AgAgAg0BQewzIAhBfiAAd3EiCDYCAAwCCyAHQRBBFCAHKAIQIARGG2ogAjYCACACRQ0BCyACIAc2AhggBCgCECIABEAgAiAANgIQIAAgAjYCGAsgBCgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAQgAyAFaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgBUEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQXhxQZA0aiEAAn9B6DMoAgAiAUEBIANBA3Z0IgNxRQRAQegzIAEgA3I2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAiAANgIcIAJCADcCECAAQQJ0QZg2aiEBAkACQCAIQQEgAHQiBnFFBEBB7DMgBiAIcjYCACABIAI2AgAMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIANGDQIgAEEddiEGIABBAXQhACABIAZBBHFqIgYoAhAiBQ0ACyAGIAI2AhALIAIgATYCGCACIAI2AgwgAiACNgIIDAELIAEoAggiACACNgIMIAEgAjYCCCACQQA2AhggAiABNgIMIAIgADYCCAsgBEEIaiEADAELAkAgCUUNAAJAIAIoAhwiAEECdEGYNmoiASgCACACRgRAIAEgBDYCACAEDQFB7DMgCkF+IAB3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBDYCACAERQ0BCyAEIAk2AhggAigCECIABEAgBCAANgIQIAAgBDYCGAsgAigCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAIgAyAFaiIAQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDAELIAIgBUEDcjYCBCACIAVqIgQgA0EBcjYCBCADIARqIAM2AgAgBwRAIAdBeHFBkDRqIQBB/DMoAgAhAQJ/QQEgB0EDdnQiBSAGcUUEQEHoMyAFIAZyNgIAIAAMAQsgACgCCAshBiAAIAE2AgggBiABNgIMIAEgADYCDCABIAY2AggLQfwzIAQ2AgBB8DMgAzYCAAsgAkEIaiEACyALQRBqJAAgAAuXAgAgAEUEQEEADwsCfwJAIAAEfyABQf8ATQ0BAkBBxDMoAgAoAgBFBEAgAUGAf3FBgL8DRg0DDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMBAsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMBAsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMBAsLQagyQRk2AgBBfwVBAQsMAQsgACABOgAAQQELC5YYAxJ/AXwCfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAGIAAgEyAQEAUgAEGzCEH2CCAFQSBxIgUbQcwIQfoIIAUbIAEgAWIbQQMQBSAAQSAgAiADIARBgMAAcxAGIAMgAiACIANIGyEJDAELIAxBEGohEQJAAn8CQCABIAxBLGoQKiIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiAMKAIsIQpBBiADIANBAEgbDAELIAwgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIAxBMGpBoAJBACAKQQBOG2oiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0BBHSADIANBHU4bIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgDCAMKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCALQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQlBACADayIDIANBCU4bIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAwgDCgCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAxqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAtBASALGyIGIANKIANBe0pxIgobIAZqIQtBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogCyAGIAlqQQlrIgZBACAGQQBKGyIGIAYgC0obIQsMAQtBACEKIAsgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAtKGyELC0F/IQkgC0H9////B0H+////ByAKIAtyIhIbSg0BIAsgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADIA5B/////wdzSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREAwiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBiAOQf////8Hc0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEAYgACATIBAQBSAAQTAgAiAFIARBgIAEcxAGAkACQAJAIBVBxgBGBEAgDEEQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQDCEGAkAgCCAJRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgBiAKRw0AIAxBMDoAGCADIQYLIAAgBiAKIAZrEAUgCEEEaiIIIA1NDQALIBIEQCAAQf4IQQEQBQsgByAITQ0BIAtBAEwNAQNAIAg1AgAgChAMIgYgDEEQaksEQANAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsLIAAgBkEJIAsgC0EJThsQBSALQQlrIQYgCEEEaiIIIAdPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAcgCEEEaiAHIAhLGyEJIAxBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAMIgZGBEAgDEEwOgAYIAMhBgsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAFIAZBAWohBiAKIAtyRQ0AIABB/ghBARAFCyAAIAYgDSAGayIGIAsgBiALSBsQBSALIAZrIQsgB0EEaiIHIAlPDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEAYgACAPIBEgD2sQBQwCCyALIQYLIABBMCAGQQlqQQlBABAGCyAAQSAgAiAFIARBgMAAcxAGIAUgAiACIAVIGyEJDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAgtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgDCgCLCIGIAZBH3UiBnMgBmutIBEQDCIGRgRAIAxBMDoADyAMQQ9qIQYLIBBBAnIhCyAFQSBxIQ0gDCgCLCEHIAZBAmsiCiAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HgI2otAAAgDXI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgDEEQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAsgESAKayIGaiINayADSA0AIABBICACIA0gA0ECaiAHIAxBEGoiB2siBSAFQQJrIANIGyAFIAMbIglqIgMgBBAGIAAgCCALEAUgAEEwIAIgAyAEQYCABHMQBiAAIAcgBRAFIABBMCAJIAVrQQBBABAGIAAgCiAGEAUgAEEgIAIgAyAEQYDAAHMQBiADIAIgAiADSBshCQsgDEGwBGokACAJC7QCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsACw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAtyAQN/IAAoAgAsAABBMGtBCk8EQEEADwsDQCAAKAIAIQNBfyEBIAJBzJmz5gBNBEBBfyADLAAAQTBrIgEgAkEKbCICaiABIAJB/////wdzShshAQsgACADQQFqNgIAIAEhAiADLAABQTBrQQpJDQALIAILkRQCE38BfkGHCSELIwBB0ABrIgUkACAFQYcJNgJMIAVBN2ohFSAFQThqIRACQAJAAkACQANAIAshCiAEIAxB/////wdzSg0BIAQgDGohDAJAAkACQCAKIgQtAAAiBgRAA0ACQAJAIAZB/wFxIgtFBEAgBCELDAELIAtBJUcNASAEIQYDQCAGLQABQSVHBEAgBiELDAILIARBAWohBCAGLQACIQcgBkECaiILIQYgB0ElRg0ACwsgBCAKayIEIAxB/////wdzIhZKDQcgAARAIAAgCiAEEAULIAQNBiAFIAs2AkwgC0EBaiEEQX8hDQJAIAssAAFBMGtBCk8NACALLQACQSRHDQAgC0EDaiEEIAssAAFBMGshDUEBIRELIAUgBDYCTEEAIQgCQCAELAAAIgZBIGsiC0EfSwRAIAQhBwwBCyAEIQdBASALdCILQYnRBHFFDQADQCAFIARBAWoiBzYCTCAIIAtyIQggBCwAASIGQSBrIgtBIE8NASAHIQRBASALdCILQYnRBHENAAsLAkAgBkEqRgRAAn8CQCAHLAABQTBrQQpPDQAgBy0AAkEkRw0AIAcsAAFBAnQgA2pBwAFrQQo2AgAgB0EDaiEGQQEhESAHLAABQQN0IAJqQYADaygCAAwBCyARDQYgB0EBaiEGIABFBEAgBSAGNgJMQQAhEUEAIQ4MAwsgASABKAIAIgRBBGo2AgBBACERIAQoAgALIQ4gBSAGNgJMIA5BAE4NAUEAIA5rIQ4gCEGAwAByIQgMAQsgBUHMAGoQKCIOQQBIDQggBSgCTCEGC0EAIQRBfyEJAn8gBi0AAEEuRwRAIAYhC0EADAELIAYtAAFBKkYEQAJ/AkAgBiwAAkEwa0EKTw0AIAYtAANBJEcNACAGLAACQQJ0IANqQcABa0EKNgIAIAZBBGohCyAGLAACQQN0IAJqQYADaygCAAwBCyARDQYgBkECaiELQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCSAFIAs2AkwgCUF/c0EfdgwBCyAFIAZBAWo2AkwgBUHMAGoQKCEJIAUoAkwhC0EBCyESA0AgBCEPQRwhByALIhQsAAAiBEH7AGtBRkkNCSAUQQFqIQsgBCAPQTpsakHPH2otAAAiBEEBa0EISQ0ACyAFIAs2AkwCQAJAIARBG0cEQCAERQ0LIA1BAE4EQCADIA1BAnRqIAQ2AgAgBSACIA1BA3RqKQMANwNADAILIABFDQggBUFAayAEIAEQJwwCCyANQQBODQoLQQAhBCAARQ0HCyAIQf//e3EiBiAIIAhBgMAAcRshCEEAIQ1BgAghEyAQIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAULAAAIgRBX3EgBCAEQQ9xQQNGGyAEIA8bIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAFKQNAIRdBgAgMBQtBACEEAkACQAJAAkACQAJAAkAgD0H/AXEOCAABAgMEGgUGGgsgBSgCQCAMNgIADBkLIAUoAkAgDDYCAAwYCyAFKAJAIAysNwMADBcLIAUoAkAgDDsBAAwWCyAFKAJAIAw6AAAMFQsgBSgCQCAMNgIADBQLIAUoAkAgDKw3AwAMEwtBCCAJIAlBCE0bIQkgCEEIciEIQfgAIQQLIBAhCiAFKQNAIhdCAFIEQCAEQSBxIQYDQCAKQQFrIgogF6dBD3FB4CNqLQAAIAZyOgAAIBdCD1YhDyAXQgSIIRcgDw0ACwsgBSkDQFANAyAIQQhxRQ0DIARBBHZBgAhqIRNBAiENDAMLIBAhBCAFKQNAIhdCAFIEQANAIARBAWsiBCAXp0EHcUEwcjoAACAXQgdWIQogF0IDiCEXIAoNAAsLIAQhCiAIQQhxRQ0CIAkgECAKayIEQQFqIAQgCUgbIQkMAgsgBSkDQCIXQgBTBEAgBUIAIBd9Ihc3A0BBASENQYAIDAELIAhBgBBxBEBBASENQYEIDAELQYIIQYAIIAhBAXEiDRsLIRMgFyAQEAwhCgsgEkEAIAlBAEgbDQ4gCEH//3txIAggEhshCAJAIAUpA0AiF0IAUg0AIAkNACAQIQpBACEJDAwLIAkgF1AgECAKa2oiBCAEIAlIGyEJDAsLAn9B/////wcgCSAJQf////8HTxsiDyIHQQBHIQgCQAJAAkAgBSgCQCIEQYAJIAQbIgoiBEEDcUUNACAHRQ0AA0AgBC0AAEUNAiAHQQFrIgdBAEchCCAEQQFqIgRBA3FFDQEgBw0ACwsgCEUNAQJAIAQtAABFDQAgB0EESQ0AA0AgBCgCACIIQX9zIAhBgYKECGtxQYCBgoR4cQ0CIARBBGohBCAHQQRrIgdBA0sNAAsLIAdFDQELA0AgBCAELQAARQ0CGiAEQQFqIQQgB0EBayIHDQALC0EACyIEIAprIA8gBBsiBCAKaiEHIAlBAE4EQCAGIQggBCEJDAsLIAYhCCAEIQkgBy0AAA0NDAoLIAkEQCAFKAJADAILQQAhBCAAQSAgDkEAIAgQBgwCCyAFQQA2AgwgBSAFKQNAPgIIIAUgBUEIaiIENgJAQX8hCSAECyEGQQAhBAJAA0AgBigCACIKRQ0BAkAgBUEEaiAKECUiCkEASCIHDQAgCiAJIARrSw0AIAZBBGohBiAEIApqIgQgCUkNAQwCCwsgBw0NC0E9IQcgBEEASA0LIABBICAOIAQgCBAGIARFBEBBACEEDAELQQAhByAFKAJAIQYDQCAGKAIAIgpFDQEgBUEEaiAKECUiCiAHaiIHIARLDQEgACAFQQRqIAoQBSAGQQRqIQYgBCAHSw0ACwsgAEEgIA4gBCAIQYDAAHMQBiAOIAQgBCAOSBshBAwICyASQQAgCUEASBsNCEE9IQcgACAFKwNAIA4gCSAIIAQQJiIEQQBODQcMCQsgBSAFKQNAPAA3QQEhCSAVIQogBiEIDAQLIAQtAAEhBiAEQQFqIQQMAAsACyAADQcgEUUNAkEBIQQDQCADIARBAnRqKAIAIgAEQCACIARBA3RqIAAgARAnQQEhDCAEQQFqIgRBCkcNAQwJCwtBASEMIARBCk8NBwNAIAMgBEECdGooAgANASAEQQFqIgRBCkcNAAsMBwtBHCEHDAQLIAkgByAKayIPIAkgD0obIgkgDUH/////B3NKDQJBPSEHIA4gCSANaiIGIAYgDkgbIgQgFkoNAyAAQSAgBCAGIAgQBiAAIBMgDRAFIABBMCAEIAYgCEGAgARzEAYgAEEwIAkgD0EAEAYgACAKIA8QBSAAQSAgBCAGIAhBgMAAcxAGDAELC0EAIQwMAwtBPSEHC0GoMiAHNgIAC0F/IQwLIAVB0ABqJAAgDAt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARAqIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLegEDfwJAAkAgACIBQQNxRQ0AIAAtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohASACKAIAIgNBf3MgA0GBgoQIa3FBgIGChHhxRQ0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLgAQBA38gAkGABE8EQCAAIAEgAhAEIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAACwMAAQv4DwIUfwN8IwBBEGsiCyQAAkAgALwiEUH/////B3EiA0Han6TuBE0EQCABIAC7IhcgF0SDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIWRAAAAFD7Ifm/oqAgFkRjYhphtBBRvqKgIhg5AwAgGEQAAABg+yHpv2MhAgJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyEDIAIEQCABIBcgFkQAAAAAAADwv6AiFkQAAABQ+yH5v6KgIBZEY2IaYbQQUb6ioDkDACADQQFrIQMMAgsgGEQAAABg+yHpP2RFDQEgASAXIBZEAAAAAAAA8D+gIhZEAAAAUPsh+b+ioCAWRGNiGmG0EFG+oqA5AwAgA0EBaiEDDAELIANBgICA/AdPBEAgASAAIACTuzkDAEEAIQMMAQsgCyADIANBF3ZBlgFrIgNBF3Rrvrs5AwggC0EIaiEOIwBBsARrIgUkACADIANBA2tBGG0iAkEAIAJBAEobIg1BaGxqIQZB8AkoAgAiB0EATgRAIAdBAWohAyANIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBgApqKAIAtws5AwAgAkEBaiECIARBAWoiBCADRw0ACwsgBkEYayEIQQAhAyAHQQAgB0EAShshBANAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEYhAiADQQFqIQMgAkUNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgByEDAkADQCAFIANBA3RqKwMAIRZBACECIAMhBCADQQBMIglFBEADQCAFQeADaiACQQJ0agJ/An8gFkQAAAAAAABwPqIiF5lEAAAAAAAA4EFjBEAgF6oMAQtBgICAgHgLtyIXRAAAAAAAAHDBoiAWoCIWmUQAAAAAAADgQWMEQCAWqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBegIRYgAkEBaiICIANHDQALCwJ/IBYgCBAPIhYgFkQAAAAAAADAP6KcRAAAAAAAACDAoqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLIQogFiAKt6EhFgJAAkACQAJ/IAhBAEwiFEUEQCADQQJ0IAVqIgIgAigC3AMiAiACIA91IgIgD3RrIgQ2AtwDIAIgCmohCiAEIBJ1DAELIAgNASADQQJ0IAVqKALcA0EXdQsiDEEATA0CDAELQQIhDCAWRAAAAAAAAOA/Zg0AQQAhDAwBC0EAIQJBACEEIAlFBEADQCAFQeADaiACQQJ0aiIVKAIAIQlB////ByEQAn8CQCAEDQBBgICACCEQIAkNAEEADAELIBUgECAJazYCAEEBCyEEIAJBAWoiAiADRw0ACwsCQCAUDQBB////AyECAkACQCATDgIBAAILQf///wEhAgsgA0ECdCAFaiIJIAkoAtwDIAJxNgLcAwsgCkEBaiEKIAxBAkcNAEQAAAAAAADwPyAWoSEWQQIhDCAERQ0AIBZEAAAAAAAA8D8gCBAPoSEWCyAWRAAAAAAAAAAAYQRAQQAhBAJAIAcgAyICTg0AA0AgBUHgA2ogAkEBayICQQJ0aigCACAEciEEIAIgB0oNAAsgBEUNACAIIQYDQCAGQRhrIQYgBUHgA2ogA0EBayIDQQJ0aigCAEUNAAsMAwtBASECA0AgAiIEQQFqIQIgBUHgA2ogByAEa0ECdGooAgBFDQALIAMgBGohBANAIAVBwAJqIANBAWoiA0EDdGogAyANakECdEGACmooAgC3OQMAQQAhAkQAAAAAAAAAACEWA0AgDiACQQN0aisDACAFQcACaiADIAJrQQN0aisDAKIgFqAhFiACQQFqIgJBAUcNAAsgBSADQQN0aiAWOQMAIAMgBEgNAAsgBCEDDAELCwJAIBZBGCAGaxAPIhZEAAAAAAAAcEFmBEAgBUHgA2ogA0ECdGoCfwJ/IBZEAAAAAAAAcD6iIheZRAAAAAAAAOBBYwRAIBeqDAELQYCAgIB4CyICt0QAAAAAAABwwaIgFqAiFplEAAAAAAAA4EFjBEAgFqoMAQtBgICAgHgLNgIAIANBAWohAwwBCwJ/IBaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4CyECIAghBgsgBUHgA2ogA0ECdGogAjYCAAtEAAAAAAAA8D8gBhAPIRYCQCADQQBIDQAgAyECA0AgBSACIgRBA3RqIBYgBUHgA2ogAkECdGooAgC3ojkDACACQQFrIQIgFkQAAAAAAABwPqIhFiAEDQALIANBAEgNACADIQQDQEQAAAAAAAAAACEWQQAhAiAHIAMgBGsiBiAGIAdKGyIIQQBOBEADQCACQQN0QdAfaisDACAFIAIgBGpBA3RqKwMAoiAWoCEWIAIgCEchDSACQQFqIQIgDQ0ACwsgBUGgAWogBkEDdGogFjkDACAEQQBKIQIgBEEBayEEIAINAAsLRAAAAAAAAAAAIRYgA0EATgRAA0AgAyICQQFrIQMgFiAFQaABaiACQQN0aisDAKAhFiACDQALCyALIBaaIBYgDBs5AwAgBUGwBGokACAKQQdxIQMgCysDACEWIBFBAEgEQCABIBaaOQMAQQAgA2shAwwBCyABIBY5AwALIAtBEGokACADC/YEAQh/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAiABQSRsaiEAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgAEcNAAsgAAUgAgs2AgQPCwJAIAIgACgCACICa0EkbSIGIAFqIgNByOPxOEkEQEHH4/E4IAQgAmtBJG0iAkEBdCIEIAMgAyAESRsgAkHj8bgcTxsiBARAIARByOPxOE8NAiAEQSRsEA4hBQsgBSAGQSRsaiIDIAFBJGxqIQYgAyECA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAkEANgIgIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIQIAJBADYCCCACQgA3AgAgAkEMaiIBQQA2AgggAUIANwIAIAJBGGoiAUEANgIIIAFCADcCACACQSRqIgIgBkcNAAsgBSAEQSRsaiEIAkAgACgCBCICIAAoAgAiCUYEQCADIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIAUgASoCBDgCBCAFIAEqAgg4AgggA0EYayIEIAJBGGsiByoCADgCACAEIAcqAgQ4AgQgBCAHKgIIOAIIIANBDGsiAyACQQxrIgIqAgA4AgAgAyACKgIEOAIEIAMgAioCCDgCCCAFIQMgASICIAlHDQALIAAoAgAhAgsgACAINgIIIAAgBjYCBCAAIAU2AgAgAgRAIAIQCgsPCxAZAAsQGAALrgoBCH8CQEHoKSgCAEHkKSgCACICa0EGdSIBIABJBEAgACABayIDQewpKAIAIgRB6CkoAgAiAWtBBnVNBEBB6CkgAwR/IAEgA0EGdGohAgNAIAEQGkFAayIBIAJHDQALIAIFIAELNgIADAILAkAgAUHkKSgCACICa0EGdSIGIANqIgVBgICAIEkEQEH///8fIAQgAmsiAUEFdSICIAUgAiAFSxsgAUHA////B08bIgcEfyAHQYCAgCBPDQIgB0EGdBAOBUEACyIEIAZBBnRqIgIgA0EGdGohBSACIQEDQCABEBpBQGsiASAFRw0AC0HoKSgCACIBQeQpKAIAIgZHBEADQCACQUBqIgMgAUFAaiIBIgL9AAIA/QsCACADIAL9AAIw/QsCMCADIAL9AAIg/QsCICADIAL9AAIQ/QsCECADIQIgASAGRw0AC0HkKSgCACEBC0HsKSAEIAdBBnRqNgIAQegpIAU2AgBB5CkgAjYCACABBEAgARAQCwwDCxAZAAsQGAALIAAgAU8NAEHoKSACIABBBnRqNgIACwJAQfQpKAIAQfApKAIAIgJrQSRtIgEgAEkEQEHwKSAAIAFrEC8MAQsgACABTw0AQfQpIAIgAEEkbGo2AgALAkBBgCooAgBB/CkoAgAiAmtBBHUiASAASQRAQQAhBEEAIQcgACABayIDQYQqKAIAIgZBgCooAgAiAmtBBHVNBEACQCADRQ0AIAIhASADQQdxIggEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAEQQFqIgQgCEcNAAsLIANBBHQgAmohAiADQQFrQf////8AcUEHSQ0AA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASACRw0ACwtBgCogAjYCAAwCCwJAIAJB/CkoAgAiAWtBBHUiBCADaiIFQYCAgIABSQRAQf////8AIAYgAWsiBkEDdSIBIAUgASAFSxsgBkHw////B08bIgUEQCAFQYCAgIABTw0CIAVBBHQQDiEHCyAHIARBBHRqIgQhASADQQdxIgYEQANAIAFC/////w83AgggAUIANwIAIAFBEGohASAIQQFqIgggBkcNAAsLIANBBHQgBGohCCADQQFrQf////8AcUEHTwRAA0AgAUIANwJwIAFCADcCYCABQgA3AlAgAUIANwJAIAFCADcCMCABQgA3AiAgAUIANwIQIAFC/////w83AgggAUIANwIAIAFC/////w83AnggAUL/////DzcCaCABQv////8PNwJYIAFC/////w83AkggAUL/////DzcCOCABQv////8PNwIoIAFC/////w83AhggAUGAAWoiASAIRw0ACwtB/CkoAgAiASACRwRAA0AgBEEQayIEIAJBEGsiAv0AAgD9CwIAIAEgAkcNAAtB/CkoAgAhAgtBhCogByAFQQR0ajYCAEGAKiAINgIAQfwpIAQ2AgAgAgRAIAIQEAsMAwsQGQALEBgACyAAIAFPDQBBgCogAiAAQQR0ajYCAAtBjCooAgBBiCooAgAiAmtBJG0iASAASQRAQYgqIAAgAWsQLw8LIAAgAUkEQEGMKiACIABBJGxqNgIACwsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLGQBBiCooAgAiAARAQYwqIAA2AgAgABAKCwsFAEG3CAsFAEHnCAsFAEGkCAsVACAARQRAQQAPCyAAQaQlECFBAEcLGgAgACABKAIIIAUQCQRAIAEgAiADIAQQHwsLNwAgACABKAIIIAUQCQRAIAEgAiADIAQQHw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEHAAunAQAgACABKAIIIAQQCQRAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLDwsCQCAAIAEoAgAgBBAJRQ0AAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0BIAFBATYCIA8LIAEgAjYCFCABIAM2AiAgASABKAIoQQFqNgIoAkAgASgCJEEBRw0AIAEoAhhBAkcNACABQQE6ADYLIAFBBDYCLAsLiAIAIAAgASgCCCAEEAkEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCQRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQcAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQUACwsZAEH8KSgCACIABEBBgCogADYCACAAEAoLCzEAIAAgASgCCEEAEAkEQCABIAIgAxAgDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRBgALGAAgACABKAIIQQAQCQRAIAEgAiADECALC5sBAQF/IwBBQGoiAyQAAn9BASAAIAFBABAJDQAaQQAgAUUNABpBACABQcQkECEiAUUNABogA0EMakEAQTQQESADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshACADQUBrJAAgAAsZAEHwKSgCACIABEBB9CkgADYCACAAEAoLCxkAQeQpKAIAIgAEQEHoKSAANgIAIAAQCgsLBABCAAsEAEEAC/QCAQd/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQcCfwJAAkACQCAAKAI8IANBEGoiAUECIANBDGoQACIEBH9BqDIgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgASAGIAEoAgQiCEsiCUEDdGoiBCAGIAhBACAJG2siCCAEKAIAajYCACABQQxBBCAJG2oiASABKAIAIAhrNgIAIAUgBmshBSAAKAI8IAQiASAHIAlrIgcgA0EMahAAIgYEf0GoMiAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIQAgA0EgaiQAIAALhwIAQZQpKAIAGgJAQX9BAAJ/QdAIECsiAAJ/QZQpKAIAQQBIBEBB0AggAEHIKBAUDAELQdAIIABByCgQFAsiASAARg0AGiABCyAARxtBAEgNAAJAQZgpKAIAQQpGDQBB3CgoAgAiAEHYKCgCAEYNAEHcKCAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQdgoKAIAIgEEfyABBUHIKBAVDQJB2CgoAgALQdwoKAIAIgFGDQBBmCkoAgBBCkYNAEHcKCABQQFqNgIAIAFBCjoAAAwBC0HIKCAAQQ9qQQFB7CgoAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACyYAQeApIAI4AgAgACABSARAA0AgABAcGiAAQQFqIgAgAUcNAAsLC+UEAgZ/D30jAEGAAWsiASQAQeQpKAIAIABBBnRqIgAqAgAhByAAKgIEIQggACoCCCEJIAAqAgwhCiAAKgIQIQsgACoCFCEMIAAqAhghDSAAKgIcIQ4gACoCICEPIAAqAiQhECAAKgIoIREgACoCLCESIAAqAjAhEyAAKgI0IRQgACoCOCEVIAEgACoCPLs5A3ggASAVuzkDcCABIBS7OQNoIAEgE7s5A2AgASASuzkDWCABIBG7OQNQIAEgELs5A0ggAUFAayAPuzkDACABIA67OQM4IAEgDbs5AzAgASAMuzkDKCABIAu7OQMgIAEgCrs5AxggASAJuzkDECABIAi7OQMIIAEgB7s5AwAjAEEQayIEJAAgBCABNgIMIwBB0AFrIgAkACAAIAE2AswBIABBoAFqIgJBAEEoEBEgACAAKALMATYCyAECQEEAIABByAFqIABB0ABqIAIQKUEASA0AQZQpKAIAQQBOIQVByCgoAgAhAkGQKSgCAEEATARAQcgoIAJBX3E2AgALAn8CQAJAQfgoKAIARQRAQfgoQdAANgIAQeQoQQA2AgBB2ChCADcDAEH0KCgCACEDQfQoIAA2AgAMAQtB2CgoAgANAQtBf0HIKBAVDQEaC0HIKCAAQcgBaiAAQdAAaiAAQaABahApCyEGIAMEf0HIKEEAQQBB7CgoAgARAgAaQfgoQQA2AgBB9CggAzYCAEHkKEEANgIAQdwoKAIAGkHYKEIANwMAQQAFIAYLGkHIKEHIKCgCACACQSBxcjYCACAFRQ0ACyAAQdABaiQAIARBEGokACABQYABaiQACwgAQYgqKAIACwgAQfwpKAIACwgAQfApKAIACwgAQeQpKAIACwvnHxQAQYAIC8cXLSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgBlbXNjcmlwdGVuIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEHTHwt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhIAshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEGbIQsBDABBpyELFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1SELARAAQeEhCxUPAAAABA8AAAAACRAAAAAAABAAABAAQY8iCwESAEGbIgseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEHSIgsOGgAAABoaGgAAAAAAAAkAQYMjCwEUAEGPIwsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEG9IwsBFgBBySML/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADgEgAA8BEAAEAUAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADgEgAAIBIAABQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADgEgAAUBIAABQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDgEgAAgBIAAHQSAAAAAAAARBIAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAAAAAACgTAAALAAAAEwAAAA0AAAAOAAAADwAAABQAAAAVAAAAFgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADgEgAAABMAAEQSAAAAAAAAmBMAAAEAAAAXAAAAGAAAAAAAAADAEwAAAQAAABkAAAAaAAAAAAAAAIATAAABAAAAGwAAABwAAABTdDlleGNlcHRpb24AAAAAuBIAAHATAABTdDliYWRfYWxsb2MAAAAA4BIAAIgTAACAEwAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAOASAACkEwAAmBMAAAAAAADwEwAAAgAAAB0AAAAeAAAAU3QxMWxvZ2ljX2Vycm9yAOASAADgEwAAgBMAAAAAAAAkFAAAAgAAAB8AAAAeAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADgEgAAEBQAAPATAABTdDl0eXBlX2luZm8AAAAAuBIAADAUAEHIKAsBBQBB1CgLAQcAQewoCw4IAAAACQAAACgVAAAABABBhCkLAQEAQZQpCwX/////CgBB2CkLA+AbAQ==\";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}function getBinaryPromise(binaryFile){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==\"function\"&&!isFileURI(binaryFile)){return fetch(binaryFile,{credentials:\"same-origin\"}).then((response=>{if(!response[\"ok\"]){throw\"failed to load wasm binary file at '\"+binaryFile+\"'\"}return response[\"arrayBuffer\"]()})).catch((()=>getBinarySync(binaryFile)))}else if(readAsync){return new Promise(((resolve,reject)=>{readAsync(binaryFile,(response=>resolve(new Uint8Array(response))),reject)}))}}return Promise.resolve().then((()=>getBinarySync(binaryFile)))}function instantiateArrayBuffer(binaryFile,imports,receiver){return getBinaryPromise(binaryFile).then((binary=>WebAssembly.instantiate(binary,imports))).then((instance=>instance)).then(receiver,(reason=>{err(\"failed to asynchronously prepare wasm: \"+reason);abort(reason)}))}function instantiateAsync(binary,binaryFile,imports,callback){if(!binary&&typeof WebAssembly.instantiateStreaming==\"function\"&&!isDataURI(binaryFile)&&!isFileURI(binaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch==\"function\"){return fetch(binaryFile,{credentials:\"same-origin\"}).then((response=>{var result=WebAssembly.instantiateStreaming(response,imports);return result.then(callback,(function(reason){err(\"wasm streaming compile failed: \"+reason);err(\"falling back to ArrayBuffer instantiation\");return instantiateArrayBuffer(binaryFile,imports,callback)}))}))}return instantiateArrayBuffer(binaryFile,imports,callback)}function createWasm(){var info={\"a\":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module[\"asm\"]=exports;wasmMemory=Module[\"asm\"][\"f\"];updateMemoryViews();wasmTable=Module[\"asm\"][\"h\"];addOnInit(Module[\"asm\"][\"g\"]);removeRunDependency(\"wasm-instantiate\");return exports}addRunDependency(\"wasm-instantiate\");function receiveInstantiationResult(result){receiveInstance(result[\"instance\"])}if(Module[\"instantiateWasm\"]){try{return Module[\"instantiateWasm\"](info,receiveInstance)}catch(e){err(\"Module.instantiateWasm callback failed with error: \"+e);return false}}instantiateAsync(wasmBinary,wasmBinaryFile,info,receiveInstantiationResult);return{}}function ExitStatus(status){this.name=\"ExitStatus\";this.message=`Program terminated with exit(${status})`;this.status=status}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor)};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw exceptionLast}var _abort=()=>{abort(\"\")};var _emscripten_memcpy_big=(dest,src,num)=>HEAPU8.copyWithin(dest,src,src+num);var getHeapMax=()=>2147483648;var growMemory=size=>{var b=wasmMemory.buffer;var pages=size-b.byteLength+65535>>>16;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}var alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var printCharBuffers=[null,[],[]];var UTF8Decoder=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):undefined;var UTF8ArrayToString=(heapOrArray,idx,maxBytesToRead)=>{var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str=\"\";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str};var printChar=(stream,curr)=>{var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}};var UTF8ToString=(ptr,maxBytesToRead)=>ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):\"\";var SYSCALLS={varargs:undefined,get(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr(ptr){var ret=UTF8ToString(ptr);return ret}};var _fd_write=(fd,iov,iovcnt,pnum)=>{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,HEAPU8[ptr+j])}num+=len}HEAPU32[pnum>>2]=num;return 0};var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module[\"onExit\"])Module[\"onExit\"](code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx};var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var wasmImports={b:___cxa_throw,d:_abort,e:_emscripten_memcpy_big,c:_emscripten_resize_heap,a:_fd_write};var asm=createWasm();var ___wasm_call_ctors=function(){return(___wasm_call_ctors=Module[\"asm\"][\"g\"]).apply(null,arguments)};var _allocation=Module[\"_allocation\"]=function(){return(_allocation=Module[\"_allocation\"]=Module[\"asm\"][\"i\"]).apply(null,arguments)};var _getMatrixBufferPtr=Module[\"_getMatrixBufferPtr\"]=function(){return(_getMatrixBufferPtr=Module[\"_getMatrixBufferPtr\"]=Module[\"asm\"][\"j\"]).apply(null,arguments)};var _getSRTPtr=Module[\"_getSRTPtr\"]=function(){return(_getSRTPtr=Module[\"_getSRTPtr\"]=Module[\"asm\"][\"k\"]).apply(null,arguments)};var _getInfoPtr=Module[\"_getInfoPtr\"]=function(){return(_getInfoPtr=Module[\"_getInfoPtr\"]=Module[\"asm\"][\"l\"]).apply(null,arguments)};var _getContinuedSRTPtr=Module[\"_getContinuedSRTPtr\"]=function(){return(_getContinuedSRTPtr=Module[\"_getContinuedSRTPtr\"]=Module[\"asm\"][\"m\"]).apply(null,arguments)};var _printMatrix=Module[\"_printMatrix\"]=function(){return(_printMatrix=Module[\"_printMatrix\"]=Module[\"asm\"][\"n\"]).apply(null,arguments)};var _updateAllMatrixContinueTransform=Module[\"_updateAllMatrixContinueTransform\"]=function(){return(_updateAllMatrixContinueTransform=Module[\"_updateAllMatrixContinueTransform\"]=Module[\"asm\"][\"o\"]).apply(null,arguments)};var _main=Module[\"_main\"]=function(){return(_main=Module[\"_main\"]=Module[\"asm\"][\"p\"]).apply(null,arguments)};var ___errno_location=function(){return(___errno_location=Module[\"asm\"][\"__errno_location\"]).apply(null,arguments)};var stackAlloc=function(){return(stackAlloc=Module[\"asm\"][\"q\"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return(___cxa_is_pointer_type=Module[\"asm\"][\"r\"]).apply(null,arguments)};var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args=[]){var entryFunction=_main;args.unshift(thisProgram);var argc=args.length;var argv=stackAlloc((argc+1)*4);var argv_ptr=argv>>2;args.forEach((arg=>{HEAP32[argv_ptr++]=stringToUTF8OnStack(arg)}));HEAP32[argv_ptr]=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(args=arguments_){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();if(Module[\"onRuntimeInitialized\"])Module[\"onRuntimeInitialized\"]();if(shouldRunNow)callMain(args);postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout((function(){setTimeout((function(){Module[\"setStatus\"](\"\")}),1);doRun()}),1)}else{doRun()}}if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].pop()()}}var shouldRunNow=true;if(Module[\"noInitialRun\"])shouldRunNow=false;run();\n\nif (!Module['ENVIRONMENT_IS_PTHREAD']) {\n    // console.log(\"is main\");\n    window['wasmMatrix'] = Module;\n}\n        ";

    class WasmMatrix {
      static matrixBuffer;
      static matrixSRTBuffer;
      static matrixContinuedSRTBuffer;
      static matrixStateBuffer;
      static matrixBufferPtr;
      static matrixSRTBufferPtr;
      static matrixContinuedSRTBufferPtr;
      static matrixStateBufferPtr;
      static wasm;
      static stateStruct = 4;
      static async init(count) {
        await new Promise((resolve) => {
          const script = document.createElement("script");
          script.async = true;
          script.type = "text/javascript";
          script.src = URL.createObjectURL(new Blob([matrixjs]));
          document.head.appendChild(script);
          script.onload = () => {
            let check = () => {
              this.wasm = window["wasmMatrix"];
              if (this.wasm && this.wasm["calledRun"])
                resolve(true);
              else
                setTimeout(check, 20);
            };
            check();
          };
        });
        this.allocMatrix(count);
      }
      static allocMatrix(count) {
        if (count > Matrix4.maxCount) {
          console.error(`The maximum allocation size is exceeded! current:${count}, limit:${Matrix4.maxCount}`);
        }
        this.wasm._allocation(count);
        this.matrixBufferPtr = this.wasm._getMatrixBufferPtr();
        this.matrixSRTBufferPtr = this.wasm._getSRTPtr();
        this.matrixStateBufferPtr = this.wasm._getInfoPtr();
        this.matrixContinuedSRTBufferPtr = this.wasm._getContinuedSRTPtr();
        this.matrixBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixBufferPtr, 16 * count);
        this.matrixSRTBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixSRTBufferPtr, 3 * 3 * count);
        this.matrixContinuedSRTBuffer = new Float32Array(this.wasm.HEAPF32.buffer, this.matrixContinuedSRTBufferPtr, 3 * 3 * count);
        this.matrixStateBuffer = new Int32Array(this.wasm.HEAP32.buffer, this.matrixStateBufferPtr, WasmMatrix.stateStruct * count);
        Matrix4.allocMatrix(count);
      }
      static updateAllContinueTransform(start, end, dt) {
        this.wasm._updateAllMatrixContinueTransform(start, end, dt);
      }
      static setParent(matIndex, x, depthOrder) {
        this.matrixStateBuffer[matIndex * WasmMatrix.stateStruct + 2] = x >= 0 ? x : -1;
        this.matrixStateBuffer[matIndex * WasmMatrix.stateStruct + 3] = depthOrder;
      }
      static setTranslate(matIndex, x, y, z) {
        this.matrixSRTBuffer[matIndex * 9 + 6] = x;
        this.matrixSRTBuffer[matIndex * 9 + 7] = y;
        this.matrixSRTBuffer[matIndex * 9 + 8] = z;
      }
      static setRotation(matIndex, x, y, z) {
        this.matrixSRTBuffer[matIndex * 9 + 3] = x % 360;
        this.matrixSRTBuffer[matIndex * 9 + 4] = y % 360;
        this.matrixSRTBuffer[matIndex * 9 + 5] = z % 360;
      }
      static setScale(matIndex, x, y, z) {
        this.matrixSRTBuffer[matIndex * 9 + 0] = x;
        this.matrixSRTBuffer[matIndex * 9 + 1] = y;
        this.matrixSRTBuffer[matIndex * 9 + 2] = z;
      }
      static setContinueTranslate(matIndex, x, y, z) {
        if (x != 0 || y != 0 || z != 0) {
          this.matrixContinuedSRTBuffer[matIndex * 9 + 6] = x;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 7] = y;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 8] = z;
          this.matrixStateBuffer[matIndex * WasmMatrix.stateStruct + 1] = 1;
        }
      }
      static setContinueRotation(matIndex, x, y, z) {
        if (x != 0 || y != 0 || z != 0) {
          this.matrixContinuedSRTBuffer[matIndex * 9 + 3] = x;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 4] = y;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 5] = z;
          this.matrixStateBuffer[matIndex * WasmMatrix.stateStruct + 1] = 1;
        }
      }
      static setContinueScale(matIndex, x, y, z) {
        if (x != 0 || y != 0 || z != 0) {
          this.matrixContinuedSRTBuffer[matIndex * 9 + 0] = x;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 1] = y;
          this.matrixContinuedSRTBuffer[matIndex * 9 + 2] = z;
          this.matrixStateBuffer[matIndex * WasmMatrix.stateStruct + 1] = 1;
        }
      }
    }

    class Orientation3D {
      static AXIS_ANGLE = "axisAngle";
      static EULER_ANGLES = "eulerAngles";
      static QUATERNION = "quaternion";
    }

    class Quaternion {
      static HELP_0 = new Quaternion(0, 0, 0, 1);
      static HELP_1 = new Quaternion(0, 0, 0, 1);
      static HELP_2 = new Quaternion(0, 0, 0, 1);
      static _zero = new Quaternion(0, 0, 0, 1);
      static CALCULATION_QUATERNION = new Quaternion();
      /**
       * @internal
       */
      x = 0;
      /**
       * @internal
       */
      y = 0;
      /**
       * @internal
       */
      z = 0;
      /**
       * @internal
       */
      w = 1;
      /**
       * Create a new quaternion object
       * @param x The X component of a quaternion.
       * @param y The Y component of a quaternion.
       * @param z The Z component of a quaternion.
       * @param w The W component of a quaternion.
       */
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      /**
       * Identity quaternion
       * @returns 
       */
      static identity() {
        return Quaternion._zero;
      }
      /**
       * Converts quaternions to matrices
       * @param q Quaternion
       * @param m Matrix
       */
      static quaternionToMatrix(q, m) {
        let x = q.x * 2;
        let y = q.y * 2;
        let z = q.z * 2;
        let xx = q.x * x;
        let yy = q.y * y;
        let zz = q.z * z;
        let xy = q.x * y;
        let xz = q.x * z;
        let yz = q.y * z;
        let wx = q.w * x;
        let wy = q.w * y;
        let wz = q.w * z;
        m.rawData[0] = 1 - (yy + zz);
        m.rawData[1] = xy + wz;
        m.rawData[2] = xz - wy;
        m.rawData[3] = 0;
        m.rawData[4] = xy - wz;
        m.rawData[5] = 1 - (xx + zz);
        m.rawData[6] = yz + wx;
        m.rawData[7] = 0;
        m.rawData[8] = xz + wy;
        m.rawData[9] = yz - wx;
        m.rawData[10] = 1 - (xx + yy);
        m.rawData[11] = 0;
        m.rawData[12] = 0;
        m.rawData[13] = 0;
        m.rawData[14] = 0;
        m.rawData[15] = 1;
      }
      get magnitude() {
        return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
      }
      /**
       * Set the x, y, z, and w components of the existing quaternions.
       * @param x The X component of a quaternion.
       * @param y The Y component of a quaternion.
       * @param z The Z component of a quaternion.
       * @param w The W component of a quaternion.
       */
      set(x = 0, y = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      divide(v) {
        if (v instanceof Quaternion) {
          return new Quaternion(this.x / v.x, this.y / v.y, this.z / v.z);
        } else {
          this.x = this.x / v;
          this.y = this.y / v;
          this.z = this.z / v;
        }
        return this;
      }
      /**
       * @internal
       */
      setFromArray(d) {
        this.x = d[0];
        this.y = d[1];
        this.z = d[2];
        this.w = d[3];
        return this;
      }
      /**
       * Multiply two quaternions
       * @param qa Quaternion 1
       * @param qb Quaternion 2
       */
      multiply(qa, qb) {
        var w1 = qa.w;
        var x1 = qa.x;
        var y1 = qa.y;
        var z1 = qa.z;
        var w2 = qb.w;
        var x2 = qb.x;
        var y2 = qb.y;
        var z2 = qb.z;
        this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
        this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
        this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
        this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
      }
      multiplyVector(vector, target = null) {
        target ||= new Quaternion();
        var x2 = vector.x;
        var y2 = vector.y;
        var z2 = vector.z;
        target.w = -this.x * x2 - this.y * y2 - this.z * z2;
        target.x = this.w * x2 + this.y * z2 - this.z * y2;
        target.y = this.w * y2 - this.x * z2 + this.z * x2;
        target.z = this.w * z2 + this.x * y2 - this.y * x2;
        return target;
      }
      /**
       * Set the quaternion with a given rotation of the axis and Angle.
       * @param axis  axis
       * @param angle angle
       */
      fromAxisAngle(axis, angle) {
        angle *= Math.PI / 180;
        var halfAngle = angle * 0.5;
        var sinA = Math.sin(halfAngle);
        this.w = Math.cos(halfAngle);
        this.x = axis.x * sinA;
        this.y = axis.y * sinA;
        this.z = axis.z * sinA;
        this.normalize();
      }
      /**
       * Turn quaternions into angles
       * @param axis axis
       * @returns 
       */
      toAxisAngle(axis) {
        var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
        var angle = 0;
        if (sqrLength > 0) {
          angle = 2 * Math.acos(this.w);
          sqrLength = 1 / Math.sqrt(sqrLength);
          axis.x = this.x * sqrLength;
          axis.y = this.y * sqrLength;
          axis.z = this.z * sqrLength;
        } else {
          angle = 0;
          axis.x = 1;
          axis.y = 0;
          axis.z = 0;
        }
        return angle;
      }
      /**
       * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
       * @param qa The first quaternion to interpolate.
       * @param qb The second quaternion to interpolate.
       * @param t The interpolation weight, a value between 0 and 1.
       */
      slerp(qa, qb, t) {
        var w1 = qa.w;
        var x1 = qa.x;
        var y1 = qa.y;
        var z1 = qa.z;
        var w2 = qb.w;
        var x2 = qb.x;
        var y2 = qb.y;
        var z2 = qb.z;
        var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
        if (dot < 0) {
          dot = -dot;
          w2 = -w2;
          x2 = -x2;
          y2 = -y2;
          z2 = -z2;
        }
        if (dot < 0.95) {
          var angle = Math.acos(dot);
          var s = 1 / Math.sin(angle);
          var s1 = Math.sin(angle * (1 - t)) * s;
          var s2 = Math.sin(angle * t) * s;
          this.w = w1 * s1 + w2 * s2;
          this.x = x1 * s1 + x2 * s2;
          this.y = y1 * s1 + y2 * s2;
          this.z = z1 * s1 + z2 * s2;
        } else {
          this.w = w1 + t * (w2 - w1);
          this.x = x1 + t * (x2 - x1);
          this.y = y1 + t * (y2 - y1);
          this.z = z1 + t * (z2 - z1);
          var len = 1 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
          this.w *= len;
          this.x *= len;
          this.y *= len;
          this.z *= len;
        }
      }
      /**
       * Linearly interpolates between two quaternions.
       * @param qa The first quaternion to interpolate.
       * @param qb The second quaternion to interpolate.
       * @param t The interpolation weight, a value between 0 and 1.
       */
      lerp(qa, qb, t) {
        var w1 = qa.w;
        var x1 = qa.x;
        var y1 = qa.y;
        var z1 = qa.z;
        var w2 = qb.w;
        var x2 = qb.x;
        var y2 = qb.y;
        var z2 = qb.z;
        var len;
        if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
          w2 = -w2;
          x2 = -x2;
          y2 = -y2;
          z2 = -z2;
        }
        this.w = w1 + t * (w2 - w1);
        this.x = x1 + t * (x2 - x1);
        this.y = y1 + t * (y2 - y1);
        this.z = z1 + t * (z2 - z1);
        len = 1 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
        this.w *= len;
        this.x *= len;
        this.y *= len;
        this.z *= len;
      }
      /**
       * Fills the quaternion object with values representing the given euler rotation.
       * @param    ax        The angle in radians of the rotation around the ax axis.
       * @param    ay        The angle in radians of the rotation around the ay axis.
       * @param    az        The angle in radians of the rotation around the az axis.
       */
      fromEulerAngles(ax, ay, az) {
        ax *= DEGREES_TO_RADIANS;
        ay *= DEGREES_TO_RADIANS;
        az *= DEGREES_TO_RADIANS;
        var halfX = ax * 0.5;
        var halfY = ay * 0.5;
        var halfZ = az * 0.5;
        var cosX = Math.cos(halfX);
        var sinX = Math.sin(halfX);
        var cosY = Math.cos(halfY);
        var sinY = Math.sin(halfY);
        var cosZ = Math.cos(halfZ);
        var sinZ = Math.sin(halfZ);
        this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
        this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
        this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
        this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
        return this;
      }
      /**
       * Sets the current quaternion from the rotation matrix
       * @param m 
       * @returns 
       */
      setFromRotationMatrix(m) {
        const te = m.rawData;
        const m11 = te[0];
        const m12 = te[4];
        const m13 = te[8];
        const m21 = te[1];
        const m22 = te[5];
        const m23 = te[9];
        const m31 = te[2];
        const m32 = te[6];
        const m33 = te[10];
        const trace = m11 + m22 + m33;
        if (trace > 0) {
          const s = 0.5 / Math.sqrt(trace + 1);
          this.w = 0.25 / s;
          this.x = (m32 - m23) * s;
          this.y = (m13 - m31) * s;
          this.z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this.w = (m32 - m23) / s;
          this.x = 0.25 * s;
          this.y = (m12 + m21) / s;
          this.z = (m13 + m31) / s;
        } else if (m22 > m33) {
          const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this.w = (m13 - m31) / s;
          this.x = (m12 + m21) / s;
          this.y = 0.25 * s;
          this.z = (m23 + m32) / s;
        } else {
          const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this.w = (m21 - m12) / s;
          this.x = (m13 + m31) / s;
          this.y = (m23 + m32) / s;
          this.z = 0.25 * s;
        }
        return this;
      }
      /**
       * Get the Euler Angle
       * @param eulers 
       * @returns 
       */
      getEulerAngles(eulers) {
        var x;
        var y;
        var z;
        var qx;
        var qy;
        var qz;
        var qw;
        var a2;
        eulers ||= new Vector3();
        qx = this.x;
        qy = this.y;
        qz = this.z;
        qw = this.w;
        a2 = 2 * (qw * qy - qx * qz);
        if (a2 <= -0.99999) {
          x = 2 * Math.atan2(qx, qw);
          y = -Math.PI / 2;
          z = 0;
        } else if (a2 >= 0.99999) {
          x = 2 * Math.atan2(qx, qw);
          y = Math.PI / 2;
          z = 0;
        } else {
          x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
          y = Math.asin(a2);
          z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
        }
        return eulers.set(x, y, z).scaleBy(RADIANS_TO_DEGREES);
      }
      /**
       * The normalize of the quaternion. Convert this quaternion to a normalize coefficient.
       * @param val normalize coefficient, which is 1 by default
       */
      normalize(val = 1) {
        var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        this.x *= mag;
        this.y *= mag;
        this.z *= mag;
        this.w *= mag;
      }
      /**
       * Returns the value of a quaternion as a string
       * @returns 
       */
      toString() {
        return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
      }
      /**
       * Extracts a quaternion rotation matrix out of a given Matrix3D object.
       * @param matrix The Matrix3D out of which the rotation will be extracted.
       */
      fromMatrix(matrix) {
        var v = matrix.decompose(Orientation3D.QUATERNION)[1];
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
      }
      /**
       * Returns a quaternion that inverts the current quaternion
       * @param target The default parameter is null. If the current parameter is null, a new quaternion object is returned
       * @returns Quaternion Result
       */
      inverse(target = null) {
        target ||= new Quaternion();
        var norm = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
        if (norm > 0) {
          var invNorm = 1 / norm;
          target.w = this.w * invNorm;
          target.x = -this.x * invNorm;
          target.y = -this.y * invNorm;
          target.z = -this.z * invNorm;
        }
        return target;
      }
      /**
       * Clones the quaternion.
       * @returns An exact duplicate of the current Quaternion.
       */
      clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      }
      /**
       * Rotates a point.
       * @param vector The Vector3D object to be rotated.
       * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
       * @returns A Vector3D object containing the rotated point.
       */
      transformVector(vector, target = null) {
        var x1;
        var y1;
        var z1;
        var w1;
        var x2 = vector.x;
        var y2 = vector.y;
        var z2 = vector.z;
        target ||= new Vector3();
        w1 = -this.x * x2 - this.y * y2 - this.z * z2;
        x1 = this.w * x2 + this.y * z2 - this.z * y2;
        y1 = this.w * y2 - this.x * z2 + this.z * x2;
        z1 = this.w * z2 + this.x * y2 - this.y * x2;
        target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
        target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
        target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
        return target;
      }
      /**
       * Copies the data from a quaternion into this instance.
       * @param q The quaternion to copy from.
       */
      copyFrom(q) {
        var v = this;
        v.x = q.x;
        v.y = q.y;
        v.z = q.z;
        v.w = q.w;
        return this;
      }
      /**
       * from untiy API
       * op
       */
      mul(lhs, rhs, target) {
        let ret = target || new Quaternion();
        ret.x = lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y;
        ret.y = lhs.w * rhs.y + lhs.y * rhs.w + lhs.z * rhs.x - lhs.x * rhs.z;
        ret.z = lhs.w * rhs.z + lhs.z * rhs.w + lhs.x * rhs.y - lhs.y * rhs.x;
        ret.w = lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z;
        return ret;
      }
      clampf(value, minInclusive, maxInclusive) {
        if (minInclusive > maxInclusive) {
          var temp = minInclusive;
          minInclusive = maxInclusive;
          maxInclusive = temp;
        }
        return value < minInclusive ? minInclusive : value < maxInclusive ? value : maxInclusive;
      }
      static serialize(value) {
        let v = new Quaternion(value.x, value.y, value.z, value.w);
        return v;
      }
    }
    function rotateVectorByQuat(lhs, rhs, target) {
      let x = lhs.x * 2;
      let y = lhs.y * 2;
      let z = lhs.z * 2;
      let xx = lhs.x * x;
      let yy = lhs.y * y;
      let zz = lhs.z * z;
      let xy = lhs.x * y;
      let xz = lhs.x * z;
      let yz = lhs.y * z;
      let wx = lhs.w * x;
      let wy = lhs.w * y;
      let wz = lhs.w * z;
      let res = target ? target : new Vector3();
      res.x = (1 - (yy + zz)) * rhs.x + (xy - wz) * rhs.y + (xz + wy) * rhs.z;
      res.y = (xy + wz) * rhs.x + (1 - (xx + zz)) * rhs.y + (yz - wx) * rhs.z;
      res.z = (xz - wy) * rhs.x + (yz + wx) * rhs.y + (1 - (xx + yy)) * rhs.z;
      return res;
    }

    class Rand {
      _x = 0;
      _y = 0;
      _z = 0;
      _w = 0;
      /**
       * Create a random number generator object with a specified seed.
       * @param seed Random seed
       */
      constructor(seed = 0) {
        this.seed = seed;
      }
      /**
       * Random seed
       */
      get seed() {
        return this._x;
      }
      set seed(value) {
        this._x = value;
        this._y = this._x * 1812433253 + 1;
        this._z = this._y * 1812433253 + 1;
        this._w = this._z * 1812433253 + 1;
      }
      /**
       * Convert an integer to a floating-point number
       * @param value integer
       * @returns 
       */
      static getFloatFromInt(value) {
        return Math.floor((value & 8388607) * (1 / 8388607));
      }
      /**
       * Converts an integer to a single-byte integer
       * @param value integer
       * @returns 
       */
      static getByteFromInt(value) {
        return value >> 23 - 8;
      }
      /**
       * Returns a new random number generator object with the same seed state as 
       * the current random number generator object
       * @returns 
       */
      clone() {
        let result = new Rand();
        result._x = this._x;
        result._y = this._y;
        result._z = this._z;
        result._w = this._w;
        return result;
      }
      /**
       * Generate a random number
       * @returns 
       */
      get() {
        let t = this._x ^ this._x << 11;
        this._x = this._y;
        this._y = this._z;
        this._z = this._w;
        return this._w = this._w ^ this._w >> 19 ^ (t ^ t >> 8);
      }
      /**
       * Randomly generate a floating-point number 0.0 to 1.0
       * @returns 
       */
      getFloat() {
        return getFloatFromInt(this.get());
      }
      /**
       * Randomly generates signed floating-point numbers -1.0 to 1.0
       * @returns 
       */
      getSignedFloat() {
        return this.getFloat() * 2 - 1;
      }
    }

    let RADIANS_TO_DEGREES = 180 / Math.PI;
    let DEGREES_TO_RADIANS = Math.PI / 180;
    let MAX_VALUE = 2147483647;
    let MIN_VALUE = -2147483647;
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    class MathUtil {
      /**
       * @private
       * The gaussian function to calculate the color value
       * @param {number} value the value (the x-value)
       * @param {number} amplitude the curve peak
       * @param {number} center the curve center
       * @param {number} rmsWidth the curve width
       * @returns {number} the color value (the y-value)
       */
      static gaussFunction(value, amplitude, center, rmsWidth) {
        let numerator = Math.pow(value - center, 2);
        let denominator = 2 * Math.pow(rmsWidth, 2);
        let exp = -1 * (numerator / denominator);
        let curve = Math.pow(Math.E, exp);
        return Math.round(curve * amplitude);
      }
      /**
       * Calculate the Gaussian distribution function
       * @param n Function variable value
       * @param theta The degree of dispersion of the data distribution
       * @returns The result of the calculated Gaussian distribution value
       */
      static computeGaussian(n, theta) {
        return 1 / Math.sqrt(2 * Math.PI * theta) * Math.exp(-(n * n) / (2 * theta * theta));
      }
      /**
       * Calculate Gaussian coefficient
       * @param sigma sigma value
       * @returns Return the calculation result
       */
      static gaussCoef(sigma) {
        if (sigma < 0.5) {
          sigma = 0.5;
        }
        let a = Math.exp(0.726 * 0.726) / sigma;
        let g1 = Math.exp(-a);
        let g2 = Math.exp(-2 * a);
        let k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
        let a0 = k;
        let a1 = k * (a - 1) * g1;
        let a2 = k * (a + 1) * g1;
        let a3 = -k * g2;
        let b1 = 2 * g1;
        let b2 = -g2;
        let left_corner = (a0 + a1) / (1 - b1 - b2);
        let right_corner = (a2 + a3) / (1 - b1 - b2);
        return new Float32Array([a0, a1, a2, a3, b1, b2, left_corner, right_corner]);
      }
      /**
       * Limit the value to a certain range
       * @param value Original value
       * @param min_inclusive minimum value
       * @param max_inclusive maximum value
       * @returns Return the calculation result
       */
      static clampf(value, min_inclusive, max_inclusive) {
        if (min_inclusive > max_inclusive) {
          let temp = min_inclusive;
          min_inclusive = max_inclusive;
          max_inclusive = temp;
        }
        return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
      }
      /**
       * Normalize the Angle so that it is limited to the range [-180, 180]
       * @param a Angle of input
       * @returns Return the processing result
       */
      static normalizeAngle(a) {
        while (a > 180) {
          a -= 360;
        }
        while (a < -180) {
          a += 360;
        }
        return a;
      }
      /**
       * Returns the fractional part of a number
       * @param v input value
       * @returns Return the result
       */
      static fract(v) {
        return v - Math.floor(v);
      }
      /**
       * Generate a random pair of x and z coordinates that fall within the radius of the circle
       * @param r radius
       * @returns The generated x, z results
       */
      static getRandDirXZ(r) {
        let rr = r * Math.random();
        let ra = 360 * Math.random() * DEGREES_TO_RADIANS;
        let x = Math.cos(ra) * rr;
        let z = Math.sin(ra) * rr;
        return { x, z };
      }
      /**
       * Generate a random pair of x, y, and z coordinates that fall within the radius of the sphere
       * @param r radius
       * @returns The Vector3 vector formed by the generated x, y, and z coordinate values
       */
      static getRandDirXYZ(r) {
        let rr = r * Math.random();
        let ra = 360 * Math.random() * DEGREES_TO_RADIANS;
        let x = Math.cos(ra) * rr;
        let y = Math.tan(ra) * rr;
        let z = Math.sin(ra) * rr;
        return new Vector3(x, y, z);
      }
      /**
       * According to the radius, generate a random pair of x, y, z coordinates that fall within the sphere and the y value is between [-r/2, r/2]
       * @param r radius
       * @returns The Vector3 vector formed by the generated x, y, and z coordinate values
       */
      static getCycleXYZ(r) {
        let rr = r * Math.random();
        let ra = 360 * Math.random() * DEGREES_TO_RADIANS;
        let x = Math.cos(ra) * rr;
        let y = r * Math.random() - r * 0.5;
        let z = Math.sin(ra) * rr;
        return new Vector3(x, y, z);
      }
      /**
       * Calculate the Angle between two vectors
       * @param p1 Vector 1
       * @param p2 Vector 2
       * @returns Return the calculation result
       */
      static angle(p1, p2) {
        let v1 = Vector2.HELP_0;
        let v2 = Vector2.HELP_1;
        v1.set(p1.x, p1.z);
        v2.set(p2.x, p2.z);
        return Math.acos((v1.x * v2.x + v1.y * v2.y) / (v1.abs() * v2.abs()));
      }
      /**
       * Calculate the Angle between two vectors
       * @param from Vector 1
       * @param to Vector 2
       * @returns The Angle between two vectors
       */
      static angle_360(from, to) {
        let v3 = Vector3.HELP_0;
        from.crossProduct(to, v3);
        if (v3.z > 0) {
          return MathUtil.angle(from, to);
        } else {
          return 360 - MathUtil.angle(from, to);
        }
      }
      /**
       * The rotation Angle around the Y-axis is obtained from the input vector
       * @param v input vector
       * @returns Return the calculation result
       */
      getRotationY(v) {
        let rot = MathUtil.normalizeAngle(Math.atan2(v.z, v.x) * RADIANS_TO_DEGREES);
        return rot;
      }
      /**
       * Calculate the quaternion from one direction to the other
       * @param fromDirection Initial direction
       * @param toDirection The transformed direction
       * @param target The calculated quaternion is null by default and the result is returned
       * @returns Quaternion The calculated quaternion returns a new instance created if target is null
       * @version Orillusion3D  0.5.1
       */
      static fromToRotation(fromDirection, toDirection, target = null) {
        target ||= new Quaternion();
        let mat = Matrix4.help_matrix_2;
        Matrix4.fromToRotation(fromDirection, toDirection, mat);
        target.fromMatrix(mat);
        return target;
      }
      /**
       * Get the Eular direction
       * @param v input value
       * @returns Return the calculation result
       */
      static getEularDir_yUp(v) {
        let q = Quaternion.HELP_0;
        q.fromEulerAngles(0, v, 0);
        q.transformVector(Vector3.Z_AXIS, Vector3.HELP_5);
        return Vector3.HELP_5;
      }
      /**
       * Compute the vector transformation and assign the results to the input variables
       * @param matrix transformation matrix
       * @param vector Original vector
       * @param result output vector
       * @returns Returns the output vector
       */
      static transformVector(matrix, vector, result = null) {
        result ||= new Vector3();
        let raw = matrix.rawData;
        let a = raw[0];
        let e = raw[1];
        let i = raw[2];
        let m = raw[3];
        let b = raw[4];
        let f = raw[5];
        let j = raw[6];
        let n = raw[7];
        let c = raw[8];
        let g = raw[9];
        let k = raw[10];
        let o = raw[11];
        let d = raw[12];
        let h = raw[13];
        let l = raw[14];
        let p = raw[15];
        let x = vector.x;
        let y = vector.y;
        let z = vector.z;
        result.x = a * x + b * y + c * z + d;
        result.y = e * x + f * y + g * z + h;
        result.z = i * x + j * y + k * z + l;
        result.w = m * x + n * y + o * z + p;
        return result;
      }
    }
    let lerp = function(v0, v1, t) {
      return v0 * (1 - t) + v1 * t;
    };
    function lerpVector3(v0, v1, t) {
      let newV = new Vector3();
      let v0x = v0.x;
      let v0y = v0.y;
      let v0z = v0.z;
      let v0w = v0.w;
      let v1x = v1.x;
      let v1y = v1.y;
      let v1z = v1.z;
      let v1w = v1.w;
      newV.x = (v1x - v0x) * t + v0x;
      newV.y = (v1y - v0y) * t + v0y;
      newV.z = (v1z - v0z) * t + v0z;
      newV.w = (v1w - v0w) * t + v0w;
      return newV;
    }
    function lerpColor(c0, c1, t) {
      let newColor = new Color();
      newColor.r = (1 - t) * c0.r + t * c1.r;
      newColor.g = (1 - t) * c0.g + t * c1.g;
      newColor.b = (1 - t) * c0.b + t * c1.b;
      newColor.a = (1 - t) * c0.a + t * c1.a;
      return newColor;
    }
    function lerpByte(u0, u1, scale2) {
      return u0 + ((u1 - u0) * scale2 >> 8) & 255;
    }
    let PingPong = function(t, start, end) {
      let len = end - start;
      let tt = Math.floor(t / len);
      let sd = tt % 2;
      if (sd == 0) {
        return t % len + start;
      } else {
        return end - t % len + start;
      }
    };
    let RepeatSE = function(t, start, end) {
      let len = end - start;
      return t % len + start;
    };
    let GetRepeat = function(datas, element) {
      let count = 0;
      for (let i in datas) {
        if (i == element) {
          count++;
        }
      }
      return count;
    };
    class RandomSeed {
      x = 0;
      y = 0;
      z = 0;
      w = 0;
      randSeedList;
      constructor() {
        this.randSeedList = [];
      }
      reset() {
        this.x = Math.random() * 1;
        this.y = Math.random() * 1;
        this.z = Math.random() * 1;
        this.w = Math.random() * 1;
        this.randSeedList.length = 0;
        for (let i = 0; i < 20; i++) {
          this.randSeedList.push(Math.random() * 1);
        }
      }
    }
    function dot(lhs, rhs) {
      if (lhs instanceof Vector3 && rhs instanceof Vector3) {
        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
      } else if (lhs instanceof Quaternion && rhs instanceof Quaternion) {
        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
      } else {
        return lhs.x * rhs.x + lhs.y * rhs.y;
      }
    }
    function scale(lhs, rhs) {
      return new Vector3(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z);
    }
    function sqrtImpl(f) {
      return Math.sqrt(f);
    }
    function magnitude(inV) {
      return sqrtImpl(dot(inV, inV));
    }
    function normalizeSafe(inV, defaultV) {
      let mag = magnitude(inV);
      if (mag > Vector3.EPSILON) {
        return inV.divide(magnitude(inV));
      } else {
        if (inV instanceof Vector2) {
          return new Vector2();
        }
        if (inV instanceof Vector3) {
          return new Vector3();
        }
        if (inV instanceof Quaternion) {
          return new Quaternion();
        }
      }
    }
    function getFloatFromInt(value) {
      let v = value & 8388607;
      return v * (1 / 8388607);
    }
    function random01(value) {
      return value.getFloat();
    }
    function rangedRandomFloat(r, min, max) {
      let t = r.getFloat();
      t = min * t + (1 - t) * max;
      return t;
    }
    function rangedRandomInt(r, min, max) {
      let dif;
      if (min < max) {
        dif = max - min;
        let t = r.get() % dif;
        t += min;
        return t;
      } else if (min > max) {
        dif = min - max;
        let t = r.get() % dif;
        t = min - t;
        return t;
      } else {
        return min;
      }
    }
    function randomUnitVector(rand) {
      let z = rangedRandomFloat(rand, -1, 1);
      let a = rangedRandomFloat(rand, 0, 2 * Math.PI);
      let r = Math.sqrt(1 - z * z);
      let x = r * Math.cos(a);
      let y = r * Math.sin(a);
      return new Vector3(x, y, z);
    }
    function randomUnitVector2(rand) {
      let a = rangedRandomFloat(rand, 0, 2 * Math.PI);
      let x = Math.cos(a);
      let y = Math.sin(a);
      return new Vector2(x, y);
    }
    function randomQuaternion(rand) {
      let q = new Quaternion();
      q.x = rangedRandomFloat(rand, -1, 1);
      q.y = rangedRandomFloat(rand, -1, 1);
      q.z = rangedRandomFloat(rand, -1, 1);
      q.w = rangedRandomFloat(rand, -1, 1);
      q = normalizeSafe(q);
      if (dot(q, Quaternion.identity()) < 0) {
        return -q;
      } else {
        return q;
      }
    }
    function randomQuaternionUniformDistribution(rand) {
      const two_pi = 2 * Math.PI;
      let u1 = rangedRandomFloat(rand, 0, 1);
      let theta = rangedRandomFloat(rand, 0, two_pi);
      let rho = rangedRandomFloat(rand, 0, two_pi);
      let i = Math.sqrt(1 - u1);
      let j = Math.sqrt(u1);
      let q = new Quaternion(i * Math.sin(theta), i * Math.cos(theta), j * Math.sin(rho), j * Math.cos(rho));
      if (dot(q, Quaternion.identity()) < 0) {
        return -q;
      } else {
        return q;
      }
    }
    function randomPointInsideCube(r, extents) {
      return new Vector3(rangedRandomFloat(r, -extents.x, extents.x), rangedRandomFloat(r, -extents.y, extents.y), rangedRandomFloat(r, -extents.z, extents.z));
    }
    function randomPointInsideUnitSphere(r) {
      let v = randomUnitVector(r);
      v.scaleBy(Math.pow(random01(r), 1 / 3));
      return v;
    }
    function randomPointInsideEllipsoid(r, extents) {
      return scale(randomPointInsideUnitSphere(r), extents);
    }
    function randomPointBetweenSphere(r, minRadius, maxRadius) {
      let v = randomUnitVector(r);
      let range = Math.pow(rangedRandomFloat(r, 0, 1), 1 / 3);
      v.scaleBy(minRadius + (maxRadius - minRadius) * range);
      return v;
    }
    function randomPointInsideUnitCircle(r) {
      let v = randomUnitVector2(r);
      v.multiply(Math.pow(rangedRandomFloat(r, 0, 1), 1 / 2), v);
      return v;
    }
    function randomPointBetweenEllipsoid(r, maxExtents, minRange) {
      let v = scale(randomUnitVector(r), maxExtents);
      let range = Math.pow(rangedRandomFloat(r, minRange, 1), 1 / 3);
      v.scaleBy(range);
      return v;
    }
    function randomBarycentricCoord(rand) {
      let u = rand.getFloat();
      let v = rand.getFloat();
      if (u + v > 1) {
        u = 1 - u;
        v = 1 - v;
      }
      let w = 1 - u - v;
      return new Vector3(u, v, w);
    }
    function deg2Rad(deg) {
      return deg / 360 * 2 * Math.PI;
    }
    function rad2Deg(deg) {
      return 180 * deg / Math.PI;
    }
    function sin(v) {
      return Math.sin(v);
    }
    function cos(v) {
      return Math.cos(v);
    }
    exports.randomSeed = 4919;
    function getGlobalRandomSeed() {
      return ++exports.randomSeed;
    }
    function swap(values, i1, i2) {
      let v1 = values[i1];
      let v2 = values[i2];
      values[i1] = v2;
      values[i2] = v1;
    }
    function floorfToIntPos(f) {
      return Math.floor(f);
    }
    function roundfToIntPos(f) {
      return floorfToIntPos(f + 0.5);
    }
    function normalizedToWord(f) {
      f = Math.max(f, 0);
      f = Math.min(f, 1);
      return roundfToIntPos(f * 65535);
    }
    function normalizedToByte(f) {
      f = Math.max(f, 0);
      f = Math.min(f, 1);
      return roundfToIntPos(f * 255);
    }
    function fastInvSqrt(f) {
      if (Math.abs(f) == 0) {
        return f;
      }
      return 1 / Math.sqrt(f);
    }
    function normalizeFast(inV) {
      let m = sqrMagnitude(inV);
      return inV.scaleBy(fastInvSqrt(m));
    }
    function crossProduct(lhs, rhs) {
      return lhs.crossProduct(rhs);
    }
    function sqrMagnitude(inV) {
      return dot(inV, inV);
    }
    function generateRandom(randomIn) {
      let rand = new Rand(randomIn);
      return random01(rand);
    }
    function generateRandom3(randomOut, randomIn) {
      let rand = new Rand(randomIn);
      randomOut.x = random01(rand);
      randomOut.y = random01(rand);
      randomOut.z = random01(rand);
    }
    function clampRepeat(t, t0, t1) {
      if (t < t0) {
        return t1;
      } else if (t > t1) {
        return t0;
      } else {
        return t;
      }
    }
    function repeat(t, length) {
      return t - Math.floor(t / length) * length;
    }

    const EPSILON = 1e-6;
    class Matrix4 {
      /**
       * matrix44 bytes block size 
       */
      static blockBytes = 16 * 4;
      /**
       * @internal
       */
      static block = 16;
      /**
       * matrix do total count 
       */
      static allocCount = 1e3;
      /**
       * quantity allocated for each capacity expansion
       */
      static allocOnceCount = 1e3;
      /**
       * matrix has max limit count
       */
      static maxCount = 50 * 1e4;
      /**
       * current matrix use count 
       */
      static useCount = 0;
      /**
       * @internal
       */
      static buffer;
      /**
       * @internal
       * wasm use memory use first ptr
       */
      static wasmMatrixPtr = 0;
      /**
       * matrix do use share bytesArray
       */
      static dynamicMatrixBytes;
      /**
       * cache all use do matrix 
       */
      static dynamicGlobalMatrixRef;
      /**
       * @internal
       */
      static wasm;
      /**
       * help fix global matrix 0 
       */
      static help_matrix_0;
      /**
       * help fix global matrix 1 
       */
      static help_matrix_1;
      /**
       * help fix global matrix 2 
       */
      static help_matrix_2;
      /**
       * help fix global matrix 3 
       */
      static helpMatrix;
      /**
       * help fix global matrix 4 
       */
      static helpMatrix2;
      static _getEulerMatrix;
      static _zero = new Vector3(0, 0, 0);
      static _one = new Vector3(1, 1, 1);
      static _prs = [new Vector3(), new Vector3(), new Vector3()];
      /**
      * matrix index at global matrix list 
      */
      index = 0;
      /**
       * @internal
       */
      offset = 0;
      /**
       * matrix raw data format Float32Array
       * @see {@link Float32Array}
       * @version Orillusion3D  0.5.1
       */
      rawData;
      _position;
      /**
      * alloc web runtime cpu memory totalCount * 4(float) * 4
      * init matrix memory by totalCount * 4(float) * 4
      * @param count every alloc matrix count
      * @version Orillusion3D  0.5.1
      */
      static allocMatrix(allocCount) {
        this.allocCount = allocCount;
        Matrix4.dynamicMatrixBytes = WasmMatrix.matrixBuffer;
        Matrix4.buffer = Matrix4.dynamicMatrixBytes.buffer;
        Matrix4.wasmMatrixPtr = WasmMatrix.matrixBufferPtr;
        this.dynamicGlobalMatrixRef ||= [];
        this.dynamicGlobalMatrixRef.forEach((m) => {
          m.offset = Matrix4.wasmMatrixPtr + m.index * Matrix4.blockBytes;
          m.rawData = new Float32Array(Matrix4.dynamicMatrixBytes.buffer, m.offset, 16);
        });
        Matrix4.help_matrix_0 ||= new Matrix4();
        Matrix4.help_matrix_1 ||= new Matrix4();
        Matrix4.help_matrix_2 ||= new Matrix4();
        Matrix4.helpMatrix ||= new Matrix4();
        Matrix4.helpMatrix2 ||= new Matrix4();
        Matrix4._getEulerMatrix ||= new Matrix4();
        Matrix4._getEulerMatrix.identity();
      }
      /**
       * create matrix from two direction
       * @param fromDirection first direction
       * @param toDirection  second direction
       * @param target ref matrix
       * @returns return new one matrix
       * @version Orillusion3D  0.5.1
       */
      static fromToRotation(fromDirection, toDirection, target) {
        target ||= new Matrix4();
        target.transformDir(fromDirection, toDirection);
        return target;
      }
      /**
       * Generate a matrix (rotate degrees with x,y,z as the center axis)
       * @param x x on the central axis
       * @param y y on the central axis
       * @param z z on the central axis
       * @param degrees rotation angle
       * @returns Matrix4 result
       * @version Orillusion3D  0.5.1
       */
      static getAxisRotation(x, y, z, degrees) {
        let m = new Matrix4();
        let rad = degrees * (Math.PI / 180);
        let c = Math.cos(rad);
        let s = Math.sin(rad);
        let t = 1 - c;
        let tmp1, tmp2;
        m.rawData[0] = c + x * x * t;
        m.rawData[5] = c + y * y * t;
        m.rawData[10] = c + z * z * t;
        tmp1 = x * y * t;
        tmp2 = z * s;
        m.rawData[1] = tmp1 + tmp2;
        m.rawData[4] = tmp1 - tmp2;
        tmp1 = x * z * t;
        tmp2 = y * s;
        m.rawData[8] = tmp1 + tmp2;
        m.rawData[2] = tmp1 - tmp2;
        tmp1 = y * z * t;
        tmp2 = x * s;
        m.rawData[9] = tmp1 - tmp2;
        m.rawData[6] = tmp1 + tmp2;
        return m;
      }
      /**
       * Arrange the Euler values
       * @param euler Euler values
       */
      static sanitizeEuler(euler) {
        Matrix4.makePositive(euler);
      }
      /**
       *
       * @param euler
       */
      static makePositive(euler) {
        let negativeFlip = -1e-4;
        let positiveFlip = Math.PI * 2 - 1e-4;
        if (euler.x < negativeFlip) {
          euler.x += 2 * Math.PI;
        } else if (euler.x > positiveFlip) {
          euler.x -= 2 * Math.PI;
        }
        if (euler.y < negativeFlip) {
          euler.y += 2 * Math.PI;
        } else if (euler.y > positiveFlip) {
          euler.y -= 2 * Math.PI;
        }
        if (euler.z < negativeFlip) {
          euler.z += 2 * Math.PI;
        } else if (euler.z > positiveFlip) {
          euler.z -= 2 * Math.PI;
        }
      }
      /**
       * Convert the matrix to Euler angles
       * @param matrix Matrix to be transformed
       * @param v euler angle
       * @returns
       */
      static matrixToEuler(matrix, v) {
        if (matrix.get(1, 2) < 0.999) {
          if (matrix.get(1, 2) > -0.999) {
            v.x = Math.asin(-matrix.get(1, 2));
            v.y = Math.atan2(matrix.get(0, 2), matrix.get(2, 2));
            v.z = Math.atan2(matrix.get(1, 0), matrix.get(1, 1));
            Matrix4.sanitizeEuler(v);
            return true;
          } else {
            v.x = Math.PI * 0.5;
            v.y = Math.atan2(matrix.get(0, 1), matrix.get(0, 0));
            v.z = 0;
            Matrix4.sanitizeEuler(v);
            return false;
          }
        } else {
          v.x = -Math.PI * 0.5;
          v.y = Math.atan2(-matrix.get(0, 1), matrix.get(0, 0));
          v.z = 0;
          Matrix4.sanitizeEuler(v);
          return false;
        }
      }
      /**
       * Multiply the world matrix, specifying parameters and results according to the index
       * @param aMat Matrix to be multiplied (please specify index)
       * @param bMat Matrix to be multiplied (please specify index)
       * @param target_Mat Result matrix (get results based on index)
       */
      static matrixMultiply(aMat, bMat, target_Mat) {
        Matrix4.wasm.Matrix_Multiply(aMat.index, bMat.index, target_Mat.index);
      }
      /**
       * World matrix extension, according to the index to specify parameters and results
       * @param aMat Matrix to be multiplied (please specify index)
       * @param bMat Matrix to be multiplied (please specify index)
       * @param target_Mat Result matrix (get results based on index)
       */
      static matrixAppend(aMat, bMat, target_Mat) {
        Matrix4.wasm.Matrix_Append(aMat.index, bMat.index, target_Mat.index);
      }
      /**
       * The Y-axis is rotated between the world matrix, and the parameters and results are specified according to the index
       * @param aMat Matrix to be multiplied (please specify index)
       * @param bMat Matrix to be multiplied (please specify index)
       * @param target_Mat Result matrix (get results based on index)
       */
      static matrixRotateY(rad, target_Mat) {
        Matrix4.wasm.Matrix_Append(rad, target_Mat.index);
      }
      /**
       * Rotate the world matrix, specifying parameters and results according to the index
       * @param aMat Matrix to be multiplied (please specify index)
       * @param bMat Matrix to be multiplied (please specify index)
       * @param target_Mat Result matrix (get results based on index)
       */
      static matrixRotate(rad, axis, target_Mat) {
        Matrix4.wasm.Matrix_Rotate(rad, axis, target_Mat.index);
      }
      /**
       * 
       * @param local -- 
       */
      constructor(doMatrix = false) {
        if (Matrix4.useCount >= Matrix4.allocCount) {
          let allocCount = Matrix4.allocCount + Matrix4.allocOnceCount;
          WasmMatrix.allocMatrix(allocCount);
        }
        this.index = Matrix4.useCount;
        this.offset = Matrix4.wasmMatrixPtr + this.index * Matrix4.blockBytes;
        Matrix4.dynamicGlobalMatrixRef[this.index] = this;
        Matrix4.useCount++;
        this.rawData = new Float32Array(Matrix4.dynamicMatrixBytes.buffer, this.offset, 16);
        this._position = new Vector3();
        this.identity();
      }
      /**
       * current matrix move position and rotation to target 
       * @param eye eye position
       * @param at target position
       * @param up normalize axis way
       * @version Orillusion3D  0.5.1
       */
      lookAt(eye, at, up = Vector3.Y_AXIS) {
        let data = this.rawData;
        let zAxis = at.subtract(eye, Vector3.HELP_0);
        if (zAxis.length < 1e-4) {
          zAxis.z = 1;
        }
        zAxis.normalize();
        let xAxis = up.crossProduct(zAxis, Vector3.HELP_1);
        if (xAxis.length < 1e-4) {
          if (Math.abs(up.z) > 0.9999) {
            zAxis.x += 1e-4;
          } else {
            zAxis.z += 1e-4;
          }
          zAxis.normalize();
        }
        xAxis = up.crossProduct(zAxis, xAxis).normalize();
        let yAxis = zAxis.crossProduct(xAxis, Vector3.HELP_2).normalize();
        data[0] = xAxis.x;
        data[1] = yAxis.x;
        data[2] = zAxis.x;
        data[3] = 0;
        data[4] = xAxis.y;
        data[5] = yAxis.y;
        data[6] = zAxis.y;
        data[7] = 0;
        data[8] = xAxis.z;
        data[9] = yAxis.z;
        data[10] = zAxis.z;
        data[11] = 0;
        data[12] = -xAxis.dotProduct(eye);
        data[13] = -yAxis.dotProduct(eye);
        data[14] = -zAxis.dotProduct(eye);
        data[15] = 1;
      }
      static float32Array = new Float32Array(16).fill(0);
      /**
       * matrix multiply
       * @param mat4 multiply target
       * @version Orillusion3D  0.5.1
       */
      multiply(mat4) {
        let a = this.rawData;
        let b = mat4.rawData;
        let r = Matrix4.float32Array;
        r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
        r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
        r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
        r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];
        r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
        r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
        r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
        r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];
        r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
        r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
        r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
        r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];
        r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
        r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
        r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
        r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];
        a[0] = r[0];
        a[1] = r[1];
        a[2] = r[2];
        a[3] = r[3];
        a[4] = r[4];
        a[5] = r[5];
        a[6] = r[6];
        a[7] = r[7];
        a[8] = r[8];
        a[9] = r[9];
        a[10] = r[10];
        a[11] = r[11];
        a[12] = r[12];
        a[13] = r[13];
        a[14] = r[14];
        a[15] = r[15];
      }
      /**
       * 
       * @param a 
       * @param b 
       * @returns 
       */
      multiplyMatrices(a, b) {
        const ae = a.rawData;
        const be = b.rawData;
        const te = this.rawData;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
      /**
       * convert a vector3 to this matrix space
       * if output not set , return a new one
       * @param v target vector3
       * @param output save target
       * @returns save target
       */
      multiplyPoint3(v, output) {
        output ||= new Vector3();
        let rawData = this.rawData;
        output.x = rawData[0] * v.x + rawData[4] * v.y + rawData[8] * v.z + rawData[12];
        output.y = rawData[1] * v.x + rawData[5] * v.y + rawData[9] * v.z + rawData[13];
        output.z = rawData[2] * v.x + rawData[6] * v.y + rawData[10] * v.z + rawData[14];
        return output;
      }
      multiplyVector4(a, out) {
        out ||= new Vector3();
        let m = this.rawData;
        let x = a.x;
        let y = a.y;
        let z = a.z;
        let w = m[3] * x + m[7] * y + m[11] * z + m[15];
        w = w || 1;
        out.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
        out.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
        out.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
        out.w = 1;
        return out;
      }
      /**
       * convert a vector3 to this matrix space
       * if output not set , return a new one
       * @param v convert target
       * @param target ref one vector3
       * @returns Vector3 
       * @version Orillusion3D  0.5.1
       */
      transformVector4(v, target) {
        let data = this.rawData;
        target ||= new Vector3();
        let x = v.x;
        let y = v.y;
        let z = v.z;
        let w = v.w;
        target.x = x * data[0] + y * data[4] + z * data[8] + w * data[12];
        target.y = x * data[1] + y * data[5] + z * data[9] + w * data[13];
        target.z = x * data[2] + y * data[6] + z * data[10] + w * data[14];
        target.w = x * data[3] + y * data[7] + z * data[11] + w * data[15];
        return target;
      }
      /**
       * Convert projection coordinates to 3D coordinates
       * @param v vector3 target
       * @param output ref vector3d
       * @returns
       */
      perspectiveMultiplyPoint3(v, output) {
        let res = Vector3.HELP_2;
        let w;
        let rawData = this.rawData;
        res.x = rawData[0] * v.x + rawData[4] * v.y + rawData[8] * v.z + rawData[12];
        res.y = rawData[1] * v.x + rawData[5] * v.y + rawData[9] * v.z + rawData[13];
        res.z = rawData[2] * v.x + rawData[6] * v.y + rawData[10] * v.z + rawData[14];
        w = rawData[3] * v.x + rawData[7] * v.y + rawData[11] * v.z + rawData[15];
        if (Math.abs(w) > 1e-7) {
          let invW = 1 / w;
          output.x = res.x * invW;
          output.y = res.y * invW;
          output.z = res.z * invW;
          return true;
        } else {
          output.x = 0;
          output.y = 0;
          output.z = 0;
          return false;
        }
      }
      /**
       * set matrix perspective 
       * @param fov perspective angle 0 ~ 90
       * @param aspect aspect ratio
       * @param zn near plane
       * @param zf far plane
       * @version Orillusion3D  0.5.1
       */
      perspective(fov, aspect, zn, zf) {
        let data = this.rawData;
        let angle = fov * DEGREES_TO_RADIANS / 2;
        let f = Math.cos(angle) / Math.sin(angle);
        data[0] = -f / aspect;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = f;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = zf / (zf - zn);
        data[11] = 1;
        data[12] = 0;
        data[13] = 0;
        data[14] = -zn * zf / (zf - zn);
        data[15] = 0;
      }
      perspective3(fov, aspect, near, far) {
        var y = Math.tan(fov * Math.PI / 360) * near;
        var x = y * aspect;
        this.frustum(-x, x, -y, y, near, far);
      }
      frustum(l, r, b, t, n, f) {
        var m = this.rawData;
        m[0] = -2 * n / (r - l);
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 2 * n / (t - b);
        m[6] = 0;
        m[7] = 0;
        m[8] = (r + l) / (r - l);
        m[9] = (t + b) / (t - b);
        m[10] = f / (f - n);
        m[11] = 1;
        m[12] = 0;
        m[13] = 0;
        m[14] = -f * n / (f - n);
        m[15] = 0;
      }
      /**
       * @version Orillusion3D  0.5.1
       * set matrix orthogonal projection
       * @param w screen width
       * @param h screen height
       * @param zn camera near plane
       * @param zf camera far plane
       * @returns this matrix
       */
      ortho(w, h, zn, zf) {
        let data = this.rawData;
        data[0] = 2 / w;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = 2 / h;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = 1 / (zf - zn);
        data[11] = 0;
        data[12] = 0;
        data[13] = 0;
        data[14] = zn / (zn - zf);
        data[15] = 1;
        return this;
      }
      /**
       * set matrix orthogonal projection by view side
       * @param left orthogonal view left
       * @param right orthogonal view right
       * @param bottom orthogonal view bottom
       * @param top orthogonal view top
       * @param near camera near plane
       * @param far camera far plane
       * @returns this matrix
       */
      orthoZO(left, right, bottom, top, near, far) {
        let data = this.rawData;
        let lr = 1 / (left - right);
        let bt = 1 / (bottom - top);
        let nf = 1 / (near - far);
        data[0] = -2 * lr;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = -2 * bt;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = nf;
        data[11] = 0;
        data[12] = (left + right) * lr;
        data[13] = (top + bottom) * bt;
        data[14] = near * nf;
        data[15] = 1;
        return this;
      }
      /**
       * set matrix orthogonal projection by view center
       */
      orthoOffCenter(l, r, b, t, zn, zf) {
        let data = this.rawData;
        data[0] = 2 / (r - l);
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = 2 / (t - b);
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = 1 / (zf - zn);
        data[11] = 0;
        data[12] = (l + r) / (l - r);
        data[13] = (t + b) / (b - t);
        data[14] = zn / (zn - zf);
        data[15] = 1;
      }
      /**
       * set matrix from two direction
       * @param fromDirection first direction
       * @param toDirection second direction
       * @version Orillusion3D  0.5.1
       */
      transformDir(fromDirection, toDirection) {
        let data = this.rawData;
        let EPSILON2 = 1e-6;
        let v = Vector3.ZERO;
        toDirection.crossProduct(fromDirection, v);
        let e = toDirection.dotProduct(fromDirection);
        if (e > 1 - EPSILON2) {
          this.identity();
        } else {
          let hvx;
          let hvz;
          let hvxy;
          let hvxz;
          let hvyz;
          let v2 = v.dotProduct(v);
          let h = (1 - e) / v2;
          hvx = h * v.x;
          hvz = h * v.z;
          hvxy = hvx * v.y;
          hvxz = hvx * v.z;
          hvyz = hvz * v.y;
          data[0] = e + hvx * v.x;
          data[1] = hvxy - v.z;
          data[2] = hvxz + v.y;
          data[4] = hvxy + v.z;
          data[5] = e + h * v.y * v.y;
          data[6] = hvyz - v.x;
          data[8] = hvxz - v.y;
          data[9] = hvyz + v.x;
          data[10] = e + hvz * v.z;
          data[3] = 0;
          data[7] = 0;
          data[11] = 0;
          data[15] = 1;
        }
      }
      /**
       * multiply matrix a b
       * @param lhs target matrix
       * @version Orillusion3D  0.5.1
       */
      append(lhs) {
        let data = this.rawData;
        let m111 = data[0];
        let m121 = data[4];
        let m131 = data[8];
        let m141 = data[12];
        let m112 = data[1];
        let m122 = data[5];
        let m132 = data[9];
        let m142 = data[13];
        let m113 = data[2];
        let m123 = data[6];
        let m133 = data[10];
        let m143 = data[14];
        let m114 = data[3];
        let m124 = data[7];
        let m134 = data[11];
        let m144 = data[15];
        data[0] = m111 * lhs.rawData[0] + m112 * lhs.rawData[4] + m113 * lhs.rawData[8] + m114 * lhs.rawData[12];
        data[1] = m111 * lhs.rawData[1] + m112 * lhs.rawData[5] + m113 * lhs.rawData[9] + m114 * lhs.rawData[13];
        data[2] = m111 * lhs.rawData[2] + m112 * lhs.rawData[6] + m113 * lhs.rawData[10] + m114 * lhs.rawData[14];
        data[3] = m111 * lhs.rawData[3] + m112 * lhs.rawData[7] + m113 * lhs.rawData[11] + m114 * lhs.rawData[15];
        data[4] = m121 * lhs.rawData[0] + m122 * lhs.rawData[4] + m123 * lhs.rawData[8] + m124 * lhs.rawData[12];
        data[5] = m121 * lhs.rawData[1] + m122 * lhs.rawData[5] + m123 * lhs.rawData[9] + m124 * lhs.rawData[13];
        data[6] = m121 * lhs.rawData[2] + m122 * lhs.rawData[6] + m123 * lhs.rawData[10] + m124 * lhs.rawData[14];
        data[7] = m121 * lhs.rawData[3] + m122 * lhs.rawData[7] + m123 * lhs.rawData[11] + m124 * lhs.rawData[15];
        data[8] = m131 * lhs.rawData[0] + m132 * lhs.rawData[4] + m133 * lhs.rawData[8] + m134 * lhs.rawData[12];
        data[9] = m131 * lhs.rawData[1] + m132 * lhs.rawData[5] + m133 * lhs.rawData[9] + m134 * lhs.rawData[13];
        data[10] = m131 * lhs.rawData[2] + m132 * lhs.rawData[6] + m133 * lhs.rawData[10] + m134 * lhs.rawData[14];
        data[11] = m131 * lhs.rawData[3] + m132 * lhs.rawData[7] + m133 * lhs.rawData[11] + m134 * lhs.rawData[15];
        data[12] = m141 * lhs.rawData[0] + m142 * lhs.rawData[4] + m143 * lhs.rawData[8] + m144 * lhs.rawData[12];
        data[13] = m141 * lhs.rawData[1] + m142 * lhs.rawData[5] + m143 * lhs.rawData[9] + m144 * lhs.rawData[13];
        data[14] = m141 * lhs.rawData[2] + m142 * lhs.rawData[6] + m143 * lhs.rawData[10] + m144 * lhs.rawData[14];
        data[15] = m141 * lhs.rawData[3] + m142 * lhs.rawData[7] + m143 * lhs.rawData[11] + m144 * lhs.rawData[15];
      }
      /**
       * matrix a add matrix b
       * @param lhs target matrix.
       * @returns Matrix4 result.
       * @version Orillusion3D  0.5.1
       */
      add(lhs) {
        let data = this.rawData;
        let m111 = data[0];
        let m121 = data[4];
        let m131 = data[8];
        let m141 = data[12];
        let m112 = data[1];
        let m122 = data[5];
        let m132 = data[9];
        let m142 = data[13];
        let m113 = data[2];
        let m123 = data[6];
        let m133 = data[10];
        let m143 = data[14];
        let m114 = data[3];
        let m124 = data[7];
        let m134 = data[11];
        let m144 = data[15];
        let m211 = lhs.rawData[0];
        let m221 = lhs.rawData[4];
        let m231 = lhs.rawData[8];
        let m241 = lhs.rawData[12];
        let m212 = lhs.rawData[1];
        let m222 = lhs.rawData[5];
        let m232 = lhs.rawData[9];
        let m242 = lhs.rawData[13];
        let m213 = lhs.rawData[2];
        let m223 = lhs.rawData[6];
        let m233 = lhs.rawData[10];
        let m243 = lhs.rawData[14];
        let m214 = lhs.rawData[3];
        let m224 = lhs.rawData[7];
        let m234 = lhs.rawData[11];
        let m244 = lhs.rawData[15];
        data[0] = m111 + m211;
        data[1] = m112 + m212;
        data[2] = m113 + m213;
        data[3] = m114 + m214;
        data[4] = m121 + m221;
        data[5] = m122 + m222;
        data[6] = m123 + m223;
        data[7] = m124 + m224;
        data[8] = m131 + m231;
        data[9] = m132 + m232;
        data[10] = m133 + m233;
        data[11] = m134 + m234;
        data[12] = m141 + m241;
        data[13] = m142 + m242;
        data[14] = m143 + m243;
        data[15] = m144 + m244;
        return this;
      }
      /**
       * matrix a sub matrix b
       * @param lhs target matrix b.
       * @returns Matrix4 .
       * @version Orillusion3D  0.5.1
       */
      sub(lhs) {
        let data = this.rawData;
        let m111 = data[0];
        let m121 = data[4];
        let m131 = data[8];
        let m141 = data[12];
        let m112 = data[1];
        let m122 = data[5];
        let m132 = data[9];
        let m142 = data[13];
        let m113 = data[2];
        let m123 = data[6];
        let m133 = data[10];
        let m143 = data[14];
        let m114 = data[3];
        let m124 = data[7];
        let m134 = data[11];
        let m144 = data[15];
        let m211 = lhs.rawData[0];
        let m221 = lhs.rawData[4];
        let m231 = lhs.rawData[8];
        let m241 = lhs.rawData[12];
        let m212 = lhs.rawData[1];
        let m222 = lhs.rawData[5];
        let m232 = lhs.rawData[9];
        let m242 = lhs.rawData[13];
        let m213 = lhs.rawData[2];
        let m223 = lhs.rawData[6];
        let m233 = lhs.rawData[10];
        let m243 = lhs.rawData[14];
        let m214 = lhs.rawData[3];
        let m224 = lhs.rawData[7];
        let m234 = lhs.rawData[11];
        let m244 = lhs.rawData[15];
        data[0] = m111 - m211;
        data[1] = m112 - m212;
        data[2] = m113 - m213;
        data[3] = m114 - m214;
        data[4] = m121 - m221;
        data[5] = m122 - m222;
        data[6] = m123 - m223;
        data[7] = m124 - m224;
        data[8] = m131 - m231;
        data[9] = m132 - m232;
        data[10] = m133 - m233;
        data[11] = m134 - m234;
        data[12] = m141 - m241;
        data[13] = m142 - m242;
        data[14] = m143 - m243;
        data[15] = m144 - m244;
        return this;
      }
      /**
       * Matrix times components.
       * @param v This matrix is going to be multiplied by this value
       * @returns Matrix4 Returns a multiplicative result matrix.
       * @version Orillusion3D  0.5.1
       */
      mult(v) {
        let data = this.rawData;
        data[0] *= v;
        data[1] *= v;
        data[2] *= v;
        data[3] *= v;
        data[4] *= v;
        data[5] *= v;
        data[6] *= v;
        data[7] *= v;
        data[8] *= v;
        data[9] *= v;
        data[10] *= v;
        data[11] *= v;
        data[12] *= v;
        data[13] *= v;
        data[14] *= v;
        data[15] *= v;
        return this;
      }
      // /**
      //  * Create an Euler rotation matrix.
      //  * @param x Angle of rotation around the x axis.
      //  * @param y Angle of rotation around the y axis.
      //  * @param z Angle of rotation around the z axis.
      //  * @version Orillusion3D  0.5.1
      //  */
      // public rotation(x: number, y: number, z: number) {
      //   Quaternion.CALCULATION_QUATERNION.fromEulerAngles(x, y, z);
      //   this.makeTransform(
      //     Matrix4.position_000,
      //     Matrix4.scale_111,
      //     Quaternion.CALCULATION_QUATERNION,
      //   );
      // }
      /**
       Add a direction Angle rotation to the current matrix (the matrix created by rotating degrees according to axis)
       @param degrees Angle of rotation.
       @param axis Angle of rotation around axis axis
       @version Orillusion3D  0.5.1
      */
      appendRotation(degrees, axis) {
        let m = Matrix4.getAxisRotation(axis.x, axis.y, axis.z, degrees);
        this.append(m);
      }
      /**
       * Create a matrix based on the axis and rotation Angle (the matrix created by rotating the degrees according to the axis)
       * @param degrees Angle of rotation.
       * @param axis Rotation Angle around axis axis. Axis needs to be specified as the orientation of an axis between x/y/z
       * @version Orillusion3D  0.5.1
       */
      createByRotation(degrees, axis) {
        let tmp = Matrix4.helpMatrix;
        let s;
        let c;
        let angle = degrees * DEGREES_TO_RADIANS;
        s = Math.sin(angle);
        c = Math.cos(angle);
        if (axis.x == 1) {
          tmp.rawData[0] = 1;
          tmp.rawData[1] = 0;
          tmp.rawData[2] = 0;
          tmp.rawData[3] = 0;
          tmp.rawData[4] = 0;
          tmp.rawData[5] = c;
          tmp.rawData[6] = s;
          tmp.rawData[7] = 0;
          tmp.rawData[8] = 0;
          tmp.rawData[9] = -s;
          tmp.rawData[10] = c;
          tmp.rawData[11] = 0;
          tmp.rawData[12] = 0;
          tmp.rawData[13] = 0;
          tmp.rawData[14] = 0;
          tmp.rawData[15] = 1;
        }
        if (axis.y == 1) {
          tmp.rawData[0] = c;
          tmp.rawData[1] = 0;
          tmp.rawData[2] = -s;
          tmp.rawData[3] = 0;
          tmp.rawData[4] = 0;
          tmp.rawData[5] = 1;
          tmp.rawData[6] = 0;
          tmp.rawData[7] = 0;
          tmp.rawData[8] = s;
          tmp.rawData[9] = 0;
          tmp.rawData[10] = c;
          tmp.rawData[11] = 0;
          tmp.rawData[12] = 0;
          tmp.rawData[13] = 0;
          tmp.rawData[14] = 0;
          tmp.rawData[15] = 1;
        }
        if (axis.z == 1) {
          tmp.rawData[0] = c;
          tmp.rawData[1] = s;
          tmp.rawData[2] = 0;
          tmp.rawData[3] = 0;
          tmp.rawData[4] = -s;
          tmp.rawData[5] = c;
          tmp.rawData[6] = 0;
          tmp.rawData[7] = 0;
          tmp.rawData[8] = 0;
          tmp.rawData[9] = 0;
          tmp.rawData[10] = 1;
          tmp.rawData[11] = 0;
          tmp.rawData[12] = 0;
          tmp.rawData[13] = 0;
          tmp.rawData[14] = 0;
          tmp.rawData[15] = 1;
        }
        this.append(tmp);
        return this;
      }
      /**
       * Append the triaxial scaling value
       * @param xScale x axis scaling
       * @param yScale y axis scaling
       * @param zScale z axis scaling
       * @version Orillusion3D  0.5.1
       */
      appendScale(xScale, yScale, zScale) {
        Matrix4.helpMatrix.createByScale(xScale, yScale, zScale);
        this.append(Matrix4.helpMatrix);
      }
      /**
       * A scaling matrix is generated and other properties are reset
       * @param xScale x axis scaling
       * @param yScale y axis scaling
       * @param zScale z axis scaling
       * @version Orillusion3D  0.5.1
       */
      createByScale(xScale, yScale, zScale) {
        let data = this.rawData;
        data[0] = xScale;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = yScale;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = zScale;
        data[11] = 0;
        data[12] = 0;
        data[13] = 0;
        data[14] = 0;
        data[15] = 1;
      }
      /**
       * Plus a translation matrix
       * @param x x axis scaling
       * @param y y axis scaling
       * @param z z axis scaling
       * @version Orillusion3D  0.5.1
       */
      appendTranslation(x, y, z) {
        let data = this.rawData;
        data[12] += x;
        data[13] += y;
        data[14] += z;
      }
      /**
       * Returns a clone of the current matrix
       * @returns Matrix4 The cloned matrix
       * @version Orillusion3D  0.5.1
       */
      clone() {
        let ret = new Matrix4();
        ret.copyFrom(this);
        return ret;
      }
      /**
       * Assigns a value to one row of the current matrix
       * @param row Row of copy
       * @param Vector3 Value of copy
       * @version Orillusion3D  0.5.1
       */
      copyRowFrom(row, Vector32) {
        let data = this.rawData;
        switch (row) {
          case 0:
            data[0] = Vector32.x;
            data[1] = Vector32.y;
            data[2] = Vector32.z;
            data[3] = Vector32.w;
            break;
          case 1:
            data[4] = Vector32.x;
            data[5] = Vector32.y;
            data[6] = Vector32.z;
            data[7] = Vector32.w;
            break;
          case 2:
            data[8] = Vector32.x;
            data[9] = Vector32.y;
            data[10] = Vector32.z;
            data[11] = Vector32.w;
            break;
          case 3:
            data[12] = Vector32.x;
            data[13] = Vector32.y;
            data[14] = Vector32.z;
            data[15] = Vector32.w;
            break;
        }
      }
      /**
       * One of the rows in the copy matrix stores the values in Vector3.
       * @param row Row of copy
       * @param Vector3 Copy the storage target
       * @version Orillusion3D  0.5.1
       */
      copyRowTo(row, Vector32) {
        let data = this.rawData;
        switch (row) {
          case 0:
            Vector32.x = data[0];
            Vector32.y = data[1];
            Vector32.z = data[2];
            Vector32.w = data[3];
            break;
          case 1:
            Vector32.x = data[4];
            Vector32.y = data[5];
            Vector32.z = data[6];
            Vector32.w = data[7];
            break;
          case 2:
            Vector32.x = data[8];
            Vector32.y = data[9];
            Vector32.z = data[10];
            Vector32.w = data[11];
            break;
          case 3:
            Vector32.x = data[12];
            Vector32.y = data[13];
            Vector32.z = data[14];
            Vector32.w = data[15];
            break;
        }
      }
      /**
       * Assigns the value of a matrix to the current matrix.
       * @param sourceMatrix3D source Matrix
       * @returns Returns the current matrix
       * @version Orillusion3D  0.5.1
       */
      copyFrom(sourceMatrix3D) {
        let data = this.rawData;
        data[0] = sourceMatrix3D.rawData[0];
        data[1] = sourceMatrix3D.rawData[1];
        data[2] = sourceMatrix3D.rawData[2];
        data[3] = sourceMatrix3D.rawData[3];
        data[4] = sourceMatrix3D.rawData[4];
        data[5] = sourceMatrix3D.rawData[5];
        data[6] = sourceMatrix3D.rawData[6];
        data[7] = sourceMatrix3D.rawData[7];
        data[8] = sourceMatrix3D.rawData[8];
        data[9] = sourceMatrix3D.rawData[9];
        data[10] = sourceMatrix3D.rawData[10];
        data[11] = sourceMatrix3D.rawData[11];
        data[12] = sourceMatrix3D.rawData[12];
        data[13] = sourceMatrix3D.rawData[13];
        data[14] = sourceMatrix3D.rawData[14];
        data[15] = sourceMatrix3D.rawData[15];
        return this;
      }
      /**
       * CoMath.PIes the value of the current matrix to a float array.
       * @param vector The target array.
       * @param index copy from the index of the array.
       * @param transpose Whether to transpose the current matrix.
       * @version Orillusion3D  0.5.1
       */
      copyRawDataTo(vector, index = 0, transpose = false) {
        let data = this.rawData;
        vector[0 + index] = data[0];
        vector[1 + index] = data[1];
        vector[2 + index] = data[2];
        vector[3 + index] = data[3];
        vector[4 + index] = data[4];
        vector[5 + index] = data[5];
        vector[6 + index] = data[6];
        vector[7 + index] = data[7];
        vector[8 + index] = data[8];
        vector[9 + index] = data[9];
        vector[10 + index] = data[10];
        vector[11 + index] = data[11];
        vector[12 + index] = data[12];
        vector[13 + index] = data[13];
        vector[14 + index] = data[14];
        vector[15 + index] = data[15];
      }
      /**
       * Assigns a value to a column of the current matrix
       * @param col column
       * @param Vector3 Source of value
       * @version Orillusion3D  0.5.1
       */
      copyColFrom(col, Vector32) {
        let data = this.rawData;
        switch (col) {
          case 0:
            data[0] = Vector32.x;
            data[4] = Vector32.y;
            data[8] = Vector32.z;
            data[12] = Vector32.w;
            break;
          case 1:
            data[1] = Vector32.x;
            data[5] = Vector32.y;
            data[9] = Vector32.z;
            data[13] = Vector32.w;
            break;
          case 2:
            data[2] = Vector32.x;
            data[6] = Vector32.y;
            data[10] = Vector32.z;
            data[14] = Vector32.w;
            break;
          case 3:
            data[3] = Vector32.x;
            data[7] = Vector32.y;
            data[11] = Vector32.z;
            data[15] = Vector32.w;
            break;
        }
      }
      /**
       * Copy a column of the current matrix
       * @param col column
       * @param Vector3 Target of copy
       * @version Orillusion3D  0.5.1
       */
      copyColTo(col, Vector32) {
        let data = this.rawData;
        switch (col) {
          case 0:
            Vector32.x = data[0];
            Vector32.y = data[4];
            Vector32.z = data[8];
            Vector32.w = data[12];
            break;
          case 1:
            Vector32.x = data[1];
            Vector32.y = data[5];
            Vector32.z = data[9];
            Vector32.w = data[13];
            break;
          case 2:
            Vector32.x = data[2];
            Vector32.y = data[6];
            Vector32.z = data[10];
            Vector32.w = data[14];
            break;
          case 3:
            Vector32.x = data[3];
            Vector32.y = data[7];
            Vector32.z = data[11];
            Vector32.w = data[15];
            break;
        }
      }
      /**
       * Copy the current matrix
       * @param dest Target of copy
       * @version Orillusion3D  0.5.1
       */
      copyToMatrix3D(dest) {
        dest.rawData = this.rawData.slice(0);
      }
      /**
       * Calculate rotation matrix
       * @param quaternion Rotate the quaternion
       * @returns
       */
      makeRotationFromQuaternion(quaternion) {
        this.compose(Matrix4._zero, quaternion, Matrix4._one);
        return this;
      }
      static decomposeRawData = new Float32Array(16).fill(0);
      /**
       * Decompose the current matrix
       * @param orientationStyle The default decomposition type is Orientation3D.EULER_ANGLES
       * @see Orientation3D.AXIS_ANGLE
       * @see Orientation3D.EULER_ANGLES
       * @see Orientation3D.QUATERNION
       * @returns Vector3[3] pos rot scale
       * @version Orillusion3D  0.5.1
       */
      decompose(orientationStyle = "eulerAngles", target) {
        let q = Quaternion.CALCULATION_QUATERNION;
        let vec = target ? target : Matrix4._prs;
        this.copyRawDataTo(Matrix4.decomposeRawData);
        let mr = Matrix4.decomposeRawData;
        let pos = vec[0];
        pos.x = mr[12];
        pos.y = mr[13];
        pos.z = mr[14];
        mr[12] = 0;
        mr[13] = 0;
        mr[14] = 0;
        let scale = vec[2];
        scale.x = Math.sqrt(mr[0] * mr[0] + mr[1] * mr[1] + mr[2] * mr[2]);
        scale.y = Math.sqrt(mr[4] * mr[4] + mr[5] * mr[5] + mr[6] * mr[6]);
        scale.z = Math.sqrt(mr[8] * mr[8] + mr[9] * mr[9] + mr[10] * mr[10]);
        if (mr[0] * (mr[5] * mr[10] - mr[6] * mr[9]) - mr[1] * (mr[4] * mr[10] - mr[6] * mr[8]) + mr[2] * (mr[4] * mr[9] - mr[5] * mr[8]) < 0) {
          scale.z = -scale.z;
        }
        mr[0] /= scale.x;
        mr[1] /= scale.x;
        mr[2] /= scale.x;
        mr[4] /= scale.y;
        mr[5] /= scale.y;
        mr[6] /= scale.y;
        mr[8] /= scale.z;
        mr[9] /= scale.z;
        mr[10] /= scale.z;
        let rot = vec[1];
        let tr;
        switch (orientationStyle) {
          case Orientation3D.AXIS_ANGLE:
            rot.w = Math.acos((mr[0] + mr[5] + mr[10] - 1) / 2);
            let len = Math.sqrt((mr[6] - mr[9]) * (mr[6] - mr[9]) + (mr[8] - mr[2]) * (mr[8] - mr[2]) + (mr[1] - mr[4]) * (mr[1] - mr[4]));
            rot.x = (mr[6] - mr[9]) / len;
            rot.y = (mr[8] - mr[2]) / len;
            rot.z = (mr[1] - mr[4]) / len;
            break;
          case Orientation3D.QUATERNION:
            tr = mr[0] + mr[5] + mr[10];
            if (tr > 0) {
              rot.w = Math.sqrt(1 + tr) / 2;
              rot.x = (mr[6] - mr[9]) / (4 * rot.w);
              rot.y = (mr[8] - mr[2]) / (4 * rot.w);
              rot.z = (mr[1] - mr[4]) / (4 * rot.w);
            } else if (mr[0] > mr[5] && mr[0] > mr[10]) {
              rot.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
              rot.w = (mr[6] - mr[9]) / (4 * rot.x);
              rot.y = (mr[1] + mr[4]) / (4 * rot.x);
              rot.z = (mr[8] + mr[2]) / (4 * rot.x);
            } else if (mr[5] > mr[10]) {
              rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
              rot.x = (mr[1] + mr[4]) / (4 * rot.y);
              rot.w = (mr[8] - mr[2]) / (4 * rot.y);
              rot.z = (mr[6] + mr[9]) / (4 * rot.y);
            } else {
              rot.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
              rot.x = (mr[8] + mr[2]) / (4 * rot.z);
              rot.y = (mr[6] + mr[9]) / (4 * rot.z);
              rot.w = (mr[1] - mr[4]) / (4 * rot.z);
            }
            break;
          case Orientation3D.EULER_ANGLES:
            tr = mr[0] + mr[5] + mr[10];
            if (tr > 0) {
              q.w = Math.sqrt(1 + tr) / 2;
              q.x = (mr[6] - mr[9]) / (4 * q.w);
              q.y = (mr[8] - mr[2]) / (4 * q.w);
              q.z = (mr[1] - mr[4]) / (4 * q.w);
            } else if (mr[0] > mr[5] && mr[0] > mr[10]) {
              q.x = Math.sqrt(1 + mr[0] - mr[5] - mr[10]) / 2;
              q.w = (mr[6] - mr[9]) / (4 * q.x);
              q.y = (mr[1] + mr[4]) / (4 * q.x);
              q.z = (mr[8] + mr[2]) / (4 * q.x);
            } else if (mr[5] > mr[10]) {
              rot.y = Math.sqrt(1 + mr[5] - mr[0] - mr[10]) / 2;
              q.x = (mr[1] + mr[4]) / (4 * q.y);
              q.w = (mr[8] - mr[2]) / (4 * q.y);
              q.z = (mr[6] + mr[9]) / (4 * q.y);
            } else {
              q.z = Math.sqrt(1 + mr[10] - mr[0] - mr[5]) / 2;
              q.x = (mr[8] + mr[2]) / (4 * q.z);
              q.y = (mr[6] + mr[9]) / (4 * q.z);
              q.w = (mr[1] - mr[4]) / (4 * q.z);
            }
            q.getEulerAngles(rot);
            break;
        }
        vec[0] = pos;
        vec[1] = rot;
        vec[2] = scale;
        return vec;
      }
      /**
       * Get the Euler vector
       * @param target Vector of results
       * @param quaternion Rotate the quaternion
       * @param isDegree Whether to convert to Angle
       * @param order convert order
       * @returns
       */
      static getEuler(target, quaternion, isDegree = true, order) {
        target ||= new Vector3();
        Matrix4._getEulerMatrix.makeRotationFromQuaternion(quaternion).makeEuler(target, isDegree, order);
        return target;
      }
      /**
       * Calculate the combined matrix of displacement, rotation and scaling
       * @param position translation
       * @param quaternion rotation
       * @param scale scale
       * @returns
       */
      compose(position, quaternion, scale) {
        const te = this.rawData;
        const x = quaternion.x;
        const y = quaternion.y;
        const z = quaternion.z;
        const w = quaternion.w;
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;
        const xx = x * x2;
        const xy = x * y2;
        const xz = x * z2;
        const yy = y * y2;
        const yz = y * z2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;
        const sx = scale.x;
        const sy = scale.y;
        const sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
      /**
       * The current matrix transforms a vector
       * @param v Vector to transform
       * @param target The default is null and if the current argument is null then a new Vector3 will be returned
       * @returns Vector3 The transformed vector
       * @version Orillusion3D  0.5.1
       */
      deltaTransformVector(v, target) {
        target ||= new Vector3();
        let data = this.rawData;
        let x = v.x;
        let y = v.y;
        let z = v.z;
        target.x = x * data[0] + y * data[4] + z * data[8];
        target.y = x * data[1] + y * data[5] + z * data[9];
        target.z = x * data[2] + y * data[6] + z * data[10];
        target.w = x * data[3] + y * data[7] + z * data[11];
        return target;
      }
      /**
       * Unifies the current matrix
       * @version Orillusion3D  0.5.1
       */
      identity() {
        let data = this.rawData;
        data[0] = 1;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = 1;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = 1;
        data[11] = 0;
        data[12] = 0;
        data[13] = 0;
        data[14] = 0;
        data[15] = 1;
        return this;
      }
      /**
       * Fill the current matrix
       * @param value The filled value
       * @version Orillusion3D  0.5.1
       */
      fill(value) {
        let data = this.rawData;
        data[1] = value;
        data[2] = value;
        data[3] = value;
        data[4] = value;
        data[6] = value;
        data[7] = value;
        data[8] = value;
        data[9] = value;
        data[11] = value;
        data[12] = value;
        data[13] = value;
        data[14] = value;
        data[0] = value;
        data[5] = value;
        data[10] = value;
        data[15] = value;
      }
      /**
       * Invert the current matrix
       * @version Orillusion3D  0.5.1
       */
      invers33() {
        let data = this.rawData;
        let rkInverse_00 = data[5] * data[10] - data[9] * data[6];
        let rkInverse_01 = data[8] * data[6] - data[4] * data[10];
        let rkInverse_02 = data[4] * data[9] - data[8] * data[5];
        let rkInverse_10 = data[9] * data[2] - data[1] * data[10];
        let rkInverse_11 = data[0] * data[10] - data[8] * data[2];
        let rkInverse_12 = data[8] * data[1] - data[0] * data[9];
        let rkInverse_20 = data[1] * data[6] - data[5] * data[2];
        let rkInverse_21 = data[4] * data[2] - data[0] * data[6];
        let rkInverse_22 = data[0] * data[5] - data[4] * data[1];
        let fDet = data[0] * rkInverse_00 + data[4] * rkInverse_10 + data[8] * rkInverse_20;
        if (Math.abs(fDet) > 1e-11) {
          let fInvDet = 1 / fDet;
          data[0] = fInvDet * rkInverse_00;
          data[4] = fInvDet * rkInverse_01;
          data[8] = fInvDet * rkInverse_02;
          data[1] = fInvDet * rkInverse_10;
          data[5] = fInvDet * rkInverse_11;
          data[9] = fInvDet * rkInverse_12;
          data[2] = fInvDet * rkInverse_20;
          data[6] = fInvDet * rkInverse_21;
          data[10] = fInvDet * rkInverse_22;
        }
      }
      /**
       * Invert the current matrix
       * @returns boolean Whether can invert it
       * @version Orillusion3D  0.5.1
       */
      invert() {
        let d = this.determinant;
        let invertable = Math.abs(d) > 1e-11;
        let data = this.rawData;
        if (invertable) {
          d = 1 / d;
          let m11 = data[0];
          let m21 = data[4];
          let m31 = data[8];
          let m41 = data[12];
          let m12 = data[1];
          let m22 = data[5];
          let m32 = data[9];
          let m42 = data[13];
          let m13 = data[2];
          let m23 = data[6];
          let m33 = data[10];
          let m43 = data[14];
          let m14 = data[3];
          let m24 = data[7];
          let m34 = data[11];
          let m44 = data[15];
          data[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
          data[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
          data[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
          data[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
          data[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
          data[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
          data[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
          data[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
          data[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
          data[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
          data[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
          data[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
          data[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
          data[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
          data[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
          data[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
        }
        return invertable;
      }
      /**
       * Converts the current coordinates to the world coordinates
       * @param v Current coordinates
       * @param target world coordinate
       * @returns world coordinate
       */
      transformPoint(v, target) {
        let data = this.rawData;
        target ||= new Vector3();
        let x = v.x;
        let y = v.y;
        let z = v.z;
        target.x = x * data[0] + y * data[4] + z * data[8] + data[12];
        target.y = x * data[1] + y * data[5] + z * data[9] + data[13];
        target.z = x * data[2] + y * data[6] + z * data[10] + data[14];
        return target;
      }
      /**
       * Transforming a 3D vector with the current matrix does not deal with displacement
       * @param v Vector of transformation
       * @param target If the current argument is null then a new Vector3 will be returned
       * @returns Vector3 The transformed vector
       * @version Orillusion3D  0.5.1
       */
      transformVector(v, target) {
        let data = this.rawData;
        target ||= new Vector3();
        let x = v.x;
        let y = v.y;
        let z = v.z;
        target.x = x * data[0] + y * data[4] + z * data[8];
        target.y = x * data[1] + y * data[5] + z * data[9];
        target.z = x * data[2] + y * data[6] + z * data[10];
        return target;
      }
      /**
       * The current matrix transpose
       * @version Orillusion3D  0.5.1
       */
      transpose() {
        let data = this.rawData;
        for (let i = 0; i < Matrix4.helpMatrix.rawData.length; i++) {
          Matrix4.helpMatrix.rawData[i] = data[i];
        }
        data[1] = Matrix4.helpMatrix.rawData[4];
        data[2] = Matrix4.helpMatrix.rawData[8];
        data[3] = Matrix4.helpMatrix.rawData[12];
        data[4] = Matrix4.helpMatrix.rawData[1];
        data[6] = Matrix4.helpMatrix.rawData[9];
        data[7] = Matrix4.helpMatrix.rawData[13];
        data[8] = Matrix4.helpMatrix.rawData[2];
        data[9] = Matrix4.helpMatrix.rawData[6];
        data[11] = Matrix4.helpMatrix.rawData[14];
        data[12] = Matrix4.helpMatrix.rawData[3];
        data[13] = Matrix4.helpMatrix.rawData[7];
        data[14] = Matrix4.helpMatrix.rawData[11];
      }
      /**
       * Returns the matrix determinant
       * @returns number determinant
       * @version Orillusion3D  0.5.1
       */
      get determinant() {
        let data = this.rawData;
        return (data[0] * data[5] - data[4] * data[1]) * (data[10] * data[15] - data[14] * data[11]) - (data[0] * data[9] - data[8] * data[1]) * (data[6] * data[15] - data[14] * data[7]) + (data[0] * data[13] - data[12] * data[1]) * (data[6] * data[11] - data[10] * data[7]) + (data[4] * data[9] - data[8] * data[5]) * (data[2] * data[15] - data[14] * data[3]) - (data[4] * data[13] - data[12] * data[5]) * (data[2] * data[11] - data[10] * data[3]) + (data[8] * data[13] - data[12] * data[9]) * (data[2] * data[7] - data[6] * data[3]);
      }
      /**
       * Return matrix displacement
       * @param out Position of translation
       * @returns Position of translation
       */
      getPosition(out) {
        out ||= new Vector3();
        let data = this.rawData;
        out.x = data[12];
        out.y = data[13];
        out.z = data[14];
        return out;
      }
      /**
       * Return translation
       * @returns Vector3 Position of translation
       * @version Orillusion3D  0.5.1
       */
      get position() {
        this._position.set(this.rawData[12], this.rawData[13], this.rawData[14]);
        return this._position;
      }
      /**
       * Set Position of translation
       * @param value Position of translation
       * @version Orillusion3D  0.5.1
       */
      set position(value) {
        let data = this.rawData;
        data[12] = value.x;
        data[13] = value.y;
        data[14] = value.z;
      }
      /**
       * get Component of scale
       *
       * @returns Vector3 scale
       * @version Orillusion3D  0.5.1
       */
      get scale() {
        let data = this.rawData;
        return new Vector3(data[0], data[5], data[10]);
      }
      /**
       * Set component of scale
       */
      set scale(value) {
        let data = this.rawData;
        data[0] = value.x;
        data[5] = value.y;
        data[10] = value.z;
      }
      // public setWorldTrans( pos:Vector3 , rotQ:Quaternion,scale:Vector3 = Vector3.SCALE){
      //     this.makeTransform(pos,scale,rotQ);
      // }
      /**
       * Returns the value of the matrix as a string
       *
       * @returns string 
       * @version Orillusion3D  0.5.1
       */
      toString() {
        let data = this.rawData;
        return "matrix3d(" + Math.round(data[0] * 1e3) / 1e3 + "," + Math.round(data[1] * 1e3) / 1e3 + "," + Math.round(data[2] * 1e3) / 1e3 + "," + Math.round(data[3] * 1e3) / 1e3 + "," + Math.round(data[4] * 1e3) / 1e3 + "," + Math.round(data[5] * 1e3) / 1e3 + "," + Math.round(data[6] * 1e3) / 1e3 + "," + Math.round(data[7] * 1e3) / 1e3 + "," + Math.round(data[8] * 1e3) / 1e3 + "," + Math.round(data[9] * 1e3) / 1e3 + "," + Math.round(data[10] * 1e3) / 1e3 + "," + Math.round(data[11] * 1e3) / 1e3 + "," + Math.round(data[12] * 1e3) / 1e3 + "," + Math.round(data[13] * 1e3) / 1e3 + "," + Math.round(data[14] * 1e3) / 1e3 + "," + Math.round(data[15] * 1e3) / 1e3 + ")";
      }
      /**
       * Interpolate between two matrices
       * @param m0 Matrix 0
       * @param m1 Matrix 1
       * @param t Factor of interpolation 0.0 - 1.0
       * @version Orillusion3D  0.5.1
       */
      lerp(m0, m1, t) {
        this.copyFrom(m1).sub(m0).mult(t).add(m0);
      }
      /**
       * Read matrix element values
       * @param row row
       * @param column column
       * @returns
       */
      get(row, column) {
        return this.rawData[row + column * 4];
      }
      /**
       * Sets the matrix element values
       * @param row row
       * @param column column
       * @param v value
       */
      set(row, column, v) {
        this.rawData[row + column * 4] = v;
      }
      /**
       * Get the maximum value of the matrix scaled on each axis
       * @version Orillusion3D  0.5.1 4.0
       */
      getMaxScaleOnAxis() {
        let te = this.rawData;
        let scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        let scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        let scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      /**
       * Calculate the displacement from the vector
       * @param inTrans Vector
       * @returns current matrix
       */
      translate(inTrans) {
        let x = this.get(0, 0) * inTrans.x + this.get(0, 1) * inTrans.y + this.get(0, 2) * inTrans.z + this.get(0, 3);
        let y = this.get(1, 0) * inTrans.x + this.get(1, 1) * inTrans.y + this.get(1, 2) * inTrans.z + this.get(1, 3);
        let z = this.get(2, 0) * inTrans.x + this.get(2, 1) * inTrans.y + this.get(2, 2) * inTrans.z + this.get(2, 3);
        let w = this.get(3, 0) * inTrans.x + this.get(3, 1) * inTrans.y + this.get(3, 2) * inTrans.z + this.get(3, 3);
        this.set(0, 3, x);
        this.set(1, 3, y);
        this.set(2, 3, z);
        this.set(3, 3, w);
        return this;
      }
      /**
       * from unity AMath.PI
       */
      setTRInverse(pos, q) {
        q = q.inverse();
        Quaternion.quaternionToMatrix(q, this);
        this.translate(new Vector3(-pos.x, -pos.y, -pos.z));
      }
      /**
       * Set scale value
       * @param inScale scale value
       * @returns this matrix
       */
      setScale(inScale) {
        this.set(0, 0, inScale.x);
        this.set(0, 1, 0);
        this.set(0, 2, 0);
        this.set(0, 3, 0);
        this.set(1, 0, 0);
        this.set(1, 1, inScale.y);
        this.set(1, 2, 0);
        this.set(1, 3, 0);
        this.set(2, 0, 0);
        this.set(2, 1, 0);
        this.set(2, 2, inScale.z);
        this.set(2, 3, 0);
        this.set(3, 0, 0);
        this.set(3, 1, 0);
        this.set(3, 2, 0);
        this.set(3, 3, 1);
        return this;
      }
      /**
       * Generate the matrix according to the three axes
       * @param xAxis
       * @param yAxis
       * @param zAxis
       */
      makeBasis(xAxis, yAxis, zAxis) {
        this.setElements(
          xAxis.x,
          yAxis.x,
          zAxis.x,
          0,
          xAxis.y,
          yAxis.y,
          zAxis.y,
          0,
          xAxis.z,
          yAxis.z,
          zAxis.z,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      makeRotationAxis(axis, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.setElements(
          tx * x + c,
          tx * y - s * z,
          tx * z + s * y,
          0,
          tx * y + s * z,
          ty * y + c,
          ty * z - s * x,
          0,
          tx * z - s * y,
          ty * z + s * x,
          t * z * z + c,
          0,
          0,
          0,
          0,
          1
        );
        return this;
      }
      /**
       * private
       */
      static transpose(matrix, result) {
        result ||= new Matrix4();
        let m = matrix.rawData;
        let r = result.rawData;
        r[0] = m[0];
        r[1] = m[4];
        r[2] = m[8];
        r[3] = m[12];
        r[4] = m[1];
        r[5] = m[5];
        r[6] = m[9];
        r[7] = m[13];
        r[8] = m[2];
        r[9] = m[6];
        r[10] = m[10];
        r[11] = m[14];
        r[12] = m[3];
        r[13] = m[7];
        r[14] = m[11];
        r[15] = m[15];
        return result;
      }
      /**
       * private
       */
      static inverse(matrix, result) {
        result ||= new Matrix4();
        let m = matrix.rawData;
        let r = result.rawData;
        r[0] = m[5] * m[10] * m[15] - m[5] * m[14] * m[11] - m[6] * m[9] * m[15] + m[6] * m[13] * m[11] + m[7] * m[9] * m[14] - m[7] * m[13] * m[10];
        r[1] = -m[1] * m[10] * m[15] + m[1] * m[14] * m[11] + m[2] * m[9] * m[15] - m[2] * m[13] * m[11] - m[3] * m[9] * m[14] + m[3] * m[13] * m[10];
        r[2] = m[1] * m[6] * m[15] - m[1] * m[14] * m[7] - m[2] * m[5] * m[15] + m[2] * m[13] * m[7] + m[3] * m[5] * m[14] - m[3] * m[13] * m[6];
        r[3] = -m[1] * m[6] * m[11] + m[1] * m[10] * m[7] + m[2] * m[5] * m[11] - m[2] * m[9] * m[7] - m[3] * m[5] * m[10] + m[3] * m[9] * m[6];
        r[4] = -m[4] * m[10] * m[15] + m[4] * m[14] * m[11] + m[6] * m[8] * m[15] - m[6] * m[12] * m[11] - m[7] * m[8] * m[14] + m[7] * m[12] * m[10];
        r[5] = m[0] * m[10] * m[15] - m[0] * m[14] * m[11] - m[2] * m[8] * m[15] + m[2] * m[12] * m[11] + m[3] * m[8] * m[14] - m[3] * m[12] * m[10];
        r[6] = -m[0] * m[6] * m[15] + m[0] * m[14] * m[7] + m[2] * m[4] * m[15] - m[2] * m[12] * m[7] - m[3] * m[4] * m[14] + m[3] * m[12] * m[6];
        r[7] = m[0] * m[6] * m[11] - m[0] * m[10] * m[7] - m[2] * m[4] * m[11] + m[2] * m[8] * m[7] + m[3] * m[4] * m[10] - m[3] * m[8] * m[6];
        r[8] = m[4] * m[9] * m[15] - m[4] * m[13] * m[11] - m[5] * m[8] * m[15] + m[5] * m[12] * m[11] + m[7] * m[8] * m[13] - m[7] * m[12] * m[9];
        r[9] = -m[0] * m[9] * m[15] + m[0] * m[13] * m[11] + m[1] * m[8] * m[15] - m[1] * m[12] * m[11] - m[3] * m[8] * m[13] + m[3] * m[12] * m[9];
        r[10] = m[0] * m[5] * m[15] - m[0] * m[13] * m[7] - m[1] * m[4] * m[15] + m[1] * m[12] * m[7] + m[3] * m[4] * m[13] - m[3] * m[12] * m[5];
        r[11] = -m[0] * m[5] * m[11] + m[0] * m[9] * m[7] + m[1] * m[4] * m[11] - m[1] * m[8] * m[7] - m[3] * m[4] * m[9] + m[3] * m[8] * m[5];
        r[12] = -m[4] * m[9] * m[14] + m[4] * m[13] * m[10] + m[5] * m[8] * m[14] - m[5] * m[12] * m[10] - m[6] * m[8] * m[13] + m[6] * m[12] * m[9];
        r[13] = m[0] * m[9] * m[14] - m[0] * m[13] * m[10] - m[1] * m[8] * m[14] + m[1] * m[12] * m[10] + m[2] * m[8] * m[13] - m[2] * m[12] * m[9];
        r[14] = -m[0] * m[5] * m[14] + m[0] * m[13] * m[6] + m[1] * m[4] * m[14] - m[1] * m[12] * m[6] - m[2] * m[4] * m[13] + m[2] * m[12] * m[5];
        r[15] = m[0] * m[5] * m[10] - m[0] * m[9] * m[6] - m[1] * m[4] * m[10] + m[1] * m[8] * m[6] + m[2] * m[4] * m[9] - m[2] * m[8] * m[5];
        let det = m[0] * r[0] + m[1] * r[4] + m[2] * r[8] + m[3] * r[12];
        for (let i = 0; i < 16; i++) {
          r[i] /= det;
        }
        return result;
      }
      makeEuler(target, toDegree, order = "XYZ") {
        const te = this.rawData;
        const m11 = te[0];
        const m12 = te[4];
        const m13 = te[8];
        const m21 = te[1];
        const m22 = te[5];
        const m23 = te[9];
        const m31 = te[2];
        const m32 = te[6];
        const m33 = te[10];
        switch (order) {
          case "XYZ":
            target.y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              target.x = Math.atan2(-m23, m33);
              target.z = Math.atan2(-m12, m11);
            } else {
              target.x = Math.atan2(m32, m22);
              target.z = 0;
            }
            break;
          case "YXZ":
            target.x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              target.y = Math.atan2(m13, m33);
              target.z = Math.atan2(m21, m22);
            } else {
              target.y = Math.atan2(-m31, m11);
              target.z = 0;
            }
            break;
          case "ZXY":
            target.x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              target.y = Math.atan2(-m31, m33);
              target.z = Math.atan2(-m12, m22);
            } else {
              target.y = 0;
              target.z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            target.y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              target.x = Math.atan2(m32, m33);
              target.z = Math.atan2(m21, m11);
            } else {
              target.x = 0;
              target.z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            target.z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              target.x = Math.atan2(-m23, m22);
              target.y = Math.atan2(-m31, m11);
            } else {
              target.x = 0;
              target.y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            target.z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              target.x = Math.atan2(m32, m22);
              target.y = Math.atan2(m13, m11);
            } else {
              target.x = Math.atan2(-m23, m33);
              target.y = 0;
            }
            break;
        }
        if (toDegree) {
          target.multiplyScalar(RADIANS_TO_DEGREES);
        }
        return target;
      }
      setElements(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.rawData;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      }
      /**
       * @internal
       */
      makeMatrix44ByQuaternion(pos, scale, rot) {
        this.identity();
        Quaternion.quaternionToMatrix(rot, this);
        this.appendTranslation(pos.x, pos.y, pos.z);
        this.appendScale(scale.x, scale.y, scale.z);
      }
    }
    function multiplyMatrices4x4REF(lhs, rhs, res) {
      for (let i = 0; i < 4; i++) {
        res.rawData[i] = lhs.rawData[i] * rhs.rawData[0] + lhs.rawData[i + 4] * rhs.rawData[1] + lhs.rawData[i + 8] * rhs.rawData[2] + lhs.rawData[i + 12] * rhs.rawData[3];
        res.rawData[i + 4] = lhs.rawData[i] * rhs.rawData[4] + lhs.rawData[i + 4] * rhs.rawData[5] + lhs.rawData[i + 8] * rhs.rawData[6] + lhs.rawData[i + 12] * rhs.rawData[7];
        res.rawData[i + 8] = lhs.rawData[i] * rhs.rawData[8] + lhs.rawData[i + 4] * rhs.rawData[9] + lhs.rawData[i + 8] * rhs.rawData[10] + lhs.rawData[i + 12] * rhs.rawData[11];
        res.rawData[i + 12] = lhs.rawData[i] * rhs.rawData[12] + lhs.rawData[i + 4] * rhs.rawData[13] + lhs.rawData[i + 8] * rhs.rawData[14] + lhs.rawData[i + 12] * rhs.rawData[15];
      }
    }
    function makeMatrix44(r, p, s, outMat) {
      let rawData = outMat.rawData;
      let x = r.x * DEGREES_TO_RADIANS;
      let y = r.y * DEGREES_TO_RADIANS;
      let z = r.z * DEGREES_TO_RADIANS;
      let w = 0;
      let halfX = x * 0.5;
      let halfY = y * 0.5;
      let halfZ = z * 0.5;
      let cosX = Math.cos(halfX);
      let sinX = Math.sin(halfX);
      let cosY = Math.cos(halfY);
      let sinY = Math.sin(halfY);
      let cosZ = Math.cos(halfZ);
      let sinZ = Math.sin(halfZ);
      w = cosX * cosY * cosZ + sinX * sinY * sinZ;
      x = sinX * cosY * cosZ - cosX * sinY * sinZ;
      y = cosX * sinY * cosZ + sinX * cosY * sinZ;
      z = cosX * cosY * sinZ - sinX * sinY * cosZ;
      let x2 = x + x;
      let y2 = y + y;
      let z2 = z + z;
      let xx = x * x2;
      let xy = x * y2;
      let xz = x * z2;
      let yy = y * y2;
      let yz = y * z2;
      let zz = z * z2;
      let wx = w * x2;
      let wy = w * y2;
      let wz = w * z2;
      let sx = s.x;
      let sy = s.y;
      let sz = s.z;
      rawData[0] = (1 - (yy + zz)) * sx;
      rawData[1] = (xy + wz) * sx;
      rawData[2] = (xz - wy) * sx;
      rawData[3] = 0;
      rawData[4] = (xy - wz) * sy;
      rawData[5] = (1 - (xx + zz)) * sy;
      rawData[6] = (yz + wx) * sy;
      rawData[7] = 0;
      rawData[8] = (xz + wy) * sz;
      rawData[9] = (yz - wx) * sz;
      rawData[10] = (1 - (xx + yy)) * sz;
      rawData[11] = 0;
      rawData[12] = p.x;
      rawData[13] = p.y;
      rawData[14] = p.z;
      rawData[15] = 1;
    }
    function append(src, lhs, target) {
      let data = src.rawData;
      let targetData = target.rawData;
      let m111 = data[0];
      let m121 = data[4];
      let m131 = data[8];
      let m141 = data[12];
      let m112 = data[1];
      let m122 = data[5];
      let m132 = data[9];
      let m142 = data[13];
      let m113 = data[2];
      let m123 = data[6];
      let m133 = data[10];
      let m143 = data[14];
      let m114 = data[3];
      let m124 = data[7];
      let m134 = data[11];
      let m144 = data[15];
      targetData[0] = m111 * lhs.rawData[0] + m112 * lhs.rawData[4] + m113 * lhs.rawData[8] + m114 * lhs.rawData[12];
      targetData[1] = m111 * lhs.rawData[1] + m112 * lhs.rawData[5] + m113 * lhs.rawData[9] + m114 * lhs.rawData[13];
      targetData[2] = m111 * lhs.rawData[2] + m112 * lhs.rawData[6] + m113 * lhs.rawData[10] + m114 * lhs.rawData[14];
      targetData[3] = m111 * lhs.rawData[3] + m112 * lhs.rawData[7] + m113 * lhs.rawData[11] + m114 * lhs.rawData[15];
      targetData[4] = m121 * lhs.rawData[0] + m122 * lhs.rawData[4] + m123 * lhs.rawData[8] + m124 * lhs.rawData[12];
      targetData[5] = m121 * lhs.rawData[1] + m122 * lhs.rawData[5] + m123 * lhs.rawData[9] + m124 * lhs.rawData[13];
      targetData[6] = m121 * lhs.rawData[2] + m122 * lhs.rawData[6] + m123 * lhs.rawData[10] + m124 * lhs.rawData[14];
      targetData[7] = m121 * lhs.rawData[3] + m122 * lhs.rawData[7] + m123 * lhs.rawData[11] + m124 * lhs.rawData[15];
      targetData[8] = m131 * lhs.rawData[0] + m132 * lhs.rawData[4] + m133 * lhs.rawData[8] + m134 * lhs.rawData[12];
      targetData[9] = m131 * lhs.rawData[1] + m132 * lhs.rawData[5] + m133 * lhs.rawData[9] + m134 * lhs.rawData[13];
      targetData[10] = m131 * lhs.rawData[2] + m132 * lhs.rawData[6] + m133 * lhs.rawData[10] + m134 * lhs.rawData[14];
      targetData[11] = m131 * lhs.rawData[3] + m132 * lhs.rawData[7] + m133 * lhs.rawData[11] + m134 * lhs.rawData[15];
      targetData[12] = m141 * lhs.rawData[0] + m142 * lhs.rawData[4] + m143 * lhs.rawData[8] + m144 * lhs.rawData[12];
      targetData[13] = m141 * lhs.rawData[1] + m142 * lhs.rawData[5] + m143 * lhs.rawData[9] + m144 * lhs.rawData[13];
      targetData[14] = m141 * lhs.rawData[2] + m142 * lhs.rawData[6] + m143 * lhs.rawData[10] + m144 * lhs.rawData[14];
      targetData[15] = m141 * lhs.rawData[3] + m142 * lhs.rawData[7] + m143 * lhs.rawData[11] + m144 * lhs.rawData[15];
    }
    function rotMatrix(mat, q) {
      let x = q.x;
      let y = q.y;
      let z = q.z;
      let w = q.w;
      let rawData = mat.rawData;
      let xy2 = 2 * x * y;
      let xz2 = 2 * x * z;
      let xw2 = 2 * x * w;
      let yz2 = 2 * y * z;
      let yw2 = 2 * y * w;
      let zw2 = 2 * z * w;
      let xx = x * x;
      let yy = y * y;
      let zz = z * z;
      let ww = w * w;
      rawData[0] = xx - yy - zz + ww;
      rawData[4] = xy2 - zw2;
      rawData[8] = xz2 + yw2;
      rawData[12] = 0;
      rawData[1] = xy2 + zw2;
      rawData[5] = -xx + yy - zz + ww;
      rawData[9] = yz2 - xw2;
      rawData[13] = 0;
      rawData[2] = xz2 - yw2;
      rawData[6] = yz2 + xw2;
      rawData[10] = -xx - yy + zz + ww;
      rawData[14] = 0;
      rawData[3] = 0;
      rawData[7] = 0;
      rawData[11] = 0;
      rawData[15] = 1;
      return mat;
    }
    function matrixRotateY(rad, target) {
      let out = target.rawData;
      let s = Math.sin(rad);
      let c = Math.cos(rad);
      out[0] = c;
      out[1] = 0;
      out[2] = -s;
      out[3] = 0;
      out[8] = s;
      out[9] = 0;
      out[10] = c;
      out[11] = 0;
      return out;
    }
    function matrixRotate(rad, axis, target) {
      let x = axis.x;
      let y = axis.y;
      let z = axis.z;
      let len = Math.hypot(x, y, z);
      let s;
      let c;
      let t;
      let b00;
      let b01;
      let b02;
      let b10;
      let b11;
      let b12;
      let b20;
      let b21;
      let b22;
      if (len < EPSILON) {
        return null;
      }
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c;
      let out = target.rawData;
      out[0] = b00;
      out[1] = b01;
      out[2] = b02;
      out[3] = 0;
      out[4] = b10;
      out[5] = b11;
      out[6] = b12;
      out[7] = 0;
      out[8] = b20;
      out[9] = b21;
      out[10] = b22;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    function matrixMultiply(aMat, bMat, target) {
      let a = aMat.rawData;
      let a00 = a[0];
      let a01 = a[1];
      let a02 = a[2];
      let a03 = a[3];
      let a10 = a[4];
      let a11 = a[5];
      let a12 = a[6];
      let a13 = a[7];
      let a20 = a[8];
      let a21 = a[9];
      let a22 = a[10];
      let a23 = a[11];
      let a30 = a[12];
      let a31 = a[13];
      let a32 = a[14];
      let a33 = a[15];
      let b = bMat.rawData;
      let out = target.rawData;
      let b0 = b[0];
      let b1 = b[1];
      let b2 = b[2];
      let b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }

    var LightType = /* @__PURE__ */ ((LightType2) => {
      LightType2[LightType2["None"] = 0] = "None";
      LightType2[LightType2["PointLight"] = 1] = "PointLight";
      LightType2[LightType2["DirectionLight"] = 2] = "DirectionLight";
      LightType2[LightType2["SpotLight"] = 3] = "SpotLight";
      LightType2[LightType2["SkyLight"] = 4] = "SkyLight";
      return LightType2;
    })(LightType || {});
    class LightData extends Struct {
      static lightSize = 24;
      index = -1;
      /**
       * Light source type
       * @see LightType
       *  */
      lightType = -1;
      /**
      * 
      * Light source radius
      */
      radius = 0.5;
      /**
       *
       * The illumination distance of the light source, which is 0, means that the intensity of the light will not decrease due to the distance
       */
      linear = 1;
      lightPosition = new Vector3();
      lightMatrixIndex = -1;
      /**
       * Light source direction
       */
      direction = new Vector3();
      quadratic = 0.032;
      /**
      *
      * The color of the light source
      */
      lightColor = new Color(1, 1, 1, 1);
      /**
       *
       * The intensity of light exposure
       */
      intensity = 1;
      /**
       *
       * Inner cone angle of light source
       */
      innerAngle = 0;
      /**
       *
       * Outer cone angle of light source
       */
      outerAngle = 1;
      /**
       *
       * The size of the light source range and the distance emitted from the center of the light source object. Only Point and Spotlight have this parameter.
       */
      range = 100;
      /**
       *
       * shadow at shadow map index
       */
      castShadowIndex = -1;
      /**
       * Tangent direction of light
       */
      lightTangent = Vector3.FORWARD;
      /**
       * Whether to use lighting ies
       */
      iesIndex = -1;
    }

    class ComponentCollect {
      /**
       * @internal
       */
      static componentsUpdateList;
      /**
       * @internal
       */
      static componentsLateUpdateList;
      /**
       * @internal
       */
      static componentsBeforeUpdateList;
      /**
       * @internal
       */
      static componentsComputeList;
      /**
       * @internal
       */
      static componentsEnablePickerList;
      /**
       * @internal
       */
      static graphicComponent;
      /**
       * @internal
       */
      // private static waitStartComponentBak: Map<Object3D, IComponent[]>;
      // private static waitStartComponentBody: Map<Object3D, IComponent[]>;
      static waitStartComponent;
      static _init = false;
      static init() {
        if (!this._init) {
          this._init = true;
          this.componentsUpdateList = /* @__PURE__ */ new Map();
          this.componentsLateUpdateList = /* @__PURE__ */ new Map();
          this.componentsBeforeUpdateList = /* @__PURE__ */ new Map();
          this.componentsComputeList = /* @__PURE__ */ new Map();
          this.componentsEnablePickerList = /* @__PURE__ */ new Map();
          this.graphicComponent = /* @__PURE__ */ new Map();
          this.waitStartComponent = /* @__PURE__ */ new Map();
        }
      }
      static bindUpdate(view, component, call) {
        this.init();
        let list = this.componentsUpdateList.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.componentsUpdateList.set(view, list);
        }
        list.set(component, call);
      }
      static unBindUpdate(view, component) {
        this.init();
        let list = this.componentsUpdateList.get(view);
        if (list) {
          list.delete(component);
        }
      }
      static bindLateUpdate(view, component, call) {
        this.init();
        let list = this.componentsLateUpdateList.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.componentsLateUpdateList.set(view, list);
        }
        list.set(component, call);
      }
      static unBindLateUpdate(view, component) {
        this.init();
        let list = this.componentsLateUpdateList.get(view);
        if (list) {
          list.delete(component);
        }
      }
      static bindBeforeUpdate(view, component, call) {
        this.init();
        let list = this.componentsBeforeUpdateList.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.componentsBeforeUpdateList.set(view, list);
        }
        list.set(component, call);
      }
      static unBindBeforeUpdate(view, component) {
        this.init();
        let list = this.componentsBeforeUpdateList.get(view);
        if (list) {
          list.delete(component);
        }
      }
      static bindCompute(view, component, call) {
        this.init();
        let list = this.componentsComputeList.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.componentsComputeList.set(view, list);
        }
        list.set(component, call);
      }
      static unBindCompute(view, component) {
        this.init();
        let list = this.componentsComputeList.get(view);
        if (list) {
          list.delete(component);
        }
      }
      static bindGraphic(view, component, call) {
        this.init();
        let list = this.graphicComponent.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.graphicComponent.set(view, list);
        }
        list.set(component, call);
      }
      static unBindGraphic(view, component) {
        this.init();
        let list = this.graphicComponent.get(view);
        if (list) {
          list.delete(component);
        }
      }
      static appendWaitStart(component) {
        this.init();
        let arr = this.waitStartComponent.get(component.object3D);
        if (!arr) {
          this.waitStartComponent.set(component.object3D, [component]);
        } else {
          let index = arr.indexOf(component);
          if (index == -1) {
            arr.push(component);
          }
        }
      }
      static removeWaitStart(obj, component) {
        this.init();
        let arr = ComponentCollect.waitStartComponent.get(obj);
        if (arr) {
          let index = arr.indexOf(component);
          if (index != -1) {
            arr.splice(index);
          }
        }
      }
      static bindEnablePick(view, component, call) {
        this.init();
        let list = this.componentsEnablePickerList.get(view);
        if (!list) {
          list = /* @__PURE__ */ new Map();
          this.componentsEnablePickerList.set(view, list);
        }
        list.set(component, call);
      }
      static unBindEnablePick(view, component) {
        this.init();
        let list = this.componentsEnablePickerList.get(view);
        if (list) {
          list.delete(component);
        }
      }
    }

    class ComponentBase {
      /**
       * owner object3D
       */
      object3D = null;
      /**
       * @internal
       */
      _eventDispatcher;
      get eventDispatcher() {
        this._eventDispatcher ||= new CEventDispatcher();
        return this._eventDispatcher;
      }
      set eventDispatcher(value) {
        console.error("The eventDispatcher should not be set externally!");
      }
      /**
       * @internal
       */
      _enable = true;
      __isStart = false;
      isDestroyed;
      get isStart() {
        return this.__isStart;
      }
      /**
       * Return the Transform component attached to the Object3D.
       */
      get transform() {
        return this.object3D.transform;
      }
      /**
       * Enable/disable components. The enabled components can be updated, while the disabled components cannot be updated.
       */
      set enable(value) {
        if (this._enable != value) {
          this._enable = value;
          if (this._enable) {
            this.onEnable?.(this.transform.view3D);
          } else {
            this.onDisable?.(this.transform.view3D);
          }
        }
      }
      /**
       * Enable/disable components. The enabled components can be updated, while the disabled components cannot be updated.
       */
      get enable() {
        return this._enable;
      }
      __init(param) {
        this.init(param);
      }
      __start() {
        if (this.transform && this.transform.scene3D && this._enable) {
          this.onEnable?.(this.transform.view3D);
        }
        if (this.transform && this.transform.scene3D && this.__isStart == false) {
          this.start?.();
          this.__isStart = true;
        }
        if (this.onUpdate) {
          this._onUpdate(this.onUpdate.bind(this));
        }
        if (this.onLateUpdate) {
          this._onLateUpdate(this.onLateUpdate.bind(this));
        }
        if (this.onBeforeUpdate) {
          this._onBeforeUpdate(this.onBeforeUpdate.bind(this));
        }
        if (this.onCompute) {
          this._onCompute(this.onCompute.bind(this));
        }
        if (this.onGraphic) {
          this._onGraphic(this.onGraphic.bind(this));
        }
      }
      __stop() {
        if (this.transform && this.transform.scene3D) {
          this.onDisable?.(this.transform.view3D);
        }
        this._onUpdate(null);
        this._onLateUpdate(null);
        this._onBeforeUpdate(null);
        this._onCompute(null);
        this._onGraphic(null);
      }
      init(param) {
      }
      start() {
      }
      stop() {
      }
      /**
       *
       * clone component data to target object3D
       * @param obj target object3D
       */
      cloneTo(obj) {
      }
      copyComponent(from) {
        return this;
      }
      /**
       * internal
       * Add update function. Will be executed at every frame update.
       * @param call callback
       */
      _onUpdate(call) {
        if (call != null) {
          ComponentCollect.bindUpdate(this.transform.view3D, this, call);
        } else {
          ComponentCollect.unBindUpdate(this.transform.view3D, this);
        }
      }
      /**
       * Add a delayed update function.
       * @param call callback
       */
      _onLateUpdate(call) {
        if (call != null) {
          ComponentCollect.bindLateUpdate(this.transform.view3D, this, call);
        } else {
          ComponentCollect.unBindLateUpdate(this.transform.view3D, this);
        }
      }
      /**
       * The function executed before adding frame updates.
       * @param call callback
       */
      _onBeforeUpdate(call) {
        if (call != null) {
          ComponentCollect.bindBeforeUpdate(this.transform.view3D, this, call);
        } else {
          ComponentCollect.unBindBeforeUpdate(this.transform.view3D, this);
        }
      }
      /**
       * @internal
       * Add individual execution compute capability
       * @param call callback
       */
      _onCompute(call) {
        if (call != null) {
          ComponentCollect.bindCompute(this.transform.view3D, this, call);
        } else {
          ComponentCollect.unBindCompute(this.transform.view3D, this);
        }
      }
      /**
       * Add individual execution drawing ability
       * @param call callback
       */
      _onGraphic(call) {
        if (call != null) {
          ComponentCollect.bindGraphic(this.transform.view3D, this, call);
        } else {
          ComponentCollect.unBindGraphic(this.transform.view3D, this);
        }
      }
      /**
       * before release this component, object refrences are not be set null now.
       */
      beforeDestroy(force) {
        ComponentCollect.removeWaitStart(this.object3D, this);
      }
      /**
       * release this component
       */
      destroy(force) {
        if (this.isDestroyed)
          return;
        this.isDestroyed = true;
        this.enable = false;
        this.stop();
        this._onBeforeUpdate(null);
        this._onUpdate(null);
        this._onLateUpdate(null);
        this.onEnable = null;
        this.onDisable = null;
        this.onUpdate = null;
        this.onLateUpdate = null;
        this.onBeforeUpdate = null;
        this.onCompute = null;
        this.onGraphic = null;
      }
    }

    class HaltonSeq {
      value = 0;
      inv_base = 0;
      static get(index, radix) {
        let result = 0;
        let fraction = 1 / radix;
        while (index > 0) {
          result += index % radix * fraction;
          index /= radix;
          fraction /= radix;
        }
        return result;
      }
      getBase(index, base) {
        let f = this.inv_base = 1 / base;
        while (index > 0) {
          this.value += f * (index % base);
          index /= base;
          f *= this.inv_base;
        }
      }
      next() {
        let r = 1 - this.value - 1e-7;
        if (this.inv_base < r)
          this.value += this.inv_base;
        else {
          let h = this.inv_base, hh;
          do {
            hh = h;
            h *= this.inv_base;
          } while (h >= r);
          this.value += hh + h - 1;
        }
      }
      get() {
        return this.value;
      }
    }

    class Ray {
      /**
       * Ray starting point
       */
      origin = new Vector3();
      /**
       * length
       */
      length = Number.MAX_VALUE;
      static _rayl = 1e9;
      static _smallnum = 1e-8;
      _vector = new Vector3();
      _dir = new Vector3();
      /**
       * Build a new ray object
       * @param origin Ray starting point
       * @param dir Ray direction
       */
      constructor(origin, dir) {
        this.origin.copyFrom(origin || new Vector3());
        this._dir.copyFrom(dir || new Vector3());
        this._dir.normalize();
      }
      /**
       * Ray direction
       */
      get direction() {
        return this._dir;
      }
      set direction(dir) {
        this._dir.copyFrom(dir);
        this._dir.normalize();
      }
      /**
       * Clone a new Ray object
       * @returns 
       */
      clone() {
        return new Ray(this.origin, this.direction);
      }
      /**
       * Determine whether it intersects a bounding box
       * @param box bounding box
       * @returns whether intersect
       */
      // public intersectsBox(box: IBound): boolean {
      //     return this.intersectBox(box, this._vector) !== null;
      // }
      intersectBox(box, target) {
        let direction = this.direction;
        let origin = this.origin;
        let tMin;
        let tMax;
        let tYMin;
        let tYMax;
        let tZMin;
        let tZMax;
        const invDirX = 1 / direction.x;
        const invDirY = 1 / direction.y;
        const invDirZ = 1 / direction.z;
        const min = box.min;
        const max = box.max;
        tMin = ((invDirX >= 0 ? min.x : max.x) - origin.x) * invDirX;
        tMax = ((invDirX >= 0 ? max.x : min.x) - origin.x) * invDirX;
        tYMin = ((invDirY >= 0 ? min.y : max.y) - origin.y) * invDirY;
        tYMax = ((invDirY >= 0 ? max.y : min.y) - origin.y) * invDirY;
        if (tMin > tYMax || tYMin > tMax) {
          return null;
        }
        if (tYMin > tMin) {
          tMin = tYMin;
        }
        if (tYMax < tMax) {
          tMax = tYMax;
        }
        tZMin = ((invDirZ >= 0 ? min.z : max.z) - origin.z) * invDirZ;
        tZMax = ((invDirZ >= 0 ? max.z : min.z) - origin.z) * invDirZ;
        if (tMin > tZMax || tZMin > tMax) {
          return null;
        }
        if (tZMin > tMin) {
          tMin = tZMin;
        }
        if (tZMax < tMax) {
          tMax = tZMax;
        }
        if (tMax < 0) {
          return null;
        }
        target ||= new Vector3();
        return this.pointAt(tMin >= 0 ? tMin : tMax, target);
      }
      /**
       * Calculate a point on the ray
       * @param t Length scalar
       * @param target output target
       * @returns result
       */
      pointAt(t, target) {
        target ||= new Vector3();
        target.copy(this.direction);
        target.multiplyScalar(t);
        target.add(this.origin, target);
        return target;
      }
      /**
       * Sets the ray to be a copy of the original ray
       * @param src Ray object source
       * @returns New ray object
       */
      copy(src) {
        this.origin.copy(src.origin);
        this.direction.copy(src.direction);
        this._dir.copy(src._dir);
        this.length = src.length;
        return this;
      }
      /**
       * Fast to the approximate ray direction
       * @param dir direction
       */
      setApproxDirection(dir) {
        this._dir = dir.normalize();
      }
      /**
       * Set ray origin
       * @param origin ray origin
       */
      setOrigin(origin) {
        this.origin.copyFrom(origin);
      }
      /**
       * Get ray origin
       */
      getOrigin() {
        return this.origin;
      }
      /**
       * Gets the point at the specified position on the ray
       * @param t Length position
       * @returns Returns a point at the specified location
       */
      getPoint(t) {
        this._dir.scaleBy(t);
        return this.origin.add(this._dir);
      }
      /**
       * Calculate the distance from a point
       * @param P Specify Point
       * @returns result
       */
      sqrDistToPoint(P) {
        let v = this._dir;
        let w = P.subtract(this.origin);
        let c1 = dot(w, v);
        let c2 = dot(v, v);
        let b = c1 / c2;
        let Pb = this.getPoint(b);
        return sqrMagnitude(P.subtract(Pb));
      }
      /**
       * Applied matrix transformation
       * @param mat4 matrix
       */
      applyMatrix(mat4) {
        this.origin = mat4.transformPoint(this.origin);
        this._dir = mat4.transformVector(this._dir);
      }
      _v0 = new Vector3();
      _v1 = new Vector3();
      _v2 = new Vector3();
      /**
       * Calculates whether a specified point is inside a triangle
       * @param P point
       * @param A Triangle vertex 1
       * @param B Triangle vertex 2
       * @param C Triangle vertex 3
       * @returns whether it is inside a triangle
       */
      pointInTriangle(P, A, B, C) {
        let v0 = this._v0;
        let v1 = this._v1;
        let v2 = this._v2;
        C.subtract(A, v0);
        B.subtract(A, v1);
        P.subtract(A, v2);
        let dot00 = Vector3.dot(v0, v0);
        let dot01 = Vector3.dot(v0, v1);
        let dot02 = Vector3.dot(v0, v2);
        let dot11 = Vector3.dot(v1, v1);
        let dot12 = Vector3.dot(v1, v2);
        let invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        let u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        let v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return u >= 0 && v >= 0 && u + v < 1;
      }
      // Determine whether a ray intersect with a triangle
      // Parameters
      // orig: origin of the ray
      // dir: direction of the ray
      // v0, v1, v2: vertices of triangle
      // t(out): weight of the intersection for the ray
      // u(out), v(out): barycentric coordinate of intersection
      _E1 = new Vector3();
      _E2 = new Vector3();
      _P = new Vector3();
      _T = new Vector3();
      _Q = new Vector3();
      /**
       * Determine whether a ray intersects a triangle
       * @param orig Ray starting point
       * @param dir Ray direction
       * @param face triangle
       * @returns point of intersection
       */
      intersectTriangle(orig, dir, face) {
        let v0 = face.v1;
        let v1 = face.v2;
        let v2 = face.v3;
        v1.subtract(v0, this._E1);
        v2.subtract(v0, this._E2);
        dir.crossProduct(this._E2, this._P);
        let det = this._E1.dotProduct(this._P);
        if (det > 0) {
          orig.subtract(v0, this._T);
        } else {
          v0.subtract(orig, this._T);
          det = -det;
        }
        if (det < 1e-4)
          return null;
        face.u = this._T.dotProduct(this._P);
        if (face.u < 0 || face.u > det)
          return null;
        this._T.crossProduct(this._E1, this._Q);
        face.v = dir.dotProduct(this._Q);
        if (face.v < 0 || face.u + face.v > det)
          return null;
        let hit = new Vector3();
        face.t0 = face.t = this._E2.dotProduct(this._Q);
        let fInvDet = 1 / det;
        face.t *= fInvDet;
        face.u *= fInvDet;
        face.v *= fInvDet;
        hit.x = orig.x + face.t * dir.x;
        hit.y = orig.y + face.t * dir.y;
        hit.z = orig.z + face.t * dir.z;
        return hit;
      }
      /**
       * Determine whether a ray intersects the sphere
       * @param o Ray starting point
       * @param dir Ray direction
       * @param center Sphere center
       * @param radius radius of sphericity
       * @returns point of intersection
       */
      intersectSphere(o, dir, center, radius) {
        let oc = o.subtract(center);
        let a = Vector3.dot(dir, dir);
        let b = 2 * Vector3.dot(oc, dir);
        let c = Vector3.dot(oc, oc) - radius * radius;
        let dt = b * b - 4 * a * c;
        let hit = Vector3.HELP_3;
        if (dt < 0) {
          return null;
        } else {
          let t0 = (-b - Math.sqrt(dt)) / (a * 2);
          if (t0 < 0) {
            return null;
          }
          hit.x = o.x + t0 * dir.x;
          hit.y = o.y + t0 * dir.y;
          hit.z = o.z + t0 * dir.z;
          return hit;
        }
      }
      /**
       * A test of the intersection between a ray and 
       * a given line segment within a given tolerance (threshold)
       * @param sega The first point of a line segment used to test the intersection
       * @param segb The second point of a line segment used to test the intersection
       * @param threshold Margin, if the ray does not intersect the line segment but is close to the given threshold, the intersection is successful
       * @return If there is an intersection, then the distance from the ray origin to the intersection, if there is no intersection, is -1
       */
      intersectionSegment(sega, segb, threshold) {
        const o = this.origin;
        const u = Vector3.HELP_0;
        const rsegb = Vector3.HELP_1;
        const v = Vector3.HELP_2;
        const w = Vector3.HELP_3;
        segb.subtract(sega, u);
        this._dir.scaleToRef(Ray._rayl, v);
        o.add(v, rsegb);
        sega.subtract(o, w);
        var a = Vector3.dot(u, u);
        var b = Vector3.dot(u, v);
        var c = Vector3.dot(v, v);
        var d = Vector3.dot(u, w);
        var e = Vector3.dot(v, w);
        var det = a * c - b * b;
        var sc, sN, sD = det;
        var tc, tN, tD = det;
        if (det < Ray._smallnum) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0) {
            sN = 0;
          } else if (-d > a) {
            sN = sD;
          } else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0) {
            sN = 0;
          } else if (-d + b > a) {
            sN = sD;
          } else {
            sN = -d + b;
            sD = a;
          }
        }
        sc = Math.abs(sN) < Ray._smallnum ? 0 : sN / sD;
        tc = Math.abs(tN) < Ray._smallnum ? 0 : tN / tD;
        const qtc = Vector3.HELP_4;
        v.scaleToRef(tc, qtc);
        const qsc = Vector3.HELP_5;
        u.scaleToRef(sc, qsc);
        qsc.add(w, qsc);
        const dP = Vector3.HELP_6;
        qsc.subtract(qtc, dP);
        var isIntersected = tc > 0 && tc <= this._dir.length && dP.lengthSquared < threshold * threshold;
        if (isIntersected) {
          let dd0 = new Vector3();
          dd0.copyFrom(segb.subtract(sega));
          dd0.scaleBy(sc);
          dd0.add(sega, dd0);
          return { out: dd0, length: qsc.length };
        }
        return { out: null, length: -1 };
      }
      get_vec(p, q) {
        let rc = Vector3.HELP_1;
        rc.x = p.x - q.x;
        rc.y = p.y - q.y;
        rc.z = p.z - q.z;
        return rc;
      }
    }

    class Rect {
      /**
       * The x-coordinate of the rectangle
       */
      x;
      /**
       * The y-coordinate of the rectangle
       */
      y;
      /**
       * Width of a rectangle
       */
      w;
      /**
       * Height of rectangle
       */
      h;
      /**
       * Creates a new rectangular area object
       * @param x The x-coordinate of the rectangle
       * @param y The y coordinate of the rectangle
       * @param width Width of a rectangle
       * @param height Height of rectangle
       */
      constructor(x = 0, y = 0, width = 0, height = 0) {
        this.x = x;
        this.y = y;
        this.w = width;
        this.h = height;
      }
      /**
       * Width of a rectangle
       */
      get width() {
        return this.w;
      }
      set width(v) {
        this.w = v;
      }
      /**
       * Height of rectangle
       */
      get height() {
        return this.h;
      }
      set height(v) {
        this.h = v;
      }
      /**
       * Whether the point is within the specified area
       * @param x x value of point
       * @param y y value of point
       * @param lt_x The x value in the upper left corner
       * @param lt_y The y value in the upper left corner
       * @param rb_x The x value in the lower right corner
       * @param rb_y The y value in the lower right corner
       * @returns 
       */
      static pointInRect(x, y, lt_x, lt_y, rb_x, rb_y) {
        if (x < lt_x || x > rb_x || y < lt_y || y > rb_y) {
          return false;
        }
        return true;
      }
      /**
       * Returns a new rectangular area object with the same properties as the current rectangular area
       * @returns 
       */
      clone() {
        return new Rect(this.x, this.y, this.w, this.h);
      }
      /**
       * Copy the properties of the source object to this object
       * @param v source object
       * @returns 
       */
      copyFrom(rect) {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
      }
      /**
       * Copy the properties of this object to the target object
       * @param v target object
       * @returns 
       */
      copyTo(rect) {
        rect.copyFrom(this);
      }
      /**
       * Whether the point is in this area
       * @param x x value of point
       * @param y y value of point
       * @returns 
       */
      inner(x, y) {
        if (x < this.x || x > this.x + this.width || y < this.y || y > this.y + this.height) {
          return false;
        }
        return true;
      }
      /**
       * Whether the current rectangle is equal to the target rectangle
       * @param rectangle Target rectangle
       * @returns 
       */
      equal(rectangle) {
        return !(this.x != rectangle.x || this.y != rectangle.y || this.width != rectangle.width || this.height != rectangle.height);
      }
      /**
       * Whether the current rectangle is equal to the target rectangle
       * @param x The x value of the rectangle
       * @param y The y value of the rectangle
       * @param width Rectangle width
       * @param height Rectangular height
       * @returns 
       */
      equalArea(x, y, width, height) {
        return !(this.x != x || this.y != y || this.width != width || this.height != height);
      }
      /**
       * Whether this rectangle overlaps with the target object
       * @param source Source object
       * @returns 
       */
      equalInnerArea(source) {
        var aMinX = this.x;
        var aMinY = this.y;
        var aMaxX = this.x + this.width;
        var aMaxY = this.y + this.height;
        var bMinX = source.x;
        var bMinY = source.y;
        var bMaxX = source.x + source.width;
        var bMaxY = source.y + source.height;
        if (Math.max(aMinX, bMinX) <= Math.min(aMaxX, bMaxX) && Math.max(aMinY, bMinY) <= Math.min(aMaxY, bMaxY)) {
          return true;
        }
        return false;
      }
      /**
       * Returns the overlap of two rectangles
       * @param source source object
       * @param target target object
       * @returns 
       */
      innerArea(source, target) {
        target = target || new Rect();
        var Xa1 = this.x;
        var Ya1 = this.y;
        var Xa2 = this.x + this.width;
        var Ya2 = this.y + this.height;
        var Xb1 = source.x;
        var Yb1 = source.y;
        var Xb2 = source.x + source.width;
        var Yb2 = source.y + source.height;
        var top = Math.max(Ya1, Yb1);
        var bottom = Math.min(Ya2, Yb2);
        var left = Math.max(Xa1, Xb1);
        var right = Math.min(Xb2, Xa2);
        if (top >= 0 && bottom >= 0 && bottom - top >= 0 && right - left > 0) {
          target.x = left;
          target.y = top;
          target.width = right - left;
          target.height = bottom - top;
        } else {
          target.x = 0;
          target.y = 0;
          target.width = 0;
          target.height = 0;
        }
        return target;
      }
      /**
       * Sets the properties of the rectangle
       * @param x x value
       * @param y y value
       * @param width Rectangle width
       * @param height Rectangular height
       */
      setTo(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
    }

    class BoundingBox {
      /**
       * The center of the bounding box.
       */
      center;
      /**
       *
       * The range of the bounding box. This is always half the size of these Bounds.
       */
      extents;
      /**
       *
       *  The maximum point of the box body. This always equals center+extensions.
       */
      max;
      /**
       *
       *  The minimum point of the box body. This always equals center extensions.
       */
      min;
      /**
       *
       * The total size of the box. This is always twice as much as extensions.
       */
      size;
      static maxVector3 = new Vector3(1, 1, 1).multiplyScalar(Number.MAX_VALUE * 0.1);
      static minVector3 = new Vector3(1, 1, 1).multiplyScalar(-Number.MAX_VALUE * 0.1);
      /**
       *
       * Create a new Bounds.
       * @param center the center of the box.
       * @param size The size of the box.
       */
      constructor(center, size) {
        center ||= Vector3.ZERO.clone();
        size ||= Vector3.ZERO.clone();
        this.setFromCenterAndSize(center, size);
      }
      makeEmpty() {
        this.setFromMinMax(BoundingBox.maxVector3, BoundingBox.minVector3);
        return this;
      }
      setFromMinMax(min, max) {
        this.init();
        max.subtract(min, this.size);
        min.add(max, this.center).multiplyScalar(0.5);
        this.extents.copyFrom(this.size).multiplyScalar(0.5);
        this.min.copyFrom(min);
        this.max.copyFrom(max);
        return this;
      }
      init() {
        this.min ||= new Vector3();
        this.max ||= new Vector3();
        this.size ||= new Vector3();
        this.center ||= new Vector3();
        this.extents ||= new Vector3();
        return this;
      }
      setFromCenterAndSize(center, size) {
        this.size = size;
        this.center = center;
        this.init();
        this.extents.copy(size).multiplyScalar(0.5);
        this.center.subtract(this.extents, this.min);
        this.center.add(this.extents, this.max);
        return this;
      }
      inFrustum(obj, frustum) {
        return frustum.containsBox(obj.bound);
      }
      merge(bound) {
        if (bound.min.x < this.min.x)
          this.min.x = bound.min.x;
        if (bound.min.y < this.min.y)
          this.min.y = bound.min.y;
        if (bound.min.z < this.min.z)
          this.min.z = bound.min.z;
        if (bound.max.x > this.max.x)
          this.max.x = bound.max.x;
        if (bound.max.y > this.max.y)
          this.max.y = bound.max.y;
        if (bound.max.z > this.max.z)
          this.max.z = bound.max.z;
        this.size.x = bound.max.x - bound.min.x;
        this.size.y = bound.max.y - bound.min.y;
        this.size.z = bound.max.z - bound.min.z;
        this.extents.x = this.size.x * 0.5;
        this.extents.y = this.size.y * 0.5;
        this.extents.z = this.size.z * 0.5;
        this.center.x = this.extents.x + bound.min.x;
        this.center.y = this.extents.y + bound.min.y;
        this.center.z = this.extents.z + bound.min.z;
      }
      intersects(bounds) {
        return this.min.x <= bounds.max.x && this.max.x >= bounds.min.x && this.min.y <= bounds.max.y && this.max.y >= bounds.min.y && this.min.z <= bounds.max.z && this.max.z >= bounds.min.z;
      }
      intersectsSphere(sphere) {
        return this.min.x <= sphere.max.x && this.max.x >= sphere.min.x && this.min.y <= sphere.max.y && this.max.y >= sphere.min.y && this.min.z <= sphere.max.z && this.max.z >= sphere.min.z;
      }
      /**
       *
       * Does the target bounding box intersect with the bounding box
       * @param box
       * @returns
       */
      intersectsBox(box) {
        return this.min.x <= box.max.x && this.max.x >= box.min.x && this.min.y <= box.max.y && this.max.y >= box.min.y && this.min.z <= box.max.z && this.max.z >= box.min.z;
      }
      equals(bounds) {
        return this.center.equals(bounds.center) && this.extents.equals(bounds.extents);
      }
      expandByPoint(point) {
        if (point.x < this.min.x) {
          this.min.x = point.x;
        }
        if (point.x > this.max.x) {
          this.max.x = point.x;
        }
        if (point.y < this.min.y) {
          this.min.y = point.y;
        }
        if (point.y > this.max.y) {
          this.max.y = point.y;
        }
        if (point.z < this.min.z) {
          this.min.z = point.z;
        }
        if (point.z > this.max.z) {
          this.max.z = point.z;
        }
      }
      static fromPoints(points) {
        var bounds = new BoundingBox(new Vector3(), new Vector3());
        for (var i = 0; i < points.length; i++) {
          bounds.expandByPoint(points[i]);
        }
        return bounds;
      }
      calculateTransform(obj) {
      }
      clone() {
        var bound = new BoundingBox(this.center.clone(), this.size.clone());
        return bound;
      }
      intersectsRay(ray, point) {
        throw new Error("Method not implemented.");
      }
      containsPoint(point) {
        return this.min.x <= point.x && this.max.x >= point.x && this.min.y <= point.y && this.max.y >= point.y && this.min.z <= point.z && this.max.z >= point.z;
      }
      containsBox(box) {
        let min = this.min;
        let max = this.max;
        let isContain = min.x <= box.min.x && min.y <= box.min.y && min.z <= box.min.z && (max.x >= box.max.x && max.y >= box.max.y && max.z >= box.max.z);
        return isContain;
      }
      updateBound() {
      }
      destroy(force) {
        this.center = null;
        this.extents = null;
        this.min = null;
        this.max = null;
        this.size = null;
      }
    }

    class Frustum {
      planes;
      corners;
      boundingBox = new BoundingBox();
      constructor() {
        this.planes = [];
        this.corners = [];
        for (var i = 0; i < 6; i++)
          this.planes[i] = new Vector3();
        for (var i = 0; i < 2 * 2 * 2; i++)
          this.corners[i] = new Vector3();
      }
      updateBoundBox(pvInv) {
        this.boundingBox.makeEmpty();
        let min = this.boundingBox.min;
        let max = this.boundingBox.max;
        let i = 0;
        for (let x = 0; x < 2; ++x) {
          for (let y = 0; y < 2; ++y) {
            for (let z = 0; z < 2; ++z) {
              let pt = this.corners[i];
              i++;
              pt.set(2 * x - 1, 2 * y - 1, z, 1);
              pvInv.transformVector4(pt, pt);
              pt.div(pt.w, pt);
              min.x = Math.min(pt.x, min.x);
              min.y = Math.min(pt.y, min.y);
              min.z = Math.min(pt.z, min.z);
              max.x = Math.max(pt.x, max.x);
              max.y = Math.max(pt.y, max.y);
              max.z = Math.max(pt.z, max.z);
            }
          }
        }
        this.boundingBox.setFromMinMax(min, max);
        return this;
      }
      setFrustumCorners(pvInv) {
        let i = 0;
        for (let x = 0; x < 2; ++x) {
          for (let y = 0; y < 2; ++y) {
            for (let z = 0; z < 2; ++z) {
              let pt = this.corners[i];
              pt.set(2 * x - 1, 2 * y - 1, z, 1);
              pvInv.transformVector4(pt, pt);
              pt.div(pt.w, pt);
              i++;
            }
          }
        }
      }
      update(vpMatrix) {
        var vpm = vpMatrix.rawData;
        this.planes[0].x = vpm[3] - vpm[0];
        this.planes[0].y = vpm[7] - vpm[4];
        this.planes[0].z = vpm[11] - vpm[8];
        this.planes[0].w = vpm[15] - vpm[12];
        var t = Math.sqrt(this.planes[0].x * this.planes[0].x + this.planes[0].y * this.planes[0].y + this.planes[0].z * this.planes[0].z);
        this.planes[0].x /= t;
        this.planes[0].y /= t;
        this.planes[0].z /= t;
        this.planes[0].w /= t;
        this.planes[1].x = vpm[3] + vpm[0];
        this.planes[1].y = vpm[7] + vpm[4];
        this.planes[1].z = vpm[11] + vpm[8];
        this.planes[1].w = vpm[15] + vpm[12];
        t = Math.sqrt(this.planes[1].x * this.planes[1].x + this.planes[1].y * this.planes[1].y + this.planes[1].z * this.planes[1].z);
        this.planes[1].x /= t;
        this.planes[1].y /= t;
        this.planes[1].z /= t;
        this.planes[1].w /= t;
        this.planes[2].x = vpm[3] + vpm[1];
        this.planes[2].y = vpm[7] + vpm[5];
        this.planes[2].z = vpm[11] + vpm[9];
        this.planes[2].w = vpm[15] + vpm[13];
        t = Math.sqrt(this.planes[2].x * this.planes[2].x + this.planes[2].y * this.planes[2].y + this.planes[2].z * this.planes[2].z);
        this.planes[2].x /= t;
        this.planes[2].y /= t;
        this.planes[2].z /= t;
        this.planes[2].w /= t;
        this.planes[3].x = vpm[3] - vpm[1];
        this.planes[3].y = vpm[7] - vpm[5];
        this.planes[3].z = vpm[11] - vpm[9];
        this.planes[3].w = vpm[15] - vpm[13];
        t = Math.sqrt(this.planes[3].x * this.planes[3].x + this.planes[3].y * this.planes[3].y + this.planes[3].z * this.planes[3].z);
        this.planes[3].x /= t;
        this.planes[3].y /= t;
        this.planes[3].z /= t;
        this.planes[3].w /= t;
        this.planes[4].x = vpm[3] - vpm[2];
        this.planes[4].y = vpm[7] - vpm[6];
        this.planes[4].z = vpm[11] - vpm[10];
        this.planes[4].w = vpm[15] - vpm[14];
        t = Math.sqrt(this.planes[4].x * this.planes[4].x + this.planes[4].y * this.planes[4].y + this.planes[4].z * this.planes[4].z);
        this.planes[4].x /= t;
        this.planes[4].y /= t;
        this.planes[4].z /= t;
        this.planes[4].w /= t;
        this.planes[5].x = vpm[3] + vpm[2];
        this.planes[5].y = vpm[7] + vpm[6];
        this.planes[5].z = vpm[11] + vpm[10];
        this.planes[5].w = vpm[15] + vpm[14];
        t = Math.sqrt(this.planes[5].x * this.planes[5].x + this.planes[5].y * this.planes[5].y + this.planes[5].z * this.planes[5].z);
        this.planes[5].x /= t;
        this.planes[5].y /= t;
        this.planes[5].z /= t;
        this.planes[5].w /= t;
      }
      containsPoint(point) {
        for (var p = 0; p < 6; p++) {
          if (this.planes[p].x * point.x + this.planes[p].y * point.y + this.planes[p].z * point.z + this.planes[p].w <= 0)
            return false;
        }
        return true;
      }
      containsSphere(object3D) {
        let sphere = object3D.bound;
        let c = 0;
        let d;
        let worldPos = object3D.transform.worldPosition;
        let sr = sphere.radius;
        let scx = sphere.center.x + worldPos.x;
        let scy = sphere.center.y + worldPos.y;
        let scz = sphere.center.z + worldPos.z;
        for (let plane of this.planes) {
          d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
          if (d <= -sr)
            return 0;
          if (d > sr)
            c++;
        }
        return c === 6 ? 2 : 1;
      }
      containsBox(box) {
        let c = 0;
        let d;
        let r = Math.max(box.size.x, box.size.y, box.size.z);
        let sr = r * 2;
        let scx = box.center.x;
        let scy = box.center.y;
        let scz = box.center.z;
        for (let plane of this.planes) {
          d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
          if (d <= -sr)
            return 0;
          if (d > sr)
            c++;
        }
        return c === 6 ? 2 : 1;
      }
      containsBox2(box) {
        let c = 0;
        let d;
        let r = 1.74 * Math.max(box.extents.x, box.extents.y, box.extents.z);
        for (let plane of this.planes) {
          d = plane.x * box.center.x + plane.y * box.center.y + plane.z * box.center.z + plane.w;
          if (d <= -r)
            return 0;
          if (d > r)
            c++;
        }
        return c === 6 ? 2 : 1;
      }
    }

    var CameraType = /* @__PURE__ */ ((CameraType2) => {
      CameraType2[CameraType2["ortho"] = 0] = "ortho";
      CameraType2[CameraType2["perspective"] = 1] = "perspective";
      CameraType2[CameraType2["shadow"] = 2] = "shadow";
      return CameraType2;
    })(CameraType || {});

    class FrustumSection {
      corners;
      index;
      constructor(index) {
        this.index = index;
        this.corners = [];
        for (let i = 0; i < 4; i++) {
          this.corners.push(new Vector3());
        }
      }
    }
    class FrustumChild {
      bound;
      twoSections;
      name;
      color;
      shadowCamera;
      index;
      constructor(near, far, index) {
        this.bound = new BoundingBox();
        this.shadowCamera = CameraUtil.createCamera3DObject(null, "csmShadowCamera_" + index);
        this.shadowCamera.isShadowCamera = true;
        this.shadowCamera.orthoOffCenter(100, -100, 100, -100, 1, 1e4);
        this.twoSections = [near, far];
        this.index = index;
        if (index == 0) {
          this.color = new Color(1, 0, 0, 1);
        } else if (index == 1) {
          this.color = new Color(0, 1, 0, 1);
        } else if (index == 2) {
          this.color = new Color(0, 0, 1, 1);
        } else if (index == 3) {
          this.color = new Color(0, 1, 1, 1);
        }
        this.name = "child_" + index;
      }
      updateBound() {
        this.bound.makeEmpty();
        let min = this.bound.min;
        let max = this.bound.max;
        for (let section of this.twoSections) {
          for (let pt of section.corners) {
            min.x = Math.min(pt.x, min.x);
            min.y = Math.min(pt.y, min.y);
            min.z = Math.min(pt.z, min.z);
            max.x = Math.max(pt.x, max.x);
            max.y = Math.max(pt.y, max.y);
            max.z = Math.max(pt.z, max.z);
          }
        }
        this.bound.setFromMinMax(min, max);
        return this;
      }
    }
    class FrustumCSM {
      sections;
      children;
      name;
      constructor(blockCount) {
        this.sections = [];
        let sectionCount = blockCount + 1;
        for (let i = 0; i < sectionCount; i++) {
          this.sections.push(new FrustumSection(i));
        }
        this.children = [];
        for (let i = 0; i < blockCount; i++) {
          this.children.push(new FrustumChild(this.sections[i], this.sections[i + 1], i));
        }
      }
      update(p, pvInv, near, far, shadowSetting) {
        let blockCount = this.sections.length - 1;
        for (let z = 0; z <= blockCount; ++z) {
          let section = this.sections[z];
          let cornerIndex = 0;
          let worldZ = this.logSplit(near, far, z, this.sections.length);
          {
            let scale = (worldZ - near) / far;
            scale = scale ** shadowSetting.csmScatteringExp;
            worldZ = (far - near) * scale + near;
          }
          worldZ *= shadowSetting.csmAreaScale;
          let depth = (p.rawData[10] * worldZ + p.rawData[14]) / worldZ;
          for (let x = 0; x < 2; ++x) {
            for (let y = 0; y < 2; ++y) {
              let pt = section.corners[cornerIndex];
              cornerIndex++;
              pt.set(2 * x - 1, 2 * y - 1, depth, 1);
              pvInv.transformVector4(pt, pt);
              pt.div(pt.w, pt);
            }
          }
        }
        for (let miniFrustum of this.children) {
          miniFrustum.updateBound();
        }
        return this;
      }
      squareSplit(near, far, index, max) {
        let ratio = index / (max - 1);
        return ratio ** 4 * (far - near) + near;
      }
      uniformSplit(near, far, index, max) {
        let ratio = index / (max - 1);
        return ratio * (far - near) + near;
      }
      logSplit(near, far, index, max) {
        let ratio = near * (far / near) ** (index / (max - 1));
        return ratio;
      }
    }

    class Camera3D extends ComponentBase {
      /**
       * camera Perspective
       */
      fov = 1;
      /**
       * camera use name
       */
      name;
      /**
       * Viewport width and height Scale
       */
      aspect = 1;
      /**
       * camera near plane
       */
      near = 1;
      /**
       * camera far plane
       */
      far = 5e3;
      /**
       * camera view port size
       */
      viewPort = new Rect();
      /**
       * camera frustum
       */
      frustum;
      /**
       * this camera is shadow camera
       */
      isShadowCamera = false;
      /**
      * @internal
      */
      _projectionMatrixInv = new Matrix4();
      _projectionMatrix = new Matrix4();
      _viewMatrix = new Matrix4();
      _unprojection = new Matrix4();
      _pvMatrixInv = new Matrix4();
      _pvMatrix = new Matrix4();
      _halfw;
      _halfh;
      _ray;
      _enableCSM = false;
      /**
       * @internal
       */
      get projectionMatrix() {
        return this._projectionMatrix;
      }
      /**
       * camera look at from where point
       */
      lookTarget;
      /**
       * camera type 
       */
      type = CameraType.perspective;
      csm;
      /**
       * @internal
       */
      cubeShadowCameras = [];
      get enableCSM() {
        return this._enableCSM;
      }
      set enableCSM(value) {
        if (value && !this.csm) {
          this.csm = new FrustumCSM(CSM.Cascades);
        }
        this._enableCSM = value;
      }
      constructor() {
        super();
      }
      init() {
        super.init();
        this._ray = new Ray();
        this.frustum = new Frustum();
        this.viewPort.x = 0;
        this.viewPort.y = 0;
        this.viewPort.w = webGPUContext.presentationSize[0];
        this.viewPort.h = webGPUContext.presentationSize[1];
        this.lookTarget = new Vector3(0, 0, 0);
      }
      getShadowBias(depthTexSize) {
        let sizeOnePixel = 2 * this.getShadowWorldExtents() / depthTexSize;
        let depth = this.far - this.near;
        return sizeOnePixel / depth - Engine3D.setting.shadow.shadowBias * 0.01;
      }
      getShadowWorldExtents() {
        let shadowBound = Engine3D.setting.shadow.shadowBound;
        if (!shadowBound) {
          shadowBound = Math.round(0.05 * this.frustum.boundingBox.extents.length);
        } else {
          shadowBound *= 0.5;
        }
        return shadowBound;
      }
      getCSMShadowBias(index, depthTexSize) {
        let sizeOnePixel = 2 * this.getCSMShadowWorldExtents(index) / depthTexSize;
        let depth = this.far - this.near;
        return sizeOnePixel / depth;
      }
      getCSMShadowWorldExtents(index) {
        return Math.round(this.csm.children[index].bound.extents.length);
      }
      /**
       * Create a perspective camera
       * @param fov 
       * @param aspect 
       * @param near  
       * @param far 
       */
      perspective(fov, aspect, near, far) {
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this._projectionMatrix.perspective(fov, aspect, near, far);
        this.type = CameraType.perspective;
      }
      resetPerspective(aspect) {
        if (this.type == CameraType.perspective) {
          this._projectionMatrix.perspective(this.fov, aspect, this.near, this.far);
        }
      }
      /**
       * Create an orthographic camera
       * @param width screen width
       * @param height screen height
       * @param znear camera near plane
       * @param zfar camera far plane
       */
      ortho(width, height, znear, zfar) {
        this.near = Math.max(znear, 0.1);
        this.far = zfar;
        this._projectionMatrix.ortho(width, height, znear, zfar);
        this.type = CameraType.ortho;
      }
      /**
       *
       * Create an orthographic camera
       * @param l 
       * @param r 
       * @param b 
       * @param t 
       * @param zn camera near plane
       * @param zf camera far plane
       */
      orthoOffCenter(l, r, b, t, zn, zf) {
        this.near = Math.max(zn, 0.01);
        this.far = zf;
        this._projectionMatrix.orthoOffCenter(l, r, b, t, zn, zf);
        this.type = CameraType.ortho;
      }
      orthoZo(l, r, b, t, zn, zf) {
        this.near = Math.max(zn, 0.01);
        this.far = zf;
        this._projectionMatrix.orthoZO(l, r, b, t, zn, zf);
        this.type = CameraType.ortho;
      }
      /**
       *
       * view invert matrix
       */
      get viewMatrix() {
        this._viewMatrix.copyFrom(this.transform.worldMatrix);
        this._viewMatrix.invert();
        return this._viewMatrix;
      }
      /**
       *
       * shadow camera view invert matrix
       */
      get shadowViewMatrix() {
        this._viewMatrix.copyFrom(this.transform.worldMatrix);
        this._viewMatrix.appendScale(1, 1, 1);
        this._viewMatrix.invert();
        return this._viewMatrix;
      }
      /**
       * world space object to screen 
       * @param n world space
       * @param target Creating an orthogonal camera with 2D screen coordinates that default to null will return a new object
       */
      object3DToScreenRay(n, target = null) {
        if (!target) {
          target = new Vector3(0, 0, 0, 1);
        }
        this._halfw = this.viewPort.width * 0.5;
        this._halfh = this.viewPort.height * 0.5;
        MathUtil.transformVector(this.viewMatrix, n, target);
        this.project(target, target);
        target.x = this._halfw + target.x * this._halfw;
        target.y = this.viewPort.height - (this._halfh - target.y * this._halfh);
        return target;
      }
      /**
       * Convert 2D screen coordinates to 3D coordinates as world space
       * @param n 2D screen coordinates
       * @param target 3D coordinates as world space
       */
      screenRayToObject3D(n, target = null) {
        if (!target) {
          target = new Vector3();
        }
        this._halfw = this.viewPort.width * 0.5;
        this._halfh = this.viewPort.height * 0.5;
        let fScreenPtX = n.x;
        let fScreenPtY = n.y;
        target.x = fScreenPtX / this.viewPort.width - 0.25;
        target.y = fScreenPtY / this.viewPort.height - 0.25;
        this.unProject(target.x, target.y, n.z, target);
        return target;
      }
      /**
       * get project * view matrix
       */
      get pvMatrix() {
        matrixMultiply(this._projectionMatrix, this.viewMatrix, this._pvMatrix);
        return this._pvMatrix;
      }
      get pvMatrix2() {
        matrixMultiply(this._projectionMatrix, this.transform.worldMatrix, this._pvMatrix);
        let matrix = this._pvMatrixInv.copyFrom(this.pvMatrix);
        matrix.invert();
        return matrix;
      }
      /**
       * get (project * view) invert matrix
       */
      get pvMatrixInv() {
        let matrix = this._pvMatrixInv.copyFrom(this.pvMatrix);
        matrix.invert();
        return matrix;
      }
      /**
       * get project invert matrix
       */
      get projectionMatrixInv() {
        this._projectionMatrixInv.copyFrom(this._projectionMatrix);
        this._projectionMatrixInv.invert();
        return this._projectionMatrixInv;
      }
      /**
       * Enter a 3D coordinate point to obtain the projected coordinate point
       * @param nX 3D x
       * @param nY 3D y
       * @param sZ 3D z
       * @param target The projected coordinate point can be empty
       * @returns Coordinates after projection
       */
      unProject(nX, nY, sZ, target) {
        if (!target)
          target = new Vector3();
        target.x = nX;
        target.y = -nY;
        target.z = sZ;
        target.w = 1;
        target.x *= sZ;
        target.y *= sZ;
        this._unprojection.copyFrom(this._projectionMatrix);
        this._unprojection.invert();
        MathUtil.transformVector(this._unprojection, target, target);
        target.z = sZ;
        return target;
      }
      /**
       * Enter the projected coordinate points to obtain a 3D coordinate point.
       * @param n Coordinate points after photography
       * @param target 3D coordinate points
       * @returns 3D coordinate points
       */
      project(n, target) {
        this._projectionMatrix.perspectiveMultiplyPoint3(n, target);
        target.x = target.x / target.w;
        target.y = -target.y / target.w;
        target.z = n.z;
        return target;
      }
      /**
       * Enter the 2D coordinates of the screen to obtain a ray that starts from the camera position and passes through the corresponding 3D position of the screen.
       * @param viewPortPosX Screen x coordinate
       * @param viewPortPosY Screen y coordinate
       * @returns ray
       */
      screenPointToRay(viewPortPosX, viewPortPosY) {
        let ray = this._ray;
        let start = CameraUtil.UnProjection(viewPortPosX, viewPortPosY, 0.01, this);
        let end = CameraUtil.UnProjection(viewPortPosX, viewPortPosY, 1, this);
        end = end.subtract(start).normalize();
        ray.origin.copyFrom(start);
        ray.direction = end;
        return ray;
      }
      /**
       * Convert screen coordinates to world coordinates
       * @param viewPortPosX Screen x coordinate
       * @param viewPortPosY Screen y coordinate
       * @param z Screen z coordinate
       * @returns World coordinates
       */
      screenPointToWorld(viewPortPosX, viewPortPosY, z) {
        let pos = CameraUtil.UnProjection(viewPortPosX, viewPortPosY, z, this);
        return pos;
      }
      /**
       * Convert world coordinates to screen coordinates
       * @param viewPortPosX Screen x coordinate
       * @param viewPortPosY Screen y coordinate
       * @param z Screen z coordinate
       * @returns World coordinates
       */
      worldToScreenPoint(point, target) {
        let pos = CameraUtil.Projection(point, this, target);
        return pos;
      }
      /**
       * Current object's gaze position (global) (modified by its own global transformation)
       * @param pos Own position (global)
       * @param target Location of the target (global)
       * @param up Upward direction
       */
      lookAt(pos, target, up = Vector3.Y_AXIS) {
        this.transform.lookAt(pos, target, up);
        if (target)
          this.lookTarget.copyFrom(target);
      }
      /**
       * @internal
       */
      resetProjectMatrix() {
        this.perspective(this.fov, this.aspect, this.near, this.far);
      }
      /**
       * @internal
       */
      onUpdate() {
        if (this.type == CameraType.perspective) {
          this.aspect = webGPUContext.aspect;
          this.resetProjectMatrix();
        }
        if (this._useJitterProjection) {
          this.getJitteredProjectionMatrix();
        }
        this.frustum.update(this.pvMatrix);
        this.frustum.updateBoundBox(this.pvMatrixInv);
        let shadow = Engine3D.setting.shadow;
        this.enableCSM && this.csm?.update(this._projectionMatrix, this._pvMatrixInv, this.near, this.far, shadow);
      }
      _haltonSeq;
      _jitterOffsetList;
      _useJitterProjection = false;
      _jitterFrameIndex = 0;
      _sampleIndex = 0;
      _jitterX = 0;
      _jitterY = 0;
      get jitterFrameIndex() {
        return this._jitterFrameIndex;
      }
      get jitterX() {
        return this._jitterX;
      }
      get jitterY() {
        return this._jitterY;
      }
      enableJitterProjection(value) {
        this._jitterFrameIndex = 0;
        this._useJitterProjection = value;
        this._haltonSeq ||= new HaltonSeq();
        this._jitterOffsetList = [];
        for (let i = 0; i < 8; i++) {
          let offset = this.generateRandomOffset();
          this._jitterOffsetList.push(offset);
        }
        this._jitterOffsetList.reverse();
      }
      generateRandomOffset() {
        let offset = new Vector2(HaltonSeq.get((this._sampleIndex & 1023) + 1, 2) - 0.5, HaltonSeq.get((this._sampleIndex & 1023) + 1, 3) - 0.5);
        const k_SampleCount = 8;
        if (++this._sampleIndex >= k_SampleCount)
          this._sampleIndex = 0;
        return offset;
      }
      getJitteredProjectionMatrix() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        let mat = this._projectionMatrix;
        let temporalJitterScale = setting.temporalJitterScale;
        let offsetIndex = this._jitterFrameIndex % setting.jitterSeedCount;
        let num1 = this._jitterOffsetList[offsetIndex].x * temporalJitterScale;
        let num2 = this._jitterOffsetList[offsetIndex].y * temporalJitterScale;
        let jitX = mat.get(0, 2);
        let jitY = mat.get(1, 2);
        this._jitterX = num1 / this.viewPort.width;
        this._jitterY = num2 / this.viewPort.height;
        jitX += this._jitterX;
        jitY += this._jitterY;
        mat.set(0, 2, jitX);
        mat.set(1, 2, jitY);
        this._jitterFrameIndex++;
      }
      // /**
      //  *
      //  * @param shadowCamera
      //  * @param lightDir
      //  */
      // public getCastShadowLightSpaceMatrix(shadowCamera: Camera3D, lightDir: Vector3) {
      //     let frustum: Frustum = this.frustum;
      //     let proMat = this.projectionMatrixInv;
      //     let wMat = this.transform.worldMatrix;
      //     Matrix4.helpMatrix.copyFrom(proMat);
      //     Matrix4.helpMatrix.multiply(wMat);
      //     frustum.setFrustumCorners(Matrix4.helpMatrix);
      //     let corners = frustum.corners;
      //     let center = Vector3.HELP_6;
      //     center.set(0, 0, 0);
      //     for (const iterator of corners) {
      //         center.add(iterator, center);
      //     }
      //     center.div(corners.length, center);
      //     let lookTarget = Vector3.HELP_5;
      //     lookTarget.copyFrom(center);
      //     Vector3.HELP_0.copyFrom(lightDir);
      //     lookTarget.add(Vector3.HELP_0, lookTarget);
      //     shadowCamera.lookAt(lookTarget, center, Vector3.UP);
      //     let minX = Number.MAX_VALUE;
      //     let maxX = -Number.MAX_VALUE;
      //     let minY = Number.MAX_VALUE;
      //     let maxY = -Number.MAX_VALUE;
      //     let minZ = Number.MAX_VALUE;
      //     let maxZ = -Number.MAX_VALUE;
      //     for (const iterator of corners) {
      //         minX = Math.min(minX, iterator.x);
      //         maxX = Math.max(maxX, iterator.x);
      //         minY = Math.min(minY, iterator.y);
      //         maxY = Math.max(maxY, iterator.y);
      //         minZ = Math.min(minZ, iterator.z);
      //         maxZ = Math.max(maxZ, iterator.z);
      //     }
      //     // Tune this parameter according to the scene
      //     let zMult = Engine3D.setting.shadow.shadowQuality;
      //     if (minZ < 0) {
      //         minZ *= zMult;
      //     } else {
      //         minZ /= zMult;
      //     }
      //     if (maxZ < 0) {
      //         maxZ /= zMult;
      //     } else {
      //         maxZ *= zMult;
      //     }
      //     shadowCamera.orthoOffCenter(minX, maxX, minY, maxY, minZ, maxZ);
      // }
      getWorldDirection(target) {
        target ||= new Vector3();
        const e = this.transform._worldMatrix.rawData;
        return target.set(-e[8], -e[9], -e[10]).normalize();
      }
    }

    class Transform extends ComponentBase {
      /**
      * @internal
      */
      static LIMIT = 1;
      /**
      * @internal
      */
      static COMPONENT_NAME = "UUTransform";
      /**
      * @internal
      */
      static COMPONENT_TYPE = "Transform";
      /**
      * @internal
      */
      static POSITION_ONCHANGE = "POSITION_ONCHANGE";
      /**
      * @internal
      */
      static ROTATION_ONCHANGE = "ROTATION_ONCHANGE";
      /**
      * @internal
      */
      static SCALE_ONCHANGE = "SCALE_ONCHANGE";
      /**
      * @internal
      */
      static PARENT_ONCHANGE = "PARENT_ONCHANGE";
      /**
      * @internal
      */
      static CHILDREN_ONCHANGE = "CHILDREN_ONCHANGE";
      /**
      * @internal
      */
      static ADD_ONCHANGE = "ADD_ONCHANGE";
      /**
       * @internal
       */
      static LOCAL_ONCHANGE = "LOCAL_ONCHANGE";
      /**
      * @internal
      */
      eventPositionChange = new CEvent(Transform.POSITION_ONCHANGE);
      /**
      * @internal
      */
      eventRotationChange = new CEvent(Transform.ROTATION_ONCHANGE);
      /**
      * @internal
      */
      eventScaleChange = new CEvent(Transform.SCALE_ONCHANGE);
      /**
      * @internal
      */
      eventLocalChange = new CEvent(Transform.LOCAL_ONCHANGE);
      /**
      * @internal
      */
      onPositionChange;
      /**
      * @internal
      */
      onRotationChange;
      /**
      * @internal
      */
      onScaleChange;
      _scene3d;
      _parent;
      _localPos;
      _localRot;
      _localRotQuat;
      _localScale;
      _localDetailPos;
      _localDetailRot;
      _localDetailScale;
      index;
      index2;
      // public localMatrix: Matrix4;
      // private _localChange: boolean = true;
      _forward = new Vector3();
      _back = new Vector3();
      _right = new Vector3();
      _left = new Vector3();
      _up = new Vector3();
      _down = new Vector3();
      _worldMatrix;
      _targetPos;
      static = false;
      depthOrder = 0;
      get localChange() {
        return WasmMatrix.matrixStateBuffer[this.index2] != 0;
      }
      set localChange(value) {
        WasmMatrix.matrixStateBuffer[this.index2] = value ? 1 : 0;
      }
      get targetPos() {
        return this._targetPos;
      }
      set targetPos(value) {
        this._targetPos = value;
      }
      get parent() {
        return this._parent;
      }
      set parent(value) {
        let lastParent = this._parent?.object3D;
        this._parent = value;
        this.depthOrder = value ? value.depthOrder + 1 : 0;
        WasmMatrix.setParent(this.index, value ? value.worldMatrix.index : -1, this.depthOrder);
        this.localChange = true;
        if (this.object3D) {
          let hasRoot = value ? value.scene3D : null;
          if (!hasRoot) {
            this.object3D.components.forEach((c) => {
              c[`__stop`]();
            });
          } else {
            this._scene3d = hasRoot;
            this.object3D.components.forEach((c) => {
              ComponentCollect.appendWaitStart(c);
            });
          }
          for (let child of this.object3D.entityChildren) {
            child.transform.parent = value ? this : null;
          }
          this.object3D.components.forEach((c) => {
            c.onParentChange?.(lastParent, this._parent?.object3D);
          });
        }
        this.notifyLocalChange();
      }
      set enable(value) {
        if (this.transform._scene3d && value) {
          super.enable = true;
        } else {
          super.enable = false;
        }
        for (let child of this.object3D.entityChildren) {
          child.transform.enable = value;
        }
      }
      get enable() {
        return this._enable;
      }
      get scene3D() {
        return this._scene3d;
      }
      set scene3D(value) {
        this._scene3d = value;
      }
      get view3D() {
        if (this._scene3d && this._scene3d.view) {
          return this._scene3d.view;
        }
        return null;
      }
      constructor() {
        super();
        this._worldMatrix = new Matrix4(true);
        this.index = this._worldMatrix.index;
        this.index2 = this._worldMatrix.index * WasmMatrix.stateStruct;
        this._localPos = new Vector3();
        this._localRot = new Vector3();
        this._localRotQuat = new Quaternion();
        this._localScale = new Vector3(1, 1, 1);
        WasmMatrix.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z);
        WasmMatrix.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z);
        WasmMatrix.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z);
      }
      awake() {
      }
      start() {
      }
      stop() {
      }
      /**
      * @internal
      */
      notifyLocalChange() {
        this.localChange = true;
        if (this.object3D) {
          let entityChildren = this.object3D.entityChildren;
          let i = 0, len = entityChildren.length;
          for (i = 0; i < len; i++) {
            const transform = entityChildren[i].transform;
            transform.notifyLocalChange();
          }
        }
        this.eventDispatcher.dispatchEvent(this.eventLocalChange);
      }
      get up() {
        this.worldMatrix.transformVector(Vector3.UP, this._up);
        return this._up;
      }
      set up(value) {
        this._up.copyFrom(value);
        MathUtil.fromToRotation(Vector3.UP, this._up, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
      }
      get down() {
        this.worldMatrix.transformVector(Vector3.DOWN, this._down);
        return this._down;
      }
      set down(value) {
        this._down.copyFrom(value);
        MathUtil.fromToRotation(Vector3.DOWN, this._down, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
        this.notifyLocalChange();
        this.onRotationChange?.();
        if (this.eventRotationChange) {
          this.eventDispatcher.dispatchEvent(this.eventRotationChange);
        }
      }
      get forward() {
        this.worldMatrix.transformVector(Vector3.FORWARD, this._forward);
        return this._forward;
      }
      set forward(value) {
        this._forward.copyFrom(value);
        MathUtil.fromToRotation(Vector3.FORWARD, this._forward, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
        this.notifyLocalChange();
        this.onRotationChange?.();
        if (this.eventRotationChange) {
          this.eventDispatcher.dispatchEvent(this.eventRotationChange);
        }
      }
      get back() {
        this.worldMatrix.transformVector(Vector3.BACK, this._back);
        return this._back;
      }
      set back(value) {
        this._back.copyFrom(value);
        MathUtil.fromToRotation(Vector3.BACK, this._back, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
      }
      get left() {
        this.worldMatrix.transformVector(Vector3.neg_X_AXIS, this._left);
        return this._left;
      }
      set left(value) {
        this._left.copyFrom(value);
        MathUtil.fromToRotation(Vector3.LEFT, this._left, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
      }
      get right() {
        this.worldMatrix.transformVector(Vector3.X_AXIS, this._right);
        return this._right;
      }
      set right(value) {
        this._right.copyFrom(value);
        MathUtil.fromToRotation(Vector3.RIGHT, this._right, Quaternion.HELP_0);
        this.transform.localRotQuat = Quaternion.HELP_0;
        this.notifyLocalChange();
        this.onRotationChange?.();
        if (this.eventRotationChange) {
          this.eventDispatcher.dispatchEvent(this.eventRotationChange);
        }
      }
      /**
       *
       * The transformation property of the object relative to the parent, stored in the from of a quaternion
       */
      get localRotQuat() {
        return this._localRotQuat;
      }
      set localRotQuat(value) {
        if (value.x != this._localRotQuat.x || value.y != this._localRotQuat.y || value.z != this._localRotQuat.z || value.w != this._localRotQuat.w) {
          this._localRotQuat.copyFrom(value);
          this._localRotQuat.getEulerAngles(this._localRot);
          WasmMatrix.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z);
          this.notifyLocalChange();
          this.onRotationChange?.();
          if (this.eventRotationChange) {
            this.eventDispatcher.dispatchEvent(this.eventRotationChange);
          }
        }
      }
      /**
       * @private
       */
      notifyChange() {
        this.notifyLocalChange();
        this.onRotationChange?.();
        this.onScaleChange?.();
        this.onPositionChange?.();
        if (this.eventRotationChange) {
          this.eventDispatcher.dispatchEvent(this.eventRotationChange);
        }
        if (this.eventPositionChange) {
          this.eventDispatcher.dispatchEvent(this.eventPositionChange);
        }
        if (this.eventScaleChange) {
          this.eventDispatcher.dispatchEvent(this.eventScaleChange);
        }
      }
      /**
      * @internal
      */
      get worldMatrix() {
        this.updateWorldMatrix();
        return this._worldMatrix;
      }
      /**
       *
       * Update the matrix4 in world space
       */
      updateWorldMatrix(force = false) {
        if (this.localChange || force) {
          if (this.parent) {
            makeMatrix44(this._localRot, this._localPos, this._localScale, this._worldMatrix);
            append(this._worldMatrix, this.parent.worldMatrix, this._worldMatrix);
          } else {
            makeMatrix44(this._localRot, this._localPos, this._localScale, this._worldMatrix);
          }
          this.localChange = false;
        }
      }
      updateChildTransform() {
        let self = this;
        if (self.localChange) {
          self.updateWorldMatrix();
        }
        if (self.object3D.numChildren > 0) {
          for (const child of self.object3D.entityChildren) {
            child.transform.updateChildTransform();
          }
        }
      }
      lookTarget(target, up = Vector3.UP) {
        this.lookAt(this.transform.worldPosition, target, up);
      }
      /**
       * Current object's gaze position (global) (modified by its own global transformation)
       * @param pos Own position (global)
       * @param target Location of the target (global)
       * @param up up direction
       */
      lookAt(pos, target, up = Vector3.UP) {
        this._targetPos ||= new Vector3();
        this._targetPos.copyFrom(target);
        this.localPosition = pos;
        Matrix4.helpMatrix.lookAt(pos, target, up);
        Matrix4.helpMatrix.invert();
        var prs = Matrix4.helpMatrix.decompose(Orientation3D.QUATERNION);
        this.localRotQuat = Quaternion.CALCULATION_QUATERNION.copyFrom(prs[1]);
      }
      decomposeFromMatrix(matrix, orientationStyle = "eulerAngles") {
        let prs = matrix.decompose(orientationStyle);
        let transform = this.transform;
        transform.localRotQuat.copyFrom(prs[1]);
        transform.localRotQuat = transform.localRotQuat;
        transform.localPosition.copyFrom(prs[0]);
        transform.localPosition = transform.localPosition;
        transform.localScale.copyFrom(prs[2]);
        transform.localScale = transform.localScale;
        return this;
      }
      /**
      *
      * Create a new component, copy the properties of the current component, and add it to the target object.
      * @param obj source Object3D
      */
      cloneTo(obj) {
        obj.transform.localPosition = this.localPosition;
        obj.transform.localRotation = this.localRotation;
        obj.transform.localScale = this.localScale;
      }
      set x(value) {
        if (this._localPos.x != value) {
          this._localPos.x = value;
          WasmMatrix.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z);
          this.notifyLocalChange();
          this.onPositionChange?.();
          if (this.eventPositionChange) {
            this.eventDispatcher.dispatchEvent(this.eventPositionChange);
          }
        }
      }
      /**
       *
       * The position of the object relative to its parent X-axis
       */
      get x() {
        return this._localPos.x;
      }
      set y(value) {
        if (this._localPos.y != value) {
          this._localPos.y = value;
          WasmMatrix.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z);
          this.notifyLocalChange();
          this.onPositionChange?.();
          if (this.eventPositionChange) {
            this.eventDispatcher.dispatchEvent(this.eventPositionChange);
          }
        }
      }
      /**
       *
       * The position of the object relative to its parent Y-axis
       */
      get y() {
        return this._localPos.y;
      }
      set z(value) {
        if (this._localPos.z != value) {
          this._localPos.z = value;
          WasmMatrix.setTranslate(this.index, this._localPos.x, this._localPos.y, this._localPos.z);
          this.notifyLocalChange();
          this.onPositionChange?.();
          if (this.eventPositionChange) {
            this.eventDispatcher.dispatchEvent(this.eventPositionChange);
          }
        }
      }
      /**
       *
       * The position of the object relative to its parent Y-axis
       */
      get z() {
        return this._localPos.z;
      }
      set scaleX(value) {
        if (this._localScale.x != value) {
          this._localScale.x = value;
          WasmMatrix.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z);
          this.notifyLocalChange();
          this.onScaleChange?.();
          if (this.eventScaleChange) {
            this.eventDispatcher.dispatchEvent(this.eventScaleChange);
          }
        }
      }
      /**
       *
       * The scale of the object relative to its parent X-axis
       */
      get scaleX() {
        return this._localScale.x;
      }
      set scaleY(value) {
        if (this._localScale.y != value) {
          this._localScale.y = value;
          WasmMatrix.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z);
          this.notifyLocalChange();
          this.onScaleChange?.();
          if (this.eventScaleChange) {
            this.eventDispatcher.dispatchEvent(this.eventScaleChange);
          }
        }
      }
      /**
       *
       * The scale of the object relative to its parent Y-axis
       */
      get scaleY() {
        return this._localScale.y;
      }
      set scaleZ(value) {
        if (this._localScale.z != value) {
          this._localScale.z = value;
          WasmMatrix.setScale(this.index, this._localScale.x, this._localScale.y, this._localScale.z);
          this.notifyLocalChange();
          this.onScaleChange?.();
          if (this.eventScaleChange) {
            this.eventDispatcher.dispatchEvent(this.eventScaleChange);
          }
        }
      }
      /**
       *
       * The scale of the object relative to its parent Z-axis
       */
      get scaleZ() {
        return this._localScale.z;
      }
      set rotationX(value) {
        if (this._localRot.x != value) {
          this._localRot.x = value;
          WasmMatrix.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z);
          this.notifyLocalChange();
          this.onRotationChange?.();
          if (this.eventRotationChange) {
            this.eventDispatcher.dispatchEvent(this.eventRotationChange);
          }
        }
      }
      /**
       *
       * The rotation of the object relative to its parent X-axis
       */
      get rotationX() {
        return this._localRot.x;
      }
      set rotationY(value) {
        if (this._localRot.y != value) {
          this._localRot.y = value;
          WasmMatrix.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z);
          this.notifyLocalChange();
          this.onRotationChange?.();
          if (this.eventRotationChange) {
            this.eventDispatcher.dispatchEvent(this.eventRotationChange);
          }
        }
      }
      /**
       *
       * The rotation of the object relative to its parent Y-axis
       */
      get rotationY() {
        return this._localRot.y;
      }
      set rotationZ(value) {
        if (this._localRot.z != value) {
          this._localRot.z = value;
          WasmMatrix.setRotation(this.index, this._localRot.x, this._localRot.y, this._localRot.z);
          this.notifyLocalChange();
          this.onRotationChange?.();
          if (this.eventRotationChange) {
            this.eventDispatcher.dispatchEvent(this.eventRotationChange);
          }
        }
      }
      /**
       *
       * The rotation of the object relative to its parent Z-axis
       */
      get rotationZ() {
        return this._localRot.z;
      }
      /**
       *
       * world position
       */
      get worldPosition() {
        if (this.localChange) {
          this.updateWorldMatrix();
        }
        return this._worldMatrix.position;
      }
      set localPosition(v) {
        this._localPos.copyFrom(v);
        WasmMatrix.setTranslate(this.index, v.x, v.y, v.z);
        this.notifyLocalChange();
        this.onPositionChange?.();
        if (this.eventPositionChange) {
          this.eventDispatcher.dispatchEvent(this.eventPositionChange);
        }
      }
      /**
       *
       * The position of an object relative to its parent
       */
      get localPosition() {
        return this._localPos;
      }
      set localRotation(v) {
        WasmMatrix.setRotation(this.index, v.x, v.y, v.z);
        this._localRot.copyFrom(v);
        this.notifyLocalChange();
        this.onRotationChange?.();
        if (this.eventRotationChange) {
          this.eventDispatcher.dispatchEvent(this.eventRotationChange);
        }
      }
      /**
       *
       * The rotaion vector of an object relative to its parent
       */
      get localRotation() {
        return this._localRot;
      }
      set localScale(v) {
        WasmMatrix.setScale(this.index, v.x, v.y, v.z);
        this._localScale.copyFrom(v);
        this.notifyLocalChange();
        this.onScaleChange?.();
        if (this.eventScaleChange) {
          this.eventDispatcher.dispatchEvent(this.eventScaleChange);
        }
      }
      /**
       *
       * The scale of an object relative to its parent
       */
      get localScale() {
        return this._localScale;
      }
      get localDetailScale() {
        return this._localDetailScale;
      }
      set localDetailScale(value) {
        this._localDetailScale = value;
        WasmMatrix.setContinueScale(this.index, value.x, value.y, value.z);
      }
      get localDetailRot() {
        return this._localDetailRot;
      }
      set localDetailRot(value) {
        this._localDetailRot = value;
        WasmMatrix.setContinueRotation(this.index, value.x, value.y, value.z);
      }
      get localDetailPos() {
        return this._localDetailPos;
      }
      set localDetailPos(value) {
        this._localDetailPos = value;
        WasmMatrix.setContinueTranslate(this.index, value.x, value.y, value.z);
      }
      beforeDestroy(force) {
        if (this.parent && this.parent.object3D) {
          this.parent.object3D.removeChild(this.object3D);
        }
        super.beforeDestroy(force);
      }
      destroy() {
        super.destroy();
        this.scene3D = null;
        this.eventPositionChange = null;
        this.eventRotationChange = null;
        this.eventScaleChange = null;
        this.onPositionChange = null;
        this.onRotationChange = null;
        this.onScaleChange = null;
        this._scene3d = null;
        this._parent = null;
        this._localPos = null;
        this._localRot = null;
        this._localRotQuat = null;
        this._localScale = null;
        this._forward = null;
        this._back = null;
        this._right = null;
        this._left = null;
        this._up = null;
        this._down = null;
        this.localChange = null;
        this._targetPos = null;
      }
    }

    class BoundUtil {
      static maxVector = new Vector3(Number.MAX_VALUE * 0.1, Number.MAX_VALUE * 0.1, Number.MAX_VALUE * 0.1);
      static minVector = this.maxVector.clone().multiplyScalar(-1);
      static genMeshMaxVector = Vector3.ZERO.clone();
      static genMeshMinVector = Vector3.ZERO.clone();
      static genMeshVectorList8 = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
      /**
       * Merge the bounding boxes that have been added to the world matrix based on the mesh of the children node
       */
      static genMeshBounds(obj, bound) {
        let tempMin = this.genMeshMinVector;
        let tempMax = this.genMeshMaxVector;
        let tempPoints = this.genMeshVectorList8;
        bound ||= new BoundingBox(Vector3.ZERO, Vector3.ZERO);
        bound.setFromMinMax(this.maxVector, this.minVector);
        let cmpts = obj.getComponents(exports.MeshRenderer);
        for (const cmpt of cmpts) {
          if (cmpt && cmpt.geometry) {
            let matrix = cmpt.object3D.transform.worldMatrix;
            tempMin.copy(cmpt.geometry.bounds.min);
            tempMax.copy(cmpt.geometry.bounds.max);
            tempPoints[0].set(tempMin.x, tempMin.y, tempMin.z);
            tempPoints[1].set(tempMin.x, tempMin.y, tempMax.z);
            tempPoints[2].set(tempMin.x, tempMax.y, tempMin.z);
            tempPoints[3].set(tempMin.x, tempMax.y, tempMax.z);
            tempPoints[4].set(tempMax.x, tempMin.y, tempMin.z);
            tempPoints[5].set(tempMax.x, tempMin.y, tempMax.z);
            tempPoints[6].set(tempMax.x, tempMax.y, tempMin.z);
            tempPoints[7].set(tempMax.x, tempMax.y, tempMax.z);
            for (const p of tempPoints) {
              matrix.transformPoint(p, p);
              bound.expandByPoint(p);
            }
          }
        }
        tempMax.copyFrom(bound.max);
        tempMin.copyFrom(bound.min);
        bound.setFromMinMax(tempMin, tempMax);
        return bound;
      }
      static transformBound(matrix, source, bound) {
        let tempMin = this.genMeshMinVector.copyFrom(source.min);
        let tempMax = this.genMeshMaxVector.copyFrom(source.max);
        let tempPoints = this.genMeshVectorList8;
        bound ||= new BoundingBox(Vector3.ZERO, Vector3.ZERO);
        bound.setFromMinMax(this.maxVector, this.minVector);
        tempPoints[0].set(tempMin.x, tempMin.y, tempMin.z);
        tempPoints[1].set(tempMin.x, tempMin.y, tempMax.z);
        tempPoints[2].set(tempMin.x, tempMax.y, tempMin.z);
        tempPoints[3].set(tempMin.x, tempMax.y, tempMax.z);
        tempPoints[4].set(tempMax.x, tempMin.y, tempMin.z);
        tempPoints[5].set(tempMax.x, tempMin.y, tempMax.z);
        tempPoints[6].set(tempMax.x, tempMax.y, tempMin.z);
        tempPoints[7].set(tempMax.x, tempMax.y, tempMax.z);
        for (const p of tempPoints) {
          matrix.transformPoint(p, p);
          bound.expandByPoint(p);
        }
        tempMax.copyFrom(bound.max);
        tempMin.copyFrom(bound.min);
        bound.setFromMinMax(tempMin, tempMax);
        return bound;
      }
    }

    class Entity extends CEventDispatcher {
      /**
       *
       * The name of the object. The default value is an empty string.
       */
      name = "";
      _instanceID = "";
      _numChildren;
      /**
       * The unique identifier of the object.
       */
      get instanceID() {
        return this._instanceID;
      }
      /**
       *
       * The Transform attached to this object.
       */
      transform;
      /**
       *
       * Renderer components
       */
      renderNode;
      /**
       *
       * An array containing sub objects of an object
       */
      entityChildren;
      /**
       *
       * List of components attached to an object
       */
      components;
      waitDisposeComponents;
      /**
       *
       * The bounding box of an object
       */
      _bound;
      _boundWorld;
      _isBoundChange = true;
      _dispose = false;
      // private _visible: boolean = true;
      /**
       *
       * Starting from the object itself, search for the object and its children, and return the first child object with a matching name.
       * For most objects, the name is an empty string by default. You must manually set it to use this method.
       * @param name input name
       * @returns result Entity
       */
      getObjectByName(name) {
        let isPath = name.indexOf("/") >= 0;
        if (!isPath) {
          return this.getChildByName(name, false);
        } else {
          let list = name.split("/");
          let currentEntity = this;
          while (list.length > 0 && currentEntity) {
            let shortName = list.shift();
            currentEntity = currentEntity.getChildByName(shortName, false);
            if (!currentEntity) {
              return null;
            }
          }
          return currentEntity;
        }
      }
      /**
       *
       * @constructor
       */
      constructor() {
        super();
        this.entityChildren = [];
        this.components = /* @__PURE__ */ new Map();
        this._instanceID = GetCountInstanceID().toString();
        this.waitDisposeComponents = [];
      }
      /**
       *
       * Returns the number of child objects of an object
       */
      get numChildren() {
        return this._numChildren;
      }
      /**
       *
       * Add an object as a child of this object. You can add any number of objects.
       * Any current parent object on the object passed here will be deleted, as an object can only have at most one parent object.
       * @param child target child entity
       * @returns
       */
      addChild(child) {
        if (child == null) {
          throw new Error("child is null!");
        }
        if (child === this) {
          throw new Error("child is self!");
        }
        let index = this.entityChildren.indexOf(child);
        if (index == -1) {
          child.removeFromParent();
          child.transform.parent = this.transform;
          this.entityChildren.push(child);
          this._numChildren = this.entityChildren.length;
          return child;
        }
        return null;
      }
      /**
       *
       * Remove the child objects of the object. You can remove any number of objects.
       * @param child Removed objects
       */
      removeChild(child) {
        if (child === null)
          return;
        if (child === this)
          throw new Error("add child is self!");
        let index = this.entityChildren.indexOf(child);
        if (index != -1) {
          this.entityChildren.splice(index, 1);
          child.transform.parent = null;
          this._numChildren = this.entityChildren.length;
        }
      }
      /**
       *
       * Remove all children of the current object
       */
      removeAllChild() {
        while (this.numChildren > 0) {
          this.removeChild(this.entityChildren[0]);
        }
      }
      /**
       *
       * Remove the current node from the parent
       * @returns this
       */
      removeSelf() {
        return this.removeFromParent();
      }
      /**
       *
       * Search for child nodes of objects and remove child objects with matching indexes.
       * @param index assign index
       * @returns
       */
      removeChildByIndex(index) {
        if (index >= 0 && index < this.entityChildren.length) {
          this.removeChild(this.entityChildren[index]);
        } else {
          console.error("remove child by index , index out of range");
        }
      }
      /**
       *
       * Does the current object contain a certain object
       * @param child certain object
       * @returns boolean
       */
      hasChild(child) {
        let index = this.entityChildren.indexOf(child);
        return index != -1;
      }
      /**
       *
       * Remove the current node from the parent
       * @returns this
       */
      removeFromParent() {
        let parent = this.transform.parent;
        if (parent && parent.object3D) {
          parent.object3D.removeChild(this);
        }
        return this;
      }
      /**
       *
       * Search for object children and return the first child object with a matching index.
       * @param index matching index
       * @returns child entity
       */
      getChildByIndex(index) {
        let outObj = null;
        if (index < this.entityChildren.length) {
          outObj = this.entityChildren[index];
        }
        return outObj;
      }
      /**
       *
       * Search for object children and return a child object with a matching name.
       * @param name matching name
       * @param loopChild Whether to traverse the children of the child object. The default value is true
       * @returns result
       */
      getChildByName(name, loopChild = true) {
        let out = null;
        for (const iterator of this.entityChildren) {
          if (iterator.name == name) {
            out = iterator;
            return out;
          } else if (loopChild) {
            out = iterator.getChildByName(name, loopChild);
            if (out) {
              return out;
            }
          }
        }
        return out;
      }
      /**
       * @internal
       */
      update() {
      }
      /**
       *
       * @private
       * @returns
       */
      instantiate() {
        return null;
      }
      onTransformLocalChange(e) {
        this._isBoundChange = true;
      }
      get bound() {
        (this._isBoundChange || !this._bound) && this.updateBound();
        return this._boundWorld;
      }
      set bound(value) {
        this._bound = value;
        this._boundWorld = this._bound.clone();
        this._isBoundChange = true;
      }
      updateBound() {
        if (!this._bound) {
          this._bound = new BoundingBox();
          this._boundWorld = this._bound.clone();
          this._isBoundChange = true;
        }
        if (this._isBoundChange) {
          BoundUtil.transformBound(this.transform.worldMatrix, this._bound, this._boundWorld);
          this._isBoundChange = false;
        }
        return this._boundWorld;
      }
      /**
       *
       * @private
       * @returns
       */
      waitUpdate() {
        if (this._dispose) {
          if (this.transform.parent) {
            this.transform.parent.object3D.removeChild(this);
          }
          this.components.forEach((v, k) => {
            v.enable = false;
            v.beforeDestroy();
            v.destroy();
          });
          this.components.clear();
        } else {
          ComponentCollect.waitStartComponent.forEach((v, k) => {
            while (v.length > 0) {
              const element = v.shift();
              element[`__start`]();
              ComponentCollect.waitStartComponent.delete(element.object3D);
            }
          });
        }
      }
      /**
       * release current object
       */
      destroy(force) {
        if (!this._dispose) {
          this.components.forEach((c) => {
            c.beforeDestroy(force);
          });
          this.components.forEach((c) => {
            c.destroy(force);
          });
          this.components.clear();
          this.entityChildren.forEach((c) => {
            c.destroy(force);
          });
          this.removeAllChild();
          this.transform.parent = null;
          this._dispose = true;
          super.destroy();
        }
      }
    }

    var __defProp$m = Object.defineProperty;
    var __getOwnPropDesc$m = Object.getOwnPropertyDescriptor;
    var __decorateClass$m = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$m(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$m(target, key, result);
      return result;
    };
    exports.Object3D = class Object3D extends Entity {
      _isScene3D;
      prefabRef;
      serializeTag;
      /**
       * Instantiate a 3D object
       */
      constructor() {
        super();
        this.transform = this.addComponent(Transform);
        this.transform.eventDispatcher.addEventListener(Transform.LOCAL_ONCHANGE, this.onTransformLocalChange, this);
      }
      get isScene3D() {
        return this._isScene3D;
      }
      /**
       *
       * Traverse all sub objects starting from the object itself.
       *  If there are still sub objects in the sub object, recursively traverse.
       * @param callFunction execution body. Will execute sub objects as parameters
       * @returns
       */
      forChild(call) {
        this.entityChildren.forEach((element) => {
          call(element);
          element.forChild(call);
        });
      }
      /**
       *
       * Create a new component and add it to the object, and return an instance of the component.
       *  If a component of this type already exists, it will not be added and will return null.
       * @param c class of component
       * @return result component
       */
      addComponent(c, param) {
        if (!this.components.has(c)) {
          let instance = new c();
          instance.object3D = this;
          this.components.set(c, instance);
          instance[`__init`](param);
          ComponentCollect.appendWaitStart(instance);
          return instance;
        }
        return null;
      }
      /**
       *
       * Returns an instance of a component object of the specified type.
       *  If there are no components of that type, a new component is created and added to the object.
       * @param c class of component
       * @returns result component
       */
      getOrAddComponent(c) {
        let component = this.components.get(c);
        if (!component) {
          component = this.addComponent(c);
        }
        return component;
      }
      /**
       *
       * Remove components of the specified type
       * @param c class of component
       */
      removeComponent(c) {
        if (this.components.has(c)) {
          let component = this.components.get(c);
          ComponentCollect.removeWaitStart(this, component);
          this.components.delete(c);
          component[`__stop`]();
          component.beforeDestroy();
          component.destroy();
        }
      }
      /**
       *
       * Is there a component of the specified type
       * @param c type of component
       * @returns boolean
       */
      hasComponent(c) {
        return this.components.has(c);
      }
      /**
       *
       * Returns a component of the specified type.
       * @param c class of component
       * @returns result component
       */
      getComponent(c) {
        return this.components.get(c);
      }
      /**
       *
       * Returns a component object of the specified type from the parent node.
       *  If there are no components of that type,
       *  calls the parent object lookup of the parent object
       * @param c class of component
       * @returns reulst component
       */
      getComponentFromParent(c) {
        if (!this.parent) {
          return null;
        }
        let component = this.parent.object3D.getComponent(c);
        if (component) {
          return component;
        }
        return this.parent.object3D.getComponentFromParent(c);
      }
      /**
       *
       * Returns an array of component objects of the specified type.
       *  If there are no components of that type, search in the list of self body class objects
       * @param c class of component
       * @returns result components
       */
      getComponentsInChild(c) {
        let list = [];
        let component = this.components.get(c);
        if (component) {
          list.push(component);
        }
        for (let i = 0; i < this.entityChildren.length; i++) {
          let child = this.entityChildren[i];
          let coms = child.getComponentsInChild(c);
          list.push(...coms);
        }
        return list;
      }
      /**
       *
       * Returns all components of the specified type contained in the current object and its children.
       *  If there are children in the child object, recursively search.
       * @param c class of component
       * @param outList result component list
       * @param includeInactive Whether to include invisible objects, default to false
       * @returns {outList}
       */
      getComponents(c, outList, includeInactive) {
        outList ||= [];
        let component = this.getComponent(c);
        if (component && (component.enable || includeInactive)) {
          outList.push(component);
        }
        for (let i = 0, count = this.entityChildren.length; i < count; i++) {
          let child = this.entityChildren[i];
          if (child && child instanceof exports.Object3D) {
            child.getComponents(c, outList, includeInactive);
          }
        }
        return outList;
      }
      /**
       *
       * Quickly obtain components and no longer access child nodes after obtaining them at a certain node
       * @template T
       * @param {{ new(): T; }} c class of component
       * @param ret List of incoming T
       * @param includeInactive Whether to include invisible objects, default to false
       * @return {*}  {T}
       * @memberof Object3D
       */
      getComponentsExt(c, ret, includeInactive) {
        ret ||= [];
        let component = this.components.get(c);
        if (component && (component.enable || includeInactive)) {
          ret.push(component);
        } else {
          for (const node of this.entityChildren) {
            if (node instanceof exports.Object3D) {
              node.getComponentsExt(c, ret, includeInactive);
            }
          }
        }
        return ret;
      }
      getComponentsByProperty(key, value, findedAndBreak = true, ret, includeInactive) {
        ret ||= [];
        let findComponent;
        for (const component of this.components.values()) {
          if (component && (component.enable || includeInactive)) {
            if (component[key] === value) {
              ret.push(component);
              findComponent = true;
            }
          }
        }
        if (!(findComponent && findedAndBreak)) {
          for (const node of this.entityChildren) {
            if (node instanceof exports.Object3D) {
              node.getComponentsByProperty(key, value, findedAndBreak, ret, includeInactive);
            }
          }
        }
        return ret;
      }
      /**
       *
       * clone a Object3D
       * @returns
       */
      clone() {
        return this.instantiate();
      }
      /**
       *
       * @private
       * @returns
       */
      instantiate() {
        let tmp = new exports.Object3D();
        tmp.name = this.name;
        tmp.serializeTag = this.serializeTag;
        tmp.prefabRef = this.prefabRef;
        this.entityChildren.forEach((v, k) => {
          let tmpChild = v.instantiate();
          tmp.addChild(tmpChild);
        });
        this.components.forEach((v, k) => {
          v.cloneTo(tmp);
        });
        return tmp;
      }
      //****************
      //****************
      //****************
      //****************
      /**
       * Get the position of an object relative to its parent
       */
      get localPosition() {
        return this.transform.localPosition;
      }
      /**
       * Set the position of an object relative to its parent
       */
      set localPosition(value) {
        this.transform.localPosition = value;
      }
      /**
       * Get the rotation attribute of an object relative to its parent
       */
      get localRotation() {
        return this.transform.localRotation;
      }
      /**
       * Set the rotation attribute of an object relative to its parent
       */
      set localRotation(value) {
        this.transform.localRotation = value;
      }
      /**
       * Get the scaling attribute of an object relative to its parent
       */
      get localScale() {
        return this.transform.localScale;
      }
      /**
       * Set the scaling attribute of an object relative to its parent
       */
      set localScale(value) {
        this.transform.localScale = value;
      }
      /**
       * Get the rotation attribute of an object relative to its parent, which is a quaternion
       */
      get localQuaternion() {
        return this.transform.localRotQuat;
      }
      /**
       * Set the rotation attribute of an object relative to its parent, which is a quaternion
       */
      set localQuaternion(value) {
        this.transform.localRotQuat = value;
      }
      /**
       * Notify transformation attribute updates
       */
      notifyChange() {
        this.transform.notifyChange();
      }
      /**
       *
       * Transform component of object parent
       */
      get parent() {
        return this.transform.parent;
      }
      /**
       *
       * parent object3D
       */
      get parentObject() {
        return this.transform.parent.object3D;
      }
      /**
       *
       * Set the x coordinate relative to the local coordinates of the parent container.
       */
      set x(value) {
        this.transform.x = value;
      }
      /**
       *
       * Get the x coordinate relative to the local coordinates of the parent container.
       */
      get x() {
        return this.transform.x;
      }
      /**
       * Set the y coordinate relative to the local coordinates of the parent container.
       */
      set y(value) {
        this.transform.y = value;
      }
      /**
       *
       * Get the y coordinate relative to the local coordinates of the parent container.
       */
      get y() {
        return this.transform.y;
      }
      /**
       * Set the z coordinate relative to the local coordinates of the parent container.
       */
      set z(value) {
        this.transform.z = value;
      }
      /**
       * Get the z coordinate relative to the local coordinates of the parent container.
       */
      get z() {
        return this.transform.z;
      }
      /**
       * Set the x scale relative to the local coordinates of the parent container.
       */
      set scaleX(value) {
        this.transform.scaleX = value;
      }
      /**
       *
       * Get the x scale relative to the local coordinates of the parent container.
       */
      get scaleX() {
        return this.transform.scaleX;
      }
      /**
       *
       * Set the y scale relative to the local coordinates of the parent container.
       */
      set scaleY(value) {
        this.transform.scaleY = value;
      }
      /**
       *
       * Get the y scale relative to the local coordinates of the parent container.
       */
      get scaleY() {
        return this.transform.scaleY;
      }
      /**
       *
       * Set the z scale relative to the local coordinates of the parent container.
       */
      set scaleZ(value) {
        this.transform.scaleZ = value;
      }
      /**
       *
       * Get the z scale relative to the local coordinates of the parent container.
       */
      get scaleZ() {
        return this.transform.scaleZ;
      }
      /**
       *
       * Set the x rotation relative to the local coordinates of the parent container.
       */
      set rotationX(value) {
        this.transform.rotationX = value;
      }
      /**
       *
       * Get the x rotation relative to the local coordinates of the parent container.
       */
      get rotationX() {
        return this.transform.rotationX;
      }
      /**
       *
       * Set the y rotation relative to the local coordinates of the parent container.
       */
      set rotationY(value) {
        this.transform.rotationY = value;
      }
      /**
       *
       * Get the y rotation relative to the local coordinates of the parent container.
       */
      get rotationY() {
        return this.transform.rotationY;
      }
      /**
       *
       * Set the z rotation relative to the local coordinates of the parent container.
       */
      set rotationZ(value) {
        this.transform.rotationZ = value;
      }
      /**
       *
       * Set the z rotation relative to the local coordinates of the parent container.
       */
      get rotationZ() {
        return this.transform.rotationZ;
      }
      /**
       * @internal
       */
      fixedUpdate() {
      }
      /**
       * @internal
       */
      lateUpdate() {
      }
      /**
       *
       * Recursive child nodes and execute specified function
       * @param callback specified function
       */
      traverse(callback) {
        callback(this);
        for (let i = 0, l = this.entityChildren.length; i < l; i++) {
          let item = this.entityChildren[i];
          if (item instanceof exports.Object3D) {
            item.traverse(callback);
          }
        }
      }
      /**
       *
       * Release self
       */
      destroy(force) {
        this.transform.eventDispatcher.removeEventListener(Transform.LOCAL_ONCHANGE, this.onTransformLocalChange, this);
        super.destroy(force);
      }
    };
    exports.Object3D = __decorateClass$m([
      DecorateObject3D
    ], exports.Object3D);
    function DecorateObject3D(ctor, _) {
      return class extends exports.Object3D {
        set active(value) {
          this.transform.enable = value > 0;
        }
        get active() {
          return this.transform.enable ? 1 : 0;
        }
        get materialColor() {
          let component = this.getComponent(exports.MeshRenderer);
          return component?.material?.shader.getDefaultColorShader().baseColor;
        }
        set materialColor(color) {
          let material = this.getComponent(exports.MeshRenderer)?.material;
          material && (material.shader.getDefaultColorShader().baseColor = color);
        }
        notifyMaterialColorChange(materialIndex, key) {
          let materials = this.getComponent(exports.MeshRenderer).materials;
          materials?.[materialIndex]?.shader.getDefaultColorShader().uniforms[key].onChange();
        }
      };
    }

    class CameraUtil {
      /**
       * create a Camera3D component
       * @param parent parent object3D
       * @param name set name to the owner of this camera3D
       * @returns
       */
      static createCamera3DObject(parent, name) {
        return this.createCamera3D(null, parent, name);
      }
      /**
       * @internal
       * @param object3D
       * @param parent
       * @param name
       * @returns
       */
      static createCamera3D(object3D, parent, name) {
        object3D ||= new exports.Object3D();
        parent && parent.addChild(object3D);
        name && (object3D.name = name);
        return object3D.getOrAddComponent(Camera3D);
      }
      /**
       * @internal
       * @param sX
       * @param sY
       * @param sZ
       * @param camera
       * @returns
       */
      static UnProjection(sX, sY, sZ = 1, camera) {
        let mouse = new Vector3(sX, sY, 0);
        let sc = 1;
        let ina = Vector3.HELP_0;
        let ox = webGPUContext.canvas.offsetLeft;
        let oy = webGPUContext.canvas.offsetTop;
        let w = webGPUContext.canvas.clientWidth;
        let h = webGPUContext.canvas.clientHeight;
        ina.x = ((mouse.x - ox) * sc / w - 0.5) * 2;
        ina.y = -((mouse.y - oy) * sc / h - 0.5) * 2;
        ina.z = sZ;
        let outP = new Vector3(0, 0, 0);
        let projectWorld = Matrix4.helpMatrix2;
        projectWorld.copyFrom(camera.projectionMatrix);
        projectWorld.invert();
        let cameraToWorld = Matrix4.helpMatrix;
        cameraToWorld.identity();
        cameraToWorld.multiply(projectWorld);
        cameraToWorld.multiply(camera.transform.worldMatrix);
        cameraToWorld.perspectiveMultiplyPoint3(ina, outP);
        return outP;
      }
      /**
       * @internal
       * @param point
       * @param camera
       * @param target
       * @returns
       */
      static Projection(point, camera, target) {
        let outP = target ? target : new Vector3(0, 0, 0);
        let cameraToWorld = Matrix4.helpMatrix;
        cameraToWorld.copyFrom(camera.viewMatrix);
        cameraToWorld.multiply(camera.projectionMatrix);
        cameraToWorld.perspectiveMultiplyPoint3(point, outP);
        let w = webGPUContext.canvas.clientWidth / 2;
        let h = webGPUContext.canvas.clientHeight / 2;
        outP.x = outP.x * w + w;
        outP.y = h - outP.y * h;
        return outP;
      }
      /**
       * @internal
       * @param sceneX
       * @param sceneY
       * @param z
       * @param camera
       * @param target
       * @returns
       */
      static UnProjection2(sceneX, sceneY, z, camera, target) {
        let outP = target ? target : new Vector3(0, 0, 0);
        let cameraToWorld = Matrix4.helpMatrix;
        cameraToWorld.copyFrom(camera.pvMatrixInv);
        let w = webGPUContext.canvas.clientWidth / 2;
        let h = webGPUContext.canvas.clientHeight / 2;
        outP.x = (sceneX - w) / w;
        outP.y = (h - sceneY) / h;
        outP.z = z;
        cameraToWorld.perspectiveMultiplyPoint3(outP, outP);
        return outP;
      }
    }

    class ShadowLightsCollect {
      static maxNumDirectionShadow = 8;
      static maxNumPointShadow = 8;
      static directionLightList;
      static pointLightList;
      static shadowLights;
      static init() {
        this.directionLightList = /* @__PURE__ */ new Map();
        this.pointLightList = /* @__PURE__ */ new Map();
        this.shadowLights = /* @__PURE__ */ new Map();
      }
      static createBuffer(view) {
        if (!this.shadowLights.has(view.scene)) {
          let list = new Float32Array(16);
          this.shadowLights.set(view.scene, list);
        }
      }
      static getShadowLightList(light) {
        if (!light.transform.view3D)
          return null;
        if (light.lightData.lightType == LightType.DirectionLight) {
          let list = this.directionLightList.get(light.transform.view3D.scene);
          if (!list) {
            list = [];
            this.directionLightList.set(light.transform.view3D.scene, list);
          }
          return list;
        } else if (light.lightData.lightType == LightType.PointLight) {
          let list = this.pointLightList.get(light.transform.view3D.scene);
          if (!list) {
            list = [];
            this.pointLightList.set(light.transform.view3D.scene, list);
          }
          return list;
        } else if (light.lightData.lightType == LightType.SpotLight) {
          let list = this.pointLightList.get(light.transform.view3D.scene);
          if (!list) {
            list = [];
            this.pointLightList.set(light.transform.view3D.scene, list);
          }
          return list;
        }
      }
      static getShadowLightWhichScene(scene, type) {
        if (type == LightType.DirectionLight) {
          let list = this.directionLightList.get(scene);
          if (!list) {
            list = [];
            this.directionLightList.set(scene, list);
          }
          return list;
        } else if (type == LightType.PointLight) {
          let list = this.pointLightList.get(scene);
          if (!list) {
            list = [];
            this.pointLightList.set(scene, list);
          }
          return list;
        }
      }
      static getDirectShadowLightWhichScene(scene) {
        let list = this.directionLightList.get(scene);
        if (!list) {
          list = [];
          this.directionLightList.set(scene, list);
        }
        return list;
      }
      static getPointShadowLightWhichScene(scene) {
        let list = this.pointLightList.get(scene);
        if (!list) {
          list = [];
          this.pointLightList.set(scene, list);
        }
        return list;
      }
      static addShadowLight(light) {
        if (!light.transform.view3D)
          return null;
        let scene = light.transform.view3D.scene;
        if (light.lightData.lightType == LightType.DirectionLight) {
          let list = this.directionLightList.get(scene);
          if (!list) {
            list = [];
            this.directionLightList.set(scene, list);
          }
          if (!light.shadowCamera) {
            light.shadowCamera = CameraUtil.createCamera3DObject(null, "shadowCamera");
            light.shadowCamera.isShadowCamera = true;
            let shadowBound = -1e3;
            light.shadowCamera.orthoOffCenter(shadowBound, -shadowBound, shadowBound, -shadowBound, 1, 1e4);
          }
          if (list.indexOf(light) == -1) {
            list.push(light);
          }
          return list;
        } else if (light.lightData.lightType == LightType.PointLight || light.lightData.lightType == LightType.SpotLight) {
          let list = this.pointLightList.get(scene);
          if (list && list.length >= 8) {
            return list;
          }
          if (!list) {
            list = [];
            this.pointLightList.set(scene, list);
          }
          if (list.indexOf(light) == -1) {
            list.push(light);
          }
          return list;
        }
      }
      static removeShadowLight(light) {
        light.lightData.castShadowIndex = -1;
        if (!light.transform.view3D)
          return null;
        if (light.lightData.lightType == LightType.DirectionLight) {
          let list = this.directionLightList.get(light.transform.view3D.scene);
          if (list) {
            let index = list.indexOf(light);
            if (index != -1) {
              list.splice(index, 1);
            }
          }
          light.lightData.castShadowIndex = -1;
          return list;
        } else if (light.lightData.lightType == LightType.PointLight || light.lightData.lightType == LightType.SpotLight) {
          let list = this.pointLightList.get(light.transform.view3D.scene);
          if (list) {
            let index = list.indexOf(light);
            if (index != -1) {
              list.splice(index, 1);
            }
          }
          light.lightData.castShadowIndex = -1;
          return list;
        }
      }
      static update(view) {
        let globalUniform = GlobalBindGroup.getCameraGroup(view.camera);
        let shadowLights = this.shadowLights.get(view.scene);
        let directionLightList = ShadowLightsCollect.directionLightList.get(view.scene);
        let pointLightList = ShadowLightsCollect.pointLightList.get(view.scene);
        let nDirShadowStart = 0;
        let nDirShadowEnd = 0;
        let nPointShadowStart = 0;
        let nPointShadowEnd = 0;
        shadowLights.fill(0);
        if (directionLightList) {
          let j = 0;
          for (let i = 0; i < directionLightList.length; i++) {
            const light = directionLightList[i];
            shadowLights[i] = light.lightData.index;
            light.lightData.castShadowIndex = j++;
          }
          nDirShadowEnd = directionLightList.length;
        }
        globalUniform.dirShadowStart = nDirShadowStart;
        globalUniform.dirShadowEnd = nDirShadowEnd;
        if (pointLightList) {
          nPointShadowStart = nDirShadowEnd;
          let j = 0;
          for (let i = nPointShadowStart; i < pointLightList.length; i++) {
            const light = pointLightList[i];
            shadowLights[i] = light.lightData.index;
            light.lightData.castShadowIndex = j++;
          }
          nPointShadowEnd = nPointShadowStart + pointLightList.length;
        }
        globalUniform.pointShadowStart = nPointShadowStart;
        globalUniform.pointShadowEnd = nPointShadowEnd;
        globalUniform.shadowLights = shadowLights;
      }
    }

    class GlobalBindGroupLayout {
      static _globalDataBindGroupLayout;
      static getGlobalDataBindGroupLayout() {
        if (this._globalDataBindGroupLayout)
          return this._globalDataBindGroupLayout;
        let entries = [];
        entries.push({
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,
          buffer: {
            type: "uniform"
          }
        });
        entries.push({
          binding: 1,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE,
          buffer: {
            type: "read-only-storage"
          }
        });
        this._globalDataBindGroupLayout = webGPUContext.device.createBindGroupLayout({ entries });
        return this._globalDataBindGroupLayout;
      }
    }

    class GlobalUniformGroup {
      uuid;
      usage;
      globalBindGroup;
      uniformGPUBuffer;
      matrixBindGroup;
      uniformByteLength;
      matrixesByteLength;
      shadowMatrixRaw = new Float32Array(8 * 16);
      csmMatrixRaw = new Float32Array(CSM.Cascades * 16);
      csmShadowBias = new Float32Array(4);
      shadowLights = new Float32Array(16);
      dirShadowStart = 0;
      dirShadowEnd = 0;
      pointShadowStart = 0;
      pointShadowEnd = 0;
      /**
       * 
       * @param matrixBindGroup global matrix bindgroup 
       */
      constructor(matrixBindGroup) {
        this.uuid = UUID();
        this.usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        this.uniformGPUBuffer = new UniformGPUBuffer(8192);
        this.uniformGPUBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
        this.matrixBindGroup = matrixBindGroup;
        this.createBindGroup();
      }
      createBindGroup() {
        this.uniformByteLength = this.uniformGPUBuffer.memory.shareDataBuffer.byteLength;
        this.matrixesByteLength = Matrix4.blockBytes * Matrix4.maxCount;
        this.globalBindGroup = webGPUContext.device.createBindGroup({
          label: `global_bindGroupLayout`,
          layout: GlobalBindGroupLayout.getGlobalDataBindGroupLayout(),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.uniformGPUBuffer.buffer,
                offset: 0,
                // this.uniformGPUBuffer.memory.shareDataBuffer.byteOffset,
                size: this.uniformByteLength
              }
            },
            {
              binding: 1,
              resource: {
                buffer: this.matrixBindGroup.matrixBufferDst.buffer,
                offset: 0,
                size: this.matrixesByteLength
              }
            }
          ]
        });
      }
      setCamera(camera) {
        this.uniformGPUBuffer.setMatrix(`_projectionMatrix`, camera.projectionMatrix);
        this.uniformGPUBuffer.setMatrix(`_viewMatrix`, camera.viewMatrix);
        this.uniformGPUBuffer.setMatrix(`_cameraWorldMatrix`, camera.transform.worldMatrix);
        this.uniformGPUBuffer.setMatrix(`pvMatrixInv`, camera.projectionMatrixInv);
        let shadowLightList = ShadowLightsCollect.getDirectShadowLightWhichScene(camera.transform.scene3D);
        this.csmShadowBias.fill(1e-4);
        this.shadowMatrixRaw.fill(0);
        this.csmMatrixRaw.fill(0);
        for (let i = 0; i < 8; i++) {
          if (i < shadowLightList.length) {
            let shadowCamera = shadowLightList[i].shadowCamera;
            this.shadowMatrixRaw.set(shadowCamera.pvMatrix.rawData, i * 16);
          } else {
            this.shadowMatrixRaw.set(camera.transform.worldMatrix.rawData, i * 16);
          }
        }
        this.uniformGPUBuffer.setFloat32Array(`shadowMatrix`, this.shadowMatrixRaw);
        let shadowMapSize = Engine3D.setting.shadow.shadowSize;
        if (CSM.Cascades > 1 && camera.enableCSM && shadowLightList[0]) {
          for (let i = 0; i < CSM.Cascades; i++) {
            let shadowCamera = camera.csm.children[i].shadowCamera;
            this.csmMatrixRaw.set(shadowCamera.pvMatrix.rawData, i * 16);
            this.csmShadowBias[i] = camera.getCSMShadowBias(i, shadowMapSize);
          }
        }
        this.uniformGPUBuffer.setFloat32Array(`csmShadowBias`, this.csmShadowBias);
        this.uniformGPUBuffer.setFloat32Array(`csmMatrix`, this.csmMatrixRaw);
        this.uniformGPUBuffer.setFloat32Array(`shadowLights`, this.shadowLights);
        this.uniformGPUBuffer.setVector3(`CameraPos`, camera.transform.worldPosition);
        this.uniformGPUBuffer.setFloat(`frame`, Time.frame);
        this.uniformGPUBuffer.setFloat(`time`, Time.frame);
        this.uniformGPUBuffer.setFloat(`delta`, Time.delta);
        this.uniformGPUBuffer.setFloat(`shadowBias`, camera.getShadowBias(shadowMapSize));
        this.uniformGPUBuffer.setFloat(`skyExposure`, Engine3D.setting.sky.skyExposure);
        this.uniformGPUBuffer.setFloat(`renderPassState`, Engine3D.setting.render.renderPassState);
        this.uniformGPUBuffer.setFloat(`quadScale`, Engine3D.setting.render.quadScale);
        this.uniformGPUBuffer.setFloat(`hdrExposure`, Engine3D.setting.render.hdrExposure);
        this.uniformGPUBuffer.setInt32(`renderState_left`, Engine3D.setting.render.renderState_left);
        this.uniformGPUBuffer.setInt32(`renderState_right`, Engine3D.setting.render.renderState_right);
        this.uniformGPUBuffer.setFloat(`renderState_split`, Engine3D.setting.render.renderState_split);
        let mouseX = Engine3D.inputSystem.mouseX * webGPUContext.pixelRatio;
        let mouseY = Engine3D.inputSystem.mouseY * webGPUContext.pixelRatio;
        this.uniformGPUBuffer.setFloat(`mouseX`, mouseX);
        this.uniformGPUBuffer.setFloat(`mouseY`, mouseY);
        this.uniformGPUBuffer.setFloat(`windowWidth`, webGPUContext.windowWidth);
        this.uniformGPUBuffer.setFloat(`windowHeight`, webGPUContext.windowHeight);
        this.uniformGPUBuffer.setFloat(`near`, camera.near);
        this.uniformGPUBuffer.setFloat(`far`, camera.far);
        this.uniformGPUBuffer.setFloat(`pointShadowBias`, Engine3D.setting.shadow.pointShadowBias);
        this.uniformGPUBuffer.setFloat(`shadowMapSize`, shadowMapSize);
        this.uniformGPUBuffer.setFloat(`shadowSoft`, Engine3D.setting.shadow.shadowSoft);
        this.uniformGPUBuffer.setFloat(`enableCSM`, camera.enableCSM ? 1 : 0);
        this.uniformGPUBuffer.setFloat(`csmMargin`, Engine3D.setting.shadow.csmMargin);
        this.uniformGPUBuffer.setInt32(`nDirShadowStart`, this.dirShadowStart);
        this.uniformGPUBuffer.setInt32(`nDirShadowEnd`, this.dirShadowEnd);
        this.uniformGPUBuffer.setInt32(`nPointShadowStart`, this.pointShadowStart);
        this.uniformGPUBuffer.setInt32(`nPointShadowEnd`, this.pointShadowEnd);
        this.uniformGPUBuffer.setInt32(`empty1`, 0);
        this.uniformGPUBuffer.setInt32(`empty2`, 0);
        this.uniformGPUBuffer.setInt32(`empty3`, 0);
        this.uniformGPUBuffer.setVector4Array(`frustumPlanes`, camera.frustum.planes);
        this.uniformGPUBuffer.apply();
      }
      setShadowCamera(camera) {
        this.uniformGPUBuffer.setMatrix(`_projectionMatrix`, camera.projectionMatrix);
        this.uniformGPUBuffer.setMatrix(`_viewMatrix`, camera.viewMatrix);
        this.uniformGPUBuffer.setMatrix(`_pvMatrix`, camera.pvMatrix);
        this.uniformGPUBuffer.setMatrix(`pvMatrixInv`, camera.projectionMatrixInv);
        this.csmShadowBias.fill(1e-4);
        this.shadowMatrixRaw.fill(0);
        this.csmMatrixRaw.fill(0);
        this.uniformGPUBuffer.setFloat32Array(`shadowCamera`, this.shadowMatrixRaw);
        this.uniformGPUBuffer.setFloat32Array(`csmShadowBias`, this.csmShadowBias);
        this.uniformGPUBuffer.setFloat32Array(`csmMatrix`, this.csmMatrixRaw);
        this.uniformGPUBuffer.setFloat32Array(`shadowLights`, this.shadowLights);
        this.uniformGPUBuffer.setVector3(`CameraPos`, camera.transform.worldPosition);
        this.uniformGPUBuffer.setFloat(`frame`, Time.frame);
        this.uniformGPUBuffer.setFloat(`time`, Time.frame);
        this.uniformGPUBuffer.setFloat(`delta`, Time.delta);
        this.uniformGPUBuffer.setFloat(`shadowBias`, Engine3D.setting.shadow.shadowBias);
        this.uniformGPUBuffer.setFloat(`skyExposure`, Engine3D.setting.sky.skyExposure);
        this.uniformGPUBuffer.setFloat(`renderPassState`, Engine3D.setting.render.renderPassState);
        this.uniformGPUBuffer.setFloat(`quadScale`, Engine3D.setting.render.quadScale);
        this.uniformGPUBuffer.setFloat(`hdrExposure`, Engine3D.setting.render.hdrExposure);
        this.uniformGPUBuffer.setInt32(`renderState_left`, Engine3D.setting.render.renderState_left);
        this.uniformGPUBuffer.setInt32(`renderState_right`, Engine3D.setting.render.renderState_right);
        this.uniformGPUBuffer.setFloat(`renderState_split`, Engine3D.setting.render.renderState_split);
        let mouseX = Engine3D.inputSystem.mouseX * webGPUContext.pixelRatio;
        let mouseY = Engine3D.inputSystem.mouseY * webGPUContext.pixelRatio;
        this.uniformGPUBuffer.setFloat(`mouseX`, mouseX);
        this.uniformGPUBuffer.setFloat(`mouseY`, mouseY);
        this.uniformGPUBuffer.setFloat(`windowWidth`, webGPUContext.windowWidth);
        this.uniformGPUBuffer.setFloat(`windowHeight`, webGPUContext.windowHeight);
        this.uniformGPUBuffer.setFloat(`near`, camera.near);
        this.uniformGPUBuffer.setFloat(`far`, camera.far);
        this.uniformGPUBuffer.setFloat(`pointShadowBias`, Engine3D.setting.shadow.pointShadowBias);
        this.uniformGPUBuffer.setFloat(`shadowMapSize`, Engine3D.setting.shadow.shadowSize);
        this.uniformGPUBuffer.setFloat(`shadowSoft`, Engine3D.setting.shadow.shadowSoft);
        this.uniformGPUBuffer.setFloat(`enableCSM`, 0);
        this.uniformGPUBuffer.setFloat(`csmMargin`, Engine3D.setting.shadow.csmMargin);
        this.uniformGPUBuffer.setInt32(`nDirShadowStart`, this.dirShadowStart);
        this.uniformGPUBuffer.setInt32(`nDirShadowEnd`, this.dirShadowEnd);
        this.uniformGPUBuffer.setInt32(`nPointShadowStart`, this.pointShadowStart);
        this.uniformGPUBuffer.setInt32(`nPointShadowEnd`, this.pointShadowEnd);
        this.uniformGPUBuffer.apply();
      }
      setShadowLight() {
      }
    }

    class Octree {
      static _v1 = new Vector3();
      static _v2 = new Vector3();
      // private static _plane = new Plane();
      // private static _line1 = new Line3();
      // private static _line2 = new Line3();
      // private static _sphere = new Sphere();
      // private static _capsule = new Capsule();
      entities;
      box;
      subTrees = [];
      parent;
      level;
      static maxSplitLevel = 6;
      static autoSplitLevel = 3;
      index;
      uuid;
      constructor(size, index = 0, parent = null, level = 0) {
        this.parent = parent;
        this.box = size.clone();
        this.level = level;
        this.index = index;
        this.uuid = level + "_" + index;
        this.entities = /* @__PURE__ */ new Map();
      }
      tryInsertEntity(entity) {
        let userBox = entity.renderer.object3D.bound;
        if (this.level == 0 || this.box.containsBox(userBox)) {
          if (this.subTrees.length == 0) {
            if (this.level < Octree.maxSplitLevel) {
              this.splitTree();
            }
          }
          let holdByChild;
          if (this.subTrees.length > 0) {
            for (let child of this.subTrees) {
              if (child.tryInsertEntity(entity)) {
                holdByChild = true;
                break;
              }
            }
          }
          if (!holdByChild) {
            entity.enterNode(this);
          }
          return true;
        }
        return false;
      }
      splitTree() {
        if (this.subTrees.length == 0) {
          const v = Octree._v1;
          const halfsize = this.box.extents.clone();
          let childLevel = this.level + 1;
          let index = 0;
          for (let x = 0; x < 2; x++) {
            for (let y = 0; y < 2; y++) {
              for (let z = 0; z < 2; z++) {
                const box = new BoundingBox();
                this.box.min.add(v.set(x, y, z).multiply(halfsize), box.min);
                box.min.add(halfsize, box.max);
                box.setFromMinMax(box.min, box.max);
                let subTree = new Octree(box, index++, this, childLevel);
                this.subTrees.push(subTree);
              }
            }
          }
        }
      }
      __rayCastTempVector = new Vector3();
      rayCasts(ray, ret) {
        if (this.level == 0 || ray.intersectBox(this.box, this.__rayCastTempVector)) {
          if (this.entities.size > 0) {
            ret.push(...this.entities.values());
          }
          for (let child of this.subTrees) {
            child.rayCasts(ray, ret);
          }
          return true;
        }
        return false;
      }
      frustumCasts(frustum, ret) {
        if (this.level == 0 || frustum.containsBox2(this.box) > 0) {
          if (this.entities.size > 0) {
            for (const item of this.entities.values()) {
              if (this.level > Octree.autoSplitLevel || frustum.containsBox2(item.renderer.object3D.bound) > 0) {
                ret.push(item);
              }
            }
          }
          for (let child of this.subTrees) {
            child.frustumCasts(frustum, ret);
          }
          return true;
        }
        return false;
      }
      getRenderNode(frustum, ret) {
        if (this.level == 0 || frustum.containsBox2(this.box) > 0) {
          if (this.entities.size > 0) {
            for (const item of this.entities.values()) {
              if (this.level > Octree.autoSplitLevel || frustum.containsBox2(item.renderer.object3D.bound) > 0) {
                if (item.renderer.renderOrder < 3e3) {
                  ret.opaqueList.push(item.renderer);
                } else if (item.renderer.renderOrder >= 3e3) {
                  ret.transparentList.push(item.renderer);
                }
              }
            }
          }
          for (let child of this.subTrees) {
            child.getRenderNode(frustum, ret);
          }
          return true;
        }
        return false;
      }
      boxCasts(box, ret) {
        if (box.intersectsBox(this.box)) {
          if (this.entities.size > 0) {
            ret.push(...this.entities.values());
          }
          for (let child of this.subTrees) {
            child.boxCasts(box, ret);
          }
          return true;
        }
        return false;
      }
      clean() {
        for (let item of this.entities.values()) {
          item.leaveNode();
        }
        this.entities.clear();
        return this;
      }
      // getRayTriangles(ray, triangles) {
      //   for (let subTree of this.subTrees) {
      //     if (!ray.intersectsBox(subTree.box)) {
      //       continue;
      //     }
      //     subTree.setGizmos(true, false);
      //     let count = subTree.entities.length;
      //     if (count > 0) {
      //       let tempTriangle: OctreeEntity;
      //       for (let j = 0; j < count; j++) {
      //         tempTriangle = subTree.entities[j];
      //         if (triangles.indexOf(tempTriangle) == -1) {
      //           triangles.push(tempTriangle);
      //         }
      //       }
      //     }
      //     // else {
      //     subTree.getRayTriangles(ray, triangles);
      //     // }
      //   }
      //   return triangles;
      // }
      // triangleCapsuleIntersect(capsule, triangle) {
      //   triangle.getPlane(Octree._plane);
      //   const d1 = Octree._plane.distanceToPoint(capsule.start) - capsule.radius;
      //   const d2 = Octree._plane.distanceToPoint(capsule.end) - capsule.radius;
      //   if ((d1 > 0 && d2 > 0) || (d1 < -capsule.radius && d2 < -capsule.radius)) {
      //     return false;
      //   }
      //   const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));
      //   const intersectPoint = Octree._v1.copy(capsule.start).lerp(capsule.end, delta);
      //   if (triangle.containsPoint(intersectPoint)) {
      //     return {
      //       normal: Octree._plane.normal.clone(),
      //       point: intersectPoint.clone(),
      //       depth: Math.abs(Math.min(d1, d2)),
      //     };
      //   }
      //   const r2 = capsule.radius * capsule.radius;
      //   const line1 = Octree._line1.set(capsule.start, capsule.end);
      //   const lines = [
      //     [triangle.a, triangle.b],
      //     [triangle.b, triangle.c],
      //     [triangle.c, triangle.a],
      //   ];
      //   for (let i = 0; i < lines.length; i++) {
      //     const line2 = Octree._line2.set(lines[i][0], lines[i][1]);
      //     const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);
      //     if (point1.distanceToSquared(point2) < r2) {
      //       return {
      //         normal: point1.clone().sub(point2).normalize(),
      //         point: point2.clone(),
      //         depth: capsule.radius - point1.distanceTo(point2),
      //       };
      //     }
      //   }
      //   return false;
      // }
      // triangleSphereIntersect(sphere, triangle) {
      //   triangle.getPlane(Octree._plane);
      //   if (!sphere.intersectsPlane(Octree._plane)) return false;
      //   const depth = Math.abs(Octree._plane.distanceToSphere(sphere));
      //   const r2 = sphere.radius * sphere.radius - depth * depth;
      //   const plainPoint = Octree._plane.projectPoint(sphere.center, Octree._v1);
      //   if (triangle.containsPoint(sphere.center)) {
      //     return {
      //       normal: Octree._plane.normal.clone(),
      //       point: plainPoint.clone(),
      //       depth: Math.abs(Octree._plane.distanceToSphere(sphere)),
      //     };
      //   }
      //   const lines = [
      //     [triangle.a, triangle.b],
      //     [triangle.b, triangle.c],
      //     [triangle.c, triangle.a],
      //   ];
      //   for (let i = 0; i < lines.length; i++) {
      //     Octree._line1.set(lines[i][0], lines[i][1]);
      //     Octree._line1.closestPointToPoint(plainPoint, true, Octree._v2);
      //     const d = Octree._v2.distanceToSquared(sphere.center);
      //     if (d < r2) {
      //       return {
      //         normal: sphere.center.clone().sub(Octree._v2).normalize(),
      //         point: Octree._v2.clone(),
      //         depth: sphere.radius - Math.sqrt(d),
      //       };
      //     }
      //   }
      //   return false;
      // }
      // getSphereTriangles(sphere, triangles) {
      //   for (let subTree of this.subTrees) {
      //     if (!sphere.intersectsBox(subTree.box)) continue;
      //     if (subTree.entities.length > 0) {
      //       for (let j = 0; j < subTree.entities.length; j++) {
      //         if (triangles.indexOf(subTree.entities[j]) === -1) triangles.push(subTree.entities[j]);
      //       }
      //     } else {
      //       subTree.getSphereTriangles(sphere, triangles);
      //     }
      //   }
      // }
      // getCapsuleTriangles(capsule, triangles) {
      //   for (let subTree of this.subTrees) {
      //     if (!capsule.intersectsBox(subTree.box)) continue;
      //     if (subTree.entities.length > 0) {
      //       for (let j = 0; j < subTree.entities.length; j++) {
      //         if (triangles.indexOf(subTree.entities[j]) === -1) triangles.push(subTree.entities[j]);
      //       }
      //     } else {
      //       subTree.getCapsuleTriangles(capsule, triangles);
      //     }
      //   }
      // }
      // sphereIntersect(sphere) {
      //   Octree._sphere.copy(sphere);
      //   const triangles = [];
      //   let result,
      //     hit = false;
      //   this.getSphereTriangles(sphere, triangles);
      //   for (let i = 0; i < triangles.length; i++) {
      //     if ((result = this.triangleSphereIntersect(Octree._sphere, triangles[i]))) {
      //       hit = true;
      //       Octree._sphere.center.add(result.normal.multiplyScalar(result.depth));
      //     }
      //   }
      //   if (hit) {
      //     const collisionVector = Octree._sphere.center.clone().sub(sphere.center);
      //     const depth = collisionVector.length();
      //     return {
      //       normal: collisionVector.normalize(),
      //       depth: depth,
      //     };
      //   }
      //   return false;
      // }
      // capsuleIntersect(capsule) {
      //   Octree._capsule.copy(capsule);
      //   const triangles = [];
      //   let result,
      //     hit = false;
      //   this.getCapsuleTriangles(Octree._capsule, triangles);
      //   for (let i = 0; i < triangles.length; i++) {
      //     if ((result = this.triangleCapsuleIntersect(Octree._capsule, triangles[i]))) {
      //       hit = true;
      //       Octree._capsule.translate(result.normal.multiplyScalar(result.depth));
      //     }
      //   }
      //   if (hit) {
      //     let collisionVector: Vector3;
      //     let getCenter = Octree._capsule['getCenter'] as any;
      //     collisionVector = getCenter(new Vector3()).sub(capsule.getCenter(Octree._v1));
      //     const depth = collisionVector.length();
      //     return {
      //       normal: collisionVector.normalize(),
      //       depth: depth,
      //     };
      //   }
      //   return false;
      // }
      // rayIntersect(ray) {
      //   if (ray.direction.length() === 0) return;
      //   const triangles = [];
      //   let triangle,
      //     position,
      //     distance = 1e100;
      //   this.getRayTriangles(ray, triangles);
      //   for (let i = 0; i < triangles.length; i++) {
      //     const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, Octree._v1);
      //     if (result) {
      //       const newdistance = result.sub(ray.origin).length();
      //       if (distance > newdistance) {
      //         position = result.clone().add(ray.origin);
      //         distance = newdistance;
      //         triangle = triangles[i];
      //       }
      //     }
      //   }
      //   return distance < 1e100
      //     ? {
      //       distance: distance,
      //       triangle: triangle,
      //       position: position,
      //     }
      //     : false;
      // }
    }

    class ZSorterUtil {
      _pool = [];
      _worldPosition = new Vector3();
      _viewPosition = new Vector3();
      _zSortList = [];
      pop() {
        return this._pool.pop() || {};
      }
      recycle() {
        for (let item of this._zSortList) {
          item.z = 0;
          item.userData = null;
          item.obj3d = null;
          this._pool.push(item);
        }
        this._zSortList.length = 0;
      }
      /**
       * Sort userDataList by z based on the view coordinates of camera3D
       * @param camera3D camera3D
       * @param userDataList List of objects that users need to sort
       * @param getObject3D Obtain the function of the Object 3D reference based on userData
       * @param result Returns a list of userData, and if passed in as null, instantiates one
       * @returns
       */
      sort(camera3D, userDataList, getObject3D, result) {
        this._zSortList = [];
        for (let userData of userDataList) {
          let zSortItemObject3D = this.pop();
          zSortItemObject3D.userData = userData;
          zSortItemObject3D.obj3d = getObject3D(userData);
          zSortItemObject3D.z = this.worldToCameraDepth(zSortItemObject3D.obj3d, camera3D);
          this._zSortList.push(zSortItemObject3D);
        }
        this._zSortList.sort((a, b) => {
          return a.z - b.z > 0 ? 1 : -1;
        });
        result ||= [];
        for (let item of this._zSortList) {
          result.push(item.userData);
        }
        this.recycle();
        return result;
      }
      worldToCameraDepth(obj3d, camera) {
        camera ||= obj3d.transform.view3D.camera;
        let z = 0;
        if (camera) {
          this._worldPosition.copyFrom(obj3d.transform.worldPosition);
          camera.worldToScreenPoint(this._worldPosition, this._viewPosition);
          z = this._viewPosition.z;
        }
        return z;
      }
    }
    let zSorterUtil = new ZSorterUtil();

    var RenderLayer = /* @__PURE__ */ ((RenderLayer2) => {
      RenderLayer2[RenderLayer2["None"] = 2] = "None";
      RenderLayer2[RenderLayer2["StaticBatch"] = 4] = "StaticBatch";
      RenderLayer2[RenderLayer2["DynamicBatch"] = 8] = "DynamicBatch";
      return RenderLayer2;
    })(RenderLayer || {});
    class RenderLayerUtil {
      static addMask(src, tag) {
        let value = src | tag;
        return value;
      }
      static removeMask(src, tag) {
        let value = src & ~tag;
        return value;
      }
      static hasMask(m1, m2) {
        return (m1 & m2) != 0;
      }
    }

    var PassType = /* @__PURE__ */ ((PassType2) => {
      PassType2[PassType2["COLOR"] = 1] = "COLOR";
      PassType2[PassType2["NORMAL"] = 2] = "NORMAL";
      PassType2[PassType2["POSITION"] = 4] = "POSITION";
      PassType2[PassType2["GRAPHIC"] = 8] = "GRAPHIC";
      PassType2[PassType2["GI"] = 16] = "GI";
      PassType2[PassType2["Cluster"] = 32] = "Cluster";
      PassType2[PassType2["SHADOW"] = 64] = "SHADOW";
      PassType2[PassType2["POINT_SHADOW"] = 128] = "POINT_SHADOW";
      PassType2[PassType2["POST"] = 256] = "POST";
      PassType2[PassType2["DEPTH"] = 512] = "DEPTH";
      PassType2[PassType2["REFLECTION"] = 1024] = "REFLECTION";
      return PassType2;
    })(PassType || {});

    class GLTFType {
      static GLTF_NODE_INDEX_PROPERTY;
      static BASE_COLOR_UNIFORM = "u_baseColorFactor";
      static BASE_COLOR_TEXTURE_UNIFORM = "u_baseColorSampler";
      static METALROUGHNESS_UNIFORM = "u_metallicRoughnessValues";
      static METALROUGHNESS_TEXTURE_UNIFORM = "u_metallicRoughnessSampler";
      static NORMAL_TEXTURE_UNIFORM = "u_normalSampler";
      static NORMAL_SCALE_UNIFORM = "u_normalScale";
      static EMISSIVE_TEXTURE_UNIFORM = "u_emissiveSampler";
      static EMISSIVE_FACTOR_UNIFORM = "u_emissiveFactor";
      static OCCLUSION_TEXTURE_UNIFORM = "u_occlusionSampler";
      static OCCLUSION_FACTOR_UNIFORM = "u_occlusionFactor";
      static MAX_MORPH_TARGETS = 8;
      static MORPH_POSITION_PREFIX = "a_morphPositions_";
      static MORPH_NORMAL_PREFIX = "a_morphNormals_";
      static MORPH_TANGENT_PREFIX = "a_morphTangents_";
      static MORPH_WEIGHT_UNIFORM = "u_morphWeights";
      static SCENE_ROOT_SKELETON = "SCENE_ROOT";
      static IDENTITY_INVERSE_BIND_MATRICES = "IDENTITY_IBM";
      static JOINT_MATRICES_UNIFORM = "u_jointMatrix";
      static ALPHA_CUTOFF_UNIFORM = "u_alphaCutoff";
    }

    var VertexAttributeName = /* @__PURE__ */ ((VertexAttributeName2) => {
      VertexAttributeName2["position"] = "position";
      VertexAttributeName2["normal"] = "normal";
      VertexAttributeName2["uv"] = "uv";
      VertexAttributeName2["TANGENT"] = "TANGENT";
      VertexAttributeName2["TEXCOORD_1"] = "TEXCOORD_1";
      VertexAttributeName2["TEXCOORD_2"] = "TEXCOORD_2";
      VertexAttributeName2["TEXCOORD_3"] = "TEXCOORD_3";
      VertexAttributeName2["TEXCOORD_4"] = "TEXCOORD_4";
      VertexAttributeName2["TEXCOORD_5"] = "TEXCOORD_5";
      VertexAttributeName2["TEXCOORD_6"] = "TEXCOORD_6";
      VertexAttributeName2["TEXCOORD_7"] = "TEXCOORD_7";
      VertexAttributeName2["color"] = "color";
      VertexAttributeName2["joints0"] = "joints0";
      VertexAttributeName2["joints1"] = "joints1";
      VertexAttributeName2["weights0"] = "weights0";
      VertexAttributeName2["weights1"] = "weights1";
      VertexAttributeName2["weight"] = "weight";
      VertexAttributeName2["indices"] = `indices`;
      VertexAttributeName2["vIndex"] = "vIndex";
      VertexAttributeName2["a_morphPositions_0"] = "a_morphPositions_0";
      VertexAttributeName2["all"] = "all";
      return VertexAttributeName2;
    })(VertexAttributeName || {});

    var BlendMode = /* @__PURE__ */ ((BlendMode2) => {
      BlendMode2[BlendMode2["NONE"] = 0] = "NONE";
      BlendMode2[BlendMode2["ABOVE"] = 1] = "ABOVE";
      BlendMode2[BlendMode2["ALPHA"] = 2] = "ALPHA";
      BlendMode2[BlendMode2["NORMAL"] = 3] = "NORMAL";
      BlendMode2[BlendMode2["ADD"] = 4] = "ADD";
      BlendMode2[BlendMode2["BELOW"] = 5] = "BELOW";
      BlendMode2[BlendMode2["ERASE"] = 6] = "ERASE";
      BlendMode2[BlendMode2["MUL"] = 7] = "MUL";
      BlendMode2[BlendMode2["SCREEN"] = 8] = "SCREEN";
      BlendMode2[BlendMode2["DIVD"] = 9] = "DIVD";
      BlendMode2[BlendMode2["SOFT_ADD"] = 10] = "SOFT_ADD";
      return BlendMode2;
    })(BlendMode || {});
    var Blend = /* @__PURE__ */ ((Blend2) => {
      Blend2[Blend2["src_a"] = 0] = "src_a";
      Blend2[Blend2["dest_a"] = 1] = "dest_a";
      return Blend2;
    })(Blend || {});
    class BlendFactor {
      static getBlend(blendMode) {
        let blend = {
          color: {
            srcFactor: "src-alpha",
            dstFactor: "one"
          },
          alpha: {
            srcFactor: "one",
            dstFactor: "one"
          }
        };
        switch (blendMode) {
          case 0 /* NONE */:
            blend.color.srcFactor = `one`;
            blend.color.dstFactor = `zero`;
            blend.color.operation = "add";
            break;
          case 1 /* ABOVE */:
            blend.color.srcFactor = `one-minus-src-alpha`;
            blend.color.dstFactor = `dst-alpha`;
            blend.color.operation = "add";
            break;
          case 4 /* ADD */:
            blend.color.srcFactor = `one`;
            blend.color.dstFactor = "one";
            blend.color.operation = `add`;
            blend.alpha.srcFactor = `one`;
            blend.alpha.dstFactor = `one`;
            blend.alpha.operation = `add`;
            break;
          case 2 /* ALPHA */:
            blend.color.srcFactor = `src-alpha`;
            blend.color.dstFactor = `one-minus-src-alpha`;
            break;
          case 5 /* BELOW */:
            blend.color.srcFactor = `one-minus-src-alpha`;
            blend.color.dstFactor = "one";
            blend.color.operation = "add";
            break;
          case 6 /* ERASE */:
            blend.color.srcFactor = `zero`;
            blend.color.dstFactor = "one-minus-src-alpha";
            blend.color.operation = "add";
            break;
          case 7 /* MUL */:
            blend.color.srcFactor = `dst`;
            blend.color.dstFactor = `one-minus-src-alpha`;
            blend.color.operation = "add";
            break;
          case 3 /* NORMAL */:
            blend.color.srcFactor = `src-alpha`;
            blend.color.dstFactor = `one-minus-src-alpha`;
            blend.color.operation = `add`;
            break;
          case 10 /* SOFT_ADD */:
            blend.color.srcFactor = `one`;
            blend.color.dstFactor = "one";
            blend.color.operation = `max`;
            blend.alpha.srcFactor = `one`;
            blend.alpha.dstFactor = `one`;
            blend.alpha.operation = `add`;
            break;
          case 8 /* SCREEN */:
            blend.color.srcFactor = "one";
            blend.color.dstFactor = `one-minus-src`;
            blend.color.operation = "add";
            break;
        }
        return blend;
      }
    }

    class TextureMipmapGenerator {
      static mipmapShader = `
    var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));
      struct VertexOutput {
        @builtin(position) position : vec4<f32>;
        @location(0) texCoord : vec2<f32>;
      };
      @vertex
      fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
      }
      @binding(0) @group(0) var imgSampler : sampler;
      @binding(1) @group(0) var img : texture_2d<f32>;
      @fragment
      fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSample(img, imgSampler, texCoord);
        return outColor ;
      }`;
      static pipelineCache = {};
      static pipeline;
      static getMipmapPipeline(texture) {
        let format = texture.format;
        let device = webGPUContext.device;
        let pipeline = TextureMipmapGenerator.pipelineCache[texture.format];
        let mipmapShaderModule;
        if (!pipeline) {
          mipmapShaderModule = device.createShaderModule({
            code: TextureMipmapGenerator.mipmapShader
          });
          let textureLayout = device.createBindGroupLayout({
            entries: [
              {
                binding: 0,
                //TODO : After adding a shadow reflection, it is necessary to know that the vertex is used | the segment is used
                visibility: texture.visibility,
                // use GPUSamplerBindingLayout = { type:`filtering`} error
                sampler: texture.samplerBindingLayout
              },
              {
                binding: 1,
                //TODO : After adding a shadow reflection, it is necessary to know that the vertex is used | the segment is used
                visibility: texture.visibility,
                // use GPUTextureBindingLayout = { sampleType:`float`} error
                texture: texture.textureBindingLayout
              }
            ]
          });
          let layouts = webGPUContext.device.createPipelineLayout({
            bindGroupLayouts: [textureLayout]
          });
          pipeline = GPUContext.createPipeline({
            layout: layouts,
            vertex: {
              module: mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format }]
            }
          });
          TextureMipmapGenerator.pipelineCache[format] = pipeline;
        }
        return pipeline;
      }
      static getMipmapCount(texture) {
        let w = texture.width;
        let h = texture.height;
        let maxSize = Math.max(w, h);
        return 1 + Math.log2(maxSize) | 0;
      }
      // TextureDescriptor should be the descriptor that the texture was created with.
      // This version only works for basic 2D textures.
      static webGPUGenerateMipmap(texture) {
        let gpuDevice = webGPUContext.device;
        let textureDescriptor = texture.textureDescriptor;
        if (!TextureMipmapGenerator.pipeline) {
          const mipmapShaderModule = gpuDevice.createShaderModule({
            code: `
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
          vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
          vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
          @builtin(position) position : vec4<f32>,
          @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
          var output : VertexOutput;
          output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
          output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
          return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
          var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
          return outColor;
        }
      `
          });
          TextureMipmapGenerator.pipeline = gpuDevice.createRenderPipeline({
            layout: `auto`,
            vertex: {
              module: mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [
                {
                  format: textureDescriptor.format
                  // Make sure to use the same format as the texture
                }
              ]
            },
            primitive: {
              topology: "triangle-strip",
              stripIndexFormat: "uint32"
            }
          });
        }
        let sampler;
        if (texture.format == `rgba16float`) {
          sampler = gpuDevice.createSampler({
            minFilter: `nearest`,
            magFilter: `linear`
          });
        } else {
          sampler = gpuDevice.createSampler({
            minFilter: GPUFilterMode.linear,
            magFilter: GPUFilterMode.linear
          });
        }
        let srcView = texture.getGPUTexture().createView({
          baseMipLevel: 0,
          mipLevelCount: 1
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {
          const dstView = texture.getGPUTexture().createView({
            baseMipLevel: i,
            // Make sure we're getting the right mip level...
            mipLevelCount: 1
            // And only selecting one mip level
          });
          const passEncoder = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: dstView,
                // Render pass uses the next mip level as it's render attachment.
                clearValue: [0, 0, 0, 0],
                loadOp: `clear`,
                storeOp: "store"
              }
            ]
          });
          const bindGroup = gpuDevice.createBindGroup({
            layout: TextureMipmapGenerator.pipeline.getBindGroupLayout(0),
            entries: [
              {
                binding: 0,
                resource: sampler
              },
              {
                binding: 1,
                resource: srcView
              }
            ]
          });
          passEncoder.setPipeline(TextureMipmapGenerator.pipeline);
          passEncoder.setBindGroup(0, bindGroup);
          passEncoder.draw(4);
          passEncoder.end();
          srcView = dstView;
        }
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class Texture {
      /**
       * name of texture
       */
      name;
      /**
       * source url
       */
      url;
      /**
       * gpu texture
       */
      gpuTexture;
      /**
       * Return index in texture array
       */
      pid;
      /**
       * GPUTextureView
       */
      view;
      // Assigned later
      /**
       * GPUSampler
       */
      gpuSampler;
      /**
       * GPUSampler for comparison
       */
      gpuSampler_comparison;
      /**
       * GPUTextureFormat
       */
      format;
      /**
       * GPUTextureUsage
       */
      usage;
      /**
       * texture width
       */
      width = 4;
      /**
       * texture height
       */
      height = 4;
      /**
       * depth or layers, default value is 1
       */
      depthOrArrayLayers = 1;
      /**
       * depth or layers, default value is 1
       */
      numberLayer = 1;
      /**
       * GPUTextureViewDescriptor
       */
      viewDescriptor;
      /**
       * GPUTextureDescriptor
       */
      textureDescriptor;
      /**
       * GPUShaderStage
       */
      visibility = GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
      /**
       * GPUTextureBindingLayout, contains viewDimension and multisampled
       */
      textureBindingLayout = {
        viewDimension: `2d`,
        multisampled: false
      };
      /**
       * GPUSamplerBindingLayout
       */
      samplerBindingLayout = {
        type: `filtering`
      };
      /**
       * GPUSamplerBindingLayout
       */
      sampler_comparisonBindingLayout = {
        type: `comparison`
      };
      /**
       * whether to flip the image on the y-axis
       */
      flipY;
      /**
       *  whether is video texture
       */
      isVideoTexture;
      isHDRTexture;
      _useMipmap = false;
      _sourceImageData;
      //****************************************/
      /**
      */
      _addressModeU;
      /**
       * 
       */
      _addressModeV;
      /**
       * Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth
       * coordinates, respectively.
       */
      _addressModeW;
      /**
       * Specifies the sampling behavior when the sample footprint is smaller than or equal to one
       * texel.
       */
      _magFilter;
      /**
       * Specifies the sampling behavior when the sample footprint is larger than one texel.
       */
      _minFilter;
      /**
       * Specifies behavior for sampling between mipmap levels.
       */
      _mipmapFilter;
      /**
      */
      _lodMinClamp;
      /**
       * Specifies the minimum and maximum levels of detail, respectively, used internally when
       * sampling a texture.
       */
      _lodMaxClamp;
      /**
       * When provided the sampler will be a comparison sampler with the specified
       * {@link GPUCompareFunction}.
       * Note: Comparison samplers may use filtering, but the sampling results will be
       * implementation-dependent and may differ from the normal filtering rules.
       */
      _compare;
      /**
       * Specifies the maximum anisotropy value clamp used by the sampler.
       * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range
       * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will
       * be clamped to the maximum value that the platform supports.
       */
      _maxAnisotropy;
      /**
       *  mipmap Count, default value is 1
       */
      mipmapCount = 1;
      _textureChange = false;
      /**
       * Create a texture2D
       * @param width size of texture width
       * @param height height of texture width
       * @param numberLayer number layer of texture
       * @returns
       */
      constructor(width = 32, height = 32, numberLayer = 1) {
        this.width = width;
        this.height = height;
        this.numberLayer = numberLayer;
        this.minFilter = GPUFilterMode.linear;
        this.magFilter = GPUFilterMode.linear;
        this.mipmapFilter = GPUFilterMode.linear;
        this.addressModeU = GPUAddressMode.repeat;
        this.addressModeV = GPUAddressMode.repeat;
      }
      init() {
        let self = this;
        if (self[`internalCreateBindingLayoutDesc`]) {
          self[`internalCreateBindingLayoutDesc`]();
        }
        if (self[`internalCreateTexture`]) {
          self[`internalCreateTexture`]();
        }
        if (self[`internalCreateView`]) {
          self[`internalCreateView`]();
        }
        if (self[`internalCreateSampler`]) {
          self[`internalCreateSampler`]();
        }
        return this;
      }
      /**
       * creatTextureDescriptor
       */
      createTextureDescriptor(width, height, mipLevelCount, format, usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.STORAGE_BINDING, sizeCount = 1, sampleCount = 0) {
        this.width = width;
        this.height = height;
        this.format = format;
        this.usage = usage;
        this.textureDescriptor = {
          size: [width, height, sizeCount],
          mipLevelCount,
          format,
          usage,
          label: `${this.name + this.width + this.height + this.format}`
        };
        if (sampleCount > 0) {
          this.textureDescriptor.sampleCount = sampleCount;
        }
        if (sizeCount > 1) {
          this.viewDescriptor = {
            dimension: `2d-array`
          };
        } else {
          this.viewDescriptor = {
            dimension: this.textureBindingLayout.viewDimension,
            mipLevelCount,
            baseMipLevel: 0
          };
        }
      }
      generate(imageBitmap) {
        let width = 32;
        let height = 32;
        if ("width" in imageBitmap) {
          width = imageBitmap.width;
          height = imageBitmap.height;
        }
        if (width < 32 || height < 32) {
          console.log(imageBitmap["name"] + "Size must be greater than 32!");
        }
        this.width = width;
        this.height = height;
        this.createTexture(imageBitmap);
      }
      createTexture(imageBitmap) {
        this._sourceImageData = imageBitmap;
        this.updateTextureDescription();
        this.updateGPUTexture();
        let device = webGPUContext.device;
        if (this.gpuTexture instanceof GPUTexture)
          device.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]);
        if (this.useMipmap) {
          TextureMipmapGenerator.webGPUGenerateMipmap(this);
        }
      }
      /**
       * enable/disable mipmap
       */
      get useMipmap() {
        return this._useMipmap;
      }
      /**
       * get mipmap
       */
      set useMipmap(value) {
        if (value) {
          this.samplerBindingLayout.type = "filtering";
          if (this._useMipmap == false && this._sourceImageData) {
            this._useMipmap = true;
            this.updateTextureDescription();
            this.updateGPUTexture();
            let device = webGPUContext.device;
            if (this.gpuTexture instanceof GPUTexture)
              device.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]);
            TextureMipmapGenerator.webGPUGenerateMipmap(this);
          }
        } else {
          this.samplerBindingLayout.type = "non-filtering";
          if (this._useMipmap == true && this._sourceImageData) {
            this._useMipmap = false;
            this.updateTextureDescription();
            this.updateGPUTexture();
            let device = webGPUContext.device;
            if (this.gpuTexture instanceof GPUTexture)
              device.queue.copyExternalImageToTexture({ source: this._sourceImageData }, { texture: this.gpuTexture }, [this.width, this.height]);
          }
        }
        this._textureChange = true;
        this._useMipmap = value;
        this.noticeChange();
      }
      get sourceImageData() {
        return this._sourceImageData;
      }
      getMipmapCount() {
        let w = this.width;
        let h = this.height;
        let maxSize = Math.max(w, h);
        return 1 + Math.log2(maxSize) | 0;
      }
      updateTextureDescription() {
        this.mipmapCount = Math.floor(this.useMipmap ? this.getMipmapCount() : 1);
        this.createTextureDescriptor(this.width, this.height, this.mipmapCount, this.format);
      }
      updateGPUTexture() {
        if (this.gpuTexture) {
          if (this.gpuTexture instanceof GPUTexture)
            this.gpuTexture.destroy();
        }
        this.gpuTexture = null;
        this.view = null;
        this.gpuTexture = this.getGPUTexture();
      }
      /**
       * create or get GPUTexture
       * @returns GPUTexture
       */
      getGPUTexture() {
        if (!this.gpuTexture) {
          this.gpuTexture = webGPUContext.device.createTexture(this.textureDescriptor);
        }
        return this.gpuTexture;
      }
      /**
       * create or get GPUTextureView
       * @returns GPUTextureView | GPUExternalTexture
       */
      getGPUView(index = 0) {
        if (!this.view) {
          this.gpuTexture = this.getGPUTexture();
          if (this.gpuTexture instanceof GPUTexture) {
            this.view = this.gpuTexture.createView(this.viewDescriptor);
            this.view.label = this.name;
          }
        }
        return this.view;
      }
      _stateChangeRef = /* @__PURE__ */ new Map();
      bindStateChange(fun, ref) {
        this._stateChangeRef.set(ref, fun);
      }
      unBindStateChange(ref) {
        this._stateChangeRef.delete(ref);
      }
      noticeChange() {
        this.gpuSampler = webGPUContext.device.createSampler(this);
        this._stateChangeRef.forEach((v, k) => {
          v();
        });
      }
      /**
       * release the texture
       */
      destroy(force) {
        if (force && this.gpuTexture instanceof GPUTexture) {
          this.gpuSampler = null;
          this.gpuSampler_comparison = null;
          this.textureBindingLayout = null;
          this.textureDescriptor = null;
          this.gpuTexture.destroy();
          this.gpuTexture = null;
        }
        this._stateChangeRef.clear();
      }
      get addressModeU() {
        return this._addressModeU;
      }
      set addressModeU(value) {
        if (this._addressModeU != value) {
          this._addressModeU = value;
          this.noticeChange();
        }
      }
      get addressModeV() {
        return this._addressModeV;
      }
      set addressModeV(value) {
        if (this._addressModeV != value) {
          this._addressModeV = value;
          this.noticeChange();
        }
      }
      get addressModeW() {
        return this._addressModeW;
      }
      set addressModeW(value) {
        if (this._addressModeW != value) {
          this._addressModeW = value;
          this.noticeChange();
        }
      }
      get magFilter() {
        return this._magFilter;
      }
      set magFilter(value) {
        if (this._magFilter != value) {
          this._magFilter = value;
          this.noticeChange();
        }
      }
      get minFilter() {
        return this._minFilter;
      }
      set minFilter(value) {
        if (this._minFilter != value) {
          this._minFilter = value;
          this.noticeChange();
        }
      }
      get mipmapFilter() {
        return this._mipmapFilter;
      }
      set mipmapFilter(value) {
        if (this._mipmapFilter != value) {
          this._mipmapFilter = value;
          this.noticeChange();
        }
      }
      get lodMinClamp() {
        return this._lodMinClamp;
      }
      set lodMinClamp(value) {
        if (this._lodMinClamp != value) {
          this._lodMinClamp = value;
          this.noticeChange();
        }
      }
      get lodMaxClamp() {
        return this._lodMaxClamp;
      }
      set lodMaxClamp(value) {
        if (this._lodMaxClamp != value) {
          this._lodMaxClamp = value;
          this.noticeChange();
        }
      }
      get compare() {
        return this._compare;
      }
      set compare(value) {
        if (this._compare != value) {
          this._compare = value;
          this.noticeChange();
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      set maxAnisotropy(value) {
        if (this._maxAnisotropy != value) {
          this._maxAnisotropy = value;
          this.noticeChange();
        }
      }
      static _texs = [];
      static delayDestroyTexture(tex) {
        if (!this._texs.includes(tex)) {
          this._texs.push(tex);
        }
      }
      static destroyTexture() {
        if (this._texs.length > 0) {
          while (this._texs.length > 0) {
            this._texs.shift().destroy();
          }
        }
      }
    }

    class BitmapTexture2DArray extends Texture {
      _bitmapTextures;
      constructor(width, height, numberLayer) {
        super(width, height, numberLayer);
        this.format = GPUTextureFormat.rgba8unorm;
        this.mipmapCount = 1;
        this._bitmapTextures = [];
        this.init();
      }
      /**
       * fill self by set texture list
       * @param texs array of BitmapTexture2D
       * @returns
       */
      setTextures(texs) {
        this._bitmapTextures.length = 0;
        for (let i = 0; i < texs.length; i++) {
          const tex = texs[i];
          this.addTexture(tex);
        }
      }
      /**
       * add one BitmapTexture2D to this
       * @param bitmapTexture the bitmapTexture2D be added
       * @returns
       */
      addTexture(bitmapTexture) {
        if (bitmapTexture.width != this.width || bitmapTexture.height != this.height) {
          console.error("bitmap texture must match bitmapTextureArray size!");
        }
        bitmapTexture.pid = this._bitmapTextures.length;
        this._bitmapTextures.push(bitmapTexture);
        this.updateTexture();
      }
      /**
      * remove one BitmapTexture2D from this
      * @param bitmapTexture the bitmapTexture2D be removed
      * @returns
      */
      removeTexture(bitmapTexture) {
        let index = this._bitmapTextures.indexOf(bitmapTexture);
        if (index != -1) {
          this._bitmapTextures.splice(index, 1);
          for (let i = 0; i < this._bitmapTextures.length; i++) {
            const bitmapTexture2 = this._bitmapTextures[i];
            bitmapTexture2.pid = i;
          }
        }
      }
      /**
       * @internal
       */
      updateTexture() {
        let encoder = GPUContext.beginCommandEncoder();
        for (let i = 0; i < this._bitmapTextures.length; i++) {
          let bitmapTexture = this._bitmapTextures[i];
          encoder.copyTextureToTexture(
            {
              texture: bitmapTexture.getGPUTexture(),
              mipLevel: 0,
              origin: { x: 0, y: 0, z: 0 }
            },
            {
              texture: this.getGPUTexture(),
              mipLevel: 0,
              origin: { x: 0, y: 0, z: i }
            },
            {
              width: this.width,
              height: this.height,
              depthOrArrayLayers: 1
            }
          );
        }
        GPUContext.endCommandEncoder(encoder);
      }
      internalCreateBindingLayoutDesc() {
        this.textureBindingLayout.viewDimension = `2d-array`;
        this.samplerBindingLayout.type = `filtering`;
        this.minFilter = GPUFilterMode.linear;
        this.magFilter = GPUFilterMode.linear;
      }
      internalCreateTexture() {
        this.textureDescriptor = {
          format: this.format,
          size: { width: this.width, height: this.height, depthOrArrayLayers: this.numberLayer },
          dimension: "2d",
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING
        };
        this.gpuTexture = this.getGPUTexture();
      }
      internalCreateView() {
        this.viewDescriptor = {
          dimension: `2d-array`
        };
        this.view = this.getGPUView();
      }
      internalCreateSampler() {
        this.gpuSampler = webGPUContext.device.createSampler(this);
      }
    }

    class IESProfiles {
      static use = false;
      static iesTexture;
      static ies_list = [];
      _iesTexture;
      index = 0;
      constructor() {
      }
      /**
       * create ies image from ies file
       */
      generateIES(file) {
      }
      set IESTexture(texture) {
        this._iesTexture = texture;
        texture.addressModeU = GPUAddressMode.repeat;
        texture.addressModeV = GPUAddressMode.repeat;
        texture.addressModeW = GPUAddressMode.repeat;
        if (IESProfiles.ies_list.indexOf(this) == -1) {
          this.index = IESProfiles.ies_list.length;
          IESProfiles.ies_list.push(this);
          if (!IESProfiles.iesTexture) {
            IESProfiles.create(texture.width, texture.height);
          }
          IESProfiles.iesTexture.addTexture(texture);
        }
      }
      get IESTexture() {
        return this._iesTexture;
      }
      static create(width, height) {
        let count = 48;
        this.iesTexture = new BitmapTexture2DArray(width, height, count);
      }
    }

    class GLSLLexerToken {
      Type = 0;
      Line = 0;
      Colume = 0;
      Literal = "";
      constructor(type = 0 /* EOF */, literal = "\0") {
        this.Type = type;
        this.Literal = literal;
      }
      /**
       * @returns determin the type is same to token
       */
      isTypeEqual(type) {
        return this.Type == type;
      }
      /**
       * @returns determin the value is same
       */
      isLiteralEqual(literal) {
        return this.Literal == literal;
      }
      /**
       * @returns determin it's builtin type
       */
      isBuiltinType() {
        return this.Type > 33 /* BeginBuiltinType */ && this.Type < 101 /* EndBuiltinType */;
      }
      /**
       * @returns determin it's a data type
       */
      isDataType() {
        return this.Type == 1 /* IDENT */ || this.isBuiltinType();
      }
      /**
       * @returns determin it's a operation
       */
      isOperation() {
        return this.Type > 102 /* BeginOperation */ && this.Type < 127 /* EndOperation */;
      }
      /**
       * @returns determin it's a assign operation
       */
      isAssignOperation() {
        return this.Type > 128 /* BeginAssignOperation */ && this.Type < 133 /* EndAssignOperation */;
      }
      /**
       * The priority of the current operator
       */
      get nOperationPriorityLevel() {
        switch (this.Type) {
          case 26 /* LEFTSAMLL */:
            return 1;
          case 27 /* RIGHTSAMLL */:
            return 1;
          case 125 /* DOT */:
            return 2;
          case 110 /* NOT */:
            return 3;
          case 114 /* BITNOT */:
            return 3;
          case 105 /* MUL */:
            return 4;
          case 106 /* DIV */:
            return 4;
          case 103 /* ADD */:
            return 5;
          case 104 /* SUB */:
            return 5;
          case 115 /* BITSHIFT_L */:
            return 6;
          case 116 /* BITSHIFT_R */:
            return 6;
          case 119 /* GREATER */:
            return 7;
          case 120 /* GREATEREQUAL */:
            return 7;
          case 122 /* LESS */:
            return 7;
          case 123 /* LESSEQUAL */:
            return 7;
          case 121 /* EQUAL */:
            return 8;
          case 124 /* NOTEQUAL */:
            return 8;
          case 111 /* BITAND */:
            return 9;
          case 113 /* BITXOR */:
            return 10;
          case 112 /* BITOR */:
            return 11;
          case 107 /* AND */:
            return 12;
          case 109 /* XOR */:
            return 13;
          case 108 /* OR */:
            return 14;
          case 24 /* QUEMARK */:
            return 15;
          case 126 /* ASSIGN */:
            return 16;
          case 129 /* ADDASSIGN */:
            return 16;
          case 130 /* SUBASSIGN */:
            return 16;
          case 131 /* MULASSIGN */:
            return 16;
          case 132 /* DIVASSIGN */:
            return 16;
        }
        return 99;
      }
    }
    var TokenType = /* @__PURE__ */ ((TokenType2) => {
      TokenType2[TokenType2["EOF"] = 0] = "EOF";
      TokenType2[TokenType2["IDENT"] = 1] = "IDENT";
      TokenType2[TokenType2["VOID"] = 2] = "VOID";
      TokenType2[TokenType2["CONST"] = 3] = "CONST";
      TokenType2[TokenType2["LAYOUT"] = 4] = "LAYOUT";
      TokenType2[TokenType2["PRECISION"] = 5] = "PRECISION";
      TokenType2[TokenType2["ATTRIBUTE"] = 6] = "ATTRIBUTE";
      TokenType2[TokenType2["UNIFORM"] = 7] = "UNIFORM";
      TokenType2[TokenType2["VARYING"] = 8] = "VARYING";
      TokenType2[TokenType2["INVARIANT"] = 9] = "INVARIANT";
      TokenType2[TokenType2["IN"] = 10] = "IN";
      TokenType2[TokenType2["OUT"] = 11] = "OUT";
      TokenType2[TokenType2["INOUT"] = 12] = "INOUT";
      TokenType2[TokenType2["IF"] = 13] = "IF";
      TokenType2[TokenType2["ELSE"] = 14] = "ELSE";
      TokenType2[TokenType2["FOR"] = 15] = "FOR";
      TokenType2[TokenType2["WHILE"] = 16] = "WHILE";
      TokenType2[TokenType2["DO"] = 17] = "DO";
      TokenType2[TokenType2["BREAK"] = 18] = "BREAK";
      TokenType2[TokenType2["RETURN"] = 19] = "RETURN";
      TokenType2[TokenType2["CONTINUE"] = 20] = "CONTINUE";
      TokenType2[TokenType2["STRUCT"] = 21] = "STRUCT";
      TokenType2[TokenType2["COMMA"] = 22] = "COMMA";
      TokenType2[TokenType2["COLON"] = 23] = "COLON";
      TokenType2[TokenType2["QUEMARK"] = 24] = "QUEMARK";
      TokenType2[TokenType2["SEMICOLON"] = 25] = "SEMICOLON";
      TokenType2[TokenType2["LEFTSAMLL"] = 26] = "LEFTSAMLL";
      TokenType2[TokenType2["RIGHTSAMLL"] = 27] = "RIGHTSAMLL";
      TokenType2[TokenType2["LEFTMEDI"] = 28] = "LEFTMEDI";
      TokenType2[TokenType2["RIGHTMEDI"] = 29] = "RIGHTMEDI";
      TokenType2[TokenType2["LEFTBIG"] = 30] = "LEFTBIG";
      TokenType2[TokenType2["RIGHTBIG"] = 31] = "RIGHTBIG";
      TokenType2[TokenType2["LITERAL"] = 32] = "LITERAL";
      TokenType2[TokenType2["BeginBuiltinType"] = 33] = "BeginBuiltinType";
      TokenType2[TokenType2["INT"] = 34] = "INT";
      TokenType2[TokenType2["INT_ARRAY"] = 35] = "INT_ARRAY";
      TokenType2[TokenType2["UINT"] = 36] = "UINT";
      TokenType2[TokenType2["UINT_ARRAY"] = 37] = "UINT_ARRAY";
      TokenType2[TokenType2["BOOL"] = 38] = "BOOL";
      TokenType2[TokenType2["BOOL_ARRAY"] = 39] = "BOOL_ARRAY";
      TokenType2[TokenType2["FLOAT"] = 40] = "FLOAT";
      TokenType2[TokenType2["FLOAT_ARRAY"] = 41] = "FLOAT_ARRAY";
      TokenType2[TokenType2["DOUBLE"] = 42] = "DOUBLE";
      TokenType2[TokenType2["DOUBLE_ARRAY"] = 43] = "DOUBLE_ARRAY";
      TokenType2[TokenType2["VEC2"] = 44] = "VEC2";
      TokenType2[TokenType2["VEC2_ARRAY"] = 45] = "VEC2_ARRAY";
      TokenType2[TokenType2["VEC3"] = 46] = "VEC3";
      TokenType2[TokenType2["VEC3_ARRAY"] = 47] = "VEC3_ARRAY";
      TokenType2[TokenType2["VEC4"] = 48] = "VEC4";
      TokenType2[TokenType2["VEC4_ARRAY"] = 49] = "VEC4_ARRAY";
      TokenType2[TokenType2["BVEC2"] = 50] = "BVEC2";
      TokenType2[TokenType2["BVEC2_ARRAY"] = 51] = "BVEC2_ARRAY";
      TokenType2[TokenType2["BVEC3"] = 52] = "BVEC3";
      TokenType2[TokenType2["BVEC3_ARRAY"] = 53] = "BVEC3_ARRAY";
      TokenType2[TokenType2["BVEC4"] = 54] = "BVEC4";
      TokenType2[TokenType2["BVEC4_ARRAY"] = 55] = "BVEC4_ARRAY";
      TokenType2[TokenType2["IVEC2"] = 56] = "IVEC2";
      TokenType2[TokenType2["IVEC2_ARRAY"] = 57] = "IVEC2_ARRAY";
      TokenType2[TokenType2["IVEC3"] = 58] = "IVEC3";
      TokenType2[TokenType2["IVEC3_ARRAY"] = 59] = "IVEC3_ARRAY";
      TokenType2[TokenType2["IVEC4"] = 60] = "IVEC4";
      TokenType2[TokenType2["IVEC4_ARRAY"] = 61] = "IVEC4_ARRAY";
      TokenType2[TokenType2["UVEC2"] = 62] = "UVEC2";
      TokenType2[TokenType2["UVEC2_ARRAY"] = 63] = "UVEC2_ARRAY";
      TokenType2[TokenType2["UVEC3"] = 64] = "UVEC3";
      TokenType2[TokenType2["UVEC3_ARRAY"] = 65] = "UVEC3_ARRAY";
      TokenType2[TokenType2["UVEC4"] = 66] = "UVEC4";
      TokenType2[TokenType2["UVEC4_ARRAY"] = 67] = "UVEC4_ARRAY";
      TokenType2[TokenType2["MAT2x2"] = 68] = "MAT2x2";
      TokenType2[TokenType2["MAT2x2_ARRAY"] = 69] = "MAT2x2_ARRAY";
      TokenType2[TokenType2["MAT2x3"] = 70] = "MAT2x3";
      TokenType2[TokenType2["MAT2x3_ARRAY"] = 71] = "MAT2x3_ARRAY";
      TokenType2[TokenType2["MAT2x4"] = 72] = "MAT2x4";
      TokenType2[TokenType2["MAT2x4_ARRAY"] = 73] = "MAT2x4_ARRAY";
      TokenType2[TokenType2["MAT3x2"] = 74] = "MAT3x2";
      TokenType2[TokenType2["MAT3x2_ARRAY"] = 75] = "MAT3x2_ARRAY";
      TokenType2[TokenType2["MAT3x3"] = 76] = "MAT3x3";
      TokenType2[TokenType2["MAT3x3_ARRAY"] = 77] = "MAT3x3_ARRAY";
      TokenType2[TokenType2["MAT3x4"] = 78] = "MAT3x4";
      TokenType2[TokenType2["MAT3x4_ARRAY"] = 79] = "MAT3x4_ARRAY";
      TokenType2[TokenType2["MAT4x2"] = 80] = "MAT4x2";
      TokenType2[TokenType2["MAT4x2_ARRAY"] = 81] = "MAT4x2_ARRAY";
      TokenType2[TokenType2["MAT4x3"] = 82] = "MAT4x3";
      TokenType2[TokenType2["MAT4x3_ARRAY"] = 83] = "MAT4x3_ARRAY";
      TokenType2[TokenType2["MAT4x4"] = 84] = "MAT4x4";
      TokenType2[TokenType2["MAT4x4_ARRAY"] = 85] = "MAT4x4_ARRAY";
      TokenType2[TokenType2["SAMPLER"] = 86] = "SAMPLER";
      TokenType2[TokenType2["SAMPLER_1D"] = 87] = "SAMPLER_1D";
      TokenType2[TokenType2["SAMPLER_2D"] = 88] = "SAMPLER_2D";
      TokenType2[TokenType2["SAMPLER_3D"] = 89] = "SAMPLER_3D";
      TokenType2[TokenType2["SAMPLER_CUBE"] = 90] = "SAMPLER_CUBE";
      TokenType2[TokenType2["SAMPLER_SHADOW"] = 91] = "SAMPLER_SHADOW";
      TokenType2[TokenType2["SAMPLER_1D_SHADOW"] = 92] = "SAMPLER_1D_SHADOW";
      TokenType2[TokenType2["SAMPLER_2D_SHADOW"] = 93] = "SAMPLER_2D_SHADOW";
      TokenType2[TokenType2["TEXTURE_1D"] = 94] = "TEXTURE_1D";
      TokenType2[TokenType2["TEXTURE_1D_ARRAY"] = 95] = "TEXTURE_1D_ARRAY";
      TokenType2[TokenType2["TEXTURE_2D"] = 96] = "TEXTURE_2D";
      TokenType2[TokenType2["TEXTURE_2D_ARRAY"] = 97] = "TEXTURE_2D_ARRAY";
      TokenType2[TokenType2["TEXTURE_3D"] = 98] = "TEXTURE_3D";
      TokenType2[TokenType2["TEXTURE_CUBE"] = 99] = "TEXTURE_CUBE";
      TokenType2[TokenType2["TEXTURE_CUBE_ARRAY"] = 100] = "TEXTURE_CUBE_ARRAY";
      TokenType2[TokenType2["EndBuiltinType"] = 101] = "EndBuiltinType";
      TokenType2[TokenType2["BeginOperation"] = 102] = "BeginOperation";
      TokenType2[TokenType2["ADD"] = 103] = "ADD";
      TokenType2[TokenType2["SUB"] = 104] = "SUB";
      TokenType2[TokenType2["MUL"] = 105] = "MUL";
      TokenType2[TokenType2["DIV"] = 106] = "DIV";
      TokenType2[TokenType2["AND"] = 107] = "AND";
      TokenType2[TokenType2["OR"] = 108] = "OR";
      TokenType2[TokenType2["XOR"] = 109] = "XOR";
      TokenType2[TokenType2["NOT"] = 110] = "NOT";
      TokenType2[TokenType2["BITAND"] = 111] = "BITAND";
      TokenType2[TokenType2["BITOR"] = 112] = "BITOR";
      TokenType2[TokenType2["BITXOR"] = 113] = "BITXOR";
      TokenType2[TokenType2["BITNOT"] = 114] = "BITNOT";
      TokenType2[TokenType2["BITSHIFT_L"] = 115] = "BITSHIFT_L";
      TokenType2[TokenType2["BITSHIFT_R"] = 116] = "BITSHIFT_R";
      TokenType2[TokenType2["INC"] = 117] = "INC";
      TokenType2[TokenType2["DEC"] = 118] = "DEC";
      TokenType2[TokenType2["GREATER"] = 119] = "GREATER";
      TokenType2[TokenType2["GREATEREQUAL"] = 120] = "GREATEREQUAL";
      TokenType2[TokenType2["EQUAL"] = 121] = "EQUAL";
      TokenType2[TokenType2["LESS"] = 122] = "LESS";
      TokenType2[TokenType2["LESSEQUAL"] = 123] = "LESSEQUAL";
      TokenType2[TokenType2["NOTEQUAL"] = 124] = "NOTEQUAL";
      TokenType2[TokenType2["DOT"] = 125] = "DOT";
      TokenType2[TokenType2["ASSIGN"] = 126] = "ASSIGN";
      TokenType2[TokenType2["EndOperation"] = 127] = "EndOperation";
      TokenType2[TokenType2["BeginAssignOperation"] = 128] = "BeginAssignOperation";
      TokenType2[TokenType2["ADDASSIGN"] = 129] = "ADDASSIGN";
      TokenType2[TokenType2["SUBASSIGN"] = 130] = "SUBASSIGN";
      TokenType2[TokenType2["MULASSIGN"] = 131] = "MULASSIGN";
      TokenType2[TokenType2["DIVASSIGN"] = 132] = "DIVASSIGN";
      TokenType2[TokenType2["EndAssignOperation"] = 133] = "EndAssignOperation";
      return TokenType2;
    })(TokenType || {});

    class Reader {
      _char;
      _line;
      _column;
      _source;
      _currPosition;
      _nextPosition;
      constructor(source) {
        this.reset(source);
      }
      reset(source) {
        this._char = "";
        this._line = 0;
        this._column = 0;
        this._source = source;
        this._currPosition = 0;
        this._nextPosition = 0;
      }
      get source() {
        return this._source;
      }
      getChar() {
        return this._char;
      }
      get currPosition() {
        return this._currPosition;
      }
      peekChar() {
        return this._nextPosition >= this._source.length ? "\0" : this._source[this._nextPosition];
      }
      readChar() {
        this._char = this._nextPosition >= this._source.length ? "\0" : this._source[this._nextPosition];
        if (this._char !== "\n") {
          this._column++;
        } else {
          this._line++;
          this._column = 0;
        }
        this._currPosition = this._nextPosition;
        this._nextPosition++;
      }
      readCharAndSkipWhitespace() {
        this.readChar();
        this.skipWhitespace();
      }
      readIdentifier() {
        var pos = this._currPosition;
        while (this.isIdentifier(this._char)) {
          this.readChar();
        }
        return this._source.substring(pos, this._currPosition);
      }
      isIdentifier(char) {
        var code = char.charCodeAt(0);
        return 97 <= code && code <= 122 || 65 <= code && code <= 90 || 48 <= code && code <= 57 || code == 95;
      }
      skipWhitespace() {
        while (this.IsWhitespace(this._char)) {
          this.readChar();
        }
      }
      IsWhitespace(char) {
        return char === " " || char === "	" || char === "\r" || char === "\n";
      }
      skipComment() {
        while (this._char !== "\n" && this._char !== "\0") {
          this.readChar();
        }
        this.skipWhitespace();
      }
      skipMultilineComment() {
        if (this._char !== "/" && this.peekChar() !== "*") {
          return;
        }
        this.readChar();
        this.readChar();
        for (let nCount = 1; nCount > 0 && this._char !== "\0"; ) {
          this.readChar();
          if (this._char === "/" && this.peekChar() === "*") {
            nCount++;
            this.readChar();
            continue;
          } else if (this._char === "*" && this.peekChar() === "/") {
            nCount--;
            this.readChar();
            continue;
          }
        }
        this.readChar();
        this.readChar();
        this.skipWhitespace();
      }
      isDigit(char) {
        var code = char.charCodeAt(0);
        return 48 <= code && code <= 57;
      }
      readNumber() {
        var pos = this._currPosition;
        while (this.isDigit(this._char)) {
          this.readChar();
        }
        if (this._char === ".") {
          this.readChar();
          while (this.isDigit(this._char)) {
            this.readChar();
          }
        }
        return this._source.substring(pos, this._currPosition);
      }
      readValue() {
        if (this.isDigit(this._char)) {
          return this.readNumber();
        }
        return this.readIdentifier();
      }
      readLine() {
        var pos = this._currPosition;
        var index = this._source.indexOf("\n", this._currPosition);
        if (index == -1) {
          index = this._source.length;
        }
        this._line++;
        this._column = 0;
        this._currPosition = index;
        this._nextPosition = index + 1;
        return this._source.substring(pos, index + 1);
      }
    }

    class GLSLLexer extends Reader {
      _tokenPosition = 0;
      _tokens = [];
      constructor(input) {
        super(input.source);
        this.parse();
      }
      skipToken(offset) {
        this._tokenPosition += offset;
      }
      peekToken(offset) {
        if (this._tokenPosition + offset >= this._tokens.length) {
          return new GLSLLexerToken(TokenType.EOF, "\0");
        }
        return this._tokens[this._tokenPosition + offset];
      }
      GetNextToken() {
        if (this._tokenPosition >= this._tokens.length) {
          return new GLSLLexerToken(TokenType.EOF, "\0");
        }
        let result = this._tokens[this._tokenPosition];
        this._tokenPosition++;
        return result;
      }
      get currTokenPosition() {
        return this._tokenPosition;
      }
      // start to parse
      parse() {
        this.readChar();
        this._tokens = new Array();
        var token;
        do {
          token = this.nextToken();
          this._tokens.push(token);
        } while (token.Type != TokenType.EOF);
      }
      // get next token
      nextToken() {
        this.skipWhitespace();
        if (this._char === "/") {
          if (this.peekChar() === "/") {
            this.skipComment();
            return this.nextToken();
          }
          if (this.peekChar() === "*") {
            this.skipMultilineComment();
            return this.nextToken();
          }
        }
        var token = new GLSLLexerToken();
        token.Line = this._line;
        token.Colume = this._column;
        switch (this._char) {
          case "\0":
            token.Type = TokenType.EOF;
            token.Literal = "EOF";
            break;
          case ".":
            token.Type = TokenType.DOT;
            token.Literal = ".";
            break;
          case ",":
            token.Type = TokenType.COMMA;
            token.Literal = ",";
            break;
          case ":":
            token.Type = TokenType.COLON;
            token.Literal = ":";
            break;
          case "?":
            token.Type = TokenType.QUEMARK;
            token.Literal = "?";
            break;
          case ";":
            token.Type = TokenType.SEMICOLON;
            token.Literal = ";";
            break;
          case "(":
            token.Type = TokenType.LEFTSAMLL;
            token.Literal = "(";
            break;
          case ")":
            token.Type = TokenType.RIGHTSAMLL;
            token.Literal = ")";
            break;
          case "[":
            token.Type = TokenType.LEFTMEDI;
            token.Literal = "[";
            break;
          case "]":
            token.Type = TokenType.RIGHTMEDI;
            token.Literal = "]";
            break;
          case "{":
            token.Type = TokenType.LEFTBIG;
            token.Literal = "{";
            break;
          case "}":
            token.Type = TokenType.RIGHTBIG;
            token.Literal = "}";
            break;
          case "+":
            if (this.peekChar() === "+") {
              this.readChar();
              token.Type = TokenType.INC;
              token.Literal = "++";
              break;
            } else if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.ADDASSIGN;
              token.Literal = "+=";
              break;
            }
            token.Type = TokenType.ADD;
            token.Literal = "+";
            break;
          case "-":
            if (this.peekChar() === "-") {
              this.readChar();
              token.Type = TokenType.DEC;
              token.Literal = "--";
              break;
            } else if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.SUBASSIGN;
              token.Literal = "-=";
              break;
            }
            token.Type = TokenType.SUB;
            token.Literal = "-";
            break;
          case "*":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.MULASSIGN;
              token.Literal = "*=";
              break;
            }
            token.Type = TokenType.MUL;
            token.Literal = "*";
            break;
          case "/":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.DIVASSIGN;
              token.Literal = "/=";
              break;
            }
            token.Type = TokenType.DIV;
            token.Literal = "/";
            break;
          case "&":
            if (this.peekChar() === "&") {
              this.readChar();
              token.Type = TokenType.AND;
              token.Literal = "&&";
              break;
            }
            token.Type = TokenType.BITAND;
            token.Literal = "&";
            break;
          case "|":
            if (this.peekChar() === "|") {
              this.readChar();
              token.Type = TokenType.OR;
              token.Literal = "||";
              break;
            }
            token.Type = TokenType.BITOR;
            token.Literal = "&";
            break;
          case "^":
            token.Type = TokenType.BITXOR;
            token.Literal = "^";
            break;
          case "!":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.NOTEQUAL;
              token.Literal = "!=";
              break;
            }
            token.Type = TokenType.NOT;
            token.Literal = "!";
            break;
          case ">":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.GREATEREQUAL;
              token.Literal = ">=";
              break;
            } else if (this.peekChar() === ">") {
              this.readChar();
              token.Type = TokenType.BITSHIFT_R;
              token.Literal = ">>";
              break;
            }
            token.Type = TokenType.GREATER;
            token.Literal = ">";
            break;
          case "=":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.EQUAL;
              token.Literal = "==";
              break;
            }
            token.Type = TokenType.ASSIGN;
            token.Literal = "=";
            break;
          case "<":
            if (this.peekChar() === "=") {
              this.readChar();
              token.Type = TokenType.LESSEQUAL;
              token.Literal = "<=";
              break;
            } else if (this.peekChar() === "<") {
              this.readChar();
              token.Type = TokenType.BITSHIFT_L;
              token.Literal = "<<";
              break;
            }
            token.Type = TokenType.LESS;
            token.Literal = "<";
            break;
          default:
            if (this.isDigit(this._char)) {
              return this.readDecimal();
            }
            token.Literal = this.readIdentifier();
            token.Type = this.lookupIdentifier(token.Literal);
            if (this.getChar() == "[" && this.peekChar() == "]" && token.isBuiltinType()) {
              token.Type++;
              token.Literal += "[]";
              this.readChar();
              this.readChar();
            }
            return token;
        }
        this.readChar();
        return token;
      }
      // read dicimal
      readDecimal() {
        var token = new GLSLLexerToken();
        token.Line = this._line;
        token.Colume = this._column;
        token.Type = TokenType.LITERAL;
        var integer = this.readNumber();
        if (this._char === "e") {
          token.Literal = integer + this._char;
          this.readChar();
          token.Literal += this._char;
          this.readChar();
          token.Literal += this.readNumber();
          token.Type = TokenType.LITERAL;
          return token;
        }
        if (this._char === "u") {
          this.readChar();
          token.Type = TokenType.LITERAL;
          token.Literal = integer + "u";
          return token;
        }
        if (this._char === "f") {
          this.readChar();
          token.Type = TokenType.LITERAL;
          token.Literal = integer + "f";
          return token;
        }
        token.Type = TokenType.LITERAL;
        token.Literal = integer;
        return token;
      }
      lookupIdentifier(literal) {
        switch (literal) {
          case "void":
            return TokenType.VOID;
          case "int":
            return TokenType.INT;
          case "uint":
            return TokenType.UINT;
          case "bool":
            return TokenType.BOOL;
          case "true":
            return TokenType.BOOL;
          case "false":
            return TokenType.BOOL;
          case "float":
            return TokenType.FLOAT;
          case "vec2":
            return TokenType.VEC2;
          case "vec3":
            return TokenType.VEC3;
          case "vec4":
            return TokenType.VEC4;
          case "bvec2":
            return TokenType.BVEC2;
          case "bvec3":
            return TokenType.BVEC3;
          case "bvec4":
            return TokenType.BVEC4;
          case "ivec2":
            return TokenType.IVEC2;
          case "ivec3":
            return TokenType.IVEC3;
          case "ivec4":
            return TokenType.IVEC4;
          case "uvec2":
            return TokenType.UVEC2;
          case "uvec3":
            return TokenType.UVEC3;
          case "uvec4":
            return TokenType.UVEC4;
          case "mat2":
            return TokenType.MAT2x2;
          case "mat2x2":
            return TokenType.MAT2x2;
          case "mat2x3":
            return TokenType.MAT2x3;
          case "mat2x4":
            return TokenType.MAT2x4;
          case "mat3":
            return TokenType.MAT3x3;
          case "mat3x2":
            return TokenType.MAT3x2;
          case "mat3x3":
            return TokenType.MAT3x3;
          case "mat3x4":
            return TokenType.MAT3x4;
          case "mat4":
            return TokenType.MAT4x4;
          case "mat4x2":
            return TokenType.MAT4x2;
          case "mat4x3":
            return TokenType.MAT4x3;
          case "mat4x4":
            return TokenType.MAT4x4;
          case "sampler":
            return TokenType.SAMPLER;
          case "sampler1D":
            return TokenType.SAMPLER_1D;
          case "sampler2D":
            return TokenType.SAMPLER_2D;
          case "sampler3D":
            return TokenType.SAMPLER_3D;
          case "samplerCube":
            return TokenType.SAMPLER_CUBE;
          case "samplerShadow":
            return TokenType.SAMPLER_SHADOW;
          case "sampler1DShadow":
            return TokenType.SAMPLER_1D_SHADOW;
          case "sampler2DShadow":
            return TokenType.SAMPLER_2D_SHADOW;
          case "texture1D":
            return TokenType.TEXTURE_1D;
          case "texture2D":
            return TokenType.TEXTURE_2D;
          case "texture3D":
            return TokenType.TEXTURE_3D;
          case "textureCube":
            return TokenType.TEXTURE_CUBE;
          case "texture1DArray":
            return TokenType.TEXTURE_1D_ARRAY;
          case "texture2DArray":
            return TokenType.TEXTURE_2D_ARRAY;
          case "textureCubeArray":
            return TokenType.TEXTURE_CUBE_ARRAY;
          case "const":
            return TokenType.CONST;
          case "layout":
            return TokenType.LAYOUT;
          case "precision":
            return TokenType.PRECISION;
          case "attribute":
            return TokenType.ATTRIBUTE;
          case "uniform":
            return TokenType.UNIFORM;
          case "varying":
            return TokenType.VARYING;
          case "invariant":
            return TokenType.INVARIANT;
          case "in":
            return TokenType.IN;
          case "out":
            return TokenType.OUT;
          case "inout":
            return TokenType.INOUT;
          case "if":
            return TokenType.IF;
          case "else":
            return TokenType.ELSE;
          case "for":
            return TokenType.FOR;
          case "while":
            return TokenType.WHILE;
          case "do":
            return TokenType.DO;
          case "break":
            return TokenType.BREAK;
          case "return":
            return TokenType.RETURN;
          case "continue":
            return TokenType.CONTINUE;
          case "struct":
            return TokenType.STRUCT;
        }
        return TokenType.IDENT;
      }
    }

    class MacroSubstitution {
      name = "";
      value = "";
      args = [];
    }
    class GLSLPreprocessor extends Reader {
      _result;
      _skipLine;
      _definitionTables;
      constructor(source) {
        super(source);
        this._result = "";
        this._skipLine = false;
        this._definitionTables = /* @__PURE__ */ new Map();
        this.parse();
      }
      parse() {
        this.readChar();
        while (this._char !== "\0") {
          this.skipWhitespace();
          if (this._char === "/") {
            if (this.peekChar() === "/") {
              this.skipComment();
              continue;
            }
            if (this.peekChar() === "*") {
              this.skipMultilineComment();
              continue;
            }
          }
          if (this._char === "#") {
            this.readCharAndSkipWhitespace();
            var name = this.readIdentifier();
            switch (name) {
              case "version":
                this.readLine().trim();
                break;
              case "define":
                this.readCharAndSkipWhitespace();
                var defineName = this.readIdentifier();
                if (this.getChar() === "(") {
                  let macro = new MacroSubstitution();
                  this.readCharAndSkipWhitespace();
                  if (this.getChar() !== ")") {
                    do {
                      var argName = this.readIdentifier();
                      macro.args.push(argName);
                      this.skipWhitespace();
                      if (this.getChar() === ",") {
                        this.readCharAndSkipWhitespace();
                        continue;
                      }
                    } while (this.getChar() !== ")");
                  }
                  this.readCharAndSkipWhitespace();
                  macro.name = defineName;
                  macro.value = this.readLine().trim();
                  this._definitionTables.set(defineName, macro);
                  this.readCharAndSkipWhitespace();
                } else {
                  let defineValue = this.readLine().trim();
                  if (defineValue[0] == "=") {
                    defineValue = defineValue.substring(1);
                  }
                  this._definitionTables.set(defineName, defineValue);
                }
                break;
              case "if":
                let condition = this.readLine().trim();
                if (condition == "0" || condition == "false") {
                  this._skipLine = true;
                  break;
                }
                if (this._definitionTables.has(condition)) {
                  condition = this._definitionTables.get(condition);
                  if (condition == "0" || condition == "false") {
                    this._skipLine = true;
                    break;
                  }
                }
                break;
              case "ifdef":
                this.readCharAndSkipWhitespace();
                var value = this.readIdentifier();
                this._skipLine = !this._definitionTables.has(value);
                break;
              case "else":
                this._skipLine = !this._skipLine;
                break;
              case "endif":
                this._skipLine = false;
                break;
              default:
                throw "Unknown preprocessing command:" + name;
            }
          } else {
            var line = this.readLine();
            if (!this._skipLine) {
              for (let key of this._definitionTables.keys()) {
                let index = line.indexOf(key);
                if (index != -1) {
                  let value2 = this._definitionTables.get(key);
                  if (typeof value2 === "string") {
                    line = line.replace(key, value2);
                  } else {
                    let macro = value2;
                    let reader = new Reader(line.substring(index + key.length));
                    reader.readCharAndSkipWhitespace();
                    if (reader.getChar() === "(") {
                      reader.readCharAndSkipWhitespace();
                      for (let count = 1; reader.getChar() !== "\0" && count > 0; ) {
                        switch (reader.getChar()) {
                          case "(":
                            count++;
                            break;
                          case ")":
                            count--;
                            break;
                        }
                        reader.readCharAndSkipWhitespace();
                      }
                    }
                    let nBeginPos = index;
                    let nEndPos = nBeginPos + key.length + reader.currPosition;
                    let expr = line.substring(nBeginPos, nEndPos).trim();
                    if (macro.args.length > 0) {
                      let args = [];
                      let argsStr = expr.substring(expr.indexOf("(") + 1, expr.lastIndexOf(")")).trim();
                      if (argsStr.length > 0) {
                        args = this.parseArgs(argsStr);
                      }
                      let macroValue = macro.value.substring(macro.value.indexOf("("));
                      for (let i = 0; i < macro.args.length; i++) {
                        macroValue = macroValue.replace(macro.args[i], args[i]);
                      }
                      macroValue = macro.value.substring(0, macro.value.indexOf("(")) + macroValue;
                      line = line.replace(expr, macroValue);
                    } else {
                      line = line.replace(expr, macro.value);
                    }
                  }
                }
              }
              this._result += line;
            }
            this.readChar();
          }
        }
      }
      get source() {
        return this._result;
      }
      parseArgs(str) {
        let result = [];
        let count = 0;
        let reader = new Reader(str);
        let position = reader.currPosition;
        reader.readCharAndSkipWhitespace();
        if (reader.getChar() !== "\0") {
          reader.readCharAndSkipWhitespace();
          for (; reader.getChar() !== "\0"; ) {
            switch (reader.getChar()) {
              case "(":
                count++;
                break;
              case ")":
                count--;
                break;
              case ",":
                if (count == 0) {
                  let arg = str.substring(position, reader.currPosition);
                  result.push(arg);
                  position = reader.currPosition + 1;
                }
                break;
            }
            reader.readCharAndSkipWhitespace();
          }
        }
        if (position < reader.currPosition) {
          let arg = str.substring(position, reader.currPosition);
          result.push(arg);
        }
        return result;
      }
    }

    class WGSLTranslator {
      result;
      ASTRoot;
      _syntax;
      constructor(syntax) {
        this.result = "";
        this._syntax = syntax;
        this.ASTRoot = syntax.ASTRoot;
      }
      /**
       * Generate WGSL code
       * @returns WGSL code
       */
      generateWGSL() {
        let context = new TranslatorContext();
        var result = new ShaderConverterResult();
        let layoutsBuffer = [];
        let layoutsUniform = [];
        let statements = [];
        for (let item of this.ASTRoot.nodes) {
          if (item instanceof SN_Layout) {
            if (item.scope == "in") {
              if (item.nodes[0] instanceof SN_Declaration) {
                context.layoutsIn.push(item);
                let info = new ShaderAttributeInfo();
                info.name = item.nodes[0].name;
                info.type = item.nodes[0].type;
                info.locationID = Number.parseInt(item.qualifier.get("location"));
                result.inputAttribute.push(info);
              } else if (item.qualifier.has("local_size_x")) {
                context.workGroupSize = item;
              } else
                throw "not impl";
            } else if (item.scope == "out") {
              context.layoutsOut.push(item);
              if (item.nodes[0] instanceof SN_Declaration) {
                let info = new ShaderAttributeInfo();
                info.name = item.nodes[0].name;
                info.type = item.nodes[0].type;
                info.locationID = Number.parseInt(item.qualifier.get("location"));
                result.outputAttribute.push(info);
              } else
                throw "not impl";
            } else if (item.scope == "uniform") {
              layoutsUniform.push(item);
              if (item.nodes[0] instanceof SN_Declaration) {
                let info = new ShaderUniformInfo();
                info.name = item.nodes[0].name;
                info.type = item.nodes[0].type;
                info.setID = Number.parseInt(item.qualifier.get("set"));
                info.bindingID = Number.parseInt(item.qualifier.get("binding"));
                result.uniformInfo.push(info);
              } else if (item.nodes[0] instanceof SN_Struct) {
                let info = new ShaderUniformInfo();
                info.name = "unif" + result.uniformInfo.length.toString();
                info.type = item.nodes[0].name;
                info.setID = Number.parseInt(item.qualifier.get("set"));
                info.bindingID = Number.parseInt(item.qualifier.get("binding"));
                result.uniformInfo.push(info);
              } else
                throw "not impl";
            } else if (item.scope == "buffer") {
              layoutsBuffer.push(item);
            }
          } else {
            statements.push(item);
          }
        }
        context.stage = "fragment";
        let position = 0;
        let reader = new Reader("");
        let source = this._syntax.lexer.source;
        let unique = /* @__PURE__ */ new Map();
        while ((position = source.indexOf("gl_", position)) != -1) {
          reader.reset(source.substring(position, position + 32));
          reader.readChar();
          let name = reader.readIdentifier();
          position += name.length;
          if (unique.has(name)) {
            continue;
          }
          unique.set(name, name);
          switch (name) {
            case "gl_InstanceID":
              context.stage = "vertex";
              context.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");
              break;
            case "gl_Position":
              context.stage = "vertex";
              context.builtinOut.push("@builtin(position) gl_Position: vec4<f32>");
              context.addIdentifier("gl_Position", "stout.gl_Position");
              break;
            case "gl_VertexIndex":
              context.stage = "vertex";
              context.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");
              break;
            case "gl_FrontFacing":
              context.stage = "fragment";
              context.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");
              break;
            case "gl_FragDepth":
              context.stage = "fragment";
              context.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32");
              context.addIdentifier("gl_FragDepth", "stout.gl_FragDepth");
              break;
            case "gl_WorkGroupID":
              context.stage = "compute";
              context.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");
              break;
            case "gl_NumWorkGroups":
              context.stage = "compute";
              context.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");
              break;
            case "gl_LocalInvocationID":
              context.stage = "compute";
              context.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");
              break;
            case "gl_LocalInvocationIndex":
              context.stage = "compute";
              context.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");
              break;
            case "gl_GlobalInvocationID":
              context.stage = "compute";
              context.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");
              break;
            default:
              throw "Unprocessed built-in variables: " + name;
          }
        }
        for (let item of layoutsUniform) {
          if (item.nodes[0] instanceof SN_Struct) {
            result.sourceCode += item.nodes[0].formatToWGSL(context, 0);
            result.sourceCode += "\r\n";
          }
        }
        for (let item of layoutsUniform) {
          result.sourceCode += item.formatToWGSL(context, 0);
        }
        result.sourceCode += "\r\n";
        for (let item of layoutsBuffer) {
          if (item.nodes[0] instanceof SN_Struct) {
            result.sourceCode += item.nodes[0].formatToWGSL(context, 0);
            result.sourceCode += "\r\n";
          }
        }
        for (let item of layoutsBuffer) {
          result.sourceCode += item.formatToWGSL(context, 0);
        }
        result.sourceCode += "\r\n";
        for (let item of statements) {
          result.sourceCode += item.formatToWGSL(context, 0);
          if (item instanceof SN_Declaration) {
            result.sourceCode += ";\r\n";
          }
        }
        return result;
      }
    }
    class TranslatorContext {
      _stage = "fragment";
      _builtinIn = [];
      _builtinOut = [];
      _layoutsIn = [];
      _layoutsOut = [];
      _layoutUniformCount = 0;
      _workGroupSize = void 0;
      _parentContext;
      _identifierEnv = /* @__PURE__ */ new Map();
      constructor(context) {
        this._parentContext = context;
      }
      get stage() {
        if (this.parentContext != void 0) {
          return this.parentContext.stage;
        }
        return this._stage;
      }
      set stage(value) {
        if (this.parentContext != void 0) {
          this.parentContext.stage = value;
        }
        this._stage = value;
      }
      get builtinIn() {
        if (this.parentContext != void 0) {
          return this.parentContext.builtinIn;
        }
        return this._builtinIn;
      }
      get builtinOut() {
        if (this.parentContext != void 0) {
          return this.parentContext.builtinOut;
        }
        return this._builtinOut;
      }
      get layoutsIn() {
        if (this.parentContext != void 0) {
          return this.parentContext.layoutsIn;
        }
        return this._layoutsIn;
      }
      get layoutsOut() {
        if (this.parentContext != void 0) {
          return this.parentContext.layoutsOut;
        }
        return this._layoutsOut;
      }
      get layoutUniformCount() {
        if (this.parentContext != void 0) {
          return this.parentContext.layoutUniformCount;
        }
        return this._layoutUniformCount;
      }
      set layoutUniformCount(value) {
        if (this.parentContext != void 0) {
          this.parentContext.layoutUniformCount = value;
          return;
        }
        this._layoutUniformCount = value;
      }
      get workGroupSize() {
        if (this.parentContext != void 0) {
          return this.parentContext.workGroupSize;
        }
        return this._workGroupSize;
      }
      set workGroupSize(value) {
        if (this.parentContext != void 0) {
          this.parentContext.workGroupSize = value;
        }
        this._workGroupSize = value;
      }
      get parentContext() {
        return this._parentContext;
      }
      findIdentifier(name) {
        if (this._identifierEnv.has(name)) {
          return this._identifierEnv.get(name);
        }
        if (this._parentContext != void 0) {
          return this._parentContext.findIdentifier(name);
        }
        return name;
      }
      addIdentifier(name, value) {
        this._identifierEnv.set(name, value);
      }
      hasIdentifier(name) {
        return this._identifierEnv.has(name);
      }
    }

    class StatementNode {
      nodes = [];
      constructor() {
      }
      addNode(node) {
        this.nodes.push(node);
      }
      formatToWGSL(context, depth) {
        return "";
      }
    }
    class SN_Struct extends StatementNode {
      name = "";
      fields = [];
      constructor(name) {
        super();
        this.name = name;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.LEFTBIG) {
          let result = new SN_Struct(r.peekToken(0).Literal);
          r.skipToken(2);
          while (r.peekToken(0).Type != TokenType.RIGHTBIG) {
            let field = SN_Declaration.parse(r);
            result.fields.push(field);
          }
          if (r.peekToken(0).Type == TokenType.RIGHTBIG) {
            r.skipToken(1);
          }
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
          }
          return result;
        }
        throw "Error parsing structure: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + "struct " + this.name + " {\r\n";
        for (let field of this.fields) {
          if (field.arraySize.nodes.length <= 0) {
            result += prefix + "  " + field.name + ": " + toWGSLType(field.type) + ",\r\n";
          } else {
            if (field.arraySize.nodes[0] instanceof SN_Constant) {
              result += prefix + "  " + field.name + ": array<" + toWGSLType(field.type) + ", " + field.arraySize.nodes[0].value + ">,\r\n";
            } else {
              result += prefix + "  " + field.name + ": array<" + toWGSLType(field.type) + ", " + field.arraySize.nodes[0].formatToWGSL(context, 0) + ">,\r\n";
            }
          }
        }
        result += prefix + "};\r\n";
        return result;
      }
    }
    class SN_Function extends StatementNode {
      name;
      args;
      body;
      returnType;
      constructor(name, args, body, returnType) {
        super();
        this.name = name;
        this.args = args;
        this.body = body;
        this.returnType = returnType;
      }
      static parse(r) {
        if ((r.peekToken(0).isBuiltinType() || r.peekToken(0).Type == TokenType.VOID) && r.peekToken(1).Type == TokenType.IDENT && r.peekToken(2).Type == TokenType.LEFTSAMLL) {
          let returnType = r.peekToken(0).Literal;
          let name = r.peekToken(1).Literal;
          r.skipToken(2);
          let args = new Array();
          if (r.peekToken(0).Type != TokenType.LEFTSAMLL) {
            throw "Error parsing function parameter list: Unexpected character";
          } else {
            r.skipToken(1);
            while (r.peekToken(0).Type != TokenType.EOF) {
              if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
                r.skipToken(1);
                break;
              }
              if (r.peekToken(0).Type == TokenType.INOUT) {
                r.skipToken(1);
              } else if (r.peekToken(0).Type == TokenType.IN) {
                r.skipToken(1);
              } else if (r.peekToken(0).Type == TokenType.OUT) {
                r.skipToken(1);
              }
              let arg = SN_Declaration.parse(r);
              args.push(arg);
              if (r.peekToken(0).Type == TokenType.COMMA) {
                r.skipToken(1);
              }
            }
          }
          let body = SN_CodeBlock.parse(r);
          return new SN_Function(name, args, body, returnType);
        }
        throw "Error parsing function: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        let outStructName;
        let hasOutStruct = context.layoutsOut.length > 0 || context.builtinOut.length > 0;
        switch (context.stage) {
          case "compute":
            outStructName = "ComputeOutput";
            break;
          case "vertex":
            outStructName = "VertexOutput";
            break;
          case "fragment":
            outStructName = "FragmentOutput";
            break;
          default:
            outStructName = "StructOutput";
            break;
        }
        if (this.name == "main" && hasOutStruct) {
          result += "struct " + outStructName + " {\r\n";
          for (let item of context.layoutsOut) {
            if (item.nodes[0] instanceof SN_Declaration) {
              let arg = item.nodes[0];
              if (item.qualifier.size == 1 && item.qualifier.has("location")) {
                result += "  @location(" + item.qualifier.get("location") + ") ";
              }
              result += arg.name + ": " + toWGSLType(arg.type) + ",\r\n";
              context.addIdentifier(arg.name, "stout." + arg.name);
            }
          }
          let builtinOut = context.builtinOut;
          for (let item of builtinOut) {
            result += "  " + item + ",\r\n";
          }
          result += "};\r\n\r\n";
        }
        let header = "";
        if (this.name == "main") {
          if (context.workGroupSize != void 0) {
            header += "@" + context.stage + " " + context.workGroupSize.formatToWGSL(context, 0) + " \r\n";
          } else {
            header += "@" + context.stage + "\r\n";
          }
        }
        context = new TranslatorContext(context);
        header += prefix + "fn " + this.name + "(";
        if (this.name != "main") {
          for (let i = 0; i < this.args.length; i++) {
            let arg = this.args[i];
            if (i > 0) {
              header += ", ";
            }
            header += arg.name + ": " + toWGSLType(arg.type);
            context.addIdentifier(arg.name, arg.name);
          }
          header += ") -> " + toWGSLType(this.returnType);
        } else {
          let layoutsIn = context.layoutsIn;
          for (let i = 0; i < layoutsIn.length; i++) {
            let item = layoutsIn[i];
            if (i > 0) {
              header += ",\r\n    ";
            } else {
              header += "\r\n    ";
            }
            if (item.nodes[0] instanceof SN_Declaration) {
              let arg = item.nodes[0];
              if (item.qualifier.size == 1 && item.qualifier.has("location")) {
                header += "@location(" + item.qualifier.get("location") + ") ";
              }
              header += arg.name + ": " + toWGSLType(arg.type);
              context.addIdentifier(arg.name, arg.name);
            }
          }
          if (layoutsIn.length > 0) {
            header += ",\r\n    ";
          }
          let builtinIn = context.builtinIn;
          for (let item of builtinIn) {
            header += item + ",\r\n    ";
          }
          if (hasOutStruct) {
            header += ") -> " + outStructName;
          } else {
            header += ") ";
          }
        }
        let bodyResult = "";
        if (this.name == "main" && hasOutStruct) {
          bodyResult += "    var stout: " + outStructName + " ;\r\n";
        }
        for (let statement of this.body.nodes) {
          bodyResult += statement.formatToWGSL(context, depth + 1);
          if (!(statement instanceof SN_IFBranch) && !(statement instanceof SN_WhileLoop) && !(statement instanceof SN_ForLoop)) {
            bodyResult += ";\r\n";
          }
        }
        if (this.name == "main" && hasOutStruct) {
          bodyResult += "    return stout;\r\n";
        }
        result += header + " {\r\n";
        result += bodyResult;
        result += prefix + "}\r\n";
        result += "\r\n";
        return result;
      }
    }
    class SN_FunctionArgs extends StatementNode {
      args = [];
      constructor() {
        super();
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.LEFTSAMLL) {
          r.skipToken(1);
          let result = new SN_FunctionArgs();
          while (r.peekToken(0).Type != TokenType.EOF) {
            if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
              r.skipToken(1);
              break;
            }
            let arg = SN_Expression.parse(r);
            result.args.push(arg);
            if (r.peekToken(0).Type == TokenType.COMMA) {
              r.skipToken(1);
            }
          }
          return result;
        }
        throw "Error parsing function argument table: Unexpected character";
      }
    }
    class SN_FunctionCall extends StatementNode {
      name;
      args;
      constructor(name, args) {
        super();
        this.name = name;
        this.args = args;
      }
      static parse(r) {
        if (r.peekToken(0).isDataType() && r.peekToken(1).Type == TokenType.LEFTSAMLL) {
          let name = r.peekToken(0).Literal;
          r.skipToken(1);
          let args = SN_FunctionArgs.parse(r);
          return new SN_FunctionCall(name, args);
        }
        throw "Error parsing function argument table: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        if (this.name == "texture" && this.args.args[0].nodes[0] instanceof SN_FunctionCall) {
          let callNode = this.args.args[0].nodes[0];
          if (callNode.name == "sampler2D") {
            result += prefix + "textureSample(";
            for (let i = 0; i < callNode.args.args.length; i++) {
              let arg = callNode.args.args[i];
              if (i > 0) {
                result += ", ";
              }
              result += arg.formatToWGSL(context, 0);
            }
            for (let i = 1; i < this.args.args.length; i++) {
              let arg = this.args.args[i];
              if (i > 0) {
                result += ", ";
              }
              result += arg.formatToWGSL(context, 0);
            }
            result += ")";
            return result;
          }
        }
        result += prefix + toWGSLType(this.name) + "(";
        for (let i = 0; i < this.args.args.length; i++) {
          let arg = this.args.args[i];
          if (i > 0) {
            result += ", ";
          }
          result += arg.formatToWGSL(context, 0);
        }
        result += ")";
        return result;
      }
    }
    class SN_Declaration extends StatementNode {
      type;
      name;
      arraySize;
      hasIn;
      hasOut;
      hasConst;
      constructor(type, name, arraySize = new SN_Expression()) {
        super();
        this.type = type;
        this.name = name;
        this.hasIn = false;
        this.hasOut = false;
        this.hasConst = false;
        this.arraySize = arraySize;
      }
      static parse(r) {
        let result = new SN_Declaration("", "");
        let first = r.peekToken(0);
        if (first.Type == TokenType.CONST) {
          r.skipToken(1);
          result.hasConst = true;
        } else if (first.Type == TokenType.IN) {
          r.skipToken(1);
          result.hasIn = true;
        } else if (first.Type == TokenType.OUT) {
          r.skipToken(1);
          result.hasOut = true;
        } else if (first.Type == TokenType.INOUT) {
          r.skipToken(1);
          result.hasIn = true;
          result.hasOut = true;
        } else if (!first.isDataType()) {
          throw "Error parsing declaration expression: Unexpected character(" + first.Literal + ")";
        }
        first = r.peekToken(0);
        if (first.isDataType() && r.peekToken(1).Type == TokenType.LEFTMEDI) {
          result.type = first.Literal;
          r.skipToken(2);
          result.arraySize = SN_Expression.parse(r);
          if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
            r.skipToken(1);
          }
          if (r.peekToken(0).Type != TokenType.IDENT) {
            throw "Unexpected";
          }
          result.name = r.peekToken(0).Literal;
          r.skipToken(1);
        } else if (first.isDataType() && r.peekToken(1).Type == TokenType.IDENT && r.peekToken(2).Type == TokenType.LEFTMEDI) {
          result.type = r.peekToken(0).Literal;
          result.name = r.peekToken(1).Literal;
          r.skipToken(3);
          if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
            r.skipToken(1);
          } else {
            result.arraySize = SN_Expression.parse(r);
            if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
              r.skipToken(1);
            }
          }
        } else if (first.isDataType() && r.peekToken(1).Type == TokenType.IDENT) {
          result.type = r.peekToken(0).Literal;
          result.name = r.peekToken(1).Literal;
          r.skipToken(2);
        } else
          throw "Error parsing declaration expression: Unexpected character(" + first.Literal + ")";
        first = r.peekToken(0);
        if (first.Type == TokenType.SEMICOLON) {
          r.skipToken(1);
          return result;
        } else if (first.Type == TokenType.RIGHTSAMLL) {
          return result;
        } else if (first.Type == TokenType.ASSIGN) {
          let op = r.peekToken(0);
          r.skipToken(1);
          let lValue = new SN_Identifier(result.name);
          let rValue = SN_Expression.parse(r);
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
          }
          result.addNode(new SN_BinaryOperation(op, lValue, rValue));
          return result;
        } else if (first.Type == TokenType.COMMA) {
          while (r.peekToken(0).Type == TokenType.COMMA && r.peekToken(1).Type == TokenType.IDENT) {
            let declaration = new SN_Declaration(result.type, r.peekToken(1).Literal);
            result.addNode(declaration);
            r.skipToken(2);
            if (r.peekToken(0).Type == TokenType.ASSIGN) {
              r.skipToken(-1);
              declaration.addNode(SN_Expression.parse(r));
            }
          }
          return result;
        }
        throw "Error parsing declaration expression: Unexpected character(" + r.peekToken(0).Literal + ")";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        if (this.hasConst) {
          result += prefix + "let ";
        } else {
          result += prefix + "var ";
        }
        context.addIdentifier(this.name, this.name);
        if (this.arraySize.nodes.length <= 0) {
          result += this.name + ": " + toWGSLType(this.type);
        } else {
          if (this.arraySize.nodes[0] instanceof SN_Constant) {
            result += this.name + ": array<" + toWGSLType(this.type) + ", " + this.arraySize.nodes[0].value + ">";
          } else {
            result += this.name + ": array<" + toWGSLType(this.type) + ", " + this.arraySize.nodes[0].formatToWGSL(context, 0) + ">";
          }
        }
        if (this.nodes.length > 0 && this.nodes[0] instanceof SN_BinaryOperation) {
          result += " = " + this.nodes[0].rightValue.formatToWGSL(context, 0);
        } else if (this.nodes.length > 0 && this.nodes[0] instanceof SN_Expression && this.nodes[0].nodes[0] instanceof SN_BinaryOperation) {
          result += " = " + this.nodes[0].nodes[0].rightValue.formatToWGSL(context, 0);
        } else if (this.nodes.length > 0 && this.nodes[0] instanceof SN_Declaration) {
          result += ";\r\n";
          for (let item of this.nodes) {
            result += item.formatToWGSL(context, depth) + ";\r\n";
          }
        } else {
          result += ";\r\n";
        }
        return result;
      }
    }
    class SN_ForLoop extends StatementNode {
      expression1;
      condition;
      expression2;
      loopBody;
      constructor(expression1, condition, expression2, loopBody) {
        super();
        this.expression1 = expression1;
        this.condition = condition;
        this.expression2 = expression2;
        this.loopBody = loopBody;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.FOR && r.peekToken(1).Type == TokenType.LEFTSAMLL) {
          r.skipToken(2);
          let expression1;
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
            expression1 = new SN_Expression();
          } else if (r.peekToken(0).isDataType() && r.peekToken(1).Type == TokenType.IDENT && r.peekToken(2).Type == TokenType.ASSIGN) {
            expression1 = new SN_Declaration(r.peekToken(0).Literal, r.peekToken(1).Literal);
            r.skipToken(1);
            expression1.addNode(SN_Expression.parse(r));
            if (r.peekToken(0).Type == TokenType.SEMICOLON) {
              r.skipToken(1);
            }
          } else {
            expression1 = SN_Expression.parse(r);
            if (r.peekToken(0).Type == TokenType.SEMICOLON) {
              r.skipToken(1);
            }
          }
          let condition;
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
            condition = new SN_Expression();
          } else {
            condition = SN_Expression.parse(r);
            if (r.peekToken(0).Type == TokenType.SEMICOLON) {
              r.skipToken(1);
            }
          }
          let expression2;
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
            expression2 = new SN_Expression();
          } else {
            expression2 = SN_Expression.parse(r);
            if (r.peekToken(0).Type == TokenType.SEMICOLON) {
              r.skipToken(1);
            }
          }
          if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
            r.skipToken(1);
          }
          let loopBody;
          if (r.peekToken(0).Type == TokenType.LEFTBIG) {
            loopBody = SN_CodeBlock.parse(r);
          } else {
            loopBody = new SN_CodeBlock();
          }
          return new SN_ForLoop(expression1, condition, expression2, loopBody);
        }
        throw "Error parsing for loop: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + "for (";
        result += this.expression1.formatToWGSL(context, 0) + "; ";
        result += this.condition.formatToWGSL(context, 0) + "; ";
        result += this.expression2.formatToWGSL(context, 0) + ")";
        result += " { \r\n";
        for (let item of this.loopBody.nodes) {
          result += item.formatToWGSL(context, depth + 1);
          if (!(item instanceof SN_IFBranch) && !(item instanceof SN_WhileLoop) && !(item instanceof SN_ForLoop)) {
            result += ";\r\n";
          }
        }
        result += prefix + "} \r\n";
        return result;
      }
    }
    class SN_WhileLoop extends StatementNode {
      conditionExpr;
      loopBody;
      constructor(condition, loopBody) {
        super();
        this.conditionExpr = condition;
        this.loopBody = loopBody;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.WHILE) {
          r.skipToken(1);
          if (r.peekToken(0).Type == TokenType.LEFTSAMLL) {
            r.skipToken(1);
          }
          let condition = SN_Expression.parse(r);
          if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
            r.skipToken(1);
          }
          let loopBody = SN_CodeBlock.parse(r);
          return new SN_WhileLoop(condition, loopBody);
        }
        throw "Error parsing while loop: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + "loop {\r\n";
        result += prefix + "    if (" + this.conditionExpr.formatToWGSL(context, 0) + ") { break; }\r\n\r\n";
        for (let item of this.loopBody.nodes) {
          result += item.formatToWGSL(context, depth + 1);
          if (!(item instanceof SN_IFBranch) && !(item instanceof SN_WhileLoop) && !(item instanceof SN_ForLoop)) {
            result += ";\r\n";
          }
        }
        result += prefix + "}\r\n";
        return result;
      }
    }
    class SN_DoWhileLoop extends StatementNode {
      constructor() {
        super();
      }
    }
    class SN_IFBranch extends StatementNode {
      conditionExpr;
      trueBranch;
      falseBranch;
      constructor(condition, trueBranch, falseBranch) {
        super();
        this.conditionExpr = condition;
        this.trueBranch = trueBranch;
        this.falseBranch = falseBranch;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.IF) {
          r.skipToken(1);
          if (r.peekToken(0).Type == TokenType.LEFTSAMLL) {
            r.skipToken(1);
          }
          let condition = SN_Expression.parse(r);
          let trueBranch;
          let falseBranch = new SN_CodeBlock();
          if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
            r.skipToken(1);
          }
          if (r.peekToken(0).Type == TokenType.LEFTBIG) {
            trueBranch = SN_CodeBlock.parse(r);
          } else {
            trueBranch = new SN_CodeBlock();
            if (r.peekToken(0).Type == TokenType.RETURN) {
              trueBranch.addNode(SN_Return.parse(r));
            } else {
              trueBranch.addNode(SN_Expression.parse(r));
            }
          }
          if (r.peekToken(0).Type == TokenType.ELSE) {
            r.skipToken(1);
            if (r.peekToken(0).Type == TokenType.LEFTBIG) {
              falseBranch = SN_CodeBlock.parse(r);
            } else
              throw "not impl";
          }
          return new SN_IFBranch(condition, trueBranch, falseBranch);
        }
        throw "Error parsing IF branch statement: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let resultl = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        resultl += prefix + "if (" + this.conditionExpr.formatToWGSL(context, 0) + ") {\r\n";
        for (let item of this.trueBranch.nodes) {
          resultl += item.formatToWGSL(context, depth + 1) + ";\r\n";
        }
        if (this.falseBranch.nodes.length > 0) {
          resultl += prefix + "} else {\r\n";
          for (let item of this.falseBranch.nodes) {
            resultl += item.formatToWGSL(context, depth + 1) + ";\r\n";
          }
        }
        resultl += prefix + "}\r\n";
        return resultl;
      }
    }
    class SN_Expression extends StatementNode {
      constructor() {
        super();
      }
      static parse(r) {
        let opStack = new Array();
        let valueStack = new Array();
        let nSamllCount = 0;
        while (r.peekToken(0).Type != TokenType.EOF) {
          let currToken = r.peekToken(0);
          if (currToken.Type == TokenType.SEMICOLON || currToken.Type == TokenType.RIGHTMEDI) {
            break;
          }
          if (currToken.Type == TokenType.COMMA || currToken.Type == TokenType.COLON || currToken.Type == TokenType.RIGHTBIG) {
            break;
          }
          if (!currToken.isOperation()) {
            if (currToken.Type == TokenType.LITERAL) {
              valueStack.push(new SN_Constant(currToken.Literal));
              r.skipToken(1);
              continue;
            } else if (currToken.Type == TokenType.LEFTSAMLL) {
              nSamllCount++;
              opStack.push(currToken);
              r.skipToken(1);
              continue;
            } else if (currToken.Type == TokenType.RIGHTSAMLL) {
              if (nSamllCount <= 0) {
                break;
              }
              nSamllCount--;
              while (SN_Expression.unionOperation(opStack, valueStack))
                ;
              if (opStack[opStack.length - 1].Type == TokenType.LEFTSAMLL) {
                opStack.pop();
                let parenExpr = new SN_ParenExpression();
                parenExpr.addNode(valueStack.pop());
                valueStack.push(parenExpr);
              }
              r.skipToken(1);
              continue;
            } else if (currToken.Type == TokenType.IDENT) {
              if (r.peekToken(1).Type == TokenType.INC || r.peekToken(1).Type == TokenType.DEC) {
                let op = r.peekToken(1);
                let value = new SN_Identifier(currToken.Literal);
                valueStack.push(new SN_UnaryOperation(op, value, void 0));
                r.skipToken(2);
                continue;
              } else if (r.peekToken(1).Type == TokenType.LEFTSAMLL) {
                valueStack.push(SN_FunctionCall.parse(r));
                continue;
              } else if (r.peekToken(1).Type == TokenType.DOT) {
                valueStack.push(SN_SelectOperation.parse(r));
                continue;
              } else if (r.peekToken(1).Type == TokenType.LEFTMEDI) {
                valueStack.push(SN_IndexOperation.parse(r));
                continue;
              }
              valueStack.push(new SN_Identifier(currToken.Literal));
              r.skipToken(1);
              continue;
            } else {
              if (currToken.isBuiltinType() && r.peekToken(1).Type == TokenType.LEFTSAMLL) {
                valueStack.push(SN_FunctionCall.parse(r));
                continue;
              }
              if (currToken.isAssignOperation()) {
                let op = currToken;
                r.skipToken(1);
                let lValue = valueStack.pop();
                let rValue = SN_Expression.parse(r);
                valueStack.push(new SN_BinaryOperation(op, lValue, rValue));
                continue;
              }
              if (currToken.Type == TokenType.LEFTBIG && (r.peekToken(1).Type == TokenType.LITERAL || r.peekToken(1).Type == TokenType.SUB && r.peekToken(2).Type == TokenType.LITERAL)) {
                valueStack.push(SN_ArrayConstant.parse(r));
                continue;
              }
              if (currToken.Type == TokenType.QUEMARK) {
                if (opStack.length > 0) {
                  let opToken = opStack[opStack.length - 1];
                  if (opToken.nOperationPriorityLevel <= currToken.nOperationPriorityLevel) {
                    SN_Expression.unionOperation(opStack, valueStack);
                  }
                }
                r.skipToken(1);
                let a = valueStack.pop();
                let b = SN_Expression.parse(r);
                if (r.peekToken(0).Type == TokenType.COLON) {
                  r.skipToken(1);
                }
                let c = SN_Expression.parse(r);
                valueStack.push(new SN_TernaryOperation(a, b, c));
                if (r.peekToken(-1).Type == TokenType.SEMICOLON) {
                  break;
                }
                continue;
              }
              if (currToken.Type == TokenType.LEFTMEDI) {
                r.skipToken(1);
                let indexValue = SN_Expression.parse(r);
                if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
                  r.skipToken(1);
                }
                let lValue = valueStack.pop();
                valueStack.push(new SN_IndexOperation(lValue, indexValue));
                continue;
              }
              throw "An unexpected character";
            }
          } else if (currToken.isOperation()) {
            if (currToken.Type == TokenType.INC || currToken.Type == TokenType.DEC) {
              let op = currToken;
              r.skipToken(1);
              let value = SN_Expression.parse(r);
              valueStack.push(new SN_UnaryOperation(op, void 0, value));
              continue;
            } else if (opStack.length > 0) {
              let opToken = opStack[opStack.length - 1];
              if (opToken.nOperationPriorityLevel <= currToken.nOperationPriorityLevel) {
                SN_Expression.unionOperation(opStack, valueStack);
              } else if (opStack.length > 0 && opStack[opStack.length - 1].Literal == "-") {
                let op = opStack.pop();
                let v1 = valueStack.pop();
                valueStack.push(new SN_UnaryOperation(op, void 0, v1));
              }
            }
            opStack.push(currToken);
            r.skipToken(1);
          }
        }
        while (opStack.length > 0 && SN_Expression.unionOperation(opStack, valueStack))
          ;
        if (opStack.length <= 0 && valueStack.length == 1) {
          let expr = new SN_Expression();
          expr.addNode(valueStack.pop());
          return expr;
        }
        throw "Error parsing expression: Unexpected character(" + r.peekToken(0).Literal + ")";
      }
      formatToWGSL(context, depth) {
        return this.nodes[0].formatToWGSL(context, depth);
      }
      static unionOperation(opStack, valueStack) {
        if (opStack.length < 0 || valueStack.length < 2) {
          if (opStack.length > 0 && opStack[opStack.length - 1].Literal == "-") {
            let op = opStack.pop();
            let v1 = valueStack.pop();
            valueStack.push(new SN_UnaryOperation(op, void 0, v1));
            return true;
          }
          return false;
        }
        if (opStack[opStack.length - 1].isOperation()) {
          let v2 = valueStack.pop();
          let op = opStack.pop();
          let v1 = valueStack.pop();
          if (op.Type == TokenType.DOT) {
            valueStack.push(new SN_SelectOperation(v1, v2));
          } else {
            valueStack.push(new SN_BinaryOperation(op, v1, v2));
          }
          return true;
        }
        return false;
      }
    }
    class SN_ParenExpression extends StatementNode {
      constructor() {
        super();
      }
      formatToWGSL(context, depth) {
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        let result = prefix + "(" + this.nodes[0].formatToWGSL(context, 0) + ")";
        return result;
      }
    }
    class SN_Identifier extends StatementNode {
      name;
      constructor(name) {
        super();
        this.name = name;
      }
      formatToWGSL(context, depth) {
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        return prefix + context.findIdentifier(this.name);
      }
    }
    class SN_Constant extends StatementNode {
      value;
      constructor(value) {
        super();
        this.value = value;
      }
      static parse(r) {
        let firstToken = r.peekToken(0);
        if (firstToken.Type == TokenType.SUB && r.peekToken(1).Type == TokenType.LITERAL) {
          let result = new SN_Constant("-" + r.peekToken(1).Literal);
          r.skipToken(2);
          return result;
        } else if (firstToken.Type == TokenType.LITERAL) {
          let result = new SN_Constant(firstToken.Literal);
          r.skipToken(1);
          return result;
        }
        throw "Error parsing literal constants: Unexpected characters(" + firstToken.Literal + ")";
      }
      formatToWGSL(context, depth) {
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        return prefix + this.value;
      }
    }
    class SN_ArrayConstant extends SN_Constant {
      arrayValue;
      constructor(value) {
        super("");
        this.arrayValue = value;
      }
      static parse(r) {
        if (
          // { 1, 2, 3, 4 }
          r.peekToken(0).Type == TokenType.LEFTBIG && r.peekToken(1).Type == TokenType.LITERAL || // { -1, 2, 3, 4 }
          r.peekToken(0).Type == TokenType.LEFTBIG && r.peekToken(1).Type == TokenType.SUB && r.peekToken(2).Type == TokenType.LITERAL
        ) {
          r.skipToken(1);
          let arrayValue = [];
          while (r.peekToken(0).Type != TokenType.RIGHTBIG) {
            if (r.peekToken(0).Type == TokenType.LEFTSAMLL) {
              arrayValue.push(SN_ArrayConstant.parse(r));
              continue;
            }
            arrayValue.push(SN_Constant.parse(r));
            if (r.peekToken(0).Type == TokenType.COMMA) {
              r.skipToken(1);
              continue;
            } else if (r.peekToken(0).Type == TokenType.RIGHTBIG) {
              r.skipToken(1);
              break;
            } else
              throw "Error parsing array constants: Unexpected characters";
          }
          return new SN_ArrayConstant(arrayValue);
        }
        throw "Error parsing array constants: Unexpected characters";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        if (this.arrayValue[0].value.includes(".")) {
          result += prefix + "array<f32, " + this.arrayValue.length.toString() + ">(";
        } else {
          result += prefix + "array<i32, " + this.arrayValue.length.toString() + ">(";
        }
        for (let i = 0; i < this.arrayValue.length; i++) {
          if (i > 0) {
            result += ", ";
          }
          result += this.arrayValue[i].formatToWGSL(context, 0);
        }
        result += ")";
        return result;
      }
    }
    class SN_Break extends StatementNode {
      constructor() {
        super();
      }
    }
    class SN_Discard extends StatementNode {
      constructor() {
        super();
      }
    }
    class SN_Continue extends StatementNode {
      constructor() {
        super();
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.CONTINUE && r.peekToken(1).Type == TokenType.SEMICOLON) {
          r.skipToken(2);
          return new SN_Continue();
        }
        throw "Error parsing continue: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + "continue";
        return result;
      }
    }
    class SN_Return extends StatementNode {
      value;
      constructor(value) {
        super();
        this.value = value;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.RETURN) {
          r.skipToken(1);
          let expr = SN_Expression.parse(r);
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
          }
          return new SN_Return(expr);
        }
        throw "Error parsing return expression: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + "return " + this.value.formatToWGSL(context, 0);
        return result;
      }
    }
    class SN_UnaryOperation extends StatementNode {
      op;
      leftValue;
      rightValue;
      constructor(op, lValue, rValue) {
        super();
        this.op = op;
        this.leftValue = lValue;
        this.rightValue = rValue;
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        if (this.op.Literal == "++" || this.op.Literal == "--") {
          if (this.leftValue != void 0) {
            let lValue = this.leftValue.formatToWGSL(context, 0);
            result += prefix + lValue + " = " + lValue + " " + this.op.Literal[0] + " 1";
          } else {
            let rValue = this.rightValue.formatToWGSL(context, 0);
            result += prefix + rValue + " = " + rValue + " " + this.op.Literal[0] + " 1";
          }
        } else {
          if (this.leftValue != void 0) {
            result += prefix + this.leftValue.formatToWGSL(context, 0) + this.op.Literal;
          } else {
            result += prefix + this.op.Literal + this.rightValue.formatToWGSL(context, 0);
          }
        }
        return result;
      }
    }
    class SN_BinaryOperation extends StatementNode {
      op;
      leftValue;
      rightValue;
      constructor(op, lValue, rValue) {
        super();
        this.op = op;
        this.leftValue = lValue;
        this.rightValue = rValue;
      }
      formatToWGSL(context, depth) {
        let result = "";
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        result += prefix + this.leftValue.formatToWGSL(context, 0) + " " + this.op.Literal + " " + this.rightValue.formatToWGSL(context, 0);
        return result;
      }
    }
    class SN_TernaryOperation extends StatementNode {
      condition;
      expression1;
      expression2;
      constructor(condition, expression1, expression2) {
        super();
        this.condition = condition;
        this.expression1 = expression1;
        this.expression2 = expression2;
      }
      static parse(r) {
        throw "Error parsing ternary operation expression: Unexpected character";
      }
      formatToWGSL(context, depth) {
        return "";
      }
    }
    class SN_SelectOperation extends StatementNode {
      leftValue;
      rightValue;
      constructor(lValue, rValue) {
        super();
        this.leftValue = lValue;
        this.rightValue = rValue;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.DOT && r.peekToken(2).Type == TokenType.IDENT) {
          let lValue = new SN_Identifier(r.peekToken(0).Literal);
          let rValue = new SN_Identifier(r.peekToken(2).Literal);
          r.skipToken(3);
          return new SN_SelectOperation(lValue, rValue);
        }
        throw "Error parsing selection expression: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        return prefix + this.leftValue.formatToWGSL(context, 0) + "." + this.rightValue.formatToWGSL(context, 0);
      }
    }
    class SN_IndexOperation extends StatementNode {
      leftValue;
      indexValue;
      constructor(lValue, indexValue) {
        super();
        this.leftValue = lValue;
        this.indexValue = indexValue;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.LEFTMEDI) {
          let lValue = new SN_Identifier(r.peekToken(0).Literal);
          r.skipToken(2);
          let indexValue = SN_Expression.parse(r);
          if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
            r.skipToken(1);
          }
          let result = new SN_IndexOperation(lValue, indexValue);
          while (r.peekToken(0).Type == TokenType.LEFTMEDI) {
            r.skipToken(1);
            indexValue = SN_Expression.parse(r);
            if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
              r.skipToken(1);
            }
            result = new SN_IndexOperation(result, indexValue);
          }
          return result;
        }
        throw "Error parsing index expression: Unexpected character";
      }
      formatToWGSL(context, depth) {
        let prefix = depth <= 0 ? "" : "    ".repeat(depth);
        return prefix + this.leftValue.formatToWGSL(context, 0) + "[" + this.indexValue.formatToWGSL(context, 0) + "]";
      }
    }
    class SN_CodeBlock extends StatementNode {
      constructor() {
        super();
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.LEFTBIG) {
          r.skipToken(1);
          let result = new SN_CodeBlock();
          for (let count = 1; count > 0 && r.peekToken(0).Type != TokenType.EOF; ) {
            let currToken = r.peekToken(0);
            if (currToken.Type == TokenType.LEFTBIG) {
              count++;
              r.skipToken(1);
              continue;
            }
            if (currToken.Type == TokenType.RIGHTBIG) {
              count--;
              r.skipToken(1);
              continue;
            }
            if (currToken.Type == TokenType.SEMICOLON) {
              r.skipToken(1);
              continue;
            }
            if (currToken.isDataType() && r.peekToken(1).Type == TokenType.IDENT) {
              result.addNode(SN_Declaration.parse(r));
              continue;
            }
            if (currToken.Type == TokenType.CONST && r.peekToken(1).isDataType() && r.peekToken(2).Type == TokenType.IDENT) {
              result.addNode(SN_Declaration.parse(r));
              continue;
            } else if (
              /**
               * assignment expression
               * a = ...;
               */
              currToken.Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.ASSIGN
            ) {
              result.addNode(SN_Expression.parse(r));
              if (r.peekToken(0).Type == TokenType.SEMICOLON) {
                r.skipToken(1);
              }
              continue;
            } else if (
              /**
               * Expression of index
               * a[...]
               */
              currToken.Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.LEFTMEDI
            ) {
              let indexOperation = SN_IndexOperation.parse(r);
              if (r.peekToken(0).Type == TokenType.ASSIGN) {
                let op = r.peekToken(0);
                r.skipToken(1);
                let rValue = SN_Expression.parse(r);
                if (r.peekToken(0).Type == TokenType.RIGHTMEDI) {
                  r.skipToken(1);
                }
                result.addNode(new SN_BinaryOperation(op, indexOperation, rValue));
                continue;
              }
              result.addNode(indexOperation);
              continue;
            } else if (
              /**
               * Expression of choice
               * a.b
               */
              currToken.Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.DOT
            ) {
              let expr = SN_Expression.parse(r);
              result.addNode(expr);
              continue;
            } else if (
              /**
               * Assignment operation expression
               * a += ...;
               */
              currToken.Type == TokenType.IDENT && r.peekToken(1).isAssignOperation()
            ) {
              let op = r.peekToken(1);
              let lValue = new SN_Identifier(currToken.Literal);
              r.skipToken(2);
              let rValue = SN_Expression.parse(r);
              if (r.peekToken(0).Type == TokenType.SEMICOLON) {
                r.skipToken(1);
              }
              result.addNode(new SN_BinaryOperation(op, lValue, rValue));
              continue;
            } else if (
              /**
               * After the increase, after the decrease
               * a++;
               */
              currToken.Type == TokenType.IDENT && (r.peekToken(1).Type == TokenType.INC || r.peekToken(1).Type == TokenType.DEC) && r.peekToken(2).Type == TokenType.SEMICOLON
            ) {
              let op = r.peekToken(1);
              result.addNode(new SN_UnaryOperation(op, new SN_Identifier(currToken.Literal), void 0));
              r.skipToken(3);
              continue;
            } else if (currToken.Type == TokenType.RETURN) {
              result.addNode(SN_Return.parse(r));
              continue;
            } else if (currToken.Type == TokenType.CONTINUE) {
              result.addNode(SN_Continue.parse(r));
              continue;
            } else if (currToken.Type == TokenType.WHILE) {
              result.addNode(SN_WhileLoop.parse(r));
              continue;
            } else if (currToken.Type == TokenType.FOR) {
              result.addNode(SN_ForLoop.parse(r));
              continue;
            } else if (currToken.Type == TokenType.IF) {
              result.addNode(SN_IFBranch.parse(r));
              continue;
            } else if (
              /**
               * function call
               */
              currToken.Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.LEFTSAMLL
            ) {
              result.addNode(SN_FunctionCall.parse(r));
              if (r.peekToken(0).Type == TokenType.SEMICOLON) {
                r.skipToken(0);
              }
              continue;
            }
            throw "Error parsing block: Unexpected symbol(" + currToken.Literal + ")";
          }
          return result;
        }
        throw "Error parsing block: Unexpected symbol";
      }
    }
    class SN_Precision extends StatementNode {
      type;
      qualifier;
      constructor(qualifier, type) {
        super();
        this.type = type;
        this.qualifier = qualifier;
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.PRECISION && r.peekToken(1).Type == TokenType.IDENT && r.peekToken(2).isBuiltinType()) {
          let result = new SN_Precision(r.peekToken(1).Literal, r.peekToken(2).Literal);
          r.skipToken(3);
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
          }
          return result;
        }
        throw "Error parsing precision qualifier: Unexpected character";
      }
      formatToWGSL(context, depth) {
        return "";
      }
    }
    class SN_Layout extends StatementNode {
      scope = "";
      qualifier = /* @__PURE__ */ new Map();
      constructor() {
        super();
      }
      addQualifier(name, value = "") {
        this.qualifier.set(name, value);
      }
      static parse(r) {
        if (r.peekToken(0).Type == TokenType.LAYOUT && r.peekToken(1).Type == TokenType.LEFTSAMLL) {
          let result = new SN_Layout();
          r.skipToken(2);
          do {
            let currToken = r.peekToken(0);
            if (currToken.Type == TokenType.IDENT) {
              if (r.peekToken(1).Type == TokenType.ASSIGN && r.peekToken(2).Type == TokenType.LITERAL) {
                let name = r.peekToken(0).Literal;
                let value = r.peekToken(2).Literal;
                result.addQualifier(name, value);
                r.skipToken(3);
                if (r.peekToken(0).Type == TokenType.COMMA) {
                  r.skipToken(1);
                  continue;
                }
                let token = r.peekToken(0);
                token.Line = 0;
              } else if (r.peekToken(1).Type == TokenType.RIGHTSAMLL) {
                let name = r.peekToken(0).Literal;
                result.addQualifier(name, "");
                r.skipToken(1);
                break;
              } else if (r.peekToken(1).Type == TokenType.COMMA) {
                let name = r.peekToken(0).Literal;
                result.addQualifier(name, "");
                r.skipToken(2);
                continue;
              }
            }
          } while (r.peekToken(0).Type != TokenType.RIGHTSAMLL);
          if (r.peekToken(0).Type == TokenType.RIGHTSAMLL) {
            r.skipToken(1);
          }
          result.scope = r.peekToken(0).Literal;
          r.skipToken(1);
          if (r.peekToken(0).Type == TokenType.SEMICOLON) {
            r.skipToken(1);
            return result;
          } else if (r.peekToken(0).isBuiltinType() && r.peekToken(1).Type == TokenType.IDENT && r.peekToken(2).Type == TokenType.SEMICOLON) {
            let node = new SN_Declaration(r.peekToken(0).Literal, r.peekToken(1).Literal);
            result.addNode(node);
            r.skipToken(3);
            return result;
          } else if (r.peekToken(0).Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.LEFTBIG) {
            let structNode = SN_Struct.parse(r);
            result.addNode(structNode);
            if (r.peekToken(0).Type == TokenType.IDENT && r.peekToken(1).Type == TokenType.SEMICOLON) {
              structNode.addNode(new SN_Declaration(structNode.name, r.peekToken(0).Literal));
              r.skipToken(2);
            }
            return result;
          } else
            throw "Error parsing layout qualifier type: Unexpected symbol(" + r.peekToken(0).Literal + ")";
        }
        throw "Error parsing layout qualifier: Unexpected symbol";
      }
      formatToWGSL(context, depth) {
        let result = "";
        if (this.qualifier.size == 1 && this.qualifier.has("location")) {
          result += "@location(" + this.qualifier.get("location") + ") ";
        } else if (this.qualifier.size == 2 && this.qualifier.has("set") && this.qualifier.has("binding")) {
          result += "@group(" + this.qualifier.get("set") + ") @binding(" + this.qualifier.get("binding") + ") ";
        } else if (this.qualifier.size >= 1 && this.qualifier.has("binding")) {
          result += "@group(0) @binding(" + this.qualifier.get("binding") + ") ";
        } else if (this.qualifier.size == 1 && this.qualifier.has("push_constant")) {
          result += "@push_constant ";
        } else if (this.qualifier.size >= 1 && this.qualifier.has("local_size_x")) {
          result += "@workgroup_size(";
          result += this.qualifier.get("local_size_x") + ", ";
          result += this.qualifier.has("local_size_y") ? this.qualifier.get("local_size_y") + ", " : "1, ";
          result += this.qualifier.has("local_size_z") ? this.qualifier.get("local_size_z") + "" : "1";
          result += ")";
        } else if (this.nodes.length <= 0) {
          return "";
        }
        let item = this.nodes[0];
        if (item instanceof SN_Declaration) {
          switch (item.type) {
            case "sampler":
            case "texture2D":
              result += "var ";
              break;
            default:
              if (this.scope == "buffer") {
                if (context.stage == "compute") {
                  result += "var<storage, read_write> ";
                } else {
                  result += "var<storage, read> ";
                }
              } else {
                result += "var<" + this.scope + "> ";
              }
              break;
          }
          context.addIdentifier(item.name, item.name);
          result += item.name + ": " + toWGSLType(item.type) + ";\r\n";
        } else if (item instanceof SN_Struct) {
          if (this.scope == "buffer") {
            if (context.stage == "compute") {
              result += "var<storage, read_write> ";
            } else {
              result += "var<storage, read> ";
            }
          } else {
            result += "var<" + this.scope + "> ";
          }
          if (item.nodes.length <= 0) {
            let rename = "unif" + context.layoutUniformCount.toString();
            while (context.hasIdentifier(rename)) {
              context.layoutUniformCount++;
              rename = "unif" + context.layoutUniformCount.toString();
            }
            for (let field of item.fields) {
              context.addIdentifier(field.name, rename + "." + field.name);
            }
            result += rename + ": " + item.name + ";\r\n";
            context.layoutUniformCount++;
          } else {
            let declaration = item.nodes[0];
            result += declaration.name + ": " + declaration.type + ";\r\n";
          }
          return result;
        }
        return result;
      }
    }
    function toWGSLType(type) {
      switch (type) {
        case "int":
          return "i32";
        case "int[]":
          return "array<i32>";
        case "uint":
          return "u32";
        case "uint[]":
          return "array<u32>";
        case "float":
          return "f32";
        case "float[]":
          return "array<f32>";
        case "vec2":
          return "vec2<f32>";
        case "vec3":
          return "vec3<f32>";
        case "vec4":
          return "vec4<f32>";
        case "vec2[]":
          return "array<vec2<f32>>";
        case "vec3[]":
          return "array<vec3<f32>>";
        case "vec4[]":
          return "array<vec4<f32>>";
        case "ivec2":
          return "vec2<i32>";
        case "ivec3":
          return "vec3<i32>";
        case "ivec4":
          return "vec4<i32>";
        case "ivec2[]":
          return "array<vec2<i32>>";
        case "ivec3[]":
          return "array<vec3<i32>>";
        case "ivec4[]":
          return "array<vec4<i32>>";
        case "mat2":
          return "mat2x2<f32>";
        case "mat2x2":
          return "mat2x2<f32>";
        case "mat2x3":
          return "mat2x3<f32>";
        case "mat2x4":
          return "mat2x4<f32>";
        case "mat2[]":
          return "array<mat2x2<f32>>";
        case "mat2x2[]":
          return "array<mat2x2<f32>>";
        case "mat2x3[]":
          return "array<mat2x3<f32>>";
        case "mat2x4[]":
          return "array<mat2x4<f32>>";
        case "mat3":
          return "mat3x3<f32>";
        case "mat3x2":
          return "mat3x2<f32>";
        case "mat3x3":
          return "mat3x3<f32>";
        case "mat3x4":
          return "mat3x4<f32>";
        case "mat3[]":
          return "array<mat3x3<f32>>";
        case "mat3x2[]":
          return "array<mat3x2<f32>>";
        case "mat3x3[]":
          return "array<mat3x3<f32>>";
        case "mat3x4[]":
          return "array<mat3x4<f32>>";
        case "mat4":
          return "mat4x4<f32>";
        case "mat4x2":
          return "mat4x2<f32>";
        case "mat4x3":
          return "mat4x3<f32>";
        case "mat4x4":
          return "mat4x4<f32>";
        case "mat4[]":
          return "array<mat4x4<f32>>";
        case "mat4x2[]":
          return "array<mat4x2<f32>>";
        case "mat4x3[]":
          return "array<mat4x3<f32>>";
        case "mat4x4[]":
          return "array<mat4x4<f32>>";
        case "texture2D":
          return "texture_2d<f32>";
      }
      return type;
    }

    class GLSLSyntax {
      _lexer;
      _rootNode;
      constructor(input) {
        this._lexer = input;
        this._rootNode = new StatementNode();
        this.parse();
      }
      get lexer() {
        return this._lexer;
      }
      parse() {
        while (this.peekToken(0).Type !== TokenType.EOF) {
          if (this.peekToken(0).Type == TokenType.SEMICOLON) {
            this.skipToken(1);
            continue;
          }
          let node = this.parseStatement();
          if (node !== null) {
            this._rootNode.addNode(node);
          }
        }
      }
      parseStatement() {
        let first = this.peekToken();
        if (first.Type == TokenType.LAYOUT && this.peekToken(1).Type == TokenType.LEFTSAMLL) {
          let layoutNode = SN_Layout.parse(this._lexer);
          return layoutNode;
        } else if (first.Type == TokenType.STRUCT) {
          this.skipToken(1);
          let structNode = SN_Struct.parse(this._lexer);
          return structNode;
        } else if (
          /**
           * function declaration
           */
          (first.isBuiltinType() || first.Type == TokenType.VOID) && this.peekToken(1).Type == TokenType.IDENT && this.peekToken(2).Type == TokenType.LEFTSAMLL
        ) {
          let functionDec = SN_Function.parse(this._lexer);
          return functionDec;
        } else if (
          /**
           * Constant declaration
           * const int a = ...;
           */
          first.Type == TokenType.CONST && this.peekToken(1).isDataType()
        ) {
          let declarationNode = SN_Declaration.parse(this._lexer);
          return declarationNode;
        } else if (
          /**
           * Declaration of variables
           * int a = ...;
           */
          first.isDataType() && this.peekToken(1).Type == TokenType.IDENT
        ) {
          let declarationNode = SN_Declaration.parse(this._lexer);
          return declarationNode;
        } else if (
          /**
           * Declaration of variables
           * out float a = ...;
           */
          first.Type == TokenType.OUT && this.peekToken(1).isDataType() && this.peekToken(2).Type == TokenType.IDENT
        ) {
          let declarationNode = SN_Declaration.parse(this._lexer);
          return declarationNode;
        } else if (first.Type == TokenType.PRECISION) {
          let precisionNode = SN_Precision.parse(this._lexer);
          return precisionNode;
        }
        throw "Error parsing statement: Unexpected character";
      }
      skipToken(offset) {
        this._lexer.skipToken(offset);
      }
      peekToken(offset = 0) {
        return this._lexer.peekToken(offset);
      }
      getNextToken() {
        return this._lexer.GetNextToken();
      }
      get ASTRoot() {
        return this._rootNode;
      }
    }

    class ShaderConverter {
      /**
       * Shader type: Vertex stage
       */
      static VertexShader = "VertexShader";
      /**
       * Shader type: Fragment stage
       */
      static FragmentShader = "FragmentShader";
      /**
       * Convert GLSL code to WGSL
       * @param source GLSL
       * @returns WGSL
       */
      static convertGLSL(source) {
        var preprocessor = new GLSLPreprocessor(source);
        var lexer = new GLSLLexer(preprocessor);
        var syntax = new GLSLSyntax(lexer);
        var translator = new WGSLTranslator(syntax);
        return translator.generateWGSL();
      }
    }
    class ShaderUniformInfo {
      setID = 0;
      bindingID = 0;
      name = "";
      type = "";
    }
    class ShaderAttributeInfo {
      name = "";
      type = "";
      locationID = 0;
      builtinName = "";
      isBuiltinAttribute() {
        return this.builtinName != "";
      }
    }
    class ShaderConverterResult {
      uniformInfo = [];
      inputAttribute = [];
      outputAttribute = [];
      sourceCode = "";
    }

    var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["vertex"] = 0] = "vertex";
      ShaderStage2[ShaderStage2["fragment"] = 1] = "fragment";
      ShaderStage2[ShaderStage2["computer"] = 2] = "computer";
      return ShaderStage2;
    })(ShaderStage || {});

    class ShaderState {
      blendMode = BlendMode.NONE;
      depthCompare = GPUCompareFunction.less;
      depthWriteEnabled = true;
      frontFace = `ccw`;
      cullMode = GPUCullMode.back;
      topology = GPUPrimitiveTopology.triangle_list;
      depthBias = 10;
      useLight = false;
      useProbe = false;
      acceptGI = false;
      acceptShadow = false;
      castShadow = false;
      castReflection = false;
      receiveEnv = false;
      renderLayer = 1e3;
      renderOrder = 2e3;
      unclippedDepth = false;
      transparent = false;
      multisample = 0;
      label;
      useZ = true;
      splitTexture = false;
      alphaCutoff;
      useFragDepth = false;
      writeMasks = [];
      setFromMapValues(values) {
        if (values.has("blendMode")) {
          this.blendMode = this.convertBlendMode(values.get("blendMode"));
        }
        if (values.has("depthCompare")) {
          this.depthCompare = values.get("depthCompare");
        }
        if (values.has("depthWriteEnabled")) {
          this.depthWriteEnabled = values.get("depthWriteEnabled");
        }
        if (values.has("frontFace")) {
          this.frontFace = values.get("frontFace");
        }
        if (values.has("cullMode")) {
          this.cullMode = values.get("cullMode");
        }
        if (values.has("topology")) {
          this.topology = values.get("topology");
        }
        if (values.has("depthBias")) {
          this.depthBias = values.get("depthBias");
        }
        if (values.has("useLight")) {
          this.useLight = values.get("useLight");
        }
        if (values.has("useProbe")) {
          this.useProbe = values.get("useProbe");
        }
        if (values.has("acceptGI")) {
          this.acceptGI = values.get("acceptGI");
        }
        if (values.has("acceptShadow")) {
          this.acceptShadow = values.get("acceptShadow");
        }
        if (values.has("castShadow")) {
          this.castShadow = values.get("castShadow");
        }
        if (values.has("receiveEnv")) {
          this.receiveEnv = values.get("receiveEnv");
        }
        if (values.has("renderLayer")) {
          this.renderLayer = values.get("renderLayer");
        }
        if (values.has("renderOrder")) {
          this.renderOrder = values.get("renderOrder");
        }
        if (values.has("unclippedDepth")) {
          this.unclippedDepth = values.get("unclippedDepth");
        }
        if (values.has("multisample")) {
          this.multisample = values.get("multisample");
        }
        if (values.has("label")) {
          this.label = values.get("label");
        }
        if (values.has("useZ")) {
          this.useZ = values.get("useZ");
        }
      }
      convertBlendMode(value) {
        switch (value) {
          case "ABOVE":
            return BlendMode.ABOVE;
          case "ALPHA":
            return BlendMode.ALPHA;
          case "NORMAL":
            return BlendMode.NORMAL;
          case "ADD":
            return BlendMode.ADD;
          case "BELOW":
            return BlendMode.BELOW;
          case "ERASE":
            return BlendMode.ERASE;
          case "MUL":
            return BlendMode.MUL;
          case "SCREEN":
            return BlendMode.SCREEN;
          case "DIVD":
            return BlendMode.DIVD;
          case "SOFT_ADD":
            return BlendMode.SOFT_ADD;
        }
        return BlendMode.NONE;
      }
    }

    class MaterialDataUniformGPUBuffer extends GPUBufferBase {
      uniformNodes = [];
      _onChange = true;
      constructor() {
        super();
        this.bufferType = GPUBufferType.MaterialDataUniformGPUBuffer;
      }
      /**
       * Initialize bound shader base variables
       * The array of variables is automatically mapped through the parameters of the shader reflection
       * @param uniformNodes 
       * @see UniformNode
       */
      initDataUniform(uniformNodes) {
        this.uniformNodes = uniformNodes;
        let len = 0;
        for (const key in uniformNodes) {
          const node = uniformNodes[key];
          if (!node) {
            console.error(key, "is empty");
          }
          len += node.size * 4;
        }
        len = Math.floor(len / 256 + 1) * 256;
        this.createBuffer(GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, len / 4, null, "MaterialDataUniformGPUBuffer");
        for (const key in uniformNodes) {
          const node = uniformNodes[key];
          if (!node)
            console.error(key, "is empty");
          let memoryInfo = this.memory.allocation_node(node.size * 4);
          node.memoryInfo = memoryInfo;
          node.bindOnChange = () => this.onChange();
        }
      }
      onChange() {
        this._onChange = true;
      }
      /**
       * Reapply and write to buffer
       * @returns 
       */
      apply() {
        if (this.uniformNodes.length == 0)
          return;
        if (!this._onChange)
          return;
        for (const key in this.uniformNodes) {
          const node = this.uniformNodes[key];
          node.update();
        }
        super.apply();
        this._onChange = false;
      }
    }

    class ShaderUtil {
      static renderShaderModulePool;
      static renderShader;
      static init() {
        this.renderShaderModulePool = /* @__PURE__ */ new Map();
        this.renderShader = /* @__PURE__ */ new Map();
      }
    }

    class Reference {
      reference;
      static _ins;
      static getInstance() {
        this._ins ||= new Reference();
        return this._ins;
      }
      /**
       * current instance attached from parent instance
       * @param ref reference current 
       * @param target reference parent
       */
      attached(ref, target) {
        this.reference ||= /* @__PURE__ */ new Map();
        let refMap = this.reference.get(ref);
        refMap ||= /* @__PURE__ */ new Map();
        refMap.set(target, ref);
        this.reference.set(ref, refMap);
      }
      /**
       * current instance detached from parent instance
       * @param ref reference current 
       * @param target reference parent
       */
      detached(ref, target) {
        let refMap = this.reference.get(ref);
        if (refMap) {
          refMap.delete(target);
        }
      }
      /**
       * current instance has reference 
       */
      hasReference(ref) {
        let refMap = this.reference.get(ref);
        if (refMap) {
          return refMap.size > 0;
        }
        return false;
      }
      /**
       * get current instance reference count
       * @param ref 
       * @returns 
       */
      getReferenceCount(ref) {
        let refMap = this.reference.get(ref);
        if (refMap) {
          return refMap.size;
        }
        return 0;
      }
      /**
      * get current instance reference from where
      * @param ref 
      * @returns 
      */
      getReference(ref) {
        let refMap = this.reference.get(ref);
        if (refMap) {
          return refMap;
        }
        return null;
      }
    }

    class PipelinePool {
      static pipelineMap = /* @__PURE__ */ new Map();
      static getSharePipeline(shaderVariant) {
        let pipeline = this.pipelineMap.get(shaderVariant);
        if (pipeline) {
          return pipeline;
        } else {
          return null;
        }
      }
      static setSharePipeline(shaderVariant, pipeline) {
        this.pipelineMap.set(shaderVariant, pipeline);
      }
    }

    class RenderShaderPass extends ShaderPassBase {
      passType = PassType.COLOR;
      useRz = false;
      /**
       * Vertex shader name
       */
      vsName;
      /**
       * Fragment shader name
       */
      fsName;
      /**
       * State of the shader
       */
      shaderState;
      /**
       * The collection of textures used in shading
       */
      textures;
      /**
       * Render pipeline
       */
      pipeline;
      /**
       * BindGroup layout
       */
      bindGroupLayouts;
      envMap;
      prefilterMap;
      _sourceVS;
      _sourceFS;
      _destVS;
      _destFS;
      _vsShaderModule;
      _fsShaderModule;
      _textureGroup = -1;
      _textureChange = false;
      _groupsShaderReflectionVarInfos;
      outBufferMask;
      constructor(vs, fs) {
        super();
        this.vsName = vs.toLowerCase();
        this.fsName = fs.toLowerCase();
        if (!(this.vsName in ShaderLib)) {
          console.error(`Shader Not Register, Please Register Shader!`, this.vsName);
        }
        if (!(this.fsName in ShaderLib)) {
          console.error(`Shader Not Register, Please Register Shader!`, this.fsName);
        }
        if (ShaderLib[this.vsName]) {
          this._sourceVS = ShaderLib[this.vsName];
        }
        if (ShaderLib[this.fsName]) {
          this._sourceFS = ShaderLib[this.fsName];
        }
        this.textures = {};
        this.bindGroups = [];
        this.shaderState = new ShaderState();
        this.materialDataUniformBuffer = new MaterialDataUniformGPUBuffer();
        this.materialDataUniformBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
        this._bufferDic.set(`global`, this.materialDataUniformBuffer);
        this._bufferDic.set(`materialUniform`, this.materialDataUniformBuffer);
      }
      /**
       * Blend mode
       */
      get renderOrder() {
        return this.shaderState.renderOrder;
      }
      set renderOrder(value) {
        if (this.shaderState.renderOrder != value) {
          this._valueChange = true;
        }
        this.shaderState.renderOrder = value;
      }
      /**
          * Cull mode
          */
      get doubleSide() {
        return this.shaderState.cullMode == GPUCullMode.none;
      }
      set doubleSide(value) {
        let b = value ? GPUCullMode.none : this.cullMode;
        if (this.shaderState.cullMode != b) {
          this._valueChange = true;
        }
        this.shaderState.cullMode = b;
      }
      /**
       * depthWriteEnabled mode
       */
      get depthWriteEnabled() {
        return this.shaderState.depthWriteEnabled;
      }
      set depthWriteEnabled(value) {
        if (this.shaderState.depthWriteEnabled != value) {
          this._valueChange = true;
        }
        this.shaderState.depthWriteEnabled = value;
      }
      /**
       * get render face cull mode
       */
      get cullMode() {
        return this.shaderState.cullMode;
      }
      /**
       * set render face cull mode
       */
      set cullMode(value) {
        if (this.shaderState.cullMode != value) {
          this._valueChange = true;
        }
        this.shaderState.cullMode = value;
      }
      /**
       * get front face mode
       * @GPUFrontFace
       */
      get frontFace() {
        return this.shaderState.frontFace;
      }
      /**
       * set front face mode
       * @GPUFrontFace value
       */
      set frontFace(value) {
        if (this.shaderState.frontFace != value) {
          this._valueChange = true;
        }
        this.shaderState.frontFace = value;
      }
      /**
       * Depth bias
       */
      get depthBias() {
        return this.shaderState.depthBias;
      }
      set depthBias(value) {
        if (this.shaderState.depthBias != value) {
          this._valueChange = true;
        }
        this.shaderState.depthBias = value;
      }
      /**
       * Primitive topology
       */
      get topology() {
        return this.shaderState.topology;
      }
      set topology(value) {
        if (this.shaderState.topology != value) {
          this._valueChange = true;
        }
        this.shaderState.topology = value;
      }
      /**
       * Blend mode
       */
      get blendMode() {
        return this.shaderState.blendMode;
      }
      set blendMode(value) {
        if (this.shaderState.blendMode != value) {
          this._valueChange = true;
          if (value != BlendMode.NORMAL && value != BlendMode.NONE) {
            this.renderOrder = 3e3;
          }
        }
        this.shaderState.blendMode = value;
      }
      /**
       * Depth compare function
       */
      get depthCompare() {
        return this.shaderState.depthCompare;
      }
      set depthCompare(value) {
        if (this.shaderState.depthCompare != value) {
          this._valueChange = true;
        }
        this.shaderState.depthCompare = value;
      }
      /**
       * Sets the entry point names for the RenderShader vertex phase and fragment phase
       * @param vsEntryPoint 
       * @param fsEntryPoint 
       */
      setShaderEntry(vsEntryPoint = "", fsEntryPoint = "") {
        this.vsEntryPoint = vsEntryPoint;
        this.fsEntryPoint = fsEntryPoint;
      }
      /**
       * 
       * @param String name 
       * @param UniformValue value 
       */
      setUniform(name, value) {
        super.setUniform(name, value);
        this.materialDataUniformBuffer.onChange();
      }
      /**
       * Set the texture used in the Render Shader code
       * @param name Name in the shader code
       * @param texture Texture object
       */
      setTexture(name, texture) {
        if (texture && this.textures[name] != texture) {
          if (this.textures[name]) {
            this.textures[name].unBindStateChange(this);
          }
          this._textureChange = true;
          this.textures[name] = texture;
          if (name == "envMap") {
            this.envMap = texture;
          } else if (name == "prefilterMap") {
            this.prefilterMap = texture;
          }
          texture.bindStateChange(() => {
            this._textureChange = true;
          }, this);
        }
      }
      get baseColor() {
        return this.getUniform(`baseColor`);
      }
      set baseColor(value) {
        this.setUniform(`baseColor`, value);
      }
      /**
       * Get the texture used in the Render Shader code
       * @param name Name in the shader code
       * @returns Texture object
       */
      getTexture(name) {
        return this.textures[name];
      }
      /**
       * Create a rendering pipeline
       * @param geometry 
       * @param renderPassState 
       */
      genRenderPipeline(geometry, renderPassState) {
        let layouts = this.createGroupLayouts();
        this.createPipeline(geometry, renderPassState, layouts);
      }
      /**
       * Recompile the shader and create the rendering pipeline
       * @param geometry 
       * @param rendererPassState 
       */
      reBuild(geometry, rendererPassState) {
        this.compileShader(ShaderStage.vertex, this._destVS, rendererPassState);
        this.compileShader(ShaderStage.fragment, this._destFS, rendererPassState);
        this.genRenderPipeline(geometry, rendererPassState);
      }
      /**
       * Apply render shader state value 
       * @param geometry 
       * @param materialPass 
       * @param rendererPassState 
       * @param noticeFun 
       */
      apply(geometry, rendererPassState, noticeFun) {
        this.materialDataUniformBuffer.apply();
        if (this._textureChange && this._textureGroup != -1) {
          this._textureChange = false;
          this.genGroups(this._textureGroup, this.shaderReflection.groups, true);
        }
        if (this._valueChange) {
          if (this._shaderChange) {
            this.preCompile(geometry);
            this._shaderChange = false;
          }
          this.shaderVariant = ShaderReflection.genRenderShaderVariant(this);
          this.reBuild(geometry, rendererPassState);
          this._valueChange = false;
          if (noticeFun) {
            noticeFun();
          }
        }
      }
      /**
       * Precompile the shader code
       * @param geometry 
       */
      preCompile(geometry) {
        this.preDefine(geometry);
        this.preCompileShader(ShaderStage.vertex, this._sourceVS.concat());
        this.preCompileShader(ShaderStage.fragment, this._sourceFS.concat());
        this.genReflection();
      }
      /**
       * Apply defines syntax values
       * @param shader 
       * @param renderPassState 
       * @returns 
       */
      applyPostDefine(shader, renderPassState) {
        if (renderPassState.renderTargetTextures.length > 1) {
          this.defineValue[`USE_WORLDPOS`] = true;
          this.defineValue[`USEGBUFFER`] = true;
        } else {
          this.defineValue[`USE_WORLDPOS`] = false;
          this.defineValue[`USEGBUFFER`] = false;
        }
        return Preprocessor.parse(shader, this.defineValue);
      }
      /**
       * Set GPUBindGroup to the specified index slot
       * @param groupIndex 
       * @param group 
       */
      setBindGroup(groupIndex, group) {
        this.bindGroups[groupIndex] = group;
      }
      checkBuffer(bufferName, buffer) {
        return;
      }
      preCompileShader(stage, code, format) {
        let shader = code;
        if (shader.indexOf(`version `) != -1) {
          var wgsl = ShaderConverter.convertGLSL(shader);
          shader = wgsl.sourceCode;
        }
        for (const key in this.constValues) {
          if (Object.prototype.hasOwnProperty.call(this.constValues, key)) {
            const value = this.constValues[key];
            shader = shader.replaceAll(`&${key}`, value.toString());
          }
        }
        switch (stage) {
          case ShaderStage.vertex:
            this._destVS = shader;
            break;
          case ShaderStage.fragment:
            this._destFS = shader;
            break;
        }
      }
      compileShader(stage, code, renderPassState) {
        let shader = code;
        shader = this.applyPostDefine(shader, renderPassState);
        let key = code;
        for (let k in this.defineValue) {
          key += `${k}=${this.defineValue[k]},`;
        }
        let shaderModule = ShaderUtil.renderShaderModulePool.get(key);
        if (!shaderModule) {
          shader = this.applyPostDefine(shader, renderPassState);
          shaderModule = webGPUContext.device.createShaderModule({
            label: stage == ShaderStage.vertex ? this.vsName : this.fsName,
            code: shader
          });
          shaderModule.getCompilationInfo().then((e) => {
            if (e.messages.length > 0) {
              console.log(shader);
              console.log(e);
            }
          });
          ShaderUtil.renderShaderModulePool.set(key, shaderModule);
        }
        switch (stage) {
          case ShaderStage.vertex:
            this._vsShaderModule = shaderModule;
            this._destVS = shader;
            break;
          case ShaderStage.fragment:
            this._fsShaderModule = shaderModule;
            this._destFS = shader;
            break;
        }
      }
      getGroupLayout(index, infos) {
        let entries = [];
        for (let i = 0; i < infos.length; i++) {
          const info = infos[i];
          if (!info) {
            continue;
          }
          if (info.varType == `uniform`) {
            if (!this._bufferDic.has(info.varName)) {
              console.error(`not set ${info.varName} buffer`);
            }
            let visibility = this._bufferDic.get(info.varName).visibility;
            let entry = {
              binding: info.binding,
              visibility,
              buffer: {
                type: "uniform"
              }
            };
            entries.push(entry);
          } else if (info.varType == `storage-read`) {
            if (!this._bufferDic.has(info.varName)) {
              console.error(`not set ${info.varName} buffer`);
            }
            let visibility = this._bufferDic.get(info.varName).visibility;
            let entry = {
              binding: info.binding,
              visibility,
              buffer: {
                type: "read-only-storage"
              }
            };
            entries.push(entry);
          } else if (info.varType == `var`) {
            switch (info.dataType) {
              case `sampler`:
                {
                  let textureName = info.varName.replace(`Sampler`, ``);
                  let texture = this.textures[textureName] ? this.textures[textureName] : Engine3D.res.redTexture;
                  let entry = {
                    binding: info.binding,
                    visibility: texture.visibility,
                    sampler: texture.samplerBindingLayout
                  };
                  entries.push(entry);
                  this._textureGroup = index;
                }
                break;
              case `sampler_comparison`:
                {
                  let textureName = info.varName.replace(`Sampler`, ``);
                  let texture = this.textures[textureName] ? this.textures[textureName] : Engine3D.res.redTexture;
                  let entry = {
                    binding: info.binding,
                    visibility: texture.visibility,
                    sampler: texture.sampler_comparisonBindingLayout
                  };
                  entries.push(entry);
                  this._textureGroup = index;
                }
                break;
              case `texture_2d<f32>`:
              case `texture_2d_array<f32>`:
              case `texture_cube<f32>`:
              case `texture_depth_2d`:
              case `texture_depth_2d_array`:
              case `texture_depth_cube`:
              case `texture_depth_cube_array`:
                {
                  let texture = this.textures[info.varName] ? this.textures[info.varName] : Engine3D.res.redTexture;
                  let entry = {
                    binding: info.binding,
                    visibility: texture.visibility,
                    texture: texture.textureBindingLayout
                  };
                  entries.push(entry);
                  this._textureGroup = index;
                  Reference.getInstance().attached(texture, this);
                }
                break;
              case `texture_external`:
                {
                  let texture = this.textures[info.varName] ? this.textures[info.varName] : Engine3D.res.redTexture;
                  let entry = {
                    binding: info.binding,
                    visibility: texture.visibility,
                    externalTexture: {}
                  };
                  entries.push(entry);
                  this._textureGroup = index;
                  Reference.getInstance().attached(texture, this);
                }
                break;
              default:
                {
                  let texture = this.textures[info.varName] ? this.textures[info.varName] : Engine3D.res.redTexture;
                  let entry = {
                    binding: info.binding,
                    visibility: texture.visibility,
                    texture: texture.textureBindingLayout
                  };
                  entries.push(entry);
                  this._textureGroup = index;
                  Reference.getInstance().attached(texture, this);
                }
                break;
            }
          } else {
            debugger;
            console.error("bind group can't empty");
          }
        }
        return entries;
      }
      _cacheEntries;
      genGroups(groupIndex, infos, force = false) {
        if (!this.bindGroups[groupIndex] || force) {
          const shaderRefs = infos[groupIndex];
          let entries = [];
          for (let j = 0; j < shaderRefs.length; j++) {
            const refs = shaderRefs[j];
            if (!refs)
              continue;
            if (refs.varType == `uniform`) {
              let buffer = this._bufferDic.get(refs.varName);
              if (buffer) {
                if (buffer.bufferType == GPUBufferType.MaterialDataUniformGPUBuffer) {
                  let uniforms = [];
                  for (let i = 0; i < refs.dataFields.length; i++) {
                    const field = refs.dataFields[i];
                    if (!this.uniforms[field.name]) {
                      console.error(`shader-${this.vsName}:${this.fsName} ${field.name}is empty`);
                    }
                    uniforms.push(this.uniforms[field.name]);
                  }
                  this.materialDataUniformBuffer.initDataUniform(uniforms);
                }
                let entry = {
                  binding: refs.binding,
                  resource: {
                    buffer: buffer.buffer,
                    offset: 0,
                    //buffer.memory.shareFloat32Array.byteOffset,
                    size: buffer.memory.shareDataBuffer.byteLength
                  }
                };
                entries.push(entry);
                this.checkBuffer(refs.varName, buffer);
              } else {
                console.error(`shader${this.vsName}-${this.fsName}`, `buffer ${refs.varName} is missing!`);
              }
            } else if (refs.varType == `storage-read`) {
              let buffer = this._bufferDic.get(refs.varName);
              if (buffer) {
                let entry = {
                  binding: refs.binding,
                  resource: {
                    buffer: buffer.buffer,
                    offset: 0,
                    //buffer.memory.shareFloat32Array.byteOffset,
                    size: buffer.memory.shareDataBuffer.byteLength
                  }
                };
                entries.push(entry);
                this.checkBuffer(refs.varName, buffer);
              } else {
                console.error(`buffer ${refs.varName} is missing!`);
              }
            } else if (refs.varType == `var`) {
              if (refs.dataType == `sampler`) {
                let textureName = refs.varName.replace(`Sampler`, ``);
                let texture = this.textures[textureName];
                if (!texture) {
                  texture = Engine3D.res.blackTexture;
                  this.setTexture(textureName, texture);
                }
                if (texture) {
                  let entry = {
                    binding: refs.binding,
                    resource: texture.gpuSampler
                  };
                  entries.push(entry);
                } else {
                  console.error(`shader${this.vsName}-${this.fsName}`, `texture ${refs.varName} is missing! `);
                }
              } else if (refs.dataType == `sampler_comparison`) {
                let textureName = refs.varName.replace(`Sampler`, ``);
                let texture = this.textures[textureName];
                if (texture) {
                  let entry = {
                    binding: refs.binding,
                    resource: texture.gpuSampler_comparison
                  };
                  entries.push(entry);
                } else {
                  console.error(`shader${this.vsName}-${this.fsName}`, `texture ${refs.varName} is missing! `);
                }
              } else {
                let texture = this.textures[refs.varName];
                if (!texture) {
                  texture = Engine3D.res.whiteTexture;
                  this.setTexture(refs.varName, texture);
                }
                if (texture) {
                  let entry = {
                    binding: refs.binding,
                    resource: texture.getGPUView()
                  };
                  entries.push(entry);
                } else {
                  console.error(`shader${this.vsName}-${this.fsName}`, `texture ${refs.varName} is missing! `);
                }
              }
            }
          }
          let gpubindGroup = webGPUContext.device.createBindGroup({
            layout: this.bindGroupLayouts[groupIndex],
            entries
          });
          this.bindGroups[groupIndex] = gpubindGroup;
        }
      }
      createPipeline(geometry, renderPassState, layouts) {
        let bufferMesh = geometry;
        let shaderState = this.shaderState;
        let targets = [];
        for (const tex of renderPassState.renderTargetTextures) {
          targets.push({
            format: tex.format
          });
        }
        for (let i = 0; i < targets.length; i++) {
          const rtTexState = targets[i];
          if (shaderState.writeMasks && shaderState.writeMasks.length > 0) {
            rtTexState.writeMask = shaderState.writeMasks[i];
          }
        }
        if (renderPassState.outColor != -1) {
          let target = targets[renderPassState.outColor];
          if (shaderState.blendMode != BlendMode.NONE) {
            target.blend = BlendFactor.getBlend(shaderState.blendMode);
          } else {
            delete target[`blend`];
          }
        }
        let renderPipelineDescriptor = {
          label: this.vsName + "|" + this.fsName,
          layout: layouts,
          primitive: {
            topology: shaderState.topology,
            cullMode: shaderState.cullMode,
            frontFace: shaderState.frontFace
          },
          vertex: void 0
        };
        if (this.vsEntryPoint != ``) {
          renderPipelineDescriptor[`vertex`] = {
            module: this._vsShaderModule,
            entryPoint: this.vsEntryPoint,
            buffers: bufferMesh.vertexBuffer.vertexBufferLayouts
          };
        }
        if (this.fsEntryPoint != "") {
          renderPipelineDescriptor[`fragment`] = {
            module: this._fsShaderModule,
            entryPoint: this.fsEntryPoint,
            targets
          };
        }
        if (shaderState.multisample > 0) {
          renderPipelineDescriptor[`multisample`] = {
            count: shaderState.multisample
          };
        }
        if (renderPassState.zPreTexture || renderPassState.depthTexture) {
          shaderState.blendMode != BlendMode.NONE;
          if (Engine3D.setting.render.zPrePass && renderPassState.zPreTexture && shaderState.useZ) {
            renderPipelineDescriptor[`depthStencil`] = {
              depthWriteEnabled: false,
              depthCompare: GPUCompareFunction.less,
              format: renderPassState.zPreTexture.format
            };
          } else {
            renderPipelineDescriptor[`depthStencil`] = {
              depthWriteEnabled: shaderState.depthWriteEnabled,
              depthCompare: shaderState.depthCompare,
              format: renderPassState.depthTexture.format
            };
          }
        }
        let pipeline = PipelinePool.getSharePipeline(this.shaderVariant);
        if (pipeline) {
          this.pipeline = pipeline;
        } else {
          this.pipeline = GPUContext.createPipeline(renderPipelineDescriptor);
          PipelinePool.setSharePipeline(this.shaderVariant, this.pipeline);
        }
      }
      createGroupLayouts() {
        this._groupsShaderReflectionVarInfos = [];
        let shaderReflection = this.shaderReflection;
        this.bindGroupLayouts = [GlobalBindGroupLayout.getGlobalDataBindGroupLayout()];
        for (let i = 1; i < shaderReflection.groups.length; i++) {
          let shaderRefs = shaderReflection.groups[i];
          if (shaderRefs) {
            let entries = this.getGroupLayout(i, shaderRefs);
            this._groupsShaderReflectionVarInfos[i] = shaderRefs;
            let layout = webGPUContext.device.createBindGroupLayout({
              entries,
              label: `vs${this.vsName} fs${this.fsName} ${shaderRefs.length}`
            });
            this.bindGroupLayouts[i] = layout;
          } else {
            console.error("can't set empty group!", i);
          }
        }
        let layouts = webGPUContext.device.createPipelineLayout({
          bindGroupLayouts: this.bindGroupLayouts
        });
        if (this._groupsShaderReflectionVarInfos[0]) ;
        if (this._groupsShaderReflectionVarInfos[1]) {
          this.genGroups(1, this._groupsShaderReflectionVarInfos);
        }
        if (this._groupsShaderReflectionVarInfos[2]) {
          this.genGroups(2, this._groupsShaderReflectionVarInfos);
        }
        if (this._groupsShaderReflectionVarInfos[3]) {
          this.genGroups(3, this._groupsShaderReflectionVarInfos);
        }
        return layouts;
      }
      preDefine(geometry) {
        let useSecondUV = geometry.hasAttribute(VertexAttributeName.TEXCOORD_1);
        let isSkeleton = geometry.hasAttribute(VertexAttributeName.joints0);
        let hasMorphTarget = geometry.hasAttribute(VertexAttributeName.a_morphPositions_0);
        let useTangent = geometry.hasAttribute(VertexAttributeName.TANGENT);
        let useVertexColor = geometry.hasAttribute(VertexAttributeName.color);
        let useGI = this.shaderState.acceptGI;
        let useLight = this.shaderState.useLight;
        if (useSecondUV) {
          this.defineValue[`USE_SECONDUV`] = true;
        }
        if (isSkeleton && hasMorphTarget) {
          this.defineValue[`USE_METAHUMAN`] = true;
        } else {
          this.defineValue[`USE_SKELETON`] = isSkeleton;
          this.defineValue[`USE_MORPHTARGETS`] = hasMorphTarget;
        }
        if (!("USE_TANGENT" in this.defineValue)) {
          this.defineValue[`USE_TANGENT`] = useTangent;
        }
        this.defineValue[`USE_GI`] = useGI;
        this.defineValue[`USE_SHADOWMAPING`] = this.shaderState.acceptShadow;
        this.defineValue[`USE_LIGHT`] = useLight;
        this.defineValue[`USE_VERTXCOLOR`] = useVertexColor;
        if (Engine3D.setting.pick.mode == `pixel`) {
          this.defineValue[`USE_WORLDPOS`] = true;
        }
        if (Engine3D.setting.gi.enable) {
          this.defineValue[`USEGI`] = true;
        } else {
          this.defineValue[`USEGI`] = false;
        }
        if (Engine3D.setting.render.debug) {
          this.defineValue[`USE_DEBUG`] = true;
          this.defineValue[`DEBUG_CLUSTER`] = true;
        }
        if (this.shaderState.useLight) {
          this.defineValue[`USE_LIGHT`] = true;
        } else {
          this.defineValue[`USE_LIGHT`] = false;
        }
        if (Engine3D.setting.render.useLogDepth) {
          this.defineValue[`USE_LOGDEPTH`] = true;
          this.shaderState.useFragDepth = true;
        } else {
          this.defineValue[`USE_LOGDEPTH`] = false;
        }
        if (this.shaderState.useFragDepth) {
          this.defineValue[`USE_OUTDEPTH`] = true;
        } else {
          this.defineValue[`USE_OUTDEPTH`] = false;
        }
        this.defineValue[`USE_PCF_SHADOW`] = Engine3D.setting.shadow.type == `PCF`;
        this.defineValue[`USE_HARD_SHADOW`] = Engine3D.setting.shadow.type == `HARD`;
        this.defineValue[`USE_SOFT_SHADOW`] = Engine3D.setting.shadow.type == `SOFT`;
        this.defineValue[`USE_CSM`] = CSM.Cascades > 1;
        this.defineValue[`USE_IES_PROFILE`] = IESProfiles.use;
      }
      genReflection() {
        this.shaderVariant = ShaderReflection.genRenderShaderVariant(this);
        let reflection = ShaderReflection.poolGetReflection(this.shaderVariant);
        if (!reflection) {
          let vsPreShader = Preprocessor.parse(this._destVS, this.defineValue);
          vsPreShader = Preprocessor.parse(vsPreShader, this.defineValue);
          ShaderReflection.getShaderReflection2(vsPreShader, this);
          let fsPreShader = Preprocessor.parse(this._destFS, this.defineValue);
          fsPreShader = Preprocessor.parse(fsPreShader, this.defineValue);
          ShaderReflection.getShaderReflection2(fsPreShader, this);
          ShaderReflection.final(this);
        } else {
          this.shaderReflection = reflection;
        }
        this.shaderState.splitTexture = this.shaderReflection.useSplit;
      }
      /**
       * Destroy and release render shader related resources
       */
      destroy(force) {
        for (const key in this.textures) {
          if (Object.prototype.hasOwnProperty.call(this.textures, key)) {
            const texture = this.textures[key];
            Reference.getInstance().detached(texture, this);
            if (force && !Reference.getInstance().hasReference(texture)) {
              texture.destroy(force);
            } else {
              texture.destroy(false);
              let table = Reference.getInstance().getReference(texture);
              if (table) {
                let list = [];
                table.forEach((v, k) => {
                  if (`name` in v) {
                    list.push(v[`name`]);
                  } else {
                    list.push(`NaN`);
                  }
                });
              }
            }
          }
        }
        this.bindGroups.length = 0;
        this.shaderState = null;
        this.textures = null;
        this.pipeline = null;
        this.bindGroupLayouts = null;
        this._sourceVS = null;
        this._sourceFS = null;
        this._destVS = null;
        this._destFS = null;
        this._vsShaderModule = null;
        this._fsShaderModule = null;
        this.materialDataUniformBuffer.destroy(force);
        this.materialDataUniformBuffer = null;
      }
      /**
       * Destroy a RenderShader object
       * @param instanceID instance ID of the RenderShader
       */
      static destroyShader(instanceID) {
        if (ShaderUtil.renderShader.has(instanceID)) {
          let shader = ShaderUtil.renderShader.get(instanceID);
          shader.destroy();
          ShaderUtil.renderShader.delete(instanceID);
        }
      }
      /**
       * Get the RenderShader object by specifying the RenderShader instance ID
       * @param instanceID instance ID of the RenderShader
       * @returns RenderShader object
       */
      static getShader(instanceID) {
        return ShaderUtil.renderShader.get(instanceID);
      }
      /**
       * Create a RenderShader with vertex shaders and fragment shaders
       * @param vs Vertex shader name
       * @param fs Fragment shader name
       * @returns Returns the instance ID of the RenderShader
       */
      static createShader(vs, fs) {
        let shader = new RenderShaderPass(vs, fs);
        ShaderUtil.renderShader.set(shader.instanceID, shader);
        return shader.instanceID;
      }
    }

    class SkyGBufferPass extends RenderShaderPass {
      constructor() {
        super(`sky_vs_frag_wgsl`, `SkyGBuffer_fs`);
        this.passType = PassType.GI;
        this.setUniformVector3(`eyesPos`, new Vector3());
        this.setUniformFloat(`exposure`, 1);
        this.setUniformFloat(`roughness`, 0);
        let shaderState = this.shaderState;
        shaderState.frontFace = `ccw`;
        shaderState.cullMode = GPUCullMode.front;
        shaderState.depthWriteEnabled = false;
        shaderState.depthCompare = GPUCompareFunction.less;
      }
    }

    class GBufferPass extends RenderShaderPass {
      transparency;
      constructor() {
        super(`gbuffer_vs`, `gbuffer_fs`);
        this.setShaderEntry(`VertMain`, `FragMain`);
        this.passType = PassType.GI;
        this.setUniformColor(`baseColor`, new Color());
        this.setUniformColor(`emissiveColor`, new Color());
        this.setUniformFloat(`emissiveIntensity`, 1);
        this.setUniformFloat(`normalScale`, 1);
        this.setUniformFloat(`alphaCutoff`, 1);
        this.blendMode = BlendMode.NONE;
        this.setTexture(`normalMap`, Engine3D.res.normalTexture);
      }
    }

    class CastShadowMaterialPass extends RenderShaderPass {
      constructor() {
        super(`shadowCastMap_vert`, `directionShadowCastMap_frag`);
        this.passType = PassType.SHADOW;
        this.setShaderEntry("main");
        this.setUniformFloat("cameraFar", 5e3);
        this.setUniformVector3("lightWorldPos", Vector3.ZERO);
        this.shaderState.receiveEnv = false;
        this.shaderState.castShadow = false;
        this.shaderState.acceptShadow = false;
        this.setDefine(`USE_ALPHACUT`, true);
      }
    }

    class CastPointShadowMaterialPass extends RenderShaderPass {
      constructor() {
        super(`castPointShadowMap_vert`, `shadowCastMap_frag`);
        this.passType = PassType.POINT_SHADOW;
        this.setShaderEntry("main", "main");
        this.setUniformFloat("cameraFar", 5e3);
        this.setUniformVector3("lightWorldPos", Vector3.ZERO);
        this.shaderState.receiveEnv = false;
        this.shaderState.castShadow = false;
        this.shaderState.acceptShadow = false;
        this.setDefine(`USE_ALPHACUT`, true);
      }
    }

    class DepthMaterialPass extends RenderShaderPass {
      constructor() {
        super(`ZPass_shader_vs`, `ZPass_shader_vs`);
        this.passType = PassType.DEPTH;
        this.setShaderEntry("main");
        this.useRz = false;
        let shaderState = this.shaderState;
        shaderState.receiveEnv = false;
      }
    }

    class PassGenerate {
      static createGIPass(renderNode, shader) {
        if (RendererMaskUtil.hasMask(renderNode.rendererMask, RendererMask.Sky)) {
          let pass0 = shader.passShader.get(PassType.GI);
          if (!pass0) {
            let colorPass = shader.getSubShaders(PassType.COLOR)[0];
            let pass = new SkyGBufferPass();
            pass.setTexture(`baseMap`, colorPass.getTexture("baseMap"));
            pass.cullMode = colorPass.cullMode;
            pass.frontFace = colorPass.frontFace;
            shader.addRenderPass(pass, 0);
            pass.preCompile(renderNode.geometry);
          }
        } else {
          this.castGBufferPass(renderNode, shader);
        }
      }
      static castGBufferPass(renderNode, shader) {
        let colorPassList = shader.getDefaultShaders();
        for (let jj = 0; jj < colorPassList.length; jj++) {
          const colorPass = colorPassList[jj];
          let giPassList = shader.getSubShaders(PassType.GI);
          if (!giPassList || giPassList.length == 0 || giPassList.length < jj) {
            let pass = new GBufferPass();
            pass.setTexture("baseMap", colorPass.getTexture("baseMap"));
            pass.setTexture("normalMap", colorPass.getTexture("normalMap"));
            pass.setTexture("emissiveMap", colorPass.getTexture("emissiveMap"));
            pass.setUniform("baseColor", colorPass.getUniform("baseColor"));
            pass.setUniform("envIntensity", colorPass.getUniform("envIntensity"));
            pass.setUniform("emissiveColor", colorPass.getUniform("emissiveColor"));
            pass.setUniform("emissiveIntensity", colorPass.getUniform("emissiveIntensity"));
            pass.setUniform("alphaCutoff", colorPass.getUniform("alphaCutoff"));
            pass.cullMode = colorPass.cullMode;
            pass.frontFace = colorPass.frontFace;
            pass.preCompile(renderNode.geometry);
            shader.addRenderPass(pass);
          }
        }
      }
      static createShadowPass(renderNode, shader) {
        let use_skeleton = RendererMaskUtil.hasMask(renderNode.rendererMask, RendererMask.SkinnedMesh);
        let useTangent = renderNode.geometry.hasAttribute(VertexAttributeName.TANGENT);
        let useMorphTargets = renderNode.geometry.hasAttribute(GLTFType.MORPH_POSITION_PREFIX + "0");
        let useMorphNormals = renderNode.geometry.hasAttribute(GLTFType.MORPH_NORMAL_PREFIX + "0");
        let colorPassList = shader.getSubShaders(PassType.COLOR);
        for (let i = 0; i < colorPassList.length; i++) {
          const colorPass = colorPassList[i];
          let shadowPassList = shader.getSubShaders(PassType.SHADOW);
          if (!shadowPassList || shadowPassList.length < i + 1) {
            let shadowPass = new CastShadowMaterialPass();
            shadowPass.setTexture(`baseMap`, colorPass.getTexture(`baseMap`));
            shadowPass.setUniform(`alphaCutoff`, colorPass.getUniform(`alphaCutoff`));
            if (useTangent) {
              shadowPass.setDefine(`USE_TANGENT`, useTangent);
            }
            if (use_skeleton) {
              shadowPass.setDefine(`USE_SKELETON`, use_skeleton);
            }
            if (useMorphTargets) {
              shadowPass.setDefine(`USE_MORPHTARGETS`, useMorphTargets);
            }
            if (useMorphNormals) {
              shadowPass.setDefine(`USE_MORPHNORMALS`, useMorphNormals);
            }
            if (colorPass.cullMode == `none`) {
              shadowPass.shaderState.cullMode = `none`;
            } else if (colorPass.cullMode == `back`) {
              shadowPass.shaderState.cullMode = `front`;
            } else if (colorPass.cullMode == `front`) {
              shadowPass.shaderState.cullMode = `back`;
            }
            shadowPass.preCompile(renderNode.geometry);
            shader.addRenderPass(shadowPass);
          }
          let castPointShadowPassList = shader.getSubShaders(PassType.POINT_SHADOW);
          if (!castPointShadowPassList || castPointShadowPassList.length < i + 1) {
            let castPointShadowPass = new CastPointShadowMaterialPass();
            castPointShadowPass.setTexture(`baseMap`, colorPass.getTexture(`baseMap`));
            castPointShadowPass.setUniform(`alphaCutoff`, colorPass.getUniform(`alphaCutoff`));
            castPointShadowPass.setDefine("USE_ALPHACUT", 1);
            for (let j = 0; j < 1; j++) {
              if (useTangent) {
                castPointShadowPass.setDefine(`USE_TANGENT`, useTangent);
              }
              if (use_skeleton) {
                castPointShadowPass.setDefine(`USE_SKELETON`, use_skeleton);
              }
              if (useMorphTargets) {
                castPointShadowPass.setDefine(`USE_MORPHTARGETS`, useMorphTargets);
              }
              if (useMorphNormals) {
                castPointShadowPass.setDefine(`USE_MORPHNORMALS`, useMorphNormals);
              }
              castPointShadowPass.shaderState.cullMode = `front`;
              castPointShadowPass.preCompile(renderNode.geometry);
            }
            shader.addRenderPass(castPointShadowPass);
          }
        }
      }
      static createDepthPass(renderNode, shader) {
        let colorListPass = shader.getSubShaders(PassType.COLOR);
        let useTangent = renderNode.geometry.hasAttribute("TANGENT");
        let useMorphTargets = renderNode.geometry.hasAttribute(GLTFType.MORPH_POSITION_PREFIX + "0");
        let useMorphNormals = renderNode.geometry.hasAttribute(GLTFType.MORPH_NORMAL_PREFIX + "0");
        let use_skeleton = RendererMaskUtil.hasMask(renderNode.rendererMask, RendererMask.SkinnedMesh);
        for (let i = 0; i < colorListPass.length; i++) {
          const colorPass = colorListPass[i];
          let depthPassList = shader.getSubShaders(PassType.DEPTH);
          if (!depthPassList && colorPass.shaderState.useZ) {
            if (!depthPassList || depthPassList.length < i) {
              let depthPass = new DepthMaterialPass();
              depthPass.setTexture(`baseMap`, colorPass.getTexture(`baseMap`));
              if (!useTangent) {
                depthPass.setDefine(`USE_TANGENT`, useTangent);
              }
              if (use_skeleton) {
                depthPass.setDefine(`USE_SKELETON`, use_skeleton);
              }
              if (useMorphTargets) {
                depthPass.setDefine(`USE_MORPHTARGETS`, useMorphTargets);
              }
              if (useMorphNormals) {
                depthPass.setDefine(`USE_MORPHNORMALS`, useMorphNormals);
              }
              depthPass.cullMode = colorPass.cullMode;
              depthPass.frontFace = colorPass.frontFace;
              depthPass.preCompile(renderNode.geometry);
              shader.addRenderPass(depthPass);
            }
          }
        }
      }
    }

    class OctreeEntity {
      renderer;
      owner;
      uuid;
      constructor(renderer) {
        this.renderer = renderer;
        this.uuid = renderer.object3D.instanceID;
      }
      leaveNode() {
        if (this.owner) {
          this.owner.entities.delete(this.uuid);
          this.owner = null;
        }
      }
      enterNode(node) {
        this.owner && this.leaveNode();
        this.owner = node;
        node.entities.set(this.uuid, this);
      }
      update(root) {
        let stayWithOwner = this.owner?.tryInsertEntity(this);
        if (!stayWithOwner) {
          this.leaveNode();
          root.tryInsertEntity(this);
        }
        return this.owner;
      }
    }

    var __defProp$l = Object.defineProperty;
    var __getOwnPropDesc$l = Object.getOwnPropertyDescriptor;
    var __decorateClass$l = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$l(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$l(target, key, result);
      return result;
    };
    class RenderNode extends ComponentBase {
      instanceCount = 0;
      lodLevel = 0;
      alwaysRender = false;
      instanceID;
      drawType = 0;
      _geometry;
      _materials = [];
      _castShadow = true;
      _castReflection = false;
      _castGI = false;
      _rendererMask = RendererMask.Default;
      _inRenderer = false;
      _readyPipeline = false;
      _combineShaderRefection;
      _ignoreEnvMap;
      _ignorePrefilterMap;
      __renderOrder = 0;
      //cameraDepth + _renderOrder
      _renderOrder = 0;
      isRenderOrderChange;
      needSortOnCameraZ;
      _octreeBinder;
      preInit = false;
      /**
       *
       * The layer membership of the object.
       *  The object is only visible when it has at least one common layer with the camera in use.
       * When using a ray projector, this attribute can also be used to filter out unwanted objects in ray intersection testing.
       */
      _renderLayer = RenderLayer.None;
      _computes;
      init(param) {
        this.renderOrder = 0;
        this.rendererMask = RendererMask.Default;
        this.instanceID = GetCountInstanceID().toString();
        this._computes = [];
      }
      attachSceneOctree(octree) {
        this._octreeBinder = { octree, entity: new OctreeEntity(this) };
        this.transform.eventDispatcher.addEventListener(Transform.LOCAL_ONCHANGE, this.updateOctreeEntity, this);
      }
      detachSceneOctree() {
        if (this._octreeBinder) {
          this._octreeBinder.entity?.leaveNode();
          this.transform.eventDispatcher.removeEventListener(Transform.LOCAL_ONCHANGE, this.updateOctreeEntity, this);
          this._octreeBinder = null;
        }
      }
      updateOctreeEntity(e) {
        this._octreeBinder?.entity?.update(this._octreeBinder.octree);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.geometry = from._geometry;
        this.materials = from._materials.slice();
        this.drawType = from.drawType;
        this.alwaysRender = from.alwaysRender;
        this.needSortOnCameraZ = from.needSortOnCameraZ;
        this.isRenderOrderChange = from.isRenderOrderChange;
        this.castShadow = from.castShadow;
        this.castGI = from.castGI;
        this.rendererMask = from.rendererMask;
        return this;
      }
      get renderLayer() {
        return this._renderLayer;
      }
      set renderLayer(value) {
        this._renderLayer = value;
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(value) {
        if (this._geometry != value) {
          if (this._geometry) {
            Reference.getInstance().detached(this._geometry, this);
          }
          Reference.getInstance().attached(value, this);
        }
        this._geometry = value;
      }
      addMask(mask) {
        this._rendererMask = RendererMaskUtil.addMask(this.rendererMask, mask);
      }
      removeMask(mask) {
        this._rendererMask = RendererMaskUtil.removeMask(this.rendererMask, mask);
      }
      hasMask(mask) {
        return RendererMaskUtil.hasMask(this.rendererMask, mask);
      }
      get rendererMask() {
        return this._rendererMask;
      }
      set rendererMask(value) {
        this._rendererMask = value;
      }
      get renderOrder() {
        return this._renderOrder;
      }
      set renderOrder(value) {
        if (value != this._renderOrder) {
          this.isRenderOrderChange = true;
          this.__renderOrder = value;
        }
        this._renderOrder = value;
      }
      get materials() {
        return this._materials;
      }
      set materials(value) {
        this._readyPipeline = false;
        for (let i = 0; i < this._materials.length; i++) {
          let mat = this._materials[i];
          Reference.getInstance().detached(mat, this);
          if (mat.shader && mat.shader.computes)
            this.removeComputes(mat.shader.computes);
        }
        for (let i = 0; i < value.length; i++) {
          let mat = value[i];
          Reference.getInstance().attached(mat, this);
          if (mat.shader && mat.shader.computes)
            this.addComputes(mat.shader.computes);
        }
        this._materials = value;
        let sort = 0;
        for (let i = 0; i < value.length; i++) {
          const element = value[i];
          const passArray = element.getPass(PassType.COLOR);
          const pass = passArray[0];
          if (pass.shaderState.transparent) {
            sort = sort > pass.renderOrder ? sort : pass.renderOrder;
          }
        }
        this.renderOrder = sort;
        if (!this._readyPipeline) {
          this.initPipeline();
        }
      }
      addComputes(computes) {
        this._computes.push(...computes);
      }
      removeComputes(computes) {
        for (const com of computes) {
          let index = this._computes.indexOf(com);
          if (index != -1) {
            this._computes.splice(index, 1);
          }
        }
      }
      addRendererMask(tag) {
        this._rendererMask = RendererMaskUtil.addMask(this._rendererMask, tag);
      }
      removeRendererMask(tag) {
        this._rendererMask = RendererMaskUtil.removeMask(this._rendererMask, tag);
      }
      onEnable() {
        if (!this._readyPipeline) {
          this.initPipeline();
        }
        EntityCollect.instance.addRenderNode(this.transform.scene3D, this);
        this.updateOctreeEntity();
      }
      onDisable() {
        this._enable = false;
        EntityCollect.instance.removeRenderNode(this.transform.scene3D, this);
        super.onDisable?.();
      }
      selfCloneMaterials(key) {
        let newMaterials = [];
        for (let i = 0, c = this.materials.length; i < c; i++) {
          const material = this.materials[i].clone();
          newMaterials.push(material);
        }
        this.materials = newMaterials;
        this._readyPipeline = false;
        this.initPipeline();
        return this;
      }
      initPipeline() {
        if (this._geometry && this._materials.length > 0) {
          for (let j = 0; j < this._materials.length; j++) {
            const material = this._materials[j];
            let passList = material.getPass(PassType.COLOR);
            for (let i = 0; i < passList.length; i++) {
              const pass = passList[i];
              if (!pass.shaderReflection) {
                pass.preCompile(this._geometry);
              }
              this._geometry.generate(pass.shaderReflection);
            }
            this.object3D.bound = this._geometry.bounds.clone();
          }
          this._readyPipeline = true;
          let sort = 0;
          for (let i = 0; i < this.materials.length; i++) {
            const element = this.materials[i];
            const passArray = element.getPass(PassType.COLOR);
            const pass = passArray[0];
            if (pass.renderOrder >= 3e3) {
              sort = sort > pass.renderOrder ? sort : pass.renderOrder;
            } else {
              sort = Math.max(sort - 3e3, 0);
            }
            this.castNeedPass();
          }
          this.renderOrder = sort;
          if (this.enable && this.transform && this.transform.scene3D) {
            EntityCollect.instance.addRenderNode(this.transform.scene3D, this);
          }
        }
      }
      castNeedPass() {
        if (this.castGI) {
          for (let i = 0; i < this.materials.length; i++) {
            const mat = this.materials[i];
            PassGenerate.createGIPass(this, mat.shader);
          }
        }
        for (let i = 0; i < this.materials.length; i++) {
          const mat = this.materials[i];
          if (mat.castShadow) {
            PassGenerate.createShadowPass(this, mat.shader);
          }
        }
        if (this.castReflection) {
          for (let i = 0; i < this.materials.length; i++) {
            const mat = this.materials[i];
            if (mat.castShadow) {
              PassGenerate.createShadowPass(this, mat.shader);
            }
          }
        }
        let ignoreDepthPass = RendererMaskUtil.hasMask(this.rendererMask, RendererMask.IgnoreDepthPass);
        if (!ignoreDepthPass && Engine3D.setting.render.zPrePass) {
          for (let i = 0; i < this.materials.length; i++) {
            const mat = this.materials[i];
            PassGenerate.createDepthPass(this, mat.shader);
          }
        } else {
          for (let i = 0; i < this.materials.length; i++) {
            const mat = this.materials[i];
            mat.shader.removeShaderByIndex(PassType.DEPTH, 0);
          }
        }
      }
      get castShadow() {
        return this._castShadow;
      }
      set castShadow(value) {
        this._castShadow = value;
      }
      get castGI() {
        return this._castGI;
      }
      set castGI(value) {
        this._castGI = value;
      }
      get castReflection() {
        return this._castReflection;
      }
      set castReflection(value) {
        this._castReflection = value;
      }
      renderPass(view, passType, renderContext) {
        let renderNode = this;
        let worldMatrix = renderNode.transform._worldMatrix;
        for (let i = 0; i < renderNode.materials.length; i++) {
          const material = renderNode.materials[i];
          if (!material || !material.enable)
            continue;
          let passes = material.getPass(passType);
          if (!passes || passes.length == 0)
            continue;
          GPUContext.bindGeometryBuffer(renderContext.encoder, renderNode._geometry);
          for (let j = 0; j < passes.length; j++) {
            if (!passes || passes.length == 0)
              continue;
            let matPass = passes[j];
            const renderShader = matPass;
            if (renderShader.pipeline) {
              if (renderShader.shaderState.splitTexture) {
                renderContext.endRenderPass();
                RTResourceMap.WriteSplitColorTexture(renderNode.instanceID);
                renderContext.beginOpaqueRenderPass();
                GPUContext.bindCamera(renderContext.encoder, view.camera);
                GPUContext.bindGeometryBuffer(renderContext.encoder, renderNode._geometry);
              }
              GPUContext.bindPipeline(renderContext.encoder, renderShader);
              let subGeometry = renderNode._geometry.subGeometries[i];
              let lodInfos = subGeometry.lodLevels;
              let lodInfo = lodInfos[renderNode.lodLevel];
              if (renderNode.instanceCount > 0) {
                GPUContext.drawIndexed(renderContext.encoder, lodInfo.indexCount, renderNode.instanceCount, lodInfo.indexStart, 0, 0);
              } else {
                GPUContext.drawIndexed(renderContext.encoder, lodInfo.indexCount, 1, lodInfo.indexStart, 0, worldMatrix.index);
              }
            }
          }
        }
      }
      /**
       * render pass at passType
       * @param pass
       * @param encoder
       * @returns
       */
      renderPass2(view, passType, rendererPassState, clusterLightingBuffer, encoder, useBundle = false) {
        if (!this.enable)
          return;
        let node = this;
        let worldMatrix = node.object3D.transform._worldMatrix;
        for (let i = 0; i < this.materials.length; i++) {
          const material = this.materials[i];
          if (!material.castShadow && passType == PassType.SHADOW)
            continue;
          let passes = material.getPass(passType);
          if (!passes || passes.length == 0)
            return;
          if (this.drawType == 2) {
            for (let matPass of passes) {
              if (matPass.pipeline) {
                GPUContext.bindPipeline(encoder, matPass);
                GPUContext.draw(encoder, 6, 1, 0, worldMatrix.index);
              }
            }
          } else {
            GPUContext.bindGeometryBuffer(encoder, node._geometry);
            for (let matPass of passes) {
              if (matPass.pipeline) {
                GPUContext.bindPipeline(encoder, matPass);
                let subGeometries = node._geometry.subGeometries;
                const subGeometry = subGeometries[i];
                let lodInfos = subGeometry.lodLevels;
                let lodInfo = lodInfos[node.lodLevel];
                GPUContext.drawIndexed(encoder, lodInfo.indexCount, 1, lodInfo.indexStart, 0, worldMatrix.index);
              }
            }
          }
        }
      }
      recordRenderPass2(view, passType, rendererPassState, clusterLightingBuffer, encoder, useBundle = false) {
        if (!this.enable)
          return;
        let node = this;
        for (let i = 0; i < this.materials.length; i++) {
          let material = this.materials[i];
          let passes = material.getPass(passType);
          if (!passes || passes.length == 0)
            return;
          let worldMatrix = node.object3D.transform._worldMatrix;
          for (let j = 0; j < passes.length; j++) {
            const renderShader = passes[j];
            GPUContext.bindPipeline(encoder, renderShader);
            let subGeometries = node._geometry.subGeometries;
            const subGeometry = subGeometries[i];
            let lodInfos = subGeometry.lodLevels;
            let lodInfo = lodInfos[node.lodLevel];
            GPUContext.drawIndexed(encoder, lodInfo.indexCount, 1, lodInfo.indexStart, 0, worldMatrix.index);
          }
        }
      }
      noticeShaderChange() {
        if (this.enable) {
          this.onEnable();
          this.preInit = false;
        }
      }
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        this.preInit = true;
        let node = this;
        let envMap = view.scene.envMap;
        for (let j = 0; j < node.materials.length; j++) {
          let material = node.materials[j];
          let passes = material.getPass(passType);
          if (passes) {
            for (let i = 0; i < passes.length; i++) {
              const pass = passes[i];
              const renderShader = pass;
              if (renderShader.shaderState.splitTexture) {
                let splitTexture = RTResourceMap.CreateSplitTexture(node.instanceID);
                renderShader.setTexture("splitTexture_Map", splitTexture);
              }
              if (!node._ignoreEnvMap && renderShader.envMap != envMap) {
                renderShader.setTexture(`envMap`, envMap);
              }
              renderShader.setTexture(`prefilterMap`, envMap);
              if (renderShader.pipeline) {
                renderShader.apply(node._geometry, renderPassState, () => node.noticeShaderChange());
                continue;
              }
              let bdrflutTex = Engine3D.res.getTexture(`BRDFLUT`);
              renderShader.setTexture(`brdflutMap`, bdrflutTex);
              let shadowRenderer = Engine3D.getRenderJob(view).shadowMapPassRenderer;
              if (shadowRenderer && shadowRenderer.depth2DArrayTexture) {
                renderShader.setTexture(`shadowMap`, Engine3D.getRenderJob(view).shadowMapPassRenderer.depth2DArrayTexture);
              }
              let pointShadowRenderer = Engine3D.getRenderJob(view).pointLightShadowRenderer;
              if (pointShadowRenderer && pointShadowRenderer.cubeArrayTexture) {
                renderShader.setTexture(`pointShadowMap`, pointShadowRenderer.cubeArrayTexture);
              }
              let iesTexture = IESProfiles.iesTexture;
              if (iesTexture) {
                renderShader.setTexture(`iesTextureArrayMap`, iesTexture);
              }
              if (renderPassState.irradianceBuffer && renderPassState.irradianceBuffer.length > 0) {
                renderShader.setTexture(`irradianceMap`, renderPassState.irradianceBuffer[0]);
                renderShader.setTexture(`irradianceDepthMap`, renderPassState.irradianceBuffer[1]);
              }
              let lightUniformEntries = GlobalBindGroup.getLightEntries(view.scene);
              if (lightUniformEntries) {
                renderShader.setStorageBuffer(`lightBuffer`, lightUniformEntries.storageGPUBuffer);
                if (lightUniformEntries.irradianceVolume) {
                  renderShader.setUniformBuffer(`irradianceData`, lightUniformEntries.irradianceVolume.irradianceVolumeBuffer);
                }
              }
              if (clusterLightingBuffer) {
                renderShader.setStorageBuffer(`clustersUniform`, clusterLightingBuffer.clustersUniformBuffer);
                renderShader.setStorageBuffer(`lightAssignBuffer`, clusterLightingBuffer.lightAssignBuffer);
                renderShader.setStorageBuffer(`assignTable`, clusterLightingBuffer.assignTableBuffer);
                renderShader.setStorageBuffer(`clusterBuffer`, clusterLightingBuffer.clusterBuffer);
              }
              renderShader.apply(node._geometry, renderPassState);
            }
          }
        }
      }
      beforeDestroy(force) {
        Reference.getInstance().detached(this._geometry, this);
        if (!Reference.getInstance().hasReference(this._geometry)) {
          this._geometry.destroy(force);
        }
        for (let i = 0; i < this._materials.length; i++) {
          const mat = this._materials[i];
          Reference.getInstance().detached(mat, this);
          if (!Reference.getInstance().hasReference(mat)) {
            mat.destroy(force);
          }
        }
        super.beforeDestroy(force);
      }
      destroy(force) {
        super.destroy(force);
        this._geometry = null;
        this._materials = null;
        this._combineShaderRefection = null;
      }
    }
    __decorateClass$l([
      EditorInspector
    ], RenderNode.prototype, "materials", 1);
    __decorateClass$l([
      EditorInspector
    ], RenderNode.prototype, "castShadow", 1);
    __decorateClass$l([
      EditorInspector
    ], RenderNode.prototype, "castShadow", 1);
    __decorateClass$l([
      EditorInspector
    ], RenderNode.prototype, "castGI", 1);
    __decorateClass$l([
      EditorInspector
    ], RenderNode.prototype, "castGI", 1);

    class Graphics3DShape {
      uuid;
      type;
      color;
      count = 0;
      pointData;
      colorData;
      dirtyData = false;
      memoryDataIndex = -1;
      transformIndex;
      constructor(transformIndex) {
        this.transformIndex = transformIndex;
      }
      buildAxis(origin = new Vector3(0, 0, 0), size = 10) {
        this.buildLines([origin, new Vector3(origin.x + size, origin.y, origin.z)], Color.hexRGBColor(Color.RED));
        this.buildLines([origin, new Vector3(origin.x, origin.y + size, origin.z)], Color.hexRGBColor(Color.GREEN));
        this.buildLines([origin, new Vector3(origin.x, origin.y, origin.z + size)], Color.hexRGBColor(Color.BLUE));
      }
      buildLines(points, colors = Color.COLOR_WHITE) {
        if (points.length < 2) {
          return;
        }
        if (points.length == 2) {
          this.fillShapeData(points, colors);
          return;
        }
        var linePoints = new Array(points.length + points.length - 2);
        for (let i = 1, index = 0; i < points.length; ++i) {
          linePoints[index++] = points[i - 1];
          linePoints[index++] = points[i];
        }
        this.fillShapeData(linePoints, colors);
      }
      buildArcLine(center, radius, startAngle, endAngle, segments = 16, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        const totalAngle = (endAngle - startAngle) * DEGREES_TO_RADIANS;
        startAngle *= DEGREES_TO_RADIANS;
        var points = [];
        for (let i = 0; i <= segments; ++i) {
          if (i > 1) {
            points.push(points[points.length - 1]);
          }
          var verAngle = totalAngle * (i / segments) + startAngle;
          var x = radius * Math.cos(verAngle);
          var y = radius * Math.sin(verAngle);
          switch (up) {
            case Vector3.X_AXIS:
              points.push(center.add(new Vector3(0, x, y)));
              break;
            case Vector3.Y_AXIS:
              points.push(center.add(new Vector3(x, 0, y)));
              break;
            case Vector3.Z_AXIS:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
            default:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
          }
        }
        this.fillShapeData(points, color);
      }
      buildCircle(center, radius, segments = 32, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        var points = [];
        for (let i = 0; i <= segments; ++i) {
          var verAngle = 2 * Math.PI * i / segments;
          var x = radius * Math.cos(verAngle);
          var y = radius * Math.sin(verAngle);
          switch (up) {
            case Vector3.X_AXIS:
              points.push(center.add(new Vector3(0, x, y)));
              break;
            case Vector3.Y_AXIS:
              points.push(center.add(new Vector3(x, 0, y)));
              break;
            case Vector3.Z_AXIS:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
            default:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
          }
          if (i > 0)
            points.push(points[points.length - 1]);
        }
        points.push(points[0]);
        this.fillShapeData(points, color);
      }
      fillShapeData(points, colors, forceUpdate = false) {
        if (!this.pointData) {
          this.pointData = new Float32Array(4 * points.length);
          this.colorData = new Float32Array(4 * points.length);
        } else if (this.count + 4 * points.length >= this.pointData.length) {
          let tmp = new Float32Array(this.pointData.length + 4 * points.length);
          tmp.set(this.pointData);
          this.pointData = tmp;
          tmp = new Float32Array(this.colorData.length + 4 * points.length);
          tmp.set(this.colorData);
          this.colorData = tmp;
        }
        if (forceUpdate || this.dirtyData == false) {
          const pointData = this.pointData;
          let index = this.count;
          for (let i = 0; i < points.length; ++i) {
            const point = points[i];
            pointData[this.count++] = point.x;
            pointData[this.count++] = point.y;
            pointData[this.count++] = point.z;
            pointData[this.count++] = this.transformIndex;
          }
          const colorData = this.colorData;
          for (let i = 0; i < points.length; ++i) {
            if (colors instanceof Color) {
              colorData[index++] = colors.r;
              colorData[index++] = colors.g;
              colorData[index++] = colors.b;
              colorData[index++] = colors.a;
            } else {
              const color = colors[i];
              colorData[index++] = color.r;
              colorData[index++] = color.g;
              colorData[index++] = color.b;
              colorData[index++] = color.a;
            }
          }
        }
        this.dirtyData = true;
      }
      reset() {
        this.count = 0;
      }
    }

    class Graphic3DBatchRenderer extends RenderNode {
      shapes;
      mDirtyData = false;
      mBatchSize;
      mMinIndexCount;
      mGPUPrimitiveTopology;
      constructor(minIndexCount, topology) {
        super();
        this.alwaysRender = true;
        this.mMinIndexCount = minIndexCount;
        this.mBatchSize = Math.trunc(65536 / this.mMinIndexCount);
        this.mGPUPrimitiveTopology = topology;
        this.shapes = /* @__PURE__ */ new Map();
      }
      init() {
        super.init();
        this.castGI = false;
        this.castShadow = false;
        this.geometry = new GeometryBase();
        let indexData = new Uint16Array((Math.trunc(this.mMinIndexCount * this.mBatchSize / 4) + 1) * 4);
        for (let i = 0; i < indexData.length; i++) {
          indexData[i] = i;
        }
        this.geometry.setIndices(indexData);
        this.geometry.setAttribute(VertexAttributeName.position, new Float32Array(4 * indexData.length));
        this.geometry.setAttribute(VertexAttributeName.color, new Float32Array(4 * indexData.length));
        this.geometry.addSubGeometry({
          indexStart: 0,
          indexCount: 0,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
        this.materials = [new Graphic3DFixedRenderMaterial(this.mGPUPrimitiveTopology)];
      }
      fillShapeData(uuid, type, color, points) {
        this.mDirtyData = true;
        var data;
        if (this.shapes.has(uuid)) {
          data = this.shapes.get(uuid);
          if (data.pointData.length < 4 * points.length) {
            data.pointData = new Float32Array(4 * points.length);
            data.colorData = new Float32Array(4 * points.length);
          }
        } else {
          data = new Graphics3DShape(this.transform._worldMatrix.index);
          data.type = type;
          data.color = color;
          data.pointData = new Float32Array(4 * points.length);
          data.colorData = new Float32Array(4 * points.length);
        }
        const pointData = data.pointData;
        const colorData = data.colorData;
        const transformIndex = this.transform._worldMatrix.index;
        for (let i = 0, index = 0; i < points.length; ++i) {
          const point = points[i];
          pointData[index] = point.x;
          colorData[index++] = color.r;
          pointData[index] = point.y;
          colorData[index++] = color.g;
          pointData[index] = point.z;
          colorData[index++] = color.b;
          pointData[index] = transformIndex;
          colorData[index++] = color.a;
        }
        this.shapes.set(uuid, data);
      }
      removeShape(uuid) {
        if (this.shapes.has(uuid)) {
          this.mDirtyData = true;
          this.shapes.delete(uuid);
        }
      }
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        if (this.mDirtyData) {
          let offset = 0;
          let posAttrData = this.geometry.getAttribute(VertexAttributeName.position);
          let colAttrData = this.geometry.getAttribute(VertexAttributeName.color);
          this.shapes.forEach((shape, uuid) => {
            posAttrData.data.set(shape.pointData, offset);
            colAttrData.data.set(shape.colorData, offset);
            offset += shape.pointData.length;
          });
          this.geometry.vertexBuffer.upload(VertexAttributeName.position, posAttrData);
          this.geometry.vertexBuffer.upload(VertexAttributeName.color, colAttrData);
          let count = offset / 4;
          let indexCount = count;
          this.geometry.subGeometries[0].lodLevels[0].indexCount = indexCount;
          this.mDirtyData = false;
        }
        super.nodeUpdate(view, passType, renderPassState, clusterLightingBuffer);
      }
      allocGraphics3DShape(uuid, transformIndex) {
        let shape;
        if (this.shapes.has(uuid)) {
          shape = this.shapes.get(uuid);
          shape.reset();
        } else {
          shape = new Graphics3DShape(transformIndex);
          shape.uuid = uuid;
          shape.type = "line";
          shape.color = Color.COLOR_WHITE;
          this.shapes.set(shape.uuid, shape);
        }
        this.mDirtyData = true;
        return shape;
      }
    }

    class CollectInfo {
      opaqueList = [];
      transparentList = [];
      sky;
      clean() {
        this.opaqueList.length = 0;
        this.transparentList.length = 0;
      }
    }

    class EntityBatchCollect {
      renderGroup;
      constructor() {
        this.renderGroup = /* @__PURE__ */ new Map();
      }
      collect_add(node) {
        let g_key = "";
        let s_key = "";
        g_key += node.geometry.instanceID;
        for (let i = 0; i < node.materials.length; i++) {
          const mat = node.materials[i];
          s_key += mat.shader.getDefaultColorShader().shaderVariant;
        }
        let key = g_key + s_key;
        if (!this.renderGroup.has(key)) {
          this.renderGroup.set(key, {
            bundleMap: /* @__PURE__ */ new Map(),
            key,
            renderNodes: []
          });
        }
        if (this.renderGroup.get(key).renderNodes.indexOf(node) == -1)
          this.renderGroup.get(key).renderNodes.push(node);
      }
    }

    class RenderShaderCollect {
      renderShaderUpdateList = /* @__PURE__ */ new Map();
      renderNodeList = /* @__PURE__ */ new Map();
      collect_add(node) {
        let view = node.transform.view3D;
        if (view && node.materials) {
          node.materials.forEach((mat) => {
            let rDic = this.renderShaderUpdateList.get(view);
            if (!rDic) {
              rDic = /* @__PURE__ */ new Map();
              this.renderShaderUpdateList.set(view, rDic);
            }
            let renderGlobalMap = this.renderNodeList.get(view);
            if (!renderGlobalMap) {
              renderGlobalMap = /* @__PURE__ */ new Map();
              this.renderNodeList.set(view, renderGlobalMap);
            }
            renderGlobalMap.set(node.instanceID, node);
            let colorPassList = mat.getAllPass();
            for (let i = 0; i < colorPassList.length; i++) {
              const pass = colorPassList[i];
              let key = `${node.geometry.instanceID + pass.instanceID}`;
              let nodeMap = rDic.get(key);
              if (!nodeMap) {
                nodeMap = /* @__PURE__ */ new Map();
                rDic.set(key, nodeMap);
              }
              nodeMap.set(node.instanceID, node);
            }
          });
        }
      }
      collect_remove(node) {
        let view = node.transform.view3D;
        if (view && node.materials) {
          let rDic = this.renderShaderUpdateList.get(view);
          if (rDic) {
            node.materials.forEach((mat) => {
              let colorPassList = mat.getAllPass();
              for (let i = 0; i < colorPassList.length; i++) {
                const pass = colorPassList[i];
                let key = `${node.geometry.instanceID + pass.instanceID}`;
                rDic.delete(key);
              }
            });
          }
        }
      }
    }

    class EntityCollect {
      static _instance;
      // private static  _sceneRenderList: Map<Scene3D, RenderNode[]>;
      _sceneLights;
      _sceneGIProbes;
      _op_RenderNodes;
      _tr_RenderNodes;
      _octreeRenderNodes;
      _graphics;
      _op_renderGroup;
      _tr_renderGroup;
      _renderShaderCollect;
      state = {
        giLightingChange: true
      };
      sky;
      _collectInfo;
      rendererOctree;
      static get instance() {
        if (!this._instance) {
          this._instance = new EntityCollect();
        }
        return this._instance;
      }
      constructor() {
        this._sceneLights = /* @__PURE__ */ new Map();
        this._sceneGIProbes = /* @__PURE__ */ new Map();
        this._op_RenderNodes = /* @__PURE__ */ new Map();
        this._tr_RenderNodes = /* @__PURE__ */ new Map();
        this._graphics = [];
        this._op_renderGroup = /* @__PURE__ */ new Map();
        this._tr_renderGroup = /* @__PURE__ */ new Map();
        this._collectInfo = new CollectInfo();
        this._renderShaderCollect = new RenderShaderCollect();
        this._octreeRenderNodes = /* @__PURE__ */ new Map();
      }
      getPashList(root, renderNode) {
        if (renderNode.renderOrder < 3e3) {
          return this._op_RenderNodes.get(root);
        } else if (renderNode.renderOrder >= 3e3) {
          return this._tr_RenderNodes.get(root);
        }
      }
      sortRenderNode(list, renderNode) {
        for (let i = list.length - 1; i > 0; i--) {
          const element = list[i];
          if (element.renderOrder < renderNode.renderOrder) {
            list.push(renderNode);
            return;
          }
        }
        list.push(renderNode);
      }
      addRenderNode(root, renderNode) {
        if (!root)
          return;
        let isTransparent = renderNode.renderOrder >= 3e3;
        if (renderNode.hasMask(RendererMask.Sky)) {
          this.sky = renderNode;
        } else if (renderNode instanceof Graphic3DBatchRenderer) {
          if (this._graphics.indexOf(renderNode) == -1) {
            this._graphics.push(renderNode);
          }
        } else if (!RenderLayerUtil.hasMask(renderNode.renderLayer, RenderLayer.None)) {
          this.removeRenderNode(root, renderNode);
          let group = isTransparent ? this._tr_renderGroup : this._op_renderGroup;
          if (!group.has(root)) {
            group.set(root, new EntityBatchCollect());
          }
          group.get(root).collect_add(renderNode);
        } else {
          this.removeRenderNode(root, renderNode);
          let map = isTransparent ? this._tr_RenderNodes : this._op_RenderNodes;
          if (!map.has(root)) {
            map.set(root, []);
          }
          map.get(root).push(renderNode);
          if (Engine3D.setting.occlusionQuery.octree) {
            renderNode.attachSceneOctree(this.getOctree(root));
          }
          let list = this.getPashList(root, renderNode);
          let index = list.indexOf(renderNode);
          if (index == -1) {
            this.sortRenderNode(list, renderNode);
          }
        }
        renderNode.object3D.renderNode = renderNode;
        this._renderShaderCollect.collect_add(renderNode);
      }
      getOctree(root) {
        let octree;
        let setting = Engine3D.setting.occlusionQuery.octree;
        if (setting) {
          octree = this._octreeRenderNodes.get(root);
          if (!octree) {
            let center = new Vector3(setting.x, setting.y, setting.z);
            let size = new Vector3(setting.width, setting.height, setting.depth);
            let bound = new BoundingBox(center, size);
            octree = new Octree(bound);
            this._octreeRenderNodes.set(root, octree);
          }
        }
        return octree;
      }
      removeRenderNode(root, renderNode) {
        renderNode.detachSceneOctree();
        if (renderNode.hasMask(RendererMask.Sky)) {
          this.sky = null;
        } else if (!RenderLayerUtil.hasMask(renderNode.renderLayer, RenderLayer.None)) ; else {
          let list = this.getPashList(root, renderNode);
          if (list) {
            let index = list.indexOf(renderNode);
            if (index != -1) {
              list.splice(index, 1);
            }
          }
        }
        this._renderShaderCollect.collect_remove(renderNode);
      }
      addLight(root, light) {
        if (!this._sceneLights.has(root)) {
          this._sceneLights.set(root, [light]);
        } else {
          let lights = this._sceneLights.get(root);
          if (lights.length >= Engine3D.setting.light.maxLight) {
            console.warn("Alreay meet maxmium light number:", Engine3D.setting.light.maxLight);
            return;
          }
          let hasLight = lights.indexOf(light) != -1;
          if (!hasLight) {
            lights.push(light);
          }
        }
      }
      removeLight(root, light) {
        if (this._sceneLights.has(root)) {
          let list = this._sceneLights.get(root);
          let index = list.indexOf(light);
          if (index != -1) {
            list.splice(index, 1);
          }
        }
      }
      getLights(root) {
        let list = this._sceneLights.get(root);
        return list ? list : [];
      }
      addGIProbe(root, probe) {
        if (!this._sceneGIProbes.has(root)) {
          this._sceneGIProbes.set(root, [probe]);
        } else {
          this._sceneGIProbes.get(root).push(probe);
        }
      }
      removeGIProbe(root, probe) {
        if (this._sceneGIProbes.has(root)) {
          let list = this._sceneGIProbes.get(root);
          let index = list.indexOf(probe);
          if (index != -1) {
            list.splice(index, 1);
          }
        }
      }
      getProbes(root) {
        let list = this._sceneGIProbes.get(root);
        return list ? list : [];
      }
      // sort renderers by renderOrder and camera depth
      autoSortRenderNodes(scene) {
        let renderList = this._tr_RenderNodes.get(scene);
        if (!renderList)
          return;
        let needSort = false;
        for (const renderNode of renderList) {
          if (renderNode.isRenderOrderChange || renderNode.needSortOnCameraZ) {
            needSort = true;
            break;
          }
        }
        if (needSort) {
          for (const renderNode of renderList) {
            let __renderOrder = renderNode.renderOrder;
            if (renderNode.needSortOnCameraZ) {
              let cameraDepth = zSorterUtil.worldToCameraDepth(renderNode.object3D);
              cameraDepth = 1 - Math.max(0, Math.min(1, cameraDepth));
              __renderOrder += cameraDepth;
            }
            renderNode["__renderOrder"] = __renderOrder;
            renderNode.isRenderOrderChange = false;
          }
          renderList.sort((a, b) => {
            return a["__renderOrder"] > b["__renderOrder"] ? 1 : -1;
          });
        }
        return this;
      }
      getRenderNodes(scene, camera) {
        this.autoSortRenderNodes(scene);
        this._collectInfo.clean();
        this._collectInfo.sky = this.sky;
        if (Engine3D.setting.occlusionQuery.octree) {
          this.rendererOctree = this.getOctree(scene);
          this.rendererOctree.getRenderNode(camera.frustum, this._collectInfo);
        } else {
          let list2 = this._op_RenderNodes.get(scene);
          if (list2) {
            this._collectInfo.opaqueList = list2.concat();
          }
          let list5 = this._tr_RenderNodes.get(scene);
          if (list5) {
            this._collectInfo.transparentList = list5.concat();
          }
        }
        return this._collectInfo;
      }
      getOpRenderGroup(scene) {
        return this._op_renderGroup.get(scene);
      }
      getTrRenderGroup(scene) {
        return this._tr_renderGroup.get(scene);
      }
      getGraphicList() {
        return this._graphics;
      }
      getRenderShaderCollect(view) {
        let viewList = this._renderShaderCollect.renderShaderUpdateList.get(view);
        return viewList;
      }
    }

    class DDGIIrradianceVolume {
      setting;
      probesBufferData;
      //offset xyz frame
      probesBuffer;
      isVolumeFrameChange = true;
      randomOrientation;
      startPosition = new Vector3();
      isVolumeChange = true;
      irradianceVolumeBuffer;
      //__make random direction
      directionDistance = 20;
      randomSeedCount = 3;
      useRandomIndex = 0;
      centerDirection = new Vector3(0, 0, this.directionDistance).normalize(1);
      arroundPositions = [];
      //__end
      updateOrientation() {
        this.useRandomIndex++;
        if (this.useRandomIndex >= this.arroundPositions.length)
          this.useRandomIndex = 0;
        Matrix4.fromToRotation(this.centerDirection, this.arroundPositions[this.useRandomIndex], this.randomOrientation);
        return this.randomOrientation;
      }
      init(setting) {
        this.setting = setting;
        this.randomOrientation = new Matrix4(false);
        this.randomOrientation.identity();
        this.irradianceVolumeBuffer = new UniformGPUBuffer(80);
        this.createFramesBuffer();
        this.arroundPositions.push(this.centerDirection.clone());
        for (let i = 0; i < this.randomSeedCount; i++) {
          let angle = Math.PI * 2 * i / this.randomSeedCount;
          let v = new Vector3(Math.sin(angle), Math.cos(angle), this.directionDistance).normalize(1);
          this.arroundPositions.push(v);
        }
      }
      setVolumeDataChange() {
        this.isVolumeChange = true;
      }
      updateProbes(probes) {
        let frameArray = this.probesBufferData;
        for (let probe of probes) {
          let offset = probe.index * 4;
          frameArray[offset + 3] = probe.drawCallFrame;
        }
      }
      createFramesBuffer() {
        if (!this.probesBufferData) {
          let size = this.setting.probeXCount * this.setting.probeYCount * this.setting.probeZCount;
          this.probesBufferData = new Float32Array(size * 4);
          this.probesBufferData.fill(-1);
          this.probesBuffer = new StorageGPUBuffer(size * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        }
      }
      uploadBuffer() {
        if (this.isVolumeChange) {
          this.fillIrradianceData();
          this.isVolumeChange = false;
          this.isVolumeFrameChange = true;
        }
        this.probesBuffer.setFloat32Array("uniformFramesBuffer", this.probesBufferData);
      }
      calcPosition(x, y, z, result) {
        let setting = this.setting;
        let space = this.setting.probeSpace;
        result = result || new Vector3();
        result.x = x * space - space * (setting.probeXCount - 1) * 0.5 + setting.offsetX;
        result.y = y * space - space * (setting.probeYCount - 1) * 0.5 + setting.offsetY;
        result.z = z * space - space * (setting.probeZCount - 1) * 0.5 + setting.offsetZ;
        return result;
      }
      debugX = 0;
      debugY = 0;
      debugZ = 0;
      fillIrradianceData() {
        let setting = this.setting;
        let start = this.calcPosition(0, 0, 0, this.startPosition);
        this.irradianceVolumeBuffer.setFloat("orientationIndex", this.randomOrientation.index);
        this.irradianceVolumeBuffer.setFloat("hysteresis", setting.hysteresis);
        this.irradianceVolumeBuffer.setFloat("OctRTSideSize", setting.octRTSideSize);
        this.irradianceVolumeBuffer.setFloat("OctRTMaxSize", setting.octRTMaxSize);
        this.irradianceVolumeBuffer.setFloat("startX", start.x);
        this.irradianceVolumeBuffer.setFloat("startY", start.y);
        this.irradianceVolumeBuffer.setFloat("startZ", start.z);
        this.irradianceVolumeBuffer.setFloat("ProbeSpace", setting.probeSpace);
        this.irradianceVolumeBuffer.setFloat("probeXCount", setting.probeXCount);
        this.irradianceVolumeBuffer.setFloat("probeYCount", setting.probeYCount);
        this.irradianceVolumeBuffer.setFloat("probeZCount", setting.probeZCount);
        this.irradianceVolumeBuffer.setFloat("maxDistance", setting.probeSpace * 1.732);
        this.irradianceVolumeBuffer.setFloat("depthSharpness", setting.depthSharpness);
        this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize", setting.probeSourceTextureSize);
        this.irradianceVolumeBuffer.setFloat("ProbeSize", setting.probeSize);
        this.irradianceVolumeBuffer.setFloat("bounceIntensity", setting.bounceIntensity);
        this.irradianceVolumeBuffer.setFloat("probeRoughness", setting.probeRoughness);
        this.irradianceVolumeBuffer.setFloat("normalBias", setting.normalBias);
        this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias", setting.irradianceChebyshevBias);
        this.irradianceVolumeBuffer.setFloat("rayNumber", setting.rayNumber);
        this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias", setting.irradianceDistanceBias);
        this.irradianceVolumeBuffer.setFloat("indirectIntensity", setting.indirectIntensity);
        this.irradianceVolumeBuffer.setFloat("ddgiGamma", setting.ddgiGamma);
        this.irradianceVolumeBuffer.setFloat("lerpHysteresis", setting.lerpHysteresis);
        this.irradianceVolumeBuffer.setFloat("debugX", this.debugX);
        this.irradianceVolumeBuffer.setFloat("debugY", this.debugY);
        this.irradianceVolumeBuffer.setFloat("debugZ", this.debugZ);
        this.irradianceVolumeBuffer.apply();
      }
    }

    class LightEntries {
      storageGPUBuffer;
      irradianceVolume;
      _lightList = [];
      constructor() {
        this.storageGPUBuffer = new StorageGPUBuffer(
          LightData.lightSize * Engine3D.setting.light.maxLight,
          GPUBufferUsage.COPY_SRC
        );
        this.irradianceVolume = new DDGIIrradianceVolume();
        this.irradianceVolume.init(Engine3D.setting.gi);
        for (let i = 0; i < Engine3D.setting.light.maxLight; i++) {
          let memory = this.storageGPUBuffer.memory.allocation_node(LightData.lightSize * 4);
          this._lightList.push(memory);
        }
        this.storageGPUBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
      }
      update(view) {
        this.storageGPUBuffer.clean();
        let lights = EntityCollect.instance.getLights(view.scene);
        for (let i = 0; i < lights.length; i++) {
          const light = lights[i].lightData;
          light.index = i;
          this.writeLightBytes(light, this._lightList[i]);
        }
        this.storageGPUBuffer.apply();
      }
      writeLightBytes(light, memory) {
        memory.offset = 0;
        memory.writeFloat(light.index);
        memory.writeInt32(light.lightType);
        memory.writeFloat(light.radius);
        memory.writeFloat(light.linear);
        memory.writeVector3(light.lightPosition);
        memory.writeFloat(light.lightMatrixIndex);
        memory.writeVector3(light.direction);
        memory.writeFloat(light.quadratic);
        memory.writeRGBColor(light.lightColor);
        memory.writeFloat(light.intensity);
        memory.writeFloat(light.innerAngle);
        memory.writeFloat(light.outerAngle);
        memory.writeFloat(light.range);
        memory.writeInt32(light.castShadowIndex);
        memory.writeVector3(light.lightTangent);
        memory.writeFloat(light.iesIndex);
      }
    }

    class ProbeEntries {
      gpuBuffer;
      probes;
      memoryDo;
      _probeInfoList;
      initDataUniform(probes) {
        this.memoryDo = new MemoryDO();
        this.probes = probes;
        this._probeInfoList = [];
        this.memoryDo.destroy();
        this.memoryDo.allocation(probes.length * 17 * 4);
        for (let i = 0; i < probes.length; i++) {
          var size = 17;
          let memoryInfo = this.memoryDo.allocation_node(size * 4);
          this._probeInfoList.push(memoryInfo);
          let probeWorldPos = probes[i].transform.worldPosition;
          memoryInfo.setArray(0, [probeWorldPos.x, probeWorldPos.y, probeWorldPos.z]);
        }
        this.gpuBuffer = webGPUContext.device.createBuffer({
          size: this.memoryDo.shareDataBuffer.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
          label: "ProbeBuffer",
          mappedAtCreation: false
        });
      }
      updateGPUBuffer() {
        const bufferData = this.memoryDo.shareDataBuffer;
        let totalBytes = this.memoryDo.shareDataBuffer.byteLength;
        let offsetBytes = 0;
        const space = 5e3 * 64;
        while (offsetBytes < totalBytes) {
          webGPUContext.device.queue.writeBuffer(this.gpuBuffer, offsetBytes, bufferData, offsetBytes, Math.floor(Math.min(space, totalBytes - offsetBytes)));
          offsetBytes += space;
        }
      }
    }

    class MatrixGPUBuffer extends GPUBufferBase {
      size;
      constructor(size, usage = 0, data) {
        super();
        this.bufferType = GPUBufferType.StorageGPUBuffer;
        this.size = size;
        this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | usage, size, data, "MatrixGPUBuffer");
      }
      writeBufferByHeap(mapAsyncArray, len) {
        let device = webGPUContext.device;
        if (mapAsyncArray.length > 0) {
          let tBuffer = null;
          while (this.mapAsyncReady.length) {
            tBuffer = this.mapAsyncReady.shift();
            if (tBuffer["usedSize"] == mapAsyncArray.byteLength)
              break;
            tBuffer.destroy();
            this.mapAsyncBuffersOutstanding--;
            tBuffer = null;
          }
          if (!tBuffer) {
            tBuffer = device.createBuffer({
              size: mapAsyncArray.byteLength,
              usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE,
              mappedAtCreation: true
            });
            tBuffer["usedSize"] = mapAsyncArray.byteLength;
            this.mapAsyncBuffersOutstanding++;
            if (this.mapAsyncBuffersOutstanding > 10) {
              console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`);
            }
          }
          let a = new Float32Array(mapAsyncArray.buffer, mapAsyncArray.byteOffset, len);
          let b = new Float32Array(tBuffer.getMappedRange(0, len * 4));
          b.set(a);
          tBuffer.unmap();
          const commandEncoder = device.createCommandEncoder();
          commandEncoder.copyBufferToBuffer(tBuffer, 0, this.buffer, 0, len * 4);
          device.queue.submit([commandEncoder.finish()]);
          tBuffer.mapAsync(GPUMapMode.WRITE).then(() => this.mapAsyncReady.push(tBuffer));
        }
      }
    }

    class MatrixBindGroup {
      uuid;
      index;
      usage;
      groupBufferSize;
      matrixBufferDst;
      constructor() {
        this.uuid = UUID();
        this.groupBufferSize = 0;
        this.usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        this.cacheWorldMatrix();
      }
      cacheWorldMatrix() {
        this.groupBufferSize = Matrix4.maxCount * Matrix4.blockBytes;
        this.matrixBufferDst = new MatrixGPUBuffer(this.groupBufferSize / 4);
        this.matrixBufferDst.visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
        this.matrixBufferDst.buffer.label = this.groupBufferSize.toString();
      }
      writeBuffer(len) {
        const matBytes = Matrix4.dynamicMatrixBytes;
        this.matrixBufferDst.mapAsyncWrite(matBytes, len);
      }
      // writeBuffer() {
      //     const matBytes = Matrix4.dynamicMatrixBytes;
      //     let totalBytes = matBytes.byteLength;
      //     let offsetBytes = 0;
      //     const space = 5000 * 64;
      //     while (offsetBytes < totalBytes) {
      //         let len = Math.min(space, totalBytes - offsetBytes);
      //         webGPUContext.device.queue.writeBuffer(this.matrixBufferDst.buffer, offsetBytes, matBytes.buffer, matBytes.byteOffset + offsetBytes, len);
      //         offsetBytes += len;
      //     }
      // }
      // public async mapAsync() {
      //     await this.matrixBufferDst.buffer.mapAsync(GPUMapMode.WRITE);
      //     const matBytes = Matrix4.dynamicMatrixBytes;
      //     new Float32Array(this.matrixBufferDst.buffer.getMappedRange()).set(matBytes);
      //     this.matrixBufferDst.buffer.unmap();
      // }
    }

    class GlobalBindGroup {
      static _cameraBindGroups;
      static _lightEntriesMap;
      static _probeEntries;
      static modelMatrixBindGroup;
      static init() {
        this.modelMatrixBindGroup = new MatrixBindGroup();
        this._cameraBindGroups = /* @__PURE__ */ new Map();
        this._lightEntriesMap = /* @__PURE__ */ new Map();
      }
      static getCameraGroup(camera) {
        let cameraBindGroup = this._cameraBindGroups.get(camera);
        if (!cameraBindGroup) {
          cameraBindGroup = new GlobalUniformGroup(this.modelMatrixBindGroup);
          this._cameraBindGroups.set(camera, cameraBindGroup);
        }
        if (camera.isShadowCamera) {
          cameraBindGroup.setShadowCamera(camera);
        } else {
          cameraBindGroup.setCamera(camera);
        }
        return cameraBindGroup;
      }
      static getLightEntries(scene) {
        if (!scene) {
          console.log(`getLightEntries scene is null`);
        }
        let lightEntries = this._lightEntriesMap.get(scene);
        if (!lightEntries) {
          lightEntries = new LightEntries();
          this._lightEntriesMap.set(scene, lightEntries);
        }
        return this._lightEntriesMap.get(scene);
      }
      static updateProbes(probes) {
        if (!this._probeEntries) {
          this._probeEntries = new ProbeEntries();
          this._probeEntries.initDataUniform(probes);
        }
      }
    }

    class GPUContext {
      static lastGeometry;
      static lastPipeline;
      static lastShader;
      static drawCount = 0;
      static renderPassCount = 0;
      static geometryCount = 0;
      static pipelineCount = 0;
      static matrixCount = 0;
      static lastRenderPassState;
      static LastCommand;
      /**
       * renderPipeline before render need bind pipeline
       * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
       * @param renderShader render pass shader {@link RenderShaderPass }
       * @returns 
       */
      static bindPipeline(encoder, renderShader) {
        if (GPUContext.lastShader != renderShader) {
          GPUContext.lastShader = renderShader;
        } else {
          return;
        }
        if (GPUContext.lastPipeline != renderShader.pipeline) {
          GPUContext.lastPipeline = renderShader.pipeline;
          encoder.setPipeline(renderShader.pipeline);
        }
        for (let i = 1; i < renderShader.bindGroups.length; i++) {
          const bindGroup = renderShader.bindGroups[i];
          if (bindGroup) {
            encoder.setBindGroup(i, bindGroup);
          }
        }
      }
      /**
       * render before need make sure use camera 
       * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
       * @param camera use camera {@link Camera3D}
       */
      static bindCamera(encoder, camera) {
        let cameraBindGroup = GlobalBindGroup.getCameraGroup(camera);
        encoder.setBindGroup(0, cameraBindGroup.globalBindGroup);
      }
      /**
       * bind geometry vertex buffer to current render pipeline 
       * @param encoder current GPURenderPassEncoder {@link GPURenderPassEncoder } {@link GPURenderBundleEncoder }
       * @param geometry engine geometry 
       * @param offset geometry buffer bytes offset 
       * @param size geometry buffer bytes length
       */
      static bindGeometryBuffer(encoder, geometry) {
        if (this.lastGeometry != geometry) {
          this.lastGeometry = geometry;
          if (geometry.indicesBuffer)
            encoder.setIndexBuffer(geometry.indicesBuffer.indicesGPUBuffer.buffer, geometry.indicesBuffer.indicesFormat);
          let vertexBuffer = geometry.vertexBuffer.vertexGPUBuffer;
          let vertexBufferLayouts = geometry.vertexBuffer.vertexBufferLayouts;
          for (let i = 0; i < vertexBufferLayouts.length; i++) {
            const vbLayout = vertexBufferLayouts[i];
            encoder.setVertexBuffer(i, vertexBuffer.buffer, vbLayout.offset, vbLayout.size);
          }
        }
      }
      /**
       * begin or end clean all use cache
       */
      static cleanCache() {
        this.lastGeometry = null;
        this.lastPipeline = null;
        this.lastShader = null;
      }
      /**
       * create a render pipeline
       * @param gpuRenderPipeline {@link GPURenderPipelineDescriptor}
       * @returns 
       */
      static createPipeline(gpuRenderPipeline) {
        ProfilerUtil.countStart("GPUContext", "pipeline");
        return webGPUContext.device.createRenderPipeline(gpuRenderPipeline);
      }
      /**
       * auto get webgpu commandEncoder and start a command encoder 
       * @returns commandEncoder {@link GPUCommandEncoder}
       */
      static beginCommandEncoder() {
        ProfilerUtil.countStart("GPUContext", "beginCommandEncoder");
        if (this.LastCommand) {
          webGPUContext.device.queue.submit([this.LastCommand.finish()]);
        }
        this.LastCommand = webGPUContext.device.createCommandEncoder();
        return this.LastCommand;
      }
      /**
       * end CommandEncoder record and submit
       * @param command {@link GPUCommandEncoder}
       */
      static endCommandEncoder(command) {
        if (this.LastCommand == command) {
          webGPUContext.device.queue.submit([this.LastCommand.finish()]);
          this.LastCommand = null;
          ProfilerUtil.countStart("GPUContext", "endCommandEncoder");
        }
      }
      /**
       * create a renderBundle gpu object by GPURenderBundleEncoderDescriptor 
       * @param des {@link GPURenderBundleEncoderDescriptor}
       * @returns renderBundleEncoder {@link GPURenderBundleEncoder}
       */
      static recordBundleEncoder(des) {
        let bundleEncoder = webGPUContext.device.createRenderBundleEncoder(des);
        return bundleEncoder;
      }
      /**
       * render pass start return current use gpu renderPassEncoder
       * @param command {@link GPUCommandEncoder}
       * @param renderPassState {@link RendererPassState}
       * @returns encoder {@link GPURenderPassEncoder}
       */
      static beginRenderPass(command, renderPassState) {
        this.cleanCache();
        this.renderPassCount++;
        this.lastRenderPassState = renderPassState;
        if (renderPassState.renderTargets && renderPassState.renderTargets.length > 0) {
          for (let i = 0; i < renderPassState.renderTargets.length; ++i) {
            const renderTarget = renderPassState.renderTargets[i];
            let att = renderPassState.renderPassDescriptor.colorAttachments[i];
            if (renderPassState.multisample > 0 && renderPassState.renderTargets.length == 1) {
              att.view = renderPassState.multiTexture.createView();
              att.resolveTarget = renderTarget.getGPUView();
            } else {
              att.view = renderTarget.getGPUTexture().createView();
            }
          }
          return command.beginRenderPass(renderPassState.renderPassDescriptor);
        } else {
          let att0 = renderPassState.renderPassDescriptor.colorAttachments[0];
          if (att0) {
            if (renderPassState.multisample > 0) {
              att0.view = renderPassState.multiTexture.createView();
              att0.resolveTarget = webGPUContext.context.getCurrentTexture().createView();
            } else {
              att0.view = webGPUContext.context.getCurrentTexture().createView();
            }
          }
          return command.beginRenderPass(renderPassState.renderPassDescriptor);
        }
      }
      /**
       * Start the rendering process to draw any pipes
       * @param encoder 
       * @param indexCount 
       * @param instanceCount 
       * @param firstIndex 
       * @param baseVertex 
       * @param firstInstance 
       */
      static drawIndexed(encoder, indexCount, instanceCount, firstIndex, baseVertex, firstInstance) {
        encoder.drawIndexed(indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
        this.drawCount++;
      }
      static draw(encoder, vertexCount, instanceCount, firstVertex, firstInstance) {
        encoder.draw(vertexCount, instanceCount, firstVertex, firstInstance);
        this.drawCount++;
      }
      /**
       * The GPU must be informed of the end of encoder recording
       * @param encoder 
       */
      static endPass(encoder) {
        encoder.insertDebugMarker("end");
        encoder.end();
      }
      /**
       * Perform the final calculation and submit the Shader to the GPU
       * @param command 
       * @param computes 
       */
      static computeCommand(command, computes) {
        let computePass = command.beginComputePass();
        for (let i = 0; i < computes.length; i++) {
          const compute = computes[i];
          compute.compute(computePass);
        }
        computePass.end();
      }
    }

    class MorphAttrDataGroup {
      source;
      input;
      output;
      reset(value) {
        this.input && this.input.destroy();
        this.output && this.output.destroy();
        this.input = this.output = null;
        this.source = value;
      }
      apply(vertexCount) {
        if (this.source) {
          if (!this.input) {
            let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
            this.input = new StorageGPUBuffer(this.source.length, usage, this.source);
            this.input.apply();
          }
          if (!this.output) {
            let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;
            this.output = new StorageGPUBuffer(vertexCount * 3, usage);
            this.output.apply();
          }
        }
      }
    }
    class MorphTargetData {
      enable;
      morphTargetsRelative;
      MaxMorphTargetCount = 64;
      _computeConfigArray;
      _computeConfigBuffer;
      _morphInfluenceArray;
      _morphInfluenceBuffer;
      _positionAttrDataGroup;
      _normalAttrDataGroup;
      _isInfluenceDirty;
      _morphTargetCount;
      _totalVertexCount;
      _computeShader;
      _computeShaders;
      _computeWorkGroupXY = 1;
      _collectMorphTargetData;
      _blendTarget;
      constructor() {
        this._isInfluenceDirty = true;
        this.generateGPUBuffer();
        this._positionAttrDataGroup = new MorphAttrDataGroup();
        this._normalAttrDataGroup = new MorphAttrDataGroup();
      }
      initMorphTarget(geometry) {
        this._collectMorphTargetData = this.collectMorphTargetList(geometry);
        this._computeShader && this._computeShader.destroy();
        let code = MorphTarget_shader.CsMain;
        this._computeShader = new ComputeShader(code);
        if (this._collectMorphTargetData.mergedNormal) {
          this._computeShader.setDefine("USE_MORPHNORMALS", true);
        } else {
          this._computeShader.deleteDefine("USE_MORPHNORMALS");
        }
        this._computeShaders = [this._computeShader];
        this._isInfluenceDirty = true;
        this._morphTargetCount = this._collectMorphTargetData.mtCount;
        this._totalVertexCount = this._collectMorphTargetData.vCount;
        this._morphInfluenceArray.fill(0);
        this._computeWorkGroupXY = this.calcWorkGroup(this._totalVertexCount);
        this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos);
        this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal);
      }
      applyRenderShader(renderShader) {
        this.uploadMorphTargetBuffer();
        this.uploadConfigGBuffer();
        renderShader.setUniformBuffer("morphTargetConfig", this._computeConfigBuffer);
        renderShader.setStorageBuffer("morphTargetOpPositions", this._positionAttrDataGroup.output);
        if (this._collectMorphTargetData.mergedNormal) {
          renderShader.setStorageBuffer("morphTargetOpNormals", this._normalAttrDataGroup.output);
        }
      }
      computeMorphTarget(command) {
        this.uploadConfigGBuffer();
        this.uploadMorphTargetBuffer();
        this._computeShader.setUniformBuffer("morphTargetConfig", this._computeConfigBuffer);
        this._computeShader.setStorageBuffer("morphTargetInfluence", this._morphInfluenceBuffer);
        this._computeShader.setStorageBuffer("morphTargetPositions", this._positionAttrDataGroup.input);
        this._computeShader.setStorageBuffer("morphTargetOpPositions", this._positionAttrDataGroup.output);
        if (this._collectMorphTargetData.mergedNormal) {
          this._computeShader.setStorageBuffer("morphTargetNormals", this._normalAttrDataGroup.input);
          this._computeShader.setStorageBuffer("morphTargetOpNormals", this._normalAttrDataGroup.output);
        }
        this._computeShader.workerSizeX = this._computeWorkGroupXY;
        this._computeShader.workerSizeY = this._computeWorkGroupXY;
        this._computeShader.workerSizeZ = 1;
        GPUContext.computeCommand(command, this._computeShaders);
      }
      updateInfluence(index, value) {
        this._isInfluenceDirty = true;
        this._morphInfluenceArray[index] = value;
      }
      get blendShape() {
        return this._blendTarget;
      }
      collectMorphTargetList(geometry) {
        let posAttrList = this.collectAttribute("a_morphPositions_", geometry);
        let morphTargetCount = posAttrList.length;
        let vertexCount = posAttrList[0].data.length / 3;
        this._blendTarget = {};
        if (geometry.blendShapeData) {
          for (let i = 0; i < geometry.blendShapeData.shapeIndexs.length; i++) {
            let index = geometry.blendShapeData.shapeIndexs[i];
            let shapeNames = geometry.blendShapeData.shapeNames[i].split(".");
            let shapeName = shapeNames[shapeNames.length - 1];
            this._blendTarget[shapeName] = (value) => this.updateInfluence(index, value);
          }
        }
        let posArray = new Float32Array(vertexCount * morphTargetCount * 3);
        {
          let offset = 0;
          for (let i = 0; i < morphTargetCount; i++) {
            let item = posAttrList[i];
            posArray.set(item.data, offset);
            offset += item.data.length;
          }
        }
        let normalAttrList = this.collectAttribute("a_morphNormals_", geometry);
        let normalArray;
        if (normalAttrList && normalAttrList.length > 0) {
          let offset = 0;
          normalArray = new Float32Array(vertexCount * morphTargetCount * 3);
          for (let i = 0; i < morphTargetCount; i++) {
            let item = normalAttrList[i];
            normalArray.set(item.data, offset);
            offset += item.data.length;
          }
        }
        return { mtCount: morphTargetCount, vCount: vertexCount, mergedPos: posArray, mergedNormal: normalArray };
      }
      collectAttribute(attrKey, geometry) {
        let list = [];
        for (let i = 0; i < this.MaxMorphTargetCount; i++) {
          let morphKey = attrKey + i;
          let item = geometry.getAttribute(morphKey);
          if (!item)
            break;
          else
            list[i] = item;
        }
        return list;
      }
      uploadConfigGBuffer() {
        if (this._isInfluenceDirty) {
          let sumInfluence = 0;
          for (let i = 0; i < this._morphTargetCount; i++) {
            sumInfluence += this._morphInfluenceArray[i];
          }
          this._morphInfluenceBuffer.setFloat32Array("data", this._morphInfluenceArray);
          this._morphInfluenceBuffer.apply();
          this._computeConfigArray[0] = this.morphTargetsRelative ? 1 : 1 - sumInfluence;
          this._computeConfigArray[1] = this._morphTargetCount;
          this._computeConfigArray[2] = this._totalVertexCount;
          this._computeConfigArray[3] = this._computeWorkGroupXY;
          this._computeConfigBuffer.setFloat32Array("data", this._computeConfigArray);
          this._computeConfigBuffer.apply();
          this._isInfluenceDirty = false;
        }
      }
      calcWorkGroup(count) {
        let groupXY = Math.ceil(Math.sqrt(count));
        let log2 = Math.ceil(Math.log2(groupXY));
        groupXY = Math.pow(2, log2);
        return groupXY;
      }
      uploadMorphTargetBuffer() {
        if (!this._positionAttrDataGroup.output) {
          this._positionAttrDataGroup.apply(this._totalVertexCount);
        }
        if (!this._normalAttrDataGroup.output) {
          this._normalAttrDataGroup.apply(this._totalVertexCount);
        }
      }
      generateGPUBuffer() {
        this._computeConfigArray = new Float32Array(4);
        this._computeConfigBuffer = new UniformGPUBuffer(4);
        this._morphInfluenceArray = new Float32Array(this.MaxMorphTargetCount);
        let usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        this._morphInfluenceBuffer = new StorageGPUBuffer(this.MaxMorphTargetCount, usage);
      }
    }

    var __defProp$k = Object.defineProperty;
    var __getOwnPropDesc$k = Object.getOwnPropertyDescriptor;
    var __decorateClass$k = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$k(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$k(target, key, result);
      return result;
    };
    exports.MeshRenderer = class MeshRenderer extends RenderNode {
      /**
       * Enabling this option allows the grid to display any shadows cast on the grid.
       */
      receiveShadow;
      morphData;
      constructor() {
        super();
      }
      onEnable() {
        super.onEnable();
      }
      onDisable() {
        super.onDisable();
      }
      cloneTo(obj) {
        let component = obj.addComponent(exports.MeshRenderer);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.receiveShadow = from.receiveShadow;
        return this;
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(value) {
        super.geometry = value;
        let isMorphTarget = value.morphTargetDictionary != null;
        if (isMorphTarget) {
          this.morphData ||= new MorphTargetData();
          this.morphData.morphTargetsRelative = value.morphTargetsRelative;
          this.morphData.initMorphTarget(value);
        }
        this.morphData && (this.morphData.enable = isMorphTarget);
        if (this.morphData && this.morphData.enable) {
          this.addRendererMask(RendererMask.MorphTarget);
        } else {
          this.removeRendererMask(RendererMask.MorphTarget);
        }
        this.object3D.bound = this._geometry.bounds.clone();
        if (!this._readyPipeline) {
          this.initPipeline();
          if (this._computes && this._computes) {
            this.onCompute = mergeFunctions(this.onCompute, () => {
              for (let i = 0; i < this._computes.length; i++) {
                const compute = this._computes[i];
                compute.onUpdate();
              }
            });
          }
        }
      }
      get material() {
        return this._materials[0];
      }
      set material(value) {
        this.materials = [value];
      }
      /**
       * Set deformation animation parameters
       */
      setMorphInfluence(key, value) {
        if (this.morphData && this.morphData.enable) {
          let index = this._geometry.morphTargetDictionary[key];
          if (index >= 0) {
            this.morphData.updateInfluence(index, value);
          }
        }
      }
      setMorphInfluenceIndex(index, value) {
        if (this.morphData && this.morphData.enable) {
          if (index >= 0) {
            this.morphData.updateInfluence(index, value);
          }
        }
      }
      onCompute(view, command) {
        if (this.morphData && this.morphData.enable) {
          this.morphData.computeMorphTarget(command);
        }
      }
      /**
       * @internal
       * @param passType
       * @param renderPassState
       * @param scene3D
       * @param clusterLightingRender
       * @param probes
       */
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        if (this.morphData && this.morphData.enable) {
          for (let i = 0; i < this.materials.length; i++) {
            const material = this.materials[i];
            let passes = material.getPass(passType);
            if (passes) {
              for (let j = 0; j < passes.length; j++) {
                this.morphData.applyRenderShader(passes[j]);
              }
            }
          }
        }
        super.nodeUpdate(view, passType, renderPassState, clusterLightingBuffer);
      }
      destroy(force) {
        super.destroy(force);
      }
      // public onGraphic(view?: View3D) {
      //     if (this._geometry)
      //         view.graphic3D.drawMeshWireframe(this._geometry.instanceID, this._geometry, this.transform, Color.COLOR_RED);
      // }
    };
    __decorateClass$k([
      EditorInspector
    ], exports.MeshRenderer.prototype, "geometry", 1);
    __decorateClass$k([
      EditorInspector
    ], exports.MeshRenderer.prototype, "geometry", 1);
    __decorateClass$k([
      EditorInspector
    ], exports.MeshRenderer.prototype, "material", 1);
    __decorateClass$k([
      EditorInspector
    ], exports.MeshRenderer.prototype, "material", 1);
    exports.MeshRenderer = __decorateClass$k([
      RegisterComponent(exports.MeshRenderer, "MeshRenderer")
    ], exports.MeshRenderer);

    class RendererPassState {
      label = "";
      customSize = false;
      zPreTexture = null;
      depthTexture = null;
      renderTargetTextures;
      outColor = -1;
      renderTargets;
      rtTextureDescriptors;
      irradianceBuffer;
      multisample = 0;
      multiTexture;
      depthViewIndex = 0;
      depthCleanValue = 0;
      isOutTarget = true;
      camera3D;
      rtFrame;
      renderPassDescriptor;
      renderBundleEncoderDescriptor;
      depthLoadOp;
      getLastRenderTexture() {
        if (this.renderTargets) {
          return this.renderTargets.length > 0 ? this.renderTargets[0] : Engine3D.res.redTexture;
        } else {
          return Engine3D.res.redTexture;
        }
      }
    }

    class WebGPUDescriptorCreator {
      static bindGroupDescriptorCount = 0;
      static bindTextureDescriptorCount = 0;
      static renderPassDescriptorCount = 0;
      static pipelineDescriptorCount = 0;
      static createRendererPassState(rtFrame, loadOp = null) {
        let rps = new RendererPassState();
        rps.label = rtFrame.label;
        rps.customSize = rtFrame.customSize;
        rps.rtFrame = rtFrame;
        rps.zPreTexture = rtFrame.zPreTexture;
        rps.depthTexture = rtFrame.depthTexture;
        rps.depthViewIndex = rtFrame.depthViewIndex;
        rps.isOutTarget = rtFrame.isOutTarget;
        rps.depthCleanValue = rtFrame.depthCleanValue;
        rps.depthLoadOp = rtFrame.depthLoadOp;
        if (rtFrame && rtFrame.renderTargets.length > 0) {
          rps.renderTargets = rtFrame.renderTargets;
          rps.rtTextureDescriptors = rtFrame.rtDescriptors;
          rps.renderPassDescriptor = WebGPUDescriptorCreator.getRenderPassDescriptor(rps);
          rps.renderBundleEncoderDescriptor = WebGPUDescriptorCreator.getRenderBundleDescriptor(rps);
          rps.renderTargetTextures = [];
          for (let i = 0; i < rtFrame.renderTargets.length; i++) {
            const element = rtFrame.renderTargets[i];
            rps.renderTargetTextures[i] = {
              format: element.format
            };
            if (element.name.indexOf(RTResourceConfig.colorBufferTex_NAME) != -1) {
              rps.outColor = i;
            }
          }
        } else {
          rps.renderPassDescriptor = WebGPUDescriptorCreator.getRenderPassDescriptor(rps, loadOp);
          rps.renderBundleEncoderDescriptor = WebGPUDescriptorCreator.getRenderBundleDescriptor(rps);
          rps.renderTargetTextures = [
            {
              format: webGPUContext.presentationFormat
            }
          ];
          rps.outColor = 0;
        }
        return rps;
      }
      /**
       * Get RenderPass Descriptor
       * Use AttachMentTextures , Texture Format Is Key
       * @param attachMentTextures
       * @param useDepth
       * @param cleanColor
       * @returns
       */
      // static getRenderPassDescriptor(attachMentTextures: VirtualTexture[], renderPassState:RenderPassState): any {
      static getRenderPassDescriptor(renderPassState, loadOp = null) {
        webGPUContext.device;
        webGPUContext.presentationSize;
        let attachMentTexture = [];
        if (renderPassState.renderTargets && renderPassState.renderTargets.length > 0) {
          [renderPassState.renderTargets[0].width, renderPassState.renderTargets[0].height];
          for (let i = 0; i < renderPassState.renderTargets.length; i++) {
            const texture = renderPassState.renderTargets[i];
            const rtDesc = renderPassState.rtTextureDescriptors[i];
            attachMentTexture.push({
              view: texture.getGPUView(),
              resolveTarget: void 0,
              loadOp: rtDesc.loadOp,
              // webGPUContext.canvasConfig && webGPUContext.canvasConfig.alpha ? `load` : `clear`,
              clearValue: rtDesc.clearValue,
              storeOp: rtDesc.storeOp
            });
          }
        } else {
          if (!renderPassState.customSize) {
            let clearValue = webGPUContext.canvasConfig && webGPUContext.canvasConfig.alpha ? [1, 1, 1, 0] : [0, 0, 0, 1];
            if (renderPassState.isOutTarget == true) {
              attachMentTexture.push({
                view: void 0,
                resolveTarget: void 0,
                loadOp: webGPUContext.canvasConfig && webGPUContext.canvasConfig.alpha || loadOp != null ? `load` : `clear`,
                clearValue,
                storeOp: "store"
              });
            }
          }
        }
        let renderPassDescriptor = null;
        if (renderPassState.depthTexture || renderPassState.zPreTexture) {
          if (renderPassState.zPreTexture) {
            renderPassState.depthTexture = renderPassState.zPreTexture;
          }
          renderPassDescriptor = {
            label: `${renderPassState.label} renderPassDescriptor zPreTexture${renderPassState.zPreTexture ? `load` : `clear`}`,
            colorAttachments: attachMentTexture,
            depthStencilAttachment: {
              view: renderPassState.depthTexture.getGPUView(),
              depthLoadOp: renderPassState.zPreTexture ? `load` : renderPassState.depthLoadOp,
              depthClearValue: renderPassState.zPreTexture ? 1 : renderPassState.depthCleanValue,
              depthStoreOp: "store"
              // stencilClearValue: 0,
              // stencilLoadOp: 'clear',
              // stencilStoreOp: 'store',
            }
          };
        } else {
          renderPassDescriptor = {
            colorAttachments: attachMentTexture,
            label: "renderPassDescriptor not writeDepth"
          };
        }
        this.renderPassDescriptorCount++;
        return renderPassDescriptor;
      }
      /**
       * Get RenderPass Descriptor
       * Use AttachMentTextures , Texture Format Is Key
       * @param attachMentTextures
       * @param useDepth
       * @param cleanColor
       * @returns
       */
      static getRenderBundleDescriptor(renderPassState) {
        webGPUContext.presentationSize;
        let attachMentTexture = [];
        if (renderPassState.renderTargets && renderPassState.renderTargets.length > 0) {
          [renderPassState.renderTargets[0].width, renderPassState.renderTargets[0].height];
          for (let i = 0; i < renderPassState.renderTargets.length; i++) {
            const renderTarget = renderPassState.renderTargets[i];
            attachMentTexture.push(renderTarget.format);
          }
        }
        let renderPassDescriptor = null;
        if (renderPassState.depthTexture) {
          renderPassDescriptor = {
            colorFormats: attachMentTexture,
            depthStencilFormat: renderPassState.depthTexture.format
          };
        } else {
          renderPassDescriptor = {
            colorFormats: attachMentTexture
          };
        }
        this.renderPassDescriptorCount++;
        return renderPassDescriptor;
      }
    }

    class VertexGPUBuffer extends GPUBufferBase {
      node;
      constructor(size) {
        super();
        this.bufferType = GPUBufferType.VertexGPUBuffer;
        this.createVertexBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.VERTEX, size);
      }
      createVertexBuffer(usage, size) {
        let device = webGPUContext.device;
        this.byteSize = size * Float32Array.BYTES_PER_ELEMENT;
        this.usage = usage;
        if (this.buffer) {
          this.destroy();
        }
        this.buffer = device.createBuffer({
          label: "VertexGPUBuffer",
          size: this.byteSize,
          usage,
          mappedAtCreation: false
        });
        this.memory = new MemoryDO();
        this.memoryNodes = /* @__PURE__ */ new Map();
        this.memory.allocation(this.byteSize);
        this.node = this.memory.allocation_node(this.byteSize);
      }
    }

    var GeometryVertexType = /* @__PURE__ */ ((GeometryVertexType2) => {
      GeometryVertexType2[GeometryVertexType2["split"] = 0] = "split";
      GeometryVertexType2[GeometryVertexType2["compose"] = 1] = "compose";
      GeometryVertexType2[GeometryVertexType2["compose_bin"] = 2] = "compose_bin";
      return GeometryVertexType2;
    })(GeometryVertexType || {});

    class GeometryVertexBuffer {
      vertexCount = 0;
      vertexGPUBuffer;
      geometryType = GeometryVertexType.compose;
      _vertexBufferLayouts;
      _attributeSlotLayouts;
      _attributeLocation;
      constructor() {
        this._vertexBufferLayouts = [];
        this._attributeLocation = {};
        this._attributeSlotLayouts = [];
      }
      get vertexBufferLayouts() {
        return this._vertexBufferLayouts;
      }
      createVertexBuffer(vertexDataInfos, shaderReflection) {
        switch (this.geometryType) {
          case GeometryVertexType.split:
            this.createSplitVertexBuffer(vertexDataInfos, shaderReflection);
            break;
          case GeometryVertexType.compose:
            this.createComposeVertexBuffer(vertexDataInfos, shaderReflection);
            break;
          case GeometryVertexType.compose_bin:
            this.createComposBinVertexBuffer(vertexDataInfos, shaderReflection);
            break;
        }
      }
      createSplitVertexBuffer(vertexDataInfos, shaderReflection) {
        let vertexOffset = 0;
        for (let i = 0; i < shaderReflection.attributes.length; i++) {
          const attributeInfo = shaderReflection.attributes[i];
          if (attributeInfo.name == `index`)
            continue;
          this._attributeLocation[attributeInfo.name] = attributeInfo.location;
          let attributeLayout = {
            name: attributeInfo.name,
            format: attributeInfo.format,
            offset: 0,
            shaderLocation: attributeInfo.location,
            stride: VertexAttributeSize[attributeInfo.format]
          };
          this._attributeSlotLayouts[attributeInfo.location] = [attributeLayout];
          let vertexInfo = vertexDataInfos.get(attributeInfo.name);
          if (!vertexInfo) {
            vertexInfo = {
              attribute: attributeInfo.name,
              data: new Float32Array(attributeInfo.size * this.vertexCount)
            };
            vertexDataInfos.set(attributeInfo.name, vertexInfo);
          }
          let len = vertexInfo.data.length / attributeLayout.stride;
          if (this.vertexCount != 0 && this.vertexCount != len) {
            console.error(" vertex count not match attribute count");
          }
          this.vertexCount = len;
          this._vertexBufferLayouts[attributeInfo.location] = {
            name: attributeInfo.name,
            arrayStride: attributeInfo.size * 4,
            stepMode: `vertex`,
            attributes: this._attributeSlotLayouts[attributeInfo.location],
            offset: vertexOffset * 4,
            size: this.vertexCount * attributeInfo.size * 4
          };
          vertexOffset += this.vertexCount * attributeInfo.size;
        }
        this.vertexGPUBuffer = new VertexGPUBuffer(vertexOffset);
      }
      createComposeVertexBuffer(vertexDataInfos, shaderReflection) {
        this._attributeSlotLayouts[0] = [];
        let attributeOffset = 0;
        for (let i = 0; i < shaderReflection.attributes.length; i++) {
          const attributeInfo = shaderReflection.attributes[i];
          if (attributeInfo.name == `index`)
            continue;
          if (attributeInfo.type == `builtin`)
            continue;
          this._attributeLocation[attributeInfo.name] = attributeInfo.location;
          let attributeLayout = {
            name: attributeInfo.name,
            format: attributeInfo.format,
            offset: attributeOffset * 4,
            shaderLocation: attributeInfo.location,
            stride: VertexAttributeSize[attributeInfo.format]
          };
          this._attributeSlotLayouts[0][attributeInfo.location] = attributeLayout;
          let vertexInfo = vertexDataInfos.get(attributeInfo.name);
          if (!vertexInfo) {
            vertexInfo = {
              attribute: attributeInfo.name,
              data: new Float32Array(attributeInfo.size * this.vertexCount)
            };
            vertexDataInfos.set(attributeInfo.name, vertexInfo);
          }
          if (vertexInfo.data) {
            let len = vertexInfo.data.length / attributeLayout.stride;
            if (this.vertexCount != 0 && this.vertexCount != len) {
              console.error(" vertex count not match attribute count");
            }
            this.vertexCount = len;
          }
          attributeOffset += attributeInfo.size;
        }
        this._vertexBufferLayouts[0] = {
          name: `composeStruct`,
          arrayStride: attributeOffset * 4,
          stepMode: `vertex`,
          attributes: this._attributeSlotLayouts[0],
          offset: 0,
          size: this.vertexCount * attributeOffset * 4
        };
        this.vertexGPUBuffer = new VertexGPUBuffer(this.vertexCount * attributeOffset);
      }
      createComposBinVertexBuffer(vertexDataInfos, shaderReflection) {
        this._attributeSlotLayouts[0] = [];
        let attributeOffset = 0;
        for (let i = 0; i < shaderReflection.attributes.length; i++) {
          const attributeInfo = shaderReflection.attributes[i];
          if (attributeInfo.name == `index`)
            continue;
          if (attributeInfo.type == `builtin`)
            continue;
          this._attributeLocation[attributeInfo.name] = attributeInfo.location;
          let attributeLayout = {
            name: attributeInfo.name,
            format: attributeInfo.format,
            offset: attributeOffset * 4,
            shaderLocation: attributeInfo.location,
            stride: VertexAttributeSize[attributeInfo.format]
          };
          this._attributeSlotLayouts[0][attributeInfo.location] = attributeLayout;
          let vertexInfo = vertexDataInfos.get(attributeInfo.name);
          if (!vertexInfo) {
            vertexInfo = {
              attribute: attributeInfo.name,
              data: new Float32Array(attributeInfo.size * this.vertexCount)
            };
            vertexDataInfos.set(attributeInfo.name, vertexInfo);
          }
          if (vertexInfo.data) {
            let len2 = vertexInfo.data.length / attributeLayout.stride;
            if (this.vertexCount != 0 && this.vertexCount != len2) {
              console.error(" vertex count not match attribute count");
            }
            this.vertexCount = len2;
          }
          attributeOffset += attributeInfo.size;
        }
        let att_all = vertexDataInfos.get(VertexAttributeName.all);
        let len = att_all.data.length / attributeOffset;
        this.vertexCount = len;
        this._vertexBufferLayouts[0] = {
          name: `composeStruct`,
          arrayStride: attributeOffset * 4,
          stepMode: `vertex`,
          attributes: this._attributeSlotLayouts[0],
          offset: 0,
          size: this.vertexCount * attributeOffset * 4
        };
        this.vertexGPUBuffer = new VertexGPUBuffer(this.vertexCount * attributeOffset);
      }
      upload(attribute, vertexDataInfo) {
        if (!this.vertexGPUBuffer)
          return;
        switch (this.geometryType) {
          case GeometryVertexType.split:
            {
              let location = this._attributeLocation[attribute];
              let vertexBufferLayout = this._vertexBufferLayouts[location];
              this.vertexGPUBuffer.node.setFloat32Array(vertexBufferLayout.offset / 4, vertexDataInfo.data);
            }
            break;
          case GeometryVertexType.compose:
            {
              for (let i = 0; i < this.vertexCount; i++) {
                const attributeLayout = this._attributeSlotLayouts[0][this._attributeLocation[attribute]];
                for (let k = 0; k < attributeLayout.stride; k++) {
                  let atData = vertexDataInfo.data[i * attributeLayout.stride + k];
                  let index = i * (this._vertexBufferLayouts[0].arrayStride / 4) + attributeLayout.offset / 4 + k;
                  this.vertexGPUBuffer.node.setFloat(atData, index);
                }
              }
            }
            break;
          case GeometryVertexType.compose_bin:
            this.vertexGPUBuffer.node.setFloat32Array(0, vertexDataInfo.data);
            break;
        }
        this.vertexGPUBuffer?.apply();
      }
      updateAttributes(vertexDataInfos) {
        switch (this.geometryType) {
          case GeometryVertexType.split:
            {
              for (let i = 0; i < this._vertexBufferLayouts.length; i++) {
                const vertexBufferLayout = this._vertexBufferLayouts[i];
                let attributeData = vertexDataInfos.get(vertexBufferLayout.name);
                this.vertexGPUBuffer.node.setFloat32Array(vertexBufferLayout.offset / 4, attributeData.data);
              }
            }
            break;
          case GeometryVertexType.compose:
            {
              for (let i = 0; i < this.vertexCount; i++) {
                this._attributeSlotLayouts.forEach((v) => {
                  for (let j = 0; j < v.length; j++) {
                    const attributeLayout = v[j];
                    let attributeData = vertexDataInfos.get(attributeLayout.name);
                    for (let k = 0; k < attributeLayout.stride; k++) {
                      let atData = attributeData.data[i * attributeLayout.stride + k];
                      let index = i * (this._vertexBufferLayouts[0].arrayStride / 4) + attributeLayout.offset / 4 + k;
                      this.vertexGPUBuffer.node.setFloat(atData, index);
                    }
                  }
                });
              }
            }
            break;
          case GeometryVertexType.compose_bin:
            {
              let attributeData = vertexDataInfos.get(VertexAttributeName.all);
              this.vertexGPUBuffer.node.setFloat32Array(0, attributeData.data);
            }
            break;
        }
        this.vertexGPUBuffer.apply();
      }
      compute() {
      }
      destroy(force) {
        this.vertexCount = null;
        this.geometryType = null;
        this._vertexBufferLayouts = null;
        this._attributeSlotLayouts = null;
        this._attributeLocation = null;
        if (this.vertexGPUBuffer)
          this.vertexGPUBuffer.destroy(force);
        this.vertexGPUBuffer = null;
      }
    }

    class IndicesGPUBuffer extends GPUBufferBase {
      indicesNode;
      constructor(data) {
        super();
        this.bufferType = GPUBufferType.IndicesGPUBuffer;
        this.createIndicesBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.INDEX | GPUBufferUsage.INDIRECT, data);
      }
      createIndicesBuffer(usage, data) {
        let device = webGPUContext.device;
        this.byteSize = data.length * 4;
        this.usage = usage;
        if (this.buffer) {
          this.destroy();
        }
        this.buffer = device.createBuffer({
          label: "IndicesGPUBuffer",
          size: this.byteSize,
          usage,
          mappedAtCreation: false
        });
        this.memory = new MemoryDO();
        this.memoryNodes = /* @__PURE__ */ new Map();
        this.memory.allocation(this.byteSize);
        if (data) {
          this.indicesNode = this.memory.allocation_node(data.length * 4);
          this.indicesNode.setArrayBuffer(0, data);
          this.apply();
        }
      }
    }

    class GeometryIndicesBuffer {
      uuid = "";
      name;
      indicesGPUBuffer;
      indicesFormat = `uint16`;
      indicesCount = 0;
      constructor() {
      }
      createIndicesBuffer(indicesData) {
        if (indicesData.data instanceof Uint16Array) {
          this.indicesFormat = `uint16`;
        } else if (indicesData.data instanceof Uint32Array) {
          this.indicesFormat = `uint32`;
        }
        this.indicesCount = indicesData.data.length;
        this.indicesGPUBuffer = new IndicesGPUBuffer(indicesData.data);
      }
      upload(data) {
        this.indicesGPUBuffer.indicesNode.setArrayBuffer(0, data);
        this.indicesGPUBuffer.apply();
      }
      compute() {
      }
      destroy() {
        this.uuid = null;
        this.name = null;
        this.indicesFormat = null;
        this.indicesCount = null;
        this.indicesGPUBuffer.destroy();
        this.indicesGPUBuffer = null;
      }
      /**
       * Get indices from geometry data 
       * Get position attribute from geometry data 
       * Get normal attribute from geometry data 
       * Get tangent attribute from geometry data 
       * Get uv0 attribute from geometry data 
       * Get uv1 attribute from geometry data 
       * Get uv2 attribute from geometry data 
       * 
       * Change position data to GPUBuffer and apply
       * Change normal data to GPUBuffer and apply
       * Change tangent data to GPUBuffer and apply
       * Change uv0 data to GPUBuffer and apply
       * Change uv1 data to GPUBuffer and apply
       * Change uv2 data to GPUBuffer and apply
       */
    }

    class SubGeometry {
      lodLevels;
    }
    class GeometryBase {
      instanceID;
      name;
      subGeometries = [];
      morphTargetsRelative;
      morphTargetDictionary;
      skinNames;
      bindPose;
      blendShapeData;
      vertexDim;
      _bounds;
      _attributeMap;
      _attributes;
      _indicesBuffer;
      _vertexBuffer;
      _onChange = true;
      _wireframeLines;
      constructor() {
        this.instanceID = UUID();
        this._attributeMap = /* @__PURE__ */ new Map();
        this._attributes = [];
        this._vertexBuffer = new GeometryVertexBuffer();
      }
      get indicesBuffer() {
        return this._indicesBuffer;
      }
      get vertexBuffer() {
        return this._vertexBuffer;
      }
      get vertexAttributes() {
        return this._attributes;
      }
      get vertexAttributeMap() {
        return this._attributeMap;
      }
      get geometryType() {
        return this._vertexBuffer.geometryType;
      }
      set geometryType(value) {
        this._vertexBuffer.geometryType = value;
      }
      get bounds() {
        if (!this._bounds) {
          this._bounds = new BoundingBox(new Vector3(), new Vector3(1, 1, 1));
          this._bounds.min.x = Number.MAX_VALUE;
          this._bounds.min.y = Number.MAX_VALUE;
          this._bounds.min.z = Number.MAX_VALUE;
          this._bounds.max.x = -Number.MAX_VALUE;
          this._bounds.max.y = -Number.MAX_VALUE;
          this._bounds.max.z = -Number.MAX_VALUE;
          let attributes = this.getAttribute(VertexAttributeName.position);
          if (attributes && attributes.data) {
            for (let i = 0; i < attributes.data.length / 3; i++) {
              const px = attributes.data[i * 3 + 0];
              const py = attributes.data[i * 3 + 1];
              const pz = attributes.data[i * 3 + 2];
              if (this._bounds.min.x > px) {
                this._bounds.min.x = px;
              }
              if (this._bounds.min.y > py) {
                this._bounds.min.y = py;
              }
              if (this._bounds.min.z > pz) {
                this._bounds.min.z = pz;
              }
              if (this._bounds.max.x < px) {
                this._bounds.max.x = px;
              }
              if (this._bounds.max.y < py) {
                this._bounds.max.y = py;
              }
              if (this._bounds.max.z < pz) {
                this._bounds.max.z = pz;
              }
            }
          }
          this._bounds.setFromMinMax(this._bounds.min, this._bounds.max);
        }
        return this._bounds;
      }
      set bounds(value) {
        this._bounds = value;
      }
      /**
       * add subGeometry from lod level 
       * @param lodLevels @see LODDescriptor
       */
      addSubGeometry(...lodLevels) {
        let sub = new SubGeometry();
        sub.lodLevels = lodLevels;
        this.subGeometries.push(sub);
        return sub;
      }
      /**
       * create geometry by shaderReflection
       * @param shaderReflection ShaderReflection
       */
      generate(shaderReflection) {
        if (this._onChange) {
          this._onChange = false;
          this._indicesBuffer.upload(this.getAttribute(VertexAttributeName.indices).data);
          this._vertexBuffer.createVertexBuffer(this._attributeMap, shaderReflection);
          this._vertexBuffer.updateAttributes(this._attributeMap);
        }
      }
      setIndices(data) {
        if (!this._attributeMap.has(VertexAttributeName.indices)) {
          let vertexInfo = {
            attribute: VertexAttributeName.indices,
            data
          };
          this._attributeMap.set(VertexAttributeName.indices, vertexInfo);
          this._indicesBuffer = new GeometryIndicesBuffer();
          this._indicesBuffer.createIndicesBuffer(vertexInfo);
        }
      }
      setAttribute(attribute, data) {
        if (attribute == VertexAttributeName.indices) {
          this.setIndices(data);
        } else {
          let vertexInfo = {
            attribute,
            data
          };
          this._attributeMap.set(attribute, vertexInfo);
          this._attributes.push(attribute);
        }
      }
      getAttribute(attribute) {
        return this._attributeMap.get(attribute);
      }
      hasAttribute(attribute) {
        return this._attributeMap.has(attribute);
      }
      genWireframe() {
        if (this._wireframeLines)
          return this._wireframeLines;
        if (this.geometryType == GeometryVertexType.split || this.geometryType == GeometryVertexType.compose) {
          let positionAttribute = this.getAttribute(VertexAttributeName.position);
          let indexAttribute = this.getAttribute(VertexAttributeName.indices);
          if (indexAttribute && positionAttribute && indexAttribute.data.length > 0) {
            let vertexData = positionAttribute.data;
            let lines = [];
            for (let i = 0; i < indexAttribute.data.length / 3; i++) {
              const i1 = indexAttribute.data[i * 3 + 0];
              const i2 = indexAttribute.data[i * 3 + 1];
              const i3 = indexAttribute.data[i * 3 + 2];
              let p1 = new Vector3(vertexData[i1 * 3 + 0], vertexData[i1 * 3 + 1], vertexData[i1 * 3 + 2]);
              let p2 = new Vector3(vertexData[i2 * 3 + 0], vertexData[i2 * 3 + 1], vertexData[i2 * 3 + 2]);
              let p3 = new Vector3(vertexData[i3 * 3 + 0], vertexData[i3 * 3 + 1], vertexData[i3 * 3 + 2]);
              lines.push(p1, p2);
              lines.push(p2, p3);
              lines.push(p3, p1);
            }
            this._wireframeLines = lines;
            return lines;
          }
        } else if (this.geometryType == GeometryVertexType.compose_bin) {
          let vertexAttribute = this.getAttribute(VertexAttributeName.all);
          let strip = this.vertexDim;
          let indexAttribute = this.getAttribute(VertexAttributeName.indices);
          if (indexAttribute && vertexAttribute && indexAttribute.data.length > 0) {
            let vertexData = vertexAttribute.data;
            let lines = [];
            for (let i = 0; i < indexAttribute.data.length / 3; i++) {
              const i1 = indexAttribute.data[i * 3 + 0];
              const i2 = indexAttribute.data[i * 3 + 1];
              const i3 = indexAttribute.data[i * 3 + 2];
              let p1 = new Vector3(vertexData[i1 * strip + 0], vertexData[i1 * strip + 1], vertexData[i1 * strip + 2]);
              let p2 = new Vector3(vertexData[i2 * strip + 0], vertexData[i2 * strip + 1], vertexData[i2 * strip + 2]);
              let p3 = new Vector3(vertexData[i3 * strip + 0], vertexData[i3 * strip + 1], vertexData[i3 * strip + 2]);
              lines.push(p1, p2);
              lines.push(p2, p3);
              lines.push(p3, p1);
            }
            this._wireframeLines = lines;
            return lines;
          }
        }
        return null;
      }
      compute() {
        if (this._indicesBuffer) {
          this._indicesBuffer.compute();
        }
        if (this._vertexBuffer) {
          this._vertexBuffer.compute();
        }
      }
      static crossA = Vector3.UP.clone();
      static crossB = Vector3.UP.clone();
      static crossRet = Vector3.UP.clone();
      static point1 = Vector3.UP.clone();
      static point2 = Vector3.UP.clone();
      static point3 = Vector3.UP.clone();
      // compute normal by vertex position
      computeNormals() {
        let posAttrData = this.getAttribute(VertexAttributeName.position);
        let normalAttrData = this.getAttribute(VertexAttributeName.normal);
        let indexAttrData = this.getAttribute(VertexAttributeName.indices);
        if (!posAttrData || !normalAttrData || !indexAttrData) {
          return this;
        }
        let trianglesCount = indexAttrData.data.length / 3;
        let point1 = GeometryBase.point1;
        let point2 = GeometryBase.point2;
        let point3 = GeometryBase.point3;
        let crossA = GeometryBase.crossA;
        let crossB = GeometryBase.crossB;
        let crossRet = GeometryBase.crossRet;
        for (let i = 0; i < trianglesCount; i++) {
          let index1 = indexAttrData.data[i * 3];
          let index2 = indexAttrData.data[i * 3 + 1];
          let index3 = indexAttrData.data[i * 3 + 2];
          point1.set(posAttrData.data[index1 * 3], posAttrData.data[index1 * 3 + 1], posAttrData.data[index1 * 3 + 2]);
          point2.set(posAttrData.data[index2 * 3], posAttrData.data[index2 * 3 + 1], posAttrData.data[index2 * 3 + 2]);
          point3.set(posAttrData.data[index3 * 3], posAttrData.data[index3 * 3 + 1], posAttrData.data[index3 * 3 + 2]);
          Vector3.sub(point1, point2, crossA).normalize();
          Vector3.sub(point1, point3, crossB).normalize();
          let normal = crossA.crossProduct(crossB, crossRet).normalize();
          normalAttrData.data[index1 * 3] = normalAttrData.data[index2 * 3] = normalAttrData.data[index3 * 3] = normal.x;
          normalAttrData.data[index1 * 3 + 1] = normalAttrData.data[index2 * 3 + 1] = normalAttrData.data[index3 * 3 + 1] = normal.y;
          normalAttrData.data[index1 * 3 + 2] = normalAttrData.data[index2 * 3 + 2] = normalAttrData.data[index3 * 3 + 2] = normal.z;
        }
        this._vertexBuffer.upload(VertexAttributeName.normal, normalAttrData);
        return this;
      }
      isPrimitive() {
        return false;
      }
      destroy(force) {
        this.instanceID = null;
        this.name = null;
        this.subGeometries = null;
        this.morphTargetDictionary = null;
        this._bounds.destroy();
        this._bounds = null;
        this._attributeMap = null;
        this._attributes = null;
        this._indicesBuffer.destroy();
        this._vertexBuffer.destroy();
        this._indicesBuffer = null;
        this._vertexBuffer = null;
      }
    }

    class PlaneGeometry extends GeometryBase {
      /**
       * Width of the plane
       */
      width;
      /**
       * Height of the plane
       */
      height;
      /**
       * Number of width segments of a plane
       */
      segmentW;
      /**
       * Number of height segments of a plane
       */
      segmentH;
      /**
       * Define the normal vector of a plane
       */
      up;
      /**
       *
       * @constructor
       * @param width Width of the plane
       * @param height Height of the plane
       * @param segmentW Number of width segments of a plane
       * @param segmentH Number of height segments of a plane
       * @param up Define the normal vector of a plane
       */
      constructor(width, height, segmentW = 1, segmentH = 1, up = Vector3.Y_AXIS) {
        super();
        this.width = width;
        this.height = height;
        this.segmentW = segmentW;
        this.segmentH = segmentH;
        this.up = up;
        this.buildGeometry(this.up);
      }
      buildGeometry(axis) {
        var x, y;
        var numIndices;
        var base;
        var tw = this.segmentW + 1;
        (this.segmentH + 1) * tw;
        this.bounds = new BoundingBox(Vector3.ZERO.clone(), new Vector3(this.width, 1, this.height));
        numIndices = this.segmentH * this.segmentW * 6;
        let vertexCount = (this.segmentW + 1) * (this.segmentH + 1);
        let position_arr = new Float32Array(vertexCount * 3);
        let normal_arr = new Float32Array(vertexCount * 3);
        let uv_arr = new Float32Array(vertexCount * 2);
        let indices_arr;
        let totalIndexCount = this.segmentW * this.segmentH * 2 * 3;
        if (totalIndexCount >= Uint16Array.length) {
          indices_arr = new Uint32Array(this.segmentW * this.segmentH * 2 * 3);
        } else {
          indices_arr = new Uint16Array(this.segmentW * this.segmentH * 2 * 3);
        }
        numIndices = 0;
        var indexP = 0;
        var indexN = 0;
        var indexU = 0;
        for (var yi = 0; yi <= this.segmentH; ++yi) {
          for (var xi = 0; xi <= this.segmentW; ++xi) {
            x = (xi / this.segmentW - 0.5) * this.width;
            y = (yi / this.segmentH - 0.5) * this.height;
            switch (axis) {
              case Vector3.Y_AXIS:
                position_arr[indexP++] = x;
                position_arr[indexP++] = 0;
                position_arr[indexP++] = y;
                normal_arr[indexN++] = 0;
                normal_arr[indexN++] = 1;
                normal_arr[indexN++] = 0;
                break;
              case Vector3.Z_AXIS:
                position_arr[indexP++] = x;
                position_arr[indexP++] = -y;
                position_arr[indexP++] = 0;
                normal_arr[indexN++] = 0;
                normal_arr[indexN++] = 0;
                normal_arr[indexN++] = 1;
                break;
              case Vector3.X_AXIS:
                position_arr[indexP++] = 0;
                position_arr[indexP++] = x;
                position_arr[indexP++] = y;
                normal_arr[indexN++] = 1;
                normal_arr[indexN++] = 0;
                normal_arr[indexN++] = 0;
                break;
              default:
                position_arr[indexP++] = x;
                position_arr[indexP++] = 0;
                position_arr[indexP++] = y;
                normal_arr[indexN++] = 0;
                normal_arr[indexN++] = 1;
                normal_arr[indexN++] = 0;
                break;
            }
            uv_arr[indexU++] = xi / this.segmentW;
            uv_arr[indexU++] = yi / this.segmentH;
            if (xi != this.segmentW && yi != this.segmentH) {
              base = xi + yi * tw;
              indices_arr[numIndices++] = base + 1;
              indices_arr[numIndices++] = base;
              indices_arr[numIndices++] = base + tw;
              indices_arr[numIndices++] = base + 1;
              indices_arr[numIndices++] = base + tw;
              indices_arr[numIndices++] = base + tw + 1;
            }
          }
        }
        this.setIndices(indices_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
      }
    }

    class Material {
      /**
       *
       * Material Unique Identifier
       */
      instanceID;
      /**
        *
        * name of this material
        */
      name;
      enable = true;
      _defaultSubShader;
      _shader;
      constructor() {
      }
      set shader(shader) {
        this._shader = shader;
        this._defaultSubShader = shader.getDefaultShaders()[0];
      }
      get shader() {
        return this._shader;
      }
      get doubleSide() {
        return this._defaultSubShader.doubleSide;
      }
      set doubleSide(value) {
        this._defaultSubShader.doubleSide = value;
      }
      get castShadow() {
        return this._defaultSubShader.shaderState.castShadow;
      }
      set castShadow(value) {
        let shaderState = this._defaultSubShader.shaderState;
        if (value != shaderState.castShadow) {
          shaderState.castShadow = value;
        }
      }
      get acceptShadow() {
        return this._defaultSubShader.shaderState.acceptShadow;
      }
      set acceptShadow(value) {
        let shaderState = this._defaultSubShader.shaderState;
        if (shaderState.acceptShadow != value) {
          shaderState.acceptShadow = value;
          this._defaultSubShader.noticeShaderChange();
          this._defaultSubShader.noticeValueChange();
        }
      }
      get blendMode() {
        return this._defaultSubShader.blendMode;
      }
      set blendMode(value) {
        this._defaultSubShader.blendMode = value;
      }
      get depthCompare() {
        return this._defaultSubShader.depthCompare;
      }
      set depthCompare(value) {
        this._defaultSubShader.depthCompare = value;
      }
      get transparent() {
        return this._defaultSubShader.shaderState.transparent;
      }
      set transparent(value) {
        this._defaultSubShader.shaderState.transparent = value;
        if (value) {
          this._defaultSubShader.renderOrder = 3e3;
        }
      }
      get cullMode() {
        return this._defaultSubShader.cullMode;
      }
      set cullMode(value) {
        if (this._defaultSubShader.cullMode != value) {
          for (let list of this._shader.passShader.values()) {
            for (let pass of list) {
              pass.cullMode = value;
            }
          }
          this._defaultSubShader.cullMode = value;
        }
      }
      get depthWriteEnabled() {
        return this._defaultSubShader.depthWriteEnabled;
      }
      set depthWriteEnabled(value) {
        this._defaultSubShader.depthWriteEnabled = value;
      }
      set useBillboard(value) {
        this._defaultSubShader.setDefine("USE_BILLBOARD", value);
      }
      /**
       * get render pass by renderType
       * @param passType 
       * @returns 
       */
      getPass(passType) {
        return this._shader.getSubShaders(passType);
      }
      /**
       * get all color render pass
       * @returns 
       */
      getAllPass() {
        return this._shader.getSubShaders(PassType.COLOR);
      }
      /**
       * clone one material
       * @returns Material
       */
      clone() {
        let newMat = new Material();
        newMat.shader = this.shader.clone();
        return newMat;
      }
      destroy(force) {
        this._shader.destroy();
        this._shader = null;
      }
      setDefine(define, value) {
        this.shader.setDefine(define, value);
      }
      setTexture(propertyName, texture) {
        this._shader.setTexture(propertyName, texture);
      }
      setStorageBuffer(propertyName, buffer) {
        this._shader.setStorageBuffer(propertyName, buffer);
      }
      setUniformBuffer(propertyName, buffer) {
        this._shader.setStorageBuffer(propertyName, buffer);
      }
      setUniformFloat(propertyName, value) {
        this._shader.setUniformFloat(propertyName, value);
      }
      setUniformVector2(propertyName, value) {
        this._shader.setUniformVector2(propertyName, value);
      }
      setUniformVector3(propertyName, value) {
        this._shader.setUniformVector3(propertyName, value);
      }
      setUniformVector4(propertyName, value) {
        this._shader.setUniformVector4(propertyName, value);
      }
      setUniformColor(propertyName, value) {
        this._shader.setUniformColor(propertyName, value);
      }
      getUniformFloat(str) {
        return this._shader.getUniform(str).data;
      }
      getUniformV2(str) {
        return this._shader.getUniformVector2(str);
      }
      getUniformV3(str) {
        return this._shader.getUniformVector3(str);
      }
      getUniformV4(str) {
        return this._shader.getUniformVector4(str);
      }
      getUniformColor(str) {
        return this._shader.getUniformColor(str);
      }
      getTexture(str) {
        return this._shader.getTexture(str);
      }
      getStorageBuffer(str) {
        return this._shader.getStorageBuffer(str);
      }
      getStructStorageBuffer(str) {
        return this._shader.getStructStorageBuffer(str);
      }
      getUniformBuffer(str) {
        return this._shader.getUniformBuffer(str);
      }
      applyUniform() {
        this._shader.applyUniform();
      }
    }

    class Shader {
      computes;
      passShader;
      constructor() {
        this.computes = [];
        this.passShader = /* @__PURE__ */ new Map();
      }
      addRenderPass(renderShader, index = -1) {
        let subShader = this.passShader.get(renderShader.passType) || [];
        if (index == -1) {
          subShader.push(renderShader);
        } else {
          subShader.splice(index, -1, renderShader);
        }
        this.passShader.set(renderShader.passType, subShader);
      }
      removeShader(renderShader, index = -1) {
        let subShader = this.passShader.get(renderShader.passType);
        if (subShader) {
          if (index == -1) {
            let index2 = subShader.indexOf(renderShader);
            if (index2 != -1) {
              subShader.splice(index2);
            }
          } else {
            subShader.splice(index, 1);
          }
        }
      }
      removeShaderByIndex(passType, index = -1) {
        let subShader = this.passShader.get(passType);
        if (subShader) {
          if (index == -1) {
            this.passShader.delete(passType);
          } else {
            subShader.splice(index, 1);
          }
        }
      }
      getSubShaders(passType) {
        return this.passShader.get(passType) || [];
      }
      hasSubShaders(passType) {
        let subs = this.passShader.get(passType);
        return subs.length > 0;
      }
      getDefaultShaders() {
        return this.passShader.get(PassType.COLOR);
      }
      getDefaultColorShader() {
        return this.passShader.get(PassType.COLOR)[0];
      }
      setDefine(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setDefine(arg0, arg1);
          }
        }
      }
      deleteDefine(arg0) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.deleteDefine(arg0);
          }
        }
      }
      setUniform(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniform(arg0, arg1);
          }
        }
      }
      setUniformFloat(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformFloat(arg0, arg1);
          }
        }
      }
      setUniformVector2(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformVector2(arg0, arg1);
          }
        }
      }
      setUniformVector3(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformVector3(arg0, arg1);
          }
        }
      }
      setUniformVector4(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformVector4(arg0, arg1);
          }
        }
      }
      setUniformColor(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformColor(arg0, arg1);
          }
        }
      }
      getUniform(arg0) {
        return this.getDefaultColorShader().getUniform(arg0);
      }
      getUniformFloat(arg0) {
        return this.getDefaultColorShader().getUniformFloat(arg0);
      }
      getUniformVector2(arg0) {
        return this.getDefaultColorShader().getUniformVector2(arg0);
      }
      getUniformVector3(arg0) {
        return this.getDefaultColorShader().getUniformVector3(arg0);
      }
      getUniformVector4(arg0) {
        return this.getDefaultColorShader().getUniformVector4(arg0);
      }
      getUniformColor(arg0) {
        return this.getDefaultColorShader().getUniformColor(arg0);
      }
      setTexture(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setTexture(arg0, arg1);
          }
        }
        this.setDefine(`USE_${arg0.toLocaleUpperCase()}`, true);
      }
      getTexture(arg0) {
        return this.getDefaultColorShader().textures[arg0];
      }
      setUniformBuffer(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setUniformBuffer(arg0, arg1);
          }
        }
      }
      getUniformBuffer(arg0) {
        return this.getDefaultColorShader().getBuffer(arg0);
      }
      setStorageBuffer(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setStorageBuffer(arg0, arg1);
          }
        }
      }
      getStorageBuffer(arg0) {
        return this.getDefaultColorShader().getBuffer(arg0);
      }
      setStructStorageBuffer(arg0, arg1) {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.setStructStorageBuffer(arg0, arg1);
          }
        }
      }
      getStructStorageBuffer(arg0) {
        return this.getDefaultColorShader().getBuffer(arg0);
      }
      noticeValueChange() {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.noticeValueChange();
          }
        }
      }
      destroy() {
        this.getDefaultColorShader().destroy();
      }
      clone() {
        let newShader = new Shader();
        let sourceShaderPassList = this.getDefaultShaders();
        for (const shadePass of sourceShaderPassList) {
          newShader.addRenderPass(shadePass);
        }
        return newShader;
      }
      applyUniform() {
        for (const pass of this.passShader) {
          for (const rd of pass[1]) {
            rd.applyUniform();
          }
        }
      }
    }

    var __defProp$j = Object.defineProperty;
    var __getOwnPropDesc$j = Object.getOwnPropertyDescriptor;
    var __decorateClass$j = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$j(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$j(target, key, result);
      return result;
    };
    exports.QuadShader = class QuadShader extends Shader {
      constructor(vs = "QuadGlsl_vs", fs = "QuadGlsl_fs") {
        super();
        let colorShader = new RenderShaderPass(vs, fs);
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        colorShader.blendMode = BlendMode.NONE;
        shaderState.frontFace = `cw`;
        shaderState.depthWriteEnabled = false;
        shaderState.depthCompare = GPUCompareFunction.always;
        shaderState.multisample = 0;
        this.setTexture("baseMap", Engine3D.res.blackTexture);
        this.setUniformFloat(`x`, 0);
        this.setUniformFloat(`y`, 0);
        this.setUniformFloat(`width`, 100);
        this.setUniformFloat(`height`, 100);
      }
    };
    exports.QuadShader = __decorateClass$j([
      RegisterShader
    ], exports.QuadShader);

    class ViewQuad extends exports.Object3D {
      width = 128;
      height = 128;
      quadRenderer;
      material;
      // uniforms: { [key: string]: UniformNode };
      rendererPassState;
      quadShader;
      constructor(vs = "QuadGlsl_vs", fs = "QuadGlsl_fs", rtFrame, multisample = 0, f = false) {
        super();
        let renderTexture = rtFrame ? rtFrame.renderTargets : [];
        this.material = new Material();
        this.quadShader = new exports.QuadShader(vs, fs);
        this.material.shader = this.quadShader;
        this.quadRenderer = this.addComponent(exports.MeshRenderer);
        this.quadRenderer.material = this.material;
        this.quadRenderer.castGI = false;
        this.quadRenderer.castShadow = false;
        this.quadRenderer.drawType = f ? 2 : 0;
        this.quadRenderer.geometry = new PlaneGeometry(100, 100, 1, 1);
        this.quadRenderer.material = this.material;
        this.quadRenderer[`__start`]();
        this.quadRenderer[`_enable`] = true;
        this.quadRenderer[`onEnable`]();
        this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(rtFrame, `load`);
        if (multisample > 0) {
          this.rendererPassState.multisample = this.quadShader.getDefaultColorShader().shaderState.multisample;
          this.rendererPassState.multiTexture = webGPUContext.device.createTexture({
            size: {
              width: webGPUContext.presentationSize[0],
              height: webGPUContext.presentationSize[1]
            },
            sampleCount: multisample,
            format: renderTexture.length > 0 ? renderTexture[0].format : webGPUContext.presentationFormat,
            usage: GPUTextureUsage.RENDER_ATTACHMENT
          });
        }
        webGPUContext.addEventListener(CResizeEvent.RESIZE, (e) => {
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(rtFrame, `load`);
          if (multisample > 0) {
            this.rendererPassState.multisample = this.quadShader.getDefaultColorShader().shaderState.multisample;
            this.rendererPassState.multiTexture = webGPUContext.device.createTexture({
              size: {
                width: webGPUContext.presentationSize[0],
                height: webGPUContext.presentationSize[1]
              },
              sampleCount: multisample,
              format: renderTexture.length > 0 ? renderTexture[0].format : webGPUContext.presentationFormat,
              usage: GPUTextureUsage.RENDER_ATTACHMENT
            });
          }
        }, this);
      }
      /**
       * By inputting a map to viewQuad and setting corresponding 
       * processing shaders, the corresponding results are output for off-screen rendering
       * Can also be directly used as the final display rendering result rendering canvas
       * @param viewQuad 
       * @see ViewQuad
       * @param scene3D 
       * @see Scene3D
       * @param command 
       */
      renderTarget(view, viewQuad, command) {
        let camera = view.camera;
        let encoder = GPUContext.beginRenderPass(command, viewQuad.rendererPassState);
        GPUContext.bindCamera(encoder, camera);
        viewQuad.quadRenderer.nodeUpdate(view, PassType.COLOR, viewQuad.rendererPassState, null);
        viewQuad.quadRenderer.renderPass2(view, PassType.COLOR, viewQuad.rendererPassState, null, encoder);
        GPUContext.endPass(encoder);
      }
      /**
       * Output to screen through screen based shading
       * @param viewQuad 
       * @see ViewQuad
       * @param scene3D 
       * @see Scene3D
       * @param command 
       * @param colorTexture 
       */
      renderToViewQuad(view, viewQuad, command, colorTexture) {
        let camera = view.camera;
        viewQuad.quadShader.setTexture("baseMap", colorTexture);
        let encoder = GPUContext.beginRenderPass(command, viewQuad.rendererPassState);
        GPUContext.bindCamera(encoder, camera);
        viewQuad.quadRenderer.nodeUpdate(view, PassType.COLOR, viewQuad.rendererPassState, null);
        viewQuad.quadRenderer.renderPass2(view, PassType.COLOR, viewQuad.rendererPassState, null, encoder);
        GPUContext.endPass(encoder);
      }
    }

    class RTDescriptor {
      storeOp = "store";
      loadOp = `clear`;
      clearValue = [0, 0, 0, 0];
    }

    class RTFrame {
      label;
      customSize = false;
      renderTargets;
      rtDescriptors;
      zPreTexture;
      depthTexture;
      depthViewIndex = 0;
      depthCleanValue = 1;
      depthLoadOp = `clear`;
      isOutTarget = true;
      constructor(attachments, rtDescriptors, depthTexture, zPreTexture, isOutTarget = true) {
        this.renderTargets = attachments;
        this.rtDescriptors = rtDescriptors;
        this.depthTexture = depthTexture;
        this.zPreTexture = zPreTexture;
        this.isOutTarget = isOutTarget;
      }
      clone2Frame(rtFrame) {
        rtFrame.renderTargets.push(...this.renderTargets.concat());
        for (let i = 0; i < this.rtDescriptors.length; i++) {
          const des = this.rtDescriptors[i];
          let rtDes = new RTDescriptor();
          rtDes.loadOp = des.loadOp;
          rtDes.storeOp = des.storeOp;
          rtDes.clearValue = des.clearValue;
          rtFrame.rtDescriptors.push(rtDes);
        }
        rtFrame.depthTexture = this.depthTexture;
        rtFrame.zPreTexture = this.zPreTexture;
        rtFrame.customSize = this.customSize;
      }
      clone() {
        let rtFrame = new RTFrame([], []);
        this.clone2Frame(rtFrame);
        return rtFrame;
      }
    }

    class RenderTexture extends Texture {
      resolveTarget;
      sampleCount;
      autoResize;
      clear;
      /**
       * create virtual texture
       * @param width width of texture
       * @param height height of texture
       * @param format GPUTextureFormat, default value is rgba8unorm
       * @param useMipmap whether or not gen mipmap
       * @returns
       */
      constructor(width, height, format = GPUTextureFormat.rgba8unorm, useMipMap = false, usage, numberLayer = 1, sampleCount = 0, clear = true, autoResize = true) {
        super(width, height, numberLayer);
        this.name = UUID();
        this.autoResize = autoResize;
        this.useMipmap = useMipMap;
        this.sampleCount = sampleCount;
        this.format = format;
        this.numberLayer = numberLayer;
        this.clear = clear;
        if (usage != void 0) {
          this.usage = usage;
        } else {
          this.usage = usage | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
        }
        this.resize(width, height);
        if (autoResize) {
          webGPUContext.addEventListener(CResizeEvent.RESIZE, (e) => {
            let { width: width2, height: height2 } = e.data;
            this.resize(width2, height2);
            this._textureChange = true;
          }, this);
        }
      }
      resize(width, height) {
        let device = webGPUContext.device;
        if (this.gpuTexture) {
          Texture.delayDestroyTexture(this.gpuTexture);
          this.gpuTexture = null;
          this.view = null;
        }
        this.width = width;
        this.height = height;
        this.createTextureDescriptor(width, height, 1, this.format, this.usage, this.numberLayer, this.sampleCount);
        this.useMipmap = false;
        this.visibility = GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
        if (this.format == GPUTextureFormat.rgba32float) {
          this.samplerBindingLayout.type = `non-filtering`;
          this.textureBindingLayout.sampleType = `unfilterable-float`;
          this.gpuSampler = device.createSampler({});
        } else if (this.format == GPUTextureFormat.depth32float) {
          this.samplerBindingLayout.type = `filtering`;
          this.sampler_comparisonBindingLayout.type = `comparison`;
          this.textureBindingLayout.sampleType = `depth`;
          this.gpuSampler = webGPUContext.device.createSampler({});
          this.gpuSampler_comparison = webGPUContext.device.createSampler({
            compare: "less",
            label: "sampler_comparison"
          });
        } else if (this.format == GPUTextureFormat.depth24plus) {
          this.samplerBindingLayout = {
            type: `filtering`
          };
          this.sampler_comparisonBindingLayout = {
            type: "comparison"
          };
          this.textureBindingLayout.sampleType = `depth`;
          this.gpuSampler = webGPUContext.device.createSampler({});
          this.gpuSampler_comparison = webGPUContext.device.createSampler({
            compare: "less",
            label: "sampler_comparison"
          });
        } else {
          this.samplerBindingLayout.type = `filtering`;
          this.textureBindingLayout.sampleType = `float`;
          if (this.sampleCount > 0) {
            this.textureBindingLayout.multisampled = true;
          }
          this.minFilter = "linear";
          this.magFilter = "linear";
          this.mipmapFilter = `linear`;
          this.maxAnisotropy = 16;
          this.addressModeU = GPUAddressMode.clamp_to_edge;
          this.addressModeV = GPUAddressMode.clamp_to_edge;
          this.gpuSampler = device.createSampler(this);
        }
        this._textureChange = true;
      }
      /**
      * create rt texture
      * @param width texture width
      * @param height texture height
      * @param data  texture pixel data
      * @param useMipmap texture use mipmap switch
      * @returns
      */
      create(width, height, useMiamp = true) {
        let device = webGPUContext.device;
        const bytesPerRow = width * 4;
        let td = new Float32Array(width * height * 4);
        const textureDataBuffer = device.createBuffer({
          size: td.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, td);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
      }
      clone() {
        let texture = new RenderTexture(this.width, this.height, this.format, this.useMipmap, this.usage, this.numberLayer, this.sampleCount, this.clear, this.autoResize);
        texture.name = "clone_" + texture.name;
        return texture;
      }
      readTextureToImage() {
        let device = webGPUContext.device;
        let w = webGPUContext.windowWidth;
        let h = webGPUContext.windowHeight;
        let td = new Float32Array(w * h * 4);
        const textureBuffer = device.createBuffer({
          size: td.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyTextureToBuffer(
          {
            texture: this.getGPUTexture()
          },
          {
            buffer: textureBuffer
          },
          [w, h]
        );
        let arryBuffer = textureBuffer.getMappedRange(0, td.byteLength);
        return arryBuffer;
      }
    }

    class RTResourceMap {
      static rtTextureMap;
      static rtViewQuad;
      static init() {
        this.rtTextureMap = /* @__PURE__ */ new Map();
        this.rtViewQuad = /* @__PURE__ */ new Map();
      }
      static createRTTexture(name, rtWidth, rtHeight, format, useMipmap = false, sampleCount = 0) {
        let rt = this.rtTextureMap.get(name);
        if (!rt) {
          if (name == RTResourceConfig.colorBufferTex_NAME) {
            rt = new RenderTexture(rtWidth, rtHeight, format, useMipmap, void 0, 1, sampleCount, false);
          } else {
            rt = new RenderTexture(rtWidth, rtHeight, format, useMipmap, void 0, 1, sampleCount, true);
          }
          rt.name = name;
          RTResourceMap.rtTextureMap.set(name, rt);
        }
        return rt;
      }
      static createRTTextureArray(name, rtWidth, rtHeight, format, length = 1, useMipmap = false, sampleCount = 0) {
        let rt = this.rtTextureMap.get(name);
        if (!rt) {
          rt = new RenderTexture(rtWidth, rtHeight, format, useMipmap, void 0, length, sampleCount);
          rt.name = name;
          RTResourceMap.rtTextureMap.set(name, rt);
        }
        return rt;
      }
      static createViewQuad(name, shaderVS, shaderFS, outRtTexture, multisample = 0) {
        let rtFrame = new RTFrame(
          [
            outRtTexture
          ],
          [
            new RTDescriptor()
          ]
        );
        let viewQuad = new ViewQuad(shaderVS, shaderFS, rtFrame, multisample);
        RTResourceMap.rtViewQuad.set(name, viewQuad);
        return viewQuad;
      }
      static getTexture(name) {
        return this.rtTextureMap.get(name);
      }
      static CreateSplitTexture(id) {
        let colorTex = this.getTexture(RTResourceConfig.colorBufferTex_NAME);
        let tex = this.getTexture(id + "_split");
        if (!tex) {
          tex = this.createRTTexture(id + "_split", colorTex.width, colorTex.height, colorTex.format, false);
        }
        return tex;
      }
      static WriteSplitColorTexture(id) {
        let colorTex = this.getTexture(RTResourceConfig.colorBufferTex_NAME);
        let tex = this.getTexture(id + "_split");
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyTextureToTexture(
          {
            texture: colorTex.getGPUTexture(),
            mipLevel: 0,
            origin: { x: 0, y: 0, z: 0 }
          },
          {
            texture: tex.getGPUTexture(),
            mipLevel: 0,
            origin: { x: 0, y: 0, z: 0 }
          },
          {
            width: tex.width,
            height: tex.height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class RenderContext {
      command;
      encoder;
      rendererPassStates;
      rtFrame;
      constructor(rtFrame) {
        this.rtFrame = rtFrame;
        this.rendererPassStates = [];
      }
      clean() {
        this.rendererPassStates.length = 0;
        GPUContext.cleanCache();
      }
      /**
       * continue renderer pass state
       * @returns 
       */
      beginContinueRendererPassState(color_loadOp = "load", depth_loadOp = "load") {
        if (this.rendererPassStates.length > 0) {
          let splitRtFrame = this.rtFrame.clone();
          for (const iterator of splitRtFrame.rtDescriptors) {
            iterator.loadOp = `load`;
          }
          splitRtFrame.depthLoadOp = depth_loadOp;
          let splitRendererPassState = WebGPUDescriptorCreator.createRendererPassState(splitRtFrame, color_loadOp);
          this.rendererPassStates.push(splitRendererPassState);
          return splitRendererPassState;
        } else {
          this.rtFrame.depthLoadOp = depth_loadOp;
          let splitRendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, color_loadOp);
          this.rendererPassStates.push(splitRendererPassState);
          return splitRendererPassState;
        }
      }
      get rendererPassState() {
        return this.rendererPassStates[this.rendererPassStates.length - 1];
      }
      beginOpaqueRenderPass() {
        this.beginContinueRendererPassState("clear", "clear");
        this.begineNewCommand();
        this.beginNewEncoder();
      }
      beginTransparentRenderPass() {
        this.beginContinueRendererPassState("load", "load");
        this.begineNewCommand();
        this.beginNewEncoder();
      }
      endRenderPass() {
        this.endEncoder();
        this.endCommand();
      }
      begineNewCommand() {
        this.command = GPUContext.beginCommandEncoder();
        return this.command;
      }
      endCommand() {
        GPUContext.endCommandEncoder(this.command);
        this.command = null;
      }
      beginNewEncoder() {
        this.encoder = GPUContext.beginRenderPass(this.command, this.rendererPassState);
        return this.encoder;
      }
      endEncoder() {
        GPUContext.endPass(this.encoder);
        this.encoder = null;
      }
    }

    class RendererBase extends CEventDispatcher {
      rendererPassState;
      splitRendererPassState;
      useRenderBundle = false;
      debugViewQuads;
      debugTextures;
      renderContext;
      _rendererType;
      _rtFrame;
      get passType() {
        return this._rendererType;
      }
      set passType(value) {
        this._rendererType = value;
      }
      constructor() {
        super();
        this.debugTextures = [];
        this.debugViewQuads = [];
      }
      setRenderStates(rtFrame) {
        this._rtFrame = rtFrame;
        if (rtFrame) {
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(rtFrame);
          let splitRtFrame = rtFrame.clone();
          splitRtFrame.depthLoadOp = "load";
          for (const iterator of splitRtFrame.rtDescriptors) {
            iterator.loadOp = `load`;
          }
          this.splitRendererPassState = WebGPUDescriptorCreator.createRendererPassState(splitRtFrame);
        }
        this.renderContext = new RenderContext(rtFrame);
      }
      setIrradiance(probeIrradianceMap, probeDepthMap) {
        this.rendererPassState.irradianceBuffer = [probeIrradianceMap, probeDepthMap];
      }
      compute(view, occlusionSystem) {
      }
      render(view, occlusionSystem, clusterLightingBuffer, maskTr = false) {
        GPUContext.cleanCache();
        let camera = view.camera;
        let scene = view.scene;
        this.rendererPassState.camera3D = camera;
        let collectInfo = EntityCollect.instance.getRenderNodes(scene, camera);
        let op_bundleList = this.renderBundleOp(view, collectInfo, occlusionSystem, clusterLightingBuffer);
        let tr_bundleList = maskTr ? [] : this.renderBundleTr(view, collectInfo, occlusionSystem, clusterLightingBuffer);
        {
          let command = GPUContext.beginCommandEncoder();
          let renderPassEncoder = GPUContext.beginRenderPass(command, this.rendererPassState);
          if (op_bundleList.length > 0) {
            renderPassEncoder.executeBundles(op_bundleList);
          }
          if (!maskTr && EntityCollect.instance.sky) {
            GPUContext.bindCamera(renderPassEncoder, camera);
            EntityCollect.instance.sky.renderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, renderPassEncoder);
          }
          this.drawRenderNodes(view, renderPassEncoder, command, collectInfo.opaqueList, occlusionSystem);
          GPUContext.endPass(renderPassEncoder);
          GPUContext.endCommandEncoder(command);
        }
        {
          let command = GPUContext.beginCommandEncoder();
          let renderPassEncoder = GPUContext.beginRenderPass(command, this.rendererPassState);
          if (tr_bundleList.length > 0) {
            renderPassEncoder.executeBundles(tr_bundleList);
          }
          if (!maskTr) {
            GPUContext.bindCamera(renderPassEncoder, camera);
            this.drawRenderNodes(view, renderPassEncoder, command, collectInfo.transparentList, occlusionSystem);
          }
          GPUContext.endPass(renderPassEncoder);
          GPUContext.endCommandEncoder(command);
        }
      }
      nodeUpload(collectInfo, scene, occlusionSystem) {
      }
      occlusionRenderNodeTest(i, id, occlusionSystem) {
        return occlusionSystem ? occlusionSystem.occlusionRenderNodeTest(i) > 0 : true;
      }
      renderOp(encoder, command, collectInfo, scene, occlusionSystem) {
      }
      renderTr(encoder, command, collectInfo, scene, occlusionSystem) {
      }
      renderBundleOp(view, collectInfo, occlusionSystem, clusterLightingBuffer) {
        let entityBatchCollect = EntityCollect.instance.getOpRenderGroup(view.scene);
        if (entityBatchCollect) {
          let bundlerList = [];
          entityBatchCollect.renderGroup.forEach((v) => {
            if (v.bundleMap.has(this._rendererType)) {
              bundlerList.push(v.bundleMap.get(this._rendererType));
            } else {
              let renderBundleEncoder = GPUContext.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);
              this.recordRenderBundleNode(view, renderBundleEncoder, v.renderNodes, clusterLightingBuffer);
              let newBundle = renderBundleEncoder.finish();
              v.bundleMap.set(this._rendererType, newBundle);
              bundlerList.push(newBundle);
            }
          });
          return bundlerList;
        }
        return [];
      }
      renderBundleTr(view, collectInfo, occlusionSystem, clusterLightingBuffer) {
        let entityBatchCollect = EntityCollect.instance.getTrRenderGroup(view.scene);
        if (entityBatchCollect) {
          let bundlerList = [];
          entityBatchCollect.renderGroup.forEach((v) => {
            if (v.bundleMap.has(this._rendererType)) {
              bundlerList.push(v.bundleMap.get(this._rendererType));
            } else {
              let renderBundleEncoder = GPUContext.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);
              this.recordRenderBundleNode(view, renderBundleEncoder, v.renderNodes, clusterLightingBuffer);
              let newBundle = renderBundleEncoder.finish();
              v.bundleMap.set(this._rendererType, newBundle);
              bundlerList.push(newBundle);
            }
          });
          return bundlerList;
        }
        return [];
      }
      recordRenderBundleNode(view, encoder, nodes, clusterLightingBuffer) {
        GPUContext.bindCamera(encoder, view.camera);
        GPUContext.bindGeometryBuffer(encoder, nodes[0].geometry);
        for (let i = 0; i < nodes.length; ++i) {
          let renderNode = nodes[i];
          renderNode.transform.worldMatrix.index;
          if (!renderNode.transform.enable)
            continue;
          renderNode.recordRenderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, encoder);
        }
      }
      drawRenderNodes(view, encoder, command, nodes, occlusionSystem, clusterLightingBuffer) {
        GPUContext.bindCamera(encoder, view.camera);
        for (let i = Engine3D.setting.render.drawOpMin; i < Math.min(nodes.length, Engine3D.setting.render.drawOpMax); ++i) {
          let renderNode = nodes[i];
          if (!renderNode.transform.enable)
            continue;
          if (!renderNode.enable)
            continue;
          renderNode.renderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, encoder);
        }
      }
      setDebugTexture(textures) {
        for (let i = 0; i < textures.length; i++) {
          let tex = textures[i];
          let vs = "Quad_vert_wgsl";
          let fs = "Quad_frag_wgsl";
          switch (tex.format) {
            case GPUTextureFormat.rgba8sint:
            case GPUTextureFormat.rgba8uint:
            case GPUTextureFormat.rgba8unorm:
            case GPUTextureFormat.rgba16float:
            case GPUTextureFormat.rgba32float:
              fs = `Quad_frag_wgsl`;
              break;
            case GPUTextureFormat.depth24plus:
            case GPUTextureFormat.depth32float:
              fs = `Quad_depth2d_frag_wgsl`;
              if (tex.textureBindingLayout.viewDimension == `cube`) {
                fs = `Quad_depthCube_frag_wgsl`;
              }
              break;
          }
          let viewQuad = new ViewQuad(vs, fs, new RTFrame([], []));
          this.debugTextures.push(textures[i]);
          this.debugViewQuads.push(viewQuad);
        }
      }
    }

    class ColorPassRenderer extends RendererBase {
      constructor() {
        super();
        this.passType = PassType.COLOR;
      }
      render(view, occlusionSystem, clusterLightingBuffer, maskTr = false) {
        this.renderContext.clean();
        let scene = view.scene;
        let camera = view.camera;
        this.rendererPassState.camera3D = camera;
        let collectInfo = EntityCollect.instance.getRenderNodes(scene, camera);
        let op_bundleList = this.renderBundleOp(view, collectInfo, occlusionSystem, clusterLightingBuffer);
        let tr_bundleList = maskTr ? [] : this.renderBundleTr(view, collectInfo, occlusionSystem, clusterLightingBuffer);
        ProfilerUtil.start("colorPass Renderer");
        {
          ProfilerUtil.start("ColorPass Draw Opaque");
          this.renderContext.beginOpaqueRenderPass();
          this.renderContext.command;
          let renderPassEncoder = this.renderContext.encoder;
          GPUContext.bindCamera(renderPassEncoder, camera);
          if (op_bundleList.length > 0) {
            EntityCollect.instance.getOpRenderGroup(scene);
            renderPassEncoder.executeBundles(op_bundleList);
          }
          if (!maskTr && EntityCollect.instance.sky) {
            GPUContext.bindCamera(renderPassEncoder, camera);
            if (!EntityCollect.instance.sky.preInit) {
              EntityCollect.instance.sky.nodeUpdate(view, this._rendererType, this.rendererPassState, clusterLightingBuffer);
            }
            EntityCollect.instance.sky.renderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, renderPassEncoder);
          }
          if (collectInfo.opaqueList) {
            GPUContext.bindCamera(renderPassEncoder, camera);
            this.drawNodes(view, this.renderContext, collectInfo.opaqueList, occlusionSystem, clusterLightingBuffer);
            this.renderContext.endRenderPass();
            ProfilerUtil.end("ColorPass Draw Opaque");
          }
        }
        {
          ProfilerUtil.start("ColorPass Draw Transparent");
          this.renderContext.beginTransparentRenderPass();
          this.renderContext.command;
          let renderPassEncoder = this.renderContext.encoder;
          if (tr_bundleList.length > 0) {
            renderPassEncoder.executeBundles(tr_bundleList);
          }
          if (!maskTr && collectInfo.transparentList) {
            GPUContext.bindCamera(renderPassEncoder, camera);
            this.drawNodes(view, this.renderContext, collectInfo.transparentList, occlusionSystem, clusterLightingBuffer);
          }
          let graphicsList = EntityCollect.instance.getGraphicList();
          for (let i = 0; i < graphicsList.length; i++) {
            const graphic3DRenderNode = graphicsList[i];
            graphic3DRenderNode.transform.worldMatrix.index;
            graphic3DRenderNode.nodeUpdate(view, this._rendererType, this.splitRendererPassState, clusterLightingBuffer);
            graphic3DRenderNode.renderPass2(view, this._rendererType, this.splitRendererPassState, clusterLightingBuffer, renderPassEncoder);
          }
          this.renderContext.endRenderPass();
          ProfilerUtil.end("ColorPass Draw Transparent");
        }
        ProfilerUtil.end("colorPass Renderer");
      }
      drawNodes(view, renderContext, nodes, occlusionSystem, clusterLightingBuffer) {
        let viewRenderList = EntityCollect.instance.getRenderShaderCollect(view);
        if (viewRenderList) {
          for (const renderList of viewRenderList) {
            let nodeMap = renderList[1];
            for (const iterator of nodeMap) {
              let node = iterator[1];
              if (node.preInit) {
                node.nodeUpdate(view, this._rendererType, this.rendererPassState, clusterLightingBuffer);
                break;
              }
            }
          }
          for (let i = Engine3D.setting.render.drawOpMin; i < Math.min(nodes.length, Engine3D.setting.render.drawOpMax); ++i) {
            let renderNode = nodes[i];
            if (!renderNode.transform.enable)
              continue;
            if (!renderNode.enable)
              continue;
            if (!renderNode.preInit) {
              renderNode.nodeUpdate(view, this._rendererType, this.rendererPassState, clusterLightingBuffer);
            }
            renderNode.renderPass(view, this.passType, this.renderContext);
          }
        }
      }
      occlusionRenderNodeTest(i, id, occlusionSystem) {
        return occlusionSystem.zDepthRenderNodeTest(id) > 0;
      }
    }

    class GBufferFrame extends RTFrame {
      static gBufferMap = /* @__PURE__ */ new Map();
      static bufferTexture = false;
      constructor() {
        super([], []);
      }
      crateGBuffer(key, rtWidth, rtHeight) {
        let attachments = this.renderTargets;
        let reDescriptors = this.rtDescriptors;
        let colorBufferTex = RTResourceMap.createRTTexture(key + RTResourceConfig.colorBufferTex_NAME, rtWidth, rtHeight, GPUTextureFormat.rgba16float, false);
        let positionBufferTex = RTResourceMap.createRTTexture(key + RTResourceConfig.positionBufferTex_NAME, rtWidth, rtHeight, GPUTextureFormat.rgba16float, false);
        let normalBufferTex = RTResourceMap.createRTTexture(key + RTResourceConfig.normalBufferTex_NAME, rtWidth, rtHeight, GPUTextureFormat.rgba8unorm, false);
        let materialBufferTex = RTResourceMap.createRTTexture(key + RTResourceConfig.materialBufferTex_NAME, rtWidth, rtHeight, GPUTextureFormat.rgba8unorm, false);
        if (GBufferFrame.bufferTexture) {
          attachments.push(colorBufferTex);
          attachments.push(positionBufferTex);
          attachments.push(normalBufferTex);
          attachments.push(materialBufferTex);
        }
        let colorRTDes = new RTDescriptor();
        colorRTDes.loadOp = `clear`;
        let depthTexture = new RenderTexture(rtWidth, rtHeight, GPUTextureFormat.depth24plus, false);
        depthTexture.name = `depthTexture`;
        let depthDec = new RTDescriptor();
        depthDec.loadOp = `load`;
        this.depthTexture = depthTexture;
        if (GBufferFrame.bufferTexture) {
          reDescriptors.push(colorRTDes);
          reDescriptors.push(new RTDescriptor());
          reDescriptors.push(new RTDescriptor());
          reDescriptors.push(new RTDescriptor());
        }
      }
      getColorMap() {
        return this.renderTargets[0];
      }
      getPositionMap() {
        return this.renderTargets[1];
      }
      getNormalMap() {
        return this.renderTargets[2];
      }
      getMaterialMap() {
        return this.renderTargets[3];
      }
      /**
       * @internal
       */
      static getGBufferFrame(key) {
        let gBuffer;
        if (!GBufferFrame.gBufferMap.has(key)) {
          gBuffer = new GBufferFrame();
          let size = webGPUContext.presentationSize;
          gBuffer.crateGBuffer(key, size[0], size[1]);
          GBufferFrame.gBufferMap.set(key, gBuffer);
        } else {
          gBuffer = GBufferFrame.gBufferMap.get(key);
        }
        return gBuffer;
      }
      clone() {
        let gBufferFrame = new GBufferFrame();
        this.clone2Frame(gBufferFrame);
        return gBufferFrame;
      }
    }

    class OcclusionSystem {
      frustumCullingList;
      zVisibleList;
      _renderList;
      static enable = true;
      constructor() {
        this._renderList = /* @__PURE__ */ new Map();
      }
      /**
       * Get GPU Test Occlusion test
       * @param index
       * @returns
       */
      occlusionRenderNodeTest(index) {
        if (!Engine3D.setting.occlusionQuery.enable)
          return 1;
        if (this.frustumCullingList) {
          return this.frustumCullingList[index];
        } else {
          return 0;
        }
      }
      /**
       * Get GPU Pixel depth visible Test
       * @param index
       * @returns
       */
      zDepthRenderNodeTest(index) {
        if (this.zVisibleList) {
          return this.zVisibleList[index];
        } else {
          return 0;
        }
      }
      update(camera, scene) {
      }
      collect(nodes, camera) {
      }
      renderCommitTesting(camera, renderNode) {
        return true;
      }
    }

    class ComputeGPUBuffer extends GPUBufferBase {
      constructor(size, data) {
        super();
        this.bufferType = GPUBufferType.ComputeGPUBuffer;
        this.createBuffer(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST, size, data, "ComputeGPUBuffer");
      }
    }

    class ClusterLightingBuffer {
      clusterBuffer;
      lightAssignBuffer;
      assignTableBuffer;
      clustersUniformBuffer;
      constructor(numClusters, maxNumLightsPerCluster) {
        this.clusterBuffer = new ComputeGPUBuffer(numClusters * /*two vec4*/
        2 * /*vec4*/
        4);
        this.clustersUniformBuffer = new UniformGPUBuffer(10);
        this.clustersUniformBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
        this.lightAssignBuffer = new ComputeGPUBuffer(numClusters * maxNumLightsPerCluster);
        this.lightAssignBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
        this.assignTableBuffer = new ComputeGPUBuffer(numClusters * 4);
        this.assignTableBuffer.visibility = GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
      }
      update(width, height, clusterPix, clusterTileX, clusterTileY, clusterTileZ, numLights, maxNumLightsPerCluster, near, far) {
        this.clustersUniformBuffer.setFloat("clusterTileX", clusterTileX);
        this.clustersUniformBuffer.setFloat("clusterTileY", clusterTileY);
        this.clustersUniformBuffer.setFloat("clusterTileZ", clusterTileZ);
        this.clustersUniformBuffer.setFloat("numLights", numLights);
        this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster", maxNumLightsPerCluster);
        this.clustersUniformBuffer.setFloat("near", near);
        this.clustersUniformBuffer.setFloat("far", far);
        this.clustersUniformBuffer.setFloat("screenWidth", width);
        this.clustersUniformBuffer.setFloat("screenHeight", height);
        this.clustersUniformBuffer.setFloat("clusterPix", clusterPix);
        this.clustersUniformBuffer.apply();
      }
    }

    class ClusterConfig {
      static clusterTileX = 16;
      static clusterTileY = 16;
      static clusterTileZ = 32;
    }

    let ClusterBoundsSource_cs = (
      /* wgsl */
      `
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
          }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${ClusterConfig.clusterTileX},${ClusterConfig.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`
    );

    let ClusterLighting_cs = (
      /*wgsl*/
      `
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${ClusterConfig.clusterTileX},${ClusterConfig.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`
    );

    class ClusterLightingRender extends RendererBase {
      // public static clusterTileX = 4;
      // public static clusterTileY = 4;
      // public static clusterTileZ = 2;
      maxNumLightsPerCluster = 64;
      clusterPix = 1;
      clusterLightingBuffer;
      _currentLightCount = 0;
      _clusterGenerateCompute;
      _clusterLightingCompute;
      _useCamera;
      resize = false;
      constructor(view) {
        super();
        this.passType = PassType.Cluster;
        this.initCompute(view);
      }
      initCompute(view) {
        this._clusterGenerateCompute = new ComputeShader(ClusterBoundsSource_cs);
        this._clusterLightingCompute = new ComputeShader(ClusterLighting_cs);
        let size = webGPUContext.presentationSize;
        let numClusters = ClusterConfig.clusterTileX * ClusterConfig.clusterTileY * ClusterConfig.clusterTileZ;
        let camera = view.camera;
        let near = camera.near;
        let far = camera.far;
        this.clusterLightingBuffer = new ClusterLightingBuffer(numClusters, this.maxNumLightsPerCluster);
        this.clusterLightingBuffer.update(size[0], size[1], this.clusterPix, ClusterConfig.clusterTileX, ClusterConfig.clusterTileY, ClusterConfig.clusterTileZ, 0, this.maxNumLightsPerCluster, near, far);
        this._clusterGenerateCompute.setUniformBuffer(`clustersUniform`, this.clusterLightingBuffer.clustersUniformBuffer);
        this._clusterGenerateCompute.setStorageBuffer(`clusterBuffer`, this.clusterLightingBuffer.clusterBuffer);
        let lightBuffer = GlobalBindGroup.getLightEntries(view.scene);
        this._clusterLightingCompute.setStorageBuffer(`models`, GlobalBindGroup.modelMatrixBindGroup.matrixBufferDst);
        this._clusterLightingCompute.setUniformBuffer(`clustersUniform`, this.clusterLightingBuffer.clustersUniformBuffer);
        this._clusterLightingCompute.setStorageBuffer(`clusterBuffer`, this.clusterLightingBuffer.clusterBuffer);
        this._clusterLightingCompute.setStorageBuffer(`lightBuffer`, lightBuffer.storageGPUBuffer);
        this._clusterLightingCompute.setStorageBuffer(`lightAssignBuffer`, this.clusterLightingBuffer.lightAssignBuffer);
        this._clusterLightingCompute.setStorageBuffer(`assignTable`, this.clusterLightingBuffer.assignTableBuffer);
        this.resize = true;
      }
      render(view, occlusionSystem) {
        let scene = view.scene;
        let lights = EntityCollect.instance.getLights(scene);
        if (this._useCamera != view.camera) {
          this._useCamera = view.camera;
          let standBindGroup = GlobalBindGroup.getCameraGroup(this._useCamera);
          this._clusterGenerateCompute.setUniformBuffer(`globalUniform`, standBindGroup.uniformGPUBuffer);
          this._clusterLightingCompute.setUniformBuffer(`globalUniform`, standBindGroup.uniformGPUBuffer);
        }
        if (this._currentLightCount != lights.length) {
          this._currentLightCount = lights.length;
          this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights", lights.length);
          this.clusterLightingBuffer.clustersUniformBuffer.apply();
          this._clusterGenerateCompute.workerSizeX = ClusterConfig.clusterTileZ;
          this._clusterLightingCompute.workerSizeX = ClusterConfig.clusterTileZ;
        }
        let size = webGPUContext.presentationSize;
        this.clusterLightingBuffer.update(
          size[0],
          size[1],
          this.clusterPix,
          ClusterConfig.clusterTileX,
          ClusterConfig.clusterTileY,
          ClusterConfig.clusterTileZ,
          lights.length,
          this.maxNumLightsPerCluster,
          view.camera.near,
          view.camera.far
        );
        this.resize = false;
        let command = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(command, [this._clusterGenerateCompute, this._clusterLightingCompute]);
        GPUContext.endCommandEncoder(command);
      }
    }

    class VirtualTexture extends Texture {
      resolveTarget;
      sampleCount;
      // storeOp: string = 'store';
      // loadOp: GPULoadOp = `load`;
      // clearValue: GPUColor = [0, 0, 0, 0];
      clone() {
        let texture = new VirtualTexture(this.width, this.height, this.format, this.useMipmap, this.usage, this.numberLayer, this.sampleCount);
        texture.name = "clone_" + texture.name;
        return texture;
      }
      /**
       * create virtual texture
       * @param width width of texture
       * @param height height of texture
       * @param format GPUTextureFormat, default value is rgba8unorm
       * @param useMipmap whether or not gen mipmap
       * @returns
       */
      constructor(width, height, format = GPUTextureFormat.rgba8unorm, useMipMap = false, usage, numberLayer = 1, sampleCount = 0, clear = true) {
        super(width, height, numberLayer);
        webGPUContext.device;
        this.name = UUID();
        this.useMipmap = useMipMap;
        this.sampleCount = sampleCount;
        this.format = format;
        this.numberLayer = numberLayer;
        if (usage != void 0) {
          this.usage = usage;
        } else {
          this.usage = usage | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
        }
        this.resize(width, height);
      }
      resize(width, height) {
        let device = webGPUContext.device;
        if (this.gpuTexture) {
          Texture.delayDestroyTexture(this.gpuTexture);
          this.gpuTexture = null;
          this.view = null;
        }
        this.width = width;
        this.height = height;
        this.createTextureDescriptor(width, height, 1, this.format, this.usage, this.numberLayer, this.sampleCount);
        this.useMipmap = false;
        this.visibility = GPUShaderStage.COMPUTE | GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
        if (this.format == GPUTextureFormat.rgba32float) {
          this.samplerBindingLayout.type = `non-filtering`;
          this.textureBindingLayout.sampleType = `unfilterable-float`;
          this.gpuSampler = device.createSampler({});
        } else if (this.format == GPUTextureFormat.depth32float) {
          this.samplerBindingLayout.type = `filtering`;
          this.sampler_comparisonBindingLayout.type = `comparison`;
          this.textureBindingLayout.sampleType = `depth`;
          this.gpuSampler = webGPUContext.device.createSampler({});
          this.gpuSampler_comparison = webGPUContext.device.createSampler({
            compare: "less",
            label: "sampler_comparison"
          });
        } else if (this.format == GPUTextureFormat.depth24plus) {
          this.samplerBindingLayout = {
            type: `filtering`
          };
          this.sampler_comparisonBindingLayout = {
            type: "comparison"
          };
          this.textureBindingLayout.sampleType = `depth`;
          this.gpuSampler = webGPUContext.device.createSampler({});
          this.gpuSampler_comparison = webGPUContext.device.createSampler({
            compare: "less",
            label: "sampler_comparison"
          });
        } else {
          this.samplerBindingLayout.type = `filtering`;
          this.textureBindingLayout.sampleType = `float`;
          if (this.sampleCount > 0) {
            this.textureBindingLayout.multisampled = true;
          }
          this.minFilter = "linear";
          this.magFilter = "linear";
          this.mipmapFilter = `linear`;
          this.maxAnisotropy = 16;
          this.addressModeU = GPUAddressMode.clamp_to_edge;
          this.addressModeV = GPUAddressMode.clamp_to_edge;
          this.gpuSampler = device.createSampler(this);
        }
        this._textureChange = true;
      }
      /**
      * create rt texture
      * @param width texture width
      * @param height texture height
      * @param data  texture pixel data
      * @param useMipmap texture use mipmap switch
      * @returns
      */
      create(width, height, useMiamp = true) {
        let device = webGPUContext.device;
        const bytesPerRow = width * 4;
        let td = new Float32Array(width * height * 4);
        const textureDataBuffer = device.createBuffer({
          size: td.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, td);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
      }
      readTextureToImage() {
        let device = webGPUContext.device;
        let w = webGPUContext.windowWidth;
        let h = webGPUContext.windowHeight;
        let td = new Float32Array(w * h * 4);
        const textureBuffer = device.createBuffer({
          size: td.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyTextureToBuffer(
          {
            texture: this.getGPUTexture()
          },
          {
            buffer: textureBuffer
          },
          [w, h]
        );
        let arryBuffer = textureBuffer.getMappedRange(0, td.byteLength);
        return arryBuffer;
      }
    }

    class PointShadowCubeCamera extends exports.Object3D {
      up_camera;
      down_camera;
      left_camera;
      right_camera;
      front_camera;
      back_camera;
      set label(v) {
        this.up_camera.name = v + "up";
        this.down_camera.name = v + "down";
        this.left_camera.name = v + "left";
        this.right_camera.name = v + "right";
        this.front_camera.name = v + "front";
        this.back_camera.name = v + "back";
      }
      /**
       *
       * @constructor
       * @param near distance from origin to near plane of frustum
       * @param far distance from origin to far plane of frustum
       */
      constructor(near = 1e-3, far = 1e4, fov = 90, isShadow = false) {
        super();
        this.initCubeCamera(near, far, fov, isShadow);
      }
      initCubeCamera(near, far, fov = 90, isShadow = false) {
        this.up_camera = CameraUtil.createCamera3DObject(this, "up");
        this.down_camera = CameraUtil.createCamera3DObject(this, "down");
        this.left_camera = CameraUtil.createCamera3DObject(this, "left");
        this.right_camera = CameraUtil.createCamera3DObject(this, "right");
        this.front_camera = CameraUtil.createCamera3DObject(this, "front");
        this.back_camera = CameraUtil.createCamera3DObject(this, "back");
        this.up_camera.isShadowCamera = isShadow;
        this.down_camera.isShadowCamera = isShadow;
        this.left_camera.isShadowCamera = isShadow;
        this.right_camera.isShadowCamera = isShadow;
        this.front_camera.isShadowCamera = isShadow;
        this.back_camera.isShadowCamera = isShadow;
        let aspect = 1;
        this.up_camera.perspective(fov, aspect, near, far);
        this.up_camera.lookAt(Vector3.ZERO, Vector3.UP, Vector3.DOWN);
        this.up_camera.object3D.scaleX = -1;
        this.up_camera.object3D.rotationY = 180;
        this.down_camera.perspective(fov, aspect, near, far);
        this.down_camera.lookAt(Vector3.ZERO, Vector3.DOWN, Vector3.DOWN);
        this.down_camera.object3D.scaleX = -1;
        this.down_camera.object3D.rotationY = 180;
        this.left_camera.perspective(fov, aspect, near, far);
        this.left_camera.lookAt(Vector3.ZERO, Vector3.LEFT);
        this.left_camera.object3D.scaleX = -1;
        this.right_camera.perspective(fov, aspect, near, far);
        this.right_camera.lookAt(Vector3.ZERO, Vector3.RIGHT);
        this.right_camera.object3D.scaleX = -1;
        this.front_camera.perspective(fov, aspect, near, far);
        this.front_camera.lookAt(Vector3.ZERO, Vector3.FORWARD);
        this.front_camera.object3D.scaleX = -1;
        this.back_camera.perspective(fov, aspect, near, far);
        this.back_camera.lookAt(Vector3.ZERO, Vector3.BACK);
        this.back_camera.object3D.scaleX = -1;
        this.up_camera.type = CameraType.shadow;
        this.down_camera.type = CameraType.shadow;
        this.left_camera.type = CameraType.shadow;
        this.right_camera.type = CameraType.shadow;
        this.front_camera.type = CameraType.shadow;
        this.back_camera.type = CameraType.shadow;
      }
    }

    class DepthCubeArrayTexture extends Texture {
      /**
       * @constructor
       */
      constructor(width, height, numberLayer) {
        super(width, height, numberLayer);
        this.format = GPUTextureFormat.depth32float;
        this.mipmapCount = 1;
        this.init();
      }
      internalCreateBindingLayoutDesc() {
        this.textureBindingLayout.sampleType = `depth`;
        this.textureBindingLayout.viewDimension = `cube-array`;
        this.samplerBindingLayout.type = `filtering`;
        this.sampler_comparisonBindingLayout.type = `comparison`;
      }
      internalCreateTexture() {
        this.textureDescriptor = {
          format: this.format,
          size: { width: this.width, height: this.height, depthOrArrayLayers: 6 * this.numberLayer },
          dimension: "2d",
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING
        };
        this.gpuTexture = this.getGPUTexture();
      }
      internalCreateView() {
        this.viewDescriptor = {
          dimension: `cube-array`
        };
        this.view = this.getGPUView();
      }
      internalCreateSampler() {
        this.gpuSampler = webGPUContext.device.createSampler({
          minFilter: GPUFilterMode.linear,
          magFilter: GPUFilterMode.linear
        });
        this.gpuSampler_comparison = webGPUContext.device.createSampler({
          compare: "less",
          label: "sampler_comparison"
        });
      }
    }

    class PointLightShadowRenderer extends RendererBase {
      shadowPassCount;
      _forceUpdate = false;
      _shadowCameraDic;
      shadowCamera;
      cubeArrayTexture;
      colorTexture;
      shadowSize = 1024;
      constructor() {
        super();
        this.passType = PassType.POINT_SHADOW;
        this._shadowCameraDic = /* @__PURE__ */ new Map();
        this.cubeArrayTexture = new DepthCubeArrayTexture(this.shadowSize, this.shadowSize, 8);
        this.colorTexture = new VirtualTexture(this.shadowSize, this.shadowSize, GPUTextureFormat.bgra8unorm, false);
        Reference.getInstance().attached(this.cubeArrayTexture, this);
      }
      getShadowCamera(view, lightBase) {
        let cubeShadowMapInfo;
        if (this._shadowCameraDic.has(lightBase)) {
          cubeShadowMapInfo = this._shadowCameraDic.get(lightBase);
        } else {
          let camera = new PointShadowCubeCamera(view.camera.near, view.camera.far, 90, true);
          camera.label = lightBase.name;
          let depths = [];
          let rendererPassStates = [];
          for (let i = 0; i < 6; i++) {
            let depthTexture = new VirtualTexture(this.shadowSize, this.shadowSize, this.cubeArrayTexture.format, false);
            let rtFrame = new RTFrame([this.colorTexture], [new RTDescriptor()]);
            depthTexture.name = `shadowDepthTexture_` + lightBase.name + i + "_face";
            rtFrame.depthTexture = depthTexture;
            rtFrame.label = "shadowRender";
            rtFrame.customSize = true;
            let rendererPassState = WebGPUDescriptorCreator.createRendererPassState(rtFrame);
            rendererPassStates[i] = rendererPassState;
            depths[i] = depthTexture;
            Engine3D.getRenderJob(view).postRenderer?.setDebugTexture([depthTexture]);
          }
          cubeShadowMapInfo = {
            cubeCamera: camera,
            depthTexture: depths,
            rendererPassState: rendererPassStates
          };
          this._shadowCameraDic.set(lightBase, cubeShadowMapInfo);
        }
        return cubeShadowMapInfo;
      }
      render(view, occlusionSystem) {
        if (!Engine3D.setting.shadow.enable)
          return;
        this.shadowPassCount = 0;
        view.camera;
        let scene = view.scene;
        let shadowLight = ShadowLightsCollect.getPointShadowLightWhichScene(scene);
        let shadowLightCount = shadowLight.length;
        for (let si = 0; si < shadowLightCount; si++) {
          let light = shadowLight[si];
          if (light.lightData.lightType == LightType.DirectionLight)
            continue;
          if (light.lightData.castShadowIndex > -1 && (light.needUpdateShadow || this._forceUpdate || Time.frame < 5 || light.realTimeShadow)) {
            light.needUpdateShadow = false;
            let cubeShadowMapInfo = this.getShadowCamera(view, light);
            let worldPos = light.transform.worldPosition;
            cubeShadowMapInfo.cubeCamera.x = worldPos.x;
            cubeShadowMapInfo.cubeCamera.y = worldPos.y;
            cubeShadowMapInfo.cubeCamera.z = worldPos.z;
            let collectInfo;
            cubeShadowMapInfo.cubeCamera.transform.updateWorldMatrix(true);
            {
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.right_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.right_camera);
              this.renderSceneOnce(0, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.right_camera, collectInfo, occlusionSystem);
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.left_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.left_camera);
              this.renderSceneOnce(1, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.left_camera, collectInfo, occlusionSystem);
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.up_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.up_camera);
              this.renderSceneOnce(2, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.up_camera, collectInfo, occlusionSystem);
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.down_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.down_camera);
              this.renderSceneOnce(3, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.down_camera, collectInfo, occlusionSystem);
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.front_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.front_camera);
              this.renderSceneOnce(4, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.front_camera, collectInfo, occlusionSystem);
              occlusionSystem.update(cubeShadowMapInfo.cubeCamera.back_camera, scene);
              collectInfo = EntityCollect.instance.getRenderNodes(scene, cubeShadowMapInfo.cubeCamera.back_camera);
              this.renderSceneOnce(5, cubeShadowMapInfo, view, cubeShadowMapInfo.cubeCamera.back_camera, collectInfo, occlusionSystem);
            }
            let qCommand = GPUContext.beginCommandEncoder();
            for (let i = 0; i < 6; i++) {
              qCommand.copyTextureToTexture(
                {
                  texture: cubeShadowMapInfo.depthTexture[i].getGPUTexture(),
                  mipLevel: 0,
                  origin: { x: 0, y: 0, z: 0 }
                },
                {
                  texture: this.cubeArrayTexture.getGPUTexture(),
                  mipLevel: 0,
                  origin: { x: 0, y: 0, z: light.shadowIndex * 6 + i }
                },
                {
                  width: this.shadowSize,
                  height: this.shadowSize,
                  depthOrArrayLayers: 1
                }
              );
            }
            GPUContext.endCommandEncoder(qCommand);
          }
        }
        this._forceUpdate = false;
      }
      renderSceneOnce(face, cubeShadowMapInfo, view, shadowCamera, collectInfo, occlusionSystem) {
        this.rendererPassState = cubeShadowMapInfo.rendererPassState[face];
        let command = GPUContext.beginCommandEncoder();
        let encoder = GPUContext.beginRenderPass(command, this.rendererPassState);
        encoder.setViewport(0, 0, this.shadowSize, this.shadowSize, 0, 1);
        encoder.setScissorRect(0, 0, this.shadowSize, this.shadowSize);
        shadowCamera.onUpdate();
        shadowCamera.transform.updateWorldMatrix(true);
        let viewRenderList = EntityCollect.instance.getRenderShaderCollect(view);
        for (const renderList of viewRenderList) {
          let nodeMap = renderList[1];
          for (const iterator of nodeMap) {
            let node = iterator[1];
            if (node.preInit) {
              node.nodeUpdate(view, this._rendererType, this.rendererPassState, null);
              break;
            }
          }
        }
        this.drawShadowRenderNodes(view, shadowCamera, encoder, collectInfo.opaqueList, occlusionSystem);
        this.drawShadowRenderNodes(view, shadowCamera, encoder, collectInfo.transparentList, occlusionSystem);
        GPUContext.endPass(encoder);
        GPUContext.endCommandEncoder(command);
      }
      drawShadowRenderNodes(view, shadowCamera, encoder, nodes, occlusionSystem) {
        GPUContext.bindCamera(encoder, shadowCamera);
        if (nodes) {
          for (let i = Engine3D.setting.render.drawOpMin; i < Math.min(nodes.length, Engine3D.setting.render.drawOpMax); ++i) {
            let renderNode = nodes[i];
            renderNode.transform.worldMatrix.index;
            if (!renderNode.transform.enable)
              continue;
            if (!renderNode.enable)
              continue;
            if (!renderNode.preInit) {
              renderNode.nodeUpdate(view, this._rendererType, this.rendererPassState);
            }
            for (let material of renderNode.materials) {
              let passes = material.getPass(this._rendererType);
              if (!passes || passes.length == 0)
                continue;
              GPUContext.bindGeometryBuffer(encoder, renderNode.geometry);
              let worldMatrix = renderNode.object3D.transform._worldMatrix;
              for (let pass of passes) {
                const renderShader = pass;
                if (renderShader.pipeline) {
                  renderShader.setUniformFloat("cameraFar", shadowCamera.far);
                  renderShader.setUniformVector3("lightWorldPos", shadowCamera.transform.worldPosition);
                  renderShader.materialDataUniformBuffer.apply();
                  GPUContext.bindPipeline(encoder, renderShader);
                  let subGeometries = renderNode.geometry.subGeometries;
                  for (const subGeometry of subGeometries) {
                    let lodInfos = subGeometry.lodLevels;
                    let lodInfo = lodInfos[renderNode.lodLevel];
                    GPUContext.drawIndexed(encoder, lodInfo.indexCount, 1, lodInfo.indexStart, 0, worldMatrix.index);
                  }
                }
              }
            }
          }
        }
      }
    }

    class Depth2DTextureArray extends Texture {
      /**
       * @constructor
       * @width texture width (pixel)
       * @width texture height (pixel)
       * @width texture format, default value is depth32float
       */
      constructor(width, height, format = GPUTextureFormat.depth32float, numberLayer = 4) {
        super(width, height, numberLayer);
        this.format = format;
        this.mipmapCount = 1;
        this.init();
      }
      internalCreateBindingLayoutDesc() {
        this.textureBindingLayout.sampleType = `depth`;
        this.textureBindingLayout.viewDimension = `2d-array`;
        this.samplerBindingLayout.type = `filtering`;
        this.sampler_comparisonBindingLayout.type = `comparison`;
      }
      internalCreateTexture() {
        this.textureDescriptor = {
          format: this.format,
          size: { width: this.width, height: this.height, depthOrArrayLayers: this.numberLayer },
          dimension: "2d",
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING
        };
        this.gpuTexture = this.getGPUTexture();
      }
      internalCreateView() {
        this.viewDescriptor = {
          dimension: `2d-array`
        };
        this.view = this.getGPUView();
      }
      internalCreateSampler() {
        this.gpuSampler = webGPUContext.device.createSampler({});
        this.gpuSampler_comparison = webGPUContext.device.createSampler({
          compare: "less",
          label: "sampler_comparison"
        });
      }
    }

    class ShadowMapPassRenderer extends RendererBase {
      shadowPassCount;
      depth2DArrayTexture;
      rendererPassStates;
      _forceUpdate = false;
      constructor() {
        super();
        this.setShadowMap(Engine3D.setting.shadow.shadowSize, CSM.Cascades);
        this.passType = PassType.SHADOW;
      }
      setShadowMap(size, cascades) {
        this.rendererPassStates = [];
        this.depth2DArrayTexture = new Depth2DTextureArray(size, size, GPUTextureFormat.depth32float, 8);
        Reference.getInstance().attached(this.depth2DArrayTexture, this);
        for (let i = 0; i < 8; i++) {
          let rtFrame = new RTFrame([], []);
          const tex = new VirtualTexture(size, size, GPUTextureFormat.depth32float, false);
          tex.name = `shadowDepthTexture_${i}`;
          rtFrame.depthTexture = tex;
          rtFrame.label = "shadowRender";
          rtFrame.customSize = true;
          rtFrame.depthCleanValue = 1;
          let rendererPassState = WebGPUDescriptorCreator.createRendererPassState(rtFrame);
          this.rendererPassStates[i] = rendererPassState;
        }
      }
      render(view, occlusionSystem) {
        let shadowSetting = Engine3D.setting.shadow;
        if (!shadowSetting.enable)
          return;
        let camera = view.camera;
        let scene = view.scene;
        this.shadowPassCount = 0;
        if (!shadowSetting.needUpdate)
          return;
        if (!(Time.frame % shadowSetting.updateFrameRate == 0))
          return;
        let shadowLightList = ShadowLightsCollect.getDirectShadowLightWhichScene(scene);
        let shadowSize = shadowSetting.shadowSize;
        const cascades = CSM.Cascades;
        for (let light of shadowLightList) {
          const dirLight = light;
          let shadowIndex = dirLight.shadowIndex;
          this.rendererPassState = this.rendererPassStates[shadowIndex];
          shadowSize = this.rendererPassState.depthTexture.width;
          let viewRenderList = EntityCollect.instance.getRenderShaderCollect(view);
          for (const renderList of viewRenderList) {
            let nodeMap = renderList[1];
            for (const iterator of nodeMap) {
              let node = iterator[1];
              if (node.preInit) {
                node.nodeUpdate(view, this._rendererType, this.rendererPassState, null);
                break;
              }
            }
          }
          if (dirLight.castShadow && dirLight.needUpdateShadow || this._forceUpdate || dirLight.castShadow && shadowSetting.autoUpdate) {
            dirLight.needUpdateShadow = false;
            if (camera.enableCSM && shadowIndex == 0) {
              for (let csmIndex = 0; csmIndex < cascades; csmIndex++) {
                this.rendererPassState = this.rendererPassStates[csmIndex];
                let csmChild = camera.csm.children[csmIndex];
                let extents = camera.getCSMShadowWorldExtents(csmIndex);
                this.poseShadowCamera(camera, dirLight.direction, csmChild.shadowCamera, extents, csmChild.bound.center);
                this.renderShadow(view, csmChild.shadowCamera, occlusionSystem, this.rendererPassState);
                this.copyDepthTexture(this.rendererPassState.depthTexture, this.depth2DArrayTexture, csmIndex, shadowSize);
              }
            } else {
              if (camera.enableCSM) {
                shadowIndex += cascades - 1;
              }
              let extents = camera.getShadowWorldExtents();
              this.rendererPassState = this.rendererPassStates[shadowIndex];
              this.poseShadowCamera(camera, dirLight.direction, dirLight.shadowCamera, extents, camera.lookTarget);
              this.renderShadow(view, dirLight.shadowCamera, occlusionSystem, this.rendererPassState);
              this.copyDepthTexture(this.rendererPassState.depthTexture, this.depth2DArrayTexture, shadowIndex, shadowSize);
            }
          }
        }
        this._forceUpdate = false;
      }
      copyDepthTexture(src, dst, dstIndex, shadowSize) {
        let qCommand = GPUContext.beginCommandEncoder();
        qCommand.copyTextureToTexture(
          {
            texture: src.getGPUTexture(),
            mipLevel: 0,
            origin: { x: 0, y: 0, z: 0 }
          },
          {
            texture: dst.getGPUTexture(),
            mipLevel: 0,
            origin: { x: 0, y: 0, z: dstIndex }
          },
          {
            width: shadowSize,
            height: shadowSize,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(qCommand);
      }
      _shadowPos = new Vector3();
      _shadowCameraTarget = new Vector3();
      poseShadowCamera(viewCamera, direction, shadowCamera, extents, lookAt) {
        this._shadowPos.copy(direction).normalize(viewCamera.far);
        lookAt.add(this._shadowPos, this._shadowCameraTarget);
        lookAt.subtract(this._shadowPos, this._shadowPos);
        shadowCamera.transform.lookAt(this._shadowPos, this._shadowCameraTarget);
        shadowCamera.orthoOffCenter(-extents, extents, -extents, extents, viewCamera.near, viewCamera.far * 2);
      }
      compute() {
      }
      renderShadow(view, shadowCamera, occlusionSystem, state) {
        let collectInfo = EntityCollect.instance.getRenderNodes(view.scene, shadowCamera);
        let command = GPUContext.beginCommandEncoder();
        let encoder = GPUContext.beginRenderPass(command, state);
        shadowCamera.transform.updateWorldMatrix();
        if (OcclusionSystem.enable) {
          occlusionSystem.update(shadowCamera, view.scene);
          occlusionSystem.collect(collectInfo, shadowCamera);
        }
        GPUContext.bindCamera(encoder, shadowCamera);
        let op_bundleList = this.renderShadowBundleOp(view, shadowCamera, state);
        let tr_bundleList = this.renderShadowBundleTr(view, shadowCamera, state);
        if (op_bundleList.length > 0) {
          encoder.executeBundles(op_bundleList);
        }
        this.drawShadowRenderNodes(view, shadowCamera, encoder, collectInfo.opaqueList);
        if (tr_bundleList.length > 0) {
          encoder.executeBundles(tr_bundleList);
        }
        this.drawShadowRenderNodes(view, shadowCamera, encoder, collectInfo.transparentList);
        GPUContext.endPass(encoder);
        GPUContext.endCommandEncoder(command);
      }
      renderShadowBundleOp(view, shadowCamera, state) {
        let entityBatchCollect = EntityCollect.instance.getOpRenderGroup(view.scene);
        if (entityBatchCollect) {
          let bundlerList = [];
          entityBatchCollect.renderGroup.forEach((v) => {
            if (v.bundleMap.has(this._rendererType)) {
              bundlerList.push(v.bundleMap.get(this._rendererType));
            } else {
              let renderBundleEncoder = GPUContext.recordBundleEncoder(state.renderBundleEncoderDescriptor);
              this.recordShadowRenderBundleNode(view, shadowCamera, renderBundleEncoder, v.renderNodes);
              let newBundle = renderBundleEncoder.finish();
              v.bundleMap.set(this._rendererType, newBundle);
              bundlerList.push(newBundle);
            }
          });
          return bundlerList;
        }
        return [];
      }
      renderShadowBundleTr(view, shadowCamera, state) {
        let entityBatchCollect = EntityCollect.instance.getTrRenderGroup(view.scene);
        if (entityBatchCollect) {
          let bundlerList = [];
          entityBatchCollect.renderGroup.forEach((v) => {
            if (v.bundleMap.has(this._rendererType)) {
              bundlerList.push(v.bundleMap.get(this._rendererType));
            } else {
              let renderBundleEncoder = GPUContext.recordBundleEncoder(state.renderBundleEncoderDescriptor);
              this.recordShadowRenderBundleNode(view, shadowCamera, renderBundleEncoder, v.renderNodes);
              let newBundle = renderBundleEncoder.finish();
              v.bundleMap.set(this._rendererType, newBundle);
              bundlerList.push(newBundle);
            }
          });
          return bundlerList;
        }
        return [];
      }
      recordShadowRenderBundleNode(view, shadowCamera, encoder, nodes, clusterLightingBuffer) {
        GPUContext.bindCamera(encoder, shadowCamera);
        if (nodes) {
          GPUContext.bindGeometryBuffer(encoder, nodes[0].geometry);
          for (let i = 0; i < nodes.length; ++i) {
            let renderNode = nodes[i];
            if (!renderNode.transform.enable)
              continue;
            renderNode.recordRenderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, encoder);
          }
        }
      }
      drawShadowRenderNodes(view, shadowCamera, encoder, nodes, clusterLightingBuffer) {
        GPUContext.bindCamera(encoder, shadowCamera);
        if (nodes) {
          for (let i = Engine3D.setting.render.drawOpMin; i < Math.min(nodes.length, Engine3D.setting.render.drawOpMax); ++i) {
            let renderNode = nodes[i];
            if (!renderNode.transform.enable)
              continue;
            if (!renderNode.enable)
              continue;
            if (!renderNode.castShadow) {
              continue;
            }
            renderNode.renderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, encoder);
          }
        }
      }
    }

    class PreDepthPassRenderer extends RendererBase {
      zBufferTexture;
      useRenderBundle = false;
      shadowPassCount;
      zCullingCompute;
      constructor() {
        super();
        this.passType = PassType.DEPTH;
        let size = webGPUContext.presentationSize;
        let scale = 1;
        this.zBufferTexture = RTResourceMap.createRTTexture(RTResourceConfig.zBufferTexture_NAME, Math.floor(size[0] * scale), Math.floor(size[1] * scale), GPUTextureFormat.rgba16float, false);
        let rtDec = new RTDescriptor();
        rtDec.clearValue = [0, 0, 0, 0];
        rtDec.loadOp = `clear`;
        let rtFrame = new RTFrame(
          [],
          [
            // new RTDescriptor()
          ],
          RTResourceMap.createRTTexture(RTResourceConfig.zPreDepthTexture_NAME, Math.floor(size[0]), Math.floor(size[1]), GPUTextureFormat.depth32float, false),
          null,
          false
        );
        this.setRenderStates(rtFrame);
      }
      render(view, occlusionSystem) {
        let camera = view.camera;
        let scene = view.scene;
        GPUContext.cleanCache();
        ProfilerUtil.start("DepthPass Renderer");
        let scene3D = scene;
        this.rendererPassState.camera3D = camera;
        let collectInfo = EntityCollect.instance.getRenderNodes(scene3D, camera);
        this.compute(view, occlusionSystem);
        let op_bundleList = this.renderBundleOp(view, collectInfo, occlusionSystem);
        let tr_bundleList = [] ;
        let command = GPUContext.beginCommandEncoder();
        let encoder = GPUContext.beginRenderPass(command, this.rendererPassState);
        if (op_bundleList.length > 0) {
          encoder.executeBundles(op_bundleList);
        }
        let viewRenderList = EntityCollect.instance.getRenderShaderCollect(view);
        for (const renderList of viewRenderList) {
          let nodeMap = renderList[1];
          for (const iterator of nodeMap) {
            let node = iterator[1];
            if (node.preInit) {
              node.nodeUpdate(view, this._rendererType, this.rendererPassState, null);
              break;
            }
          }
        }
        this.drawRenderNodes(view, encoder, command, collectInfo.opaqueList, occlusionSystem);
        if (tr_bundleList.length > 0) {
          encoder.executeBundles(tr_bundleList);
        }
        GPUContext.endPass(encoder);
        GPUContext.endCommandEncoder(command);
        ProfilerUtil.end("DepthPass Renderer");
      }
      drawRenderNodes(view, encoder, command, nodes, occlusionSystem, clusterLightingBuffer) {
        GPUContext.bindCamera(encoder, view.camera);
        for (let i = Engine3D.setting.render.drawOpMin; i < Math.min(nodes.length, Engine3D.setting.render.drawOpMax); ++i) {
          let renderNode = nodes[i];
          if (!renderNode.transform.enable)
            continue;
          if (!renderNode.enable)
            continue;
          if (!renderNode.preInit) {
            renderNode.nodeUpdate(view, this._rendererType, this.rendererPassState);
          }
          renderNode.renderPass2(view, this._rendererType, this.rendererPassState, clusterLightingBuffer, encoder);
        }
      }
    }

    class RendererMap {
      map;
      passRendererList;
      constructor() {
        this.map = /* @__PURE__ */ new Map();
        this.passRendererList = [];
      }
      addRenderer(renderer) {
        if (!this.map.has(renderer.passType)) {
          this.map.set(renderer.passType, renderer);
          if (renderer.passType <= 1 << 3) {
            this.addPassRenderer(renderer);
          }
        } else {
          console.error("same renderer pass repeat!");
        }
      }
      getRenderer(passType) {
        return this.map.get(passType);
      }
      addPassRenderer(renderer) {
        this.passRendererList.push(renderer);
      }
      getAllRenderer() {
        return this.map;
      }
      getAllPassRenderer() {
        return this.passRendererList;
      }
    }

    class PostRenderer extends RendererBase {
      finalQuadView;
      postList;
      constructor() {
        super();
        this._rendererType = PassType.POST;
        this.postList = [];
        this.initRenderer();
      }
      initRenderer() {
        ShaderLib.register("FullQuad_vert_wgsl", FullQuad_vert_wgsl);
        this.finalQuadView = new ViewQuad(`Quad_vert_wgsl`, `Quad_frag_wgsl`, new RTFrame([], []), 0, false);
      }
      attachPost(view, post) {
        post.postRenderer = this;
        let has = this.postList.indexOf(post) != -1;
        if (!has) {
          this.postList.push(post);
          post.onAttach(view);
        }
      }
      detachPost(view, post) {
        let index = this.postList.indexOf(post);
        if (index >= 0) {
          this.postList.splice(index, 1);
          post.onDetach(view);
          post.postRenderer = null;
        }
        return index >= 0;
      }
      render(view) {
        let command = GPUContext.beginCommandEncoder();
        for (let i = 0; i < this.postList.length; i++) {
          const post = this.postList[i];
          if (!post.enable)
            continue;
          post.render(view, command);
        }
        let lastTexture = GPUContext.lastRenderPassState.getLastRenderTexture();
        this.finalQuadView.renderToViewQuad(view, this.finalQuadView, command, lastTexture);
        {
          if (this.debugViewQuads.length) {
            let debugIndex = Engine3D.setting.render.debugQuad;
            if (debugIndex >= 0)
              this.debugViewQuads[debugIndex].renderToViewQuad(view, this.debugViewQuads[debugIndex], command, this.debugTextures[debugIndex]);
          }
        }
        GPUContext.endCommandEncoder(command);
      }
    }

    class PostBase {
      enable = true;
      postRenderer;
      rtViewQuad;
      virtualTexture;
      constructor() {
        this.rtViewQuad = /* @__PURE__ */ new Map();
        this.virtualTexture = /* @__PURE__ */ new Map();
        webGPUContext.addEventListener(CResizeEvent.RESIZE, this.onResize, this);
      }
      createRTTexture(name, rtWidth, rtHeight, format, useMipmap = false, sampleCount = 0) {
        let rt = RTResourceMap.createRTTexture(name, rtWidth, rtHeight, format, useMipmap, sampleCount);
        rt.name = name;
        this.virtualTexture.set(name, rt);
        Reference.getInstance().attached(rt, this);
        return rt;
      }
      createViewQuad(name, shaderName, outRtTexture, msaa = 0) {
        let viewQuad = RTResourceMap.createViewQuad(name, "Quad_vert_wgsl", shaderName, outRtTexture, msaa);
        this.rtViewQuad.set(name, viewQuad);
        return viewQuad;
      }
      getOutTexture() {
        let colorTexture;
        let renderTargets = GPUContext.lastRenderPassState.renderTargets;
        if (renderTargets.length > 0) {
          colorTexture = renderTargets[0];
        } else {
          colorTexture = RTResourceMap.getTexture(RTResourceConfig.colorBufferTex_NAME);
        }
        return colorTexture;
      }
      autoSetColorTexture(name, compute) {
        let input = this.getOutTexture();
        compute.setSamplerTexture(name, input);
      }
      /**
       * @internal
       */
      compute(view) {
      }
      /**
       * @internal
       */
      onAttach(view) {
      }
      /**
       * @internal
       */
      onDetach(view) {
      }
      onResize() {
      }
      /**
       * @internal
       */
      render(view, command) {
        this.compute(view);
        this.rtViewQuad.forEach((viewQuad, k) => {
          let lastTexture = GPUContext.lastRenderPassState.getLastRenderTexture();
          viewQuad.renderToViewQuad(view, viewQuad, command, lastTexture);
        });
      }
      destroy(force) {
        this.postRenderer = null;
        for (let i = 0; i < this.rtViewQuad.size; i++) {
          const quad = this.rtViewQuad.values[i];
          quad.destroy(force);
        }
        this.rtViewQuad.clear();
        this.rtViewQuad = null;
        for (let i = 0; i < this.virtualTexture.size; i++) {
          const tex = this.virtualTexture.values[i];
          Reference.getInstance().detached(tex, this);
          tex.destroy(force);
        }
      }
    }

    class RendererJob {
      /**
       * @internal
       */
      rendererMap;
      /**
       * @internal
       */
      shadowMapPassRenderer;
      /**
       * @internal
       */
      pointLightShadowRenderer;
      /**
       * @internal
       */
      ddgiProbeRenderer;
      /**
       * @internal
       */
      postRenderer;
      /**
       * @internal
       */
      clusterLightingRender;
      /**
       * @internal
       */
      occlusionSystem;
      /**
       * @internal
       */
      depthPassRenderer;
      /**
         * @internal
         */
      colorPassRenderer;
      /**
       * @internal
       */
      pauseRender = false;
      pickFire;
      renderState = false;
      _view;
      /**
       * Create a renderer task class
       * @param scene Scene3D {@link Scene3D}
       */
      constructor(view) {
        this._view = view;
        this.rendererMap = new RendererMap();
        this.occlusionSystem = new OcclusionSystem();
        this.clusterLightingRender = this.addRenderer(ClusterLightingRender, view);
        if (Engine3D.setting.render.zPrePass) {
          this.depthPassRenderer = this.addRenderer(PreDepthPassRenderer);
        }
        this.shadowMapPassRenderer = new ShadowMapPassRenderer();
        this.pointLightShadowRenderer = new PointLightShadowRenderer();
      }
      addRenderer(c, param) {
        let renderer;
        if (param) {
          renderer = new c(param);
        } else {
          renderer = new c();
        }
        this.rendererMap.addRenderer(renderer);
        return renderer;
      }
      /**
       * @internal
       */
      get view() {
        return this._view;
      }
      set view(view) {
        this._view = view;
      }
      /**
       * start render task
       */
      start() {
        this.renderState = true;
      }
      // public get guiCanvas(): UICanvas {
      //     return this._canvas;
      // }
      /**
       * stop render task
       */
      stop() {
      }
      /**
       * pause render task
       */
      pause() {
        this.pauseRender = true;
      }
      /**
       * back render task
       */
      resume() {
        this.pauseRender = false;
      }
      /** 
       * @internal
       */
      enablePost(gbufferFrame) {
        this.postRenderer = this.addRenderer(PostRenderer);
        this.postRenderer.setRenderStates(gbufferFrame);
      }
      /**
       * Add a post processing special effects task
       * @param post
       */
      addPost(post) {
        if (!this.postRenderer) {
          GBufferFrame.bufferTexture = true;
          this.enablePost(GBufferFrame.getGBufferFrame("ColorPassGBuffer"));
        }
        if (post instanceof PostBase) {
          this.postRenderer.attachPost(this.view, post);
        }
        return post;
      }
      /**
       * Remove specified post-processing effects
       * @param post
       */
      removePost(post) {
        if (post instanceof PostBase) {
          this.postRenderer.detachPost(this.view, post);
        } else {
          for (let i = 0; i < post.length; i++) {
            this.postRenderer.detachPost(this.view, post[i]);
          }
        }
      }
      /**
       * To render a frame of the scene 
       */
      renderFrame() {
        let view = this._view;
        GlobalBindGroup.getLightEntries(view.scene).update(view);
        this.occlusionSystem.update(view.camera, view.scene);
        this.clusterLightingRender.render(view, this.occlusionSystem);
        if (this.shadowMapPassRenderer) {
          ShadowLightsCollect.update(view);
          this.shadowMapPassRenderer.render(view, this.occlusionSystem);
        }
        if (this.pointLightShadowRenderer) {
          this.pointLightShadowRenderer.render(view, this.occlusionSystem);
        }
        if (this.depthPassRenderer) {
          this.depthPassRenderer.compute(view, this.occlusionSystem);
          this.depthPassRenderer.render(view, this.occlusionSystem);
        }
        if (Engine3D.setting.gi.enable && this.ddgiProbeRenderer) {
          this.ddgiProbeRenderer.compute(view, this.occlusionSystem);
          this.ddgiProbeRenderer.render(view, this.occlusionSystem);
        }
        let passList = this.rendererMap.getAllPassRenderer();
        for (let i = 0; i < passList.length; i++) {
          const renderer = passList[i];
          renderer.compute(view, this.occlusionSystem);
          renderer.render(view, this.occlusionSystem, this.clusterLightingRender.clusterLightingBuffer);
        }
        if (this.postRenderer && this.postRenderer.postList.length > 0) {
          this.postRenderer.render(view);
        }
      }
      debug() {
      }
    }

    class CubeCamera extends exports.Object3D {
      up_camera;
      down_camera;
      left_camera;
      right_camera;
      front_camera;
      back_camera;
      /**
       *
       * Construct a cube camera with 6 perspective cameras,
       * @param near  near plane
       * @param far far plane
       */
      constructor(near = 1e-3, far = 1e4, fov = 90, isShadow = false) {
        super();
        this.initCubeCamera(near, far, fov, isShadow);
      }
      initCubeCamera(near, far, fov = 90, isShadow = false) {
        this.up_camera = CameraUtil.createCamera3DObject(this, "up");
        this.down_camera = CameraUtil.createCamera3DObject(this, "down");
        this.left_camera = CameraUtil.createCamera3DObject(this, "left");
        this.right_camera = CameraUtil.createCamera3DObject(this, "right");
        this.front_camera = CameraUtil.createCamera3DObject(this, "front");
        this.back_camera = CameraUtil.createCamera3DObject(this, "back");
        this.up_camera.isShadowCamera = isShadow;
        this.down_camera.isShadowCamera = isShadow;
        this.left_camera.isShadowCamera = isShadow;
        this.right_camera.isShadowCamera = isShadow;
        this.front_camera.isShadowCamera = isShadow;
        this.back_camera.isShadowCamera = isShadow;
        let aspect = 1;
        this.up_camera.perspective(fov, aspect, near, far);
        this.up_camera.lookAt(Vector3.ZERO, Vector3.UP, Vector3.DOWN);
        this.down_camera.perspective(fov, aspect, near, far);
        this.down_camera.lookAt(Vector3.ZERO, Vector3.DOWN, Vector3.DOWN);
        this.left_camera.perspective(fov, aspect, near, far);
        this.left_camera.lookAt(Vector3.ZERO, Vector3.LEFT);
        this.right_camera.perspective(fov, aspect, near, far);
        this.right_camera.lookAt(Vector3.ZERO, Vector3.RIGHT);
        this.front_camera.perspective(fov, aspect, near, far);
        this.front_camera.lookAt(Vector3.ZERO, Vector3.FORWARD);
        this.back_camera.perspective(fov, aspect, near, far);
        this.back_camera.lookAt(Vector3.ZERO, Vector3.BACK);
        this.up_camera.type = CameraType.shadow;
        this.down_camera.type = CameraType.shadow;
        this.left_camera.type = CameraType.shadow;
        this.right_camera.type = CameraType.shadow;
        this.front_camera.type = CameraType.shadow;
        this.back_camera.type = CameraType.shadow;
      }
    }

    class ProbeGBufferFrame extends RTFrame {
      constructor(rtWidth, rtHeight, autoResize = true) {
        super([], []);
        this.crateGBuffer(rtWidth, rtHeight, autoResize);
      }
      crateGBuffer(rtWidth, rtHeight, autoResize) {
        let attachments = this.renderTargets;
        let rtDescriptors = this.rtDescriptors;
        let positionMap = new RenderTexture(rtWidth, rtHeight, GPUTextureFormat.rgba16float, false, void 0, 1, 0, true, autoResize);
        positionMap.name = `positionMap`;
        let posDec = new RTDescriptor();
        posDec.loadOp = `load`;
        let normalMap = new RenderTexture(rtWidth, rtHeight, GPUTextureFormat.rgba16float, false, void 0, 1, 0, true, autoResize);
        normalMap.name = `normalMap`;
        let normalDec = new RTDescriptor();
        normalDec.loadOp = `load`;
        let colorMap = new RenderTexture(rtWidth, rtHeight, GPUTextureFormat.rgba16float, false, void 0, 1, 0, true, autoResize);
        colorMap.name = `colorMap`;
        let colorDec = new RTDescriptor();
        colorDec.loadOp = `load`;
        let depthTexture = new RenderTexture(rtWidth, rtHeight, GPUTextureFormat.depth24plus, false, void 0, 1, 0, true, autoResize);
        depthTexture.name = `depthTexture`;
        let depthDec = new RTDescriptor();
        depthDec.loadOp = `load`;
        attachments.push(positionMap);
        attachments.push(normalMap);
        attachments.push(colorMap);
        rtDescriptors.push(posDec);
        rtDescriptors.push(normalDec);
        rtDescriptors.push(colorDec);
        this.depthTexture = depthTexture;
      }
    }

    let DDGIIrradiance_shader = (
      /*wgsl*/
      `
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //左右
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //上下
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //补角
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`
    );

    class DDGIIrradianceComputePass {
      irradianceBuffer;
      depthBuffer;
      probeIrradianceMap;
      probeDepthMap;
      volume;
      computeShader;
      depthRaysBuffer;
      constructor(volume) {
        this.volume = volume;
        this.initPipeline();
      }
      initPipeline() {
        this.computeShader = new ComputeShader(DDGIIrradiance_shader);
        let giSetting = Engine3D.setting.gi;
        let pixelCount = giSetting.octRTMaxSize * giSetting.octRTMaxSize;
        this.irradianceBuffer = new StorageGPUBuffer(pixelCount * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        this.computeShader.setStorageBuffer(`irradianceBuffer`, this.irradianceBuffer);
        this.depthBuffer = new StorageGPUBuffer(pixelCount * 4, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        this.computeShader.setStorageBuffer(`depthBuffer`, this.depthBuffer);
        this.depthRaysBuffer = new StorageGPUBuffer(4096 * 4 * 2 * 2 * 2, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
        this.computeShader.setStorageBuffer(`depthRaysBuffer`, this.depthRaysBuffer);
        this.computeShader.setStorageBuffer(`probes`, this.volume.probesBuffer);
        this.computeShader.setUniformBuffer(`uniformData`, this.volume.irradianceVolumeBuffer);
        this.computeShader.setStorageBuffer("models", GlobalBindGroup.modelMatrixBindGroup.matrixBufferDst);
      }
      setTextures(inputs, probeIrradianceMap, probeDepthMap) {
        this.probeIrradianceMap = probeIrradianceMap;
        this.probeDepthMap = probeDepthMap;
        let worldPosMap = inputs[0];
        let worldNormalMap = inputs[1];
        let colorMap = inputs[2];
        this.computeShader.setStorageTexture(`probeIrradianceMap`, this.probeIrradianceMap);
        this.computeShader.setStorageTexture(`probeDepthMap`, this.probeDepthMap);
        this.computeShader.setSamplerTexture(`positionMap`, worldPosMap);
        this.computeShader.setSamplerTexture(`normalMap`, worldNormalMap);
        this.computeShader.setSamplerTexture(`colorMap`, colorMap);
      }
      readBuffer() {
        return this.depthRaysBuffer.readBuffer();
      }
      compute(view, renderPassState) {
        let setting = this.volume.setting;
        let command = GPUContext.beginCommandEncoder();
        let probes = EntityCollect.instance.getProbes(view.scene);
        this.computeShader.workerSizeX = setting.octRTSideSize / 8;
        this.computeShader.workerSizeY = setting.octRTSideSize / 8;
        this.computeShader.workerSizeZ = probes.length;
        GPUContext.computeCommand(command, [this.computeShader]);
      }
    }

    let MultiBouncePass_cs = (
      /*wgsl*/
      `
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`
    );

    class DDGIMultiBouncePass {
      blendTexture;
      volume;
      computerShader;
      constructor(volume) {
        this.volume = volume;
        this.initPipeline();
      }
      initPipeline() {
        let giSetting = Engine3D.setting.gi;
        this.blendTexture = new RenderTexture(giSetting.probeSourceTextureSize, giSetting.probeSourceTextureSize, GPUTextureFormat.rgba16float, false, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING);
        this.computerShader = new ComputeShader(MultiBouncePass_cs);
        this.computerShader.setStorageTexture("outputBuffer", this.blendTexture);
        this.computerShader.setUniformBuffer("uniformData", this.volume.irradianceVolumeBuffer);
      }
      setInputs(inputs) {
        let worldNormalMap = inputs[0];
        let colorMap = inputs[1];
        let lightingMap = inputs[2];
        let irradianceMap = inputs[3];
        this.computerShader.setSamplerTexture("normalMap", worldNormalMap);
        this.computerShader.setSamplerTexture("colorMap", colorMap);
        this.computerShader.setSamplerTexture("litMap", lightingMap);
        this.computerShader.setSamplerTexture("irradianceMap", irradianceMap);
      }
      compute(view, renderPassState) {
        let command = GPUContext.beginCommandEncoder();
        let setting = this.volume.setting;
        let probesCount = setting.probeXCount * setting.probeYCount * setting.probeZCount;
        let probeSourceSize = setting.probeSize;
        this.computerShader.workerSizeX = probeSourceSize * 6 / 8;
        this.computerShader.workerSizeY = probeSourceSize / 8;
        this.computerShader.workerSizeZ = probesCount;
        GPUContext.computeCommand(command, [this.computerShader]);
      }
    }

    let DDGILighting_shader = (
      /*wgsl*/
      `
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(auto) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(auto) var prefilterMapSampler: sampler;
@group(0) @binding(auto) var prefilterMap: texture_cube<f32>;

@group(1) @binding(auto) var positionMapSampler : sampler;
@group(1) @binding(auto) var positionMap : texture_2d<f32>;

@group(1) @binding(auto) var normalMapSampler : sampler;
@group(1) @binding(auto) var normalMap : texture_2d<f32>;

@group(1) @binding(auto) var colorMapSampler : sampler;
@group(1) @binding(auto) var colorMap : texture_2d<f32>;

@group(1) @binding(auto) var shadowMapSampler : sampler_comparison;
@group(1) @binding(auto) var shadowMap : texture_depth_2d_array;
@group(1) @binding(auto) var pointShadowMapSampler: sampler;
@group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${CSM.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
    var shadowIndex = i32(light.castShadow);
    if (shadowIndex >= 0 ) {
      var shadowMatrix:mat4x4<f32>;
      if(enableCSM && csmCount > 1){
        for(var csm:i32 = 0; csm < csmCount; csm ++){
          var csmShadowBias = globalUniform.csmShadowBias[csm];
          shadowMatrix = globalUniform.csmMatrix[csm];
          let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
          if(csmShadowResult.y < 0.5){
            visibility = csmShadowResult.x;
            break;
          }
        }
      }else{
        shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
        visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
      }
    }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`
    );

    class DDGILightingPass {
      computeShader;
      worldPosMap;
      worldNormalMap;
      colorMap;
      shadowMap;
      pointShadowMap;
      lightingTexture;
      constructor() {
        let giSetting = Engine3D.setting.gi;
        this.lightingTexture = new RenderTexture(giSetting.probeSourceTextureSize, giSetting.probeSourceTextureSize, GPUTextureFormat.rgba16float, false, GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING);
      }
      create(view) {
        let lightUniformEntries = GlobalBindGroup.getLightEntries(view.scene);
        this.computeShader = new ComputeShader(DDGILighting_shader);
        let cameraBindGroup = GlobalBindGroup.getCameraGroup(view.camera);
        this.computeShader.setUniformBuffer("globalUniform", cameraBindGroup.uniformGPUBuffer);
        this.computeShader.setStorageTexture("outputBuffer", this.lightingTexture);
        this.computeShader.setStorageBuffer("lightBuffer", lightUniformEntries.storageGPUBuffer);
        this.computeShader.setStorageBuffer("models", GlobalBindGroup.modelMatrixBindGroup.matrixBufferDst);
        this.computeShader.setSamplerTexture("positionMap", this.worldPosMap);
        this.computeShader.setSamplerTexture("normalMap", this.worldNormalMap);
        this.computeShader.setSamplerTexture("colorMap", this.colorMap);
        this.computeShader.setSamplerTexture("shadowMap", this.shadowMap);
        this.computeShader.setSamplerTexture("pointShadowMap", this.pointShadowMap);
        this.computeShader.setSamplerTexture("prefilterMap", Engine3D.res.defaultSky);
      }
      setInputs(inputs) {
        this.worldPosMap = inputs[0];
        this.worldNormalMap = inputs[1];
        this.colorMap = inputs[2];
        this.shadowMap = inputs[3];
        this.pointShadowMap = inputs[4];
      }
      compute(view, renderPassState) {
        if (!this.computeShader) {
          this.create(view);
        }
        let command = GPUContext.beginCommandEncoder();
        let giSetting = Engine3D.setting.gi;
        this.computeShader.workerSizeX = giSetting.probeSourceTextureSize / 8;
        this.computeShader.workerSizeY = giSetting.probeSourceTextureSize / 8;
        this.computeShader.workerSizeZ = 1;
        GPUContext.computeCommand(command, [this.computeShader]);
      }
    }

    let GIRenderStartEvent = new CEvent("GIRenderStartEvent");
    let GIRenderCompleteEvent = new CEvent("GIRenderCompleteEvent");
    class ProbeRenderResult {
      count;
      complete;
    }
    class DDGIProbeRenderer extends RendererBase {
      cubeCamera;
      volume;
      probeCountPerFrame = 1;
      nextProbeIndex = -1;
      tempProbeList = [];
      isRenderCloudGI;
      probeRenderResult;
      renderStatus = "none";
      positionMap;
      normalMap;
      colorMap;
      probeNext = 128;
      sizeW;
      sizeH;
      lightingPass;
      bouncePass;
      irradianceComputePass;
      irradianceDepthMap;
      irradianceColorMap;
      /**
       * 
       * @param volume 
       */
      constructor(volume) {
        super();
        this.passType = PassType.GI;
        this.volume = volume;
        let giSetting = volume.setting;
        this.cubeCamera = new CubeCamera(0.01, 5e3);
        this.sizeW = giSetting.probeSourceTextureSize;
        this.sizeH = giSetting.probeSourceTextureSize;
        this.probeNext = giSetting.probeSourceTextureSize / giSetting.probeSize;
        this.initIrradianceMap(volume);
        this.probeRenderResult = new ProbeRenderResult();
        let probeGBufferFrame = new ProbeGBufferFrame(this.sizeW, this.sizeH, false);
        this.positionMap = probeGBufferFrame.renderTargets[0];
        this.normalMap = probeGBufferFrame.renderTargets[1];
        this.colorMap = probeGBufferFrame.renderTargets[2];
        this.setRenderStates(probeGBufferFrame);
      }
      /**
       * @internal
       * @group DDGI
       */
      setInputTexture(textures) {
        this.lightingPass = new DDGILightingPass();
        this.bouncePass = new DDGIMultiBouncePass(this.volume);
        this.irradianceComputePass = new DDGIIrradianceComputePass(this.volume);
        this.lightingPass.setInputs([this.positionMap, this.normalMap, this.colorMap, textures[0], textures[1]]);
        this.bouncePass.setInputs([this.normalMap, this.colorMap, this.lightingPass.lightingTexture, this.irradianceColorMap]);
        this.irradianceComputePass.setTextures([this.positionMap, this.normalMap, this.bouncePass.blendTexture], this.irradianceColorMap, this.irradianceDepthMap);
      }
      /**
       * @internal
       * @group DDGI
       */
      setIrradianceData(colorData, depthData, width, height) {
        if (width != this.irradianceColorMap.width || height != this.irradianceColorMap.height) {
          console.error("irradiance image size not match !");
          return;
        }
        this.writeToTexture(this.irradianceColorMap, colorData, width, height);
        this.writeToTexture(this.irradianceDepthMap, depthData, width, height);
      }
      updateProbe(view, probe, encoder) {
        let lights = EntityCollect.instance.getLights(view.scene);
        let cubeSize = this.volume.setting.probeSize;
        probe.drawCallFrame += 1;
        this.cubeCamera.x = probe.x;
        this.cubeCamera.y = probe.y;
        this.cubeCamera.z = probe.z;
        if (this.volume.setting.debugCamera) {
          this.cubeCamera.x = view.camera.transform.x;
          this.cubeCamera.y = view.camera.transform.y;
          this.cubeCamera.z = view.camera.transform.z;
          this.cubeCamera.rotationX = view.camera.transform.rotationX;
          this.cubeCamera.rotationY = view.camera.transform.rotationY;
          this.cubeCamera.rotationZ = view.camera.transform.rotationZ;
        } else {
          this.cubeCamera.rotationX = probe.rotationX;
          this.cubeCamera.rotationY = probe.rotationY;
          this.cubeCamera.rotationZ = probe.rotationZ;
        }
        let cubeCamera = this.cubeCamera;
        let offsetX = Math.floor(probe.index / this.probeNext) * (cubeSize * 6);
        let offsetY = Math.floor(probe.index % this.probeNext) * cubeSize;
        {
          encoder.setViewport(0 + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.right_camera, encoder, lights);
        }
        {
          encoder.setViewport(cubeSize + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.left_camera, encoder, lights);
        }
        {
          encoder.setViewport(cubeSize * 2 + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.up_camera, encoder, lights);
        }
        {
          encoder.setViewport(cubeSize * 3 + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.down_camera, encoder, lights);
        }
        {
          encoder.setViewport(cubeSize * 4 + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.front_camera, encoder, lights);
        }
        {
          encoder.setViewport(cubeSize * 5 + offsetX, offsetY, cubeSize, cubeSize, 0, 1);
          this.renderSceneOnce(view, cubeCamera.back_camera, encoder, lights);
        }
      }
      renderSceneOnce(view, probeCamera, encoder, lights) {
        this.volume.uploadBuffer();
        let collectInfo = EntityCollect.instance.getRenderNodes(view.scene, probeCamera);
        GPUContext.bindCamera(encoder, probeCamera);
        let drawMin = Math.max(0, Engine3D.setting.render.drawOpMin);
        let drawMax = Math.min(Engine3D.setting.render.drawOpMax, collectInfo.opaqueList.length);
        let viewRenderList = EntityCollect.instance.getRenderShaderCollect(view);
        for (const renderList of viewRenderList) {
          let nodeMap = renderList[1];
          for (const iterator of nodeMap) {
            let node = iterator[1];
            if (node.preInit) {
              node.nodeUpdate(view, this.passType, this.rendererPassState, null);
              break;
            }
          }
        }
        for (let i = drawMin; i < drawMax; ++i) {
          let renderNode = collectInfo.opaqueList[i];
          if (renderNode.enable && renderNode.transform.enable) {
            if (!renderNode.preInit) {
              renderNode.nodeUpdate(view, this.passType, this.rendererPassState, null);
            }
            renderNode.renderPass2(view, this.passType, this.rendererPassState, null, encoder);
          }
        }
        if (EntityCollect.instance.sky) {
          if (!EntityCollect.instance.sky.preInit) {
            EntityCollect.instance.sky.nodeUpdate(view, this.passType, this.rendererPassState, null);
          }
          EntityCollect.instance.sky.renderPass2(view, this.passType, this.rendererPassState, null, encoder);
        }
        drawMin = Math.max(0, Engine3D.setting.render.drawTrMin);
        drawMax = Math.min(Engine3D.setting.render.drawTrMax, collectInfo.transparentList.length);
        for (let i = drawMin; i < drawMax; ++i) {
          let renderNode = collectInfo.transparentList[i];
          if (renderNode.enable && renderNode.transform.enable) {
            if (!renderNode.preInit) {
              renderNode.nodeUpdate(view, this.passType, this.rendererPassState, null);
            }
            renderNode.renderPass2(view, this.passType, this.rendererPassState, null, encoder);
          }
        }
      }
      render(view, occlusionSystem) {
        if (!Engine3D.setting.gi.enable)
          return;
        this.volume.updateOrientation();
        this.volume.isVolumeFrameChange = false;
        this.volume.uploadBuffer();
        this.rendProbe(view);
        let probeBeRendered = this.probeRenderResult.count > 0;
        if (EntityCollect.instance.state.giLightingChange || probeBeRendered || Engine3D.setting.gi.realTimeGI) {
          EntityCollect.instance.state.giLightingChange = false;
          this.lightingPass.compute(view, this.rendererPassState);
          this.bouncePass.compute(view, this.rendererPassState);
          this.irradianceComputePass.compute(view, this.rendererPassState);
        }
        if (this.probeRenderResult.complete) {
          this.dispatchEvent(GIRenderCompleteEvent);
        }
      }
      startRenderGI(index = 0) {
        if (this.nextProbeIndex == -1 && index == 0) {
          this.dispatchEvent(GIRenderStartEvent);
        }
        this.nextProbeIndex = index;
        this.renderStatus = "rendering";
      }
      startRenderCloudGI() {
        this.dispatchEvent(GIRenderStartEvent);
        this.nextProbeIndex = 0;
        this.renderStatus = "rendering";
        this.isRenderCloudGI = true;
      }
      rendProbe(view) {
        let autoRenderProbe = Engine3D.setting.gi.autoRenderProbe;
        let execRender = false;
        if (autoRenderProbe) {
          if (this.nextProbeIndex == -1) {
            this.startRenderGI();
          }
          execRender = true;
        } else {
          execRender = this.renderStatus == "rendering";
        }
        this.probeRenderResult.count = 0;
        this.probeRenderResult.complete = false;
        if (execRender) {
          let probeList = EntityCollect.instance.getProbes(view.scene);
          this.renderContext.clean();
          this.renderContext.beginOpaqueRenderPass();
          this.tempProbeList.length = 0;
          let remainCount = Math.min(this.probeCountPerFrame, probeList.length);
          this.probeRenderResult.count = remainCount;
          while (remainCount > 0) {
            const probe = probeList[this.nextProbeIndex];
            this.updateProbe(view, probe, this.renderContext.encoder);
            remainCount--;
            this.nextProbeIndex++;
            if (probe.drawCallFrame < 3) {
              this.tempProbeList.push(probe);
            }
          }
          if (this.tempProbeList.length > 0) {
            this.volume.updateProbes(this.tempProbeList);
          }
          let isComplete = this.nextProbeIndex >= probeList.length;
          if (this.nextProbeIndex >= probeList.length && this.isRenderCloudGI) {
            this.updateProbe(view, probeList[0], this.renderContext.encoder);
          }
          this.renderContext.endRenderPass();
          if (isComplete) {
            this.nextProbeIndex = -1;
            this.renderStatus = "complete";
            this.probeRenderResult.complete = true;
          }
        }
      }
      /**
       * @internal
       * @group DDGI
       */
      initIrradianceMap(volume) {
        let setting = volume.setting;
        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST;
        this.irradianceDepthMap = new RenderTexture(setting.octRTMaxSize, setting.octRTMaxSize, GPUTextureFormat.rgba16float, false, usage);
        this.irradianceDepthMap.name = "irradianceDepthMap";
        this.irradianceColorMap = new RenderTexture(setting.octRTMaxSize, setting.octRTMaxSize, GPUTextureFormat.rgba16float, false, usage);
        this.irradianceColorMap.name = "irradianceColorMap";
      }
      /**
      * @internal
      * @group DDGI
      */
      writeToTexture(texture, array, width, height) {
        console.log(texture.name);
        const buffer = webGPUContext.device.createBuffer({
          size: array.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        webGPUContext.device.queue.writeBuffer(buffer, 0, array);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer,
            bytesPerRow: width * 16
          },
          {
            texture: texture.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class ForwardRenderJob extends RendererJob {
      constructor(view) {
        super(view);
      }
      start() {
        super.start();
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        {
          let debugTextures = [];
          let colorPassRenderer = new ColorPassRenderer();
          if (Engine3D.setting.render.zPrePass) {
            rtFrame.zPreTexture = this.depthPassRenderer.rendererPassState.depthTexture;
          }
          colorPassRenderer.setRenderStates(rtFrame);
          for (let i = 0; i < rtFrame.renderTargets.length; i++) {
            const tex = rtFrame.renderTargets[i];
            debugTextures.push(tex);
          }
          if (Engine3D.setting.gi.enable) {
            let lightEntries = GlobalBindGroup.getLightEntries(this.view.scene);
            this.ddgiProbeRenderer = new DDGIProbeRenderer(lightEntries.irradianceVolume);
            this.ddgiProbeRenderer.setInputTexture([
              this.shadowMapPassRenderer.depth2DArrayTexture,
              this.pointLightShadowRenderer.cubeArrayTexture
            ]);
            colorPassRenderer.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap, this.ddgiProbeRenderer.irradianceDepthMap);
            this.rendererMap.addRenderer(this.ddgiProbeRenderer);
            debugTextures.push(
              this.ddgiProbeRenderer.positionMap,
              this.ddgiProbeRenderer.normalMap,
              this.ddgiProbeRenderer.colorMap,
              this.ddgiProbeRenderer.lightingPass.lightingTexture,
              this.ddgiProbeRenderer.irradianceColorMap,
              this.ddgiProbeRenderer.irradianceDepthMap
            );
          }
          if (this.postRenderer) {
            this.postRenderer.setDebugTexture(debugTextures);
          }
          this.rendererMap.addRenderer(colorPassRenderer);
        }
        if (Engine3D.setting.render.debug) {
          this.debug();
        }
      }
      /**
       * @internal
       */
      debug() {
      }
    }

    class AccelerateInterpolator {
      _factor;
      _doubleFactor;
      constructor() {
        this._factor = 1;
        this._doubleFactor = 2;
      }
      get accelerateInterpolator() {
        return this._factor;
      }
      set accelerateInterpolator(factor) {
        this._factor = factor;
        this._doubleFactor = 2 * this._factor;
      }
      getInterpolation(input) {
        if (this._factor == 1) {
          return input * input;
        } else {
          return Math.pow(input, this._doubleFactor);
        }
      }
    }
    class DecelerateInterpolator {
      _factor = 1;
      constructor() {
      }
      get decelerateInterpolator() {
        return this._factor;
      }
      set decelerateInterpolator(factor) {
        this._factor = factor;
      }
      getInterpolation(input) {
        let result;
        if (this._factor == 1) {
          result = 1 - (1 - input) * (1 - input);
        } else {
          result = 1 - Math.pow(1 - input, 2 * this._factor);
        }
        return result;
      }
    }
    class AccelerateDecelerateInterpolator {
      _factor = 1;
      constructor() {
      }
      getInterpolation(input) {
        return Math.cos((input + 1) * Math.PI) / 2 + 0.5;
      }
    }
    class LinearInterpolator {
      getInterpolation(input) {
        return input;
      }
    }
    class JumperInterpolator {
      getInterpolation(t) {
        return 4.9 * t + 4.9 * t;
      }
    }
    class BounceInterpolator {
      constructor() {
      }
      static bounce(t) {
        return t * t * 9.8;
      }
      getInterpolation(t) {
        t *= 1.1226;
        if (t < 0.3535)
          return BounceInterpolator.bounce(t);
        else if (t < 0.7408)
          return BounceInterpolator.bounce(t - 0.54719) + 0.7;
        else if (t < 0.9644)
          return BounceInterpolator.bounce(t - 0.8526) + 0.9;
        else
          return BounceInterpolator.bounce(t - 1.0435) + 0.95;
      }
      getBounceInterpolation(t) {
        if (t < 0.5)
          return BounceInterpolator.bounce(t);
        else
          return BounceInterpolator.bounce(t - 1);
      }
      geJumpUp(v0, t) {
        if (t < 0.5) {
          t = t / 0.5;
          return v0 * t - BounceInterpolator.bounce(t);
        } else if (t < 0.8) {
          t = (t - 0.5) / (0.8 - 0.5);
          return (v0 * t - BounceInterpolator.bounce(t)) * 0.3;
        } else if (t < 1) {
          t = (t - 0.8) / (1 - 0.8);
          return (v0 * t - BounceInterpolator.bounce(t)) * 0.15;
        } else
          return v0 * t - BounceInterpolator.bounce(t);
      }
    }
    class AnticipateInterpolator {
      _tension;
      constructor() {
        this._tension = 2;
      }
      get anticipateInterpolator() {
        return this._tension;
      }
      set anticipateInterpolator(tension) {
        this._tension = tension;
      }
      getInterpolation(t) {
        return t * t * ((this._tension + 1) * t - this._tension);
      }
    }
    class AnticipateOvershootInterpolator {
      _tension;
      constructor() {
        this._tension = 1 * 1.5;
      }
      anticipateOvershootInterpolator(tension) {
        this._tension = tension * 1.5;
      }
      anticipateOvershootInterpolator2(tension, extraTension) {
        this._tension = tension * extraTension;
      }
      getInterpolation(t) {
        if (t < 0.5)
          return 0.5 * AnticipateOvershootInterpolator.a(t * 2, this._tension);
        else
          return 0.5 * (AnticipateOvershootInterpolator.o(t * 2 - 2, this._tension) + 2);
      }
      static a(t, s) {
        return t * t * ((s + 1) * t - s);
      }
      static o(t, s) {
        return t * t * ((s + 1) * t + s);
      }
    }
    class CycleInterpolator {
      _cycles;
      constructor(cycles) {
        this._cycles = cycles;
      }
      getInterpolation(t) {
        return Math.sin(2 * this._cycles * Math.PI * t);
      }
    }
    class OvershootInterpolator {
      _tension;
      constructor() {
        this._tension = 2;
      }
      getInterpolation(t) {
        t -= 1;
        return t * t * ((this._tension + 1) * t + this._tension) + 1;
      }
    }
    var InterpolatorEnum = /* @__PURE__ */ ((InterpolatorEnum2) => {
      InterpolatorEnum2[InterpolatorEnum2["AccelerateInterpolator"] = 0] = "AccelerateInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["DecelerateInterpolator"] = 1] = "DecelerateInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["AccelerateDecelerateInterpolator"] = 2] = "AccelerateDecelerateInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["LinearInterpolator"] = 3] = "LinearInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["BounceInterpolator"] = 4] = "BounceInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["AnticipateInterpolator"] = 5] = "AnticipateInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["AnticipateOvershootInterpolator"] = 6] = "AnticipateOvershootInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["CycleInterpolator"] = 7] = "CycleInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["OvershootInterpolator"] = 8] = "OvershootInterpolator";
      InterpolatorEnum2[InterpolatorEnum2["JumperInterpolator"] = 9] = "JumperInterpolator";
      return InterpolatorEnum2;
    })(InterpolatorEnum || {});
    class Interpolator {
      /**
       * @internal
       */
      static interpolators = [];
      /**
       * @internal
       */
      complete = false;
      /**
       * @internal
       */
      onComplete;
      /**
       * @internal
       */
      onProgress;
      /**
       * @internal
       */
      target;
      /**
       * @internal
       */
      property;
      /**
       * @internal
       */
      targetProperty;
      /**
       * @internal
       */
      durtion;
      /**
       * @internal
       */
      interpolatorEnum;
      /**
       * @internal
       */
      delayTime = 0;
      _interpolator;
      _ct = 0;
      _p = 0;
      /**
       * Creates an animation from the current property to the specified target property.
       * @param target Objects that need to be animated
       * @param property Animation parameter
       * @param durtion Animation duration, usually seconds
       * @param interpolatorEnum Interpolator type
       * @returns 
       */
      static to(target, property, durtion, interpolatorEnum = 0 /* AccelerateInterpolator */) {
        var interpolator = new Interpolator();
        interpolator.target = target;
        interpolator.property = property;
        interpolator.durtion = durtion;
        interpolator.interpolatorEnum = interpolatorEnum;
        interpolator.start();
        interpolator.delayTime = property["delayTime"] ? property["delayTime"] : 0;
        if (property["onComplete"])
          interpolator.onComplete = property["onComplete"];
        if (property["onProgress"])
          interpolator.onProgress = property["onProgress"];
        this.interpolators.push(interpolator);
        return interpolator;
      }
      /**
       * @internal
       */
      static tick(delta) {
        let interpolators = Interpolator.interpolators;
        for (let inter of interpolators) {
          if (inter.complete) {
            Interpolator.remove(inter, true);
          } else {
            inter.tick(delta);
          }
        }
      }
      /**
       * @internal
       */
      static remove(interpolator, dispose) {
        let interpolators = Interpolator.interpolators;
        let index = interpolators.indexOf(interpolator);
        if (index != -1)
          interpolators.splice(index, 1);
        if (dispose)
          interpolator.dispose();
      }
      static removeList(interpolators, dispose) {
        interpolators.forEach((v) => {
          this.remove(v, dispose);
        });
      }
      /**
       * @internal
       */
      start() {
        window["AccelerateInterpolator"] = AccelerateInterpolator;
        window["DecelerateInterpolator"] = DecelerateInterpolator;
        window["AccelerateDecelerateInterpolator"] = AccelerateDecelerateInterpolator;
        window["LinearInterpolator"] = LinearInterpolator;
        window["BounceInterpolator"] = BounceInterpolator;
        window["AnticipateInterpolator"] = AnticipateInterpolator;
        window["AnticipateOvershootInterpolator"] = AnticipateOvershootInterpolator;
        window["CycleInterpolator"] = CycleInterpolator;
        window["OvershootInterpolator"] = OvershootInterpolator;
        window["JumperInterpolator"] = JumperInterpolator;
        this._interpolator = new window[InterpolatorEnum[this.interpolatorEnum]]();
        this.targetProperty = {};
        for (let p in this.property) {
          this.targetProperty[p] = this.target[p];
        }
      }
      /**
       * @internal
       */
      tick(delta) {
        if (this.delayTime <= 0) {
          this._p = Math.min(this._ct / this.durtion, 1);
          let v = this._interpolator.getInterpolation(this._p);
          let property = this.property;
          let target = this.target;
          let targetProperty = this.targetProperty;
          let ct;
          let tt;
          for (let p in property) {
            tt = property[p];
            ct = targetProperty[p];
            target[p] = ct + (tt - ct) * v;
          }
          if (this.onProgress != null)
            this.onProgress(this._p);
          if (this._ct >= this.durtion) {
            this.complete = true;
            if (this.onComplete != null) {
              this.onComplete(this.target);
            }
          }
          this._ct += delta;
        } else {
          this.delayTime -= delta;
        }
      }
      /**
       * @internal
       */
      dispose() {
        this.onComplete = null;
        this.onProgress = null;
        this.target = null;
        this.property = null;
        this.targetProperty = null;
        this.interpolatorEnum = null;
        this._interpolator = null;
        Interpolator.remove(this);
      }
    }

    class StringUtil {
      static _filterChar = [" ", "  ", ";", "\n", "\r", "	", "\n", "\r", "	"];
      /**
       *
       * Does the string exist
       * @param fields List of detected string
       * @param str source string
       * @returns Return the index position where it is located. If it does not exist, return -1
       */
      static hasString(fields, str) {
        for (var i = 0; i < fields.length; ++i) {
          if (fields[i] == str) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Gets an ellipsis terminated string representation that exceeds the range
       * @param str source string
       * @param len range of string
       * @returns result string
       */
      static getEllipsis(str, len = 4) {
        let name = str;
        if (name.length > len)
          name = name.slice(0, len) + "...";
        return name;
      }
      /**
       * get name based on URL
       * @param url source url
       * @returns name
       */
      static getURLName(url) {
        var urlArray;
        urlArray = url.split("/");
        let name = urlArray[urlArray.length - 1];
        name = name.split(".")[0];
        return name;
      }
      /**
       * get suffix of file name from url
       * @param url source url
       * @returns suffix
       */
      static getFileFormat(url) {
        var startPos = url.lastIndexOf(".");
        startPos++;
        var endPos = url.length;
        if (url.indexOf("?", startPos) !== -1) {
          endPos = url.indexOf("?", startPos);
        }
        var fileFormat = url.substr(startPos, endPos - startPos);
        fileFormat = fileFormat.toLowerCase();
        return fileFormat;
      }
      /**
       * get information stored in a string
       * @param line source string
       * @param data result data reference
       */
      static readLineProperty(line, data) {
        line.trim().split(" ").forEach((v, i) => {
          let strArr = v.split("=");
          if (strArr.length > 1) {
            let key = strArr[0];
            let value = strArr[1];
            if (Object.prototype.hasOwnProperty.call(data, key)) {
              if (value.indexOf('"') == -1) {
                data[key] = parseFloat(strArr[1]);
              } else {
                data[key] = value.replace('"', "").replace('"', "");
              }
            }
          }
        });
      }
      static getPath(url) {
        var s_pos = url.lastIndexOf("/");
        s_pos++;
        return url.substring(0, s_pos);
      }
      static normalizePath(url) {
        var tmp = url.replaceAll(`//`, `/`);
        tmp = tmp.replaceAll(`\\`, `/`);
        return tmp;
      }
      // public static ab2str(byte: ByteArray, block:number = 65535):string {
      //   //  return String.fromCharCode.apply(null, new Uint8Array(buf));
      //     var str: string = "";
      //     var oldPos: number = byte.position;
      //     var length: number = block;
      //     while (byte.position < byte.length) {
      //         length = block;
      //         if (byte.length - byte.position < length) {
      //             length = byte.length - byte.position;
      //         }
      //         str += byte.readUTFBytes(length);
      //     }
      //     byte.position = oldPos;
      //     return str;
      // }
      // public static str2ab(str: string):ByteArray {
      //     var byte: ByteArray = new ByteArray();
      //     byte.writeUTFBytes(str);
      //     return byte;
      // }
      /**
       * Used to cut specified characters
       * @param str source string
       * @param char cut string
       * @returns result string array
       */
      static getStringList(str, char = ";") {
        return str.split(char);
      }
      /**
       * Format timestamp data
       * @param time timestamp
       * @returns
       */
      static formatTime(time) {
        let t = time / 1e3;
        let temp = t / 60;
        let m = Math.floor(temp);
        let s = Math.floor(temp - m);
        return [m.toString(), s.toString()];
      }
      /**
       * trim
       * @param str source string
       * @returns result string
       */
      static trim(str) {
        return str.replace(/^\s+/g, "").replace(/\s+$/g, "");
      }
      /**
       * Determine if the string is empty, null, '' or 'null'
       * @param value source string
       * @returns boolean
       */
      static isEmpty(value) {
        return !value || typeof value == "undefined" || value == null || typeof value === "string" && this.trim(value) === "" || value === "null";
      }
      /**
       * Handle strings that exceed the length range, such as adding strings that exceed the range
       * @param str source string
       * @param len length
       * @returns result string
       */
      static strCut(str, len) {
        if (str.length * 2 <= len) {
          return str;
        }
        var strlen = 0;
        var s = "";
        for (var i = 0; i < str.length; i++) {
          s = s + str.charAt(i);
          if (str.charCodeAt(i) > 128) {
            strlen = strlen + 2;
            if (strlen >= len) {
              return s.substring(0, s.length - 1) + "...";
            }
          } else {
            strlen = strlen + 1;
            if (strlen >= len) {
              return s.substring(0, s.length - 2) + "...";
            }
          }
        }
        return s;
      }
      /**
       * According to the splicing request parameters
       * @param key key string
       * @param value value string
       * @param isEncodeURI isEncodeURI
       * @returns result string
       */
      static toQueryPair(key, value, isEncodeURI = false) {
        return key + "=" + (isEncodeURI ? encodeURIComponent(value) : value);
      }
      /**
       * format a string
       * @param str source string
       * @param params Pass in a regular processing parameter array
       * @returns result string
       */
      static stringFormat(str, ...params) {
        if (arguments.length === 0)
          throw new Error("please give arg at least one !");
        if (arguments.length === 2 && typeof arguments[1] === "object") {
          for (let key in arguments[1]) {
            let reg = new RegExp("({" + key + "})", "g");
            str = str.replace(reg, arguments[1][key]);
          }
        } else {
          for (let i = 0; i < params.length; i++) {
            if (params[i] == void 0) {
              return str;
            } else {
              let reg = new RegExp("({[" + i + "]})", "g");
              str = str.replace(reg, params[i]);
            }
          }
        }
        return str;
      }
      /**
       * Convert JSON objects to strings
       * @param json object of json
       * @param options
       * @returns result string
       */
      static parseJson2String(json, options) {
        let reg = null, formatted = "", pad = 0, PADDING = "    ";
        options = options || {};
        options.newlineAfterColonIfBeforeBraceOrBracket = options.newlineAfterColonIfBeforeBraceOrBracket === true ? true : false;
        options.spaceAfterColon = options.spaceAfterColon === false ? false : true;
        if (typeof json !== "string") {
          json = JSON.stringify(json);
        } else {
          json = JSON.parse(json);
          json = JSON.stringify(json);
        }
        reg = /([\{\}])/g;
        json = json.replace(reg, "\r\n$1\r\n");
        reg = /([\[\]])/g;
        json = json.replace(reg, "\r\n$1\r\n");
        reg = /(\,)/g;
        json = json.replace(reg, "$1\r\n");
        reg = /(\r\n\r\n)/g;
        json = json.replace(reg, "\r\n");
        reg = /\r\n\,/g;
        json = json.replace(reg, ",");
        if (!options.newlineAfterColonIfBeforeBraceOrBracket) {
          reg = /\:\r\n\{/g;
          json = json.replace(reg, ":{");
          reg = /\:\r\n\[/g;
          json = json.replace(reg, ":[");
        }
        if (options.spaceAfterColon) {
          reg = /\:/g;
          json = json.replace(reg, ":");
        }
        json.split("\r\n").forEach(function(node, index) {
          let i = 0, indent = 0, padding = "";
          if (node.match(/\{$/) || node.match(/\[$/)) {
            indent = 1;
          } else if (node.match(/\}/) || node.match(/\]/)) {
            if (pad !== 0) {
              pad -= 1;
            }
          } else {
            indent = 0;
          }
          for (i = 0; i < pad; i++) {
            padding += PADDING;
          }
          formatted += padding + node + "\r\n";
          pad += indent;
        });
        return formatted;
      }
      /**
       * Compatibility mode - version comparison
       * @param v1 Version 1
       * @param v2 Version 2
       * @returns Returns 1, -1, or 0, indicating that the version number is greater, less, or equal, respectively
       */
      static compareVersion(v1, v2) {
        v1 = v1.split(".");
        v2 = v2.split(".");
        let len = Math.max(v1.length, v2.length);
        while (v1.length < len) {
          v1.push("0");
        }
        while (v2.length < len) {
          v2.push("0");
        }
        for (let i = 0; i < len; i++) {
          let num1 = parseInt(v1[i]);
          let num2 = parseInt(v2[i]);
          if (num1 > num2) {
            return 1;
          } else if (num1 < num2) {
            return -1;
          }
        }
        return 0;
      }
      /**
       * Generate non repeating random string codes
       * @returns result
       */
      static buildRandomCode() {
        let words = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let len = words.length;
        let str = "";
        for (let i = 0; i < 26; i++) {
          let rand = Math.floor(Math.random() * len);
          str += words.charAt(rand);
        }
        let millisecond = (/* @__PURE__ */ new Date()).getTime();
        return `${millisecond}-${str}`;
      }
      /**
       * UUID
       * @returns UUID
       */
      static UUID() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      }
      /**
       * make hash code
       * @param str source value
       * @returns hash code
       */
      static stringToHash(str) {
        let hash = 0;
        if (str.length == 0)
          return hash;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return hash;
      }
      /**
       * Convert GLTF URL Address
       * @param base baseURL
       * @param url source url
       * @returns result url
       */
      static parseUrl(base, url) {
        return url.match(/^(blob|http|https):/) ? url : base + url;
      }
      // public static readLineProperty(line:string){
      //     fnt.trim().split('\r\n').forEach((v,i)=>{
      //         if(i<2){
      //             FntParser.readLineProperty(v,fontData);
      //         }else{
      //             if(i<fontData.pages+2){
      //                 let page = new FontPage();
      //                 FntParser.readLineProperty(v,page);
      //                 fontData.fontPage.push(page);
      //             }else if(i<fontData.pages+3){
      //                 FntParser.readLineProperty(v,fontData);
      //             }else{
      //                 if(fontData.count>0){
      //                     let char = new FontChar();
      //                     FntParser.readLineProperty(v,char);
      //                     fontData.fontChar[char.id] = char ;
      //                     fontData.count--;
      //                 }
      //             }
      //         }
      //     })
      // }
    }

    class BitmapTexture2D extends Texture {
      _source;
      premultiplyAlpha = "none";
      /**
       * @constructor
       * @param useMipmap Set whether to use mipmap
       */
      constructor(useMipmap = true) {
        super();
        this.useMipmap = useMipmap;
        this.lodMinClamp = 0;
        this.lodMaxClamp = 4;
      }
      /**
       * get raw data of this texture
       */
      get source() {
        return this._source;
      }
      /**
       * set raw data of this texture
       */
      set source(value) {
        this._source = value;
        if (this._source instanceof HTMLImageElement) {
          this._source.decode().then(async () => {
            if (this._source instanceof HTMLImageElement) {
              const imageBitmap = await createImageBitmap(this._source, { imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
              this.generate(imageBitmap);
            }
          });
        } else {
          if (this._source instanceof HTMLCanvasElement || this._source instanceof ImageBitmap) {
            this.generate(this._source);
          }
        }
      }
      /**
       * load texture data from web url
       * @param url web url
       * @param loaderFunctions callback function when load complete
       */
      async load(url, loaderFunctions) {
        this.name = StringUtil.getURLName(url);
        if (url.indexOf(";base64") != -1) {
          const img = document.createElement("img");
          let start = url.indexOf("data:image");
          let uri = url.substring(start, url.length);
          img.src = uri;
          await img.decode();
          img.width = Math.max(img.width, 32);
          img.height = Math.max(img.height, 32);
          const imageBitmap = await createImageBitmap(img, {
            resizeWidth: img.width,
            resizeHeight: img.height,
            imageOrientation: this.flipY ? "flipY" : "from-image",
            premultiplyAlpha: "none"
          });
          this.format = GPUTextureFormat.rgba8unorm;
          this.generate(imageBitmap);
        } else {
          return new Promise((succ, fial) => {
            fetch(url, {
              headers: Object.assign({
                "Accept": "image/avif,image/webp,*/*"
              }, loaderFunctions?.headers)
            }).then((r) => {
              LoaderBase.read(url, r, loaderFunctions).then((chunks) => {
                let img = new Blob([chunks], { type: "image/jpeg" });
                chunks = null;
                this.loadFromBlob(img).then(() => {
                  succ(true);
                });
              });
            });
          });
        }
        return true;
      }
      imageData;
      /**
      * load data from Blob
      * @param imgData blob data which contains image
      */
      async loadFromBlob(imgData) {
        this.imageData = imgData;
        let imageBitmap = await createImageBitmap(imgData, { imageOrientation: this.flipY ? "flipY" : "from-image", premultiplyAlpha: "none" });
        if (imageBitmap.width < 32 || imageBitmap.height < 32) {
          let width = Math.max(imageBitmap.width, 32);
          let height = Math.max(imageBitmap.height, 32);
          imageBitmap = await createImageBitmap(imageBitmap, {
            resizeWidth: width,
            resizeHeight: height,
            imageOrientation: this.flipY ? "flipY" : "from-image",
            premultiplyAlpha: "none"
          });
        }
        this.format = GPUTextureFormat.rgba8unorm;
        this.generate(imageBitmap);
        return true;
      }
    }

    class LoaderBase {
      baseUrl = "";
      initUrl;
      _progress = 0;
      constructor() {
      }
      /**
       * @private
       */
      async loadBinData(url, loaderFunctions) {
        this.baseUrl = StringUtil.getPath(url);
        this.initUrl = url;
        return new Promise(async (succ, fail) => {
          fetch(url, { headers: loaderFunctions?.headers }).then(async (response) => {
            if (response.ok) {
              let chunks = await LoaderBase.read(url, response, loaderFunctions);
              let buffer = chunks.buffer;
              chunks = null;
              succ(buffer);
            } else {
              throw Error("request rejected with status " + response.status);
            }
          }).catch((e) => {
            if (loaderFunctions.onError) {
              loaderFunctions.onError(e);
            }
            fail(e);
          });
        });
      }
      /**
       *
       * @private
       */
      async loadAsyncBitmapTexture(url, loaderFunctions) {
        this.baseUrl = StringUtil.getPath(url);
        this.initUrl = url;
        let bitmapTexture = new BitmapTexture2D();
        bitmapTexture.url = url;
        bitmapTexture.name = StringUtil.getURLName(url);
        await bitmapTexture.load(url, loaderFunctions);
        Engine3D.res.addTexture(url, bitmapTexture);
        return bitmapTexture;
      }
      /**
       *
       * @private
       */
      async loadJson(url, loaderFunctions) {
        this.baseUrl = StringUtil.getPath(url);
        this.initUrl = url;
        return new Promise(async (succ, fail) => {
          fetch(url, { headers: loaderFunctions?.headers }).then(async (response) => {
            if (response.ok) {
              let chunks = await LoaderBase.read(url, response, loaderFunctions);
              let utf8decoder = new TextDecoder("utf-8");
              const jsonString = utf8decoder.decode(chunks);
              chunks = null;
              succ(JSON.parse(jsonString));
            } else {
              throw Error("request rejected with status" + response.status);
            }
          }).catch((e) => {
            if (loaderFunctions.onError) {
              loaderFunctions.onError(e);
            }
            fail(e);
          });
        });
      }
      /**
       * @private
       */
      async loadTxt(url, loaderFunctions) {
        this.baseUrl = StringUtil.getPath(url);
        return new Promise(async (succ, fail) => {
          fetch(url).then(async (response) => {
            if (response.ok) {
              let chunks = await LoaderBase.read(url, response, loaderFunctions);
              let utf8decoder = new TextDecoder("utf-8");
              const textString = utf8decoder.decode(chunks);
              chunks = null;
              succ({ data: textString });
            } else {
              throw Error("request rejected with status" + response.status);
            }
          }).catch((e) => {
            if (loaderFunctions.onError) {
              loaderFunctions.onError(e);
            }
            fail(e);
          });
        });
      }
      /**
       * @private
       */
      static async read(url, response, loaderFunctions) {
        const reader = response.body.getReader();
        const contentLength = +response.headers.get("Content-Length");
        let receivedLength = 0;
        let chunks = [];
        let receivedArr = [];
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            if (contentLength > 0) {
              if (loaderFunctions && loaderFunctions.onComplete) {
                loaderFunctions.onComplete.call(this, url);
              }
            }
            break;
          }
          chunks.push(value);
          receivedLength += value.length;
          if (contentLength > 0) {
            if (loaderFunctions && loaderFunctions.onProgress) {
              loaderFunctions.onProgress.call(this, receivedLength, contentLength, url);
            }
          } else {
            receivedArr.push(value.length);
          }
        }
        if (receivedArr.length > 0) {
          for (let i = 0; i < chunks.length; i++) {
            console.log(receivedArr[i]);
            if (loaderFunctions && loaderFunctions.onProgress) {
              loaderFunctions.onProgress.call(this, receivedArr[i], receivedLength, url);
            }
            if (receivedArr[i] == receivedLength) {
              if (loaderFunctions && loaderFunctions.onComplete) {
                loaderFunctions.onComplete.call(this, url);
              }
            }
          }
        }
        let chunksAll = new Uint8Array(receivedLength);
        let position = 0;
        for (let chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }
        return chunksAll;
      }
    }

    var ParserFormat = /* @__PURE__ */ ((ParserFormat2) => {
      ParserFormat2[ParserFormat2["TEXT"] = 0] = "TEXT";
      ParserFormat2[ParserFormat2["BIN"] = 1] = "BIN";
      ParserFormat2[ParserFormat2["JSON"] = 2] = "JSON";
      return ParserFormat2;
    })(ParserFormat || {});

    class FileLoader extends LoaderBase {
      /**
       * Load the file from the URL
       * @param url file URL
       * @param c File parser
       * @param loaderFunctions loader callback
       * @see LoaderFunctions
       * @returns
       */
      async load(url, c, loaderFunctions, userData) {
        switch (c.format) {
          case ParserFormat.BIN: {
            return new Promise(async (succ, fail) => {
              this.loadBinData(url, loaderFunctions).then(async (data) => {
                let parser = new c();
                parser.userData = userData;
                parser.baseUrl = this.baseUrl;
                parser.initUrl = url;
                await parser.parseBuffer(data);
                if (parser.verification()) {
                  succ(parser);
                } else {
                  throw new Error("parser error");
                }
              }).catch((e) => {
                fail(e);
              });
            });
          }
          case ParserFormat.JSON: {
            return new Promise((succ, fail) => {
              this.loadJson(url, loaderFunctions).then(async (ret) => {
                let parser = new c();
                parser.userData = userData;
                parser.baseUrl = this.baseUrl;
                parser.initUrl = url;
                parser.loaderFunctions = loaderFunctions;
                await parser.parseJson(ret);
                succ(parser);
              }).catch((e) => {
                fail(e);
              });
            });
          }
          case ParserFormat.TEXT: {
            return new Promise((succ, fail) => {
              this.loadTxt(url, loaderFunctions).then(async (ret) => {
                let parser = new c();
                parser.userData = userData;
                parser.baseUrl = this.baseUrl;
                parser.initUrl = url;
                parser.loaderFunctions = loaderFunctions;
                if (!ret[`data`]) {
                  fail(`text load is empty!`);
                } else {
                  await parser.parseString(ret[`data`]);
                  succ(parser);
                }
              }).catch((e) => {
                fail(e);
              });
            });
          }
        }
      }
    }

    class ParserBase {
      static format = ParserFormat.BIN;
      baseUrl;
      initUrl;
      loaderFunctions;
      userData;
      data;
      parseString(str) {
      }
      parseJson(obj) {
      }
      parseBuffer(buffer) {
      }
      parseTexture(buffer) {
        throw this.parserError("Method not implemented.", -1);
      }
      parse(data) {
      }
      verification(ret) {
        throw this.parserError("Method not implemented.", -1);
      }
      parserError(info, id) {
        console.error(`error id:${id} ${info}`);
      }
      // public static getTypedArrayTypeFromGLType(componentType:number){
      //   switch (componentType) {
      //     case 5126:
      //       return Float32Array;
      //       break;
      //       case 5125:
      //         return Uint8Array;
      //         break;
      //     default:
      //       break;
      //   }
      // }
    }

    class GLTF_Info {
      asset;
      accessors;
      buffers;
      bufferViews;
      materials;
      meshes;
      nodes;
      scene = 0;
      scenes;
      textures;
      cameras;
      skins;
      resources;
      images;
      samplers;
      animations;
      extensions;
    }
    class GLTF_Scene {
      nodes;
    }
    class GLTF_Light {
      name;
      type;
      color;
      intensity;
      range;
      spot;
      isParsed;
    }
    class GLTF_Node {
      name;
      rotation;
      scale;
      translation;
      children;
      matrix;
      mesh = -1;
      isParsed;
      dnode;
      camera;
      skin;
      nodeId;
      primitives;
      extensions;
      light;
    }
    class GLTF_Primitives {
      attributes;
      indices;
      material;
      mode;
      name;
      targets;
      extensions;
      morphTargetsRelative;
    }
    class GLTF_Mesh {
      name;
      primitives;
      isParsed;
      dprimitives;
      weights;
      extras;
    }
    class GLTF_Accessors {
      bufferView;
      componentType;
      count;
      type;
      max;
      min;
      isParsed;
      daccessor;
      normalized;
      sparse;
      byteOffset;
      computeResult;
    }

    const isArrayBuffer = window.SharedArrayBuffer ? function isArrayBufferOrSharedArrayBuffer(ary) {
      return ary && ary.buffer && (ary.buffer instanceof ArrayBuffer || ary.buffer instanceof window.SharedArrayBuffer);
    } : function isArrayBuffer2(ary) {
      return ary && ary.buffer && ary.buffer instanceof ArrayBuffer;
    };
    const BYTE = 5120;
    const UNSIGNED_BYTE = 5121;
    const SHORT = 5122;
    const UNSIGNED_SHORT = 5123;
    const INT = 5124;
    const UNSIGNED_INT = 5125;
    const FLOAT = 5126;
    const UNSIGNED_SHORT_4_4_4_4 = 32819;
    const UNSIGNED_SHORT_5_5_5_1 = 32820;
    const UNSIGNED_SHORT_5_6_5 = 33635;
    const HALF_FLOAT = 5131;
    const UNSIGNED_INT_2_10_10_10_REV = 33640;
    const UNSIGNED_INT_10F_11F_11F_REV = 35899;
    const UNSIGNED_INT_5_9_9_9_REV = 35902;
    const FLOAT_32_UNSIGNED_INT_24_8_REV = 36269;
    const UNSIGNED_INT_24_8 = 34042;
    const glTypeToTypedArray = {};
    {
      const tt = glTypeToTypedArray;
      tt[BYTE] = Int8Array;
      tt[UNSIGNED_BYTE] = Uint8Array;
      tt[SHORT] = Int16Array;
      tt[UNSIGNED_SHORT] = Uint16Array;
      tt[INT] = Int32Array;
      tt[UNSIGNED_INT] = Uint32Array;
      tt[FLOAT] = Float32Array;
      tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;
      tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;
      tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;
      tt[HALF_FLOAT] = Uint16Array;
      tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;
      tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;
      tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;
      tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
      tt[UNSIGNED_INT_24_8] = Uint32Array;
    }
    function getGLTypeFromTypedArrayType(typedArrayType) {
      switch (typedArrayType) {
        case Int8Array:
          return BYTE;
        case Uint8Array:
          return UNSIGNED_BYTE;
        case Uint8ClampedArray:
          return UNSIGNED_BYTE;
        case Int16Array:
          return SHORT;
        case Uint16Array:
          return UNSIGNED_SHORT;
        case Int32Array:
          return INT;
        case Uint32Array:
          return UNSIGNED_INT;
        case Float32Array:
          return FLOAT;
        default:
          throw new Error("unsupported typed array type");
      }
    }
    function getGLTypeFromTypedArray(typedArray) {
      if (typedArray instanceof Int8Array)
        return BYTE;
      if (typedArray instanceof Uint8Array)
        return UNSIGNED_BYTE;
      if (typedArray instanceof Uint8ClampedArray)
        return UNSIGNED_BYTE;
      if (typedArray instanceof Int16Array)
        return SHORT;
      if (typedArray instanceof Uint16Array)
        return UNSIGNED_SHORT;
      if (typedArray instanceof Int32Array)
        return INT;
      if (typedArray instanceof Uint32Array)
        return UNSIGNED_INT;
      if (typedArray instanceof Float32Array)
        return FLOAT;
      throw new Error("unsupported typed array type");
    }
    function getTypedArrayTypeFromGLType(type) {
      const arrayType = glTypeToTypedArray[type];
      if (!arrayType)
        throw new Error("unkonw gl type");
      return arrayType;
    }
    function getTypedArray(array, Type = Float32Array) {
      if (isArrayBuffer(array))
        return array;
      return new Type(array);
    }

    class KHR_draco_mesh_compression {
      static _workerCode;
      static _workers = /* @__PURE__ */ new Map();
      static async apply(parser, primitive) {
        if (!primitive.extensions) {
          return;
        }
        const extensionArgs = primitive.extensions["KHR_draco_mesh_compression"];
        if (!extensionArgs) {
          return;
        }
        let worker = this._workers.get(parser.gltf);
        if (!worker) {
          worker = new Worker(await this.initDecoder());
          this._workers.set(parser.gltf, worker);
        }
        worker.postMessage({
          type: "init",
          decoderConfig: {
            // wasmBinary: dracoDecoderWasm
          }
        });
        let buffer = parser.parseBufferView(extensionArgs.bufferView);
        if (!buffer.result) {
          let result = await new Promise((resolve, reject) => {
            worker.onmessage = (e) => {
              const msg = e.data;
              if (msg.type == "decode") {
                resolve(msg.result);
              } else if (msg.type == "error") {
                reject(msg.error);
              }
            };
            worker.postMessage({
              type: "decoder",
              buffer,
              attributes: extensionArgs.attributes
            }, [buffer]);
          });
          buffer.result = result;
        }
        return buffer.result;
      }
      static unload(gltf) {
        let worker = this._workers.get(gltf);
        if (worker) {
          worker.terminate();
          this._workers.delete(gltf);
        }
      }
      static async initDecoder() {
        if (!this._workerCode) {
          let dracoDecoderJs = await new FileLoader().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");
          const blob = new Blob([dracoDecoderJs["data"], "", `(${dracoDecoderWoeker})()`], { type: "application/javascript" });
          this._workerCode = URL.createObjectURL(blob);
        }
        return this._workerCode;
      }
    }
    function dracoDecoderWoeker() {
      let decoderConfig;
      let decoderPending;
      onmessage = (e) => {
        const msg = e.data;
        switch (msg.type) {
          case "init":
            decoderConfig = msg.decoderConfig;
            decoderPending = new Promise((resolve, reject) => {
              decoderConfig.onModuleLoaded = (draco) => {
                resolve({
                  draco
                });
              };
              DracoDecoderModule(decoderConfig);
            });
            break;
          case "decoder":
            const buffer = msg.buffer;
            const attributes = msg.attributes;
            decoderPending.then((module) => {
              const draco = module.draco;
              let decoder = new draco.Decoder();
              let decoderBuffer = new draco.DecoderBuffer();
              decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);
              let status, dracoGeometry;
              try {
                const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);
                if (geometryType == draco.TRIANGULAR_MESH) {
                  dracoGeometry = new draco.Mesh();
                  status = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);
                } else {
                  self.postMessage(new Error("INVALID_GEOMETRY_TYPE:" + geometryType));
                }
                if (!status.ok()) {
                  self.postMessage(new Error("DracoDecode:" + status.error_msg()));
                }
                let result = {};
                for (const attributeName in attributes) {
                  let attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributes[attributeName]);
                  const numComponents = attribute.num_components();
                  const numPoints = dracoGeometry.num_points();
                  const numValues = numPoints * numComponents;
                  const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;
                  const dataType = draco.DT_FLOAT32;
                  const ptr = draco._malloc(byteLength);
                  decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
                  const array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();
                  draco._free(ptr);
                  result[attributeName] = {
                    data: array,
                    numComponents,
                    normalize: false
                  };
                }
                {
                  const numFaces = dracoGeometry.num_faces();
                  const numIndices = numFaces * 3;
                  const byteLength = numIndices * 4;
                  const ptr = draco._malloc(byteLength);
                  decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
                  const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
                  draco._free(ptr);
                  result["indices"] = {
                    data: index,
                    numComponents: 1,
                    normalize: false
                  };
                }
                self.postMessage({
                  type: "decode",
                  result
                });
              } catch (error) {
                self.postMessage({
                  type: "error",
                  error: error.message
                });
              } finally {
                draco.destroy(dracoGeometry);
                draco.destroy(decoder);
                draco.destroy(decoderBuffer);
              }
            });
            break;
        }
      };
    }

    class GLTFSubParserCamera {
      gltf;
      constructor(gltf) {
        this.gltf = gltf;
      }
      parse(cameraId) {
        const camera = this.gltf.cameras[cameraId];
        if (!camera)
          return this.errorMiss("camera", cameraId);
        if (camera.isParsed)
          return camera.dcamera;
        camera.isParsed = true;
        camera.dcamera = false;
        const { name, type, perspective, orthographic } = camera;
        if (type === "perspective" && perspective) {
          const { aspectRatio, yfov, zfar, znear } = perspective;
          camera.dcamera = Object.assign(
            {},
            {
              name,
              type,
              yfov,
              znear,
              aspectRatio,
              zfar
            }
          );
        } else if (type === "orthographic" && orthographic) {
          const { xmag, ymag, zfar, znear } = orthographic;
          camera.dcamera = Object.assign(
            {},
            {
              name,
              type,
              xmag,
              ymag,
              zfar,
              znear
            }
          );
        }
        return camera.dcamera;
      }
      errorMiss(e, info) {
        throw new Error(e + info);
      }
    }

    class GLTFParser extends ParserBase {
      static format = ParserFormat.JSON;
      _gltf;
      async parseJson(obj) {
        this._gltf = new GLTF_Info();
        this._gltf = { ...this._gltf, ...obj };
        this._gltf.resources = {};
        await Promise.all([this.load_gltf_bin(), this.load_gltf_textures()]);
        let subParser = new GLTFSubParser();
        let nodes = await subParser.parse(this.initUrl, this._gltf, this._gltf.scene);
        subParser.destory();
        subParser = null;
        if (nodes) {
          this.data = nodes.rootNode;
          return nodes.rootNode;
        }
        this._gltf = null;
        return null;
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
      static _counter = 0;
      static getMeshNameCounter() {
        return function getMeshNameCounter() {
          return `GLTF_NO_NAME_PRIMITIVE_${GLTFParser._counter++}`;
        };
      }
      static getModelNameCounter() {
        let counter = 0;
        return function getModelNameCounter() {
          return `GLTF_NO_NAME_MESH_${counter++}`;
        };
      }
      static getTexCoordDefine(texNum) {
        return `UV_NUM ${texNum}`;
      }
      static getVertexColorDefine(num) {
        return `HAS_VERTEXCOLOR ${num}`;
      }
      static getBaseColorTextureDefine() {
        return "HAS_BASECOLORMAP";
      }
      static getMetalRoughnessDefine() {
        return "HAS_METALROUGHNESSMAP";
      }
      static getNormalMapDefine() {
        return "HAS_NORMALMAP";
      }
      static getEmissiveMapDefine() {
        return "HAS_EMISSIVEMAP";
      }
      static getOcclusionMapDefine() {
        return "HAS_OCCLUSIONMAP";
      }
      static getMorphTargetsDefine(targetNum) {
        return `MORPH_TARGET_NUM ${targetNum}`;
      }
      static getMorphtargetPositionDefine() {
        return "HAS_MORPH_POSITION";
      }
      static getMorphtargetNormalDefine() {
        return "HAS_MORPH_NORMAL";
      }
      static getMorphtargetTangentDefine() {
        return "HAS_MORPH_TANGENT";
      }
      static getJointsNumDefine(num) {
        return `JOINTS_NUM ${num}`;
      }
      static getJointVec8Define() {
        return "JOINT_VEC8";
      }
      static getHasNormalDefine() {
        return "HAS_NORMAL";
      }
      static getHasTangentDefine() {
        return "HAS_TANGENT";
      }
      static getHasNormalMapDefine() {
        return "HAS_NORMAL_MAP";
      }
      static getAlphaMaskDefine() {
        return "ALPHA_MASK";
      }
      static getAlphaBlendDefine() {
        return "ALPHA_BLEND";
      }
      static defaultMaterial = {
        name: "GLTF_DEFAULT_MATERIAL",
        alphaCutoff: 0.33,
        alphaMode: "MASK",
        pbrMetallicRoughness: {
          name: "GLTF_DEFAULT_MATERIAL",
          defines: [],
          doubleSided: false,
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1,
          emissiveFactor: [0, 0, 0]
        }
      };
      async load_gltf_bin() {
        if (this._gltf.buffers && this._gltf.buffers.length > 0) {
          let binArray = [];
          for (let i = 0; i < this._gltf.buffers.length; i++) {
            const element = this._gltf.buffers[i];
            if (element.uri.substring(0, 5) !== "data:") {
              let url = StringUtil.parseUrl(this.baseUrl, element.uri);
              if (this.loaderFunctions?.onUrl)
                url = await this.loaderFunctions.onUrl(url);
              let promise = new FileLoader().loadBinData(url, this.loaderFunctions).then((loader) => {
                this._gltf.resources[element.uri] = loader;
              });
              binArray.push(promise);
            }
          }
          await Promise.all(binArray);
        }
      }
      async load_gltf_textures() {
        this._gltf;
        if (this._gltf.images) {
          let textureArray = [];
          for (let i = 0; i < this._gltf.images.length; i++) {
            const element = this._gltf.images[i];
            if (element.uri) {
              let url = StringUtil.parseUrl(this.baseUrl, element.uri);
              if (this.loaderFunctions?.onUrl)
                url = await this.loaderFunctions.onUrl(url);
              let promise = new FileLoader().loadAsyncBitmapTexture(url, this.loaderFunctions).then((texture) => {
                texture.name = StringUtil.getURLName(element.uri);
                this._gltf.resources[texture.name] = texture;
              });
              textureArray.push(promise);
            }
          }
          await Promise.all(textureArray);
        }
      }
    }

    class GLTFSubParserMesh {
      gltf;
      subParser;
      constructor(subParser) {
        this.gltf = subParser.gltf;
        this.subParser = subParser;
      }
      async parse(meshId) {
        const mesh = this.gltf.meshes[meshId];
        if (!mesh)
          return this.errorMiss("mesh", meshId);
        if (mesh.isParsed)
          return mesh.dprimitives;
        const primitives = mesh.primitives;
        const extras = mesh.extras;
        const dprimitives = [];
        for (let i = 0; i < primitives.length; i++) {
          const primitive = primitives[i];
          const { attributes, indices, material, mode, name, targets, morphTargetsRelative, extensions } = primitive;
          let tmpName = mesh.name;
          for (let tn in attributes) {
            tmpName += tn;
          }
          tmpName += `indices:${indices}`;
          tmpName += `material:${material}`;
          const dprimitive = {
            attribArrays: { indices: [] },
            weights: [],
            defines: [],
            material: null,
            drawMode: null,
            meshName: null,
            modelName: null,
            morphTargetsRelative: false,
            targetNames: extras ? extras.targetNames : null
          };
          let hasNormal = false;
          let texCoordNum = 0;
          let jointVec8 = false;
          let overlayAccessors;
          if (extensions && extensions.KHR_draco_mesh_compression) {
            overlayAccessors = await KHR_draco_mesh_compression.apply(this.subParser, primitive);
          }
          for (const attribute in attributes) {
            const accessor = overlayAccessors ? overlayAccessors[attribute] : this.parseAccessor(attributes[attribute]);
            if (accessor) {
              let attribName;
              switch (attribute) {
                case "POSITION":
                  attribName = VertexAttributeName.position;
                  break;
                case "NORMAL":
                  attribName = VertexAttributeName.normal;
                  hasNormal = true;
                  break;
                case "TEXCOORD_0":
                  attribName = VertexAttributeName.uv;
                  texCoordNum++;
                  break;
                case "JOINTS_0":
                  attribName = VertexAttributeName.joints0;
                  break;
                case "JOINTS_1":
                  attribName = VertexAttributeName.joints1;
                  jointVec8 = true;
                  break;
                case "WEIGHTS_0":
                  attribName = VertexAttributeName.weights0;
                  break;
                case "WEIGHTS_1":
                  attribName = VertexAttributeName.weights1;
                  break;
                default:
                  attribName = attribute;
              }
              dprimitive.attribArrays[attribName] = accessor;
            }
          }
          if (hasNormal)
            dprimitive.defines.push(GLTFParser.getHasNormalDefine());
          if (texCoordNum)
            dprimitive.defines.push(GLTFParser.getTexCoordDefine(texCoordNum));
          if (jointVec8)
            dprimitive.defines.push(GLTFParser.getJointVec8Define());
          if (indices !== void 0) {
            const accessor = overlayAccessors ? overlayAccessors["indices"] : this.parseAccessor(indices);
            if (accessor)
              dprimitive.attribArrays.indices = accessor;
          }
          const dmaterial = await this.parseMaterial(material);
          if (dmaterial) {
            dprimitive.material = dmaterial;
            dprimitive.defines = dprimitive.defines.concat(dmaterial.defines);
          }
          dprimitive.drawMode = mode === void 0 ? 4 : mode;
          dprimitive.meshName = () => {
            return tmpName;
          };
          dprimitive.modelName = mesh.name || GLTFParser.getModelNameCounter();
          if (targets) {
            dprimitive.defines.push(GLTFParser.getMorphTargetsDefine(targets.length));
            dprimitive.morphTargetsRelative = true;
            let hasPositions = false;
            let hasNormals = false;
            let hasTangents = false;
            for (let j = 0; j < targets.length; j++) {
              const target = targets[j];
              Object.keys(target).forEach((attribute) => {
                const accessor = this.parseAccessor(target[attribute]);
                if (accessor) {
                  let attribName;
                  switch (attribute) {
                    case "POSITION":
                      attribName = GLTFType.MORPH_POSITION_PREFIX + j;
                      hasPositions = true;
                      break;
                    case "NORMAL":
                      attribName = GLTFType.MORPH_NORMAL_PREFIX + j;
                      hasNormals = true;
                      break;
                    case "TANGENT":
                      attribName = GLTFType.MORPH_TANGENT_PREFIX + j;
                      hasTangents = true;
                      break;
                    default:
                      attribName = false;
                  }
                  if (!attribName)
                    console.error(`glTF has unsupported morph target attribute ${attribute}`);
                  else
                    dprimitive.attribArrays[attribName] = accessor;
                }
              });
            }
            if (hasPositions)
              dprimitive.defines.push(GLTFParser.getMorphtargetPositionDefine());
            if (hasNormals)
              dprimitive.defines.push(GLTFParser.getMorphtargetNormalDefine());
            if (hasTangents)
              dprimitive.defines.push(GLTFParser.getMorphtargetTangentDefine());
            dprimitive.weights = mesh.weights || new Array(targets.length).fill(0);
          }
          dprimitives.push(dprimitive);
        }
        mesh.dprimitives = dprimitives;
        mesh.isParsed = true;
        return mesh.dprimitives;
      }
      parseAccessor(accessorId) {
        return this.subParser.parseAccessor(accessorId);
      }
      parseMaterial(material) {
        return this.subParser.parseMaterial(material);
      }
      errorMiss(e, info) {
        throw new Error(e + info);
      }
    }

    class GLTFSubParserMaterial {
      gltf;
      subParser;
      constructor(subParser) {
        this.gltf = subParser.gltf;
        this.subParser = subParser;
      }
      async parse(materialId) {
        let material;
        if (materialId == void 0) {
          material = GLTFParser.defaultMaterial;
        } else {
          material = this.gltf.materials[materialId];
        }
        if (!material)
          return this.errorMiss("material", materialId);
        if (material.isParsed)
          return material.dmaterial;
        let { name, pbrMetallicRoughness, normalTexture, occlusionTexture, emissiveTexture, emissiveFactor, alphaMode, alphaCutoff, doubleSided, extensions } = material;
        const dmaterial = {
          name,
          defines: [],
          doubleSided: !!doubleSided,
          baseColorFactor: [1, 1, 1, 1],
          emissiveFactor: null,
          alphaCutoff: 0,
          enableBlend: false,
          baseColorTexture: null,
          metallicRoughnessTexture: null,
          normalTexture: null,
          occlusionTexture: null,
          emissiveTexture: null,
          transformUV1: null,
          transformUV2: null,
          extensions: null
        };
        if (pbrMetallicRoughness) {
          const { baseColorFactor, metallicFactor, roughnessFactor, baseColorTexture, metallicRoughnessTexture } = pbrMetallicRoughness;
          Object.assign(dmaterial, {
            baseColorFactor: baseColorFactor || [1, 1, 1, 1],
            metallicFactor: metallicFactor === void 0 ? 1 : metallicFactor,
            roughnessFactor: roughnessFactor === void 0 ? 0.5 : roughnessFactor
          });
          if (baseColorTexture) {
            let ext = baseColorTexture.extensions;
            if (ext) {
              let KHR_texture_transform = ext.KHR_texture_transform;
              if (KHR_texture_transform) {
                dmaterial.transformUV1 = new Vector4(
                  KHR_texture_transform.offset ? KHR_texture_transform.offset[0] : 0,
                  KHR_texture_transform.offset ? KHR_texture_transform.offset[1] : 0,
                  KHR_texture_transform.scale ? KHR_texture_transform.scale[0] : 1,
                  KHR_texture_transform.scale ? KHR_texture_transform.scale[1] : 1
                );
              }
            }
            const texture = await this.parseTexture(baseColorTexture.index);
            if (texture) {
              dmaterial.baseColorTexture = texture;
            } else {
              dmaterial.baseColorTexture = Engine3D.res.redTexture;
            }
          }
          if (metallicRoughnessTexture) {
            const texture = await this.parseTexture(metallicRoughnessTexture.index);
            if (texture) {
              dmaterial.metallicRoughnessTexture = texture;
            } else {
              dmaterial.metallicRoughnessTexture = Engine3D.res.blackTexture;
            }
          }
        } else {
          Object.assign(dmaterial, {
            baseColorFactor: [1, 1, 1, 1],
            metallicFactor: 0,
            roughnessFactor: 0.5
          });
        }
        if (dmaterial.baseColorFactor && dmaterial.baseColorFactor[3] < 1) {
          alphaMode = alphaMode === "MASK" ? "MASK" : "BLEND";
        }
        if (alphaMode && alphaMode !== "OPAQUE") {
          if (alphaMode === "MASK") {
            dmaterial.defines.push(GLTFParser.getAlphaMaskDefine());
            dmaterial.alphaCutoff = alphaCutoff === void 0 ? 0.5 : alphaCutoff;
          }
          if (alphaMode === "BLEND") {
            dmaterial.defines.push(GLTFParser.getAlphaBlendDefine());
            dmaterial.enableBlend = true;
          }
        }
        if (normalTexture) {
          const texture = await this.parseTexture(normalTexture.index);
          if (texture) {
            dmaterial.normalTexture = texture;
          } else {
            dmaterial.normalTexture = Engine3D.res.normalTexture;
          }
        }
        if (occlusionTexture) {
          const texture = await this.parseTexture(occlusionTexture.index);
          if (texture) {
            dmaterial.occlusionTexture = texture;
          }
        }
        if (emissiveFactor) {
          dmaterial.emissiveFactor = emissiveFactor;
        }
        if (emissiveTexture) {
          const texture = await this.parseTexture(emissiveTexture.index);
          if (texture) {
            dmaterial.emissiveTexture = texture;
          } else {
            dmaterial.emissiveTexture = Engine3D.res.blackTexture;
          }
        }
        if (extensions) {
          dmaterial.extensions = extensions;
        }
        material.isParsed = true;
        material.dmaterial = dmaterial;
        return dmaterial;
      }
      async parseTexture(index) {
        return this.subParser.parseTexture(index);
      }
      errorMiss(e, info) {
        throw new Error(e + info);
      }
    }

    class GLTFSubParserSkin {
      gltf;
      subParser;
      constructor(subParser) {
        this.gltf = subParser.gltf;
        this.subParser = subParser;
      }
      parse(skinId) {
        const skin = this.gltf.skins[skinId];
        if (!skin)
          return this.errorMiss("skin", skinId);
        if (skin.isParsed)
          return skin.dskin;
        const { name, joints, inverseBindMatrices, skeleton } = skin;
        if (!joints)
          return this.errorMiss("skin.joints", skinId);
        skin.isParsed = true;
        skin.dskin = false;
        let dskin = {
          name,
          skeleton: null,
          inverseBindMatrices: null,
          joints,
          defines: [GLTFParser.getJointsNumDefine(joints.length)]
        };
        if (skeleton) {
          dskin.skeleton = skeleton;
        } else {
          var rootNodeId = -1;
          for (let i = 0; i < this.gltf.nodes.length; i++) {
            const n = this.gltf.nodes[i];
            if (n.name == "root") {
              rootNodeId = i;
              break;
            }
          }
          if (rootNodeId == -1) {
            let scene = this.gltf.scenes[this.gltf.scene];
            rootNodeId = scene.nodes[scene.nodes.length - 1];
          }
          dskin.skeleton = rootNodeId;
        }
        dskin.inverseBindMatrices = GLTFType.IDENTITY_INVERSE_BIND_MATRICES;
        if (inverseBindMatrices !== void 0) {
          const accessor = this.parseAccessor(inverseBindMatrices);
          if (accessor) {
            const array = accessor.data;
            const matrices = [];
            for (let i = 0; i < array.length; i += 16)
              matrices.push(array.slice(i, i + 16));
            dskin.inverseBindMatrices = matrices;
          } else
            dskin = null;
        }
        skin.dskin = dskin;
        return skin.dskin;
      }
      parseAccessor(accessorId) {
        return this.subParser.parseAccessor(accessorId);
      }
      errorMiss(e, info) {
        throw new Error(e + info);
      }
    }

    class Joint {
      /**
       * Name of bone joint
       */
      name = "";
      /**
       * Bone joint index
       */
      index = 0;
      /**
       * Bone instanceID
       */
      instanceID = "";
      /**
       * The parent of a bone joint
       */
      parent = null;
      /**
       * Bone joint child object
       */
      // public children: Array<Joint> = [];
      /**
       * The scaling value of the bone joint
       */
      scale = new Vector3();
      /**
       * The rotation Angle of the bone and joint
       */
      rotation = new Quaternion();
      /**
       * The position of the bone joint
       */
      translation = new Vector3();
      constructor(name = "") {
        this.name = name;
      }
    }

    class Skeleton {
      /**
       * Link information for all joints
       */
      joints;
      constructor(joints = []) {
        this.joints = joints;
      }
      get numJoint() {
        return this.joints.length;
      }
      addJoint(joint) {
        joint.index = this.joints.push(joint) - 1;
      }
      getJointName(jointIndex) {
        return this.joints[jointIndex].name;
      }
      getJointParentIndex(jointIndex) {
        let joint = this.joints[jointIndex];
        return joint.parent ? joint.parent.index : -1;
      }
      getJointByName(name) {
        for (let joint of this.joints) {
          if (joint.name == name) {
            return joint;
          }
        }
        return null;
      }
    }

    class JointPose {
      index;
      worldMatrix;
      constructor(index, useGlobalMatrix = false) {
        this.index = index;
        this.worldMatrix = new Matrix4(!useGlobalMatrix);
      }
    }

    class SkeletonPose {
      /**
      * time of this pose in owner animation clip 
      */
      time;
      _skeleton;
      _jointsPose;
      mJointMatrixIndexTable;
      constructor(skeleton, useGlobalMatrix = false) {
        this._skeleton = skeleton;
        this._jointsPose = new Array(skeleton.numJoint);
        this.mJointMatrixIndexTable = new Array(skeleton.numJoint);
        for (let index = 0; index < skeleton.numJoint; index++) {
          let joint = new JointPose(index, useGlobalMatrix);
          this._jointsPose[index] = joint;
          this.mJointMatrixIndexTable[index] = joint.worldMatrix.index;
        }
      }
      /**
      * build this pose from float32 array data
      */
      buildSkeletonPose(poseData) {
        let scale = new Vector3();
        let rotation = new Quaternion();
        let translation = new Vector3();
        let jointLocalMatrix = new Array(this._skeleton.numJoint);
        this.time = poseData[11] > 0 ? poseData[11] : poseData[24];
        for (let jointIndex = 0; jointIndex < this._skeleton.numJoint; jointIndex++) {
          let byteOffset = 12 * jointIndex * 4;
          let jointData = new Float32Array(poseData.buffer, poseData.byteOffset + byteOffset, 12);
          let localMatrix = new Matrix4();
          scale.set(jointData[0], jointData[1], jointData[2]);
          rotation.set(jointData[4], jointData[5], jointData[6], jointData[7]);
          translation.set(jointData[8], jointData[9], jointData[10]);
          makeMatrix44(rotation.getEulerAngles(), translation, scale, localMatrix);
          jointLocalMatrix[jointIndex] = localMatrix;
          let joint = new JointPose(jointIndex);
          const nParentIndex = this._skeleton.getJointParentIndex(jointIndex);
          if (nParentIndex < 0) {
            joint.worldMatrix.copyFrom(localMatrix);
          } else {
            let parentJoint = this._jointsPose[nParentIndex];
            multiplyMatrices4x4REF(parentJoint.worldMatrix, localMatrix, joint.worldMatrix);
          }
          this._jointsPose[jointIndex] = joint;
        }
      }
      /** 
      * Returns joints count of owner skeleton
      */
      get numJoint() {
        return this._skeleton.numJoint;
      }
      /** 
      * Returns all joint pose
      */
      get joints() {
        return this._jointsPose;
      }
      /** 
      * Returns list of matrix's index
      */
      get jointMatrixIndexTable() {
        return this.mJointMatrixIndexTable;
      }
      /** 
      * Returns lerped skeletonPose from pose a to pose b
      * @param a selected pose No.1
      * @param b selected pose No.2
      * @param weight number
      */
      lerp(a, b, weight) {
        if (a && b) {
          for (let index = 0; index < this._jointsPose.length; index++) {
            let jointA = a._jointsPose[index];
            let jointB = b._jointsPose[index];
            let jointDst = this._jointsPose[index];
            jointDst.worldMatrix.lerp(jointA.worldMatrix, jointB.worldMatrix, weight);
          }
        } else {
          for (let index = 0; index < this._jointsPose.length; index++) {
            let jointA = a._jointsPose[index];
            let jointDst = this._jointsPose[index];
            jointDst.worldMatrix.copyFrom(jointA.worldMatrix);
          }
        }
      }
      /** 
      * Copy skeleton pose from other skeleton pose
      * @param other source skeleton pose
      */
      copyFrom(other) {
        for (let index = 0; index < this._jointsPose.length; index++) {
          this._jointsPose[index].worldMatrix.copyFrom(other._jointsPose[index].worldMatrix);
        }
      }
      /** 
      * Reset this skeleton pose
      */
      reset() {
        for (let index = 0; index < this._jointsPose.length; index++) {
          this._jointsPose[index].worldMatrix.identity();
        }
      }
    }

    class OAnimationEvent extends CEvent {
      /**
       * owner skeleton animation component
       */
      skeletonAnimation;
      constructor(name, time) {
        super();
        this.type = name;
        this.time = time;
      }
    }

    class SkeletonAnimationClip {
      name = "";
      _skeleton;
      _skeletonPoses;
      _animationClipData;
      _events;
      constructor(name, skeleton, numFrame, bufferData) {
        this.name = name;
        this._skeleton = skeleton;
        this._animationClipData = bufferData;
        if (numFrame > 0 && bufferData) {
          this._skeletonPoses = new Array(numFrame);
          let skeletonPoseLength = 12 * skeleton.numJoint;
          for (let nFrame = 0; nFrame < numFrame; nFrame++) {
            let byteOffset = skeletonPoseLength * nFrame * 4;
            let poseData = new Float32Array(bufferData.buffer, byteOffset, skeletonPoseLength);
            let skeletonPose = new SkeletonPose(skeleton);
            skeletonPose.buildSkeletonPose(poseData);
            this._skeletonPoses[nFrame] = skeletonPose;
          }
        }
      }
      /*
      * Animation total time in seconds
      */
      get totalTime() {
        return this._skeletonPoses[this._skeletonPoses.length - 1].time;
      }
      /*
      * Frame rate at which keyframes are sampled.
      */
      get frameRate() {
        return this.totalTime / this._skeletonPoses.length;
      }
      /*
      * Returns owner skeleton
      */
      get skeleton() {
        return this._skeleton;
      }
      /*
      * Returns key frame count 
      */
      get numFrame() {
        return this._skeletonPoses.length - 1;
      }
      /*
      * Returns float32 array of this animation clip
      */
      get animationClipData() {
        return this._animationClipData;
      }
      /*
      * Returns skeletonPose at target frame
      */
      getSkeletonPose(frame) {
        return this._skeletonPoses[frame];
      }
      /** 
      * Returns lerped skeletonPose between currFrame and nextFrame
      * @param currFrame selected frame No.1
      * @param nextFrame selected frame No.2
      * @param weight number
      * @param dst  result SkeletonPose
      */
      getLerpSkeletonPose(currFrame, nextFrame, weight, dst) {
        let skeletonPoseA = this.getSkeletonPose(currFrame);
        let skeletonPoseB = this.getSkeletonPose(nextFrame);
        dst.lerp(skeletonPoseA, skeletonPoseB, weight);
        return dst;
      }
      /** 
      * create one skeletonAnimationClip from startTime to endTime
      * @param name the name of new animation clip
      * @param startTime set time of animation clip start from
      * @param endTime set time of animation clip end of
      */
      createSubClip(name, startTime, endTime) {
        var result = new SkeletonAnimationClip(name, this._skeleton, 0, null);
        const startFrame = Math.max(Math.floor(startTime / this.frameRate), 0);
        const endFrame = Math.min(Math.floor(endTime / this.frameRate), this._skeletonPoses.length - 1);
        result._skeletonPoses = this._skeletonPoses.slice(startFrame, endFrame);
        const skeletonPoseByteLength = 12 * this._skeleton.numJoint * 4;
        this._animationClipData = new Float32Array(this._animationClipData, startFrame * skeletonPoseByteLength, (endFrame - startFrame) * skeletonPoseByteLength);
        return result;
      }
      /** 
      * register a event in this animation clip.
      * @param eventName event name
      * @param startTime number
      */
      addEvent(eventName, triggerTime) {
        if (!this._events) {
          this._events = new Array();
        }
        this._events.push(new OAnimationEvent(eventName, triggerTime));
      }
      /** 
      * remove a event in this animation clip
      * @param eventName event name
      */
      removeEvent(eventName) {
        if (this._events) {
          this._events = this._events.filter((items) => items.type != eventName);
        }
      }
      /** 
      * Returns all AnimationEvent of this animationClip
      * @param eventName event name
      */
      getEvents() {
        return this._events;
      }
    }

    class GLTFSubParserSkeleton {
      gltf;
      subParser;
      constructor(subParser) {
        this.gltf = subParser.gltf;
        this.subParser = subParser;
      }
      parse(skeletonID) {
        let skeleton = new Skeleton();
        this.buildSkeleton(skeleton, void 0, skeletonID);
        return skeleton;
      }
      parseSkeletonAnimation(skeleton, animation) {
        let inputAccessor = this.subParser.parseAccessor(animation.samplers[0].input);
        let numFrame = inputAccessor.data.length;
        let frameRate = inputAccessor.data[1] - inputAccessor.data[0];
        inputAccessor.data[inputAccessor.data.length - 1];
        let skeletonPoseLength = 12 * skeleton.numJoint;
        let bufferData = new Float32Array(skeletonPoseLength * numFrame);
        for (var index = 0; index < skeleton.numJoint; index++) {
          for (var nFrame = 0; nFrame < numFrame; nFrame++) {
            var dstOffset = skeletonPoseLength * nFrame + 12 * index;
            bufferData[dstOffset + 0] = 1;
            bufferData[dstOffset + 1] = 1;
            bufferData[dstOffset + 2] = 1;
            bufferData[dstOffset + 3] = 1;
          }
        }
        for (let channel of animation.channels) {
          let sampler = animation.samplers[channel.sampler];
          const inputAccessor2 = this.subParser.parseAccessor(sampler.input);
          const outputAccessor = this.subParser.parseAccessor(sampler.output);
          let nodeId = channel.target.node;
          let property = channel.target.path;
          let node = this.gltf.nodes[nodeId];
          if (!node) {
            continue;
          }
          let joint = skeleton.getJointByName(node.name);
          if (!joint) ; else {
            switch (property) {
              case "scale":
                if (numFrame * outputAccessor.numComponents == outputAccessor.data.length) {
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    var srcOffset = nFrame * outputAccessor.numComponents;
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index;
                    bufferData[dstOffset + 0] = outputAccessor.data[srcOffset + 0];
                    bufferData[dstOffset + 1] = outputAccessor.data[srcOffset + 1];
                    bufferData[dstOffset + 2] = outputAccessor.data[srcOffset + 2];
                    bufferData[dstOffset + 3] = 1;
                  }
                } else if (inputAccessor2.data.length == 2) {
                  let time = 0;
                  inputAccessor2.data[0];
                  let t1 = inputAccessor2.data[1];
                  var srcOffsetA = 0 * outputAccessor.numComponents;
                  Vector3.HELP_0.set(
                    outputAccessor.data[srcOffsetA + 0],
                    outputAccessor.data[srcOffsetA + 1],
                    outputAccessor.data[srcOffsetA + 2]
                  );
                  var srcOffsetB = 1 * outputAccessor.numComponents;
                  Vector3.HELP_1.set(
                    outputAccessor.data[srcOffsetB + 0],
                    outputAccessor.data[srcOffsetB + 1],
                    outputAccessor.data[srcOffsetB + 2]
                  );
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    let t = time / t1;
                    Vector3.HELP_2.lerp(Vector3.HELP_0, Vector3.HELP_1, t);
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index;
                    bufferData[dstOffset + 0] = Vector3.HELP_2.x;
                    bufferData[dstOffset + 1] = Vector3.HELP_2.y;
                    bufferData[dstOffset + 2] = Vector3.HELP_2.z;
                    bufferData[dstOffset + 3] = 1;
                    time += frameRate;
                  }
                } else
                  throw new Error("Unsupported animation sampler interpolation.");
                break;
              case "rotation":
                if (numFrame * outputAccessor.numComponents == outputAccessor.data.length) {
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    var srcOffset = nFrame * outputAccessor.numComponents;
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index + 4;
                    bufferData[dstOffset + 0] = outputAccessor.data[srcOffset + 0];
                    bufferData[dstOffset + 1] = outputAccessor.data[srcOffset + 1];
                    bufferData[dstOffset + 2] = outputAccessor.data[srcOffset + 2];
                    bufferData[dstOffset + 3] = outputAccessor.data[srcOffset + 3];
                  }
                } else if (inputAccessor2.data.length == 2) {
                  let time = 0;
                  inputAccessor2.data[0];
                  let t1 = inputAccessor2.data[1];
                  var srcOffsetA = 0 * outputAccessor.numComponents;
                  Vector3.HELP_0.set(
                    outputAccessor.data[srcOffsetA + 0],
                    outputAccessor.data[srcOffsetA + 1],
                    outputAccessor.data[srcOffsetA + 2],
                    outputAccessor.data[srcOffsetA + 3]
                  );
                  var srcOffsetB = 1 * outputAccessor.numComponents;
                  Vector3.HELP_1.set(
                    outputAccessor.data[srcOffsetB + 0],
                    outputAccessor.data[srcOffsetB + 1],
                    outputAccessor.data[srcOffsetB + 2],
                    outputAccessor.data[srcOffsetB + 3]
                  );
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    let t = time / t1;
                    Vector3.HELP_2.lerp(Vector3.HELP_0, Vector3.HELP_1, t);
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index + 4;
                    bufferData[dstOffset + 0] = Vector3.HELP_2.x;
                    bufferData[dstOffset + 1] = Vector3.HELP_2.y;
                    bufferData[dstOffset + 2] = Vector3.HELP_2.z;
                    bufferData[dstOffset + 3] = Vector3.HELP_2.w;
                    time += frameRate;
                  }
                } else
                  throw new Error("Unsupported animation sampler interpolation.");
                break;
              case "translation":
                if (numFrame * outputAccessor.numComponents == outputAccessor.data.length) {
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    var srcOffset = nFrame * outputAccessor.numComponents;
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index + 8;
                    bufferData[dstOffset + 0] = outputAccessor.data[srcOffset + 0];
                    bufferData[dstOffset + 1] = outputAccessor.data[srcOffset + 1];
                    bufferData[dstOffset + 2] = outputAccessor.data[srcOffset + 2];
                    bufferData[dstOffset + 3] = inputAccessor2.data[nFrame * inputAccessor2.numComponents];
                  }
                } else if (inputAccessor2.data.length == 2) {
                  let time = 0;
                  inputAccessor2.data[0];
                  let t1 = inputAccessor2.data[1];
                  var srcOffsetA = 0 * outputAccessor.numComponents;
                  Vector3.HELP_0.set(
                    outputAccessor.data[srcOffsetA + 0],
                    outputAccessor.data[srcOffsetA + 1],
                    outputAccessor.data[srcOffsetA + 2]
                  );
                  var srcOffsetB = 1 * outputAccessor.numComponents;
                  Vector3.HELP_1.set(
                    outputAccessor.data[srcOffsetB + 0],
                    outputAccessor.data[srcOffsetB + 1],
                    outputAccessor.data[srcOffsetB + 2]
                  );
                  for (var nFrame = 0; nFrame < numFrame; nFrame++) {
                    let t = time / t1;
                    Vector3.HELP_2.lerp(Vector3.HELP_0, Vector3.HELP_1, t);
                    var dstOffset = skeletonPoseLength * nFrame + 12 * joint.index + 8;
                    bufferData[dstOffset + 0] = Vector3.HELP_2.x;
                    bufferData[dstOffset + 1] = Vector3.HELP_2.y;
                    bufferData[dstOffset + 2] = Vector3.HELP_2.z;
                    bufferData[dstOffset + 3] = time;
                    time += frameRate;
                  }
                } else
                  throw new Error("Unsupported animation sampler interpolation.");
                break;
            }
          }
        }
        let animationClip = new SkeletonAnimationClip(animation.name, skeleton, numFrame, bufferData);
        return animationClip;
      }
      buildSkeleton(skeleton, parent, nodeId, depth = 0) {
        let node = this.gltf.nodes[nodeId];
        if (!node.name) {
          node.name = "Node_" + nodeId;
        }
        let joint = new Joint(node.name);
        joint.parent = parent;
        if (node.scale) {
          joint.scale.set(node.scale[0], node.scale[1], node.scale[2]);
        }
        if (node.rotation) {
          joint.rotation.set(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]);
        }
        if (node.translation) {
          joint.translation.set(node.translation[0], node.translation[1], node.translation[2]);
        }
        skeleton.addJoint(joint);
        if (node.children) {
          for (let children of node.children) {
            this.buildSkeleton(skeleton, joint, children, depth + 1);
          }
        }
      }
    }

    class SkeletonAnimationClipState {
      loop = true;
      speed = 1;
      t = 0;
      time = 0;
      weight = 0;
      currFrame = 0;
      lastFrame = -1;
      nextFrame = 0;
      clip;
      animation;
      _isEnd = false;
      _currSkeletonPose;
      constructor(clip) {
        this.clip = clip;
        this._currSkeletonPose = new SkeletonPose(this.clip.skeleton);
      }
      reset() {
        this.time = 0;
        this.weight = 0;
        this._isEnd = false;
      }
      /** 
      * Returns animation clip's name.
      */
      get name() {
        return this.clip.name;
      }
      /** 
      * Returns current skeleton pose.
      */
      get currSkeletonPose() {
        return this._currSkeletonPose;
      }
      /** 
      * update animation clip, it will change key frame to sample animation clip.
      * @param delta time from last frame to now
      */
      update(delta) {
        this.time = (this.time + delta * this.speed) % this.clip.totalTime;
        let frameTime = this.time / this.clip.frameRate;
        this.currFrame = Math.trunc(frameTime);
        this.t = frameTime - this.currFrame;
        if (this.currFrame < 0) {
          this.currFrame = this.clip.numFrame + this.currFrame;
        }
        if (this.time >= 0) {
          this.nextFrame = (this.currFrame + 1) % this.clip.numFrame;
        } else {
          this.nextFrame = this.currFrame - 1;
          if (this.nextFrame < 0) {
            this.nextFrame = this.clip.numFrame + this.nextFrame;
          }
          this.t = 1 - this.t;
        }
        if (this._isEnd) {
          this.currFrame = this.nextFrame = this.speed < 0 ? 0 : this.clip.numFrame - 1;
        } else if (this.currFrame != this.lastFrame) {
          let endFrame = this.speed < 0 ? 0 : this.clip.numFrame;
          if (this.currFrame == endFrame) {
            if (this.loop) {
              this.currFrame = 0;
              this.nextFrame = 1;
              this.time = this.t = 0;
            } else {
              this.currFrame = this.nextFrame = this.speed < 0 ? 0 : this.clip.numFrame - 1;
              this._isEnd = true;
            }
          }
          var events = this.clip.getEvents();
          if (events) {
            for (let event of events) {
              var triggerFrame = Math.floor(event.time / this.clip.frameRate);
              triggerFrame = Math.min(triggerFrame, this.clip.numFrame);
              triggerFrame = Math.max(triggerFrame, 0);
              if (triggerFrame == this.currFrame) {
                event.skeletonAnimation = this.animation;
                this.animation.eventDispatcher.dispatchEvent(event);
                break;
              }
            }
          }
          this.lastFrame = this.currFrame;
        }
        this.clip.getLerpSkeletonPose(this.currFrame, this.nextFrame, this.t, this._currSkeletonPose);
      }
    }

    var __defProp$i = Object.defineProperty;
    var __getOwnPropDesc$i = Object.getOwnPropertyDescriptor;
    var __decorateClass$i = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$i(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$i(target, key, result);
      return result;
    };
    exports.SkeletonAnimationComponent = class SkeletonAnimationComponent extends ComponentBase {
      /**
       * Whether it is playing
       */
      isPlaying = true;
      /**
       * Global animation time scaling
       */
      timeScale = 1;
      _skeleton;
      _clips = [];
      _clipStates = /* @__PURE__ */ new Map();
      _mixSkeletonPose;
      _mixTempSkeletonPose;
      _currentClipState;
      _bindList = [];
      _jointMatrixIndexTableBuffer;
      _crossFadeState;
      constructor() {
        super();
      }
      start() {
      }
      /**
       * The name of the currently playing animation
       */
      get currName() {
        if (this._currentClipState) {
          return this._currentClipState.name;
        }
        return "";
      }
      /**
       * Skeleton data
       */
      set skeleton(value) {
        this._skeleton = value;
        this._mixSkeletonPose = new SkeletonPose(this._skeleton, true);
        this._mixTempSkeletonPose = new SkeletonPose(this._skeleton);
        const jointMatrixIndexTable = new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);
        this._jointMatrixIndexTableBuffer = new StorageGPUBuffer(this._skeleton.numJoint * 4, 0, jointMatrixIndexTable);
      }
      /**
       * Skeleton data
       */
      get skeleton() {
        return this._skeleton;
      }
      /**
       * Current final skeleton posture data
       */
      get finalSkeletonPose() {
        return this._mixSkeletonPose;
      }
      /**
       * Bone matrix index table data
       */
      get jointMatrixIndexTableBuffer() {
        return this._jointMatrixIndexTableBuffer;
      }
      /**
       * Get the bone index information by the bone name
       * @param skinJointsName bone name
       * @returns bone index
       */
      getJointIndexTable(skinJointsName) {
        let result = new Array();
        for (let i = 0; i < skinJointsName.length; i++) {
          const name = skinJointsName[i];
          let joint = this._skeleton.getJointByName(name);
          result[i] = joint ? joint.index : -1;
        }
        return result;
      }
      /**
       * Add a skeleton animation clip
       * @param clip Skeletal animation clip
       */
      addAnimationClip(clip) {
        if (!this._clipStates.has(clip.name)) {
          this._clips.push(clip);
          let clipState = new SkeletonAnimationClipState(clip);
          clipState.animation = this;
          this._clipStates.set(clip.name, clipState);
          if (!this._currentClipState) {
            this.setCurrentClipState(clipState);
          }
        }
      }
      /**
       * Gets the animation clip data object with the specified name
       * @param name Name of animation
       * @returns Animation clip data object
       */
      getAnimationClip(name) {
        var clipState = this.getAnimationClipState(name);
        if (clipState) {
          return clipState.clip;
        }
        return null;
      }
      /**
       * Gets all animation clip data objects
       * @returns Animation clip data object
       */
      getAnimationClips() {
        return this._clips;
      }
      /**
       * Gets the animation clip state object with the specified name
       * @param name Name of animation
       * @returns Animation clip state object
       */
      getAnimationClipState(name) {
        if (this._clipStates.has(name)) {
          return this._clipStates.get(name);
        }
        return null;
      }
      /**
       * Gets all animation clip state objects
       * @returns Animation clip state object
       */
      getAnimationClipStates() {
        return this._clipStates;
      }
      /**
       * stop playing
       */
      pause() {
        this.isPlaying = false;
      }
      /**
       * Resume playback
       */
      resume() {
        this.isPlaying = true;
      }
      /**
       * Play the specified animation
       * @param animName The data set name for the animation
       * @param speed Animation playback speed, default value is 1.0
       * @param reset When true, each play starts with the first frame
       * @returns
       */
      play(animName, speed = 1, reset = false) {
        if (this._currentClipState && this._currentClipState.name == animName) {
          if (reset) {
            this._currentClipState.reset();
          }
          return false;
        }
        let clipState = this.getAnimationClipState(animName);
        if (!clipState) {
          return false;
        }
        clipState.speed = speed;
        clipState.reset();
        this._clipStates.forEach((clipState2, name) => {
          clipState2.weight = 0;
        });
        this.setCurrentClipState(clipState);
        return true;
      }
      /**
       * Fades the current animation and fades into another animation state for a specified time.
       * @param animName The name of the animation to fade in.
       * @param crossTime The time of transition, in seconds.
       * @returns
       */
      crossFade(animName, crossTime) {
        if (crossTime < 0.01) {
          this.play(animName);
          return;
        }
        if (this._currentClipState.name == animName) {
          return;
        }
        let clipState = this.getAnimationClipState(animName);
        if (!clipState) {
          return;
        }
        clipState.reset();
        if (this._crossFadeState) {
          if (this._crossFadeState.inClip) {
            this._crossFadeState.inClip.weight = 0;
          }
          if (this._crossFadeState.outClip) {
            this._crossFadeState.outClip.weight = 0;
          }
          this._crossFadeState.reset(clipState, this._currentClipState, crossTime);
        } else {
          this._crossFadeState = new SkeletonAnimationCrossFadeState(
            clipState,
            this._currentClipState,
            crossTime
          );
        }
        this._currentClipState = clipState;
      }
      /**
       * Set the animation loop
       * @param animName The data set name for the animation
       * @param isLoop   If true, loop the animation
       */
      setAnimIsLoop(animName, isLoop) {
        if (this._clipStates.has(animName)) {
          this._clipStates.get(animName).loop = isLoop;
        }
      }
      /**
       * Add joint bindings to the object
       * @param jointName Name of joint
       * @param obj       Object of binding
       */
      addJointBind(jointName, obj) {
        this._bindList.push({
          jointName,
          obj
        });
      }
      /**
       * Removes the joint binding of the specified object
       * @param jointName Name of joint
       * @param obj Object of binding
       */
      removeJointBind(obj) {
        for (let index = 0; index < this._bindList.length; index++) {
          let item = this._bindList[index];
          if (item.obj == obj) {
            this._bindList.splice(index, 1);
            break;
          }
        }
      }
      /**
       * @internal
       */
      onUpdate() {
        if (!this.isPlaying) {
          return;
        }
        let delta = Time.delta * 1e-3 * this.timeScale;
        if (this._crossFadeState) {
          this._crossFadeState.update(delta);
        }
        var totalWeight = 0;
        var mixClipState = [];
        this._clipStates.forEach((clipState, name) => {
          if (clipState.weight > 0) {
            clipState.update(delta);
            totalWeight += clipState.weight;
            mixClipState.push(clipState);
          }
        });
        if (mixClipState.length > 0) {
          this._mixSkeletonPose.copyFrom(mixClipState[0].currSkeletonPose);
          for (var i = 1; i < mixClipState.length; ++i) {
            const clipState = mixClipState[i];
            this._mixTempSkeletonPose.lerp(this._mixSkeletonPose, clipState.currSkeletonPose, clipState.weight / totalWeight);
            this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose);
          }
        }
      }
      /**
       * Clones the current component to the specified object
       * @param obj target object
       */
      cloneTo(obj) {
        let animator = obj.addComponent(exports.SkeletonAnimationComponent);
        animator.skeleton = this.skeleton;
        for (var i = 0; i < this._clips.length; ++i) {
          animator.addAnimationClip(this._clips[i]);
        }
      }
      setCurrentClipState(clipState) {
        if (this._currentClipState == clipState) {
          return;
        }
        this._currentClipState = clipState;
        this._currentClipState.weight = 1;
      }
    };
    exports.SkeletonAnimationComponent = __decorateClass$i([
      RegisterComponent(exports.SkeletonAnimationComponent, "SkeletonAnimationComponent")
    ], exports.SkeletonAnimationComponent);
    class SkeletonAnimationCrossFadeState {
      inClip;
      outClip;
      currentTime;
      crossFadeTime;
      constructor(inClip, outClip, time) {
        this.reset(inClip, outClip, time);
      }
      reset(inClip, outClip, time) {
        this.inClip = inClip;
        this.outClip = outClip;
        this.currentTime = 0;
        this.crossFadeTime = time;
      }
      update(delta) {
        if (!this.inClip || !this.outClip) {
          return;
        }
        this.currentTime += delta;
        this.inClip.weight = Math.min(Math.abs(this.currentTime % this.crossFadeTime) / this.crossFadeTime, 1);
        this.outClip.weight = 1 - this.inClip.weight;
        if (Math.abs(this.currentTime) >= this.crossFadeTime) {
          this.inClip.weight = 1;
          this.outClip.weight = 0;
          this.inClip = null;
          this.outClip = null;
        }
      }
    }

    class GILighting {
      static list = [];
      static add(light) {
        let index = this.list.indexOf(light);
        if (index == -1) {
          this.list.push(light);
        }
      }
      static remove(light) {
        let index = this.list.indexOf(light);
        if (index != -1) {
          this.list.splice(index, 1);
        }
      }
    }

    class LightBase extends ComponentBase {
      /**
       * light name
       */
      name;
      /**
       * light size
       */
      size = 1;
      /**
       * light source data
       */
      lightData;
      /**
       * fix light direction
       */
      dirFix = 1;
      /**
       * Callback function when binding changes
       */
      bindOnChange;
      needUpdateShadow = true;
      /**
       * Whether to enable real-time rendering of shadows
       */
      realTimeShadow = true;
      _castGI = false;
      _castShadow = false;
      _iesProfiles;
      constructor() {
        super();
      }
      init() {
        this.transform.object3D.bound = new BoundingBox(new Vector3(), new Vector3());
        this.lightData = new LightData();
        this.lightData.lightMatrixIndex = this.transform.worldMatrix.index;
      }
      onChange() {
        if (this.bindOnChange)
          this.bindOnChange();
        this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition, new Vector3(this.size, this.size, this.size));
        if (this._castGI) {
          EntityCollect.instance.state.giLightingChange = true;
        }
        if (this._castShadow) {
          this.needUpdateShadow = true;
          ShadowLightsCollect.addShadowLight(this);
        } else {
          ShadowLightsCollect.removeShadowLight(this);
        }
      }
      start() {
        this.transform.onPositionChange = () => this.onPositionChange();
        this.transform.onScaleChange = () => this.onScaleChange();
        this.transform.onRotationChange = () => this.onRotChange();
        this.onPositionChange();
        this.onRotChange();
        this.onScaleChange();
      }
      onPositionChange() {
        this.lightData.lightPosition.copyFrom(this.transform.worldPosition);
      }
      onRotChange() {
        if (this.dirFix == 1) {
          this.lightData.direction.copyFrom(this.transform.forward);
        } else {
          this.lightData.direction.copyFrom(this.transform.back);
        }
        this.lightData.lightTangent.copyFrom(this.transform.up);
        this.onChange();
      }
      onScaleChange() {
        this.onChange();
      }
      onEnable() {
        this.onChange();
        EntityCollect.instance.addLight(this.transform.scene3D, this);
      }
      onDisable() {
        this.onChange();
        EntityCollect.instance.removeLight(this.transform.scene3D, this);
        ShadowLightsCollect.removeShadowLight(this);
      }
      set iesProfiles(iesProfiles) {
        this._iesProfiles = iesProfiles;
        this.lightData.iesIndex = iesProfiles.index;
        IESProfiles.use = true;
        this.onChange();
      }
      get iesProfile() {
        return this._iesProfiles;
      }
      /**
       * Get the red component of the lighting color
       */
      get r() {
        return this.lightData.lightColor.r;
      }
      /**
       * Set the red component of the lighting color
       */
      set r(value) {
        this.lightData.lightColor.r = value;
        this.onChange();
      }
      /**
       * Get the green component of the lighting color
       */
      get g() {
        return this.lightData.lightColor.g;
      }
      /**
       * Set the green component of the lighting color
       */
      set g(value) {
        this.lightData.lightColor.g = value;
        this.onChange();
      }
      /**
       * Get the blue component of the lighting color
       */
      get b() {
        return this.lightData.lightColor.b;
      }
      /**
       * Set the blue component of the lighting color
       */
      set b(value) {
        this.lightData.lightColor.b = value;
        this.onChange();
      }
      /**
       * Get light source color
       * @return Color
       */
      get lightColor() {
        return this.lightData.lightColor;
      }
      /**
       * Set light source color
       * @param Color
       */
      set lightColor(value) {
        this.lightData.lightColor = value;
        this.onChange();
      }
      /**
       * Get light source color
       * @return Color
       */
      get color() {
        return this.lightData.lightColor;
      }
      /**
       * Set light source color
       * @param Color
       */
      set color(value) {
        this.lightData.lightColor = value;
        this.onChange();
      }
      /**
       * Get Illumination intensity of light source
       * @return number
       */
      get intensity() {
        return this.lightData.intensity;
      }
      /**
       * Set Illumination intensity of light source
       * @param value
       */
      set intensity(value) {
        this.lightData.intensity = value;
        this.onChange();
      }
      /**
       * Cast Light Shadow
       * @param value 
       *  */
      set castShadow(value) {
        if (value != this._castShadow) {
          this._castShadow = value;
          this.onChange();
        }
      }
      get castShadow() {
        return this._castShadow;
      }
      /**
       * get shadow index at shadow map list
       */
      get shadowIndex() {
        return this.lightData.castShadowIndex;
      }
      /**
      * get gi is enable 
      * @return boolean
      *  */
      get castGI() {
        return this._castGI;
      }
      /**
       * set gi is enable 
       * @param value  
       *  */
      set castGI(value) {
        if (value) {
          GILighting.add(this);
        } else {
          GILighting.remove(this);
        }
        this._castGI = value;
        if (value)
          this.onChange();
      }
      /**
       * light source direction
       * @return Vector3
       *  */
      get direction() {
        return this.lightData.direction;
      }
      destroy(force) {
        this.bindOnChange = null;
        EntityCollect.instance.removeLight(this.transform.scene3D, this);
        ShadowLightsCollect.removeShadowLight(this);
        this.transform.eventDispatcher.removeEventListener(Transform.ROTATION_ONCHANGE, this.onRotChange, this);
        this.transform.eventDispatcher.removeEventListener(Transform.SCALE_ONCHANGE, this.onScaleChange, this);
        super.destroy(force);
      }
    }

    var __defProp$h = Object.defineProperty;
    var __getOwnPropDesc$h = Object.getOwnPropertyDescriptor;
    var __decorateClass$h = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$h(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$h(target, key, result);
      return result;
    };
    exports.DirectLight = class DirectLight extends LightBase {
      shadowCamera;
      constructor() {
        super();
      }
      init() {
        super.init();
        if (this.object3D.name == "") {
          this.object3D.name = "DirectionLight_" + UUID();
        }
        this.radius = Number.MAX_SAFE_INTEGER;
        this.lightData.lightType = LightType.DirectionLight;
        this.lightData.linear = 0;
        this.lightData.quadratic = 0.3;
      }
      start() {
        super.start();
        this.castGI = true;
      }
      /**
       *
       * Get the radius of a directional light source
       */
      get radius() {
        return this.lightData.range;
      }
      /**
       * Set the radius of a directional light source
       */
      set radius(value) {
        this.lightData.range = value;
        this.onChange();
      }
      /**
       *
       * Get the radius of a directional light source
       */
      get indirect() {
        return this.lightData.quadratic;
      }
      /**
       * Set the radius of a directional light source
       */
      set indirect(value) {
        this.lightData.quadratic = value;
        this.onChange();
      }
      // /**
      //  * Set cast shadow
      //  * @param value
      //  **/
      // public set castShadow(value: boolean) {
      //     if (value != this._castShadow) {
      //         this.onChange();
      //     }
      //     this._castShadow = value;
      // }
      // /**
      //  * get cast shadow
      //  * @return boolean
      //  * */
      // public get castShadow(): boolean {
      //     return this.lightData.castShadowIndex as number >= 0;
      // }
      /**
       * enable light debug gui
       */
      debug() {
      }
    };
    exports.DirectLight = __decorateClass$h([
      RegisterComponent(exports.DirectLight, "DirectLight")
    ], exports.DirectLight);

    var __defProp$g = Object.defineProperty;
    var __getOwnPropDesc$g = Object.getOwnPropertyDescriptor;
    var __decorateClass$g = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$g(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$g(target, key, result);
      return result;
    };
    exports.PointLight = class PointLight extends LightBase {
      constructor() {
        super();
      }
      init() {
        super.init();
        this.lightData.lightType = LightType.PointLight;
        if (this.object3D.name == "") {
          this.object3D.name = "PointLight" + UUID();
        }
      }
      /**
       *
       * Get the range of the light source
       * @return {number}
       */
      get range() {
        return this.lightData.range;
      }
      /**
       *
       * Set the range of the light source
       * @param {number}
       */
      set range(value) {
        this.lightData.range = value;
        this.onChange();
      }
      /**
       *
       * Get the illumination distance of the light source
       * @type {number}
       * @memberof PointLight
       */
      get at() {
        return this.lightData.linear;
      }
      /**
       *
       * Set the illumination distance of the light source
       * @param {value} It will decay linearly from the maximum value to the current light position at a distance of 0, 
       * with a default value of 0. This means that the intensity of the light will not decrease due to distance
       * @memberof PointLight
       */
      set at(value) {
        this.lightData.linear = value;
        this.onChange();
      }
      /**
       * Get the radius to control the light
       */
      get radius() {
        return this.lightData.radius;
      }
      /**
       * Set the radius of the control light
       */
      set radius(value) {
        this.lightData.radius = value;
        this.onChange();
      }
      /**
       * Get the radius to control the light
       */
      get quadratic() {
        return this.lightData.quadratic;
      }
      /**
       * Set the radius of the control light
       */
      set quadratic(value) {
        this.lightData.quadratic = value;
        this.onChange();
      }
      start() {
        this.transform.rotationX = 90;
        super.start();
      }
      onUpdate() {
      }
      onGraphic(view) {
      }
      /**
       *  enable GUI debug
       */
      debug() {
      }
      debugDraw(show) {
      }
    };
    exports.PointLight = __decorateClass$g([
      RegisterComponent(exports.PointLight, "PointLight")
    ], exports.PointLight);

    var __defProp$f = Object.defineProperty;
    var __getOwnPropDesc$f = Object.getOwnPropertyDescriptor;
    var __decorateClass$f = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$f(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$f(target, key, result);
      return result;
    };
    exports.SpotLight = class SpotLight extends LightBase {
      constructor() {
        super();
      }
      init() {
        super.init();
        this.lightData.lightType = LightType.SpotLight;
        if (this.object3D.name == "") {
          this.object3D.name = "SpotLight" + UUID();
        }
      }
      /**
       * Get the inner cone angle of the light source (as a percentage relative to the outer cone angle)
       */
      get innerAngle() {
        return this.lightData.innerAngle / this.lightData.outerAngle * 100;
      }
      /**
       *
       * Set the inner cone angle of the light source (as a percentage relative to the outer cone angle)
       * @param {value} 0.0 - 100.0
       */
      set innerAngle(value) {
        this.lightData.innerAngle = clamp(value, 0, 100) / 100 * this.lightData.outerAngle;
        this.onChange();
      }
      /**
       * Get the outer cone angle of the light source
       * @return number
       */
      get outerAngle() {
        return this.lightData.outerAngle * RADIANS_TO_DEGREES * 2;
      }
      /**
       * Set the outer cone angle of the light source
       * @param {value} 1.0 - 179.0
       */
      set outerAngle(value) {
        this.lightData.outerAngle = clamp(value, 1, 179) * DEGREES_TO_RADIANS * 0.5;
        this.onChange();
      }
      /**
       *
       * Get the radius of the light source
       * @return number
       */
      get radius() {
        return this.lightData.radius;
      }
      /**
       *
       * Set the radius of the light source
       * @param {value}
       */
      set radius(value) {
        this.lightData.radius = value;
        this.onChange();
      }
      /**
       * Get the range of the light source
       */
      get range() {
        return this.lightData.range;
      }
      /**
       *
       * Set the range of the light source
       * @param {value}
       */
      set range(value) {
        this.lightData.range = value;
        this.onChange();
      }
      /**
       * Get the illumination distance of the light source
       */
      get at() {
        return this.lightData.linear;
      }
      /**
       * Set the illumination distance of the light source
       */
      set at(value) {
        this.lightData.linear = value;
        this.onChange();
      }
      start() {
        super.start();
        this.lightData.lightType = LightType.SpotLight;
      }
      onUpdate() {
      }
      onGraphic(view) {
      }
      /**
       * enable GUI debug
       */
      debug() {
      }
      debugDraw(show) {
      }
    };
    exports.SpotLight = __decorateClass$f([
      RegisterComponent(exports.SpotLight, "SpotLight")
    ], exports.SpotLight);

    var __defProp$e = Object.defineProperty;
    var __getOwnPropDesc$e = Object.getOwnPropertyDescriptor;
    var __decorateClass$e = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$e(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$e(target, key, result);
      return result;
    };
    exports.SkinnedMeshRenderer = class SkinnedMeshRenderer extends exports.MeshRenderer {
      skinJointsName;
      mInverseBindMatrixData;
      mInverseBindMatrixBuffer;
      mSkeletonAnimation;
      mJointIndexTableBuffer;
      constructor() {
        super();
        this.addRendererMask(RendererMask.SkinnedMesh);
      }
      start() {
        super.start();
        this.skeletonAnimation = this.object3D.getComponent(exports.SkeletonAnimationComponent);
        if (!this.skeletonAnimation) {
          let comps = this.object3D.parentObject.parentObject.getComponentsInChild(exports.SkeletonAnimationComponent);
          if (comps.length > 0) {
            this.skeletonAnimation = comps[0];
          }
          let parentObj = this.object3D;
          while (!this.skeletonAnimation && parentObj) {
            this.skeletonAnimation = parentObj.getComponentFromParent(exports.SkeletonAnimationComponent);
            if (parentObj.parent) {
              parentObj = parentObj.parent.object3D;
            }
          }
        }
      }
      onEnable() {
        super.onEnable();
      }
      get skeletonAnimation() {
        return this.mSkeletonAnimation;
      }
      set skeletonAnimation(value) {
        this.mSkeletonAnimation = value;
        if (!value) {
          return;
        }
        if (!this.mJointIndexTableBuffer) {
          let skinJointIndexData = this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);
          this.mJointIndexTableBuffer = new StorageGPUBuffer(skinJointIndexData.length * 4, 0, new Float32Array(skinJointIndexData));
          this.mJointIndexTableBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
        }
      }
      get skinInverseBindMatrices() {
        return this.mInverseBindMatrixData;
      }
      set skinInverseBindMatrices(inverseBindMatrices) {
        this.mInverseBindMatrixData = inverseBindMatrices;
        var inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16);
        for (let i = 0; i < inverseBindMatrices.length; i++) {
          let index = i * 16;
          let mat4x4 = inverseBindMatrices[i];
          inverseBindMatricesData.set(mat4x4, index);
        }
        this.mInverseBindMatrixBuffer = new StorageGPUBuffer(inverseBindMatricesData.byteLength, 0, inverseBindMatricesData);
        this.mInverseBindMatrixBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
      }
      get inverseBindMatrixBuffer() {
        return this.mInverseBindMatrixBuffer;
      }
      get jointIndexTableBuffer() {
        return this.mJointIndexTableBuffer.buffer;
      }
      cloneTo(obj) {
        let skinnedMesh = obj.addComponent(exports.SkinnedMeshRenderer);
        skinnedMesh.geometry = this.geometry;
        skinnedMesh.material = this.material.clone();
        skinnedMesh.castShadow = this.castShadow;
        skinnedMesh.castGI = this.castGI;
        skinnedMesh.receiveShadow = this.receiveShadow;
        skinnedMesh.rendererMask = this.rendererMask;
        skinnedMesh.skinJointsName = this.skinJointsName;
        skinnedMesh.skinInverseBindMatrices = this.skinInverseBindMatrices;
        skinnedMesh.mJointIndexTableBuffer = this.mJointIndexTableBuffer;
      }
      /**
       * @internal
       * @param passType
       * @param renderPassState
       * @param scene3D
       * @param clusterLightingRender
       * @param probes
       */
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        for (let i = 0; i < this.materials.length; i++) {
          const material = this.materials[i];
          let passes = material.getPass(passType);
          if (passes)
            for (let i2 = 0; i2 < passes.length; i2++) {
              const renderShader = passes[i2];
              if (!renderShader.pipeline && this.mSkeletonAnimation) {
                renderShader.setStorageBuffer("jointsMatrixIndexTable", this.mSkeletonAnimation.jointMatrixIndexTableBuffer);
                renderShader.setStorageBuffer("jointsInverseMatrix", this.mInverseBindMatrixBuffer);
                renderShader.setStorageBuffer("jointsIndexMapingTable", this.mJointIndexTableBuffer);
              }
            }
        }
        super.nodeUpdate(view, passType, renderPassState, clusterLightingBuffer);
      }
    };
    exports.SkinnedMeshRenderer = __decorateClass$e([
      RegisterComponent(exports.SkinnedMeshRenderer, "SkinnedMeshRenderer")
    ], exports.SkinnedMeshRenderer);

    class KHR_materials_clearcoat {
      static apply(gltf, dmaterial, tMaterial) {
        let extensions = dmaterial.extensions;
        if (extensions && extensions[`KHR_materials_clearcoat`]) {
          tMaterial.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
          let KHR_materials_clearcoat2 = extensions[`KHR_materials_clearcoat`];
          if (`clearcoatFactor` in KHR_materials_clearcoat2) {
            dmaterial.clearcoatFactor = KHR_materials_clearcoat2[`clearcoatFactor`];
            tMaterial.clearcoatFactor = dmaterial.clearcoatFactor;
          }
          if (`clearcoatRoughnessFactor` in KHR_materials_clearcoat2) {
            dmaterial.clearcoatRoughnessFactor = KHR_materials_clearcoat2[`clearcoatRoughnessFactor`];
            tMaterial.clearcoatRoughnessFactor = dmaterial.clearcoatRoughnessFactor;
          }
        }
      }
    }

    class KHR_materials_emissive_strength {
      static apply(gltf, dmaterial, tMaterial) {
        let extensions = dmaterial.extensions;
        if (extensions && extensions[`KHR_materials_emissive_strength`]) {
          tMaterial.emissiveIntensity = extensions[`KHR_materials_emissive_strength`].emissiveStrength * 0.5;
          if (tMaterial.emissiveMap == Engine3D.res.blackTexture) {
            tMaterial.emissiveMap = Engine3D.res.whiteTexture;
          }
        } else {
          tMaterial.emissiveIntensity = 1;
        }
      }
    }

    class KHR_materials_unlit {
      static apply(gltf, dmaterial, tMaterial) {
        let extensions = dmaterial.extensions;
        if (extensions && extensions[`KHR_materials_unlit`]) {
          tMaterial.supportLight = true;
        } else {
          tMaterial.supportLight = false;
        }
      }
    }

    class GLTFSubParserConverter {
      gltf;
      subParser;
      _testCount = 8;
      _hasCastShadow = false;
      constructor(subParser) {
        this.gltf = subParser.gltf;
        this.subParser = subParser;
      }
      async convertNodeToObject3D(nodeInfo, parentNode) {
        const node = new exports.Object3D();
        node.name = nodeInfo.name;
        node[GLTFType.GLTF_NODE_INDEX_PROPERTY] = nodeInfo.nodeId;
        nodeInfo["nodeObj"] = node;
        if (nodeInfo.matrix) {
          nodeInfo.translation = [0, 0, 0];
          nodeInfo.rotation = [0, 0, 0, 1];
          nodeInfo.scale = [1, 1, 1];
        }
        if (nodeInfo.translation) {
          node.transform.x = nodeInfo.translation[0];
          node.transform.y = nodeInfo.translation[1];
          node.transform.z = nodeInfo.translation[2];
        }
        if (nodeInfo.rotation) {
          let qat = new Quaternion();
          qat.setFromArray(nodeInfo.rotation);
          node.transform.localRotQuat = qat;
        }
        if (nodeInfo.scale) {
          node.transform.scaleX = nodeInfo.scale[0];
          node.transform.scaleY = nodeInfo.scale[1];
          node.transform.scaleZ = nodeInfo.scale[2];
        }
        parentNode.addChild(node);
        if (nodeInfo.light) {
          this.convertLight(nodeInfo, node);
        }
        if (nodeInfo.primitives) {
          this.convertprimitives(nodeInfo, node);
        }
        if (nodeInfo["skeleton"]) {
          let skeletonAnimation = node.addComponent(exports.SkeletonAnimationComponent);
          if (skeletonAnimation) {
            skeletonAnimation.skeleton = this.subParser.parseSkeleton(nodeInfo["skeleton"].skeleton);
            for (let i = 0; i < this.gltf.animations.length; i++) {
              let animation = this.gltf.animations[i];
              if (!animation.name)
                animation.name = i.toString();
              let animationClip = this.subParser.parseSkeletonAnimation(skeletonAnimation.skeleton, animation);
              skeletonAnimation.addAnimationClip(animationClip);
            }
          }
        }
        return node;
      }
      convertLight(nodeInfo, node) {
        switch (nodeInfo.light.type) {
          case `directional`:
            let directLight = node.addComponent(exports.DirectLight);
            node.name = nodeInfo.light.name;
            directLight.intensity = nodeInfo.light.intensity * 0.1;
            directLight.radius = Number.MAX_SAFE_INTEGER;
            directLight.dirFix = -1;
            if (!this._hasCastShadow) {
              this._hasCastShadow = true;
              directLight.castShadow = this._hasCastShadow;
            }
            directLight.lightColor = nodeInfo.light.color ? new Color(nodeInfo.light.color[0], nodeInfo.light.color[1], nodeInfo.light.color[2]) : new Color(1, 1, 1, 1);
            directLight.debug();
            break;
          case `point`:
            if (this._testCount > 0) {
              let point = node.addComponent(exports.PointLight);
              point.name = nodeInfo.light.name;
              point.intensity = nodeInfo.light.intensity ? nodeInfo.light.intensity * 8 * 2 : 1;
              point.radius = 8;
              point.at = 2;
              point.range = nodeInfo.light.range ? nodeInfo.light.range : 8;
              point.lightColor = nodeInfo.light.color ? new Color(nodeInfo.light.color[0], nodeInfo.light.color[1], nodeInfo.light.color[2]) : new Color(1, 1, 1, 1);
            }
            this._testCount--;
            break;
          case `spot`:
            let spot = node.addComponent(exports.SpotLight);
            spot.name = nodeInfo.light.name;
            spot.intensity = nodeInfo.light.intensity * 5;
            spot.radius = 1;
            spot.dirFix = -1;
            spot.at = 2;
            spot.range = nodeInfo.light.range ? nodeInfo.light.range : 8;
            spot.outerAngle = nodeInfo.light.spot.outerConeAngle * RADIANS_TO_DEGREES;
            spot.lightColor = nodeInfo.light.color ? new Color(nodeInfo.light.color[0], nodeInfo.light.color[1], nodeInfo.light.color[2]) : new Color(1, 1, 1, 1);
            break;
        }
      }
      convertprimitives(nodeInfo, node) {
        for (let i = 0; i < nodeInfo.primitives.length; i++) {
          const primitive = nodeInfo.primitives[i];
          primitive.modelName;
          let md = primitive.material;
          if (md.name == void 0) {
            md.name = UUID();
          }
          let mat;
          let materialKey = `matkey_${md.name}`;
          if (md && this.gltf.resources[materialKey]) {
            mat = this.gltf.resources[materialKey];
          } else {
            let newMat = mat = new LitMaterial();
            this.gltf.resources[materialKey] = newMat;
            newMat.name = md.name;
            if (primitive.material) {
              const { baseColorTexture, baseColorFactor, metallicFactor, roughnessFactor, doubleSided, metallicRoughnessTexture, normalTexture, occlusionTexture, emissiveTexture, emissiveFactor, enableBlend, alphaCutoff } = primitive.material;
              let physicMaterial = newMat = this.applyMaterialExtensions(primitive.material, newMat);
              if (`enableBlend` in primitive.material) {
                if (primitive.material[`enableBlend`]) {
                  physicMaterial.blendMode = BlendMode.SOFT_ADD;
                } else {
                  physicMaterial.blendMode = BlendMode.NONE;
                }
              }
              if (`alphaCutoff` in primitive.material && alphaCutoff > 0 && alphaCutoff < 1) {
                physicMaterial.setUniformFloat("alphaCutoff", alphaCutoff);
                physicMaterial.blendMode = BlendMode.NORMAL;
                physicMaterial.transparent = true;
              }
              if (primitive.material.transformUV1) {
                physicMaterial.setUniformVector4("uvTransform_1", primitive.material.transformUV1);
              }
              if (primitive.material.transformUV2) {
                physicMaterial.setUniformVector4("uvTransform_2", primitive.material.transformUV2);
              }
              physicMaterial.setUniformColor("baseColor", new Color(baseColorFactor[0], baseColorFactor[1], baseColorFactor[2], baseColorFactor[3]));
              physicMaterial.setUniformFloat("roughness", roughnessFactor);
              physicMaterial.setUniformFloat("metallic", metallicFactor);
              physicMaterial.setUniformFloat("ao", 1);
              physicMaterial.doubleSide = doubleSided;
              if (baseColorTexture) {
                physicMaterial.setTexture("baseMap", baseColorTexture);
              }
              if (normalTexture) {
                physicMaterial.setTexture("normalMap", normalTexture);
              }
              if (metallicRoughnessTexture) {
                physicMaterial.setTexture("maskMap", metallicRoughnessTexture);
              }
              if (occlusionTexture && metallicRoughnessTexture != occlusionTexture) {
                physicMaterial.setTexture("aoMap", occlusionTexture);
              }
              if (emissiveTexture) {
                physicMaterial.setTexture("emissiveMap", emissiveTexture);
              }
              if (emissiveFactor && (emissiveFactor[0] > 0 || emissiveFactor[1] > 0 || emissiveFactor[2] > 0)) {
                if (!physicMaterial.shader.getTexture("emissiveMap")) {
                  physicMaterial.shader.setTexture("emissiveMap", Engine3D.res.whiteTexture);
                }
                physicMaterial.setUniformColor("emissiveColor", new Color(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], emissiveFactor[3]));
              }
            }
          }
          const { attribArrays, modelName, drawMode } = primitive;
          let geometry;
          if (!attribArrays[`indices`].data) {
            let indices = [];
            let count = attribArrays["position"].data.length / 3 / 3;
            for (let i2 = 0; i2 < count; i2++) {
              let a = i2 * 3;
              indices.push(a + 2);
              indices.push(a + 0);
              indices.push(a + 1);
            }
            attribArrays[`indices`] = {
              data: new Uint8Array(indices),
              normalize: false,
              numComponents: 1
            };
          }
          if (!attribArrays[`normal`]) {
            let normal = [];
            let count = attribArrays["position"].data.length / 3;
            for (let i2 = 0; i2 < count; i2++) {
              normal.push(0);
              normal.push(0);
              normal.push(0);
            }
            attribArrays[`normal`] = {
              data: new Float32Array(normal),
              normalize: false,
              numComponents: 3
            };
          }
          if (attribArrays[`indices`].data && attribArrays[`indices`].data.length > 3) {
            let meshName2 = primitive.meshName();
            if (this.gltf.resources[meshName2]) {
              geometry = this.gltf.resources[meshName2];
            } else {
              geometry ||= this.createGeometryBase(meshName2, attribArrays, primitive);
              this.gltf.resources[meshName2] = geometry;
            }
            const model = new exports.Object3D();
            model.name = modelName + i;
            if (this.gltf.animations && attribArrays[VertexAttributeName.joints0] != void 0) {
              geometry ||= this.createGeometryBase(modelName, attribArrays, primitive);
              this.gltf.resources[meshName2] = geometry;
              let skeletonNode = this.gltf.nodes[nodeInfo.skin.skeleton];
              if (skeletonNode.dnode && skeletonNode.dnode["nodeObj"]) {
                let node2 = skeletonNode.dnode["nodeObj"];
                let skeletonAnimation = node2.addComponent(exports.SkeletonAnimationComponent);
                if (skeletonAnimation) {
                  skeletonAnimation.skeleton = this.subParser.parseSkeleton(nodeInfo.skin.skeleton);
                  for (let i2 = 0; i2 < this.gltf.animations.length; i2++) {
                    let animation = this.gltf.animations[i2];
                    if (!animation.name)
                      animation.name = i2.toString();
                    let animationClip = this.subParser.parseSkeletonAnimation(skeletonAnimation.skeleton, animation);
                    skeletonAnimation.addAnimationClip(animationClip);
                  }
                }
              } else {
                skeletonNode.dnode["skeleton"] = nodeInfo.skin;
              }
              let smr = model.addComponent(exports.SkinnedMeshRenderer);
              smr.castShadow = true;
              smr.castGI = true;
              smr.geometry = geometry;
              smr.material = mat;
              smr.skinJointsName = this.parseSkinJoints(nodeInfo.skin);
              smr.skinInverseBindMatrices = nodeInfo.skin.inverseBindMatrices;
            } else {
              geometry ||= this.createGeometryBase(modelName, attribArrays, primitive);
              this.gltf.resources[meshName2] = geometry;
              if (geometry.hasAttribute(VertexAttributeName.joints0)) {
                geometry.vertexAttributeMap.delete(VertexAttributeName.joints0);
              }
              let mc = model.addComponent(exports.MeshRenderer);
              mc.castShadow = true;
              mc.castGI = true;
              mc.geometry = geometry;
              mc.material = mat;
            }
            nodeInfo.skin && nodeInfo.skin.defines || [];
            node.addChild(model);
          }
        }
      }
      createGeometryBase(name, attribArrays, primitive) {
        let geometry = new GeometryBase();
        geometry.name = name;
        if ("indices" in attribArrays) {
          let bigIndices = attribArrays[`indices`].data.length > 65535;
          if (bigIndices) {
            attribArrays[`indices`].data = new Uint32Array(attribArrays[`indices`].data);
          } else {
            attribArrays[`indices`].data = new Uint16Array(attribArrays[`indices`].data);
          }
        }
        geometry.morphTargetsRelative = primitive.morphTargetsRelative;
        let targetNames = primitive.targetNames;
        if (targetNames && targetNames.length > 0) {
          let morphTargetDictionary = geometry.morphTargetDictionary = {};
          for (let i = 0; i < targetNames.length; i++) {
            morphTargetDictionary[targetNames[i]] = i;
          }
        }
        if (geometry.morphTargetDictionary) {
          let vertexCount = attribArrays["position"].data.length / 3;
          let vIndexArray = new Float32Array(vertexCount);
          for (let i = 0; i < vertexCount; i++) {
            vIndexArray[i] = i;
          }
          attribArrays[`vIndex`] = {
            data: vIndexArray,
            normalize: false,
            numComponents: 1
          };
        }
        for (const attributeName in attribArrays) {
          let attributeData = attribArrays[attributeName];
          geometry.setAttribute(attributeName, attributeData.data);
        }
        let indicesAttribute = geometry.getAttribute(VertexAttributeName.indices);
        geometry.addSubGeometry(
          {
            indexStart: 0,
            indexCount: indicesAttribute.data.length,
            vertexStart: 0,
            index: 0,
            vertexCount: 0,
            firstStart: 0,
            topology: 0
          }
        );
        return geometry;
      }
      applyMaterialExtensions(dmaterial, mat) {
        KHR_materials_clearcoat.apply(this.gltf, dmaterial, mat);
        KHR_materials_unlit.apply(this.gltf, dmaterial, mat);
        KHR_materials_emissive_strength.apply(this.gltf, dmaterial, mat);
        return mat;
      }
      parseSkinJoints(skin) {
        let skinJointsName = [];
        for (let nodeId of skin.joints) {
          let node = this.gltf.nodes[nodeId];
          skinJointsName.push(node.name);
        }
        return skinJointsName;
      }
    }

    class GLTFSubParser {
      currentSceneName;
      gltf;
      initUrl;
      _generator;
      _version;
      _BASE64_MARKER = ";base64,";
      _cameraParser = null;
      _meshParser = null;
      _materialParser = null;
      _skinParser = null;
      _skeletonParser = null;
      _converter = null;
      constructor() {
      }
      get version() {
        if (this.version)
          return this.version;
        else if (this.gltf) {
          if (!this.gltf.asset)
            return this.errorMiss("asset");
          this._version = this.gltf.asset.version;
          if (this.gltf.asset.minVersion)
            this._version += `\r minVersion${this.gltf.asset.minVersion}`;
          return this.version;
        }
        console.warn("glTF not loaded.");
        return null;
      }
      async parse(initUrl, gltf, sceneId) {
        this.gltf = gltf;
        this.initUrl = initUrl;
        const { version, generator } = this.gltf.asset;
        this._generator = generator;
        if (version !== "2.0") {
          console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`);
          return false;
        }
        const result = {
          nodes: await this.parseScene(sceneId),
          animations: this.parseAnimations(),
          name: this.currentSceneName
        };
        return await this.convertToNode(result);
      }
      destory() {
        KHR_draco_mesh_compression.unload(this.gltf);
        this.gltf = null;
      }
      async parseScene(sceneId) {
        const loadScene = sceneId || this.gltf.scene || 0;
        const scene = this.gltf.scenes[loadScene];
        if (typeof scene === "undefined")
          return this.errorMiss("scene", loadScene);
        this.currentSceneName = scene.name || "GLTF_NO_NAME_SCENE";
        const result = [];
        const nodes = scene.nodes;
        for (let i = 0; i < nodes.length; i++) {
          const node = await this.parseNode(nodes[i]);
          if (node)
            result.push(node);
        }
        return result;
      }
      async parseNode(nodeId) {
        const node = this.gltf.nodes[nodeId];
        if (!node)
          return this.errorMiss("node", nodeId);
        if (node.isParsed)
          return node.dnode;
        const { name, matrix, translation, rotation, scale } = node;
        const dnode = {
          name,
          matrix,
          translation,
          rotation,
          scale,
          nodeId,
          camera: null,
          primitives: null,
          skin: null,
          children: null,
          light: null
        };
        if (node.camera !== void 0)
          dnode.camera = this.parseCamera(node.camera);
        if (node.mesh !== void 0)
          dnode.primitives = await this.parseMesh(node.mesh);
        if (node.extensions !== void 0)
          this.applyNodeExtensions(node, dnode);
        if (node.skin !== void 0) {
          const skin = this.parseSkin(node.skin);
          if (skin)
            dnode.skin = skin;
        }
        dnode.children = [];
        if (node.children)
          for (let i = 0; i < node.children.length; i++) {
            dnode.children.push(await this.parseNode(node.children[i]));
          }
        node.dnode = dnode;
        node.isParsed = true;
        return node.dnode;
      }
      errorMiss(e, info) {
        throw new Error(e + info);
      }
      parseCamera(cameraId) {
        if (!this._cameraParser) {
          this._cameraParser = new GLTFSubParserCamera(this.gltf);
        }
        return this._cameraParser.parse(cameraId);
      }
      async parseMesh(meshId) {
        if (!this._meshParser) {
          this._meshParser = new GLTFSubParserMesh(this);
        }
        return this._meshParser.parse(meshId);
      }
      async parseTexture(index) {
        let textureInfo = this.gltf.textures[index];
        if (textureInfo && !textureInfo.dtexture) {
          if (textureInfo && textureInfo.source != null) {
            let image = this.gltf.images[textureInfo.source];
            if (image.uri) {
              let name = image.uri;
              name = StringUtil.getURLName(name);
              textureInfo.dtexture = this.gltf.resources[name];
            } else if (image.bufferView) {
              let buffer = this.parseBufferView(image.bufferView);
              let bitmapTexture = new BitmapTexture2D();
              let img = new Blob([buffer], { type: image.mimeType });
              await bitmapTexture.loadFromBlob(img);
              textureInfo.dtexture = bitmapTexture;
            } else {
              textureInfo.dtexture = this.gltf.resources[image.name];
            }
          } else if (textureInfo.name) {
            let name = StringUtil.getURLName(textureInfo.name);
            textureInfo.dtexture = this.gltf.resources[name];
          }
        }
        if (!textureInfo.dtexture) {
          console.log("miss texture , please check texture!", index, textureInfo);
        }
        return textureInfo.dtexture;
      }
      async parseMaterial(materialId) {
        if (!this._materialParser) {
          this._materialParser = new GLTFSubParserMaterial(this);
        }
        return this._materialParser.parse(materialId);
      }
      parseAnimations() {
        const result = [];
        return result;
      }
      async parseObject3D(nodeInfo, parentNode) {
        if (!this._converter) {
          this._converter = new GLTFSubParserConverter(this);
        }
        return this._converter.convertNodeToObject3D(nodeInfo, parentNode);
      }
      parseSkeleton(skeletonID) {
        if (!this._skeletonParser) {
          this._skeletonParser = new GLTFSubParserSkeleton(this);
        }
        return this._skeletonParser.parse(skeletonID);
      }
      parseSkeletonAnimation(skeleton, animation) {
        if (!this._skeletonParser) {
          this._skeletonParser = new GLTFSubParserSkeleton(this);
        }
        return this._skeletonParser.parseSkeletonAnimation(skeleton, animation);
      }
      async traverse(parentNode, nodeInfos) {
        for (let i = 0; i < nodeInfos.length; i++) {
          const node = await this.parseObject3D(nodeInfos[i], parentNode);
          await this.traverse(node, nodeInfos[i].children);
        }
      }
      async convertToNode(infos) {
        const rootNode = new exports.Object3D();
        rootNode.name = infos.name;
        const nodes = infos.nodes;
        infos.animations;
        const textures = [];
        const cameras = [];
        await this.traverse(rootNode, nodes);
        let animas;
        return {
          rootNode,
          textures,
          animations: animas,
          cameras
        };
      }
      parseSkin(skinId) {
        if (!this._skinParser) {
          this._skinParser = new GLTFSubParserSkin(this);
        }
        return this._skinParser.parse(skinId);
      }
      parseAccessor(accessorId) {
        const accessor = this.gltf.accessors[accessorId];
        if (!accessor)
          return this.errorMiss("accessor", accessorId);
        if (accessor.isParsed)
          return accessor.daccessor;
        accessor.isParsed = true;
        accessor.daccessor = false;
        const normalize = !!accessor.normalized;
        const bufferView = this.gltf.bufferViews[accessor.bufferView];
        const byteStride = bufferView && bufferView.byteStride;
        const arrayType = getTypedArrayTypeFromGLType(accessor.componentType);
        let numComponents = 1;
        switch (accessor.type) {
          case "SCALAR":
            numComponents = 1;
            break;
          case "VEC2":
            numComponents = 2;
            break;
          case "VEC3":
            numComponents = 3;
            break;
          case "VEC4":
          case "MAT2":
            numComponents = 4;
            break;
          case "MAT3":
            numComponents = 9;
            break;
          case "MAT4":
            numComponents = 16;
            break;
          default:
            numComponents = 0;
            break;
        }
        if (numComponents === 0) {
          console.error(`glTF has unknown data type in accessor: ${accessor.type}`);
          return false;
        }
        const componentsBytes = numComponents * arrayType.BYTES_PER_ELEMENT;
        let buffer;
        if (bufferView !== void 0) {
          buffer = this.parseBufferView(accessor.bufferView);
          if (!buffer)
            return accessor.daccessor;
        } else
          buffer = new Uint8Array(componentsBytes * accessor.count).buffer;
        let typedArray = this.getTypedArrayFromArrayBuffer(buffer, byteStride, accessor.byteOffset || 0, arrayType, numComponents, accessor.count);
        if (accessor.sparse) {
          const { count, indices, values } = accessor.sparse;
          typedArray = new arrayType(typedArray);
          const indicesByteOffset = indices.byteOffset || 0;
          const indicesBufferView = this.gltf.bufferViews[indices.bufferView];
          const indicesArrayType = getTypedArrayTypeFromGLType(indices.componentType);
          const indicesBuffer = this.parseBufferView(indices.bufferView);
          const indicesArray = this.getTypedArrayFromArrayBuffer(indicesBuffer, indicesBufferView.byteStride, indicesByteOffset, indicesArrayType, 1, count);
          const valuesByteOffset = values.byteOffset || 0;
          const valuesBufferView = this.gltf.bufferViews[values.bufferView];
          const valuesBuffer = this.parseBufferView(values.bufferView);
          const valuesArray = this.getTypedArrayFromArrayBuffer(valuesBuffer, valuesBufferView.byteStride, valuesByteOffset, arrayType, numComponents, count);
          for (let i = 0; i < indicesArray.length; i++)
            typedArray.set(valuesArray.slice(i * numComponents, i * numComponents + numComponents), indicesArray[i] * numComponents);
        }
        accessor.computeResult = {
          typedArray,
          arrayType,
          numComponents
        };
        accessor.daccessor = {
          data: typedArray,
          numComponents,
          normalize
        };
        return accessor.daccessor;
      }
      getTypedArrayFromArrayBuffer(buffer, byteStride, byteOffset, arrayType, numComponents, count) {
        let typedArray;
        const componentsBytes = numComponents * arrayType.BYTES_PER_ELEMENT;
        if (byteStride && componentsBytes !== byteStride) {
          const arrayLength = numComponents * count;
          typedArray = new arrayType(arrayLength);
          for (let i = 0; i < count; i++) {
            const componentVals = new arrayType(buffer, byteOffset + i * byteStride, numComponents);
            for (let j = 0; j < numComponents; j++)
              typedArray[i * numComponents + j] = componentVals[j];
          }
        } else
          typedArray = new arrayType(buffer, byteOffset, count * numComponents);
        return typedArray;
      }
      parseBufferView(bufferViewId) {
        const bufferView = this.gltf.bufferViews[bufferViewId];
        if (!bufferView)
          return this.errorMiss("bufferView", bufferViewId);
        if (bufferView.isParsed)
          return bufferView.dbufferView;
        bufferView.isParsed = true;
        bufferView.dbufferView = false;
        const buffer = this.parseBuffer(bufferView.buffer);
        if (buffer) {
          const { byteOffset, byteLength } = bufferView;
          const bufferArray = new Uint8Array(buffer, byteOffset || 0, byteLength);
          bufferView.dbufferView = new Uint8Array(bufferArray).buffer;
        }
        return bufferView.dbufferView;
      }
      parseBuffer(bufferId) {
        const buffer = this.gltf.buffers[bufferId];
        if (!buffer)
          return this.errorMiss("buffer", bufferId);
        if (buffer.isParsed)
          return buffer.dbuffer;
        buffer.isParsed = true;
        buffer.dbuffer = false;
        if (buffer.uri.substring(0, 5) !== "data:") {
          const uri = buffer.uri;
          const arrayBuffer = this.gltf.resources[uri];
          if (arrayBuffer)
            if (arrayBuffer.byteLength === buffer.byteLength) {
              buffer.dbuffer = this.gltf.resources[uri];
            } else
              console.error(`load gltf resource "${uri}" at buffers[${bufferId} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`);
          else
            console.error(`load gltf resource "${uri}" at buffers[${bufferId}] failed`);
        } else {
          const base64Idx = buffer.uri.indexOf(this._BASE64_MARKER) + this._BASE64_MARKER.length;
          const blob = window.atob(buffer.uri.substring(base64Idx));
          const bytes = new Uint8Array(blob.length);
          for (let i = 0; i < blob.length; i++)
            bytes[i] = blob.charCodeAt(i);
          buffer.dbuffer = bytes.buffer;
        }
        return buffer.dbuffer;
      }
      getLight(lightID) {
        let info = this.gltf.extensions.KHR_lights_punctual.lights[lightID];
        return info;
      }
      applyNodeExtensions(node, dNode) {
        let extensions = node.extensions;
        if (extensions[`KHR_lights_punctual`] && this.gltf.extensions.KHR_lights_punctual) {
          dNode.light = this.getLight(extensions[`KHR_lights_punctual`].light);
        }
      }
    }

    class GLBHeader {
      magic;
      version;
      length;
    }
    class GLBChunk {
      chunkLength;
      chunkType;
      chunkData;
    }
    class GLBParser extends ParserBase {
      static format = ParserFormat.BIN;
      _gltf;
      async parseBuffer(buffer) {
        let byteArray = new Uint8Array(buffer);
        byteArray["pos"] = 0;
        const fileHeader = this.parseHeader(byteArray);
        if (fileHeader.magic != 1179937895) {
          console.error(`invalid GLB file`);
          return false;
        }
        if (fileHeader.version !== 2) {
          console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${fileHeader.version}`);
          return false;
        }
        let chunks = [];
        while (byteArray["pos"] < byteArray.length) {
          let chunk = this.parseChunk(byteArray);
          chunks.push(chunk);
        }
        if (chunks[0].chunkType != 1313821514) {
          console.error(`invalid GLBChunk`);
          return false;
        }
        let gltfJSON = "";
        let maxCount = 65535;
        let chunkJSONData = chunks[0].chunkData;
        for (let i = 0; i < chunkJSONData.length; i += maxCount) {
          let count = chunkJSONData.length - i;
          count = Math.min(count, maxCount);
          let newUint = chunkJSONData.subarray(i, i + count);
          gltfJSON += String.fromCharCode(...newUint);
        }
        let obj = JSON.parse(gltfJSON);
        this._gltf = new GLTF_Info();
        this._gltf = { ...this._gltf, ...obj };
        this._gltf.resources = {};
        for (let i = 0; i < this._gltf.buffers.length; i++) {
          let buffer2 = this._gltf.buffers[i];
          buffer2.isParsed = true;
          buffer2.dbuffer = chunks[i + 1].chunkData.buffer;
        }
        if (this._gltf.images) {
          for (let i = 0; i < this._gltf.images.length; i++) {
            let image = this._gltf.images[i];
            image.name = image.name || "bufferView_" + image.bufferView.toString();
            const bufferView = this._gltf.bufferViews[image.bufferView];
            const buffer2 = this._gltf.buffers[bufferView.buffer];
            let dataBuffer = new Uint8Array(buffer2.dbuffer, bufferView.byteOffset, bufferView.byteLength);
            let imgData = new Blob([dataBuffer], { type: image.mimeType });
            let dtexture = new BitmapTexture2D();
            await dtexture.loadFromBlob(imgData);
            dtexture.name = image.name;
            this._gltf.resources[image.name] = dtexture;
          }
        }
        let subParser = new GLTFSubParser();
        let nodes = await subParser.parse(this.initUrl, this._gltf, this._gltf.scene);
        if (nodes) {
          this.data = nodes.rootNode;
          return nodes.rootNode;
        }
        return null;
      }
      async parseJsonAndBuffer(obj, bin) {
        this._gltf = new GLTF_Info();
        this._gltf = { ...this._gltf, ...obj };
        this._gltf.resources = {};
        let dbuffer = this._gltf.buffers[0];
        dbuffer.isParsed = true;
        dbuffer.dbuffer = bin;
        if (this._gltf.images) {
          for (let i = 0; i < this._gltf.images.length; i++) {
            let image = this._gltf.images[i];
            image.name = image.name || "bufferView_" + image.bufferView.toString();
            const bufferView = this._gltf.bufferViews[image.bufferView];
            const buffer = this._gltf.buffers[bufferView.buffer];
            let dataBuffer = new Uint8Array(buffer.dbuffer, bufferView.byteOffset, bufferView.byteLength);
            let imgData = new Blob([dataBuffer], { type: image.mimeType });
            let dtexture = new BitmapTexture2D();
            await dtexture.loadFromBlob(imgData);
            dtexture.name = image.name;
            this._gltf.resources[image.name] = dtexture;
          }
        }
        let subParser = new GLTFSubParser();
        let nodes = await subParser.parse(this.initUrl, this._gltf, this._gltf.scene);
        if (nodes) {
          this.data = nodes.rootNode;
          return nodes.rootNode;
        }
        return null;
      }
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
      parseHeader(buffer) {
        let pos = buffer["pos"];
        let result = new GLBHeader();
        let data = new Uint32Array(buffer.buffer, pos, 3);
        buffer["pos"] += data.byteLength;
        result.magic = data[0];
        result.version = data[1];
        result.length = data[2];
        return result;
      }
      parseChunk(buffer) {
        let pos = buffer["pos"];
        let result = new GLBChunk();
        let data = new Uint32Array(buffer.buffer, pos, 2);
        pos = buffer["pos"] += data.byteLength;
        result.chunkLength = data[0];
        result.chunkType = data[1];
        result.chunkData = new Uint8Array(buffer.buffer, pos, result.chunkLength);
        const bytes = new Uint8Array(result.chunkLength);
        for (let i = 0; i < result.chunkLength; i++)
          bytes[i] = result.chunkData[i];
        result.chunkData = bytes;
        buffer["pos"] += result.chunkLength;
        return result;
      }
    }

    var __defProp$d = Object.defineProperty;
    var __getOwnPropDesc$d = Object.getOwnPropertyDescriptor;
    var __decorateClass$d = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$d(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$d(target, key, result);
      return result;
    };
    exports.StandShader = class StandShader extends Shader {
      constructor() {
        super();
        let colorShader = new RenderShaderPass("PBRLItShader", "PBRLItShader");
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        colorShader.passType = PassType.COLOR;
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefault();
      }
      setDefault() {
        this.setUniformFloat(`shadowBias`, 35e-5);
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor`, new Color(0.75, 0.75, 0.75, 1));
        this.setUniformColor(`emissiveColor`, new Color(0, 0, 0));
        this.setUniformVector4(`materialF0`, new Vector4(0.04, 0.04, 0.04, 1));
        this.setUniformColor(`specularColor`, new Color(0.04, 0.04, 0.04));
        this.setUniformFloat(`envIntensity`, 1);
        this.setUniformFloat(`normalScale`, 1);
        this.setUniformFloat(`roughness`, 1);
        this.setUniformFloat(`metallic`, 1);
        this.setUniformFloat(`ao`, 1);
        this.setUniformFloat(`roughness_min`, 0);
        this.setUniformFloat(`roughness_max`, 1);
        this.setUniformFloat(`metallic_min`, 0);
        this.setUniformFloat(`metallic_max`, 1);
        this.setUniformFloat(`emissiveIntensity`, 0);
        this.setUniformFloat(`alphaCutoff`, 0);
        this.setUniformFloat(`ior`, 1.5);
        this.setUniformFloat(`clearcoatFactor`, 0);
        this.setUniformFloat(`clearcoatRoughnessFactor`, 0);
        this.setUniformColor(`clearcoatColor`, new Color(1, 1, 1));
        this.setUniformFloat(`clearcoatWeight`, 0);
        this.baseMap = Engine3D.res.whiteTexture;
        this.normalMap = Engine3D.res.normalTexture;
        this.maskMap = Engine3D.res.maskTexture;
      }
      get baseMap() {
        return this.getDefaultColorShader().getTexture(`baseMap`);
      }
      set baseMap(value) {
        this.getDefaultColorShader().setTexture(`baseMap`, value);
      }
      get baseColor() {
        return this.getDefaultColorShader().getUniform(`baseColor`);
      }
      set baseColor(value) {
        this.getDefaultColorShader().setUniformColor(`baseColor`, value);
      }
      get normalMap() {
        return this.getDefaultColorShader().getTexture(`normalMap`);
      }
      set normalMap(value) {
        this.getDefaultColorShader().setTexture(`normalMap`, value);
      }
      get doubleSide() {
        return this.getDefaultColorShader().doubleSide;
      }
      set doubleSide(value) {
        this.getDefaultColorShader().doubleSide = value;
      }
      get alphaCutoff() {
        return this.getDefaultColorShader().shaderState.alphaCutoff;
      }
      set alphaCutoff(value) {
        this.getDefaultColorShader().setDefine("USE_ALPHACUT", true);
        this.getDefaultColorShader().shaderState.alphaCutoff = value;
        this.getDefaultColorShader().setUniform(`alphaCutoff`, value);
      }
      get emissiveColor() {
        return this.getDefaultColorShader().getUniform(`emissiveColor`);
      }
      set emissiveColor(value) {
        this.getDefaultColorShader().setUniform(`emissiveColor`, value);
      }
      get emissiveIntensity() {
        return this.getDefaultColorShader().getUniform(`emissiveIntensity`);
      }
      set emissiveIntensity(value) {
        this.getDefaultColorShader().setUniform(`emissiveIntensity`, value);
      }
      /**
       * get transformUV1
       */
      get uvTransform_1() {
        return this.getDefaultColorShader().uniforms[`transformUV1`].vector4;
      }
      /**
       * set transformUV1
       */
      set uvTransform_1(value) {
        this.getDefaultColorShader().setUniform(`transformUV1`, value);
      }
      /**
       * get transformUV2
       */
      get uvTransform_2() {
        return this.getDefaultColorShader().uniforms[`transformUV2`].vector4;
      }
      /**
       * set transformUV2
       */
      set uvTransform_2(value) {
        this.getDefaultColorShader().setUniform(`transformUV2`, value);
      }
      get depthWriteEnabled() {
        return this.getDefaultColorShader().shaderState.depthWriteEnabled;
      }
      set depthWriteEnabled(value) {
        this.getDefaultColorShader().shaderState.depthWriteEnabled = value;
      }
      /**
       * get reflectivity
       */
      get materialF0() {
        return this.getDefaultColorShader().uniforms[`materialF0`].vector4;
      }
      /**
       * set reflectivity
       */
      set materialF0(value) {
        this.getDefaultColorShader().setUniform(`materialF0`, value);
      }
      /**
      * get specularColor
      */
      get specularColor() {
        return this.getDefaultColorShader().uniforms[`specularColor`].color;
      }
      /**specularColor
       * set reflectivity
       */
      set specularColor(value) {
        this.getDefaultColorShader().setUniform(`specularColor`, value);
      }
      /**
       * get roughness
       */
      get roughness() {
        return this.getDefaultColorShader().uniforms[`roughness`].value;
      }
      /**
       * set roughness
       */
      set roughness(value) {
        this.getDefaultColorShader().setUniform(`roughness`, value);
      }
      /**
       * get metallic
       */
      get metallic() {
        return this.getDefaultColorShader().uniforms[`metallic`].value;
      }
      /**
       * set metallic
       */
      set metallic(value) {
        this.getDefaultColorShader().setUniform(`metallic`, value);
      }
      /**
       * get Ambient Occlussion, dealing with the effect of ambient light on object occlusion
       */
      get ao() {
        return this.getDefaultColorShader().uniforms[`ao`].value;
      }
      /**
       * set Ambient Occlussion, dealing with the effect of ambient light on object occlusion
       */
      set ao(value) {
        this.getDefaultColorShader().setUniform(`ao`, value);
      }
      /**
       * get min metallic
       */
      get metallic_min() {
        return this.getDefaultColorShader().uniforms[`metallic_min`].value;
      }
      /**
       * set min metallic
       */
      set metallic_min(value) {
        this.getDefaultColorShader().setUniform(`metallic_min`, value);
      }
      /**
       * get max metallic
       */
      get metallic_max() {
        return this.getDefaultColorShader().uniforms[`metallic_max`].value;
      }
      /**
       * set max metallic
       */
      set metallic_max(value) {
        this.getDefaultColorShader().setUniform(`metallic_max`, value);
      }
      /**
       * get min roughness
       */
      get roughness_min() {
        return this.getDefaultColorShader().uniforms[`roughness_min`].value;
      }
      /**
       * set min roughness
       */
      set roughness_min(value) {
        this.getDefaultColorShader().setUniform(`roughness_min`, value);
      }
      /**
       * get max roughness
       */
      get roughness_max() {
        return this.getDefaultColorShader().uniforms[`roughness_max`].value;
      }
      /**
       * set max roughness
       */
      set roughness_max(value) {
        this.getDefaultColorShader().setUniform(`roughness_max`, value);
      }
      /**
       * Get the influence of Normal mapping on materials
       */
      get normalScale() {
        return this.getDefaultColorShader().uniforms[`normalScale`].value;
      }
      /**
       * Set the influence of Normal mapping on materials
       */
      set normalScale(value) {
        this.getDefaultColorShader().setUniform(`normalScale`, value);
      }
      /**
       * get Mask Map
       * R_chanel -> AoMap 
       * G_chanel -> Roughness
       * B_chanel -> Metallic
       * A_chanel -> C
       */
      get maskMap() {
        return this.getDefaultColorShader().textures[`maskMap`];
      }
      /**
       * set Mask Map
       * R_chanel -> AoMap 
       * G_chanel -> Roughness
       * B_chanel -> Metallic
       * A_chanel -> C
       */
      set maskMap(value) {
        this.getDefaultColorShader().setDefine(`USE_MR`, true);
        this.getDefaultColorShader().setTexture(`maskMap`, value);
      }
      /**
       * set Ambient Occlussion Map, dealing with the effect of ambient light on object occlusion
       */
      set aoMap(value) {
        if (!value)
          return;
        this.getDefaultColorShader().setTexture(`aoMap`, value);
        if (value != Engine3D.res.whiteTexture) {
          this.getDefaultColorShader().setDefine(`USE_AOTEX`, true);
        }
      }
      /**
       * get Ambient Occlussion Map, dealing with the effect of ambient light on object occlusion
       */
      get aoMap() {
        return this.getDefaultColorShader().textures[`aoMap`];
      }
      /**
       * set clearCoatRoughnessMap
       */
      set clearCoatRoughnessMap(value) {
        if (!value)
          return;
        console.log("USE_CLEARCOAT_ROUGHNESS");
        this.getDefaultColorShader().setTexture(`clearCoatRoughnessMap`, value);
        this.getDefaultColorShader().setDefine(`USE_CLEARCOAT_ROUGHNESS`, true);
      }
      /**
       * get clearCoatRoughnessMap
       */
      get clearCoatRoughnessMap() {
        return this.getDefaultColorShader().textures[`clearCoatRoughnessMap`];
      }
      /**
       * get brdf query map
       */
      get brdfLUT() {
        return this.getDefaultColorShader().textures[`brdfLUT`];
      }
      /**
       * set brdf query map
       */
      set brdfLUT(value) {
        this.getDefaultColorShader().setTexture(`brdfLUT`, value);
        this.getDefaultColorShader().setTexture(`brdflutMap`, value);
      }
      /**
       * get emissive map
       */
      get emissiveMap() {
        return this.getDefaultColorShader().textures[`emissiveMap`];
      }
      /**
       * set emissive map
       */
      set emissiveMap(value) {
        this.getDefaultColorShader().setTexture(`emissiveMap`, value);
      }
      /**
       * set intensity of environment light or color of sampled by texture
       */
      set envIntensity(value) {
        this.getDefaultColorShader().setUniformFloat(`envIntensity`, value);
      }
      /**
       * get intensity of environment light or color of sampled by texture
       */
      get envIntensity() {
        return this.getDefaultColorShader().uniforms[`envIntensity`].value;
      }
      /**
       * set factor of refractive
       */
      set ior(value) {
        this.getDefaultColorShader().setUniformFloat(`ior`, value);
      }
      /**
       * get factor of refractive
       */
      get ior() {
        return this.getDefaultColorShader().uniforms[`ior`].value;
      }
      /**
       * valid USE_CLEARCOAT define in shader
       */
      useCleanCoat() {
        this.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
      }
      /**
       * Set the factor of the clearcoat
       */
      set clearcoatFactor(value) {
        this.getDefaultColorShader().setUniformFloat(`clearcoatFactor`, value);
        this.useCleanCoat();
      }
      /**
       * get the factor of the clearcoat
       */
      get clearcoatFactor() {
        return this.getDefaultColorShader().uniforms[`clearcoatFactor`].value;
      }
      /**
       * set the factor of the clearcoat Roughness
       */
      set clearcoatRoughnessFactor(value) {
        this.getDefaultColorShader().setUniformFloat(`clearcoatRoughnessFactor`, value);
        this.useCleanCoat();
      }
      /**
       * get the factor of the clearcoat Roughness
       */
      get clearcoatRoughnessFactor() {
        return this.getDefaultColorShader().uniforms[`clearcoatRoughnessFactor`].value;
      }
      /**
       * set the weight of the clearcoat
       */
      set clearcoatWeight(value) {
        this.getDefaultColorShader().setUniformFloat(`clearcoatWeight`, value);
        this.useCleanCoat();
      }
      /**
       * get the weight of the clearcoat
       */
      get clearcoatWeight() {
        return this.getDefaultColorShader().uniforms[`clearcoatWeight`].value;
      }
      /**
       * get the color of the clearcoat
       */
      set clearcoatColor(value) {
        this.getDefaultColorShader().setUniformColor(`clearcoatColor`, value);
        this.useCleanCoat();
      }
      /**
       * set the color of the clearcoat
       */
      get clearcoatColor() {
        return this.getDefaultColorShader().uniforms[`clearcoatColor`].color;
      }
    };
    exports.StandShader = __decorateClass$d([
      RegisterShader
    ], exports.StandShader);

    class LitMaterial extends Material {
      constructor() {
        super();
        let shader = new exports.StandShader();
        this.shader = shader;
      }
      clone() {
        let litMaterial = new LitMaterial();
        let colorPass = litMaterial.shader.getDefaultColorShader();
        let sourceShader = this.shader.getDefaultColorShader();
        colorPass.defineValue = { ...sourceShader.defineValue };
        colorPass.setUniform(`shadowBias`, sourceShader.getUniform(`shadowBias`));
        colorPass.setUniform(`transformUV1`, sourceShader.getUniform(`transformUV1`));
        colorPass.setUniform(`transformUV2`, sourceShader.getUniform(`transformUV2`));
        colorPass.setUniform(`baseColor`, sourceShader.getUniform(`baseColor`));
        colorPass.setUniform(`specularColor`, sourceShader.getUniform(`specularColor`));
        colorPass.setUniform(`emissiveColor`, sourceShader.getUniform(`emissiveColor`));
        colorPass.setUniform(`materialF0`, sourceShader.getUniform(`materialF0`));
        colorPass.setUniform(`envIntensity`, sourceShader.getUniform(`envIntensity`));
        colorPass.setUniform(`normalScale`, sourceShader.getUniform(`normalScale`));
        colorPass.setUniform(`roughness`, sourceShader.getUniform(`roughness`));
        colorPass.setUniform(`metallic`, sourceShader.getUniform(`metallic`));
        colorPass.setUniform(`ao`, sourceShader.getUniform(`ao`));
        colorPass.setUniform(`roughness_min`, sourceShader.getUniform(`roughness_min`));
        colorPass.setUniform(`roughness_max`, sourceShader.getUniform(`roughness_max`));
        colorPass.setUniform(`metallic_min`, sourceShader.getUniform(`metallic_min`));
        colorPass.setUniform(`metallic_max`, sourceShader.getUniform(`metallic_max`));
        colorPass.setUniform(`emissiveIntensity`, sourceShader.getUniform(`emissiveIntensity`));
        colorPass.setUniform(`alphaCutoff`, sourceShader.getUniform(`alphaCutoff`));
        colorPass.setUniform(`ior`, sourceShader.getUniform(`ior`));
        colorPass.setUniform(`clearcoatFactor`, sourceShader.getUniform(`clearcoatFactor`));
        colorPass.setUniform(`clearcoatRoughnessFactor`, sourceShader.getUniform(`clearcoatRoughnessFactor`));
        colorPass.setUniform(`clearcoatColor`, sourceShader.getUniform(`clearcoatColor`));
        colorPass.setUniform(`clearcoatWeight`, sourceShader.getUniform(`clearcoatWeight`));
        colorPass.setTexture(`baseMap`, sourceShader.getTexture(`baseMap`));
        colorPass.setTexture(`normalMap`, sourceShader.getTexture(`normalMap`));
        colorPass.setTexture(`emissiveMap`, sourceShader.getTexture(`emissiveMap`));
        colorPass.setTexture(`aoMap`, sourceShader.getTexture(`aoMap`));
        colorPass.setTexture(`maskMap`, sourceShader.getTexture(`maskMap`));
        return litMaterial;
      }
      set baseMap(texture) {
        this.shader.setTexture(`baseMap`, texture);
      }
      get baseMap() {
        return this.shader.getTexture(`baseMap`);
      }
      set maskMap(texture) {
        this.shader.setTexture(`maskMap`, texture);
      }
      get maskMap() {
        return this.shader.getTexture(`maskMap`);
      }
      set normalMap(texture) {
        this.shader.setTexture(`normalMap`, texture);
      }
      get normalMap() {
        return this.shader.getTexture(`normalMap`);
      }
      set emissiveMap(texture) {
        this.shader.setTexture(`emissiveMap`, texture);
      }
      get emissiveMap() {
        return this.shader.getTexture(`emissiveMap`);
      }
      set aoMap(texture) {
        this.shader.setTexture(`aoMap`, texture);
      }
      get aoMap() {
        return this.shader.getTexture(`aoMap`);
      }
      set clearCoatRoughnessMap(texture) {
        this.shader.setTexture(`clearCoatRoughnessMap`, texture);
        this.shader.setDefine(`USE_CLEARCOAT`, true);
        this.shader.setDefine(`USE_CLEARCOAT_ROUGHNESS`, true);
      }
      get clearCoatRoughnessMap() {
        return this.shader.getTexture(`clearCoatRoughnessMap`);
      }
      set clearcoatColor(value) {
        this.shader.setUniformColor(`clearcoatColor`, value);
        this.shader.setDefine(`USE_CLEARCOAT`, true);
      }
      get clearcoatColor() {
        return this.shader.getUniformColor(`clearcoatColor`);
      }
      set clearcoatWeight(value) {
        this.shader.setUniformFloat(`clearcoatWeight`, value);
        this.shader.setDefine(`USE_CLEARCOAT`, true);
      }
      get clearcoatWeight() {
        return this.shader.getUniformFloat(`clearcoatWeight`);
      }
      set clearcoatFactor(value) {
        this.shader.setUniformFloat(`clearcoatFactor`, value);
        this.shader.setDefine(`USE_CLEARCOAT`, true);
      }
      get clearcoatFactor() {
        return this.shader.getUniformFloat(`clearcoatFactor`);
      }
      set clearcoatRoughnessFactor(value) {
        this.shader.setUniformFloat(`clearcoatRoughnessFactor`, value);
        this.shader.setDefine(`USE_CLEARCOAT`, true);
      }
      get clearcoatRoughnessFactor() {
        return this.shader.getUniformFloat(`clearcoatRoughnessFactor`);
      }
      set alphaCutoff(value) {
        this.shader.setUniform(`alphaCutoff`, value);
      }
      get alphaCutoff() {
        return this.shader.getUniform(`alphaCutoff`);
      }
      /**
       * set base color (tint color)
       */
      set baseColor(color) {
        this.shader.setUniformColor(`baseColor`, color);
      }
      /**
       * get base color (tint color)
       */
      get baseColor() {
        return this.shader.getUniformColor("baseColor");
      }
      get roughness() {
        return this.shader.getUniformFloat("roughness");
      }
      set roughness(value) {
        this.shader.setUniformFloat("roughness", value);
      }
      get metallic() {
        return this.shader.getUniformFloat("metallic");
      }
      set metallic(value) {
        this.shader.setUniformFloat("metallic", value);
      }
      get emissiveColor() {
        return this.shader.getUniformColor("emissiveColor");
      }
      set emissiveColor(value) {
        this.shader.setUniformColor("emissiveColor", value);
      }
      get emissiveIntensity() {
        return this.shader.getUniformFloat("emissiveIntensity");
      }
      set emissiveIntensity(value) {
        this.shader.setUniformFloat("emissiveIntensity", value);
      }
      get ao() {
        return this.shader.getUniform(`ao`);
      }
      set ao(value) {
        this.shader.setUniform(`ao`, value);
      }
    }

    class OBJParser extends ParserBase {
      static format = ParserFormat.TEXT;
      textData = "";
      source_vertices;
      source_normals;
      source_tangents;
      source_textureCoords;
      // private source_faces:Face[];
      // public faces: {
      //   indices: string[],
      //   texture: string[],
      //   normal: string[]
      // }[];
      matLibs;
      geometrys;
      activeGeo;
      facesMaterialsIndex;
      mtl;
      mtlUrl;
      // public geometryDatas:GeometryData[];
      async parseString(obj) {
        this.source_vertices = [];
        this.source_normals = [];
        this.source_tangents = [];
        this.source_textureCoords = [];
        this.matLibs = {};
        this.geometrys = {};
        this.textData = obj;
        await Promise.all([this.parserOBJ(), this.loadMTL()]);
        this.parser_mesh();
        return `null`;
      }
      applyVector2(fi, sourceData, destData) {
        if (sourceData[fi] && sourceData[fi].length > 0) {
          destData.push(sourceData[fi][0]);
          destData.push(sourceData[fi][1]);
        } else {
          destData.push(0);
          destData.push(0);
        }
      }
      applyVector3(fi, sourceData, destData) {
        destData.push(sourceData[fi][0]);
        destData.push(sourceData[fi][1]);
        destData.push(sourceData[fi][2]);
      }
      applyVector4(fi, sourceData, destData) {
        destData.push(sourceData[fi][0]);
        destData.push(sourceData[fi][1]);
        destData.push(sourceData[fi][2]);
        destData.push(sourceData[fi][3]);
      }
      async loadMTL() {
        let fileLoad = new FileLoader();
        let sourceData = await fileLoad.loadTxt(this.baseUrl + this.mtlUrl);
        let sourceStr = sourceData[`data`];
        let mat;
        let str = sourceStr.split("\r\n");
        for (let i = 0; i < str.length; i++) {
          let line = str[i];
          var commentStart = line.indexOf("#");
          if (commentStart != -1) {
            line = line.substring(0, commentStart);
          }
          line = line.trim();
          var splitedLine = line.split(/\s+/);
          if (splitedLine[0] === "newmtl") {
            mat = { name: splitedLine[1] };
            this.matLibs[splitedLine[1]] = mat;
          } else {
            if (splitedLine[0].indexOf(`map_`) != -1) {
              mat[splitedLine[0]] = splitedLine[1];
              if (!mat.textures) {
                mat.textures = [splitedLine[splitedLine.length - 1]];
              }
              mat.textures.push(splitedLine[splitedLine.length - 1]);
            } else if (splitedLine.length == 2) {
              mat[splitedLine[0]] = Number(splitedLine[1]);
            } else if (splitedLine.length == 3) {
              mat[splitedLine[0]] = [Number(splitedLine[1]), Number(splitedLine[2])];
            } else if (splitedLine.length == 4) {
              mat[splitedLine[0]] = [Number(splitedLine[1]), Number(splitedLine[2]), Number(splitedLine[3])];
            }
          }
        }
        for (const key in this.matLibs) {
          const mat2 = this.matLibs[key];
          if (mat2.textures && mat2.textures.length > 0) {
            for (let i = 0; i < mat2.textures.length; i++) {
              const texUrl = StringUtil.normalizePath(this.baseUrl + mat2.textures[i]);
              await Engine3D.res.loadTexture(texUrl);
            }
          }
        }
        sourceData = null;
        return true;
      }
      async load_textures() {
      }
      parserLine(line) {
        var commentStart = line.indexOf("#");
        if (commentStart != -1) {
          if (line.indexOf(`# object`) != -1) {
            var splitedLine = line.split(/\s+/);
            let type = splitedLine[1];
            let geoName = splitedLine[2];
            this.activeGeo = {
              type,
              name: geoName[1],
              source_mat: ``,
              source_faces: []
            };
            this.geometrys[geoName] = this.activeGeo;
          }
          line = line.substring(0, commentStart);
        }
        line = line.trim();
        var splitedLine = line.split(/\s+/);
        if (splitedLine[0] === "v") {
          var vertex = [Number(splitedLine[1]), Number(splitedLine[2]), Number(splitedLine[3]), splitedLine[4] ? 1 : Number(splitedLine[4])];
          this.source_vertices.push(vertex);
        } else if (splitedLine[0] === "vt") {
          var textureCoord = [Number(splitedLine[1]), Number(splitedLine[2]), splitedLine[3] ? 1 : Number(splitedLine[3])];
          this.source_textureCoords.push(textureCoord);
        } else if (splitedLine[0] === "vn") {
          var normal = [Number(splitedLine[1]), Number(splitedLine[2]), Number(splitedLine[3])];
          this.source_normals.push(normal);
        } else if (splitedLine[0] === "f") {
          var face = {
            indices: [],
            texture: [],
            normal: []
          };
          for (var i = 1; i < splitedLine.length; ++i) {
            var dIndex = splitedLine[i].indexOf("//");
            var splitedFaceIndices = splitedLine[i].split(/\W+/);
            if (dIndex > 0) {
              face.indices.push(splitedFaceIndices[0]);
              face.normal.push(splitedFaceIndices[1]);
            } else {
              if (splitedFaceIndices.length === 1) {
                face.indices.push(splitedFaceIndices[0]);
              } else if (splitedFaceIndices.length === 2) {
                face.indices.push(splitedFaceIndices[0]);
                face.texture.push(splitedFaceIndices[1]);
              } else if (splitedFaceIndices.length === 3) {
                face.indices.push(splitedFaceIndices[0]);
                face.texture.push(splitedFaceIndices[1]);
                face.normal.push(splitedFaceIndices[2]);
              }
            }
          }
          this.activeGeo.source_faces.push(face);
        } else if (splitedLine[0] === "usemtl") {
          this.activeGeo.source_mat = splitedLine[1];
        } else if (splitedLine[0] === `mtllib`) {
          this.mtlUrl = splitedLine[1];
        }
      }
      async parserOBJ() {
        let str = this.textData.split("\r\n");
        for (let i = 0; i < str.length; i++) {
          const element = str[i];
          this.parserLine(element);
        }
        this.textData = ``;
        return true;
      }
      async parser_mesh() {
        for (const key in this.geometrys) {
          const geoData = this.geometrys[key];
          geoData.vertex_arr = [];
          geoData.normal_arr = [];
          geoData.uv_arr = [];
          geoData.indeice_arr = [];
          let index = 0;
          for (let i = 0; i < geoData.source_faces.length; i++) {
            const face = geoData.source_faces[i];
            let f0 = parseInt(face.indices[0]) - 1;
            let f1 = parseInt(face.indices[1]) - 1;
            let f2 = parseInt(face.indices[2]) - 1;
            let n0 = parseInt(face.normal[0]) - 1;
            let n1 = parseInt(face.normal[1]) - 1;
            let n2 = parseInt(face.normal[2]) - 1;
            let u0 = parseInt(face.texture[0]) - 1;
            let u1 = parseInt(face.texture[1]) - 1;
            let u2 = parseInt(face.texture[2]) - 1;
            this.applyVector3(f0, this.source_vertices, geoData.vertex_arr);
            this.applyVector3(n0, this.source_normals, geoData.normal_arr);
            this.applyVector2(u0, this.source_textureCoords, geoData.uv_arr);
            geoData.indeice_arr[index] = index++;
            this.applyVector3(f1, this.source_vertices, geoData.vertex_arr);
            this.applyVector3(n1, this.source_normals, geoData.normal_arr);
            this.applyVector2(u1, this.source_textureCoords, geoData.uv_arr);
            geoData.indeice_arr[index] = index++;
            this.applyVector3(f2, this.source_vertices, geoData.vertex_arr);
            this.applyVector3(n2, this.source_normals, geoData.normal_arr);
            this.applyVector2(u2, this.source_textureCoords, geoData.uv_arr);
            geoData.indeice_arr[index] = index++;
            if (face.indices.length > 3) {
              let f3 = parseInt(face.indices[3]) - 1;
              let n3 = parseInt(face.normal[3]) - 1;
              let u3 = parseInt(face.texture[3]) - 1;
              this.applyVector3(f0, this.source_vertices, geoData.vertex_arr);
              this.applyVector3(n0, this.source_normals, geoData.normal_arr);
              this.applyVector2(u0, this.source_textureCoords, geoData.uv_arr);
              geoData.indeice_arr[index] = index++;
              this.applyVector3(f2, this.source_vertices, geoData.vertex_arr);
              this.applyVector3(n2, this.source_normals, geoData.normal_arr);
              this.applyVector2(u2, this.source_textureCoords, geoData.uv_arr);
              geoData.indeice_arr[index] = index++;
              this.applyVector3(f3, this.source_vertices, geoData.vertex_arr);
              this.applyVector3(n3, this.source_normals, geoData.normal_arr);
              this.applyVector2(u3, this.source_textureCoords, geoData.uv_arr);
              geoData.indeice_arr[index] = index++;
            }
          }
          let root = new exports.Object3D();
          for (const key2 in this.geometrys) {
            const geoData2 = this.geometrys[key2];
            let geo = new GeometryBase();
            geo.setIndices(new Uint32Array(geoData2.indeice_arr));
            geo.setAttribute(VertexAttributeName.position, new Float32Array(geoData2.vertex_arr));
            geo.setAttribute(VertexAttributeName.normal, new Float32Array(geoData2.normal_arr));
            geo.setAttribute(VertexAttributeName.uv, new Float32Array(geoData2.uv_arr));
            geo.setAttribute(VertexAttributeName.TEXCOORD_1, new Float32Array(geoData2.uv_arr));
            geo.addSubGeometry({
              indexStart: 0,
              indexCount: geoData2.indeice_arr.length,
              vertexStart: 0,
              vertexCount: 0,
              firstStart: 0,
              index: 0,
              topology: 0
            });
            let mat = new LitMaterial();
            let matData = this.matLibs[geoData2.source_mat];
            mat.baseMap = Engine3D.res.getTexture(StringUtil.normalizePath(this.baseUrl + matData.map_Kd));
            let obj = new exports.Object3D();
            let mr = obj.addComponent(exports.MeshRenderer);
            mr.geometry = geo;
            mr.material = mat;
            root.addChild(obj);
          }
          this.data = root;
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
    }

    let BlurEffectCreatorSample_cs = (
      /*wgsl*/
      `
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`
    );
    let BlurEffectCreatorBlur_cs = (
      /*wgsl*/
      `
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`
    );

    class BlurTexture2DBufferCreator {
      //Image is the texture of converting from rgba8unorm to rgba8unorm
      static blurImageFromTexture(image, dstWidth, dstHeight, blur) {
        const device = webGPUContext.device;
        let code = blur ? BlurEffectCreatorBlur_cs : BlurEffectCreatorSample_cs;
        const computePipeline = device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code
            }),
            entryPoint: "main"
          }
        });
        const configStride = 4 * 4;
        const configBuffer = device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(configBuffer, 0, new Uint32Array([image.width, image.height, dstWidth, dstHeight]));
        const outputTexture = device.createTexture({
          size: [dstWidth, dstHeight, 1],
          mipLevelCount: 1,
          format: "rgba8unorm",
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
          label: `blurImageFromTexture`
        });
        let entries0 = [
          {
            binding: 0,
            resource: {
              buffer: configBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: image.gpuTexture.createView({
              format: "rgba8unorm",
              dimension: "2d",
              baseMipLevel: 0,
              mipLevelCount: 1
            })
          },
          {
            binding: 2,
            resource: outputTexture.createView({
              format: "rgba8unorm",
              dimension: "2d",
              baseMipLevel: 0,
              mipLevelCount: 1
            })
          }
        ];
        const computeBindGroup0 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: entries0
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, computeBindGroup0);
        computePass.dispatchWorkgroups(Math.floor(dstWidth / 8), Math.floor(dstHeight / 8));
        computePass.end();
        GPUContext.endCommandEncoder(commandEncoder);
        configBuffer.destroy();
        return outputTexture;
      }
    }

    class TextureCube extends Texture {
      /**
       * texture width, default value is 4
       */
      width = 4;
      /**
       * texture height, default value is 4
       */
      height = 4;
      /**
       * depth or array layers, default value is 6
       */
      depthOrArrayLayers = 6;
      /**
       * GPUShaderStage
       */
      visibility = GPUShaderStage.FRAGMENT;
      /**
       * GPUTextureBindingLayout
       */
      textureBindingLayout = {
        viewDimension: "cube",
        multisampled: false
      };
      /**
       * GPUSamplerBindingLayout
       */
      samplerBindingLayout = {
        type: "filtering"
      };
      /**
       * @constructor
       */
      constructor() {
        super(4, 4);
        this.addressModeU = GPUAddressMode.clamp_to_edge;
        this.addressModeV = GPUAddressMode.clamp_to_edge;
        this.addressModeW = GPUAddressMode.clamp_to_edge;
        this.magFilter = this.minFilter = "linear";
        this.mipmapFilter = "linear";
        this.visibility = GPUShaderStage.FRAGMENT;
      }
      /**
       * createTextureDescriptor
       */
      createTextureDescriptor(width, height, mipLevelCount, format, usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT, sizeCount = 1) {
        this.width = width;
        this.height = height;
        this.format = format;
        this.usage = usage;
        this.textureDescriptor = {
          size: { width, height, depthOrArrayLayers: 6 },
          mipLevelCount,
          format,
          usage,
          dimension: "2d"
        };
        if (sizeCount > 1) {
          this.viewDescriptor = {
            dimension: `cube-array`
          };
        } else {
          this.viewDescriptor = {
            dimension: this.textureBindingLayout.viewDimension
          };
        }
      }
    }

    class TextureCubeStdCreator {
      static createCube = (
        /*wgsl*/
        `

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`
      );
      static configBuffer = null;
      static blurSettingBuffer = null;
      static pipeline;
      static createFace(index, size, inTex, outTex) {
        const device = webGPUContext.device;
        if (this.pipeline == null) {
          this.pipeline = device.createComputePipeline({
            layout: `auto`,
            compute: {
              module: device.createShaderModule({
                code: TextureCubeStdCreator.createCube
              }),
              entryPoint: "main"
            }
          });
        }
        const computePipeline = this.pipeline;
        const configStride = 4 * 4;
        this.configBuffer ||= device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(this.configBuffer, 0, new Uint32Array([index, 0, 0, 0]));
        this.blurSettingBuffer ||= device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(this.blurSettingBuffer, 0, new Float32Array([0, 0, 0, 0]));
        let entries0 = [
          {
            binding: 0,
            resource: {
              buffer: this.configBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: inTex.getGPUView()
          },
          {
            binding: 2,
            resource: outTex.getGPUView()
          }
        ];
        const computeBindGroup0 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: entries0
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, computeBindGroup0);
        computePass.dispatchWorkgroups(size / 8, size / 8);
        computePass.end();
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class BitmapTextureCube extends TextureCube {
      _images;
      _url;
      constructor() {
        super();
        this.useMipmap = true;
      }
      generateImages(images) {
        let device = webGPUContext.device;
        this.width = this.height = 32;
        if ("width" in images[0]) {
          this.width = this.height = images[0].width;
        }
        let mipmapSize = Math.min(this.width, this.height);
        this.mipmapCount = 1;
        while (mipmapSize > 16) {
          mipmapSize /= 2;
          this.mipmapCount++;
        }
        this.textureBindingLayout.viewDimension = "cube";
        this.samplerBindingLayout.type = "filtering";
        this.createTextureDescriptor(this.width, this.height, this.mipmapCount, this.format);
        this.textureDescriptor.size = { width: this.width, height: this.height, depthOrArrayLayers: 6 };
        this.textureDescriptor.dimension = "2d";
        this.gpuTexture = this.getGPUTexture();
        let faceTextures = [];
        let lastFaceTextures = faceTextures;
        let mipWidth = this.width;
        let mipHeight = this.height;
        if (images[0] instanceof Texture) {
          for (let i = 0; i < 6; i++) {
            let t = images[i];
            faceTextures[i] = t.getGPUTexture();
          }
          this.uploadMipmapGPUTexture(0, this.width, this.width, faceTextures);
        } else {
          this.uploadBaseImages(this.width, images);
          for (let i = 0; i < 6; i++) {
            let t = new BitmapTexture2D(false);
            t.format = this.format;
            t.source = images[i];
            faceTextures[i] = t.getGPUTexture();
          }
        }
        for (let i = 1; i < this.mipmapCount; i++) {
          lastFaceTextures = faceTextures;
          faceTextures = [];
          let dstBuffer = { width: mipWidth, height: mipHeight, gpuTexture: null };
          mipWidth = mipWidth / 2;
          mipHeight = mipHeight / 2;
          for (let faceId = 0; faceId < 6; faceId++) {
            dstBuffer.gpuTexture = lastFaceTextures[faceId];
            faceTextures[faceId] = BlurTexture2DBufferCreator.blurImageFromTexture(dstBuffer, mipWidth, mipHeight, false);
          }
          this.uploadMipmapGPUTexture(i, mipWidth, mipHeight, faceTextures);
        }
        this.gpuSampler = device.createSampler(this);
      }
      uploadBaseImages(size, textures) {
        let device = webGPUContext.device;
        const commandEncoder = GPUContext.beginCommandEncoder();
        for (let i = 0; i < 6; i++) {
          device.queue.copyExternalImageToTexture(
            { source: textures[i] },
            {
              texture: this.gpuTexture,
              mipLevel: 0,
              origin: { x: 0, y: 0, z: i }
            },
            { width: size, height: size, depthOrArrayLayers: 1 }
          );
        }
        GPUContext.endCommandEncoder(commandEncoder);
      }
      uploadMipmapGPUTexture(mip, width, height, textures) {
        const commandEncoder = GPUContext.beginCommandEncoder();
        for (let i = 0; i < 6; i++) {
          commandEncoder.copyTextureToTexture(
            {
              texture: textures[i],
              mipLevel: 0,
              origin: { x: 0, y: 0, z: 0 }
            },
            {
              texture: this.gpuTexture,
              mipLevel: mip,
              origin: { x: 0, y: 0, z: i }
            },
            {
              width,
              height,
              depthOrArrayLayers: 1
            }
          );
        }
        GPUContext.endCommandEncoder(commandEncoder);
      }
      /**
       * get images of this texture
       */
      get images() {
        return this._images;
      }
      /**
      * set images of this texture
      */
      set images(value) {
        this._images = value;
        if (this._images[0] instanceof HTMLImageElement) {
          let loadImage = function(index, image) {
            image.decode().then(async () => {
              bitmaps[index] = await createImageBitmap(image);
              remain--;
              if (remain == 0) {
                that.generateImages(bitmaps);
              }
            });
          };
          let bitmaps = [];
          let remain = 6;
          let that = this;
          for (let i = 0; i < 6; i++) {
            loadImage(i, this._images[i]);
          }
        } else {
          if (this._images instanceof HTMLCanvasElement || this._images instanceof ImageBitmap) {
            this.generateImages(this._images);
          }
        }
      }
      /**
       * load texture data from array of web url.
       * make sure there are six images in a group,
       * and the order is: nx, px, py, ny, nz, pz
       * @param urls array of image url
       */
      async load(urls) {
        this._url = urls;
        let remain = 6;
        let bitmaps = [];
        this.format = GPUTextureFormat.rgba8unorm;
        let that = this;
        async function loadImage(index, url) {
          const img = document.createElement("img");
          img.src = url;
          img.setAttribute("crossOrigin", "");
          await img.decode();
          bitmaps[index] = await createImageBitmap(img);
          remain--;
          if (remain == 0) {
            that.generateImages(bitmaps);
            return true;
          }
        }
        for (let i = 0; i < 6; i++) {
          await loadImage(i, urls[i]);
        }
        return true;
      }
      /**
        * load texture data from url.
        * the image is assembled from six images into cross shaped image.
        * @param url the path of image
        */
      async loadStd(url) {
        this._url = url;
        this.format = GPUTextureFormat.rgba8unorm;
        const img = document.createElement("img");
        img.src = url;
        img.setAttribute("crossOrigin", "");
        await img.decode();
        let srcTexture = new BitmapTexture2D(false);
        srcTexture.name = StringUtil.getURLName(url);
        srcTexture.format = "rgba8unorm";
        srcTexture.source = await createImageBitmap(img);
        let cubeSize = Math.round(Math.log2(srcTexture.width / 4));
        cubeSize = Math.pow(2, cubeSize);
        this.width = this.height = cubeSize;
        let textureList = [];
        for (let i = 0; i < 6; i++) {
          let item = new VirtualTexture(
            cubeSize,
            cubeSize,
            this.format,
            false,
            GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING
          );
          item.name = "face " + i;
          textureList.push(item);
          TextureCubeStdCreator.createFace(i, this.width, srcTexture, item);
        }
        this.generateImages(textureList);
        return true;
      }
    }

    var CubeMapFaceEnum = /* @__PURE__ */ ((CubeMapFaceEnum2) => {
      CubeMapFaceEnum2[CubeMapFaceEnum2["Left"] = 0] = "Left";
      CubeMapFaceEnum2[CubeMapFaceEnum2["Right"] = 1] = "Right";
      CubeMapFaceEnum2[CubeMapFaceEnum2["Bottom"] = 2] = "Bottom";
      CubeMapFaceEnum2[CubeMapFaceEnum2["Top"] = 3] = "Top";
      CubeMapFaceEnum2[CubeMapFaceEnum2["Back"] = 4] = "Back";
      CubeMapFaceEnum2[CubeMapFaceEnum2["Front"] = 5] = "Front";
      return CubeMapFaceEnum2;
    })(CubeMapFaceEnum || {});
    class TextureCubeUtils {
      static getRotationToFace(face) {
        let quaternion = Quaternion.identity().clone();
        let target = new Vector3();
        let matrix = new Matrix4().identity();
        let up = new Vector3();
        switch (face) {
          case 3 /* Top */:
            target.set(0, -1, 0);
            up.set(0, 0, -1);
            break;
          case 2 /* Bottom */:
            target.set(0, 1, 0);
            up.set(0, 0, 1);
            break;
          case 1 /* Right */:
            target.set(1, 0, 0);
            up.set(0, 1, 0);
            break;
          case 0 /* Left */:
            target.set(-1, 0, 0);
            up.set(0, 1, 0);
            break;
          case 4 /* Back */:
            target.set(0, 0, -1);
            up.set(0, 1, 0);
            break;
          case 5 /* Front */:
            return Quaternion.identity();
        }
        matrix.lookAt(new Vector3(), target, up);
        quaternion.setFromRotationMatrix(matrix);
        return quaternion;
      }
    }

    let ErpImage2CubeMapCreateCube_cs = (
      /*wgsl*/
      `
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`
    );

    let ErpImage2CubeMapRgbe2rgba_cs = (
      /*wgsl*/
      `
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`
    );

    class ErpImage2CubeMap {
      static convertRGBE2RGBA(image, data) {
        const device = webGPUContext.device;
        const computePipeline = device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code: ErpImage2CubeMapRgbe2rgba_cs
            }),
            entryPoint: "main"
          }
        });
        const configBuffer = device.createBuffer({
          size: 4 * 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(configBuffer, 0, new Uint32Array([image.width, image.height, image.width, image.height]));
        const input = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(input, 0, data);
        let entries0 = [
          {
            binding: 0,
            resource: {
              buffer: configBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: {
              buffer: input,
              size: data.byteLength
            }
          },
          {
            binding: 2,
            resource: image.getGPUView()
          }
        ];
        const computeBindGroup0 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: entries0
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, computeBindGroup0);
        computePass.dispatchWorkgroups(Math.floor(image.width / 8), Math.floor(image.height / 8));
        computePass.end();
        GPUContext.endCommandEncoder(commandEncoder);
        configBuffer.destroy();
      }
      static makeFaceTexturePipeline;
      static configBuffer;
      static quaternionBuffer;
      //Image is the float32 color value converted from rgbe to rgba
      static makeTextureCube(image, dstSize, dstView) {
        const device = webGPUContext.device;
        ErpImage2CubeMap.makeFaceTexturePipeline ||= device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code: ErpImage2CubeMapCreateCube_cs
            }),
            entryPoint: "main"
          }
        });
        const computePipeline = ErpImage2CubeMap.makeFaceTexturePipeline;
        const configStride = 4 * 4;
        ErpImage2CubeMap.configBuffer ||= device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(ErpImage2CubeMap.configBuffer, 0, new Uint32Array([image.width, image.height, dstSize, dstSize]));
        const quaternionSize = 4 * 6;
        if (!ErpImage2CubeMap.quaternionBuffer) {
          ErpImage2CubeMap.quaternionBuffer = device.createBuffer({
            size: quaternionSize * 4 * 6,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          });
          let qArray = new Float32Array(4 * 6);
          for (let i = 0; i < 6; i++) {
            let q = TextureCubeUtils.getRotationToFace(i);
            qArray[i * 4 + 0] = q.x;
            qArray[i * 4 + 1] = q.y;
            qArray[i * 4 + 2] = q.z;
            qArray[i * 4 + 3] = q.w;
          }
          device.queue.writeBuffer(ErpImage2CubeMap.quaternionBuffer, 0, qArray);
        }
        let entries0 = [
          {
            binding: 0,
            resource: {
              buffer: ErpImage2CubeMap.configBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: {
              buffer: ErpImage2CubeMap.quaternionBuffer,
              size: quaternionSize * 4
            }
          },
          {
            binding: 2,
            resource: image.gpuSampler
          },
          {
            binding: 3,
            resource: image.getGPUView()
          }
        ];
        let entries1 = [
          {
            binding: 0,
            resource: dstView
          }
        ];
        const computeBindGroup0 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: entries0
        });
        const computeBindGroup1 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(1),
          entries: entries1
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, computeBindGroup0);
        computePass.setBindGroup(1, computeBindGroup1);
        computePass.dispatchWorkgroups(dstSize / 8, dstSize / 8, 6);
        computePass.end();
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class HDRTexture extends Texture {
      constructor() {
        super(32, 32, null);
        this.isHDRTexture = true;
      }
      /**
       * fill this texture by array of numbers;the format as [red0, green0, blue0, e0, red1, green1, blue1, e1...]
       * @param width assign the texture width
       * @param height assign the texture height
       * @param data color of each pixel
       * @param useMipmap gen mipmap or not
       * @returns
       */
      create(width = 32, height = 32, data = null, useMipmap = true) {
        this.width = width;
        this.height = height;
        let device = webGPUContext.device;
        const bit = 2;
        const bytesPerRow = width * 4 * bit;
        let fixedData = data;
        this.format = GPUTextureFormat.rgba16float;
        this.useMipmap = useMipmap;
        this.updateTextureDescription();
        this.updateGPUTexture();
        const textureDataBuffer = device.createBuffer({
          size: fixedData.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, fixedData);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        if (!this.useMipmap) {
          this.samplerBindingLayout.type = `filtering`;
          this.textureBindingLayout.sampleType = `float`;
        }
        this.gpuSampler = device.createSampler(this);
        return this;
      }
      /**
       * load one hdr image
       * @param url the url of hdr image
       * @param loaderFunctions callback when load complete
       * @returns
       */
      async load(url, loaderFunctions) {
        let loader = new FileLoader();
        let parser = await loader.load(url, RGBEParser, loaderFunctions);
        return parser.getHDRTexture();
      }
    }

    const _floatView = new Float32Array(1);
    const _int32View = new Int32Array(_floatView.buffer);
    let toHalfFloat = function(val) {
      _floatView[0] = val;
      const x = _int32View[0];
      let bits = x >> 16 & 32768;
      let m = x >> 12 & 2047;
      const e = x >> 23 & 255;
      if (e < 103)
        return bits;
      if (e > 142) {
        bits |= 31744;
        bits |= (e == 255 ? 1 : 0) && x & 8388607;
        return bits;
      }
      if (e < 114) {
        m |= 2048;
        bits |= (m >> 114 - e) + (m >> 113 - e & 1);
        return bits;
      }
      bits |= e - 112 << 10 | m >> 1;
      bits += m & 1;
      return bits;
    };

    var RGBEErrorCode = /* @__PURE__ */ ((RGBEErrorCode2) => {
      RGBEErrorCode2[RGBEErrorCode2["RGBE_RETURN_FAILURE"] = -1] = "RGBE_RETURN_FAILURE";
      RGBEErrorCode2[RGBEErrorCode2["rgbe_read_error"] = 1] = "rgbe_read_error";
      RGBEErrorCode2[RGBEErrorCode2["rgbe_write_error"] = 2] = "rgbe_write_error";
      RGBEErrorCode2[RGBEErrorCode2["rgbe_format_error"] = 3] = "rgbe_format_error";
      RGBEErrorCode2[RGBEErrorCode2["rgbe_memory_error"] = 4] = "rgbe_memory_error";
      return RGBEErrorCode2;
    })(RGBEErrorCode || {});
    class RGBEHeader {
      valid;
      string;
      comments;
      programtype;
      format;
      gamma;
      exposure;
      width;
      height;
    }
    class RGBEParser extends ParserBase {
      // static format: string = 'bin';
      _rgbeArray;
      _width;
      _height;
      _RGBE_RETURN_FAILURE = -1;
      // parserType: GPUTextureFormat = GPUTextureFormat.rgba16float;
      _parserType = GPUTextureFormat.rgba8uint;
      parseBuffer(buffer) {
        let ret_texture;
        let byteArray = new Uint8Array(buffer);
        byteArray["pos"] = 0;
        const rgbe_header_info = this.paserHeader(byteArray);
        if (rgbe_header_info instanceof RGBEHeader) {
          const w = this._width = rgbe_header_info.width;
          const h = this._height = rgbe_header_info.height;
          let image_rgba_data = this.parserPixel(byteArray.subarray(byteArray["pos"]), w, h);
          if (image_rgba_data instanceof Uint8Array) {
            this._rgbeArray = image_rgba_data;
            switch (this._parserType) {
            }
            this.data = ret_texture;
            return ret_texture;
          }
        }
        return null;
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data && this.data instanceof Texture) {
          return true;
        } else if (this._rgbeArray) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
      getTexture() {
        return this.data;
      }
      getCubeTexture() {
        let size = this._width / 4;
        let cubeTexture = new HDRTextureCube().createFromHDRData(size, {
          width: this._width,
          height: this._height,
          array: this._rgbeArray
        });
        return cubeTexture;
      }
      getHDRTexture() {
        let texture = new HDRTexture().create(this._width, this._height, this._rgbeArray);
        return texture;
      }
      parseError(rgbe_error_code, msg) {
        switch (rgbe_error_code) {
          case 1 /* rgbe_read_error */:
            console.error("Read Error: " + (msg || ""));
            break;
          case 2 /* rgbe_write_error */:
            console.error("Write Error: " + (msg || ""));
            break;
          case 3 /* rgbe_format_error */:
            console.error("Bad File Format: " + (msg || ""));
            break;
          default:
          case 4 /* rgbe_memory_error */:
            console.error("Error: " + (msg || ""));
        }
        return -1 /* RGBE_RETURN_FAILURE */;
      }
      parserBlock(buffer, lineLimit, consume) {
        const chunkSize = 128;
        lineLimit = !lineLimit ? 1024 : lineLimit;
        let p = buffer["pos"], i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        const next = "\n";
        while (0 > (i = chunk.indexOf(next)) && len < lineLimit && p < buffer.byteLength) {
          s += chunk;
          len += chunk.length;
          p += chunkSize;
          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));
        }
        if (-1 < i) {
          if (false !== consume)
            buffer["pos"] += len + i + 1;
          return s + chunk.slice(0, i);
        }
        return false;
      }
      paserHeader(buffer) {
        const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = new RGBEHeader();
        let line, match;
        if (buffer["pos"] >= buffer.byteLength || !(line = this.parserBlock(buffer))) {
          return this.parseError(1 /* rgbe_read_error */, "no header found");
        }
        if (!(match = line.match(magic_token_re))) {
          return this.parseError(3 /* rgbe_format_error */, "bad initial token");
        }
        const RGBE_VALID_PROGRAMTYPE = 1;
        const RGBE_VALID_FORMAT = 2;
        const RGBE_VALID_DIMENSIONS = 4;
        header.valid |= RGBE_VALID_PROGRAMTYPE;
        header.programtype = match[1];
        header.string += line + "\n";
        while (true) {
          line = this.parserBlock(buffer);
          if (false === line)
            break;
          header.string += line + "\n";
          if ("#" === line.charAt(0)) {
            header.comments += line + "\n";
            continue;
          }
          if (match = line.match(gamma_re)) {
            header.gamma = Math.floor(parseFloat(match[1]) * 10) / 10;
          }
          if (match = line.match(exposure_re)) {
            header.exposure = Math.floor(parseFloat(match[1]) * 10) / 10;
          }
          if (match = line.match(format_re)) {
            header.valid |= RGBE_VALID_FORMAT;
            header.format = match[1];
          }
          if (match = line.match(dimensions_re)) {
            header.valid |= RGBE_VALID_DIMENSIONS;
            header.height = parseInt(match[1], 10);
            header.width = parseInt(match[2], 10);
          }
          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
            break;
        }
        if (!(header.valid & RGBE_VALID_FORMAT)) {
          this.parseError(3 /* rgbe_format_error */, "missing format specifier");
          return null;
        }
        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
          this.parseError(3 /* rgbe_format_error */, "missing image size specifier");
          return null;
        }
        return header;
      }
      parserPixel(buffer, w, h) {
        const scanline_width = w;
        if (
          // run length encoding is not allowed so read flat
          scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
          2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 128
        ) {
          return new Uint8Array(buffer);
        }
        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {
          return this.parseError(3 /* rgbe_format_error */, "wrong scanline width");
        }
        const data_rgba = new Uint8Array(4 * w * h);
        if (!data_rgba.length) {
          return this.parseError(4 /* rgbe_memory_error */, "unable to allocate buffer space");
        }
        let offset = 0, pos = 0;
        const ptr_end = 4 * scanline_width;
        const rgbeStart = new Uint8Array(4);
        const scanline_buffer = new Uint8Array(ptr_end);
        let num_scanlines = h;
        while (num_scanlines > 0 && pos < buffer.byteLength) {
          if (pos + 4 > buffer.byteLength) {
            return this.parseError(1 /* rgbe_read_error */, "");
          }
          rgbeStart[0] = buffer[pos++];
          rgbeStart[1] = buffer[pos++];
          rgbeStart[2] = buffer[pos++];
          rgbeStart[3] = buffer[pos++];
          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
            return this.parseError(3 /* rgbe_format_error */, "bad rgbe scanline format");
          }
          let ptr = 0, count;
          while (ptr < ptr_end && pos < buffer.byteLength) {
            count = buffer[pos++];
            const isEncodedRun = count > 128;
            if (isEncodedRun)
              count -= 128;
            if (0 === count || ptr + count > ptr_end) {
              return this.parseError(3 /* rgbe_format_error */, "bad scanline data");
            }
            if (isEncodedRun) {
              const byteValue = buffer[pos++];
              for (let i = 0; i < count; i++) {
                scanline_buffer[ptr++] = byteValue;
              }
            } else {
              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);
              ptr += count;
              pos += count;
            }
          }
          const l = scanline_width;
          for (let i = 0; i < l; i++) {
            let off = 0;
            data_rgba[offset] = scanline_buffer[i + off];
            off += scanline_width;
            data_rgba[offset + 1] = scanline_buffer[i + off];
            off += scanline_width;
            data_rgba[offset + 2] = scanline_buffer[i + off];
            off += scanline_width;
            data_rgba[offset + 3] = scanline_buffer[i + off];
            offset += 4;
          }
          num_scanlines--;
        }
        return data_rgba;
      }
      rbgeToFloat(sourceArray, sourceOffset, destArray, destOffset) {
        const e = sourceArray[sourceOffset + 3];
        const scale = Math.pow(2, e - 128) / 255;
        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
        destArray[destOffset + 3] = 1;
      }
      rbgeToHalfFloat(sourceArray, sourceOffset, destArray, destOffset) {
        const e = sourceArray[sourceOffset + 3];
        const scale = Math.pow(2, e - 128) / 255;
        destArray[destOffset + 0] = toHalfFloat(sourceArray[sourceOffset + 0] * scale);
        destArray[destOffset + 1] = toHalfFloat(sourceArray[sourceOffset + 1] * scale);
        destArray[destOffset + 2] = toHalfFloat(sourceArray[sourceOffset + 2] * scale);
        destArray[destOffset + 3] = toHalfFloat(1);
      }
    }

    let IBLEnvMapCreator_cs = (
      /*wgsl*/
      `
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(localPos:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(localPos);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`
    );

    class IBLEnvMapCreator {
      static configBuffer = null;
      static quaternionBuffer = null;
      static blurSettingBuffer = null;
      static pipeline;
      static importantSample(image, dstSize, roughness, dstView) {
        const device = webGPUContext.device;
        if (this.pipeline == null) {
          this.pipeline = device.createComputePipeline({
            layout: `auto`,
            compute: {
              module: device.createShaderModule({
                code: IBLEnvMapCreator_cs
              }),
              entryPoint: "main"
            }
          });
        }
        const computePipeline = this.pipeline;
        const configStride = 4 * 4;
        this.configBuffer ||= device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(this.configBuffer, 0, new Uint32Array([image.width, image.height, dstSize, dstSize]));
        const quaternionSize = 4 * 6;
        if (!this.quaternionBuffer) {
          this.quaternionBuffer = device.createBuffer({
            size: quaternionSize * 4 * 6,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          });
          let qArray = new Float32Array(4 * 6);
          for (let i = 0; i < 6; i++) {
            let q = TextureCubeUtils.getRotationToFace(i);
            qArray[i * 4 + 0] = q.x;
            qArray[i * 4 + 1] = q.y;
            qArray[i * 4 + 2] = q.z;
            qArray[i * 4 + 3] = q.w;
          }
          device.queue.writeBuffer(this.quaternionBuffer, 0, qArray);
        }
        this.blurSettingBuffer ||= device.createBuffer({
          size: configStride,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
        device.queue.writeBuffer(this.blurSettingBuffer, 0, new Float32Array([roughness, 0, 0, 0]));
        const inputImageBuffer = image.erpTexture;
        let entries0 = [
          {
            binding: 0,
            resource: {
              buffer: this.configBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: {
              buffer: this.quaternionBuffer,
              size: quaternionSize * 4
            }
          },
          {
            binding: 2,
            resource: inputImageBuffer.gpuSampler
          },
          {
            binding: 3,
            resource: inputImageBuffer.getGPUView()
          }
        ];
        let entries1 = [
          {
            binding: 0,
            resource: {
              buffer: this.blurSettingBuffer,
              size: 4 * 4
            }
          },
          {
            binding: 1,
            resource: dstView
          }
        ];
        const computeBindGroup0 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: entries0
        });
        const computeBindGroup1 = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(1),
          entries: entries1
        });
        const commandEncoder = GPUContext.beginCommandEncoder();
        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, computeBindGroup0);
        computePass.setBindGroup(1, computeBindGroup1);
        computePass.dispatchWorkgroups(dstSize / 8, dstSize / 8, 6);
        computePass.end();
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class TextureCubeFaceData {
      faceTextureRef;
      _texture;
      constructor(texture) {
        this._texture = texture;
        this.faceTextureRef = {};
      }
      /**
       * fill this texture by a texture2D, which is a 360 panorama image
       * assign mipmap level
       * @param mip mipmap level
       * @param texture a panorama image
       * @returns
       */
      uploadTexture(mip, texture) {
        let gpuSource = this.getGpuSource(mip);
        ErpImage2CubeMap.makeTextureCube(texture, this._texture.width, gpuSource.v);
        return this;
      }
      /**
       * @private
       * @param texture texture reference
       * @returns this
       */
      uploadErpTexture(texture) {
        let gpuSource = this.getGpuSource(0);
        ErpImage2CubeMap.makeTextureCube(texture, this._texture.width, gpuSource.v);
        this.generateMipmap(texture);
        return this;
      }
      /**
       * get GPU texture raw data
       * @param mip mipmap level
       * @returns GPU texture raw data, including t: GPUTexture and v: GPUTextureView
       */
      getGpuSource(mip) {
        let source = this.faceTextureRef[mip];
        if (!source) {
          source = {
            t: this._texture.getGPUTexture(),
            v: this._texture.getGPUTexture().createView({
              format: this._texture.format,
              dimension: "2d-array",
              baseMipLevel: mip,
              mipLevelCount: 1,
              arrayLayerCount: 6
            })
          };
          this.faceTextureRef[mip] = source;
        }
        return source;
      }
      /**
       * @private generateMipmap
       * @param texture texture reference
       */
      generateMipmap(texture) {
        let mipmap = 1;
        while (mipmap < this._texture.mipmapCount) {
          this.generateMipmapAtLevel(mipmap, texture);
          mipmap++;
        }
      }
      /**
       * @private Generate a specified level of Mipmap
       * @param mipmap mipmap level
       * @param erpTexture ERP Texture Object
       * @param pow power
       */
      generateMipmapAtLevel(mipmap, erpTexture, pow = 3) {
        let mipFaceSize = this._texture.width / Math.pow(2, mipmap);
        let image = { width: mipFaceSize, height: mipFaceSize, erpTexture };
        let roughness = (mipmap + 1) / this._texture.mipmapCount;
        roughness = Math.pow(roughness, pow);
        let gpuSource = this.getGpuSource(mipmap);
        IBLEnvMapCreator.importantSample(image, mipFaceSize, roughness, gpuSource.v);
      }
    }

    class HDRTextureCube extends TextureCube {
      _url;
      _faceData;
      /**
       * create a cube texture, it's high dynamic range texture
       */
      constructor() {
        super();
        this.useMipmap = true;
        this.format = GPUTextureFormat.rgba16float;
        this.isHDRTexture = true;
        this._faceData = new TextureCubeFaceData(this);
      }
      /**
       * fill this texture by array of numbers;the format as [red0, green0, blue0, alpha0, red1, green1, blue1, alpha1...]
       * @param size assign the cube texture size
       * @param data raw data of cubeTexture; the format is { width: number; height: number; array: Uint8Array }
       * @returns
       */
      createFromHDRData(size, data) {
        let texture = new VirtualTexture(data.width, data.height, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        let float32Array = new Float32Array(data.array);
        ErpImage2CubeMap.convertRGBE2RGBA(texture, float32Array);
        this.createFromTexture(size, texture);
        return this;
      }
      /**
       * fill this texture by a texture2D, which is a 360 panorama image
       * @param size assign the cube texture size
       * @param texture the image texture
       * @returns
       */
      createFromTexture(size, texture) {
        this.width = this.height = size;
        this.textureBindingLayout.viewDimension = "cube";
        let mipmapSize = this.width;
        this.mipmapCount = 1;
        while (mipmapSize > 16) {
          mipmapSize /= 2;
          this.mipmapCount++;
        }
        this.createTextureDescriptor(size, size, this.mipmapCount, this.format);
        this.textureDescriptor.size = { width: size, height: size, depthOrArrayLayers: 6 };
        this.textureDescriptor.dimension = "2d";
        this.gpuSampler = webGPUContext.device.createSampler(this);
        this._faceData.uploadErpTexture(texture);
        return this;
      }
      /**
      * load texture data from web url, which is a 360 panorama image
      * @param url web url
      * @param loaderFunctions callback function when load complete
      */
      async load(url, loaderFunctions) {
        this._url = url;
        let loader = new FileLoader();
        let parser = await loader.load(url, RGBEParser, loaderFunctions);
        return parser.getCubeTexture();
      }
    }

    function arrayToString(array) {
      const utf8decoder = new TextDecoder();
      return utf8decoder.decode(array);
    }

    class FeatureTable {
      buffer;
      binOffset;
      binLength;
      header;
      constructor(buffer, start, headerLength, binLength) {
        this.buffer = buffer;
        this.binOffset = start + headerLength;
        this.binLength = binLength;
        let header = null;
        if (headerLength !== 0) {
          const headerData = new Uint8Array(buffer, start, headerLength);
          header = JSON.parse(arrayToString(headerData));
        } else {
          header = {};
        }
        this.header = header;
      }
      getKeys() {
        return Object.keys(this.header);
      }
      getData(key, count, defaultComponentType = null, defaultType = null) {
        const header = this.header;
        if (!(key in header)) {
          return null;
        }
        const feature = header[key];
        if (!(feature instanceof Object)) {
          return feature;
        } else if (Array.isArray(feature)) {
          return feature;
        } else {
          const { buffer, binOffset, binLength } = this;
          const byteOffset = feature.byteOffset || 0;
          const featureType = feature.type || defaultType;
          const featureComponentType = feature.componentType || defaultComponentType;
          if ("type" in feature && defaultType && feature.type !== defaultType) {
            throw new Error("FeatureTable: Specified type does not match expected type.");
          }
          let stride;
          switch (featureType) {
            case "SCALAR":
              stride = 1;
              break;
            case "VEC2":
              stride = 2;
              break;
            case "VEC3":
              stride = 3;
              break;
            case "VEC4":
              stride = 4;
              break;
            default:
              throw new Error(`FeatureTable : Feature type not provided for "${key}".`);
          }
          let data;
          const arrayStart = binOffset + byteOffset;
          const arrayLength = count * stride;
          switch (featureComponentType) {
            case "BYTE":
              data = new Int8Array(buffer, arrayStart, arrayLength);
              break;
            case "UNSIGNED_BYTE":
              data = new Uint8Array(buffer, arrayStart, arrayLength);
              break;
            case "SHORT":
              data = new Int16Array(buffer, arrayStart, arrayLength);
              break;
            case "UNSIGNED_SHORT":
              data = new Uint16Array(buffer, arrayStart, arrayLength);
              break;
            case "INT":
              data = new Int32Array(buffer, arrayStart, arrayLength);
              break;
            case "UNSIGNED_INT":
              data = new Uint32Array(buffer, arrayStart, arrayLength);
              break;
            case "FLOAT":
              data = new Float32Array(buffer, arrayStart, arrayLength);
              break;
            case "DOUBLE":
              data = new Float64Array(buffer, arrayStart, arrayLength);
              break;
            default:
              throw new Error(`FeatureTable : Feature component type not provided for "${key}".`);
          }
          const dataEnd = arrayStart + arrayLength * data.BYTES_PER_ELEMENT;
          if (dataEnd > binOffset + binLength) {
            throw new Error("FeatureTable: Feature data read outside binary body length.");
          }
          return data;
        }
      }
    }
    class BatchTable extends FeatureTable {
      batchSize;
      constructor(buffer, batchSize, start, headerLength, binLength) {
        super(buffer, start, headerLength, binLength);
        this.batchSize = batchSize;
      }
      getData(key, componentType = null, type = null) {
        return super.getData(key, this.batchSize, componentType, type);
      }
    }

    function readMagicBytes(bufferOrDataView) {
      let view;
      if (bufferOrDataView instanceof DataView) {
        view = bufferOrDataView;
      } else {
        view = new DataView(bufferOrDataView);
      }
      if (String.fromCharCode(view.getUint8(0)) === "{") {
        return null;
      }
      let magicBytes = "";
      for (let i = 0; i < 4; i++) {
        magicBytes += String.fromCharCode(view.getUint8(i));
      }
      return magicBytes;
    }

    class B3DMLoaderBase {
      async parse(buffer) {
        const dataView = new DataView(buffer);
        const magic = readMagicBytes(dataView);
        console.assert(magic === "b3dm");
        const version = dataView.getUint32(4, true);
        console.assert(version === 1);
        const byteLength = dataView.getUint32(8, true);
        console.assert(byteLength === buffer.byteLength);
        const featureTableJSONByteLength = dataView.getUint32(12, true);
        const featureTableBinaryByteLength = dataView.getUint32(16, true);
        const batchTableJSONByteLength = dataView.getUint32(20, true);
        const batchTableBinaryByteLength = dataView.getUint32(24, true);
        const featureTableStart = 28;
        const featureTable = new FeatureTable(
          buffer,
          featureTableStart,
          featureTableJSONByteLength,
          featureTableBinaryByteLength
        );
        const batchTableStart = featureTableStart + featureTableJSONByteLength + featureTableBinaryByteLength;
        const batchTable = new BatchTable(
          buffer,
          featureTable.getData("BATCH_LENGTH"),
          batchTableStart,
          batchTableJSONByteLength,
          batchTableBinaryByteLength
        );
        const glbStart = batchTableStart + batchTableJSONByteLength + batchTableBinaryByteLength;
        const glbBytes = new Uint8Array(buffer, glbStart, byteLength - glbStart);
        return {
          version,
          featureTable,
          batchTable,
          glbBytes
        };
      }
    }

    class B3DMLoader extends B3DMLoaderBase {
      adjustmentTransform;
      gltfBuffer;
      static tempMatrix;
      constructor() {
        super();
        this.adjustmentTransform = new Matrix4().identity();
        B3DMLoader.tempMatrix ||= new Matrix4().identity();
      }
      async parse(buffer) {
        const b3dm = await super.parse(buffer);
        this.gltfBuffer = b3dm.glbBytes.slice().buffer;
        let glbLoader = new B3DMParseUtil();
        let model = await glbLoader.parseBinary(this.gltfBuffer);
        let { batchTable, featureTable } = b3dm;
        const rtcCenter = featureTable.getData("RTC_CENTER");
        if (rtcCenter) {
          model.x += rtcCenter[0];
          model.y += rtcCenter[1];
          model.z += rtcCenter[2];
        }
        let transform = model.getComponent(Transform);
        transform.updateWorldMatrix();
        let tempMatrix = B3DMLoader.tempMatrix;
        tempMatrix.compose(transform.localPosition, transform.localRotQuat, transform.localScale);
        tempMatrix.multiply(this.adjustmentTransform);
        let prs = tempMatrix.decompose(Orientation3D.QUATERNION);
        transform.localRotQuat.copyFrom(prs[1]);
        transform.localRotQuat = transform.localRotQuat;
        transform.localPosition.copyFrom(prs[0]);
        transform.localPosition = transform.localPosition;
        transform.localScale.copyFrom(prs[2]);
        transform.localScale = transform.localScale;
        transform.updateWorldMatrix();
        model["batchTable"] = batchTable;
        model["featureTable"] = featureTable;
        return model;
      }
      static decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        let s = "";
        for (let i = 0, il = array.length; i < il; i++) {
          s += String.fromCharCode(array[i]);
        }
        try {
          return decodeURIComponent(escape(s));
        } catch (e) {
          return s;
        }
      }
    }

    class B3DMParser extends ParserBase {
      static format = ParserFormat.JSON;
      async parseBuffer(buffer) {
        let loader = new B3DMLoader();
        loader.adjustmentTransform = this.userData;
        this.data = await loader.parse(buffer);
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
    }
    const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
    const BINARY_EXTENSION_HEADER_LENGTH = 12;
    const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
    const EXTENSIONS = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    class GLTFBinaryExtension {
      name;
      content;
      body;
      header;
      constructor(data) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;
        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
        this.header = {
          magic: B3DMLoader.decodeText(new Uint8Array(data.slice(0, 4))),
          version: headerView.getUint32(4, true),
          length: headerView.getUint32(8, true)
        };
        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
          throw new Error("GLTFLoader: Unsupported glTF-Binary header.");
        } else if (this.header.version < 2) {
          throw new Error("GLTFLoader: Legacy binary file detected.");
        }
        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        let chunkIndex = 0;
        while (chunkIndex < chunkContentsLength) {
          const chunkLength = chunkView.getUint32(chunkIndex, true);
          chunkIndex += 4;
          const chunkType = chunkView.getUint32(chunkIndex, true);
          chunkIndex += 4;
          if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
            const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
            this.content = B3DMLoader.decodeText(contentArray);
          } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
            const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
            this.body = data.slice(byteOffset, byteOffset + chunkLength);
          }
          chunkIndex += chunkLength;
        }
        if (this.content === null) {
          throw new Error("GLTFLoader: JSON content not found.");
        }
      }
    }
    class B3DMParseUtil {
      _binary;
      async parseBinary(bytes) {
        this._binary = bytes;
        const magic = B3DMLoader.decodeText(new Uint8Array(this._binary, 0, 4));
        const extensions = {};
        let content;
        let info;
        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            info = extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(this._binary);
          } catch (error) {
            return;
          }
          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = B3DMLoader.decodeText(new Uint8Array(this._binary));
        }
        const json = JSON.parse(content);
        let obj3d = await this.parseGLB(json, info.body);
        return obj3d;
      }
      async parseGLB(json, bin) {
        let loader = new GLBParser();
        let obj3d = await loader.parseJsonAndBuffer(json, bin);
        return obj3d;
      }
    }

    class I3DMLoaderBase {
      async parse(buffer) {
        const dataView = new DataView(buffer);
        const magic = readMagicBytes(dataView);
        console.assert(magic === "i3dm");
        const version = dataView.getUint32(4, true);
        console.assert(version === 1);
        const byteLength = dataView.getUint32(8, true);
        console.assert(byteLength === buffer.byteLength);
        const featureTableJSONByteLength = dataView.getUint32(12, true);
        const featureTableBinaryByteLength = dataView.getUint32(16, true);
        const batchTableJSONByteLength = dataView.getUint32(20, true);
        const batchTableBinaryByteLength = dataView.getUint32(24, true);
        dataView.getUint32(28, true);
        const featureTableStart = 32;
        const featureTable = new FeatureTable(
          buffer,
          featureTableStart,
          featureTableJSONByteLength,
          featureTableBinaryByteLength
        );
        const batchTableStart = featureTableStart + featureTableJSONByteLength + featureTableBinaryByteLength;
        const batchTable = new BatchTable(
          buffer,
          featureTable.getData("INSTANCES_LENGTH"),
          batchTableStart,
          batchTableJSONByteLength,
          batchTableBinaryByteLength
        );
        const glbStart = batchTableStart + batchTableJSONByteLength + batchTableBinaryByteLength;
        const glbBytes = new Uint8Array(buffer, glbStart, byteLength - glbStart);
        return {
          version,
          featureTable,
          batchTable,
          glbBytes
        };
      }
    }

    class InstancedMesh extends exports.Object3D {
      _geometry;
      _material;
      _instanceList;
      constructor(geometry, material, length) {
        super();
        this._geometry = geometry;
        this._material = material;
        this._instanceList = [];
        for (let i = 0; i < length; i++) {
          let component;
          let child = new exports.Object3D();
          component = child.addComponent(exports.MeshRenderer);
          component.geometry = this._geometry;
          component.material = this._material;
          this.addChild(child);
          this._instanceList.push(child);
        }
      }
      setMatrixAt(index, matrix) {
        let instance = this._instanceList[index];
        let prs = matrix.decompose(Orientation3D.QUATERNION);
        let transform = instance.transform;
        transform.localRotQuat.copyFrom(prs[1]);
        transform.localRotQuat = transform.localRotQuat;
        transform.localPosition.copyFrom(prs[0]);
        transform.localPosition = transform.localPosition;
        transform.localScale.copyFrom(prs[2]);
        transform.localScale = transform.localScale;
        return this;
      }
      // public setMatrixAt1(index: number, matrix: Matrix4) {
      //     let instance = this.getIndex(index);
      //     let p = new Vector3();
      //     let r = new Quaternion();
      //     let s = new Vector3();
      //     matrix.decompose1(p, r, s);
      //     let childTransform = instance.transform;
      //     childTransform.localRotQuat = r;
      //     childTransform.localPosition = p;
      //     childTransform.localScale = s;
      // }
    }

    class I3DMLoader extends I3DMLoaderBase {
      static tempFwd;
      static tempUp;
      static tempRight;
      static tempPos;
      static tempQuat;
      static tempSca;
      static tempMat;
      adjustmentTransform;
      _gltfBuffer;
      constructor() {
        super();
        I3DMLoader.tempFwd ||= new Vector3();
        I3DMLoader.tempUp ||= new Vector3();
        I3DMLoader.tempRight ||= new Vector3();
        I3DMLoader.tempPos ||= new Vector3();
        I3DMLoader.tempQuat ||= new Quaternion();
        I3DMLoader.tempSca ||= new Vector3();
        I3DMLoader.tempMat ||= new Matrix4();
        this.adjustmentTransform = new Matrix4().identity();
      }
      async parse(buffer) {
        const i3dm = await super.parse(buffer);
        this._gltfBuffer = i3dm.glbBytes.slice().buffer;
        let glbLoader = new B3DMParseUtil();
        let model = await glbLoader.parseBinary(this._gltfBuffer);
        let { batchTable, featureTable } = i3dm;
        const adjustmentTransform = this.adjustmentTransform;
        const INSTANCES_LENGTH = featureTable.getData("INSTANCES_LENGTH");
        const POSITION = featureTable.getData("POSITION", INSTANCES_LENGTH, "FLOAT", "VEC3");
        const NORMAL_UP = featureTable.getData("NORMAL_UP", INSTANCES_LENGTH, "FLOAT", "VEC3");
        const NORMAL_RIGHT = featureTable.getData("NORMAL_RIGHT", INSTANCES_LENGTH, "FLOAT", "VEC3");
        const SCALE_NON_UNIFORM = featureTable.getData("SCALE_NON_UNIFORM", INSTANCES_LENGTH, "FLOAT", "VEC3");
        const SCALE = featureTable.getData("SCALE", INSTANCES_LENGTH, "FLOAT", "SCALAR");
        const instanceMap = /* @__PURE__ */ new Map();
        const instances = [];
        model.traverse((child) => {
          let renderer;
          renderer = child ? child.getComponent(exports.MeshRenderer) : null;
          if (renderer) {
            const { geometry, material } = renderer;
            const instancedMesh = new InstancedMesh(geometry, material, INSTANCES_LENGTH);
            instancedMesh.localPosition = instancedMesh.localPosition.copy(child.localPosition);
            instancedMesh.localRotation = instancedMesh.localRotation.copy(child.localRotation);
            instancedMesh.localScale = instancedMesh.localScale.copy(child.localScale);
            instances.push(instancedMesh);
            instanceMap.set(child, instancedMesh);
          }
        });
        const averageVector = new Vector3();
        for (let i = 0; i < INSTANCES_LENGTH; i++) {
          averageVector.x += POSITION[i * 3 + 0] / INSTANCES_LENGTH;
          averageVector.y += POSITION[i * 3 + 1] / INSTANCES_LENGTH;
          averageVector.z += POSITION[i * 3 + 2] / INSTANCES_LENGTH;
        }
        instanceMap.forEach((instancedMesh, oldObject) => {
          const parent = oldObject.parent ? oldObject.parentObject : null;
          if (parent) {
            parent.removeChild(oldObject);
            parent.addChild(instancedMesh);
            instancedMesh.transform.updateWorldMatrix();
            instancedMesh.transform.worldMatrix.transformVector4(averageVector, instancedMesh.localPosition);
          }
        });
        const temp = I3DMLoader;
        for (let i = 0; i < INSTANCES_LENGTH; i++) {
          temp.tempMat.identity();
          temp.tempPos.set(
            POSITION[i * 3 + 0] - averageVector.x,
            POSITION[i * 3 + 1] - averageVector.y,
            POSITION[i * 3 + 2] - averageVector.z
          );
          if (NORMAL_UP) {
            temp.tempUp.set(NORMAL_UP[i * 3 + 0], NORMAL_UP[i * 3 + 1], NORMAL_UP[i * 3 + 2]);
            temp.tempRight.set(NORMAL_RIGHT[i * 3 + 0], NORMAL_RIGHT[i * 3 + 1], NORMAL_RIGHT[i * 3 + 2]);
            temp.tempRight.crossProduct(temp.tempUp, temp.tempFwd).normalize();
            temp.tempMat.makeBasis(temp.tempRight, temp.tempUp, temp.tempFwd);
            temp.tempQuat.setFromRotationMatrix(temp.tempMat);
          } else {
            temp.tempQuat.set(0, 0, 0, 1);
          }
          if (SCALE) {
            temp.tempSca.setScalar(SCALE[i]);
          } else if (SCALE_NON_UNIFORM) {
            temp.tempSca.set(
              SCALE_NON_UNIFORM[i * 3 + 0],
              SCALE_NON_UNIFORM[i * 3 + 1],
              SCALE_NON_UNIFORM[i * 3 + 2]
            );
          } else {
            temp.tempSca.set(1, 1, 1);
          }
          temp.tempMat.compose(temp.tempPos, temp.tempQuat, temp.tempSca);
          temp.tempMat.multiplyMatrices(temp.tempMat, adjustmentTransform);
          for (let j = 0, l = instances.length; j < l; j++) {
            const instance = instances[j];
            instance.setMatrixAt(i, temp.tempMat);
          }
        }
        model["batchTable"] = batchTable;
        model["featureTable"] = featureTable;
        return model;
      }
    }

    class I3DMParser extends ParserBase {
      static format = ParserFormat.BIN;
      async parseBuffer(buffer) {
        let loader = new I3DMLoader();
        loader.adjustmentTransform = this.userData;
        this.data = await loader.parse(buffer);
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
    }

    class LDRTextureCube extends TextureCube {
      _faceData;
      _url;
      /**
       * constructor: create a cube texture, it's low dynamic range texture
       */
      get ldrImageUrl() {
        return this._url;
      }
      constructor() {
        super();
        this.useMipmap = true;
        this.format = GPUTextureFormat.rgba16float;
        this._faceData = new TextureCubeFaceData(this);
      }
      /**
      * load texture data from web url, which is a 360 panorama image
      * @param url web url
      * @param loaderFunctions callback function when load complete
      */
      async load(url, loaderFunctions) {
        this._url = url;
        let bitmapTexture = new BitmapTexture2D(false);
        await bitmapTexture.load(url, loaderFunctions);
        this.createFromLDRTexture(bitmapTexture);
        return this;
      }
      /**
       *
       * Create a texture cube
       * @param srcTexture The cube texture will be created from this 2D texture
       * @returns this
       */
      createFromLDRTexture(srcTexture) {
        let size = Math.log2(srcTexture.width / 4);
        size = Math.pow(2, Math.round(size));
        this.createFromTexture(size, srcTexture);
        return this;
      }
      /**
       *
       * create cube texture by environment image
       * @param size size of cube texture
       * @param texture source texture
       */
      createFromTexture(size, texture) {
        this.width = this.height = size;
        this.textureBindingLayout.viewDimension = "cube";
        let mipmapSize = this.width;
        this.mipmapCount = 1;
        while (mipmapSize > 16) {
          mipmapSize /= 2;
          this.mipmapCount++;
        }
        this.createTextureDescriptor(size, size, this.mipmapCount, this.format);
        this.textureDescriptor.size = { width: size, height: size, depthOrArrayLayers: 6 };
        this.textureDescriptor.dimension = "2d";
        this.gpuSampler = webGPUContext.device.createSampler(this);
        this._faceData.uploadErpTexture(texture);
        return this;
      }
    }

    let BRDFLUT = (
      /*wgsl*/
      `
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`
    );

    class BRDFLUTGenerate {
      compute;
      constructor() {
        this.compute = new ComputeShader(BRDFLUT);
      }
      generateBRDFLUTTexture() {
        let texture = new VirtualTexture(256, 256, GPUTextureFormat.rgba8unorm, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        this.compute.setStorageTexture("brdflutTexture", texture);
        this.compute.workerSizeX = 256 / 8;
        this.compute.workerSizeY = 256 / 8;
        let commandEncoder = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(commandEncoder, [this.compute]);
        GPUContext.endCommandEncoder(commandEncoder);
        return texture;
      }
    }

    class Uint8ArrayTexture extends Texture {
      _dataBuffer;
      /**
       * create texture by number array, which format is uint8
       * @param width width of texture
       * @param height height of texture
       * @param data uint8 array
       * @param useMipmap whether or not gen mipmap
       * @returns
       */
      create(width, height, data, useMipmap = false) {
        let device = webGPUContext.device;
        const bytesPerRow = Math.ceil(width * 4 / 256) * 256;
        this.format = GPUTextureFormat.rgba8unorm;
        this.mipmapCount = Math.floor(useMipmap ? Math.log2(width) : 1);
        this.createTextureDescriptor(width, height, this.mipmapCount, this.format);
        const textureDataBuffer = this._dataBuffer = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, data);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        if (useMipmap) {
          TextureMipmapGenerator.webGPUGenerateMipmap(this);
        }
        return this;
      }
      /**
       * validate the change of this texture
       */
      updateTexture(width, height, data) {
        let device = webGPUContext.device;
        const bytesPerRow = Math.ceil(width * 4 / 256) * 256;
        this.mipmapCount = Math.floor(Math.log2(width) );
        this._dataBuffer && this._dataBuffer.destroy();
        this._dataBuffer = null;
        const textureDataBuffer = this._dataBuffer = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, data);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        this.gpuSampler = device.createSampler(this);
        if (this.mipmapCount > 1) {
          TextureMipmapGenerator.webGPUGenerateMipmap(this);
        }
      }
    }

    class GUISprite {
      id;
      guiTexture;
      //Information on maps in the atlas
      //xy：offset， zw：width，height
      uvRec = new Vector4(0, 0, 1, 1);
      uvBorder = new Vector4(0, 0, 0, 0);
      //Real white space used to restore the map
      offsetSize = new Vector4(0, 0, 4, 4);
      borderSize = new Vector4(0, 0, 0, 0);
      //size after trim
      trimSize = new Vector2();
      isSliced = false;
      height = 4;
      width = 4;
      xadvance = 0;
      xoffset = 0;
      yoffset = 0;
      constructor(texture) {
        this.guiTexture = texture || Engine3D.res.defaultGUITexture;
      }
    }

    class GUITexture {
      static _maxUid = -1;
      //Self increasing number, starting from 0
      _staticId = -1;
      //When rendering, dynamically assign subscripts.
      //Given the ability, the maximum UI map in the engine can be unlimited,
      dynamicId = -1;
      texture;
      width = 1;
      height = 1;
      get staticId() {
        return this._staticId;
      }
      constructor(texture) {
        texture ||= Engine3D.res.whiteTexture;
        this.texture = texture;
        GUITexture._maxUid++;
        this._staticId = GUITexture._maxUid;
        this.init();
      }
      init() {
        this.dynamicId = -1;
        this.width = this.texture.width;
        this.height = this.texture.height;
      }
    }

    class Fonts {
      fntCache = {};
      fntData = {};
      addFontData(face, size, fontData) {
        this.fntData[`${face}${size}`] = fontData;
      }
      getFontData(face, size) {
        return this.fntData[`${face}${size}`];
      }
      addFnt(font, size, id, sprite) {
        let key = `${font}${size}`;
        if (!this.fntCache[key])
          this.fntCache[key] = {};
        this.fntCache[key][id] = sprite;
      }
      getFnt(font, size, id) {
        let key = `${font}${size}`;
        let list = this.fntCache[key];
        return list ? list[id] : this.fntCache[` `];
      }
    }
    let fonts = new Fonts();

    class FontInfo {
      face = "";
      size = 0;
      bold = false;
      italic = false;
      stretchH = 0;
      spacing = "";
      outline = 0;
      lineHeight = 0;
      base = 0;
      scaleW = 0;
      scaleH = 0;
      pages = 0;
      packed = 0;
      alphaChnl = 0;
      redChnl = 0;
      greenChnl = 0;
      blueChnl = 0;
      count = 0;
      fontPage = [];
      fontChar = {};
      constructor() {
      }
    }
    class FontPage {
      id = 0;
      file = "";
    }
    class FontChar {
      id = -1;
      x = 0;
      y = 0;
      width = 0;
      height = 0;
      xoffset = 0;
      yoffset = 0;
      xadvance = 0;
      page = 0;
      chnl = 0;
    }
    class FontParser extends ParserBase {
      static format = ParserFormat.TEXT;
      static parseSprite(guiTexture, fontData) {
        for (const key in fontData.fontChar) {
          if (Object.prototype.hasOwnProperty.call(fontData.fontChar, key)) {
            const charInfo = fontData.fontChar[key];
            let sprite = new GUISprite();
            sprite.id = charInfo.id.toString();
            sprite.offsetSize.set(0, 0, charInfo.width, charInfo.height);
            sprite.trimSize.set(charInfo.width, charInfo.height);
            sprite.width = charInfo.width;
            sprite.height = charInfo.height;
            sprite.xadvance = charInfo.xadvance;
            sprite.xoffset = charInfo.xoffset;
            sprite.yoffset = charInfo.yoffset;
            sprite.guiTexture = guiTexture[charInfo.page];
            sprite.uvRec.set(charInfo.x / fontData.scaleW, (fontData.scaleH - (charInfo.y + charInfo.height)) / fontData.scaleH, charInfo.width / fontData.scaleW, charInfo.height / fontData.scaleH);
            fonts.addFnt(fontData.face, fontData.size, sprite.id, sprite);
          }
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("Method not implemented.");
      }
      async parseString(data) {
        let newLine = this.getNewLine(data);
        let fnt = data;
        let fontData = new FontInfo();
        fnt.trim().split(newLine).forEach((v, i) => {
          if (i < 2) {
            FontParser.readLineProperty(v, fontData);
          } else {
            if (i < fontData.pages + 2) {
              let page = new FontPage();
              FontParser.readLineProperty(v, page);
              fontData.fontPage.push(page);
            } else if (i < fontData.pages + 3) {
              FontParser.readLineProperty(v, fontData);
            } else {
              if (fontData.count > 0) {
                let char = new FontChar();
                FontParser.readLineProperty(v, char);
                fontData.fontChar[char.id] = char;
                fontData.count--;
              }
            }
          }
        });
        fnt = "";
        this.data = fontData;
        await this.loadFontTextures();
      }
      getNewLine(value) {
        if (value.indexOf("\r\n") != -1)
          return "\r\n";
        else if (value.indexOf("\r") != -1)
          return "\r";
        else
          return "\n";
      }
      async loadFontTextures() {
        let images = [];
        let fontData = this.data;
        for (const fontPage of fontData.fontPage) {
          let texturePath = this.baseUrl + fontPage.file;
          await Engine3D.res.loadTexture(texturePath, null, true);
          let texture = Engine3D.res.getTexture(texturePath);
          let source = new GUITexture(texture);
          images.push(source);
        }
        FontParser.parseSprite(images, fontData);
        if (!fontData.fontChar[" "]) {
          FontParser.insertSpaceChar(fontData, images[0]);
        }
      }
      static insertSpaceChar(fontData, texture) {
        let sprite = new GUISprite();
        let width = fontData.size * 0.5;
        let height = fontData.lineHeight * 0.5;
        sprite.id = " ";
        sprite.offsetSize.set(0, 0, fontData.size, fontData.size);
        sprite.trimSize.set(width, height);
        sprite.width = width;
        sprite.height = height;
        sprite.xadvance = 0;
        sprite.xoffset = 0;
        sprite.yoffset = 0;
        sprite.guiTexture = texture;
        sprite.uvRec.set(0, 0, 1e-6, 1e-6);
        fonts.addFnt(fontData.face, fontData.size, sprite.id, sprite);
      }
      static readLineProperty(line, data) {
        line.trim().split(" ").forEach((v, i) => {
          let strArr = v.split("=");
          if (strArr.length > 1) {
            let key = strArr[0];
            let value = strArr[1];
            if (Object.prototype.hasOwnProperty.call(data, key)) {
              if (value.indexOf('"') == -1) {
                data[key] = parseFloat(strArr[1]);
              } else {
                data[key] = value.replace('"', "").replace('"', "");
              }
            }
          }
        });
      }
    }

    function makeAloneSprite(id, texture) {
      let sprite = new GUISprite();
      sprite.id = id;
      sprite.offsetSize.set(0, 0, texture.width, texture.height);
      sprite.trimSize.set(texture.width, texture.height);
      sprite.width = texture.width;
      sprite.height = texture.height;
      sprite.xadvance = 0;
      sprite.xoffset = 0;
      sprite.yoffset = 0;
      sprite.guiTexture = new GUITexture(texture);
      sprite.uvRec.set(0, 0, 1, 1);
      if (!texture.isVideoTexture) {
        texture.flipY = true;
      }
      return sprite;
    }
    function makeGUISprite(source, id, data) {
      let sprite = new GUISprite();
      sprite.guiTexture = source;
      sprite.id = id;
      sprite.uvRec.copyFrom(data.textureRect);
      sprite.trimSize.x = data.textureRect.z;
      sprite.trimSize.y = data.textureRect.w;
      sprite.offsetSize.x = data.textureRectOffset.x;
      sprite.offsetSize.y = data.textureRectOffset.y;
      sprite.offsetSize.z = data.size.x;
      sprite.offsetSize.w = data.size.y;
      sprite.width = data.size.x;
      sprite.height = data.size.y;
      let wScale = 1 / source.width;
      let hScale = 1 / source.height;
      sprite.uvRec.set(sprite.uvRec.x * wScale, sprite.uvRec.y * hScale, sprite.uvRec.z * wScale, sprite.uvRec.w * hScale);
      let tiny = 0.1;
      if (data.border.x <= tiny && data.border.y <= tiny && data.border.z <= tiny && data.border.x <= tiny) {
        sprite.isSliced = false;
      } else {
        sprite.borderSize.copyFrom(data.border);
        sprite.uvBorder.copyFrom(data.border);
        sprite.uvBorder.x -= data.textureRectOffset.x;
        sprite.uvBorder.y -= data.textureRectOffset.y;
        sprite.uvBorder.z = data.border.z - (data.size.x - data.textureRect.z - data.textureRectOffset.x);
        sprite.uvBorder.w = data.border.w - (data.size.y - data.textureRect.w - data.textureRectOffset.y);
        sprite.uvBorder.x /= data.textureRect.z;
        sprite.uvBorder.z /= data.textureRect.z;
        sprite.uvBorder.y /= data.textureRect.w;
        sprite.uvBorder.w /= data.textureRect.w;
        sprite.isSliced = true;
      }
      return sprite;
    }

    class GUIAtlasTexture {
      _spriteMap = /* @__PURE__ */ new Map();
      _spriteList = [];
      //Record Texture Size
      textureSize = new Vector2();
      name;
      //constructor
      constructor(size) {
        this.textureSize.set(size.x, size.y);
      }
      /**
       * create a sprite 
       * @param srcTexture Usually it's an atlas diagram
       * @param id key of sprite
       * @param detail description of sprite
       * @returns GUISprite
       */
      setTexture(srcTexture, id, detail) {
        let sprite = makeGUISprite(srcTexture, id, detail);
        this._spriteMap.set(sprite.id, sprite);
        this._spriteList.push(sprite);
        return sprite;
      }
      /**
      * get a sprite by key/id/name
      * @param id key of sprite
      * @returns GUISprite
      */
      getSprite(id) {
        return this._spriteMap.get(id);
      }
      /**
      * Returns all sprite list
      * @returns list of GUISprite
      */
      get spriteList() {
        return this._spriteList;
      }
    }

    class AtlasParser extends ParserBase {
      static format = ParserFormat.TEXT;
      _json;
      _texture;
      async parseString(data) {
        this._json = JSON.parse(data);
        let textureUrl = this.userData.replace(".json", ".png");
        this._texture = await Engine3D.res.loadTexture(textureUrl, null, true);
        this.data = { json: this._json, texture: this._texture };
        this.parseAtlas();
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
      parseAtlas() {
        let atlas = new GUIAtlasTexture(this._json.size);
        let texture = new GUITexture(this._texture);
        let atlasInfo = this._json.atlas;
        for (const key in atlasInfo) {
          atlas.setTexture(texture, key, atlasInfo[key]);
        }
        Engine3D.res.addAtlas(this.baseUrl, atlas);
        this.data = atlas;
      }
    }

    class Res {
      _texturePool;
      _materialPool;
      _prefabPool;
      // private _prefabLoaderPool: Map<string, PrefabLoader>;
      _gltfPool;
      _geometryPool;
      _atlasList;
      _obj;
      /**
       * @constructor
       */
      constructor() {
        this._texturePool = /* @__PURE__ */ new Map();
        this._materialPool = /* @__PURE__ */ new Map();
        this._prefabPool = /* @__PURE__ */ new Map();
        this._geometryPool = /* @__PURE__ */ new Map();
        this._gltfPool = /* @__PURE__ */ new Map();
        this._atlasList = /* @__PURE__ */ new Map();
        this._obj = /* @__PURE__ */ new Map();
      }
      getGltf(url) {
        return this._gltfPool.get(url);
      }
      /**
      * add a obj with reference of url
      * @param url file path
      * @param texture source obj
      */
      addObj(url, obj) {
        this._obj.set(url, obj);
      }
      /**
       * get obj by url
       * @param url file path
       * @returns
       */
      getObj(url) {
        return this._obj.get(url);
      }
      /**
       * add a texture with reference of url
       * @param url file path
       * @param texture source texture
       */
      addTexture(url, texture) {
        this._texturePool.set(url, texture);
      }
      /**
       * get texture by url
       * @param url file path
       * @returns
       */
      getTexture(url) {
        return this._texturePool.get(url);
      }
      addGeometry(url, geo) {
        this._geometryPool.set(url, geo);
      }
      getGeometry(url) {
        return this._geometryPool.get(url);
      }
      /**
       * add a material with reference of name
       * @param name material name
       * @param mat  target material
       */
      addMat(name, mat) {
        return this._materialPool.set(name, mat);
      }
      /**
       * get material by name
       * @param name material name
       * @returns
       */
      getMat(name) {
        return this._materialPool.get(name);
      }
      /**
       * add prefab with reference name
       * @param name prefab name
       * @param rootScene root object of prefab
       */
      addPrefab(name, rootScene) {
        this._prefabPool.set(name, rootScene);
      }
      /**
       * get prefab by name
       * @param name prefab name
       * @returns
       */
      getPrefab(name) {
        return this._prefabPool.get(name).instantiate();
      }
      addAtlas(name, atlas) {
        atlas.name = name;
        this._atlasList.set(name, atlas);
      }
      getAtlas(name) {
        return this._atlasList.get(name);
      }
      getGUISprite(id) {
        for (let item of this._atlasList.values()) {
          let sprite = item.getSprite(id);
          if (sprite)
            return sprite;
        }
        return null;
      }
      async load(url, c, loaderFunctions) {
        let loader = new FileLoader();
        let parser = await loader.load(url, c, loaderFunctions);
        let ret = parser.data;
        return ret;
      }
      /**
       * load a gltf file
       * @param url the url of file
       * @param loaderFunctions callback
       * @returns
       */
      async loadGltf(url, loaderFunctions) {
        if (this._prefabPool.has(url)) {
          return this._prefabPool.get(url);
        }
        let parser;
        let ext = url.substring(url.lastIndexOf(".")).toLowerCase();
        let loader = new FileLoader();
        if (ext == ".gltf") {
          parser = await loader.load(url, GLTFParser, loaderFunctions);
        } else {
          parser = await loader.load(url, GLBParser, loaderFunctions);
        }
        let obj = parser.data;
        this._prefabPool.set(url, obj);
        this._gltfPool.set(url, parser.gltf);
        return obj;
      }
      /**
       * load obj file
       * @param url obj file path
       * @param loaderFunctions callback
       * @returns
       */
      async loadObj(url, loaderFunctions) {
        if (this._prefabPool.has(url)) {
          return this._prefabPool.get(url);
        }
        let parser;
        let ext = url.substring(url.lastIndexOf(".")).toLowerCase();
        let loader = new FileLoader();
        if (ext == ".obj") {
          parser = await loader.load(url, OBJParser, loaderFunctions);
        }
        let obj = parser.data;
        this._prefabPool.set(url, obj);
        return obj;
      }
      /**
       * load b3dm file by url
       * @param url path of file
       * @param loaderFunctions callback
       * @returns
       */
      async loadB3DM(url, loaderFunctions, userData) {
        if (this._prefabPool.has(url)) {
          return this._prefabPool.get(url);
        }
        let loader = new FileLoader();
        let parser = await loader.load(url, B3DMParser, loaderFunctions, userData);
        let obj = parser.data;
        this._prefabPool.set(url, obj);
        return obj;
      }
      /**
       * load i3dm file by url
       * @param url path of i3dm file
       * @param loaderFunctions callback
       * @returns
       */
      async loadI3DM(url, loaderFunctions, userData) {
        if (this._prefabPool.has(url)) {
          return this._prefabPool.get(url);
        }
        let loader = new FileLoader();
        let parser = await loader.load(url, I3DMParser, loaderFunctions, userData);
        let obj = parser.data;
        this._prefabPool.set(url, obj);
        return obj;
      }
      /**
       * load texture by url
       * @param url texture path
       * @param loaderFunctions callback
       * @param flipY use flip y or not
       * @returns
       */
      async loadTexture(url, loaderFunctions, flipY) {
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let texture = new BitmapTexture2D();
        texture.flipY = flipY;
        await texture.load(url, loaderFunctions);
        this._texturePool.set(url, texture);
        return texture;
      }
      async loadTextureCount(urls, count, loaderFunctions, flipY) {
        return new Promise(
          async (suc, fail) => {
            let total = 0;
            let loadTexture = [];
            if (count == 0) {
              suc(loadTexture);
            }
            for (let j = 0; j < count; j++) {
              const url = urls.shift();
              this.loadTexture(url, loaderFunctions, flipY).then((t) => {
                loadTexture.push(t);
                total++;
                if (total == count) {
                  suc(loadTexture);
                }
              });
            }
          }
        );
      }
      async loadBitmapTextures(urls, count = 5, loaderFunctions, flipY) {
        let loadTexture = [];
        let loadCount = Math.floor(urls.length / count) + 1;
        let last = Math.floor(urls.length % count);
        for (let i = 0; i < loadCount; i++) {
          let list = await this.loadTextureCount(urls, i == loadCount - 1 ? last : count, loaderFunctions, flipY);
          loadTexture.push(...list);
        }
        return loadTexture;
      }
      /**
       * load a hdr texture
       * @param url texture url
       * @param loaderFunctions callback
       * @returns
       */
      async loadHDRTexture(url, loaderFunctions) {
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let hdrTexture = new HDRTexture();
        hdrTexture = await hdrTexture.load(url, loaderFunctions);
        this._texturePool.set(url, hdrTexture);
        return hdrTexture;
      }
      /**
       * load hdr cube texture
       * @param url file url
       * @param loaderFunctions callback
       * @returns
       */
      async loadHDRTextureCube(url, loaderFunctions) {
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let hdrTexture = new HDRTextureCube();
        hdrTexture = await hdrTexture.load(url, loaderFunctions);
        this._texturePool.set(url, hdrTexture);
        return hdrTexture;
      }
      /**
       * load ldr cube texture
       * @param url file path
       * @param loaderFunctions callback
       * @returns
       */
      async loadLDRTextureCube(url, loaderFunctions) {
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let ldrTextureCube = new LDRTextureCube();
        ldrTextureCube = await ldrTextureCube.load(url, loaderFunctions);
        this._texturePool.set(url, ldrTextureCube);
        return ldrTextureCube;
      }
      /**
       * load texture data from array of web url.
       * make sure there are six images in a group,
       * and the order is: nx, px, py, ny, nz, pz
       * @param urls 
       */
      async loadTextureCubeMaps(urls) {
        let url = urls[0];
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let textureCube = new BitmapTextureCube();
        await textureCube.load(urls);
        this._texturePool.set(urls[0], textureCube);
        return textureCube;
      }
      /**
       * load texture data from url.
       * the image is assembled from six images into cross shaped image.
       * @param url the path of image
       */
      async loadTextureCubeStd(url, loaderFunctions) {
        if (this._texturePool.has(url)) {
          return this._texturePool.get(url);
        }
        let cubeMap = new BitmapTextureCube();
        await cubeMap.loadStd(url);
        return cubeMap;
      }
      /**
       * load json data from url.
       * @param url the path of image
       */
      async loadJSON(url, loaderFunctions) {
        return await new FileLoader().loadJson(url, loaderFunctions).then(async (ret) => {
          return ret;
        }).catch((e) => {
          console.log(e);
        });
      }
      /**
       * load font file by url
       * @param url font file url
       * @param loaderFunctions callback
       * @returns
       */
      async loadFont(url, loaderFunctions, userData) {
        let loader = new FileLoader();
        let parser = await loader.load(url, FontParser, loaderFunctions, userData);
        let data = parser.data;
        fonts.addFontData(data.face, data.size, data);
        return parser.data;
      }
      /**
       * load a atlas file by url
       * @param url file path
       * @param loaderFunctions callback
       * @returns
       */
      async loadAtlas(url, loaderFunctions) {
        let loader = new FileLoader();
        let parser = await loader.load(url, AtlasParser, loaderFunctions, url);
        return parser.data;
      }
      /**
       * normal texture
       */
      normalTexture;
      maskTexture;
      whiteTexture;
      blackTexture;
      redTexture;
      blueTexture;
      greenTexture;
      yellowTexture;
      grayTexture;
      defaultSky;
      defaultGUITexture;
      defaultGUISprite;
      defaultMaterial;
      /**
       * create a texture
       * @param width width of texture
       * @param height height of texture
       * @param r component-red
       * @param g component-green
       * @param b component-blue
       * @param a component-alpha（0 for transparent，1 for opaque）
       * @param name name string
       * @returns
       */
      createTexture(width, height, r, g, b, a, name) {
        let w = 32;
        let h = 32;
        let textureData = new Uint8Array(w * h * 4);
        this.fillColor(textureData, width, height, r, g, b, a);
        let texture = new Uint8ArrayTexture();
        texture.name = name;
        texture.create(16, 16, textureData, true);
        if (name) {
          this.addTexture(name, texture);
        }
        return texture;
      }
      /**
       * fill slod color to this texture
       * @param array data of texture
       * @param w width of texture
       * @param h height of texture
       * @param r component-red
       * @param g component-green
       * @param b component-blue
       * @param a component-alpha（0 for transparent，1 for opaque）
       */
      fillColor(array, w, h, r, g, b, a) {
        for (let i = 0; i < w; i++) {
          for (let j = 0; j < h; j++) {
            let pixelIndex = j * w + i;
            array[pixelIndex * 4 + 0] = r;
            array[pixelIndex * 4 + 1] = g;
            array[pixelIndex * 4 + 2] = b;
            array[pixelIndex * 4 + 3] = a;
          }
        }
      }
      /**
       * Initialize a common texture object. Provide a universal solid color texture object.
       */
      initDefault() {
        this.normalTexture = this.createTexture(32, 32, 255 * 0.5, 255 * 0.5, 255, 255, "default-normalTexture");
        this.maskTexture = this.createTexture(32, 32, 255, 255 * 0.5, 255, 255, "default-maskTexture");
        this.whiteTexture = this.createTexture(32, 32, 255, 255, 255, 255, "default-whiteTexture");
        this.blackTexture = this.createTexture(32, 32, 0, 0, 0, 255, "default-blackTexture");
        this.redTexture = this.createTexture(32, 32, 255, 0, 0, 255, "default-redTexture");
        this.blueTexture = this.createTexture(32, 32, 0, 0, 255, 255, "default-blueTexture");
        this.greenTexture = this.createTexture(32, 32, 0, 255, 0, 255, "default-greenTexture");
        this.yellowTexture = this.createTexture(32, 32, 0, 255, 255, 255, "default-yellowTexture");
        this.grayTexture = this.createTexture(32, 32, 128, 128, 128, 255, "default-grayTexture");
        let brdf = new BRDFLUTGenerate();
        let brdf_texture = brdf.generateBRDFLUTTexture();
        let BRDFLUT = brdf_texture.name = "BRDFLUT";
        this.addTexture(BRDFLUT, brdf_texture);
        this.defaultSky = new HDRTextureCube();
        this.defaultSky.createFromTexture(128, this.blackTexture);
        Reference.getInstance().attached(this.defaultSky, this);
        Reference.getInstance().attached(brdf_texture, this);
        Reference.getInstance().attached(this.normalTexture, this);
        Reference.getInstance().attached(this.maskTexture, this);
        Reference.getInstance().attached(this.whiteTexture, this);
        Reference.getInstance().attached(this.blackTexture, this);
        Reference.getInstance().attached(this.redTexture, this);
        Reference.getInstance().attached(this.blueTexture, this);
        Reference.getInstance().attached(this.greenTexture, this);
        Reference.getInstance().attached(this.yellowTexture, this);
        Reference.getInstance().attached(this.grayTexture, this);
        this.defaultGUITexture = new GUITexture(this.whiteTexture);
        this.defaultGUISprite = new GUISprite(this.defaultGUITexture);
        this.defaultGUISprite.trimSize.set(4, 4);
        this.defaultMaterial = new LitMaterial();
      }
    }

    class FXAAPost extends PostBase {
      constructor() {
        super();
        let presentationSize = webGPUContext.presentationSize;
        ShaderLib.register("FXAA_Shader", FXAAShader);
        let rt = this.createRTTexture(`FXAAPost`, presentationSize[0], presentationSize[1], GPUTextureFormat.rgba16float);
        let quad = this.createViewQuad(`fxaa`, "FXAA_Shader", rt);
        quad.quadShader.setUniform("u_texel", new Vector2(1 / presentationSize[0], 1 / presentationSize[1]));
        quad.quadShader.setUniform("u_strength", 4);
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.fxaa.enable = true;
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.fxaa.enable = false;
      }
    }

    class PostProcessingComponent extends ComponentBase {
      _postList;
      init(param) {
        this._postList = /* @__PURE__ */ new Map();
      }
      start() {
      }
      stop() {
      }
      onEnable() {
        this.activePost();
      }
      onDisable() {
        this.unActivePost();
      }
      activePost() {
        let view = this.transform.view3D;
        let job = Engine3D.getRenderJob(view);
        this._postList.forEach((v) => {
          job.addPost(v);
        });
      }
      unActivePost() {
        let view = this.transform.view3D;
        let job = Engine3D.getRenderJob(view);
        this._postList.forEach((v) => {
          job.removePost(v);
        });
      }
      addPost(c) {
        if (this._postList.has(c))
          return;
        if (!this._postList.has(FXAAPost)) {
          let post2 = new FXAAPost();
          this._postList.set(FXAAPost, post2);
          if (this._enable)
            this.activePost();
          if (c === FXAAPost) {
            return post2;
          }
        }
        let post = new c();
        this._postList.set(c, post);
        if (this._enable)
          this.activePost();
        return post;
      }
      removePost(c) {
        if (!this._postList.has(c))
          return;
        let post = this._postList.get(c);
        this._postList.delete(c);
        let view = this.transform.view3D;
        let job = Engine3D.getRenderJob(view);
        job.removePost(post);
      }
      getPost(c) {
        if (!this._postList.has(c))
          return null;
        return this._postList.get(c);
      }
    }

    class Engine3D {
      /**
       * resource manager in engine3d
       */
      static res;
      /**
       * input system in engine3d
       */
      static inputSystem;
      /**
       * more view in engine3d
       */
      static views;
      static _frameRateValue = 0;
      static _frameRate = 360;
      static _frameTimeCount = 0;
      static _deltaTime = 0;
      static _time = 0;
      static _beforeRender;
      static _renderLoop;
      static _lateRender;
      static _requestAnimationFrameID = 0;
      static Engine3D;
      static divB;
      /**
       * set engine render frameRate 24/30/60/114/120/144/240/360 fps or other
       */
      static get frameRate() {
        return this._frameRate;
      }
      /**
       * get engine render frameRate 
       */
      static set frameRate(value) {
        this._frameRate = value;
        this._frameRateValue = 1 / value;
        if (value >= 360) {
          this._frameRateValue = 0;
        }
      }
      /**
       * get render window size width and height
       */
      static get size() {
        return webGPUContext.presentationSize;
      }
      /**
       * get render window aspect
       */
      static get aspect() {
        return webGPUContext.aspect;
      }
      /**
       * get render window size width 
       */
      static get width() {
        return webGPUContext.windowWidth;
      }
      /**
       * get render window size height 
       */
      static get height() {
        return webGPUContext.windowHeight;
      }
      /**
       * engine setting
       */
      static setting = {
        occlusionQuery: {
          enable: true,
          debug: false
        },
        pick: {
          enable: true,
          mode: `bound`,
          detail: `mesh`
        },
        render: {
          debug: false,
          renderPassState: 4,
          renderState_left: 5,
          renderState_right: 5,
          renderState_split: 0.5,
          quadScale: 1,
          hdrExposure: 1.5,
          debugQuad: -1,
          maxPointLight: 1e3,
          maxDirectLight: 4,
          maxSportLight: 1e3,
          drawOpMin: 0,
          drawOpMax: Number.MAX_SAFE_INTEGER,
          drawTrMin: 0,
          drawTrMax: Number.MAX_SAFE_INTEGER,
          zPrePass: false,
          useLogDepth: false,
          gi: false,
          postProcessing: {
            bloom: {
              downSampleStep: 5,
              downSampleBlurSize: 5,
              downSampleBlurSigma: 1,
              upSampleBlurSize: 5,
              upSampleBlurSigma: 1,
              luminanceThreshole: 1,
              bloomIntensity: 1
            },
            globalFog: {
              debug: false,
              enable: false,
              fogType: 0,
              fogHeightScale: 0.1,
              start: 400,
              end: 10,
              density: 0.02,
              ins: 0.5,
              skyFactor: 0.5,
              skyRoughness: 0.4,
              overrideSkyFactor: 0.8,
              fogColor: new Color(96 / 255, 117 / 255, 133 / 255, 1),
              falloff: 0.7,
              rayLength: 200,
              scatteringExponent: 2.7,
              dirHeightLine: 10
            },
            godRay: {
              blendColor: true,
              rayMarchCount: 16,
              scatteringExponent: 5,
              intensity: 0.5
            },
            ssao: {
              enable: false,
              radius: 0.15,
              bias: -0.1,
              aoPower: 2,
              debug: true
            },
            outline: {
              enable: false,
              strength: 1,
              groupCount: 4,
              outlinePixel: 2,
              fadeOutlinePixel: 4,
              textureScale: 0.7,
              useAddMode: false,
              debug: true
            },
            taa: {
              enable: false,
              jitterSeedCount: 8,
              blendFactor: 0.1,
              sharpFactor: 0.6,
              sharpPreBlurFactor: 0.5,
              temporalJitterScale: 0.13,
              debug: true
            },
            gtao: {
              enable: false,
              darkFactor: 1,
              maxDistance: 5,
              maxPixel: 50,
              rayMarchSegment: 6,
              multiBounce: false,
              usePosFloat32: true,
              blendColor: true,
              debug: true
            },
            ssr: {
              enable: false,
              pixelRatio: 1,
              fadeEdgeRatio: 0.2,
              rayMarchRatio: 0.5,
              fadeDistanceMin: 600,
              fadeDistanceMax: 2e3,
              roughnessThreshold: 0.5,
              powDotRN: 0.2,
              mixThreshold: 0.1,
              debug: true
            },
            fxaa: {
              enable: false
            },
            depthOfView: {
              enable: false,
              iterationCount: 3,
              pixelOffset: 1,
              near: 150,
              far: 300
            }
          }
        },
        shadow: {
          enable: true,
          type: "HARD",
          pointShadowBias: 2e-3,
          shadowSize: 1024,
          pointShadowSize: 1024,
          shadowSoft: 5e-3,
          shadowBias: 1e-4,
          needUpdate: true,
          autoUpdate: true,
          updateFrameRate: 2,
          csmMargin: 0.1,
          csmScatteringExp: 0.7,
          csmAreaScale: 0.4,
          debug: false
        },
        gi: {
          enable: false,
          offsetX: 0,
          offsetY: 0,
          offsetZ: 0,
          probeSpace: 64,
          probeXCount: 4,
          probeYCount: 2,
          probeZCount: 4,
          probeSize: 32,
          probeSourceTextureSize: 2048,
          octRTMaxSize: 2048,
          octRTSideSize: 16,
          maxDistance: 64 * 1.73,
          normalBias: 0.25,
          depthSharpness: 1,
          hysteresis: 0.98,
          lerpHysteresis: 0.01,
          //The smaller the value, the slower the reaction, which can counteract flickering
          irradianceChebyshevBias: 0.01,
          rayNumber: 144,
          irradianceDistanceBias: 32,
          indirectIntensity: 1,
          ddgiGamma: 2.2,
          bounceIntensity: 0.025,
          probeRoughness: 1,
          realTimeGI: false,
          debug: false,
          autoRenderProbe: false
        },
        sky: {
          type: "HDRSKY",
          sky: null,
          skyExposure: 1,
          defaultFar: 65536,
          //can't be too big
          defaultNear: 1
        },
        light: {
          maxLight: 4096
        },
        material: {
          materialChannelDebug: false,
          materialDebug: false
        },
        loader: {
          numConcurrent: 20
        }
      };
      /**
       * @internal
       */
      static renderJobs;
      /**
       * create webgpu 3d engine
       * @param descriptor  {@link CanvasConfig}
       * @returns
       */
      static async init(descriptor = {}) {
        console.log("Engine Version", version);
        this.setting = { ...this.setting, ...descriptor.engineSetting };
        await WasmMatrix.init(Matrix4.allocCount);
        await webGPUContext.init(descriptor.canvasConfig);
        ShaderLib.init();
        ShaderUtil.init();
        GlobalBindGroup.init();
        RTResourceMap.init();
        ShadowLightsCollect.init();
        this.res = new Res();
        this.res.initDefault();
        this._beforeRender = descriptor.beforeRender;
        this._renderLoop = descriptor.renderLoop;
        this._lateRender = descriptor.lateRender;
        this.inputSystem = new InputSystem();
        this.inputSystem.initCanvas(webGPUContext.canvas);
        return;
      }
      /**
       * set render view and start renderer
       * @param view 
       * @returns 
       */
      static startRenderView(view) {
        this.renderJobs ||= /* @__PURE__ */ new Map();
        this.views = [view];
        let renderJob = new ForwardRenderJob(view);
        this.renderJobs.set(view, renderJob);
        webGPUContext.presentationSize;
        if (this.setting.pick.mode == `pixel`) {
          let postProcessing = view.scene.getOrAddComponent(PostProcessingComponent);
          postProcessing.addPost(FXAAPost);
        }
        if (this.setting.pick.mode == `pixel` || this.setting.pick.mode == `bound`) {
          view.enablePick = true;
        }
        this.resume();
        return renderJob;
      }
      /**
       * set render views and start renderer
       * @param view 
       * @returns 
       */
      static startRenderViews(views) {
        this.renderJobs ||= /* @__PURE__ */ new Map();
        this.views = views;
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let renderJob = new ForwardRenderJob(view);
          this.renderJobs.set(view, renderJob);
          let presentationSize = webGPUContext.presentationSize;
          if (this.setting.pick.mode == `pixel`) {
            let postProcessing = view.scene.addComponent(PostProcessingComponent);
            postProcessing.addPost(FXAAPost);
          } else {
            RTResourceMap.createRTTexture(RTResourceConfig.colorBufferTex_NAME, presentationSize[0], presentationSize[1], GPUTextureFormat.rgba16float, false);
          }
          if (this.setting.pick.mode == `pixel` || this.setting.pick.mode == `bound`) {
            view.enablePick = true;
          }
        }
        this.resume();
      }
      /**
       * get view render job instance
       * @param view 
       * @returns 
       */
      static getRenderJob(view) {
        return this.renderJobs.get(view);
      }
      /**
       * Pause the engine render
       */
      static pause() {
        if (this._requestAnimationFrameID != 0) {
          cancelAnimationFrame(this._requestAnimationFrameID);
          this._requestAnimationFrameID = 0;
        }
      }
      /**
       * Resume the engine render
       */
      static resume() {
        this._requestAnimationFrameID = requestAnimationFrame((t) => this.render(t));
      }
      /**
       * start engine render
       * @internal
       */
      static render(time) {
        this._deltaTime = time - this._time;
        this._time = time;
        if (this._frameRateValue > 0) {
          this._frameTimeCount += this._deltaTime * 1e-3;
          if (this._frameTimeCount >= this._frameRateValue * 0.95) {
            this._frameTimeCount = 0;
            this.updateFrame(time);
          }
        } else {
          this.updateFrame(time);
        }
        this.resume();
      }
      static updateFrame(time) {
        Time.delta = time - Time.time;
        Time.time = time;
        Time.frame += 1;
        Interpolator.tick(Time.delta);
        let views = this.views;
        let i = 0;
        for (i = 0; i < views.length; i++) {
          const view = views[i];
          view.scene.waitUpdate();
          view.camera.resetPerspective(webGPUContext.aspect);
        }
        if (this._beforeRender)
          this._beforeRender();
        for (const iterator of ComponentCollect.componentsBeforeUpdateList) {
          let k = iterator[0];
          let v = iterator[1];
          for (const iterator2 of v) {
            let f = iterator2[0];
            let c = iterator2[1];
            if (f.enable) {
              c(k);
            }
          }
        }
        let command = webGPUContext.device.createCommandEncoder();
        for (const iterator of ComponentCollect.componentsComputeList) {
          let k = iterator[0];
          let v = iterator[1];
          for (const iterator2 of v) {
            let f = iterator2[0];
            let c = iterator2[1];
            if (f.enable) {
              c(k, command);
            }
          }
        }
        webGPUContext.device.queue.submit([command.finish()]);
        for (const iterator of ComponentCollect.componentsUpdateList) {
          let k = iterator[0];
          let v = iterator[1];
          for (const iterator2 of v) {
            let f = iterator2[0];
            let c = iterator2[1];
            if (f.enable) {
              c(k);
            }
          }
        }
        for (const iterator of ComponentCollect.graphicComponent) {
          let k = iterator[0];
          let v = iterator[1];
          for (const iterator2 of v) {
            let f = iterator2[0];
            let c = iterator2[1];
            if (k && f.enable) {
              c(k);
            }
          }
        }
        if (this._renderLoop) {
          this._renderLoop();
        }
        WasmMatrix.updateAllContinueTransform(0, Matrix4.useCount, 16);
        let globalMatrixBindGroup = GlobalBindGroup.modelMatrixBindGroup;
        globalMatrixBindGroup.writeBuffer(Matrix4.useCount * 16);
        this.renderJobs.forEach((v, k) => {
          if (!v.renderState) {
            v.start();
          }
          v.renderFrame();
        });
        for (const iterator of ComponentCollect.componentsLateUpdateList) {
          let k = iterator[0];
          let v = iterator[1];
          for (const iterator2 of v) {
            let f = iterator2[0];
            let c = iterator2[1];
            if (f.enable) {
              c(k);
            }
          }
        }
        if (this._lateRender)
          this._lateRender();
      }
    }

    let BLUR_CsShader = (
      /* wgsl */
      `
#include "GlobalUniform"

struct UniformData {
  radius: f32 ,
  bias: f32,
  aoPower: f32 ,
  blurSize: f32 ,
};

// @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(0) var<uniform> uniformData: UniformData;
@group(0) @binding(1) var colorMap : texture_2d<f32>;
// @group(0) @binding(2) var ssaoMapSampler : sampler;
@group(0) @binding(2) var ssaoMap : texture_2d<f32>;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

@compute @workgroup_size( 8 , 8 )
fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  var fragCoord = vec2<i32>( globalInvocation_id.xy );

  var texSize = vec2<f32>(textureDimensions(ssaoMap).xy);
  var texCoord = vec2<f32>(fragCoord) / texSize ;

  let blurSize = i32(uniformData.blurSize);

  var result = vec4<f32>(0.0) ;
  var ii = 0.0 ;
  for (var i = -2; i < 2 ; i+=1) {
     for (var j = -2; j < 2 ; j+=1) {
        var offset = vec2<i32>( i , j ) ;
        result += textureLoad(ssaoMap, fragCoord + offset, 0 );
        // result += textureSampleLevel(ssaoMap,ssaoMapSampler, vec2<f32>( fragCoord + offset) / texSize , 0.0 );
        ii += 1.0 ;
     }
  }
  var fResult = result.r / ii ;
  var color = textureLoad(colorMap, fragCoord , 0 );
  textureStore(outTex, fragCoord , vec4(color.rgb * fResult,1.0) );
}
`
    );

    let BloomCfg = (
      /*wgsl*/
      `
struct BloomCfg{
  downSampleStep: f32,
  downSampleBlurSize: f32,
  downSampleBlurSigma: f32,
  upSampleBlurSize: f32,
  upSampleBlurSigma: f32,
  luminanceThreshole: f32,
  bloomIntensity: f32,
  slot: f32,
}
@group(0) @binding(0) var<uniform> bloomCfg: BloomCfg;
`
    );
    let CalcUV_01 = (
      /*wgsl*/
      `
  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

`
    );
    let GaussWeight2D = (
      /*wgsl*/
      `
fn GaussWeight2D(x:f32, y:f32, sigma:f32) -> f32
  {
      let PI = 3.14159265358;
      let E  = 2.71828182846;
      let sigma_2 = pow(sigma, 2);
  
      let a = -(x*x + y*y) / (2.0 * sigma_2);
      return pow(E, a) / (2.0 * PI * sigma_2);
  }
`
    );
    let GaussBlur = function(GaussNxN, inTex, inTexSampler) {
      var code = (
        /*wgsl*/
        `
  
  
  fn ${GaussNxN}(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32>
  {
      var color = vec3<f32>(0.0);
      let r:i32 = n / 2;
      var weight:f32 = 0.0;
  
      for(var i:i32=-r; i<=r; i+=1)
      {
          for(var j=-r; j<=r; j+=1)
          {
              let w = GaussWeight2D(f32(i), f32(j), sigma);
              var coord:vec2<f32> = uv + vec2<f32>(f32(i), f32(j)) * stride;
              // color += tex2D(tex, coord).rgb * w;
              color += textureSampleLevel(${inTex}, ${inTexSampler}, coord, 0.0).xyz * w;
              weight += w;
          }
      }
  
      color /= weight;
      return color;
  }`
      );
      return code;
    };
    let threshold = (
      /*wgsl*/
      `
${BloomCfg}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(inTex, fragCoord, 0);
  let lum = dot(vec3<f32>(0.2126, 0.7152, 0.0722), color.rgb);
  
  // if(lum<=bloomCfg.luminanceThreshole) {
  //   color = vec4<f32>(0,0,0,color.w);
  // }
  var ret = color.xyz;
  var brightness = lum;
  var contribution = max(0, brightness - bloomCfg.luminanceThreshole);
  contribution /=max(brightness, 0.00001);
  ret = ret * contribution;

  textureStore(outTex, fragCoord, vec4<f32>(ret, color.w));
}
`
    );
    let downSample = (
      /*wgsl*/
      `
${BloomCfg}

@group(0) @binding(1) var inTex : texture_2d<f32>;
@group(0) @binding(2) var inTexSampler: sampler;
@group(0) @binding(3) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${GaussWeight2D}
${GaussBlur("GaussNxN", "inTex", "inTexSampler")}
${CalcUV_01}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  let stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));   //  texel size of last level
  let rgb = GaussNxN(uv, i32(bloomCfg.downSampleBlurSize), stride, bloomCfg.downSampleBlurSigma);
  color = vec4<f32>(rgb, color.w);
  textureStore(outTex, fragCoord, color);
}
`
    );
    let upSample = (
      /*wgsl*/
      `
${BloomCfg}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _MainTexSampler: sampler;
@group(0) @binding(3) var _PrevMip : texture_2d<f32>;
@group(0) @binding(4) var _PrevMipSampler: sampler;
@group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

${GaussWeight2D}
${GaussBlur("GaussNxN_0", "_MainTex", "_MainTexSampler")}
${GaussBlur("GaussNxN_1", "_PrevMip", "_PrevMipSampler")}
${CalcUV_01}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
  var uv = CalcUV_01(fragCoord, texSize);
  
  // half stride
  let prev_stride = vec2<f32>(0.5) / vec2<f32>(f32(texSize.x), f32(texSize.y));
  let curr_stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));

  let rgb1 = GaussNxN_1(uv, i32(bloomCfg.upSampleBlurSize), prev_stride, bloomCfg.upSampleBlurSigma);
  let rgb2 = GaussNxN_0(uv, i32(bloomCfg.upSampleBlurSize), curr_stride, bloomCfg.upSampleBlurSigma);
  color = vec4<f32>(rgb1 + rgb2, color.w);
  textureStore(outTex, fragCoord, color);
}
`
    );
    let post = (
      /*wgsl*/
      `
${BloomCfg}
${CalcUV_01}

@group(0) @binding(1) var _MainTex : texture_2d<f32>;
@group(0) @binding(2) var _BloomTex : texture_2d<f32>;
@group(0) @binding(3) var _BloomTexSampler :  sampler;
@group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;

fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
{
    let A = 2.51;
    let B = 0.03;
    let C = 2.43;
    let D = 0.59;
    let E = 0.14;

    var color2 = color * adapted_lum;
    color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
    return color2;
}

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(outTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  var color = textureLoad(_MainTex, fragCoord, 0);
  var uv = CalcUV_01(fragCoord, texSize);
  var bloom = textureSampleLevel(_BloomTex, _BloomTexSampler, uv, 0.0).xyz * bloomCfg.bloomIntensity;
  
  // tone map
  bloom = ACESToneMapping(bloom, 1.0);
  let g = 1.0 / 2.2;
  bloom = saturate(pow(bloom, vec3<f32>(g)));
 
  color = vec4<f32>(color.xyz + bloom.xyz, color.w);
  textureStore(outTex, fragCoord, color);
}
`
    );

    let DepthOfView_cs = (
      /*wgsl*/
      `
#include "GlobalUniform"

  struct BlurSetting{
    near: f32,
    far: f32,
    pixelOffset: f32,
  }
 
  @group(0) @binding(1) var<uniform> blurSetting: BlurSetting;
  @group(0) @binding(2) var positionBufferTex : texture_2d<f32>;
  @group(0) @binding(3) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(4) var inTexSampler : sampler;
  @group(0) @binding(5) var inTex : texture_2d<f32>;
  @group(0) @binding(6) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> cameraPosition: vec3<f32>;
  var<private> texSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> texelSize: vec2<f32>;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(inTex).xy;
    texelSize = 1.0 / vec2<f32>(texSize - 1);
    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    cameraPosition = globalUniform.CameraPos.xyz ;
    let wPosition:vec3<f32> = textureLoad(positionBufferTex, fragCoord , 0).xyz;
    var distance = length(wPosition - cameraPosition);
    var oc:vec4<f32> = textureLoad(inTex, fragCoord, 0);
    if(distance > blurSetting.near){
        let normal = textureLoad(normalBufferTex, fragCoord, 0);
        var pixelScale = 0.5;
        if(normal.w > 0.5){
            distance = min(distance, blurSetting.far);
            pixelScale = (distance - blurSetting.near) / (blurSetting.far - blurSetting.near);
        }
        oc = mixBlurColor(oc, fragCoord, blurSetting.pixelOffset, pixelScale);
    }
    textureStore(outTex, fragCoord, oc);
  }

  fn mixBlurColor(orginColor:vec4<f32>, coord:vec2<i32>, pixelOffset:f32, scale:f32) -> vec4<f32> {

    let uv = vec2<f32>(coord);
    var uv0 = (uv + scale * vec2<f32>( pixelOffset,  pixelOffset)) * texelSize;
    var uv1 = (uv + scale * vec2<f32>(-pixelOffset,  pixelOffset)) * texelSize;
    var uv2 = (uv + scale * vec2<f32>(-pixelOffset, -pixelOffset)) * texelSize;
    var uv3 = (uv + scale * vec2<f32>( pixelOffset, -pixelOffset)) * texelSize;

    uv0.x = processUVEdge(uv0.x);
    uv0.y = processUVEdge(uv0.y);
    uv1.x = processUVEdge(uv1.x);
    uv1.y = processUVEdge(uv1.y);
    uv2.x = processUVEdge(uv2.x);
    uv2.y = processUVEdge(uv2.y);
    uv3.x = processUVEdge(uv3.x);
    uv3.y = processUVEdge(uv3.y);

    var ob = vec4<f32>(0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv0, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv1, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv2, 0.0);
    ob += textureSampleLevel(inTex, inTexSampler, uv3, 0.0);
    return mix(orginColor, ob * 0.25, scale);
  }

  fn processUVEdge(v: f32) -> f32{
      var value = v;
      if(value < 0.0){
        value = - value;
      }else if(value > 1.0){
        value = 2.0 - value;
      }
      return value;
  }
`
    );

    let GTAO_cs = (
      /*wgsl*/
      `
    #include "GlobalUniform"
    
    struct GTAO{
      maxDistance: f32,
      maxPixel: f32,
      darkFactor: f32,
      rayMarchSegment: f32,
      cameraNear: f32,
      cameraFar: f32,
      multiBounce: f32,
      blendColor: f32,
    }

    @group(0) @binding(1) var<uniform> gtaoData: GTAO;
    @group(0) @binding(2) var<storage, read_write> directions : array<vec2<f32>>;
    @group(0) @binding(3) var<storage, read_write> aoBuffer : array<f32>;

    @group(0) @binding(4) var posTex : texture_2d<f32>;
    @group(0) @binding(5) var normalTex : texture_2d<f32>;
    @group(0) @binding(6) var inTex : texture_2d<f32>;
    @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> maxPixelScaled: f32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      let index = fragCoord.x + fragCoord.y * i32(texSize.x);
      let lastFactor = aoBuffer[index];
      var newFactor = 0.0;
      if(wNormal.w < 0.5){//sky
          
      }else{
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          let ndc = globalUniform.projMat * globalUniform.viewMat * vec4<f32>(wPosition, 1.0);
          let ndcZ = ndc.z / ndc.w;
          maxPixelScaled = calcPixelByNDC(ndcZ);
          newFactor = rayMarch();
      }
      
      var factor:f32 = mix(lastFactor, newFactor, 0.6);
      aoBuffer[index] = factor;
      factor = blurFactor(factor);
      factor = saturate(1.0 - factor * gtaoData.darkFactor);
      var gtao = vec3<f32>(factor);
      if(gtaoData.multiBounce > 0.5){
          gtao = MultiBounce(factor, oc.xyz);
      }
      
      var outColor = gtao;
      if(gtaoData.blendColor > 0.5){
          outColor = oc.xyz * gtao;
      }
      // textureStore(outTex, fragCoord , vec4<f32>(vec3f(newFactor), oc.w));
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }
    
    fn MultiBounce(AO:f32, Albedo:vec3<f32>) -> vec3<f32>
    {
        var A = 2 * Albedo - 0.33;
        var B = -4.8 * Albedo + 0.64;
        var C = 2.75 * Albedo + 0.69;
        return max(vec3<f32>(AO), ((AO * A + B) * AO + C) * AO);
    }
    
    fn calcPixelByNDC(ndcZ:f32) -> f32{
      let nearAspect = gtaoData.cameraNear / (gtaoData.cameraFar - gtaoData.cameraNear);
      let aspect = (1.0 + nearAspect) / (ndcZ + nearAspect);
      var viewPortMax = min(f32(texSize.x), f32(texSize.y));
      var maxPixel = min(viewPortMax, gtaoData.maxPixel * aspect);
      maxPixel = max(0.1, maxPixel);
      return maxPixel;
    }
    
    fn blurFactor(centerFactor:f32) -> f32{
      var coord0 = clamp(fragCoord + vec2<i32>(1, 0) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord1 = clamp(fragCoord + vec2<i32>(-1, 0), vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord2 = clamp(fragCoord + vec2<i32>(0, 1) , vec2<i32>(0), vec2<i32>(texSize - 1));
      var coord3 = clamp(fragCoord + vec2<i32>(0, -1), vec2<i32>(0), vec2<i32>(texSize - 1));
      var index0 = coord0.x + coord0.y * i32(texSize.x);
      var index1 = coord1.x + coord1.y * i32(texSize.x);
      var index2 = coord2.x + coord2.y * i32(texSize.x);
      var index3 = coord3.x + coord3.y * i32(texSize.x);
      let factor0:f32 = aoBuffer[index0];
      let factor1:f32 = aoBuffer[index1];
      let factor2:f32 = aoBuffer[index2];
      let factor3:f32 = aoBuffer[index3];
      var factor = 0.25 * (factor0 + factor1 + factor2 + factor3);
      factor = mix(factor, centerFactor, 0.8);
      return factor;
    }
    
    fn rayMarch() -> f32{
      let originNormal = normalize(vec3<f32>(wNormal.xyz) * 2.0 - 1.0);
      let stepPixel = maxPixelScaled / gtaoData.rayMarchSegment;
      var weight:f32 = 0.0;
      var totalWeight:f32 = 0.1;
      for(var i:i32 = 0; i < 8; i += 1){
          let dirVec2 = directions[i];
          for(var j:f32 = 1.1; j < maxPixelScaled; j += stepPixel){
              var sampleCoord = vec2<i32>(dirVec2 * j) + fragCoord;
              if(sampleCoord.x >= 0 && sampleCoord.y >= 0 
                && sampleCoord.x < i32(texSize.x) 
                && sampleCoord.y < i32(texSize.y) )
              {
                totalWeight += 1.0;
                let samplePosition = textureLoad(posTex, sampleCoord, 0).xyzw;
                if(samplePosition.w>0.0){
                  let distanceVec2 = samplePosition.xyz - wPosition;
                  let distance = length(distanceVec2);
                  if(distance < gtaoData.maxDistance ){
                    let sampleDir = normalize(distanceVec2);
                    var factor = saturate( dot(sampleDir, originNormal));
                    factor *= 1.0 - distance / gtaoData.maxDistance;
                    weight += factor;
                  }
                }
              }
          }
      }
      weight /= totalWeight;
      return weight;
    }
  `
    );

    let GodRay_cs = (
      /*wgsl*/
      `

    #include "GlobalUniform"
    struct LightData {
      index:f32,
      lightType:i32,
      radius:f32,
      linear:f32,
      
      position:vec3<f32>,
      lightMatrixIndex:f32,

      direction:vec3<f32>,
      quadratic:f32,

      lightColor:vec3<f32>,
      intensity:f32,

      innerCutOff :f32,
      outerCutOff:f32,
      range :f32,
      castShadow:i32,

      lightTangent:vec3<f32>,
      ies:f32,
    };

    struct Uniforms {
      matrix : array<mat4x4<f32>>
    };

    struct CacheGodRay {
      pos:vec3<f32>,
      value:f32,
    };

    struct GodRayUniform{
      intensity: f32,
      rayMarchCount: f32,
      viewPortWidth: f32,
      viewPortHeight: f32,

      blendColor: f32,
      scatteringExponent: f32,
    }

    @group(0) @binding(1) var<uniform> godRayUniform: GodRayUniform;
    @group(0) @binding(2) var posTex : texture_2d<f32>;
    @group(0) @binding(3) var normalTex : texture_2d<f32>;
    @group(0) @binding(4) var inTex : texture_2d<f32>;
    @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;
    @group(0) @binding(6) var shadowMapSampler : sampler_comparison;
    @group(0) @binding(7) var shadowMap : texture_depth_2d_array;

    @group(1) @binding(0)
    var<storage,read> lightBuffer: array<LightData>;
    @group(1) @binding(1)
    var<storage, read> models : Uniforms;

    @group(2) @binding(0) var<storage, read_write> historyGodRayData: array<CacheGodRay>;
    
    struct ShadowStruct{
      directShadowVisibility:f32,
      pointShadows:array<f32,8>,
     }

    var<private> viewDirection: vec3<f32> ;
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> wPosition: vec3<f32>;
    var<private> wNormal: vec4<f32>;
    var<private> directLight: LightData;
    var<private> shadowStrut: ShadowStruct ;

    const csmCount:i32 = ${CSM.Cascades} ;
    fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
      let enableCSM:bool = globalUniform.enableCSM > 0.5;
      var light = lightBuffer[0];
      var visibility = 1.0;
      var shadowIndex = i32(light.castShadow);
      if (shadowIndex >= 0 ) {
        var shadowMatrix:mat4x4<f32>;
        if(enableCSM && csmCount > 1){
          for(var csm:i32 = 0; csm < csmCount; csm ++){
            var csmShadowBias = globalUniform.csmShadowBias[csm];
            shadowMatrix = globalUniform.csmMatrix[csm];
            let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
            if(csmShadowResult.y < 0.5){
              visibility = csmShadowResult.x;
              break;
            }
          }
        }else{
          shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
          visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
        }
      }
      shadowStrut.directShadowVisibility = visibility;
    }
    
    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
      var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
      var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
      if (varying_shadowUV.x <= 1.0
        && varying_shadowUV.x >= 0.0
        && varying_shadowUV.y <= 1.0
        && varying_shadowUV.y >= 0.0
        && shadowPosTmp.z <= 1.0
        && shadowPosTmp.z >= 0.0)
      {
        isOutSideArea = 0.0;
        var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
        var NoL = abs(dot(N, normalize(light.direction)));
        var bias = shadowBias / max(NoL, 0.000001);
        visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
        visibility += 0.001;
      }
      return vec2<f32>(visibility, isOutSideArea);
    }

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );

      texSize = textureDimensions(inTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      wNormal = textureLoad(normalTex, fragCoord, 0);
      var oc = textureLoad(inTex, fragCoord, 0);
      var outColor = oc.xyz;
      directLight = lightBuffer[0] ;
      if(directLight.castShadow >= 0){
        let index = fragCoord.x + fragCoord.y * i32(texSize.x);
        var historyData = historyGodRayData[index];
        let lightColor = directLight.lightColor;
        
        var godRayFactor = 0.0;
        if(wNormal.w > 0.5){
          //not sky
          let lightPos = models.matrix[u32(directLight.lightMatrixIndex)][3].xyz;
          wPosition = textureLoad(posTex, fragCoord, 0).xyz;
          viewDirection = normalize(globalUniform.CameraPos - wPosition) ;
          godRayFactor = rayMarch();
          godRayFactor = updateGodRay(historyData, godRayFactor);
        }
        historyData.pos = wPosition;
        historyData.value = godRayFactor;
        historyGodRayData[index] = historyData;

        outColor = oc.xyz + vec3<f32>(godRayFactor * godRayUniform.intensity * lightColor);
      }
      textureStore(outTex, fragCoord , vec4<f32>(outColor, oc.w));
    }

    fn updateGodRay(historyData:CacheGodRay, newFactor:f32) -> f32 {
      var changeFactor = 0.2;
      if(length(historyData.pos - wPosition) > 0.01){
        changeFactor = 0.4;
      }
      var factor = mix(historyData.value, newFactor, changeFactor);
      
      let pixelOffset = 1 + i32(globalUniform.frame) % 3;
      let coordRange = vec2<i32>(texSize);
      let coordIndex0 = getCoordIndex(fragCoord.x + pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex1 = getCoordIndex(fragCoord.x - pixelOffset, fragCoord.y - pixelOffset, coordRange);
      let coordIndex2 = getCoordIndex(fragCoord.x, fragCoord.y + pixelOffset * 2, coordRange);

      let oldOC0 = historyGodRayData[coordIndex0].value;
      let oldOC1 = historyGodRayData[coordIndex1].value;
      let oldOC2 = historyGodRayData[coordIndex2].value;

      let opRound = (oldOC0 + oldOC1 + oldOC2) * 0.3333333;
      factor = mix(opRound, factor, 0.5);

      return factor;
    }

    fn getCoordIndex(x0:i32, y0:i32, size:vec2<i32>) -> i32{
      let x = clamp(x0, 0, size.x - 1);
      let y = clamp(y0, 0, size.y - 1);
      return y * size.x + x;
    }
    
    
    fn rayMarch() -> f32{
      var godRayFactor = 0.0;
      let L = normalize(directLight.direction);
      let rayMarchCount = godRayUniform.rayMarchCount;
      if(godRayUniform.blendColor > 0.5){
        let eyePosition = globalUniform.CameraPos;
        var samplePosition = eyePosition;
        var lastSamplePosition = eyePosition;
        
        var frameOffset = f32(i32(globalUniform.frame) % 4);
        frameOffset *= 0.25;
        var N = normalize(wNormal.xyz);
        for(var i:f32 = 1.0; i < rayMarchCount; i += 1.0){
          var t = (i + frameOffset) / rayMarchCount;
          lastSamplePosition = samplePosition;
          samplePosition = mix(eyePosition, wPosition, t * t);

          // var shadowVisibility = directionShadowMapping(samplePosition, globalUniform.shadowBias);
          directShadowMaping(samplePosition.xyz, N, globalUniform.shadowBias);
          var shadowVisibility = shadowStrut.directShadowVisibility;
          if(shadowVisibility > 0.5){
            var stepFactor = calcGodRayValue(samplePosition, L, viewDirection);
            stepFactor *= length(lastSamplePosition - samplePosition);
            godRayFactor += stepFactor;
          }
        }
        godRayFactor /= length(wPosition - eyePosition);
      }
      return godRayFactor;
    }

    fn calcGodRayValue(pos:vec3<f32>, L:vec3<f32>, V:vec3<f32>) -> f32{
      var halfLoV = normalize(L + V);
      var LoV = saturate(dot(V,halfLoV));
      LoV = pow(LoV, godRayUniform.scatteringExponent);
      var distance = length(pos - globalUniform.CameraPos) / (globalUniform.far);
      distance = 1.0 - saturate(distance);
      distance *= distance;
      return LoV * distance;
    }
  `
    );

    let MergeRGBA_cs = (
      /*wgsl*/
      `
    @group(0) @binding(0) var textureR : texture_2d<f32>;
    @group(0) @binding(1) var textureG : texture_2d<f32>;
    @group(0) @binding(2) var textureB : texture_2d<f32>;
    @group(0) @binding(3) var textureA : texture_2d<f32>;
    @group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let size = textureDimensions(outTex);
        let fragCoord : vec2<i32> = vec2<i32>(GlobalInvocationID.xy); 
        var uv:vec2<f32>;
        uv.x = f32(fragCoord.x)/f32(size.x);
        uv.y = f32(fragCoord.y)/f32(size.y);
        var oc:vec4<f32> = textureSampleLevel(atlasTexture, atlasTextureSampler, targetUV, 0.0);

        let sizeR = textureDimensions(textureR);
        let sizeG = textureDimensions(textureG);
        let sizeB = textureDimensions(textureB);
        let sizeA = textureDimensions(textureA);
        
        var tr = textureLoad(textureR, vec2<i32>(uv * sizeR) , 0 ) ;
        var tg = textureLoad(textureG, vec2<i32>(uv * sizeG) , 0 ) ;
        var tb = textureLoad(textureB, vec2<i32>(uv * sizeB) , 0 ) ;
        var ta = textureLoad(textureA, vec2<i32>(uv * sizeA) , 0 ) ;

        let color = vec4<f32>(tr,tg,tb,ta);
        textureStore(outTex, fragCoord , vec4(color));
    }

`
    );

    let OutLineBlendColor_cs = (
      /*wgsl*/
      `
   struct OutlineSettingData{
      strength: f32,
      useAddMode: f32,
      outlinePixel: f32,
      fadeOutlinePixel: f32,
      lowTexWidth: f32,
      lowTexHeight: f32,
      slot0: f32,
      slot1: f32,
   }

   @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
   @group(0) @binding(1) var inTex : texture_2d<f32>;
   @group(0) @binding(2) var lowTexSampler : sampler;
   @group(0) @binding(3) var lowTex : texture_2d<f32>;
   @group(0) @binding(4) var outlineTex : texture_storage_2d<rgba16float, write>;
   
   var<private> texSize: vec2<u32>;
   var<private> fragCoord: vec2<i32>;


   fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
   {
      let u = (f32(coord.x) + 0.5) / f32(texSize.x);
      let v = (f32(coord.y) + 0.5) / f32(texSize.y);
      return vec2<f32>(u, v);
   }

   @compute @workgroup_size( 8 , 8 , 1 )
   fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
   {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outlineTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
         return;
      }

      let uv01 = CalcUV_01(fragCoord, texSize);
      var outLineColor = textureSampleLevel(lowTex, lowTexSampler, uv01, 0.0);

      outLineColor.x *= outlineSetting.strength;
      outLineColor.y *= outlineSetting.strength;
      outLineColor.z *= outlineSetting.strength;

      var inColor = textureLoad(inTex, fragCoord, 0);
      var blendColor:vec3<f32> = vec3<f32>(0.0);
      if(outlineSetting.useAddMode > 0.5){
         blendColor = inColor.xyz + outLineColor.xyz * outLineColor.w;
      }else{
         blendColor = mix(inColor.xyz, outLineColor.xyz, outLineColor.w);
      }
      textureStore(outlineTex, fragCoord, vec4<f32>(blendColor, inColor.w));
   }

`
    );

    let OutlineCalcOutline_cs = (
      /*wgsl*/
      `
  struct OutlineSettingData{
    strength: f32,
    useAddMode: f32,
    outlinePixel: f32,
    fadeOutlinePixel: f32,
    lowTexWidth: f32,
    lowTexHeight: f32,
    slot0: f32,
    slot1: f32,
  }

  struct OutlineSlotData{
    color: vec3<f32>,
    count: f32,
  }

  struct OutlineWeightData{
    slotIndex:f32,
    outerSlotIndex:f32,
    entityIndex:f32,
    weight:f32
  }

  struct OutlineEntities{
    list: array<f32, 16u>,
  }

  @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
  @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
  @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
  @group(0) @binding(3) var<storage, read_write> entitiesBuffer : array<OutlineEntities>;
  @group(0) @binding(4) var indexTexture : texture_2d<f32>;

  var<private> texSize: vec2<u32>;
  var<private> lowSize: vec2<i32>;
  var<private> fragCoord: vec2<i32>;
  var<private> fragCoordLow: vec2<i32>;
  var<private> coordIndex: i32;

  var<private> fragOutline: OutlineWeightData;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoordLow = vec2<i32>( globalInvocation_id.xy );
    texSize = textureDimensions(indexTexture).xy;
    lowSize = vec2<i32>(i32(outlineSetting.lowTexWidth), i32(outlineSetting.lowTexHeight));
    let scaleValue = f32(texSize.x) / f32(lowSize.x);
    fragCoord.x = i32(f32(fragCoordLow.x) * scaleValue);
    fragCoord.y = i32(f32(fragCoordLow.y) * scaleValue);

    if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
        return;
    }
    if(fragCoordLow.x >= lowSize.x || fragCoordLow.y >= lowSize.y){
        return;
    }
    
    coordIndex = fragCoordLow.x + fragCoordLow.y * lowSize.x;
    fragOutline = weightBuffer[coordIndex];
    var wPos = textureLoad(indexTexture, fragCoord, 0 ) ;
    
    fragOutline.entityIndex = round(wPos.w);
    fragOutline.slotIndex = -1.0;
    fragOutline.outerSlotIndex = -1.0;
    fragOutline.weight = 0.0;
    
    if(fragOutline.entityIndex >= 0.0){
      fragOutline.slotIndex = f32(matchOutlineSlot());
    }
    weightBuffer[coordIndex] = fragOutline;
  }

  fn matchOutlineSlot() -> i32
  {
    for(var i:i32 = 0; i < 8; i ++){
        var slotData:OutlineSlotData = slotsBuffer[i];
        var entities:array<f32, 16u> = entitiesBuffer[i].list;
        let count:i32 = i32(slotData.count);
        for(var j:i32 = 0; j < count; j ++){
            var outlineIndex = entities[j];
            if(abs(fragOutline.entityIndex - outlineIndex) < 0.1){ 
                return i;
            }
        }
    }
    return -1;
  }
`
    );

    let Outline_cs = (
      /*wgsl*/
      `
    struct OutlineSettingData{
        strength: f32,
        useAddMode: f32,
        outlinePixel: f32,
        fadeOutlinePixel: f32,
        lowTexWidth: f32,
        lowTexHeight: f32,
        slot0: f32,
        slot1: f32,
    }
    
    struct OutlineSlotData{
        color: vec3<f32>,
        count: f32,
    }
    
    struct OutlineWeightData{
        slotIndex:f32,
        outerSlotIndex:f32,
        entityIndex:f32,
        weight:f32
    }

    @group(0) @binding(0) var<uniform> outlineSetting: OutlineSettingData;
    @group(0) @binding(1) var<storage, read_write> slotsBuffer : array<OutlineSlotData>;
    @group(0) @binding(2) var<storage, read_write> weightBuffer : array<OutlineWeightData>;
    @group(0) @binding(3) var<storage, read_write> oldOutlineColor : array<vec4<f32>>;
    @group(0) @binding(4) var lowTex : texture_storage_2d<rgba16float, write>;
    
    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    var<private> fragOutline: OutlineWeightData;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        fragCoord = vec2<i32>( globalInvocation_id.xy );
        texSize = textureDimensions(lowTex).xy;
        if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
            return;
        }
        
        coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
        fragOutline = weightBuffer[coordIndex];
        
        var newOC = vec4<f32>(0.0);
        
        calcOutline();
        let outerSlotIndex:i32 = i32(round(fragOutline.outerSlotIndex));
        if(outerSlotIndex >= 0){
            let outLineColor = slotsBuffer[outerSlotIndex].color;
            newOC = vec4<f32>(outLineColor, fragOutline.weight);
        }
        
        let coordIndex0 = fragCoord.x + 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex1 = fragCoord.x - 1 + (fragCoord.y + 1) * i32(texSize.x);
        let coordIndex2 = fragCoord.x + (fragCoord.y - 1) * i32(texSize.x);

        let oldOC = oldOutlineColor[coordIndex];
        let oldOC0 = oldOutlineColor[coordIndex0];
        let oldOC1 = oldOutlineColor[coordIndex1];
        let oldOC2 = oldOutlineColor[coordIndex2];
        
        newOC = mix((oldOC + oldOC0 + oldOC1 + oldOC2) * 0.25, newOC, 0.5);
        oldOutlineColor[coordIndex] = newOC;
        textureStore(lowTex, fragCoord, newOC);
    }
    
    fn calcOutline()
    {
        let outlinePixel = outlineSetting.outlinePixel;
        let pixelRadius = outlinePixel + outlineSetting.fadeOutlinePixel;
        let minX = max(0.0, f32(fragCoord.x) - pixelRadius);
        let maxX = min(f32(texSize.x), f32(fragCoord.x) + pixelRadius);
        let minY = max(0.0, f32(fragCoord.y) - pixelRadius);
        let maxY = min(f32(texSize.y), f32(fragCoord.y) + pixelRadius);
        var coordTemp_f32 = vec2<f32>(0.0);
        var coordCurrent_f32 = vec2<f32>(fragCoord);
        var tempCoordIndex = 0;
        var tempWeightData: OutlineWeightData;
        for(var x:f32 = minX; x < maxX; x += 1.0){
            for(var y:f32 = minY; y < maxY; y += 1.0){
                coordTemp_f32.x = x;
                coordTemp_f32.y = y;
                let distanceToOuter = length(coordTemp_f32 - coordCurrent_f32);
                if(distanceToOuter < pixelRadius){
                    var coord_i32 = vec2<i32>(coordTemp_f32);
                    tempCoordIndex = coord_i32.x + coord_i32.y * i32(texSize.x);
                    tempWeightData = weightBuffer[tempCoordIndex];
                    let outlineGap = abs(tempWeightData.slotIndex - fragOutline.slotIndex);
                    if(outlineGap > 0.1){
                        if(tempWeightData.slotIndex > fragOutline.slotIndex){
                            if(abs(tempWeightData.slotIndex - fragOutline.outerSlotIndex) < 0.1){
                                fragOutline.weight = max(fragOutline.weight, calcWeight(pixelRadius, distanceToOuter, outlinePixel));
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }else if(tempWeightData.slotIndex > fragOutline.outerSlotIndex){
                                fragOutline.weight = calcWeight(pixelRadius, distanceToOuter, outlinePixel);
                                fragOutline.outerSlotIndex = tempWeightData.slotIndex;
                                weightBuffer[tempCoordIndex] = tempWeightData;
                            }
                        }
                    }
                }
            }
        }
    }
    
    fn calcWeight(totalRadius:f32, distance:f32, innerRadius:f32) -> f32{
        if(distance < innerRadius){
            return 1.0;
        }
        var ret = 1.0 - (distance - innerRadius)  / (totalRadius - innerRadius);

        return ret;
    }
`
    );

    let Picker_cs = (
      /*wgsl*/
      `

    #include "GlobalUniform"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,
        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,
    }

    //@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
    @group(0) @binding(1) var<storage,read_write> outBuffer: PickResult;
    @group(0) @binding(2) var visibleMap : texture_2d<f32>;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    // result.pick_meshID
    let texSize = textureDimensions(visibleMap).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy); 
    let info = textureLoad(visibleMap, vec2<i32>(mouseUV) , 0);

    outBuffer.pick_meshID = f32(info.w) ;
    outBuffer.pick_meshID2 = f32(info.w) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    outBuffer.pick_Position = vec4<f32>(info.xyzw) ;
    outBuffer.pick_Normal = vec4<f32>(info.xyzw) ;
    }
`
    );

    let PreIntegratedLut = (
      /*wgsl*/
      `
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`
    );

    let SSAO_cs = (
      /*wgsl*/
      `
#include "GlobalUniform"
  struct UniformData {
    radius: f32 ,
    bias: f32,
    aoPower: f32 ,
    blurSize: f32 ,
  };

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> uniformData: UniformData;
  @group(0) @binding(2) var<storage,read> sampleData: array<vec4<f32>>;

  // @group(0) @binding(3) var colorMap : texture_2d<f32>;
  @group(0) @binding(3) var positionMap : texture_2d<f32>;
  @group(0) @binding(4) var normalMap : texture_2d<f32>;

  @group(0) @binding(5) var noiseMapSampler: sampler;
  @group(0) @binding(6) var noiseMap : texture_2d<f32>;

  @group(0) @binding(7) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> kernelSize: i32 = 32 ;

  @compute @workgroup_size( 8 , 8 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    var fragCoord = vec2<i32>( globalInvocation_id.xy );

    var texSize = textureDimensions(positionMap).xy;
    var texCoord = vec2<f32>(fragCoord) / vec2<f32>(texSize);

    var fragColor = vec4<f32>(1.0);

    var viewMat = standUniform.viewMat  ;
    // var color = textureLoad(colorMap, fragCoord , 0 ) ;
    var wPos = textureLoad(positionMap, fragCoord , 0 ) ;

    var fragPosition = viewMat * vec4<f32>(wPos.xyz,1.0);
    fragPosition = vec4(fragPosition.xyz / fragPosition.w,1.0) ;

    var texNormal = textureLoad(normalMap, fragCoord , 0 ) ;
    var sampleNormal = texNormal.xyz ;
    sampleNormal = sampleNormal * 2.0 - 1.0;
    var fragNormal = viewMat * vec4<f32>((sampleNormal.xyz),0.0);

    var pes = vec2<f32>(texSize.xy) / 4.0 ;
    var noiseTex:vec4<f32> = textureSampleLevel(noiseMap, noiseMapSampler, texCoord * pes , 0.0);
    var randomVec  = (viewMat * vec4<f32>(normalize(noiseTex.xyz),0.0)).xyz;

    var tangent = normalize(randomVec - fragNormal.xyz * dot(randomVec , fragNormal.xyz));
    var bTangent = cross(fragNormal.xyz, tangent) + 0.0001 ;
    var tbn = mat3x3<f32>(tangent, bTangent, fragNormal.xyz);

    var offset:vec4<f32>;
    var samplePos :vec3<f32>;
    var offsetPosition:f32;
    var sample_depth_v:vec4<f32>;
    var occlusion:f32 = 0.0;
    var rangeCheck:f32 = 0.0 ;
    var radius:f32 = uniformData.radius * 32.0 * fragPosition.z ;

    for(var i:i32 = 0; i < 32 ; i = i + 1 ){
      samplePos  = (tbn * sampleData[i].xyz ) ;
      samplePos  = fragPosition.xyz + samplePos * radius ;

      offset = vec4(samplePos, 1.0);
      offset = standUniform.projMat * offset;

      var off = offset.xyz / offset.w;
      off = (off.xyz * 0.5 ) + 0.5 ;
      off.y = 1.0 - off.y ;
      var offsetUV = vec2<i32>(off.xy * vec2<f32>(texSize.xy));

      sample_depth_v = textureLoad(positionMap, offsetUV.xy , 0 ) ;
      sample_depth_v = vec4<f32>((viewMat * vec4<f32>(sample_depth_v.xyz,1.0)).xyz,1.0);
      offsetPosition = sample_depth_v.z / sample_depth_v.w ;

      rangeCheck = smoothstep(0.0, 1.0, radius / abs(offsetPosition - fragPosition.z ));
      // rangeCheck = smoothstep(0.0, 1.0, radius / uniformData.bias);

      var a = 1.0 ;
      if(offsetPosition >= (samplePos.z + uniformData.bias)){
        a = 0.0 ;
      }
      a = a * rangeCheck ;
      occlusion = occlusion + a ;
    }

    occlusion = 1.0 - ( occlusion / f32(kernelSize) * texNormal.w );
    occlusion = pow(occlusion, uniformData.aoPower) ;

    // color = color * occlusion ;

    textureStore(outTex, fragCoord , vec4(occlusion));
  }
`
    );

    let SSR_BlendColor_cs = (
      /*wgsl*/
      `
@group(0) @binding(0) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(1) var colorMap : texture_2d<f32>;
  @group(0) @binding(2) var ssrMapSampler : sampler;
  @group(0) @binding(3) var ssrMap : texture_2d<f32>;
  @group(0) @binding(4) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> colorTexSize: vec2<u32>;
  var<private> ssrTexSize: vec2<u32>;
  var<private> fragCoord: vec2<i32>;
  var<private> ssrCoord: vec2<i32>;

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
  {
    let u = (f32(coord.x) + 0.5) / f32(texSize.x);
    let v = (f32(coord.y) + 0.5) / f32(texSize.y);
    return vec2<f32>(u, v);
  }

  
  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    fragCoord = vec2<i32>( globalInvocation_id.xy );
    colorTexSize = textureDimensions(colorMap).xy;
    ssrTexSize = textureDimensions(ssrMap).xy;
    if(fragCoord.x >= i32(colorTexSize.x) || fragCoord.y >= i32(colorTexSize.y)){
        return;
    }
    let scale:f32 = f32(ssrTexSize.x) / f32(colorTexSize.x);
    ssrCoord = vec2<i32>(vec2<f32>(fragCoord.xy) * scale);
    let index = ssrCoord.x + ssrCoord.y * i32(ssrTexSize.x);
    let hitData = rayTraceBuffer[index];
    var color = textureLoad(colorMap, fragCoord , 0);
    var uv01 = CalcUV_01(fragCoord, colorTexSize);
    
    var ssrColor = textureSampleLevel(ssrMap, ssrMapSampler, uv01, 0.0);
    var tc = mix(color, ssrColor, hitData.fresnel) ;
    var outColor = tc ;
    outColor.a = color.a ; 
    textureStore(outTex, fragCoord , outColor );
  }

`
    );

    let SSR_IS_cs = (
      /*wgsl*/
      `
  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(1) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(2) var<storage, read_write> ssrColorData : array<vec4<f32>>;
  @group(0) @binding(3) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(4) var colorMap: texture_2d<f32>;
  @group(0) @binding(5) var outTex : texture_storage_2d<rgba16float, write>;

  var<private> ssrBufferCoord: vec2<i32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> bufferData: RayTraceRetData;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> coordIndex: i32;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy );
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));

    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }

    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    bufferData = rayTraceBuffer[coordIndex];
    var oc = vec4<f32>(0.0, 0.0, 0.0, -1.0);
    
    var mixFactor = historyPosition[coordIndex].w;
    
    if(bufferData.alpha >= 0.0 && bufferData.roughness < ssrUniform.roughnessThreshold){
      let roughness = clamp(bufferData.roughness, 0.0, 1.0);
      let prefilterColor = bufferData.skyColor;
      var ssrColor = textureLoad(colorMap, vec2<i32>(bufferData.hitCoord), 0);
      ssrColor.w = bufferData.alpha;
      oc = ssrColor;
    }
    let skyColor = vec4<f32>(bufferData.skyColor, 1.0);
    oc = mix(oc, skyColor, 1.0 - bufferData.alpha);
    
    let lastColor = ssrColorData[coordIndex];
    var newColor = mix(oc, lastColor, mixFactor);
    newColor.w = oc.w;
    
    ssrColorData[coordIndex] = newColor;
    
    textureStore(outTex, ssrBufferCoord , newColor);
  }
`
    );

    let SSR_RayTrace_cs = (
      /*wgsl*/
      `
  #include "GlobalUniform"

  struct SSRUniformData {
    ssrBufferSizeX: f32,
    ssrBufferSizeY: f32,
    colorMapSizeX: f32,
    colorMapSizeY: f32,

    fadeEdgeRatio: f32,
    rayMarchRatio: f32,
    fadeDistanceMin: f32,
    fadeDistanceMax: f32,
    
    mixThreshold: f32,
    roughnessThreshold: f32,
    reflectionRatio: f32,
    powDotRN: f32,

    randomSeedX: f32,
    randomSeedY: f32,
    slot1: f32,
    slot2: f32,
  };

  struct HitData{
    hitPos:vec3<f32>,
    hitNormal:vec3<f32>,
    fadeAlpha:vec4<f32>,
    hitCoord:vec2<i32>,
    hitResult:i32,
    hitSky:i32,
  };

  struct RayTraceRetData{
    skyColor:vec3<f32>,
    roughness:f32,

    hitCoord:vec2<f32>,
    alpha:f32,
    fresnel:f32,
  }

  @group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
  @group(0) @binding(1) var<uniform> ssrUniform: SSRUniformData;
  @group(0) @binding(2) var<storage, read_write> rayTraceBuffer : array<RayTraceRetData>;
  @group(0) @binding(4) var<storage, read_write> historyPosition : array<vec4<f32>>;

  @group(0) @binding(5) var zBufferTexture : texture_2d<f32>;
  @group(0) @binding(6) var normalBufferTex : texture_2d<f32>;
  @group(0) @binding(7) var materialBufferTex : texture_2d<f32>;
  @group(0) @binding(8) var prefilterMapSampler: sampler;
  @group(0) @binding(9) var prefilterMap: texture_cube<f32>;

  var<private> rayOrigin: vec3<f32>;
  var<private> rayDirection: vec3<f32>;
  var<private> cameraPosition: vec3<f32>;
  var<private> reflectionDir: vec3<f32>;
  var<private> colorTexSize: vec2<i32>;
  var<private> fragCoordColor: vec2<i32>;
  var<private> ssrBufferCoord: vec2<i32>;
  var<private> ssrBufferSize: vec2<i32>;
  var<private> hitData: HitData;
  var<private> rayTraceRet: RayTraceRetData;
  var<private> worldPosition: vec3<f32>;
  var<private> worldNormal: vec3<f32>;
  var<private> roughness: f32;
  var<private> fresnel: f32;

  var<private> historyPos: vec3<f32>;
  var<private> coordIndex: i32;

  var <private> PI: f32 = 3.14159;

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    ssrBufferCoord = vec2<i32>( globalInvocation_id.xy);
    ssrBufferSize = vec2<i32>(i32(ssrUniform.ssrBufferSizeX), i32(ssrUniform.ssrBufferSizeY));
    if(ssrBufferCoord.x >= ssrBufferSize.x || ssrBufferCoord.y >= ssrBufferSize.y){
        return;
    }
    coordIndex = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;

    colorTexSize = vec2<i32>(i32(ssrUniform.colorMapSizeX), i32(ssrUniform.colorMapSizeY));
    fragCoordColor = convertColorCoordFromSSRCoord(ssrBufferCoord);

    hitData.fadeAlpha = vec4<f32>(0.0);
    hitData.hitCoord = vec2<i32>(0);
    hitData.hitResult = 0;
    hitData.hitNormal = vec3<f32>(0.0, 1.0, 0.0);
    hitData.hitSky = 1;

    worldPosition = textureLoad(zBufferTexture, fragCoordColor , 0).xyz;
    historyPos = historyPosition[coordIndex].xyz;
    
    var mixFactor = 0.2;
    if(length(historyPos - worldPosition) < ssrUniform.mixThreshold){
        mixFactor = 0.9;
    }
    historyPosition[coordIndex] = vec4<f32>(worldPosition, mixFactor);
    
    let normal_v4 = textureLoad(normalBufferTex, fragCoordColor , 0);
    worldNormal = normalize(vec3<f32>(normal_v4.xyz) * 2.0 - 1.0);
    let materialData = textureLoad(materialBufferTex, fragCoordColor , 0 );
    let roughness = materialData.g * (1.0 - materialData.b);
    fresnel = (1.0 - roughness) * ssrUniform.reflectionRatio;

    cameraPosition = vec3<f32>(standUniform.cameraWorldMatrix[3].xyz);
    rayOrigin = vec3<f32>(worldPosition.xyz);

    rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    
    var randomSeed = fract(ssrUniform.randomSeedX + worldPosition.x);
    rand_seed.x = randomSeed;
    rand_seed.y = fract(ssrUniform.randomSeedY + worldPosition.y + worldPosition.z);
    randomSeed = rand();
    
    let normalRandom = makeRandomDirection(worldNormal, u32(randomSeed * 256.0), 256, roughness);
    
    reflectionDir = normalize(reflect(rayDirection, normalRandom));

    if(normal_v4.w > 0.5 && roughness < ssrUniform.roughnessThreshold){
      let uvOrigin = vec2<f32>(f32(fragCoordColor.x), f32(fragCoordColor.y));
      let rayMarchPosition = rayOrigin + reflectionDir * 100.0;
      var uvRayMarch = standUniform.projMat * (standUniform.viewMat * vec4<f32>(rayMarchPosition, 1.0));
      var uvOffset = (vec2<f32>(uvRayMarch.xy / uvRayMarch.w) + 1.0) * 0.5;
      uvOffset.y = 1.0 - uvOffset.y;
      uvOffset = uvOffset * vec2<f32>(colorTexSize - 1) - uvOrigin;
      uvOffset = normalize(uvOffset);

      rayTrace(uvOffset);
      if(hitData.hitResult == 1){
          hidingArtifact();
          rayTraceRet.alpha = hitData.fadeAlpha.x * hitData.fadeAlpha.y * hitData.fadeAlpha.z * hitData.fadeAlpha.w;
          if(hitData.hitSky == 1){
            rayTraceRet.alpha = 0.0;
          }
      }else{
        rayTraceRet.alpha = 0.0;
      }
      rayTraceRet.skyColor = getSkyColor();
    }else{
      rayTraceRet.alpha = -1.0;
      rayTraceRet.skyColor = vec3<f32>(0.0);
    }

    rayTraceRet.roughness = roughness;
    rayTraceRet.fresnel = fresnel;
    rayTraceRet.hitCoord = vec2<f32>(hitData.hitCoord);

    let index:i32 = ssrBufferCoord.x + ssrBufferCoord.y * ssrBufferSize.x;
    rayTraceBuffer[index] = rayTraceRet;
  }

  fn makeRandomDirection(srcDirection:vec3<f32>, i:u32, SAMPLE_COUNT:u32, roughness:f32) -> vec3<f32>
  {
    var N: vec3<f32> = normalize(srcDirection);
    var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
    return ImportanceSampleGGX(Xi, N, roughness);
  }

  fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
  {
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) /f32(N), rdi);
  }

  fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
  {
    var a = roughness*roughness;

    var phi = 2.0 * PI * Xi.x;
    var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    var sinTheta = sqrt(1.0 - cosTheta*cosTheta);

    // from spherical coordinates to cartesian coordinates
    var H:vec3<f32>;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    // from tangent-space vector to world-space sample vector
  var up:vec3<f32>;
    if(abs(N.z) < 0.999)
    {
        up = vec3<f32>(0.0, 0.0, 1.0);
    }
    else
    {
        up = vec3<f32>(1.0, 0.0, 0.0);
    }
  var tangent:vec3<f32>  = normalize(cross(up, N));
  var bitangent:vec3<f32> = cross(N, tangent);
  var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
  return normalize(sampleVec);
  }

  var<private> rand_seed :vec2<f32> = vec2<f32>(0.0);
  fn rand() -> f32 {
    rand_seed.x = fract(cos(dot(rand_seed, vec2<f32>(23.14077926, 232.61690225))) * 136.8168);
    rand_seed.y = fract(cos(dot(rand_seed, vec2<f32>(54.47856553, 345.84153136))) * 534.7645);
    return rand_seed.y;
  }

  fn getSkyColor() -> vec3<f32>{
    let calcRoughness = clamp(roughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, reflectionDir, calcRoughness * MAX_REFLECTION_LOD);
    return LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)) * standUniform.skyExposure;
  }

  fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
      var linRGB1 = max(linRGB, vec3<f32>(0.0));
      linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
      return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
  }

  fn convertColorCoordFromSSRCoord(coord:vec2<i32>) -> vec2<i32>{
    let color_ssr_ratio = ssrUniform.colorMapSizeX / ssrUniform.ssrBufferSizeX;
    let targetCoord = vec2<f32>(coord) * color_ssr_ratio;
    return vec2<i32>(targetCoord);
  }

  fn hidingArtifact(){
    let texSizeF32 = vec2<f32>(f32(colorTexSize.x), f32(colorTexSize.y));
    let halfTexSizeF32 = texSizeF32 * 0.5;

    //near screen edge
    var distance2Center = abs(vec2<f32>(f32(hitData.hitCoord.x), f32(hitData.hitCoord.y)) - halfTexSizeF32);
    let halfEdgeSize:f32 = min(texSizeF32.x, texSizeF32.y) * clamp(0.01, ssrUniform.fadeEdgeRatio, 1.0) * 0.5;
    var distance2Edge = min(vec2<f32>(halfEdgeSize), halfTexSizeF32 - distance2Center);
    var ratioXY = distance2Edge / halfEdgeSize;
    hitData.fadeAlpha.x = sqrt(ratioXY.x * ratioXY.y);

    //back face hit
    var backFaceBias = max(0.0, dot(hitData.hitNormal, -reflectionDir));
    hitData.fadeAlpha.y = pow(backFaceBias, max(0.0001, ssrUniform.powDotRN));

    //screen distance ratio
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    let screenPointer = hitData.hitCoord - fragCoordColor;
    var screenDistance = length(vec2<f32>(f32(screenPointer.x), f32(screenPointer.y)));
    screenDistance = clamp(screenDistance / maxLength, 0.0, 1.0);
    hitData.fadeAlpha.z = 1.0 - screenDistance;

    //position distance ratio
    var fadeDistance = length(vec3<f32>(hitData.hitPos - cameraPosition));
    var dFar = ssrUniform.fadeDistanceMax;
    var dNear = ssrUniform.fadeDistanceMin;
    dFar = max(1.0, dFar);
    dNear = clamp(dNear, 0.001, dFar - 0.001);
    fadeDistance = clamp(fadeDistance, dNear, dFar);
    fadeDistance = (fadeDistance - dNear) / (dFar - dNear);
    hitData.fadeAlpha.w = 1.0 - fadeDistance;
  }

  fn rayTrace(rayMarchDir:vec2<f32>){
    let stepLength = 4.0;
    let maxLength = max(f32(colorTexSize.x), f32(colorTexSize.y)) * ssrUniform.rayMarchRatio;
    for(var i:f32 = 1.0; i < maxLength; i = i + stepLength){
        let offsetFloat32 = i * rayMarchDir;
        var uv = fragCoordColor + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
        let hitRet = rayInterestScene(uv);
        if(hitRet > 0){
          hitData.hitResult = hitRet;
          break;
        }
    }
    if(hitData.hitResult == 1){
        let fromUV = hitData.hitCoord;
        for(var i:f32 = -stepLength; i <= 0.0; i = i + 1.0){
          let offsetFloat32 = i * rayMarchDir;
          var uv = fromUV + vec2<i32>(i32(offsetFloat32.x), i32(offsetFloat32.y));
          let hitRet = rayInterestScene(uv);
          if(hitRet == 1){
            let WN = textureLoad(normalBufferTex, hitData.hitCoord , 0 );
            if(WN.w > 0.5){
                hitData.hitSky = 0;
            }
            let normal = vec3<f32>(WN.xyz) * 2.0 - 1.0;
            hitData.hitNormal = normalize(vec3<f32>(normal.xyz));
            break;
          }
        }
    }
  }

  fn rayInterestScene(uv:vec2<i32>) -> i32 {
    if(uv.x < 0 || uv.y < 0 || uv.x >= colorTexSize.x || uv.y >= colorTexSize.y){
      return 2;
    }else{
      let hitPos = textureLoad(zBufferTexture, uv , 0 );
      let testDir = normalize(vec3<f32>(hitPos.xyz - rayOrigin));
      let cosValue = dot(reflectionDir, testDir);

      if(cosValue > 0.9996){
        let cross1 = cross(reflectionDir, -rayDirection);
        let cross2 = cross(reflectionDir, testDir);
        if(dot(cross1, cross2) > 0.0){
          hitData.hitPos = vec3<f32>(hitPos.xyz);
          hitData.hitCoord = uv;
          return 1;
        }
      }
    }
    return 0;
  }
`
    );

    let TAACopyTex_cs = (
      /*wgsl*/
      `
    @group(0) @binding(0) var<storage, read_write> preColor : array<vec4<f32>>;
    @group(0) @binding(1) var preColorTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;
    var<private> coordIndex: i32;
    
    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(preColorTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
      textureStore(preColorTex, fragCoord , preColor[coordIndex]);
    }
 `
    );

    let TAASharpTex_cs = (
      /*wgsl*/
      `
    struct TAAData{
      preProjMatrix: mat4x4<f32>,
      preViewMatrix: mat4x4<f32>,
      jitterFrameIndex: f32,
      blendFactor: f32,
      sharpFactor: f32,
      sharpPreBlurFactor: f32,
      jitterX: f32,
      jitterY: f32,
      slot0: f32,
      slot1: f32,
    }
    @group(0) @binding(0) var<uniform> taaData: TAAData;
    @group(0) @binding(1) var inTex : texture_2d<f32>;
    @group(0) @binding(2) var outTex : texture_storage_2d<rgba16float, write>;

    var<private> texSize: vec2<u32>;
    var<private> fragCoord: vec2<i32>;

    @compute @workgroup_size( 8 , 8 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
      fragCoord = vec2<i32>( globalInvocation_id.xy );
      texSize = textureDimensions(outTex).xy;
      if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
          return;
      }
      
      let c0 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y - 1), 0);
      let c1 = textureLoad(inTex, vec2<i32>(fragCoord.x, fragCoord.y + 1), 0);
      let c2 = textureLoad(inTex, vec2<i32>(fragCoord.x - 1, fragCoord.y), 0);
      let c3 = textureLoad(inTex, vec2<i32>(fragCoord.x + 1, fragCoord.y), 0);
      
      var roundColor = (c0 + c1 + c2 + c3) * 0.25;
      let originColor = textureLoad(inTex, fragCoord, 0);
      let blurColor = mix(roundColor, originColor, taaData.sharpPreBlurFactor);
      var oc = (originColor - blurColor * taaData.sharpFactor) / (1.0 - taaData.sharpFactor);
      oc = clamp(oc, vec4<f32>(0.0), oc);
      textureStore(outTex, fragCoord , oc);
    }
`
    );

    let TAA_cs = (
      /*wgsl*/
      `
#include "GlobalUniform"

struct TAAData{
  preProjMatrix: mat4x4<f32>,
  preViewMatrix: mat4x4<f32>,
  jitterFrameIndex: f32,
  blendFactor: f32,
  sharpFactor: f32,
  sharpPreBlurFactor: f32,
  jitterX: f32,
  jitterY: f32,
  slot0: f32,
  slot1: f32,
}

@group(0) @binding(0) var<uniform> standUniform: GlobalUniform;
@group(0) @binding(1) var<uniform> taaData: TAAData;
@group(0) @binding(2) var<storage, read_write> preColorBuffer : array<vec4<f32>>;

@group(0) @binding(3) var preColorTexSampler : sampler;
@group(0) @binding(4) var preColorTex : texture_2d<f32>;
@group(0) @binding(5) var posTex : texture_2d<f32>;
@group(0) @binding(6) var inTexSampler : sampler;
@group(0) @binding(7) var inTex : texture_2d<f32>;
@group(0) @binding(8) var outTex : texture_storage_2d<rgba16float, write>;

var<private> texSize: vec2<u32>;
var<private> fragCoord: vec2<i32>;
var<private> coordIndex: i32;
var<private> color_min: vec4<f32>;
var<private> color_max: vec4<f32>;
var<private> color_avg: vec4<f32>;
var<private> re_proj_uv01: vec2<f32>;
var<private> FLT_EPS:f32 = 5.960464478e-8;  // 2^-24, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
  fragCoord = vec2<i32>( globalInvocation_id.xy );
  texSize = textureDimensions(inTex).xy;
  if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
      return;
  }
  let frame = standUniform.frame;
  coordIndex = fragCoord.x + fragCoord.y * i32(texSize.x);
  
  let oc = blendColor();
  preColorBuffer[coordIndex] = oc;
  textureStore(outTex, fragCoord , oc);
}

fn blendColor() -> vec4<f32>
{
  var preCoord = fragCoord;
  var mixWeight = 1.0;
  re_proj_uv01 = vec2<f32>(0.0);
  var reProjectionCoord:vec2<f32> = vec2<f32>(fragCoord);
  //var jitterUVOffset = 0.5 * vec2<f32>(taaData.jitterX, -taaData.jitterY);
  if(taaData.jitterFrameIndex > 0.5){
      var wPos = textureLoad(posTex, fragCoord, 0);
      let ndc = taaData.preProjMatrix * (taaData.preViewMatrix * vec4<f32>(wPos.xyz, 1.0));
      re_proj_uv01 = vec2<f32>(ndc.x, -ndc.y) / ndc.w;
      re_proj_uv01 = (re_proj_uv01 + 1.0) * 0.5;
      
      if(re_proj_uv01.x >= 0.0 && re_proj_uv01.x <= 1.0 && re_proj_uv01.y >= 0.0 && re_proj_uv01.y <= 1.0){
          mixWeight = taaData.blendFactor;
          //reProjectionCoord = re_proj_uv01 + jitterUVOffset;
          reProjectionCoord.x = re_proj_uv01.x * f32(texSize.x - 1);
          reProjectionCoord.y = re_proj_uv01.y * f32(texSize.y - 1);
          preCoord = vec2<i32>(reProjectionCoord);
      }else{ 
          //outside of screen
          mixWeight = 1.0;
      }
  }
  
  var curUV01 = vec2<f32>(fragCoord) / vec2<f32>(texSize - 1);
  //curUV01 += jitterUVOffset;
  
  let curColor = textureSampleLevel(inTex, inTexSampler, curUV01, 0.0);
  
  let preIndex = preCoord.x + preCoord.y * i32(texSize.x);
  var preColor = textureSampleLevel(preColorTex, preColorTexSampler, re_proj_uv01, 0.0);
  
  //minmax9(fragCoord);
  minmax4(fragCoord);
  
  preColor = clip_aabb(color_min.xyz, color_max.xyz, color_avg, preColor);
  var outColor = mix(preColor, curColor, mixWeight);

  return outColor;
}

fn clampCoord(coord0:vec2<i32>) -> vec2<i32>{
  return clamp(coord0, vec2<i32>(0), vec2<i32>(texSize - 1));
}

fn minmax4(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv1 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv2 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      
      let c0 = textureLoad(inTex, uv0, 0);
      let c1 = textureLoad(inTex, uv1, 0);
      let c2 = textureLoad(inTex, uv2, 0);
      let c3 = textureLoad(inTex, uv3, 0);
      
      color_min = min(c0, min(c1, min(c2, c3)));
      color_max = max(c0, max(c1, max(c2, c3)));
      color_avg = (c0 + c1 + c2 + c3) * 0.25;
  }
  
 fn minmax9(coord:vec2<i32>) {
      let uv0 = clampCoord(vec2<i32>(coord.x - 1, coord.y - 1));
      let uv1 = clampCoord(vec2<i32>(coord.x - 1, coord.y));
      let uv2 = clampCoord(vec2<i32>(coord.x - 1, coord.y + 1));
      let uv3 = clampCoord(vec2<i32>(coord.x, coord.y - 1));
      let uv4 = clampCoord(vec2<i32>(coord.x, coord.y));
      let uv5 = clampCoord(vec2<i32>(coord.x, coord.y + 1));
      let uv6 = clampCoord(vec2<i32>(coord.x + 1, coord.y - 1));
      let uv7 = clampCoord(vec2<i32>(coord.x + 1, coord.y));
      let uv8 = clampCoord(vec2<i32>(coord.x + 1, coord.y + 1));
      
      let ctl = textureLoad(inTex, uv0, 0);
      let ctc = textureLoad(inTex, uv1, 0);
      let ctr = textureLoad(inTex, uv2, 0);
      let cml = textureLoad(inTex, uv3, 0);
      let cmc = textureLoad(inTex, uv4, 0);
      let cmr = textureLoad(inTex, uv5, 0);
      let cbl = textureLoad(inTex, uv6, 0);
      let cbc = textureLoad(inTex, uv7, 0);
      let cbr = textureLoad(inTex, uv8, 0);
      
      color_min = min(ctl, min(ctc, min(ctr, min(cml, min(cmc, min(cmr, min(cbl, min(cbc, cbr))))))));
      color_max = max(ctl, max(ctc, max(ctr, max(cml, max(cmc, max(cmr, max(cbl, max(cbc, cbr))))))));
      color_avg = (ctl + ctc + ctr + cml + cmc + cmr + cbl + cbc + cbr) / 9.0;
  }
  
  fn clip_aabb(aabb_max:vec3<f32>, aabb_min:vec3<f32>, color_avg:vec4<f32>, input_texel:vec4<f32>) -> vec4<f32>
  {
      var p_clip:vec3<f32> = 0.5 * (aabb_max + aabb_min);
      var e_clip:vec3<f32> = 0.5 * (aabb_max - aabb_min) + FLT_EPS;
      var v_clip:vec4<f32> = input_texel - vec4<f32>(p_clip, color_avg.w);
      var v_unit:vec3<f32> = v_clip.xyz / e_clip;
      var a_unit:vec3<f32> = abs(v_unit);
      var ma_unit:f32 = max(a_unit.x, max(a_unit.y, a_unit.z));

      if (ma_unit > 1.0){
          return vec4<f32>(p_clip, color_avg.w) + v_clip / ma_unit;
      }else{
          return input_texel;
      }
  }`
    );

    let FrustumCulling_cs = (
      /*wgsl*/
      `
#include "GlobalUniform"

struct RenderBound{
    index:f32,
}

struct Uniforms {
    matrix : array<mat4x4<f32>>
};

//@group(0) @binding(0) var<uniform> globalUniform: GlobalUniform;
@group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(2) var<storage, read> planes: array<vec4<f32>,7>;
@group(0) @binding(3) var<storage, read> cullingList: array<RenderBound>;
@group(0) @binding(4) var<storage,read_write> outBuffer: array<f32>;


var<private> boundPoints : array<vec4<f32>,8> ;   

fn IsInClipSpace( coord : vec4<f32> ) -> bool {
    return -coord.w <= coord.x && coord.x <= coord.w
        && -coord.w <= coord.y && coord.y <= coord.w
        && -coord.w <= coord.z && coord.z <= coord.w;
}

fn IsOutsideThePlane( plane: vec4<f32>, pointPosition : vec3<f32> ) -> bool{
    if(dot(plane.xyz, pointPosition) + plane.w > 0.0){
        return true;
    }
    return false;
}

fn containsBox( size:vec3<f32> , center:vec3<f32> ) -> f32 {
    var c = 0.0 ;
    var d = 0.0 ;

    var r = max(size.x, size.y);
    var sr = max(r , size.z);
    var scx = center.x;
    var scy = center.y;
    var scz = center.z;

    for(var p:i32 = 0; p < 6 ; p = p + 1 ){
        var plane = planes[p];
        d = plane.x * scx + plane.y * scy + plane.z * scz + plane.w;
        if (d <= -sr) {
        return 0.0;
        }
        if (d > sr) {
        c+=1.0;
        }
    }

    if( c >= 6.0 ){
        return 2.0 ;
    }else{
        return 1.0 ;
    }
}

@compute @workgroup_size( 128 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
    let id = globalInvocation_id.x ;
    if(id + 1u > u32(planes[6].x) ){
        outBuffer[id] = f32(0.0); 
        return ;
    }

    let renderBound = cullingList[id];
    let boundID = i32(renderBound.index) ;
    var plane = planes[0];

    let worldMatrix = models.matrix[boundID];
    let projMat = globalUniform.projMat ;

    let const_boundMin : vec3<f32> = vec3<f32>(-0.5,-0.5,-0.5) ;   
    let const_boundMax : vec3<f32> = vec3<f32>(0.5,0.5,0.5) ;   

    let boundMin = worldMatrix * vec4<f32>(const_boundMin, 1.0);
    let boundMax = worldMatrix * vec4<f32>(const_boundMax, 1.0);

    let size = abs( boundMax.xyz - boundMin.xyz ) * 0.65 ;
    let center = worldMatrix[3].xyz ;

    var isIn :f32 = 0.0 ;

    isIn = containsBox(size,center);

    outBuffer[id] = f32(isIn); 
}
`
    );

    let ZPassShader_cs = (
      /*wgsl*/
      `
    @group(0) @binding(0) var<storage,read_write> visibleBuffer: array<f32>;
    @group(0) @binding(1) var zBufferTexture : texture_2d<f32>;

    @compute @workgroup_size(8, 8, 1)
    fn CsMain( @builtin(global_invocation_id) globalInvocation_id : vec3<u32> ) {
        var fragCoord = vec2<i32>( globalInvocation_id.xy );
        let md = textureLoad(zBufferTexture,fragCoord,0);

        let meshID = i32(floor( md.w + 0.1 ));
        if (meshID >= 0) {
            visibleBuffer[meshID] = 1.0 ;
        }
    }
`
    );

    let VertexAttributeIndexShader = (
      /*wgsl*/
      `
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,
        @location(auto) vIndex: f32,
        @location(auto) index2: f32,
        
    }

    struct VertexOutput {
        @location(auto) index: f32,
        @location(auto) varying_UV0: vec2<f32>,
        @location(auto) varying_UV1: vec2<f32>,
        @location(auto) varying_ViewPos: vec4<f32>,
        @location(auto) varying_Clip: vec4<f32>,
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_WNormal: vec3<f32>,
        @location(auto) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(auto) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,

        fillRotation:f32,
        empty0:f32,
        empty1:f32,
        empty2:f32,

        baseColor:vec4f,
        lineColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
        uvRect2:vec4f,
        uvSpeed:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`
    );

    let Sky_glsl_vs = `
#version 450
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 normal;
layout(location = 2) in vec2 uv;

layout(location = 0) out vec2 fragUV;
layout(location = 1) out vec4 vWorldPos;
layout(location = 2) out vec3 vWorldNormal;

layout(set = 0, binding = 0) 
uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
};

layout(set = 1, binding = 0) 
buffer Uniforms {
    mat4[] modeMat;
};

 mat4 inverse( in mat4 m ){
    return mat4(
        m[0][0], m[1][0], m[2][0], 0.0,
        m[0][1], m[1][1], m[2][1], 0.0,
        m[0][2], m[1][2], m[2][2], 0.0,
        -dot(m[0].xyz,m[3].xyz),
        -dot(m[1].xyz,m[3].xyz),
        -dot(m[2].xyz,m[3].xyz),
        1.0 );
}

void main(){
    fragUV = uv;
    mat4 modelMat = modeMat[gl_InstanceID]; 
    mat4 vm = viewMat * modelMat;
	mat3 normalMatrix = mat3(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	vec3 eNormal = normalize( normalMatrix * normal );
    
    vWorldPos = modelMat * vec4(position.xyz,1.0) ;

    mat4 fixedViewMat = viewMat ;
    fixedViewMat[3] = vec4(0.0,0.0,-8.0,1.0);
    vec4 mvPosition = modelMat * vec4( position.xyz, 1.0 );
    gl_Position = projMat * fixedViewMat * mvPosition;
}

`;
    let Sky_glsl_fs = `
#version 450

layout(location = 0) in vec2 fragUV;
layout(location = 1) in vec4 vWorldPos;
layout(location = 2) in vec3 vWorldNormal;

layout(location = 0) out vec4 o_Target;

layout(set = 2, binding = 0) 
uniform sampler baseMapSampler;
layout(set = 2, binding = 1) 
uniform texture2D baseMap;

layout(set = 3, binding = 0) uniform uniformData {
    vec3 eyesPos;
    float exposure;
    float roughness;
};

vec3 LinearToGammaSpace(in vec3 linRGB)
{
    vec3 _linRGB = vec3(linRGB) ;
    _linRGB = max(linRGB, vec3(0.0, 0.0, 0.0));
    _linRGB.r = pow(linRGB.r,0.416666667);
    _linRGB.g = pow(linRGB.g,0.416666667);
    _linRGB.b = pow(linRGB.b,0.416666667);
    return max(1.055 * _linRGB - 0.055, vec3(0.0));
}

void main(){
    int maxMipLevel = textureQueryLevels(baseMap, fragUV).x ;
    vec4 textureColor = textureCubeLod( sampler2D(baseMap, baseMapSampler), normalize(vWorldPos.xyz), roughness * float(maxMipLevel) ) ;
    o_Target = vec4(LinearToGammaSpace(textureColor.rgb),1.0) * exposure ;
}

`;

    let LUT_glsl = `
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix ;
    mat4 pvMatrixInv ;
    float frame;
    float time;
    float detail;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;
    float intensity;
};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;

layout(set = 2, binding = 2) uniform sampler lutMapSample;
layout(set = 2, binding = 3) uniform texture2D lutMap;

layout(set = 3, binding = 0) uniform UniformData{
    float intensity ;
};

void main() {
    vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
    vec4 col = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale);
    // vec3 col = vec3(pow(base.xyz,vec3(1.0/2.2)));

    float Bcolor = col.b * 63.0;
	vec2 quad1;
    quad1.y = floor(floor(Bcolor) / 8.0);
    quad1.x = floor(Bcolor) - (quad1.y * 8.0);

    vec2 quad2;
    quad2.y = floor(ceil(Bcolor) / 8.0);
    quad2.x = ceil(Bcolor) - (quad2.y * 8.0);

    const float tmp = (0.125-(0.5/512.0)) ;
    const float tmp2 = 0.5/512.0 ;

    vec2 uv1;
    vec2 uv2;
	uv1.x = ((quad1.x)*0.125)+ tmp2 + (tmp* col.r);
	uv1.y = (((quad1.y)*0.125) + tmp2 + (tmp* col.g));

	uv2.x = ((quad2.x)*0.125)+ tmp2 + (tmp* col.r);
	uv2.y = (((quad2.y)*0.125)+ tmp2 + (tmp* col.g));

    vec4 color1 = texture(sampler2D(lutMap, lutMapSample), uv1);
    vec4 color2 = texture(sampler2D(lutMap, lutMapSample), uv2);

    vec4 newColor = mix(color1, color2, fract(Bcolor));
    // vec3 outC = pow(newColor.xyz,vec3(2.2));

    o_Target = vec4(newColor.rgb, col.a );
    // o_Target = vec4(1.0);
}
`;

    let Graphic3DShader = (
      /*wgsl*/
      `
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexAttributes {
        @location(auto) position: vec4<f32>,
        @location(auto) color: vec4<f32>,
    }

    struct VertexOutput {
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        var worldMatrix = models.matrix[u32(vertex.position.w)];
        var worldPos = (worldMatrix * vec4<f32>(vertex.position.xyz, 1.0));
        var viewPosition = ((globalUniform.viewMat) * worldPos);
        var clipPosition = globalUniform.projMat * viewPosition;

        var ORI_VertexOut: VertexOutput; 
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_Color = vertex.color;
        ORI_VertexOut.member = clipPosition;
        return ORI_VertexOut;
    }

    struct FragmentOutput {
        @location(auto) color: vec4<f32>,
        // #if USE_WORLDPOS
            @location(auto) worldPos: vec4<f32>,
        // #endif
        // #if USEGBUFFER
            @location(auto) worldNormal: vec4<f32>,
            @location(auto) material: vec4<f32>,
        // #endif
        @builtin(frag_depth) out_depth: f32
    };

    @fragment
    fn FragMain(  
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) varying_Color: vec4<f32>,
    ) -> FragmentOutput {
        var result: FragmentOutput;

        // #if USE_WORLDPOS
            result.worldPos = vWorldPos;
        // #endif

        // #if USEGBUFFER
            // result.worldNormal = vec4<f32>(0.0, 0.0, 0.0, 1.0); 
            result.material = vec4<f32>(0.0, 1.0, 0.0, 0.0);
        // #endif

        result.color = varying_Color;

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // let pt = pow((f / n),z);
        // let ratio = n * pt / (f / n);
        // result.out_depth =  ratio ;
        return result;
    }
`
    );

    let graphicDynamicCompute = (subCode) => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    #include "MatrixShader"

    ${subCode}

    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:u32,
        skipFace3:u32,
        skipFace4:u32,
    }

    var<private> uv0 = vec2f(0.0, 0.0);
    var<private> uv1 = vec2f(1.0, 0.0);
    var<private> uv2 = vec2f(1.0, 1.0);
    var<private> uv3 = vec2f(0.0, 1.0);

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read_write> drawBuffer : DrawInfo ;
    
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        compute(workgroup_id,local_invocation_id);
    }

    //* gID mesh vertex group id
    //* v1 face vertex 1 position 
    //* v2 face vertex 2 position 
    //* v3 face vertex 3 position 
    //* u1 face uv 1  
    //* u2 face uv 2  
    //* u3 face uv 3  
    fn drawFace(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawLine(gID:u32, v1:vec3f, v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(1.0,0.0);
        var fID = atomicAdd(&drawBuffer.skipFace,1u);  
        drawFace2(gID, fID, v1, v2, v3, u1, u2, u3, uv2);
    }

    fn drawFace2(gID:u32, fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f, uv2:vec2f){
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(gID , fID * 3u + 0u, v1, n, u1, uv2);
        writeVertexBuffer(gID , fID * 3u + 1u, v2, n, u2, uv2);
        writeVertexBuffer(gID , fID * 3u + 2u, v3, n, u3, uv2);
    }

    fn drawRect(gID:u32,center:vec3f,width:f32,height:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,0.0,1.0);
        let p1 = mat * vec4f(maxX,maxY,0.0,1.0);
        let p2 = mat * vec4f(maxX,minY,0.0,1.0);
        let p3 = mat * vec4f(minX,minY,0.0,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
    }

    fn drawCube(gID:u32,center:vec3f,width:f32,height:f32,depth:f32,rotX:f32,rotY:f32,rotZ:f32){
        let minX = -width * 0.5;
        let maxX = width * 0.5;
        let minY = -height * 0.5;
        let maxY = height * 0.5;
        let minZ = -depth * 0.5;
        let maxZ = depth * 0.5;

        let mat = buildRotateXYZMat4(rotX,rotY,rotZ,center.x, center.y, center.z);

        let p0 = mat * vec4f(minX,maxY,minZ,1.0);
        let p1 = mat * vec4f(maxX,maxY,minZ,1.0);
        let p2 = mat * vec4f(maxX,minY,minZ,1.0);
        let p3 = mat * vec4f(minX,minY,minZ,1.0);

        let p4 = mat * vec4f(maxX,maxY,maxZ,1.0);
        let p5 = mat * vec4f(minX,maxY,maxZ,1.0);
        let p6 = mat * vec4f(minX,minY,maxZ,1.0);
        let p7 = mat * vec4f(maxX,minY,maxZ,1.0);

        drawFace(gID,p0.xyz,p1.xyz,p2.xyz,uv0,uv1,uv2);
        drawFace(gID,p0.xyz,p2.xyz,p3.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p4.xyz,p7.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p7.xyz,p2.xyz,uv0,uv2,uv3);
        drawFace(gID,p4.xyz,p5.xyz,p6.xyz,uv0,uv1,uv2);
        drawFace(gID,p4.xyz,p6.xyz,p7.xyz,uv0,uv2,uv3);
        drawFace(gID,p1.xyz,p0.xyz,p5.xyz,uv0,uv1,uv2);
        drawFace(gID,p1.xyz,p5.xyz,p4.xyz,uv0,uv2,uv3);
        drawFace(gID,p0.xyz,p3.xyz,p6.xyz,uv1,uv2,uv3);
        drawFace(gID,p0.xyz,p6.xyz,p5.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p6.xyz,p3.xyz,uv1,uv3,uv0);
        drawFace(gID,p2.xyz,p7.xyz,p6.xyz,uv1,uv2,uv3);
    }

    //** compute face normal */
    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    //** write vertice data to geometry */
    fn writeVertexBuffer( gID:u32, vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(gID) ;
    }

    fn GetDistance( pos: vec3f,  plane : vec4f ) -> f32 {
        return plane.x * pos.x + plane.y * pos.y + plane.z * pos.z + plane.w;
     }
  
     fn IsOutofFrustum( pos:vec3f , radius: f32) -> bool {
        var c: i32 = 0;
        var d: f32 = 0.0;
        for(var i :i32 = 0; i < 6; i++){
           d = GetDistance(pos, globalUniform.frustumPlanes[i]);
           if (d <= -radius) {
              return false;
           }
           if (d > radius) {
              c++;
           }
       }
       return c > 0;
     }

    `
      );
      return code;
    };

    let graphicFaceCompute2 = (segmentCode) => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${segmentCode}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                genDir(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                genDir2(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn genDir(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = lc * dc + p1 ;
        // let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;
        // let end_r = lc * dc * 2.0 + p1;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    
    fn genDir2(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let sOe = dot(d0,dc);
        let neg = dirNeg(sOe) ;
        
        let angle = acos(sOe) ;
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * neg;

        let right = cross( normalize(d1) , up );
        let first_l = lc * dc + p1;
        let first_r = right * shapeInfo.width + p1;

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)  ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV) ;//* + vec2f(0.0,1.0) /* vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) ;//* + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l1 * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace( fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `
      );
      return code;
    };

    let graphicFaceCompute = (segmentCode) => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${segmentCode}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }else if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else{
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                let l3 = segi + 2u;
                drawLineBody(l0,l1,l2,l3,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(l0:u32,l1:u32,l2:u32,l3:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 
        let p3 = shapeInfo.paths[l3].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;
        let right1 = cross(d2 , d1) ;

        let dir0 = normalize(d1 - d0) ;
        let dir1 = normalize(d2 - d1) ;

        // let lOr0 = dot(d0 , d3);
        // let lOr1 = dot(d1 , d4);

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(d1,dir1)) ;

        if(angle0<0.0){
            angle0 *= -1.0 ;
        }
        if(angle1<0.0){
            angle1 *= -1.0 ;
        }

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;

        let d1Right = cross(d1,up);
        let d2Right = cross(d2,up);

        newP0 = dir0 * lc0 + p1 ;
        newP1 = -dir0 * lc0 + p1 ;
        newP2 = dir1 * lc1 + p2 ;
        newP3 = -dir1 * lc1 + p2 ;

        newP4 = -d2Right * shapeInfo.width + p2 ;
        newP5 = -lc1 * dir1 + p2 ;

        let uScale = 1.0 ;
        let lVScale = length(newP2 - newP0);
        let rVScale = length(newP3 - newP1);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l1 * 4u + 0u,newP0,newP1,newP2,u0,u1,u3);
        // drawFace(l1 * 4u + 1u,newP0,newP2,newP3,u0,u1,u3);

        // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u1,u2,u3);
        // drawFace(l1 * 4u + 3u,newP3,newP4,newP5,u1,u2,u3);
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let nextRight = cross( normalize(d1) , up );
        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
        var next:vec3f;
        var outer:vec3f = p1 - lc * dc;
    
        if(lOr < 0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
            next = -nextRight * shapeInfo.width + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
            next = nextRight * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0) - vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)- vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 4u + 0u,end_l,end_r,next,u0,u1,u3);

        if(lOr < 0.0){
            drawFace(l0 * 4u + 1u,outer,end_l,next,u0,u1,u3);
        }else{
            drawFace(l0 * 4u + 1u,next,end_r,outer,u0,u1,u3);
        }

        drawFace(l0 * 4u + 2u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 4u + 3u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = cross(d0 , d1).y;
        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        // drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 4u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 4u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `
      );
      return code;
    };

    let GraphicFaceCompute3 = (segmentCode) => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        height:f32,
        pathCount:f32,
        uSpeed:f32,
        vSpeed:f32,
        radiu:f32,
        paths:array<vec4f,${segmentCode}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> shapeIndex:u32 ;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        shapeIndex = workgroup_id.x ;
        segIndex = workgroup_id.y * 256u + global_invocation_id.x ;
        shape = shapeBuffer[shapeIndex];
        segCount = u32(shape.pathCount -1.0);
        // segIndex = 3u ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            // geometryInfoBuffer[0].index = 0;
            switch (u32(shape.shapeType)) {
                case 0u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    break;
                }
                case 1u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 2u:{
                    // drawFace(0u,shape.paths[0].xyz,shape.paths[1].xyz,shape.paths[2].xyz,uv,uv,uv);
                    // drawFace(1u,shape.paths[2].xyz,shape.paths[3].xyz,shape.paths[0].xyz,uv,uv,uv);
                    break;
                }
                case 3u:{
                    // if(segIndex < u32(shape.pathCount)){
                        drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    // }
                    break;
                }
                default:
                    {
                    break;
                    }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == 0u){
                let l0 = segi ;
                let l1 = segi + 1u;
                let l2 = segi + 2u;
                drawLineStart(l0,l1,l2,shapeInfo,up);
            }else if(segi == (segCount -1u)){
                let l0 = segi - 1u;
                let l1 = segi ;
                let l2 = segi + 1u;
                drawLineEnd(l0,l1,l2,shapeInfo,up);
            }
        }
    }

    fn drawLineStart(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);
        let angle = acos(dot(d0,dc)) ;
        let lc = shapeInfo.width / sin(angle) ;

        let right = cross( normalize(d0) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        var end_l:vec3f;
        var end_r:vec3f;
    
        if(lOr<0.0){
            end_l = -right * shapeInfo.width + p1;
            end_r = lc * dc + p1 ;
        }else{
            end_l = lc * dc + p1 ;
            end_r = right * shapeInfo.width + p1 ;
        }

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l);
        let rVScale = length(end_r - first_r);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l0 * 3u + 0u,end_l,end_r,p1,u0,u1,u3);
        drawFace(l0 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l0 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawLineEnd(l0:u32,l1:u32,l2:u32,shapeInfo:ShapeInfo,up:vec3f){
        let p0 = shapeInfo.paths[l0].xyz; 
        let p1 = shapeInfo.paths[l1].xyz; 
        let p2 = shapeInfo.paths[l2].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let dc = normalize(d1 - d0) ;

        let lOr = dirNeg(p2.x - p0.x);

        let angle = acos(dot(d0,dc));
        let lc = shapeInfo.width / sin(angle) ;
        let offsetV = shapeInfo.width / tan(angle) * (-lOr) ;

        let right = cross( normalize(d1) , up );

        var first_l:vec3f;
        var first_r:vec3f;
        if(lOr<0.0){
            first_l = -right * shapeInfo.width + p1;
            first_r = lc * dc + p1;
        }else{
            first_l = lc * dc + p1;
            first_r = right * shapeInfo.width + p1;
        }

        let end_l = -right * shapeInfo.width + p2;
        let end_r = right * shapeInfo.width + p2;

        let uScale = 1.0 ;
        let lVScale = length(end_l - first_l) ;
        let rVScale = length(end_r - first_r) ;

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0 - offsetV)   + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,rVScale - offsetV)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,lVScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(l2 * 3u + 0u,p1,first_r,first_l,u0,u1,u3);
        drawFace(l2 * 3u + 1u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(l2 * 3u + 2u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = shapeInfo.paths[firstSegi].xyz; 
        let p1 = shapeInfo.paths[endSegi].xyz; 
        // let p2 = shapeInfo.paths[nextSegi].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let u0 = vec2f(0.0,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;
        let u1 = vec2f(uScale,0.0)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u2 = vec2f(uScale,vScale)  + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time;
        let u3 = vec2f(0.0,vScale) + vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed) * time ;

        drawFace(segi * 2u + 0u,first_l,first_r,end_l,u0,u1,u3);
        drawFace(segi * 2u + 1u,first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(fID:u32, v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        writeVertexBuffer(fID*3u+0u,v1,n,u1,uv2);
        writeVertexBuffer(fID*3u+1u,v2,n,u2,uv2);
        writeVertexBuffer(fID*3u+2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    fn dirNeg(cosO:f32) -> f32{
        var neg = 1.0 ;
        if(cosO == 0.0){
            neg = 0.0 ;
        }else if(cosO < 0.0){
            neg = -1.0 ;
        }
        return neg ;
    }
  
    `
      );
      return code;
    };

    let GraphicLineCompute = () => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        nx:f32, 
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct GeometryInfo{
        index : u32 ,
        faceStart : u32 ,
        faceEnd : u32 ,
        faceCount : u32 ,
    }

    struct ShapeInfo{
        shapeIndex:f32, //face,poly,rectangle,line,cycle,,box,sphere
        shapeType:f32,
        width:f32,
        lineCap:f32,
        
        pathCount:f32,
        uScale:f32,
        vScale:f32,
        lineJoin:f32,

        startPath:f32,
        endPath:f32,
        uSpeed:f32,
        vSpeed:f32,
    }

    struct DrawInfo{
        skipFace:atomic<u32>,
        skipFace2:atomic<u32>,
        skipFace3:atomic<u32>,
        skipFace4:atomic<u32>,
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    // @group(0) @binding(2) var<storage, read_write> geometryInfoBuffer : array<GeometryInfo>;
    @group(0) @binding(2) var<storage, read> shapeBuffer : array<ShapeInfo>;
    @group(0) @binding(3) var<storage, read> pathBuffer : array<vec4f>;
    @group(0) @binding(4) var<storage, read_write> drawBuffer : DrawInfo ;
    // @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;
    var<private> segIndex:u32 ;
    var<private> segCount:u32 ;
    var<private> time:f32 ;
    var<private> pathOffset:u32 ;
    var<private> faceOffset:u32 ;
    // var<private> faceStrip:u32 = 1u ;
    var<private> shape:ShapeInfo ;
    @compute @workgroup_size(256,1,1)
    fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32>){
        shape = shapeBuffer[workgroup_id.x];
        pathOffset = u32(shape.startPath) ;
        segCount = u32(shape.pathCount - 1.0);
        segIndex = workgroup_id.y * 256u + local_invocation_id.x ;
        if( segIndex < segCount ){
            time = globalUniform.time * 0.001;
            let uv = vec2f(0.0,0.0);
            switch (u32(shape.shapeType)) {
                case 0u:{
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                case 3u:{
                    drawLine(segIndex,shape,vec3f(0.0,1.0,0.0));
                    break;
                }
                default:
                {
                    break;
                }
            }
        }
    }

    fn drawLine(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        if(segCount == 1u){
            drawPolyStartEnd(segi,shapeInfo,up);
        }else{
            if(segi == (segCount - 1u)){
                drawLineEnd(segi,shapeInfo,up);
            }else if(segi == 0u){
                drawLineStart(segi,shapeInfo,up);
            }else{
                drawLineBody(segi,shapeInfo,up);
            }
        }
    }

    fn drawLineBody(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = segi + 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p1,d1)) ;
        let len1 = (dot(newP1 - p1,d1)) ;
        let len2 = (dot(newP2 - p1,d1)) ;
        let len3 = (dot(newP3 - p1,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawLineStart(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = 0u;
        let l1 = 0u ;
        let l2 = 1u;
        let l3 = 2u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p0 = normalize(p1 - p2) * 10.0 + p1 ; 
        let p3 = pathBuffer[l3+pathOffset].xyz; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1<0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            newP2 = dir1 * lc1 + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);
        
        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
        }
    }

    fn drawLineEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let l0 = segi - 1u;
        let l1 = segi ;
        let l2 = segi + 1u;
        let l3 = 0u;

        var newP0 : vec3f ;
        var newP1 : vec3f ;
        var newP2 : vec3f ;
        var newP3 : vec3f ;
        var newP4 : vec3f ;
        var newP5 : vec3f ;
        var newP6 : vec3f ;

        let p0 = pathBuffer[l0+pathOffset].xyz; 
        let p1 = pathBuffer[l1+pathOffset].xyz; 
        let p2 = pathBuffer[l2+pathOffset].xyz; 
        let p3 = normalize(p2 - p1) * 10.0 + p2 ; 

        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        let d2 = normalize(p3 - p2) ;

        let right0 = cross(d0 , d1) ;

        var dir0 = normalize(d1 - d0) ;
        var dir1 = normalize(d2 - d1) ;

        var angle0 = acos(dot(d0,dir0)) ;
        var angle1 = acos(dot(dir1,d2)) ; 

        var neg0 = 1.0 ;
        var neg1 = 1.0 ;

        var negD0 = cross(d1,-d0).y ;
        var negD1 = cross(-d1,d2).y ;

        let lc0 = shapeInfo.width / sin(angle0) ;
        let lc1 = shapeInfo.width / sin(angle1) ;

        let d0Right = cross(d1,up);
        let d1Right = cross(d2,up);

        if(negD0<0.0){
            ///neg true
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = dir0 * lc0 + p1 ;
        }else if( negD0 == 0.0){
            newP0 = -d0Right * shapeInfo.width + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }else{
            ///neg false
            newP0 = dir0 * lc0 + p1 ;
            newP1 = d0Right * shapeInfo.width + p1 ;
        }

        if(negD1 < 0.0){
            ///neg true
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = dir1 * lc1 + p2 ;

            newP4 = d1Right * shapeInfo.width + p2 ;
            newP5 = -dir1 * lc1 + p2 ;
            newP6 = newP2 ;
        }else if(negD1 == 0.0) {
            ///neg false
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }else{
            ///neg false
            // newP2 = dir1 * lc1 + p2 ;
            newP2 = d0Right * shapeInfo.width + p2 ;
            newP3 = -d0Right * shapeInfo.width + p2 ;

            newP4 = -d1Right * shapeInfo.width + p2 ;
            newP5 = newP3 ;
            newP6 = -dir1 * lc1 + p2 ;
        }

        let len0 = (dot(newP0 - p0,d1)) ;
        let len1 = (dot(newP1 - p0,d1)) ;
        let len2 = (dot(newP2 - p0,d1)) ;
        let len3 = (dot(newP3 - p0,d1)) ;

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uSpeed,shapeInfo.vSpeed)  * time ;

        let u0 = vec2f(0.0,len0) * uvScale + vRoll;
        let u1 = vec2f(1.0,len1) * uvScale + vRoll;
        let u2 = vec2f(1.0,len2) * uvScale + vRoll;
        let u3 = vec2f(0.0,len3) * uvScale + vRoll;

        drawFace(newP0,newP1,newP2,u0,u1,u2);
        drawFace(newP0,newP2,newP3,u0,u2,u3);

        if(negD1 != 0.0) {
            let outFaceDir = normalize(d1 + d2);
            let l = dot(newP4 - p2,outFaceDir) * 0.5 ;

            switch (u32(shapeInfo.lineJoin)) {
                case 0u:{
                    var uu0 : vec2f ;
                    var uu1 : vec2f ;
                    var uu2 : vec2f ;
                    if(negD1>0.0){
                        uu0 = vec2f(1.0,0.0) * uvScale - vRoll; 
                        uu1 = vec2f(0.0,-l) * uvScale - vRoll;
                        uu2 = vec2f(0.0,l) * uvScale - vRoll;
                    }else{
                        uu0 = vec2f(1.0,-l) * uvScale + vRoll;
                        uu1 = vec2f(1.0,l) * uvScale  + vRoll;
                        uu2 = vec2f(0.0,0.0) * uvScale + vRoll;
                    }
                    // drawFace(newP2,newP4,newP3,uu0,uu1,uu2);
                    break;
                }
                case 1u:{
                    // let len4 = dot(newP4 - p2,outFaceDir) ;
                    // let len5 = dot(newP5 - p2,outFaceDir) ;
                    // let len6 = dot(newP3 - p2,outFaceDir) ;
                    // let len7 = dot(newP2 - p2,outFaceDir) ;
        
                    // let vRoll = -vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
                    // let u4 = vec2f(1.0,-len4) + vRoll; //
                    // let u5 = vec2f(0.0,0.0) + vRoll;  //
                    // let u6 = vec2f(1.0,len4) + vRoll;//
                    // let u7 = vec2f(1.0,0.0) + vRoll;  //
                    // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
                    // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
                    break;
                }
                case 2u:{
                    break;
                }
                default:{
                    break;
                }
            }
            // drawFace(l1 * 4u + 2u,newP2,newP4,newP3,u4,u6,u5);
            // drawFace(l1 * 4u + 3u,newP6,newP5,newP4,u4,u7,u6); 
        }
    }

    fn drawPolyStartEnd(segi:u32,shapeInfo:ShapeInfo,up:vec3f){
        let firstSegi = segi ;
        let endSegi = segi + 1u;
        let nextSegi = segi + 2u;

        let p0 = pathBuffer[firstSegi+pathOffset].xyz; 
        let p1 = pathBuffer[endSegi+pathOffset].xyz; 
        // let p2 = pathBuffer[nextSegi+pathOffset].xyz; 

        let dir = p1 - p0 ;
        let right = cross( normalize(dir) , up );
        let first_l = -right * shapeInfo.width + p0;
        let first_r = right * shapeInfo.width + p0;

        let end_l = -right * shapeInfo.width + p1;
        let end_r = right * shapeInfo.width + p1;

        let uScale = 1.0 ;
        let vScale = length(dir);

        let uvScale = vec2f(shapeInfo.uScale,shapeInfo.vScale) ;// * time ;
        let u0 = vec2f(0.0,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;
        let u1 = vec2f(uScale,0.0) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u2 = vec2f(uScale,vScale) * uvScale ;// + vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time;
        let u3 = vec2f(0.0,vScale) * uvScale ;//+ vec2f(0.0,1.0) * vec2f(shapeInfo.uScale,shapeInfo.vScale) * time ;

        drawFace(first_l,first_r,end_l,u0,u1,u3);
        drawFace(first_r,end_r,end_l,u1,u2,u3);
    }

    fn drawFace(v1:vec3f , v2:vec3f , v3:vec3f , u1:vec2f , u2:vec2f, u3:vec2f){
        let uv2 = vec2f(0.0,0.0);
        let n = getNormal(v1,v2,v3);
        var fID = atomicAdd(&drawBuffer.skipFace,1u); 
        writeVertexBuffer(fID * 3u + 0u, v1,n,u1,uv2);
        writeVertexBuffer(fID * 3u + 1u,v2,n,u2,uv2);
        writeVertexBuffer(fID * 3u + 2u,v3,n,u3,uv2);
    }

    fn getNormal(v1:vec3f , v2:vec3f , v3:vec3f) -> vec3f{
        let p0 = v2 - v1 ;
        let p1 = v3 - v2 ;
        let n = cross(p0,p1);
        return normalize(n);
    }

    fn writeVertexBuffer( vID:u32 , pos:vec3f , normal:vec3f , uv:vec2f, uv2:vec2f ){
        vertexBuffer[vID].position = pos;
        vertexBuffer[vID].nx = normal.x ;
        vertexBuffer[vID].ny = normal.y ;
        vertexBuffer[vID].nz = normal.z ;
        vertexBuffer[vID].uv_x = uv.x ;
        vertexBuffer[vID].uv_y = uv.y ;
        vertexBuffer[vID].uv2_x = uv2.x ;
        vertexBuffer[vID].uv2_y = uv2.y ;
        vertexBuffer[vID].index = f32(0) ;
    }

    `
      );
      return code;
    };

    let graphicTrailCompute = (segmentCode) => {
      let code = (
        /*wgsl*/
        `
    #include "GlobalUniform"
    struct VertexInfo{
        position:vec3f,
        // px:f32,
        // py:f32,
        // pz:f32,
        nx:f32,
        ny:f32,
        nz:f32,
        uv_x:f32,
        uv_y:f32,
        uv2_x:f32,
        uv2_y:f32,
        index:f32,
        index2:f32
    }

    struct TrailInfo{
        index : f32 ,
        segment : f32 ,
        visible : f32 ,
        width: f32,

        uv: vec4f,

        uvSpeed: vec2f,
        smoothLine: f32,
        faceMode: f32,
        up: vec4f,
        ids:array<f32,${segmentCode}>
    }

    @group(0) @binding(1) var<storage, read_write> vertexBuffer : array<VertexInfo>;
    @group(0) @binding(2) var<storage, read> trailBuffer : array<TrailInfo>;
    @group(0) @binding(3) var<storage, read> models : array<mat4x4<f32>>;

    var<private> time:f32;
    var<private> viewDir:vec3f;

    @compute @workgroup_size(256)
    fn CsMain(@builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) global_invocation_id : vec3<u32>){
        let rID = workgroup_id.x ;
        let trailInfo = trailBuffer[rID];
        let vLen = u32(trailInfo.segment+1.0) ;
        let vID = global_invocation_id.x ;

        // if(vID < vLen ){
            time = globalUniform.time * 0.001;
            var right:vec3f ;
            
            switch (u32(trailInfo.faceMode)) {
                case 0u:{
                    right = getRightByMode(vID,vLen,viewDir,trailInfo) ;
                    break;
                }
                case 1u:{
                    right = vec3f(0.0,0.0,1.0) ;
                    break;
                }
                case 2u:{
                    right = getRightByMode(vID,vLen,trailInfo.up.xyz,trailInfo) ;
                    break;
                }
                default:{
                    break;
                }
            }
            writeTOBuffer(rID,vID,vLen,right,trailInfo);
        // }
    }

 

    fn writeTOBuffer(rID:u32, vID:u32 , vLen:u32, right:vec3f , trailInfo:TrailInfo ){
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;

        let worldPos = models[i32(trailInfo.ids[vID])][3].xyz ;
        let leftPos = worldPos - right.xyz * trailInfo.width ;
        let rightPos = worldPos + right.xyz * trailInfo.width ;

        vertexBuffer[li].position = leftPos ;
        vertexBuffer[ri].position = rightPos ;

        let uvS = time * trailInfo.uvSpeed ;

        vertexBuffer[li].uv_x = (trailInfo.uv.x) + uvS.x ;
        vertexBuffer[ri].uv_x = (trailInfo.uv.z + trailInfo.uv.x) + uvS.x ;

        // var ld = 0.0 ;
        // var rd = 0.0 ;
        // if(vID>0u){
        //     let vid0 = getVID(vID,vLen,rID);
        //     let vid1 = getVID(vID-1u,vLen,rID);
        
        //     ld = distance( vertexBuffer[li].position , vertexBuffer[vid1.x].position ) ;
        //     rd = distance( vertexBuffer[ri].position , vertexBuffer[vid1.y].position ) ;

        //     vertexBuffer[li].uv_y = vertexBuffer[vid1.x].uv_y + 1.0 / ld * 100.0 ;//+ uvS.y ;
        //     vertexBuffer[ri].uv_y = vertexBuffer[vid1.y].uv_y + 1.0 / rd * 100.0 ;//+ uvS.y ;
        // }else{
            let v = (1.0 - f32(vID) / trailInfo.segment) * trailInfo.uv.w + trailInfo.uv.y;
            vertexBuffer[li].uv_y = v + uvS.y ;
            vertexBuffer[ri].uv_y = v + uvS.y ;
        // }
    }

    fn getRight(p0:vec3f,p1:vec3f,p2:vec3f,up:vec3f) -> vec3f {
        let d0 = normalize(p1 - p0) ;
        let d1 = normalize(p2 - p1) ;
        // var a = dot(d0,d1) ;
        // var ep = 0.0 ;
        // if(a<0.0){
        //     a = -a ;
        //     ep = 1.0/sin(a*0.25) ;
        // }else if(a == 0.0){
        //     ep = 1.414 ;
        // }else{
        //     ep = 1.0 ;
        // }
        let forward = normalize((d0 + d1)+ vec3f(0.000001,0.000001,0.000001)) ;
        return normalize(cross(forward,up)) ;//* ep ;
    }

    fn getVID(vID:u32,vLen:u32,rID:u32) -> vec2<u32> {
        let i0 = (vID + (vLen * rID)) * 2u ;
        let li = i0 + 0u ;
        let ri = i0 + 1u ;
        return vec2<u32>(li,ri);
    }

    fn getRightByMode( vID:u32 , vLen:u32, up:vec3f, trailInfo:TrailInfo ) -> vec3f{
        var right:vec3f;
        if(vID==0u){
            // first
            let sp0 = models[i32(trailInfo.ids[ 0 ])][3].xyz ;
            let sp1 = models[i32(trailInfo.ids[ 1 ])][3].xyz ;
            let firstFront = normalize(sp1 - sp0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - sp0) ;
            right = normalize(cross(firstFront,viewDir));
        }else if( vID < (vLen-1) ){
            // body
            let bp0 = models[i32(trailInfo.ids[vID-1])][3].xyz ;
            let bp1 = models[i32(trailInfo.ids[vID])][3].xyz ;
            let bp2 = models[i32(trailInfo.ids[vID+1])][3].xyz ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - bp1) ;
            right = getRight(bp0,bp1,bp2,viewDir) ;
        }else{
            // last
            let ep0 = models[i32(trailInfo.ids[u32(trailInfo.segment)-1u])][3].xyz ;
            let ep1 = models[i32(trailInfo.ids[u32(trailInfo.segment)])][3].xyz ;
            let endFront = normalize(ep1 - ep0) ;
            viewDir = -normalize(globalUniform.CameraPos.xyz - ep1) ;
            right = normalize(cross(endFront,viewDir));
        }
        return normalize(right) ; 
    }
    `
      );
      return code;
    };

    let ColorLitShader = (
      /*wgsl*/
      `
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }

        fn frag(){
            ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
            ORI_ShadingInput.Roughness = materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = 1.0 ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

            useShadow();

            BxDFShading();
        }
    `
    );

    let GIProbeShader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "Irradiance_frag"
    #include "MathShader"
    
    struct MaterialUniform {
      probeUniform:vec4<f32>,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    var<private> probeID: i32 ;
    var<private> debugType: i32 ;
    
    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        probeID = i32(materialUniform.probeUniform.x);
        debugType = i32(materialUniform.probeUniform.y);
        if(debugType == 0){
            ORI_ShadingInput.BaseColor = debugProbe(probeID);
        }else if(debugType == 1){
            ORI_ShadingInput.BaseColor = getIrradiance();
        }else if(debugType == 2){
            ORI_ShadingInput.BaseColor = debugProbeDepth(probeID);
        }
        UnLit();
    }
    `
    );

    let GlassShader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    // @group(1) @binding(auto)
    // var noes_MapSampler: sampler;
    // @group(1) @binding(auto)
    // var noes_Map: texture_2d<f32>;

    @group(1) @binding(auto)
    var splitTexture_MapSampler: sampler;
    @group(1) @binding(auto)
    var splitTexture_Map: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
        screenUV = (screenUV.xy + 1.0) * 0.5;
        screenUV.y = 1.0 - screenUV.y;

        screenUV.x = clamp(sin(screenUV.x * 1.0),0.0,1.0) ;
        screenUV.y = clamp(sin(screenUV.y * 1.0),0.0,1.0) ;
        // screenUV.y = cos(ORI_VertexVarying.fragPosition.y/7.15);

        let frameMap = textureSample(splitTexture_Map,splitTexture_MapSampler,screenUV);
        // let noesMap = textureSample(noes_Map,noes_MapSampler,screenUV);

        ORI_ShadingInput.BaseColor = vec4<f32>( frameMap.rgb , 1.0) ;
        UnLit();
    }
`
    );

    let Hair_shader_op = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        useShadow();

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`
    );
    let Hair_shader_tr = (
      /*wgsl*/
      `
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`
    );

    let OutlinePass = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;


    struct MaterialUniform {
        baseColor:vec4<f32>,
        lineWeight:f32
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(vertex:VertexAttributes) -> VertexOutput {
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

                #if USE_MORPHTARGETS
                    vertexPosition = vertexPosition * morphTargetData.morphBaseInfluence + vertex.a_morphPositions_0 * morphTargetData.morphInfluence0;
                    #if USE_MORPHNORMALS
                        vertexNormal = vertexNormal * morphTargetData.morphBaseInfluence + vertex.a_morphNormals_0 * morphTargetData.morphInfluence0;
                    #endif
                #endif

                #if USE_SKELETON
                    #if USE_JOINT_VEC8
                        let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #else
                        let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                        ORI_MATRIX_M *= skeletonNormal ;
                        // vertexNormal = vec4<f32>(vec4<f32>(vertexNormal,0.0) * skeletonNormal).xyz; 
                    #endif
                #endif


                #if USE_TANGENT
                    ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
                #endif

                ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));

                let worldNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

                vertexPosition = vertexPosition + worldNormal * materialUniform.lineWeight ;

                var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
                var viewPosition = ORI_MATRIX_V * worldPos;
                var clipPosition = ORI_MATRIX_P * viewPosition ;

                ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
                ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
                ORI_VertexOut.varying_ViewPos = viewPosition / viewPosition.w;
                ORI_VertexOut.varying_Clip = clipPosition ;
                ORI_VertexOut.varying_WPos = worldPos ;
                ORI_VertexOut.varying_WPos.w = f32(vertex.index);
                ORI_VertexOut.varying_WNormal = worldNormal ;
                ORI_VertexOut.member = clipPosition ;


        return ORI_VertexOut ;
    }

    fn frag(){
        let color = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0) ;
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = 0.5  ;
        ORI_ShadingInput.Metallic = 0.5 ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);
        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;
        UnLit();
    }
`
    );

    let PBRLitSSSShader = (
      /*wgsl*/
      `
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        useShadow();

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity / LUMEN)  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`
    );

    let PavementShader = (
      /*wgsl*/
      `
        #include "Common_vert"
        #include "Common_frag"
        #include "BxDF_frag"

        @group(1) @binding(auto)
        var rtColorTex: texture_2d<f32>;

        @group(1) @binding(auto)
        var baseMapSampler: sampler;
        @group(1) @binding(auto)
        var baseMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var normalMapSampler: sampler;
        @group(1) @binding(auto)
        var normalMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var displaceMapSampler: sampler;
        @group(1) @binding(auto)
        var displaceMap: texture_2d<f32>;

        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
 
        @group(1) @binding(auto)
        var reflectMapSampler: sampler;
        @group(1) @binding(auto)
        var reflectMap: texture_2d<f32>;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            // let displaceDimensions = textureDimensions(displaceMap) ;
            // let displace = textureGather(0,displaceMap,displaceMapSampler,inputData.uv) ;
            // ORI_VertexOut.member.y += displace.r * 10.0;
            return ORI_VertexOut ;
        }

        fn frag(){
            var screenUV = ORI_VertexVarying.fragPosition.xy / ORI_VertexVarying.fragPosition.w;
            screenUV = (screenUV.xy + 1.0) * 0.5;
            screenUV.y = 1.0 - screenUV.y;

            let FrameMap = textureSample(rtColorTex,baseMapSampler,screenUV);

            let Albedo = textureSample(baseMap,baseMapSampler,ORI_VertexVarying.fragUV0);
            var Normal = textureSample(normalMap,normalMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            Normal.y = 1.0 - Normal.y ;
            let Displace = textureSample(displaceMap,displaceMapSampler,ORI_VertexVarying.fragUV0).rgb ;
            let Ao = textureSample(aoMap,aoMapSampler,ORI_VertexVarying.fragUV0).r ;
            let ReflectMap = 1.0 - textureSample(reflectMap,reflectMapSampler,ORI_VertexVarying.fragUV0).r ;

            ORI_ShadingInput.BaseColor = FrameMap * materialUniform.baseColor * vec4<f32>(LinearToGammaSpace(Albedo.rgb),1.0);
            ORI_ShadingInput.Roughness = ReflectMap * materialUniform.roughness  ;
            ORI_ShadingInput.Metallic = materialUniform.metallic ;
            ORI_ShadingInput.Specular = 0.5 ;
            ORI_ShadingInput.AmbientOcclusion = Ao;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

            let normal = unPackRGNormal(Normal,Displace.r*materialUniform.normalScale,1.0) ;
            ORI_ShadingInput.Normal = normal ;

            BxDFShading();
        }
    `
    );

    let PointShadowDebug = (
      /*wgsl*/
      `
        #include "Common_vert"
        #include "Common_frag"
        #include "UnLit_frag"

        @group(1) @binding(auto) var pointShadowMapSampler: sampler;
        @group(1) @binding(auto) var pointShadowMap: texture_depth_cube ;

        struct MaterialUniform {
            center: vec3<f32>,
        };
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;

        fn vert(inputData:VertexAttributes) -> VertexOutput {
            ORI_Vert(inputData) ;
            return ORI_VertexOut ;
        }
 
        fn frag(){

            var center = materialUniform.center ; 

            var dir = normalize(ORI_VertexVarying.vWorldPos.xyz - center) ;
            var depth = textureSample(pointShadowMap,pointShadowMapSampler,dir.xyz) ;
            depth = depth * globalUniform.far ;

            ORI_ShadingInput.BaseColor = vec4<f32>(depth*255.0,0.0,0.0,1.0)  ;
            UnLit();
        }
    `
    );

    let UnLitTextureArray = (
      /*wgsl*/
      `
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy;
        //The fragUV1.x is 1.0 when the vertex belongs to line.
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            uv = graphicNode.uvRect2.zw * uv.xy + graphicNode.uvRect2.xy;
            uv += graphicNode.uvSpeed.zw * globalUniform.time;
        }else{
            uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy;
            uv += graphicNode.uvSpeed.xy * globalUniform.time;
            let rad = graphicNode.fillRotation;
            if(rad != 0.0){
                let zrot = mat3x3<f32>(
                    cos(rad),-sin(rad),0.0,
                    sin(rad), cos(rad),0.0,
                    0.0,0.0,1.0
                );
                uv = (zrot * vec3f(uv, 0.0)).xy;
            }
        }
        var graphicTextureID = graphicNode.texIndex;
        var graphicNodeColor = graphicNode.baseColor;
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            graphicTextureID = graphicNode.tex2Index;
            graphicNodeColor = graphicNode.lineColor;
        }
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicTextureID)) ) * materialUniform.baseColor * graphicNodeColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < 0.5){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`
    );

    let MaterialUniform = (
      /*wgsl*/
      `
    struct MaterialUniform{
       #if USE_BRDF
        #include "PhysicMaterialUniform_frag"
       #endif

       #if USE_ColorLit
       #endif

       #if USE_UnLit
       #endif
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;
`
    );

    let FXAAShader = (
      /*wgsl*/
      `
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        return textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`
    );

    let GlobalFog_shader = (
      /* wgsl */
      `
var<private> PI: f32 = 3.14159265359;

struct FragmentOutput {
    @location(auto) o_Target: vec4<f32>
};

${GlobalUniform}

#include "FastMathShader" 
 
struct LightData {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,
    
    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:i32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct UniformData {
    fogColor : vec4<f32>,
    fogType : f32 ,
    fogHeightScale : f32 , 
    start: f32,
    end: f32,
    density : f32 ,
    ins : f32 ,
    falloff : f32 ,
    rayLength : f32 ,
    scatteringExponent : f32 ,
    dirHeightLine : f32 ,
    skyFactor: f32,
    skyRoughness: f32,
    overrideSkyFactor: f32,
    isSkyHDR: f32
};

@group(1) @binding(0)
var positionMapSampler: sampler;
@group(1) @binding(1)
var positionMap: texture_2d<f32>;

@group(1) @binding(2)
var colorMapSampler: sampler;
@group(1) @binding(3)
var colorMap: texture_2d<f32>;

@group(1) @binding(4)
var normalMapSampler: sampler;
@group(1) @binding(5)
var normalMap: texture_2d<f32>;

@group(1) @binding(6)
var prefilterMapSampler: sampler;
@group(1) @binding(7)
var prefilterMap: texture_cube<f32>;


@group(2) @binding(0)
var<uniform> global : UniformData;
var<private> varying_uv: vec2<f32>;

@group(2) @binding(1)
var<storage,read> lightBuffer: array<LightData>;

var<private> texPosition: vec4<f32>;
var<private> texNormal: vec4<f32>;
var<private> texColor: vec4<f32>;

fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32>
{
    var linRGB1 = max(linRGB, vec3<f32>(0.0));
    linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
    return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
}

fn getSkyColor(worldPosition:vec3<f32>, skyRoughness:f32, isHDRTexture:bool) -> vec3<f32>
{
    let cameraPosition = vec3<f32>(globalUniform.cameraWorldMatrix[3].xyz);
    let rayDirection = normalize(vec3<f32>(worldPosition.xyz - cameraPosition));
    let calcRoughness = clamp(skyRoughness, 0.0, 1.0);
    let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
    var prefilterColor = textureSampleLevel(prefilterMap, prefilterMapSampler, rayDirection, calcRoughness * MAX_REFLECTION_LOD);
    if(isHDRTexture){
        prefilterColor = vec4<f32>(LinearToGammaSpace(vec3<f32>(prefilterColor.xyz)), prefilterColor.w);
    }
    return prefilterColor.xyz * globalUniform.skyExposure;
}

@fragment
fn main(@location(auto) fragUV: vec2<f32>, @builtin(position) coord: vec4<f32>) -> FragmentOutput {
    var texCoord = vec2<f32>(fragUV.x, 1.0 - fragUV.y);
    texPosition = textureSample(positionMap, positionMapSampler, texCoord) ;
    texNormal = textureSample(normalMap, normalMapSampler, texCoord) ;
    texColor = textureSample(colorMap, colorMapSampler, texCoord) ;
  
    var opColor = vec3<f32>(0.0);
    if(texNormal.w <= 0.5){
        //for sky
        if(global.overrideSkyFactor > 0.01){
            opColor = blendSkyColor();
        }else{
            opColor = texColor.xyz;
        }
    }else{
        //for ground
        var fogFactor = calcFogFactor();
        if(global.skyFactor > 0.01 || global.overrideSkyFactor > 0.01){
            opColor = blendGroundColor(fogFactor);
        }else{
            opColor = mix(texColor.rgb, global.fogColor.xyz, fogFactor);
        }

        let sunLight = lightBuffer[0] ;
        var inScatteringValue = inScatterIng(sunLight.direction, texPosition.xyz, sunLight.lightColor);
        opColor += inScatteringValue;
    }
    return FragmentOutput(vec4<f32>(opColor.xyz, texColor.a));
}

fn calcFogFactor() -> f32 
{
    var cameraPos = globalUniform.cameraWorldMatrix[3].xyz  ;
    let dis = distance(cameraPos, texPosition.xyz);
    var heightFactor = computeFog(dis) + cFog(-texPosition.y);
    return clamp(global.ins * heightFactor,0.0,1.0);
}

    
fn blendGroundColor(fogFactor:f32) -> vec3<f32>
{
    var skyColorBlur = getSkyColor(texPosition.xyz, global.skyRoughness, global.isSkyHDR > 0.5);
    let skyFactor = clamp(global.skyFactor - global.overrideSkyFactor * 0.5, 0.0, 1.0);
    var fogColor = mix(global.fogColor.xyz, skyColorBlur, skyFactor);
    return mix(texColor.rgb, fogColor.rgb, fogFactor);
}

fn blendSkyColor() -> vec3<f32>
{
    let overrideSkyFactor = sqrt(global.overrideSkyFactor);
    var skyColorBlur = getSkyColor(texPosition.xyz, overrideSkyFactor * 0.3, global.isSkyHDR > 0.5);
    return mix(global.fogColor.xyz, skyColorBlur, 1.0 - overrideSkyFactor);
}


fn computeFog(z:f32) -> f32 
{
    var fog = 0.0;
    if( global.fogType < 0.5 ){
        fog = (global.end - z) / (global.end - global.start);
    }else if(global.fogType < 1.5 ){
        fog = exp2(-global.density * z);
    }else if(global.fogType == 2.5 ){
        fog = global.density * z;
        fog = exp2(-fog * fog);
    }
    return max(fog,0.0);
}

  fn cFog(y:f32) -> f32 
  {
     let fogDensity = global.density * exp(global.fogHeightScale * y);
     let fogFactor = (1.0 - exp2(-global.falloff)) / global.falloff ;
     let fog = fogDensity * fogFactor * max(global.rayLength - global.start, 0.0); 
     return max(fog,0.0);
  }

  fn inScatterIng(sunDir:vec3<f32>, worldPos:vec3<f32>, sunColor:vec3<f32>) -> vec3<f32> 
  {
    let viewDir = normalize(globalUniform.CameraPos.xyz - worldPos.xyz) ;
    let VoL = saturate(dot(viewDir,sunDir)) ;
    var scatter = pow(VoL,global.scatteringExponent);
    scatter *= (1.0-saturate(exp2(-global.dirHeightLine)));
    return vec3<f32>(scatter*sunColor);
  }

`
    );

    class AtmosphericScatteringSky_shader {
      static cs = (
        /* wgsl */
        `
    #include 'ColorUtil'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = saturate((1.0 - phaseTheta) * setting.sunRadius);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `
      );
    }

    class AtmosphericScatteringSkySetting {
      sunRadius = 500;
      sunRadiance = 11;
      mieG = 0.76;
      mieHeight = 1200;
      eyePos = 1500;
      sunX = 0.71;
      sunY = 0.56;
      sunBrightness = 1;
      displaySun = true;
      defaultTextureCubeSize = 512;
      defaultTexture2DSize = 1024;
      skyColor = new Color(1, 1, 1, 1);
    }
    class AtmosphericScatteringSky extends LDRTextureCube {
      _internalTexture;
      _cubeSize;
      setting;
      /**
       * @constructor
       * @param setting AtmosphericScatteringSkySetting
       * @returns
       */
      constructor(setting) {
        super();
        this.setting = setting;
        this._cubeSize = setting.defaultTextureCubeSize;
        this._internalTexture = new AtmosphericTexture2D(setting.defaultTexture2DSize, setting.defaultTexture2DSize * 0.5);
        this._internalTexture.update(this.setting);
        this.createFromTexture(this._cubeSize, this._internalTexture);
        return this;
      }
      get texture2D() {
        return this._internalTexture;
      }
      /**
       * @internal
       * @returns
       */
      apply() {
        this._internalTexture.update(this.setting);
        this._faceData.uploadErpTexture(this._internalTexture);
        return this;
      }
    }
    class AtmosphericTexture2D extends VirtualTexture {
      _computeShader;
      _uniformBuffer;
      constructor(width, height) {
        super(width, height, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        this.initCompute(width, height);
      }
      initCompute(w, h) {
        this._uniformBuffer = new UniformGPUBuffer(16 * 4);
        this._uniformBuffer.apply();
        this._computeShader = new ComputeShader(AtmosphericScatteringSky_shader.cs);
        this._computeShader.setUniformBuffer("uniformBuffer", this._uniformBuffer);
        this._computeShader.setStorageTexture(`outTexture`, this);
        this._computeShader.workerSizeX = w / 8;
        this._computeShader.workerSizeY = h / 8;
      }
      update(setting) {
        this._uniformBuffer.setFloat("width", this.width);
        this._uniformBuffer.setFloat("height", this.height);
        this._uniformBuffer.setFloat("sunU", setting.sunX);
        this._uniformBuffer.setFloat("sunV", setting.sunY);
        this._uniformBuffer.setFloat("eyePos", setting.eyePos);
        this._uniformBuffer.setFloat("sunRadius", setting.sunRadius);
        this._uniformBuffer.setFloat("sunRadiance", setting.sunRadiance);
        this._uniformBuffer.setFloat("mieG", setting.mieG);
        this._uniformBuffer.setFloat("mieHeight", setting.mieHeight);
        this._uniformBuffer.setFloat("sunBrightness", setting.sunBrightness);
        this._uniformBuffer.setFloat("displaySun", setting.displaySun ? 1 : 0);
        this._uniformBuffer.setColor("skyColor", setting.skyColor);
        this._uniformBuffer.apply();
        let command = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(command, [this._computeShader]);
        GPUContext.endCommandEncoder(command);
        return this;
      }
    }

    var __defProp$c = Object.defineProperty;
    var __getOwnPropDesc$c = Object.getOwnPropertyDescriptor;
    var __decorateClass$c = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$c(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$c(target, key, result);
      return result;
    };
    exports.SkyShader = class SkyShader extends Shader {
      constructor() {
        super();
        let colorShader = new RenderShaderPass("sky_vs_frag_wgsl", "sky_fs_frag_wgsl");
        this.addRenderPass(colorShader);
        colorShader.setUniformVector3(`eyesPos`, new Vector3());
        colorShader.setUniformFloat(`exposure`, 1);
        colorShader.setUniformFloat(`roughness`, 0);
        let shaderState = colorShader.shaderState;
        shaderState.frontFace = `cw`;
        shaderState.cullMode = GPUCullMode.back;
        shaderState.depthWriteEnabled = false;
        shaderState.depthCompare = GPUCompareFunction.less;
      }
    };
    exports.SkyShader = __decorateClass$c([
      RegisterShader
    ], exports.SkyShader);

    class SkyMaterial extends Material {
      constructor() {
        super();
        this.shader = new exports.SkyShader();
        this.shader.setUniformVector3(`eyesPos`, new Vector3());
        this.shader.setUniformFloat(`exposure`, 1);
        this.shader.setUniformFloat(`roughness`, 0);
      }
      /**
       *  Set base map(main map)
       */
      set baseMap(texture) {
        this.setTexture(`baseMap`, texture);
        const key = "IS_HDR_SKY";
        let defaultShader = this._shader.getDefaultShaders()[0];
        if (defaultShader.defineValue[key] != texture?.isHDRTexture) {
          this._shader.setDefine(key, texture?.isHDRTexture ? true : false);
        }
      }
      /**
       * Get base map(main map)
      //  */
      get baseMap() {
        let defaultShader = this._shader.getDefaultColorShader();
        return defaultShader.getTexture(`baseMap`);
      }
      set envMap(texture) {
      }
      set shadowMap(texture) {
      }
      get exposure() {
        return Engine3D.setting.sky.skyExposure;
      }
      set exposure(value) {
        Engine3D.setting.sky.skyExposure = value;
      }
      get roughness() {
        let defaultShader = this._shader.getDefaultColorShader();
        return defaultShader.uniforms[`roughness`].value;
      }
      set roughness(value) {
        let defaultShader = this._shader.getDefaultColorShader();
        if (`roughness` in defaultShader.uniforms)
          defaultShader.uniforms[`roughness`].value = value;
      }
    }

    class SphereGeometry extends GeometryBase {
      shape_vertices = [];
      shape_indices = [];
      /**
       * radius of sphere
       */
      radius;
      /**
       * Define the number of horizontal segments
       */
      widthSegments;
      /**
       * Define the number of vertical segments
       */
      heightSegments;
      /**
       * The starting point radian of the equatorial line of a sphere
       */
      phiStart;
      /**
       * The arc length of the equatorial line of a sphere
       */
      phiLength;
      /**
       * The radian of the starting point of the sphere's meridian
       */
      thetaStart;
      /**
       * Arc length of sphere meridian
       */
      thetaLength;
      /**
       *
       * @constructor
       * @param radius radius of sphere
       * @param widthSegments Define the number of horizontal segments
       * @param heightSegments Define the number of vertical segments
       * @param phiStart  The starting point radian of the equatorial line of a sphere
       * @param phiLength The arc length of the equatorial line of a sphere
       * @param thetaStart The radian of the starting point of the sphere's meridian
       * @param thetaLength Arc length of sphere meridian
       */
      constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        super();
        this.radius = radius;
        this.widthSegments = widthSegments;
        this.heightSegments = heightSegments;
        this.phiStart = phiStart;
        this.phiLength = phiLength;
        this.thetaStart = thetaStart;
        this.thetaLength = thetaLength;
        this.buildGeometry();
      }
      buildGeometry() {
        var i, j, triIndex = 0;
        let _segmentsH = this.heightSegments;
        let _segmentsW = this.widthSegments;
        let _radius = this.radius;
        var vertexCount = (_segmentsH + 1) * (_segmentsW + 1);
        let position_arr = new Float32Array(vertexCount * 3);
        let normal_arr = new Float32Array(vertexCount * 3);
        let uv_arr = new Float32Array(vertexCount * 2);
        let indice_arr = new Uint16Array(_segmentsW * _segmentsH * 2 * 3);
        let pi = 0;
        let ni = 0;
        let ui = 0;
        for (j = 0; j <= _segmentsH; ++j) {
          var horAngle = Math.PI * j / _segmentsH;
          var z = -_radius * Math.cos(horAngle);
          var ringRadius = _radius * Math.sin(horAngle);
          for (i = 0; i <= _segmentsW; ++i) {
            var verAngle = 2 * Math.PI * i / _segmentsW;
            var x = ringRadius * Math.cos(verAngle);
            var y = ringRadius * Math.sin(verAngle);
            var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
            position_arr[pi++] = x;
            position_arr[pi++] = y;
            position_arr[pi++] = z;
            normal_arr[ni++] = x * normLen;
            normal_arr[ni++] = y * normLen;
            normal_arr[ni++] = z * normLen;
            uv_arr[ui++] = i / _segmentsW;
            uv_arr[ui++] = 1 - j / _segmentsH;
            if (i > 0 && j > 0) {
              var a = (_segmentsW + 1) * j + i;
              var b = (_segmentsW + 1) * j + i - 1;
              var c = (_segmentsW + 1) * (j - 1) + i - 1;
              var d = (_segmentsW + 1) * (j - 1) + i;
              if (j == _segmentsH) {
                indice_arr[triIndex++] = a;
                indice_arr[triIndex++] = c;
                indice_arr[triIndex++] = d;
              } else if (j == 1) {
                indice_arr[triIndex++] = a;
                indice_arr[triIndex++] = b;
                indice_arr[triIndex++] = c;
              } else {
                indice_arr[triIndex++] = a;
                indice_arr[triIndex++] = b;
                indice_arr[triIndex++] = c;
                indice_arr[triIndex++] = a;
                indice_arr[triIndex++] = c;
                indice_arr[triIndex++] = d;
              }
            }
          }
        }
        this.setIndices(indice_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indice_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
        this.bounds = new BoundingBox(Vector3.ZERO, new Vector3(this.radius * 2, this.radius * 2, this.radius * 2));
      }
    }

    class SkyRenderer extends exports.MeshRenderer {
      /**
       * The material used in the Sky Box.
       */
      skyMaterial;
      init() {
        super.init();
        this.castShadow = false;
        this.castGI = true;
        this.addRendererMask(RendererMask.Sky);
        this.alwaysRender = true;
        this.object3D.bound = new BoundingBox(Vector3.ZERO.clone(), Vector3.MAX);
        this.geometry = new SphereGeometry(Engine3D.setting.sky.defaultFar, 20, 20);
        this.skyMaterial ||= new SkyMaterial();
      }
      onEnable() {
        if (!this._readyPipeline) {
          this.initPipeline();
        } else {
          this.castNeedPass();
          if (!this._inRenderer && this.transform.scene3D) {
            EntityCollect.instance.sky = this;
            this._inRenderer = true;
          }
        }
      }
      onDisable() {
        if (this._inRenderer && this.transform.scene3D) {
          this._inRenderer = false;
          EntityCollect.instance.sky = null;
        }
        super.onDisable();
      }
      renderPass2(view, passType, rendererPassState, clusterLightingBuffer, encoder, useBundle = false) {
        super.renderPass2(view, passType, rendererPassState, clusterLightingBuffer, encoder, useBundle);
      }
      /**
       * set environment texture
       */
      set map(texture) {
        this.skyMaterial.baseMap = texture;
        if (this.skyMaterial.name == null) {
          this.skyMaterial.name = "skyMaterial";
        }
        this.material = this.skyMaterial;
      }
      /**
       * get environment texture
       */
      get map() {
        return this.skyMaterial.baseMap;
      }
      get exposure() {
        return this.skyMaterial.exposure;
      }
      set exposure(value) {
        if (this.skyMaterial)
          this.skyMaterial.exposure = value;
      }
      get roughness() {
        return this.skyMaterial.roughness;
      }
      set roughness(value) {
        if (this.skyMaterial)
          this.skyMaterial.roughness = value;
      }
    }

    class HistoryData {
      rotateX;
      rotateY;
      sunX;
      sunY;
      constructor() {
        this.reset();
      }
      reset() {
        this.rotateX = this.rotateY = this.sunX = this.sunY = Number.MAX_VALUE;
        return this;
      }
      isRotateChange(rx, ry) {
        return Math.abs(this.rotateX - rx) >= 1e-3 || Math.abs(this.rotateY - ry) >= 1e-3;
      }
      isSkyChange(x, y) {
        return Math.abs(this.sunX - x) >= 1e-3 || Math.abs(this.sunY - y) >= 1e-3;
      }
      save(x, y, rx, ry) {
        this.sunX = x;
        this.sunY = y;
        this.rotateX = rx;
        this.rotateY = ry;
        return this;
      }
    }
    class AtmosphericComponent extends SkyRenderer {
      _atmosphericScatteringSky;
      _onChange = true;
      _relatedTransform;
      _historyData;
      get sunX() {
        return this._atmosphericScatteringSky.setting.sunX;
      }
      set sunX(value) {
        if (this._atmosphericScatteringSky.setting.sunX != value) {
          this._atmosphericScatteringSky.setting.sunX = value;
          this._onChange = true;
        }
      }
      get sunY() {
        return this._atmosphericScatteringSky.setting.sunY;
      }
      set sunY(value) {
        if (this._atmosphericScatteringSky.setting.sunY != value) {
          this._atmosphericScatteringSky.setting.sunY = value;
          this._onChange = true;
        }
      }
      get eyePos() {
        return this._atmosphericScatteringSky.setting.eyePos;
      }
      set eyePos(value) {
        if (this._atmosphericScatteringSky.setting.eyePos != value) {
          this._atmosphericScatteringSky.setting.eyePos = value;
          this._onChange = true;
        }
      }
      get sunRadius() {
        return this._atmosphericScatteringSky.setting.sunRadius;
      }
      set sunRadius(value) {
        if (this._atmosphericScatteringSky.setting.sunRadius != value) {
          this._atmosphericScatteringSky.setting.sunRadius = value;
          this._onChange = true;
        }
      }
      get sunRadiance() {
        return this._atmosphericScatteringSky.setting.sunRadiance;
      }
      set sunRadiance(value) {
        if (this._atmosphericScatteringSky.setting.sunRadiance != value) {
          this._atmosphericScatteringSky.setting.sunRadiance = value;
          this._onChange = true;
        }
      }
      get sunBrightness() {
        return this._atmosphericScatteringSky.setting.sunBrightness;
      }
      set sunBrightness(value) {
        if (this._atmosphericScatteringSky.setting.sunBrightness != value) {
          this._atmosphericScatteringSky.setting.sunBrightness = value;
          this._onChange = true;
        }
      }
      get displaySun() {
        return this._atmosphericScatteringSky.setting.displaySun;
      }
      set displaySun(value) {
        if (this._atmosphericScatteringSky.setting.displaySun != value) {
          this._atmosphericScatteringSky.setting.displaySun = value;
          this._onChange = true;
        }
      }
      init() {
        super.init();
        this._historyData = new HistoryData();
        this._atmosphericScatteringSky = new AtmosphericScatteringSky(new AtmosphericScatteringSkySetting());
        let view3D = this.transform.view3D;
        let scene = this.transform.scene3D;
        this.map = this._atmosphericScatteringSky;
        scene.envMap = this._atmosphericScatteringSky;
        this.onUpdate(view3D);
      }
      start(view) {
        let scene = this.transform.scene3D;
        this.map = this._atmosphericScatteringSky;
        scene.envMap = this._atmosphericScatteringSky;
        super.start();
      }
      get relativeTransform() {
        return this._relatedTransform;
      }
      set relativeTransform(value) {
        this._relatedTransform = value;
        this._historyData.reset();
      }
      onUpdate(view) {
        if (this._relatedTransform) {
          this._relatedTransform.rotationZ = 0;
          if (this._historyData.isRotateChange(this._relatedTransform.rotationX, this._relatedTransform.rotationY)) {
            this.sunX = (this._relatedTransform.rotationY + 90) / 360;
            this.sunY = this._relatedTransform.rotationX / 180 + 0.5;
          } else if (this._historyData.isSkyChange(this.sunX, this.sunY)) {
            this._relatedTransform.rotationY = this.sunX * 360 - 90;
            this._relatedTransform.rotationX = (this.sunY - 0.5) * 180;
          }
          this._historyData.save(this.sunX, this.sunY, this._relatedTransform.rotationX, this._relatedTransform.rotationY);
        }
        if (this._onChange) {
          this._onChange = false;
          this._atmosphericScatteringSky.apply();
        }
      }
      destroy(force) {
        super.destroy(force);
        this._atmosphericScatteringSky.destroy();
        this._atmosphericScatteringSky = null;
        this._onChange = null;
      }
    }

    class GUIConfig {
      static panelRatio = 1;
      static quadMaxCountForWorld = 256;
      static quadMaxCountForView = 2048;
      static SortOrderStartWorld = 7e3;
      static SortOrderStartView = 8e3;
      static SortOrderCanvasSpan = 1e4;
    }
    var GUISpace = /* @__PURE__ */ ((GUISpace2) => {
      GUISpace2[GUISpace2["View"] = 0] = "View";
      GUISpace2[GUISpace2["World"] = 2] = "World";
      return GUISpace2;
    })(GUISpace || {});
    var ImageType = /* @__PURE__ */ ((ImageType2) => {
      ImageType2[ImageType2["Simple"] = 0] = "Simple";
      ImageType2[ImageType2["Sliced"] = 1] = "Sliced";
      ImageType2[ImageType2["Tiled"] = 2] = "Tiled";
      ImageType2[ImageType2["Filled"] = 3] = "Filled";
      return ImageType2;
    })(ImageType || {});
    var BillboardType = /* @__PURE__ */ ((BillboardType2) => {
      BillboardType2[BillboardType2["None"] = 0] = "None";
      BillboardType2[BillboardType2["BillboardY"] = 9] = "BillboardY";
      BillboardType2[BillboardType2["BillboardXYZ"] = 10] = "BillboardXYZ";
      return BillboardType2;
    })(BillboardType || {});

    class BillboardComponent extends ComponentBase {
      type;
      camera;
      _cameraPosition;
      constructor() {
        super();
        this._cameraPosition = new Vector3();
      }
      onUpdate() {
        if (this.enable && this.transform.view3D.camera) {
          this.updateBillboardMatrix();
        }
      }
      updateBillboardMatrix() {
        let camera = this.transform.view3D.camera;
        this._cameraPosition.copyFrom(camera.transform.back);
        if (this.type == BillboardType.BillboardXYZ) ; else if (this.type == BillboardType.BillboardY) {
          this._cameraPosition.y = 0;
        }
        this._cameraPosition.normalize();
        this._cameraPosition.add(this.object3D.localPosition, this._cameraPosition);
        this.transform.lookAt(this.object3D.localPosition, this._cameraPosition, camera.transform.up);
      }
      cloneTo(obj) {
        let component = obj.addComponent(BillboardComponent);
        component.type = this.type;
      }
    }

    var ColliderShapeType = /* @__PURE__ */ ((ColliderShapeType2) => {
      ColliderShapeType2[ColliderShapeType2["None"] = 0] = "None";
      ColliderShapeType2[ColliderShapeType2["Box"] = 1] = "Box";
      ColliderShapeType2[ColliderShapeType2["Capsule"] = 2] = "Capsule";
      ColliderShapeType2[ColliderShapeType2["Sphere"] = 3] = "Sphere";
      ColliderShapeType2[ColliderShapeType2["Mesh"] = 4] = "Mesh";
      return ColliderShapeType2;
    })(ColliderShapeType || {});
    class ColliderShape {
      _center;
      _size;
      _halfSize;
      _shapeType = 0 /* None */;
      static v3_help_0;
      static helpMatrix;
      static helpRay;
      constructor() {
        ColliderShape.v3_help_0 ||= new Vector3();
        ColliderShape.helpMatrix ||= new Matrix4();
        ColliderShape.helpRay ||= new Ray();
        this._center = new Vector3();
        this._size = new Vector3();
        this._halfSize = new Vector3();
      }
      get shapeType() {
        return this._shapeType;
      }
      /**
       * Set the position and size of collision objects
       * @param ct The position of the collision object in the local space of the object.
       * @param sz The size of the collision body in the X, Y, and Z directions.
       * @returns
       */
      setFromCenterAndSize(ct, sz) {
        ct && this._center.copy(ct);
        sz && this._size.copy(sz);
        return this;
      }
      /**
       * The position of the collision object in the local space of the object.
       */
      get center() {
        return this._center;
      }
      set center(value) {
        this._center.copy(value);
      }
      /**
       *
       * The size of the collision body in the X, Y, and Z directions.
       * @returns Vector3
       */
      get size() {
        return this._size;
      }
      set size(value) {
        this._size.copy(value);
        this._halfSize.copy(value).multiplyScalar(0.5);
      }
      /**
       * Half the size of the collision body.
       */
      get halfSize() {
        return this._halfSize;
      }
      /**
       * Ray pickup.Emit a ray from a designated location to detect objects colliding with the ray.
       * @param ray emit ray
       * @param fromMatrix matrix
       * @returns Pick result intersect: whether to collide;
       *  IntersectPoint: collision point;
       *  Distance: The distance from the origin of the ray to the collision point.
       */
      rayPick(ray, fromMatrix) {
        return null;
      }
    }

    class BoxColliderShape extends ColliderShape {
      _pickRet;
      box;
      /**
       * @constructor
       */
      constructor() {
        super();
        this._shapeType = ColliderShapeType.Box;
        this.box = new BoundingBox(new Vector3(), new Vector3());
      }
      /**
       * @internal
       * @param ray 
       * @param fromMatrix 
       * @returns 
       */
      rayPick(ray, fromMatrix) {
        let box = this.box;
        box.setFromCenterAndSize(this.center, this.size);
        let helpMatrix = ColliderShape.helpMatrix;
        helpMatrix.copyFrom(fromMatrix).invert();
        let helpRay = ColliderShape.helpRay.copy(ray);
        helpRay.applyMatrix(helpMatrix);
        let pick = helpRay.intersectBox(this.box, ColliderShape.v3_help_0);
        if (pick) {
          if (!this._pickRet) {
            this._pickRet = { intersectPoint: new Vector3(), distance: 0 };
          }
          this._pickRet.intersectPoint = pick;
          this._pickRet.distance = Vector3.distance(helpRay.origin, ColliderShape.v3_help_0);
          return this._pickRet;
        }
        return null;
      }
    }

    class ColliderComponent extends ComponentBase {
      _shape;
      constructor() {
        super();
        this._shape = new BoxColliderShape();
      }
      /**
       * @internal
       */
      start() {
        if (Engine3D.setting.pick.mode == `pixel`) {
          this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index, this);
        }
      }
      onEnable(view) {
        ComponentCollect.bindEnablePick(view, this, null);
      }
      onDisable(view) {
        ComponentCollect.unBindEnablePick(view, this);
      }
      /**
       * Returns the shape of collider
       */
      get shape() {
        return this._shape;
      }
      /**
       * Set the shape of collider
       */
      set shape(value) {
        this._shape = value;
      }
      /**
       * @internal
       * @param ray
       * @returns
       */
      rayPick(ray) {
        if (this._enable) {
          return this._shape.rayPick(ray, this.transform.worldMatrix);
        }
        return null;
      }
      beforeDestroy(force) {
        if (Engine3D.setting.pick.mode == `pixel`) {
          this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index);
        }
        super.beforeDestroy(force);
      }
    }

    var __defProp$b = Object.defineProperty;
    var __getOwnPropDesc$b = Object.getOwnPropertyDescriptor;
    var __decorateClass$b = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$b(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$b(target, key, result);
      return result;
    };
    exports.AnimatorComponent = class AnimatorComponent extends ComponentBase {
      jointMatrixIndexTableBuffer;
      playBlendShapeLoop = false;
      inverseBindMatrices;
      _avatar;
      _rendererList;
      propertyCache;
      _clips;
      _clipsMap;
      _currentSkeletonClip;
      _currentBlendAnimClip;
      _skeletonTime = 0;
      _blendShapeTime = 0;
      _skeletonSpeed = 1;
      _blendShapeSpeed = 1;
      _skeletonStart = true;
      _blendShapeStart = true;
      root;
      _avatarName;
      init(param) {
        this.propertyCache = /* @__PURE__ */ new Map();
        this._clipsMap = /* @__PURE__ */ new Map();
        this._clips = [];
      }
      start() {
        this._rendererList = this.object3D.getComponentsInChild(exports.SkinnedMeshRenderer2);
      }
      debug() {
      }
      playAnim(anim, time = 0, speed = 1) {
        if (this._clipsMap.has(anim)) {
          this._currentSkeletonClip = this._clipsMap.get(anim);
          this._skeletonTime = time;
          this._skeletonSpeed = speed;
          this._skeletonStart = true;
        } else {
          console.warn(`not has anim ${anim}`);
        }
      }
      playBlendShape(shapeName, time = 0, speed = 1) {
        if (this._clipsMap.has(shapeName)) {
          this._currentBlendAnimClip = this._clipsMap.get(shapeName);
          this._blendShapeTime = time;
          this._blendShapeSpeed = speed;
          this._blendShapeStart = true;
        } else {
          console.warn(`not has blendShape ${shapeName}`);
        }
      }
      set avatar(name) {
        this._avatarName = name;
        this.inverseBindMatrices = [];
        this._avatar = Engine3D.res.getObj(name);
        let jointMapping = this.buildSkeletonPose();
        const jointMatrixIndexTable = new Float32Array(jointMapping);
        this.jointMatrixIndexTableBuffer = new StorageGPUBuffer(this._avatar.count, 0, jointMatrixIndexTable);
      }
      getJointIndexTable(skinJointsName) {
        let result = new Array();
        for (let i = 0; i < skinJointsName.length; i++) {
          let joint = this._avatar.boneMap.get(skinJointsName[i]);
          result[i] = joint ? joint.boneID : -1;
        }
        return result;
      }
      skeltonPoseObject3D = {};
      skeltonTPoseObject3D = {};
      buildSkeletonPose() {
        let list = [];
        for (const joint of this._avatar.boneData) {
          let obj = new exports.Object3D();
          Matrix4.getEuler(Vector3.HELP_6, joint.q, true, "ZYX");
          obj.localPosition = joint.t.clone();
          obj.localRotation = Vector3.HELP_6.clone();
          obj.localScale = Vector3.ONE;
          joint.s.clone();
          this.skeltonPoseObject3D[joint.boneName] = obj;
          this.skeltonTPoseObject3D[joint.bonePath] = obj.clone();
          if (joint.parentBoneName && joint.parentBoneName != "") {
            this.skeltonPoseObject3D[joint.parentBoneName].addChild(obj);
          } else {
            if (this.object3D.transform.scene3D) {
              this.object3D.transform.scene3D.addChild(obj);
            }
            this.root = obj;
          }
          list.push(obj.transform.worldMatrix.index);
          let local = new Matrix4();
          local.copyFrom(obj.transform.worldMatrix);
          local.invert();
          this.inverseBindMatrices.push(local.rawData);
        }
        return list;
      }
      set clips(clips) {
        this._clips = clips;
        for (const clip of clips) {
          this._clipsMap.set(clip.clipName, clip);
        }
      }
      get clips() {
        return this._clips;
      }
      cloneTo(obj) {
        let animatorComponent = obj.addComponent(exports.AnimatorComponent);
        animatorComponent.avatar = this._avatarName;
        animatorComponent.clips = this._clips;
      }
      updateTime() {
        if (this._skeletonStart) {
          this._skeletonTime += Time.delta * 1e-3 * this._skeletonSpeed;
          if (this._currentSkeletonClip && this._currentSkeletonClip.loopTime) {
            this._skeletonTime = this._skeletonTime % this._currentSkeletonClip.stopTime;
          }
        }
        if (this._blendShapeStart) {
          this._blendShapeTime += Time.delta * 1e-3 * this._blendShapeSpeed;
          if (this._currentBlendAnimClip) {
            if (this._currentBlendAnimClip.loopTime && this.playBlendShapeLoop) {
              this._blendShapeTime = this._blendShapeTime % this._currentBlendAnimClip.stopTime;
            } else {
              this._blendShapeTime = Math.min(this._blendShapeTime, this._currentBlendAnimClip.stopTime) - 1e-4;
            }
          }
        }
      }
      onUpdate(view) {
        this.transform.worldMatrix;
        this.updateTime();
        this.updateSkeletonAnim();
        this.updateMorphAnim();
      }
      updateSkeletonAnim() {
        if (this._currentSkeletonClip) {
          let joints = this._avatar.boneData;
          let i = 0;
          let len = joints.length;
          for (i = 0; i < len; i++) {
            const joint = joints[i];
            let obj = this.skeltonPoseObject3D[joint.boneName];
            if (this._currentSkeletonClip.useSkeletonPos) {
              let pos = this.getPosition(joint.bonePath, this._skeletonTime);
              obj.transform.localPosition = pos;
            }
            let rot = this.getRotation(joint.bonePath, this._skeletonTime);
            obj.transform.localRotation = rot;
            if (this._currentSkeletonClip.useSkeletonScale) {
              let scale = this.getScale(joint.bonePath, this._skeletonTime);
              obj.transform.localScale = scale;
            }
          }
        }
      }
      updateMorphAnim() {
        if (this._currentBlendAnimClip && this._currentBlendAnimClip.floatCurves) {
          if (this._currentBlendAnimClip.floatCurves.size > 0 && this._rendererList) {
            for (const iterator of this._currentBlendAnimClip.floatCurves) {
              let key = iterator[0];
              let curve = iterator[1];
              let attributes = curve.propertys;
              let x = this._currentBlendAnimClip.floatCurves.get(key).getValue(this._blendShapeTime);
              let value = x / 100;
              for (const renderer of this._rendererList) {
                if (renderer.blendShape) {
                  let property = this.propertyCache.get(renderer);
                  if (property && key in property) {
                    property[key](value);
                  } else {
                    property = renderer;
                    for (const att of attributes) {
                      if (!property[att])
                        break;
                      property = property[att];
                    }
                    if (!property || property == renderer)
                      break;
                    if (!this.propertyCache.get(renderer))
                      this.propertyCache.set(renderer, {});
                    this.propertyCache.get(renderer)[key] = property;
                    property(value);
                  }
                }
              }
            }
          }
        }
      }
      updateBlendShape(attributes, key, value) {
        for (const renderer of this._rendererList) {
          if (renderer.blendShape) {
            let property = this.propertyCache.get(renderer);
            if (property && key in property) {
              property[key](value);
            } else {
              property = renderer;
              for (const att of attributes) {
                if (!property[att])
                  break;
                property = property[att];
              }
              if (!property || property == renderer)
                break;
              if (!this.propertyCache.get(renderer))
                this.propertyCache.set(renderer, {});
              this.propertyCache.get(renderer)[key] = property;
              property(value);
            }
          }
        }
      }
      getPosition(boneName, time) {
        if (this._currentSkeletonClip.positionCurves.has(boneName)) {
          let t = this._currentSkeletonClip.positionCurves.get(boneName).getValue(time);
          return t;
        }
        return this.skeltonTPoseObject3D[boneName].localPosition;
      }
      getRotation(boneName, time) {
        if (this._currentSkeletonClip.rotationCurves.has(boneName)) {
          let v4 = this._currentSkeletonClip.rotationCurves.get(boneName).getValue(time);
          Quaternion.HELP_2.set(v4.x, v4.y, v4.z, v4.w);
          Matrix4.getEuler(Vector3.HELP_6, Quaternion.HELP_2, true, "ZYX");
          return Vector3.HELP_6;
        }
        return this.skeltonTPoseObject3D[boneName].localRotation;
      }
      getScale(boneName, time) {
        if (this._currentSkeletonClip.scaleCurves.has(boneName)) {
          let x = this._currentSkeletonClip.scaleCurves.get(boneName).getValue(time);
          return x;
        }
        return this.skeltonTPoseObject3D[boneName].localScale;
      }
      getFloat(propertyName, time) {
        let x = this._currentSkeletonClip.floatCurves.get(propertyName).getValue(time);
        return x;
      }
    };
    exports.AnimatorComponent = __decorateClass$b([
      RegisterComponent(exports.AnimatorComponent, "AnimatorComponent")
    ], exports.AnimatorComponent);

    class FrameCache {
      index;
      //= lhsIndex;
      time;
      // = lhs.time + timeOffset;
      timeEnd;
      // = rhs.time + timeOffset;
      coeff = [];
      //= lhsIndex;
    }

    var WrapTimeMode = /* @__PURE__ */ ((WrapTimeMode2) => {
      WrapTimeMode2[WrapTimeMode2["PingPong"] = 0] = "PingPong";
      WrapTimeMode2[WrapTimeMode2["Repeat"] = 1] = "Repeat";
      WrapTimeMode2[WrapTimeMode2["Clamp"] = 2] = "Clamp";
      return WrapTimeMode2;
    })(WrapTimeMode || {});

    class Keyframe {
      serializedVersion = "2";
      time;
      value;
      inSlope = 0;
      outSlope = 0;
      tangentMode = 0;
      weightedMode = 0;
      inWeight;
      outWeight;
      constructor(time = 0, value = 0) {
        this.time = time;
        this.value = value;
      }
      unSerialized(data) {
        this.serializedVersion = data["serializedVersion"];
        this.time = data["time"];
        this.value = data["value"];
        this.tangentMode = data["tangentMode"];
        this.inSlope = data["inSlope"] == "Infinity" ? NaN : data["inSlope"];
        this.outSlope = data["outSlope"] == "Infinity" ? NaN : data["outSlope"];
      }
      unSerialized2(data) {
        this.serializedVersion = data["serializedVersion"];
        this.time = data["time"];
        this.value = data["value"];
        this.tangentMode = data["tangentMode"];
        this.inSlope = data["inTangent"] == "Infinity" ? NaN : data["inTangent"];
        this.outSlope = data["outTangent"] == "Infinity" ? NaN : data["outTangent"];
      }
    }

    class AnimationCurve {
      _totalTime = 1;
      _cache = new FrameCache();
      _cacheOut = {
        lhsIndex: 0,
        rhsIndex: 0
      };
      _InvalidateCache = false;
      curve = [];
      serializedVersion;
      preWarpMode;
      postWarpMode;
      rotationOrder;
      constructor(frames, preWarpMode = WrapTimeMode.Repeat, postWarpMode = WrapTimeMode.Repeat) {
        if (frames)
          for (let i = 0; i < frames.length; i++) {
            const frame = frames[i];
            this.addKeyFrame(frame);
          }
        this.preWarpMode = preWarpMode;
        this.postWarpMode = postWarpMode;
      }
      /**
       * return this curve use total time
       */
      get totalTime() {
        return this._totalTime;
      }
      /**
       * get curve first keframe time
       */
      get first() {
        return this.curve[0];
      }
      /**
       * get curve last keyframe time
       */
      get last() {
        return this.curve[this.curve.length - 1];
      }
      /**
       * add keyFrame to curve keyframe last and calcTotalTime
       * @param keyFrame {@link Keyframe}  sea: one key frame data
       */
      addKeyFrame(keyFrame) {
        if (this.curve.indexOf(keyFrame) == -1) {
          this.curve.push(keyFrame);
        }
        this.calcTotalTime();
      }
      /**
       * remove keyframe from this curve
       * @param keyFrame {@link Keyframe} 
       */
      removeKeyFrame(keyFrame) {
        let index = this.curve.indexOf(keyFrame);
        if (index != -1) {
          this.curve.splice(index, 1);
        }
        this.calcTotalTime();
      }
      /**
       * calculate keyframe list in to timeline
       * @param cache {@link FrameCache} 
       * @param lhsIndex left frame index 
       * @param rhsIndex right frame index
       * @param timeOffset offset time default 0.0
       */
      calculateCacheData(cache, lhsIndex, rhsIndex, timeOffset = 0) {
        let m_Curve = this.curve;
        let lhs = m_Curve[lhsIndex];
        let rhs = m_Curve[rhsIndex];
        cache.index = lhsIndex;
        cache.time = lhs.time + timeOffset;
        cache.timeEnd = rhs.time + timeOffset;
        cache.index = lhsIndex;
        let dx, length;
        let dy;
        let m1, m2, d1, d2;
        dx = rhs.time - lhs.time;
        dx = Math.max(dx, 1e-4);
        dy = rhs.value - lhs.value;
        length = 1 / (dx * dx);
        m1 = lhs.outSlope;
        m2 = rhs.inSlope;
        d1 = m1 * dx;
        d2 = m2 * dx;
        cache.coeff[0] = (d1 + d2 - dy - dy) * length / dx;
        cache.coeff[1] = (dy + dy + dy - d1 - d1 - d2) * length;
        cache.coeff[2] = m1;
        cache.coeff[3] = lhs.value;
        this.setupStepped(cache.coeff, lhs, rhs);
      }
      /**
       * get caculate frames value 
       * @param time 
       * @returns 
       */
      getValue(time) {
        time = this.wrapTime(time);
        this.findCurve(time, this._cacheOut);
        this.calculateCacheData(this._cache, this._cacheOut.lhsIndex, this._cacheOut.rhsIndex, 0);
        return this.evaluateCache(this._cache, time);
      }
      /**
       * get has Keyframe list count
       * @returns  int 
       */
      getKeyCount() {
        return this.curve.length;
      }
      /**
       * Get a Keyframe Data by Index
       * @param index must int 
       * @returns Keyframe {@link Keyframe}
       */
      getKey(index) {
        return this.curve[index];
      }
      unSerialized(data) {
        this.preWarpMode = data["m_PreInfinity"];
        this.postWarpMode = data["m_PostInfinity"];
        this.rotationOrder = data["m_RotationOrder"];
        let len = data["m_Curve"].length;
        for (let i = 0; i < len; i++) {
          this.curve[i] = new Keyframe();
          this.curve[i].unSerialized(data["m_Curve"][i.toString()]);
        }
        this.calcTotalTime();
        return this;
      }
      unSerialized2(data) {
        this.preWarpMode = data["preWrapMode"];
        this.postWarpMode = data["postWrapMode"];
        let keyFrames = data["keyFrames"] || data["keys"];
        let len = keyFrames.length;
        for (let i = 0; i < len; i++) {
          this.curve[i] = new Keyframe();
          this.curve[i].unSerialized2(keyFrames[i.toString()]);
        }
        this.calcTotalTime();
        return this;
      }
      wrapTime(curveT) {
        let m_Curve = this.curve;
        let begTime = m_Curve[0].time;
        let endTime = m_Curve[m_Curve.length - 1].time;
        if (curveT < begTime) {
          if (this.preWarpMode == WrapTimeMode.Clamp)
            curveT = begTime;
          else if (this.preWarpMode == WrapTimeMode.PingPong)
            curveT = PingPong(curveT, begTime, endTime);
          else
            curveT = RepeatSE(curveT, begTime, endTime);
        } else if (curveT > endTime) {
          if (this.postWarpMode == WrapTimeMode.Clamp)
            curveT = endTime;
          else if (this.postWarpMode == WrapTimeMode.PingPong)
            curveT = PingPong(curveT, begTime, endTime);
          else
            curveT = RepeatSE(curveT, begTime, endTime);
        }
        return curveT;
      }
      evaluateCache(cache, curveT) {
        let t = curveT - cache.time;
        let output = t * (t * (t * cache.coeff[0] + cache.coeff[1]) + cache.coeff[2]) + cache.coeff[3];
        return output;
      }
      findCurve(time, out) {
        let frames = this.curve;
        for (let i = 1; i < frames.length; i++) {
          let left = frames[i - 1];
          let right = frames[i];
          if (left.time <= time && right.time > time) {
            out.lhsIndex = i - 1;
            out.rhsIndex = i;
          }
        }
      }
      setupStepped(coeff, lhs, rhs) {
        if (isNaN(lhs.outSlope) || isNaN(rhs.inSlope)) {
          coeff[0] = 0;
          coeff[1] = 0;
          coeff[2] = 0;
          coeff[3] = lhs.value;
        }
      }
      invalidateCache() {
        this._InvalidateCache = true;
      }
      calcTotalTime() {
        let maxTime = 0;
        for (let curve of this.curve) {
          if (curve) {
            maxTime = Math.max(maxTime, curve.time);
          } else {
            console.error(curve);
          }
        }
        this._totalTime = maxTime;
      }
      static scaleCurveValue(curve, scale) {
        if (!curve._InvalidateCache) {
          for (let i = 0; i < curve.curve.length; i++) {
            let c = curve.curve[i];
            c.value *= scale;
            c.inSlope *= scale;
            c.outSlope *= scale;
          }
        }
        curve.invalidateCache();
      }
    }

    class AttributeAnimCurve extends AnimationCurve {
      attribute = "";
      propertyList;
      path;
      constructor() {
        super();
      }
      unSerialized(data) {
        let { attribute, path } = data;
        this.attribute = attribute;
        this.path = path;
        this.propertyList = attribute.split(".");
        super.unSerialized(data.curve);
        return this;
      }
    }

    class ObjectAnimClip {
      curve = {};
    }
    var WrapMode = /* @__PURE__ */ ((WrapMode2) => {
      WrapMode2[WrapMode2["Default"] = 0] = "Default";
      WrapMode2[WrapMode2["Clamp"] = 1] = "Clamp";
      WrapMode2[WrapMode2["Once"] = 1] = "Once";
      WrapMode2[WrapMode2["Loop"] = 2] = "Loop";
      WrapMode2[WrapMode2["PingPong"] = 4] = "PingPong";
      WrapMode2[WrapMode2["ClampForever"] = 8] = "ClampForever";
      return WrapMode2;
    })(WrapMode || {});
    class PropertyAnimClip {
      name;
      objAnimClip;
      totalTime = 0;
      time = 0;
      // private _startTime: number = 0;
      _stopTime = 0;
      _loopTime;
      _wrapMode;
      _sampleRate;
      get wrapMode() {
        if (!this._wrapMode)
          this._wrapMode = 0 /* Default */;
        return this._wrapMode;
      }
      set wrapMode(value) {
        this._wrapMode = value;
      }
      parse(jsonData) {
        this.objAnimClip = {};
        let clip = jsonData["AnimationClip"];
        let { m_Name, m_AnimationClipSettings, m_WrapMode, m_SampleRate } = clip;
        this.name = m_Name;
        this._wrapMode = m_WrapMode;
        this._sampleRate = m_SampleRate;
        this._loopTime = m_AnimationClipSettings.m_LoopTime;
        for (const key in clip.m_EditorCurves) {
          if (Object.prototype.hasOwnProperty.call(clip.m_EditorCurves, key)) {
            const curve = clip.m_EditorCurves[key];
            let attribute = curve.attribute;
            let attributeAnimCurve = new AttributeAnimCurve();
            attributeAnimCurve.unSerialized(curve);
            this.totalTime = Math.max(this.totalTime, attributeAnimCurve.totalTime);
            let objClip = this.objAnimClip[curve.path];
            if (!objClip) {
              objClip = new ObjectAnimClip();
              this.objAnimClip[curve.path] = objClip;
            }
            objClip.curve[attribute] = attributeAnimCurve;
          }
        }
      }
    }

    class PropertyAnimTag {
      transform;
      quaternion;
      materialColor;
    }
    class PropertyHelp {
      static Property = {
        "m_LocalPosition.x": "localPosition.x",
        "m_LocalPosition.y": "localPosition.y",
        "m_LocalPosition.z": "localPosition.z",
        "m_LocalRotation.x": "localQuaternion.x",
        "m_LocalRotation.y": "localQuaternion.y",
        "m_LocalRotation.z": "localQuaternion.z",
        "m_LocalRotation.w": "localQuaternion.w",
        "localEulerAnglesRaw.x": "localRotation.x",
        "localEulerAnglesRaw.y": "localRotation.y",
        "localEulerAnglesRaw.z": "localRotation.z",
        "m_LocalEulerAngles.x": "localRotation.x",
        "m_LocalEulerAngles.y": "localRotation.y",
        "m_LocalEulerAngles.z": "localRotation.z",
        "m_LocalScale.x": "localScale.x",
        "m_LocalScale.y": "localScale.y",
        "m_LocalScale.z": "localScale.z",
        "m_Color.r": "materialColor.r",
        "m_Color.g": "materialColor.g",
        "m_Color.b": "materialColor.b",
        "m_Color.a": "materialColor.a",
        "material._Color.r": "materialColor.r",
        "material._Color.g": "materialColor.g",
        "material._Color.b": "materialColor.b",
        "material._Color.a": "materialColor.a",
        "material._UnlitColor.r": "materialColor.r",
        "material._UnlitColor.g": "materialColor.g",
        "material._UnlitColor.b": "materialColor.b",
        "material._UnlitColor.a": "materialColor.a",
        "field of view": "camera3D.fov",
        m_IsActive: "active",
        m_Sprite: "sprite",
        m_FlipX: "flipX",
        m_FlipY: "flipY"
      };
      static Scale = {
        "m_LocalPosition.x": 1,
        "m_LocalPosition.y": 1,
        "m_LocalPosition.z": -1,
        "localEulerAnglesRaw.x": -1,
        //Deg2Rad(1),
        "localEulerAnglesRaw.y": 1,
        //Deg2Rad(1),
        "localEulerAnglesRaw.z": 1,
        //Deg2Rad(1),
        "m_LocalEulerAngles.x": -1,
        //Deg2Rad(1),
        "m_LocalEulerAngles.y": 1,
        //Deg2Rad(1),
        "m_LocalEulerAngles.z": 1,
        //Deg2Rad(1),
        "m_LocalRotation.x": 1,
        //Rad2Deg(1),
        "m_LocalRotation.y": 1,
        //Rad2Deg(1),
        "m_LocalRotation.z": -1,
        //Rad2Deg(1),
        "m_LocalRotation.w": -1,
        //Rad2Deg(1),
        "field of view": 1,
        m_IsActive: 1,
        m_Sprite: 1
      };
      static updatePropertyTag(tag, attribute) {
        tag.quaternion ||= this.tag_quaternion[attribute];
        tag.transform ||= this.tag_transform[attribute];
        tag.materialColor ||= this.tag_materialColor[attribute];
      }
      static tag_quaternion = {
        "m_LocalRotation.x": true,
        "m_LocalRotation.y": true,
        "m_LocalRotation.z": true,
        "m_LocalRotation.w": true
      };
      static tag_materialColor = {
        "material._Color.r": true,
        "material._Color.g": true,
        "material._Color.b": true,
        "material._Color.a": true,
        "material._UnlitColor.r": true,
        "material._UnlitColor.g": true,
        "material._UnlitColor.b": true,
        "material._UnlitColor.a": true
      };
      static tag_transform = {
        "m_LocalPosition.x": true,
        "m_LocalPosition.y": true,
        "m_LocalPosition.z": true,
        "m_LocalRotation.x": true,
        "m_LocalRotation.y": true,
        "m_LocalRotation.z": true,
        "m_LocalRotation.w": true,
        "localEulerAnglesRaw.x": true,
        "localEulerAnglesRaw.y": true,
        "localEulerAnglesRaw.z": true,
        "m_LocalEulerAngles.x": true,
        "m_LocalEulerAngles.y": true,
        "m_LocalEulerAngles.z": true,
        "m_LocalScale.x": true,
        "m_LocalScale.y": true,
        "m_LocalScale.z": true
      };
    }

    class AnimationMonitor {
      static Complete = 0;
      static Seek = 1;
      _rootObject3D;
      _animation;
      _propertyCache;
      _currentClip;
      _frame = 0;
      _time = 0;
      _isPlaying = true;
      speed = 1;
      _propertyTagDic;
      constructor(animation) {
        this._rootObject3D = animation.object3D;
        this._animation = animation;
        this._propertyTagDic = /* @__PURE__ */ new Map();
        this.reset();
      }
      reset() {
        this._propertyCache = {};
        this._propertyTagDic.clear();
      }
      get time() {
        return this._time;
      }
      get currentClip() {
        return this._currentClip;
      }
      play(clip, reset = true) {
        this._isPlaying = true;
        if (reset) {
          this._time = 0;
        }
        if (clip != this._currentClip) {
          if (clip) {
            this.parseAnimClip(clip);
          }
        }
        this._currentClip = clip;
        this.validProperty();
      }
      parseAnimClip(clip) {
        this.reset();
        for (const objPath in clip.objAnimClip) {
          let objClip = clip.objAnimClip[objPath];
          let bindObject3D = this._rootObject3D;
          let attsCache = {};
          if (objPath == "") {
            bindObject3D = this._rootObject3D;
          } else {
            bindObject3D = this._rootObject3D.getObjectByName(objPath);
          }
          if (!bindObject3D)
            continue;
          let tag = new PropertyAnimTag();
          this._propertyTagDic.set(bindObject3D, tag);
          let curve = objClip.curve;
          for (const attribute in curve) {
            PropertyHelp.updatePropertyTag(tag, attribute);
            let binder = this._propertyCache[objPath] ||= {};
            let atts = PropertyHelp.Property[attribute].split(".");
            let atts_0 = atts[0];
            if (atts.length > 1) {
              let value = attsCache[atts_0];
              if (!value) {
                value = attsCache[atts_0] = bindObject3D[atts_0];
              }
              binder[attribute] = { value, property: atts[1] };
            } else {
              binder[attribute] = { value: bindObject3D, property: atts[0] };
            }
          }
        }
        return this;
      }
      stop() {
        this._isPlaying = false;
        return this;
      }
      toggle() {
        this._isPlaying = !this._isPlaying;
        return this;
      }
      get isPlaying() {
        return this._isPlaying;
      }
      update(time, delta) {
        time = time * 1e-3;
        delta = delta * 1e-3;
        if (!this._currentClip || this._frame == time)
          return;
        if (!this._isPlaying)
          return;
        this._frame = time;
        let lastTime = this._time;
        this._time = this.calcTime(lastTime + delta * this.speed);
        this.validProperty();
        if (this._currentClip.wrapMode != WrapMode.Loop && this._currentClip.wrapMode != WrapMode.Default) {
          let complete = this.speed > 0 ? this._time >= this._currentClip.totalTime : this._time <= 0;
          if (complete) {
            this._isPlaying = false;
            this._animation["statusCall"](AnimationMonitor.Complete, lastTime, this._time);
          }
        }
        this._animation["statusCall"](AnimationMonitor.Seek, lastTime, this._time);
      }
      seek(time) {
        this._time = this.calcTime(time);
        this._rootObject3D && this.validProperty();
        return this;
      }
      calcTime(time) {
        if (this._currentClip.wrapMode == WrapMode.Loop || this._currentClip.wrapMode == WrapMode.Default) {
          time = repeat(time, this._currentClip.totalTime);
        } else {
          time = clamp(time, 0, this._currentClip.totalTime);
        }
        return time;
      }
      validProperty() {
        for (const objName in this._currentClip.objAnimClip) {
          let objClip = this._currentClip.objAnimClip[objName];
          let curve = objClip.curve;
          for (const attribute in curve) {
            const attributeAnim = curve[attribute];
            let target = this._propertyCache[objName][attribute];
            let ret = attributeAnim.getValue(this._time);
            if (attribute in PropertyHelp.Scale) {
              ret *= PropertyHelp.Scale[attribute];
            }
            target.value[target.property] = ret;
          }
        }
        this._propertyTagDic.forEach((v, k) => {
          this.applyProperty(v, k);
        });
      }
      applyProperty(tag, obj3d) {
        if (tag.quaternion) {
          Matrix4.getEuler(obj3d.transform.localRotation, obj3d.transform.localRotQuat, true, "ZYX");
        }
        if (tag.transform) {
          obj3d.transform.localPosition = obj3d.transform.localPosition;
          obj3d.transform.localRotation = obj3d.transform.localRotation;
          obj3d.transform.localScale = obj3d.transform.localScale;
        }
        let animObj = obj3d;
        if (tag.materialColor) {
          animObj.notifyMaterialColorChange(0, "baseColor");
        }
      }
    }

    class AnimatorEventKeyframe {
      clipName;
      data;
      time;
    }
    class PropertyAnimationEvent extends CEvent {
      static SEEK = "SEEK";
      static COMPLETE = "COMPLETE";
      animation;
      frame;
      constructor(animation, name) {
        super(name);
        this.animation = animation;
      }
    }

    class PropertyAnimation extends ComponentBase {
      _animator;
      _clips = [];
      /**
       * name of default animation clip
       */
      defaultClip;
      /**
       * is it play auto
       */
      autoPlay;
      _seekEvent;
      _completeEvent;
      _keyFrameList;
      constructor() {
        super();
        this._seekEvent = new PropertyAnimationEvent(this, PropertyAnimationEvent.SEEK);
        this._completeEvent = new PropertyAnimationEvent(this, PropertyAnimationEvent.COMPLETE);
        this._keyFrameList = {};
      }
      /**
       * register a event to animator
       * @param frame source AnimatorEventKeyframe
       */
      registerEventKeyFrame(frame) {
        let list = this._keyFrameList[frame.clipName];
        if (list == null) {
          this._keyFrameList[frame.clipName] = list = [];
        }
        list.push(frame);
      }
      /**
       * @internal
       */
      init() {
        this._animator = new AnimationMonitor(this);
      }
      /**
       * @internal
       */
      onUpdate() {
        if (this.enable) {
          this._animator.update(Time.time, Time.delta);
        }
      }
      /**
       * append a perperty animation clip
       * @param clip source PropertyAnimClip
       */
      appendClip(clip) {
        this._clips.push(clip);
        this.play(clip.name);
      }
      statusCall(tag, last, now) {
        if (tag == AnimationMonitor.Complete) {
          this.eventDispatcher.dispatchEvent(this._completeEvent);
        } else if (tag == AnimationMonitor.Seek) {
          if (last != now) {
            let frames = this._keyFrameList[this.currentClip.name];
            if (frames) {
              for (let frame of frames) {
                if (frame.time > last && frame.time <= now) {
                  this._seekEvent.data = this._seekEvent.frame = frame;
                  this.eventDispatcher.dispatchEvent(this._seekEvent);
                }
              }
            }
          }
        }
      }
      /**
       * set playing speed
       */
      set speed(value) {
        this._animator.speed = value;
      }
      /**
       * get playing speed
       */
      get speed() {
        return this._animator.speed;
      }
      /**
       * stop playing
       */
      stop() {
        this._animator.stop();
      }
      /**
       * stop or resume playing
       */
      toggle() {
        this._animator.toggle();
      }
      /**
       * get animation clip by clip name
       * @param clip name of PropertyAnimClip
       * @returns 
       */
      getClip(name) {
        let clip;
        for (let item of this._clips) {
          if (item.name == name) {
            clip = item;
            break;
          }
        }
        return clip;
      }
      /**
       * get animation clip which is playing now
       */
      get currentClip() {
        return this._animator.currentClip;
      }
      /**
       * get time of current animator
       */
      get time() {
        return this._animator.time;
      }
      /**
       * seek the animation to assign time
       * @param time assign time
       */
      seek(time) {
        this._animator.seek(time);
      }
      /**
       * play animation by given name
       * @param name animation name
       * @param reset if true, play the animation from time 0
       * @returns 
       */
      play(name, reset = true) {
        let clip = this.getClip(name);
        if (clip) {
          this._animator.play(clip, reset);
          return clip;
        }
        return null;
      }
      /**
       * @internal
       *
       */
      start() {
        if (this.autoPlay) {
          this.play(this.defaultClip);
        }
      }
      copyComponent(from) {
        this.autoPlay = from.autoPlay;
        this.defaultClip = from.defaultClip;
        let clips = from._clips;
        for (let i = 0, count = clips.length; i < count; i++) {
          this.appendClip(clips[i]);
        }
        return this;
      }
      /**
       * Create a new PropertyAnimation component, copy the properties of the current component, 
       * and add them to the target object.
       * @param obj target object3D
       */
      cloneTo(obj) {
        let animator = obj.addComponent(PropertyAnimation);
        animator.copyComponent(this);
      }
    }

    var __defProp$a = Object.defineProperty;
    var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
    var __decorateClass$a = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$a(target, key, result);
      return result;
    };
    exports.SkinnedMeshRenderer2 = class SkinnedMeshRenderer2 extends exports.MeshRenderer {
      skinJointsName;
      mInverseBindMatrixData;
      mInverseBindMatrixBuffer;
      mSkeletonAnimation;
      mJointIndexTableBuffer;
      constructor() {
        super();
        this.addRendererMask(RendererMask.SkinnedMesh);
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(value) {
        this.skinJointsName = value.skinNames;
        let matrixList = [];
        for (let i = 0; i < value.bindPose.length; i++) {
          matrixList.push(value.bindPose[i].rawData.slice(0, 16));
        }
        this.skinInverseBindMatrices = matrixList;
        super.geometry = value;
      }
      start() {
        super.start();
        this.skeletonAnimation = this.object3D.getComponent(exports.AnimatorComponent);
        if (!this.skeletonAnimation) {
          let comps = this.object3D.parentObject.parentObject.getComponentsInChild(exports.AnimatorComponent);
          if (comps.length > 0) {
            this.skeletonAnimation = comps[0];
          }
          let parentObj = this.object3D;
          while (!this.skeletonAnimation && parentObj) {
            this.skeletonAnimation = parentObj.getComponentFromParent(exports.AnimatorComponent);
            if (parentObj.parent) {
              parentObj = parentObj.parent.object3D;
            }
          }
        }
      }
      get blendShape() {
        return this.morphData;
      }
      onEnable() {
        super.onEnable();
      }
      get skeletonAnimation() {
        return this.mSkeletonAnimation;
      }
      set skeletonAnimation(value) {
        this.mSkeletonAnimation = value;
        if (!value) {
          return;
        }
        if (!this.mJointIndexTableBuffer) {
          let skinJointIndexData = this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);
          this.mJointIndexTableBuffer = new StorageGPUBuffer(skinJointIndexData.length, 0, new Float32Array(skinJointIndexData));
          this.mJointIndexTableBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
        }
      }
      get skinInverseBindMatrices() {
        return this.mInverseBindMatrixData;
      }
      set skinInverseBindMatrices(inverseBindMatrices) {
        this.mInverseBindMatrixData = inverseBindMatrices;
        var inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16);
        for (let i = 0; i < inverseBindMatrices.length; i++) {
          let index = i * 16;
          let mat4x4 = inverseBindMatrices[i];
          inverseBindMatricesData.set(mat4x4, index);
        }
        this.mInverseBindMatrixBuffer = new StorageGPUBuffer(inverseBindMatricesData.byteLength, 0, inverseBindMatricesData);
        this.mInverseBindMatrixBuffer.visibility = GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE;
      }
      get inverseBindMatrixBuffer() {
        return this.mInverseBindMatrixBuffer;
      }
      get jointIndexTableBuffer() {
        return this.mJointIndexTableBuffer.buffer;
      }
      cloneTo(obj) {
        let skinnedMesh = obj.addComponent(exports.SkinnedMeshRenderer2);
        let newMats = [];
        for (const mat of this.materials) {
          newMats.push(mat.clone());
        }
        skinnedMesh.materials = newMats;
        skinnedMesh.geometry = this.geometry;
        skinnedMesh.castShadow = this.castShadow;
        skinnedMesh.castGI = this.castGI;
        skinnedMesh.receiveShadow = this.receiveShadow;
        skinnedMesh.rendererMask = this.rendererMask;
        skinnedMesh.skinJointsName = this.skinJointsName;
        skinnedMesh.skinInverseBindMatrices = this.skinInverseBindMatrices;
        skinnedMesh.mJointIndexTableBuffer = this.mJointIndexTableBuffer;
      }
      /**
       * @internal
       * @param passType
       * @param renderPassState
       * @param scene3D
       * @param clusterLightingRender
       * @param probes
       */
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        for (let i = 0; i < this.materials.length; i++) {
          const material = this.materials[i];
          let passes = material.getPass(passType);
          if (passes)
            for (let i2 = 0; i2 < passes.length; i2++) {
              const renderShader = passes[i2];
              if (!renderShader.pipeline && this.mSkeletonAnimation) {
                renderShader.setStorageBuffer("jointsMatrixIndexTable", this.mSkeletonAnimation.jointMatrixIndexTableBuffer);
                renderShader.setStorageBuffer("jointsInverseMatrix", this.mInverseBindMatrixBuffer);
                renderShader.setStorageBuffer("jointsIndexMapingTable", this.mJointIndexTableBuffer);
              }
            }
        }
        super.nodeUpdate(view, passType, renderPassState, clusterLightingBuffer);
      }
    };
    exports.SkinnedMeshRenderer2 = __decorateClass$a([
      RegisterComponent(exports.SkinnedMeshRenderer2, "SkinnedMeshRenderer2")
    ], exports.SkinnedMeshRenderer2);

    class MorphTargetBlender extends ComponentBase {
      _targetRenderers = {};
      _vec3 = new Vector3();
      _matrix4 = new Matrix4();
      _quaternion = new Quaternion();
      init(param) {
        let meshRenders = this.fetchMorphRenderers(this.object3D, exports.SkinnedMeshRenderer2);
        let meshRenders2 = this.fetchMorphRenderers(this.object3D, exports.MeshRenderer);
        meshRenders.push(...meshRenders2);
        for (const renderer of meshRenders) {
          let hasMorphTarget = RendererMaskUtil.hasMask(renderer.rendererMask, RendererMask.MorphTarget);
          if (hasMorphTarget) {
            renderer.selfCloneMaterials("MORPH_TARGET_UUID");
          }
          for (const key in renderer.geometry.morphTargetDictionary) {
            let renderList = this._targetRenderers[key] || [];
            renderList.push(renderer);
            this._targetRenderers[key] = renderList;
          }
        }
      }
      getMorphRenderersByKey(key) {
        return this._targetRenderers[key];
      }
      cloneMorphRenderers() {
        let dst = {};
        for (let key in this._targetRenderers) {
          dst[key] = this._targetRenderers[key];
        }
        return dst;
      }
      /**
       * Inject arkit data into the model and let all meshRender below the node accept morph animation
       * @param frame: BlendShape data output from ARKit.
       * @param keyMapper: Table mapping the relationship between the model's modelKey and ARKit's output arkitKey: {modelKey: arkitKey}.
       * @param multiplier: Scaling factor for movement data.
       * @returns
       */
      applyBlendShape(frame, keyMapper, multiplier = 1) {
        if (!frame) {
          console.warn("blendShape is null");
          return;
        }
        this._vec3.setFromArray(frame.transform.transform[3]);
        this._vec3.multiplyScalar(multiplier);
        this.object3D.transform.localPosition = this._vec3;
        this._vec3.setFromArray(frame.transform.transform[2]);
        this._matrix4.copyColFrom(2, this._vec3);
        this._vec3.setFromArray(frame.transform.transform[1]);
        this._matrix4.copyColFrom(1, this._vec3);
        this._vec3.setFromArray(frame.transform.transform[0]);
        this._matrix4.copyColFrom(0, this._vec3);
        this._matrix4.transpose();
        this._quaternion.fromMatrix(this._matrix4);
        this.object3D.localQuaternion = this._quaternion;
        for (let keyInModel in keyMapper) {
          let renderList = this._targetRenderers[keyInModel];
          let stdKey = keyMapper[keyInModel];
          let influence = frame.texture[stdKey];
          this.applyMorphTargetInfluence(keyInModel, influence, renderList);
        }
      }
      applyMorphTargetInfluence(key, influence, rendererList) {
        for (let renderer of rendererList) {
          renderer.setMorphInfluence(key, influence);
        }
      }
      fetchMorphRenderers(obj, c) {
        let sourceRenders = obj.getComponentsInChild(c);
        let result = [];
        for (let renderer of sourceRenders) {
          if (renderer.hasMask(RendererMask.MorphTarget)) {
            result.push(renderer);
          }
        }
        return result;
      }
    }

    class MorphTargetFrame {
      texture;
      transform;
    }

    var MorphTargetTransformKey = /* @__PURE__ */ ((MorphTargetTransformKey2) => {
      MorphTargetTransformKey2["mouthRollLower"] = "mouthRollLower";
      MorphTargetTransformKey2["browOuterUp_L"] = "browOuterUpLeft";
      MorphTargetTransformKey2["mouthSmile_L"] = "mouthSmileLeft";
      MorphTargetTransformKey2["jawRight"] = "jawRight";
      MorphTargetTransformKey2["eyeLookOut_L"] = "eyeLookOutLeft";
      MorphTargetTransformKey2["mouthFunnel"] = "mouthFunnel";
      MorphTargetTransformKey2["mouthUpperUp_R"] = "mouthUpperUpRight";
      MorphTargetTransformKey2["browDown_L"] = "browDownLeft";
      MorphTargetTransformKey2["jawLeft"] = "jawLeft";
      MorphTargetTransformKey2["mouthLowerDown_L"] = "mouthLowerDownLeft";
      MorphTargetTransformKey2["noseSneer_R"] = "noseSneerRight";
      MorphTargetTransformKey2["jawForward"] = "jawForward";
      MorphTargetTransformKey2["mouthLowerDown_R"] = "mouthLowerDownRight";
      MorphTargetTransformKey2["browInnerUp"] = "browInnerUp";
      MorphTargetTransformKey2["mouthRollUpper"] = "mouthRollUpper";
      MorphTargetTransformKey2["mouthStretch_R"] = "mouthStretchRight";
      MorphTargetTransformKey2["mouthPucker"] = "mouthPucker";
      MorphTargetTransformKey2["eyeBlink_L"] = "eyeBlinkLeft";
      MorphTargetTransformKey2["mouthUpperUp_L"] = "mouthUpperUpLeft";
      MorphTargetTransformKey2["mouthShrugUpper"] = "mouthShrugUpper";
      MorphTargetTransformKey2["eyeLookIn_R"] = "eyeLookInRight";
      MorphTargetTransformKey2["noseSneer_L"] = "noseSneerLeft";
      MorphTargetTransformKey2["mouthFrown_L"] = "mouthFrownLeft";
      MorphTargetTransformKey2["cheekSquint_L"] = "cheekSquintLeft";
      MorphTargetTransformKey2["eyeLookDown_L"] = "eyeLookDownLeft";
      MorphTargetTransformKey2["mouthDimple_L"] = "mouthDimpleLeft";
      MorphTargetTransformKey2["mouthFrown_R"] = "mouthFrownRight";
      MorphTargetTransformKey2["eyeLookIn_L"] = "eyeLookInLeft";
      MorphTargetTransformKey2["eyeLookOut_R"] = "eyeLookOutRight";
      MorphTargetTransformKey2["mouthLeft"] = "mouthLeft";
      MorphTargetTransformKey2["mouthStretch_L"] = "mouthStretchLeft";
      MorphTargetTransformKey2["mouthPress_L"] = "mouthPressLeft";
      MorphTargetTransformKey2["mouthDimple_R"] = "mouthDimpleRight";
      MorphTargetTransformKey2["eyeWide_R"] = "eyeWideRight";
      MorphTargetTransformKey2["browDown_R"] = "browDownRight";
      MorphTargetTransformKey2["eyeLookUp_R"] = "eyeLookUpRight";
      MorphTargetTransformKey2["eyeBlink_R"] = "eyeBlinkRight";
      MorphTargetTransformKey2["cheekSquint_R"] = "cheekSquintRight";
      MorphTargetTransformKey2["mouthRight"] = "mouthDimpleRight";
      MorphTargetTransformKey2["eyeLookDown_R"] = "eyeLookDownRight";
      MorphTargetTransformKey2["eyeLookUp_L"] = "eyeLookUpLeft";
      MorphTargetTransformKey2["eyeSquint_L"] = "eyeSquintLeft";
      MorphTargetTransformKey2["jawOpen"] = "jawOpen";
      MorphTargetTransformKey2["browOuterUp_R"] = "browOuterUpRight";
      MorphTargetTransformKey2["mouthClose"] = "mouthClose";
      MorphTargetTransformKey2["mouthShrugLower"] = "mouthShrugLower";
      MorphTargetTransformKey2["eyeWide_L"] = "eyeWideLeft";
      MorphTargetTransformKey2["tongueOut"] = "tongueOut";
      MorphTargetTransformKey2["eyeSquint_R"] = "eyeSquintRight";
      MorphTargetTransformKey2["cheekPuff"] = "cheekPuff";
      MorphTargetTransformKey2["mouthPress_R"] = "mouthPressRight";
      MorphTargetTransformKey2["mouthSmile_R"] = "mouthSmileRight";
      return MorphTargetTransformKey2;
    })(MorphTargetTransformKey || {});

    class SkeletonAnimationCompute {
      _computePipeline;
      _computeBindGroup;
      constructor(computeShader, entries) {
        let device = webGPUContext.device;
        this._computePipeline = device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code: computeShader
            }),
            entryPoint: "CsMain"
          }
        });
        this._computeBindGroup = device.createBindGroup({
          layout: this._computePipeline.getBindGroupLayout(0),
          entries
        });
      }
      compute(command, workgroupCountX, workgroupCountY, workgroupCountZ) {
        let computePass = command.beginComputePass();
        computePass.setPipeline(this._computePipeline);
        computePass.setBindGroup(0, this._computeBindGroup);
        computePass.dispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
        computePass.end();
        return this;
      }
    }

    class SkeletonBlendComputeArgs extends MemoryDO {
      numJoint;
      numState;
      time;
      weight;
      argumentsData;
      _isDirty = false;
      _argumentsBuffer;
      _argumentsBufferEntries;
      constructor() {
        super();
        this.allocationMemorySet([
          { name: `numJoint`, data: [0] },
          { name: `numState`, data: [0] },
          { name: `retain1`, data: [0] },
          { name: `retain2`, data: [0] },
          { name: `time`, data: [0, 0] },
          { name: `weight`, data: [0, 0] }
        ]);
        this.generateGPUBuffer();
      }
      getGPUBuffer() {
        return this._argumentsBuffer;
      }
      getGPUBindGroupEntry() {
        return this._argumentsBufferEntries;
      }
      // public setNumJoint(value: number) {
      //     if (this.numJoint.bytes[0] != value) {
      //         this.numJoint.bytes[0] = value;
      //         this.isDirty = true;
      //     }
      // }
      // public setNumState(value: number) {
      //     if (this.numState.bytes[0] != value) {
      //         this.numState.bytes[0] = value;
      //         this.isDirty = true;
      //     }
      // }
      // public setTime(index: number, value: number) {
      //     if (this.time.bytes[index] != value) {
      //         this.time.bytes[index] = value;
      //         this.isDirty = true;
      //     }
      // }
      // public setWeight(index: number, value: number) {
      //     if (this.weight.bytes[index] != value) {
      //         this.weight.bytes[index] = value;
      //         this.isDirty = true;
      //     }
      // }
      updateGPUBuffer() {
        if (this._isDirty) {
          this._isDirty = false;
          webGPUContext.device.queue.writeBuffer(this._argumentsBuffer, 0, this.shareDataBuffer);
        }
        return this;
      }
      allocationMemorySet(dataDic) {
        this.argumentsData = {};
        let count = 0;
        for (let i = 0; i < dataDic.length; i++) {
          const element = dataDic[i];
          count += element.data.length;
        }
        this.allocation(count * 4);
        let self = this;
        for (let i = 0; i < dataDic.length; i++) {
          const element = dataDic[i];
          const key = element.name;
          this.argumentsData[key] = this.allocation_node(element.data.length * 4);
          self[key] = this.argumentsData[key];
        }
      }
      generateGPUBuffer() {
        let device = webGPUContext.device;
        this._argumentsBuffer = device.createBuffer({
          size: this.shareDataBuffer.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
          mappedAtCreation: false
        });
        this._argumentsBufferEntries = {
          binding: 0,
          resource: {
            buffer: this._argumentsBuffer,
            offset: 0,
            size: this.shareDataBuffer.byteLength
          }
        };
      }
    }

    class SkeletonTransformComputeArgs extends MemoryDO {
      numJoint;
      numFrame;
      retain0;
      retain1;
      argumentsData;
      _isDirty = false;
      _argumentsBuffer;
      _argumentsBufferEntries;
      constructor() {
        super();
        this.allocationMemorySet([
          { name: `numJoint`, data: [0] },
          { name: `numFrame`, data: [0] },
          { name: `retain0`, data: [0] },
          { name: `retain1`, data: [0] }
        ]);
        this.generateGPUBuffer();
      }
      getGPUBuffer() {
        return this._argumentsBuffer;
      }
      getGPUBindGroupEntry() {
        return this._argumentsBufferEntries;
      }
      // public setNumJoint(value: number) {
      //     if (this.numJoint.bytes[0] != value) {
      //         this.numJoint.bytes[0] = value;
      //         this.isDirty = true;
      //     }
      // }
      // public setNumFrame(value: number) {
      //     if (this.numFrame.bytes[0] != value) {
      //         this.numFrame.bytes[0] = value;
      //         this.isDirty = true;
      //     }
      // }
      updateGPUBuffer() {
        if (this._isDirty) {
          this._isDirty = false;
          webGPUContext.device.queue.writeBuffer(this._argumentsBuffer, 0, this.shareDataBuffer);
        }
      }
      allocationMemorySet(dataDic) {
        this.argumentsData = {};
        let count = 0;
        for (let i = 0; i < dataDic.length; i++) {
          const element = dataDic[i];
          count += element.data.length;
        }
        this.allocation(count * 4);
        let self = this;
        for (let i = 0; i < dataDic.length; i++) {
          const element = dataDic[i];
          const key = element.name;
          this.argumentsData[key] = this.allocation_node(element.data.length * 4);
          self[key] = this.argumentsData[key];
        }
      }
      generateGPUBuffer() {
        let device = webGPUContext.device;
        this._argumentsBuffer = device.createBuffer({
          size: this.shareDataBuffer.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
          mappedAtCreation: false
        });
        this._argumentsBufferEntries = {
          binding: 0,
          resource: {
            buffer: this._argumentsBuffer,
            offset: 0,
            size: this.shareDataBuffer.byteLength
          }
        };
      }
    }

    let compute_skeleton_blend = (
      /* wgsl */
      `
  ${MathShader}

  struct Arguments {
    numJoint: f32,
    numState: f32,
    retain1: f32,
    retain2: f32,
    time: vec2<f32>,
    weight: vec2<f32>,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsFinalMatrix: array<mat4x4<f32>>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let numState = i32(args.numState);
    let nJointIndex = i32(workgroup_id.x);

    jointsFinalMatrix[nJointIndex] = mixMatrix4x4(jointsWorldMatrix[0 * numJoint + nJointIndex], jointsWorldMatrix[1 * numJoint + nJointIndex], args.time[0]) * args.weight[0];

    for (var i = 1; i < numState; i++) {
      jointsFinalMatrix[nJointIndex] += mixMatrix4x4(jointsWorldMatrix[(i * 2 + 0) * numJoint + nJointIndex], jointsWorldMatrix[(i * 2 + 1) * numJoint + nJointIndex], args.time[i]) * args.weight[i];
    }
  }
`
    );

    let compute_skeleton_transform = (
      /* wgsl */
      `
  ${MathShader}

  struct Arguments {
    numJoint: f32,
    numFrame: f32,
    retain0: f32,
    retain1: f32,
  };

  struct JointData {
    scale: vec4<f32>,
    rotation: vec4<f32>,
    translation: vec4<f32>,
  };

  @group(0) @binding(0) var<storage, read_write> args: Arguments;
  @group(0) @binding(1) var<storage, read_write> jointsKeyframe: array<JointData>;
  @group(0) @binding(2) var<storage, read_write> jointsWorldMatrix: array<mat4x4<f32>>;
  @group(0) @binding(3) var<storage, read_write> jointsParentIndex: array<f32>;

  @compute @workgroup_size(1)
  fn CsMain(@builtin(workgroup_id) workgroup_id: vec3<u32>, @builtin(local_invocation_index) local_index: u32) {
    let numJoint = i32(args.numJoint);
    let nFrameIndex = i32(workgroup_id.x);
    for (var nJointIndex = 0; nJointIndex < numJoint; nJointIndex++) {
      let dataIndex = nFrameIndex * numJoint + nJointIndex;
      let joint = jointsKeyframe[dataIndex];
      let jointLocalMatrix = MakeMatrix4x4(joint.scale.xyz, joint.rotation, joint.translation.xyz);

      let nParentIndex = i32(jointsParentIndex[nJointIndex]);
      if (nParentIndex < 0) {
        jointsWorldMatrix[dataIndex] = jointLocalMatrix;
      } else {
        jointsWorldMatrix[dataIndex] = jointsWorldMatrix[nFrameIndex * numJoint + nParentIndex] * jointLocalMatrix;
      }
    }
  }
`
    );

    class CameraControllerBase {
      _autoUpdate = true;
      _target;
      _lookAtObject;
      _origin = new Vector3(0, 0, 0);
      _speed = 300;
      /**
       *
       * @constructor
       * @param targetObject control object3D
       * @param lookAtObject observational object3D
       */
      constructor(targetObject = null, lookAtObject = null) {
        this._target = targetObject;
        this._lookAtObject = lookAtObject;
      }
      /**
       *
       * Get the control object3D
       * @returns Object3D
       */
      get target() {
        return this._target;
      }
      /**
       *
       * Set the control object3D
       * @param val Object3D
       */
      set target(val) {
        if (this._target == val)
          return;
        this._target = val;
      }
      /**
       *
       * Get observational object3D
       * @returns Object3D
       */
      get lookAtObject() {
        return this._lookAtObject;
      }
      /**
       *
       * Set observational object3D
       * @param val Object3D
       */
      set lookAtObject(val) {
        if (this._lookAtObject == val)
          return;
        this._lookAtObject = val;
      }
      /**
       *
       * Get moving speed
       * @returns number
       * @version FlyEngine
       */
      get speed() {
        return this._speed;
      }
      /**
       *
       * Set moving speed
       * @returns number
       * @version FlyEngine
       */
      set speed(val) {
        this._speed = val;
      }
      /**
       * update(tick)
       */
      update() {
      }
    }

    class FirstPersonCameraController extends ComponentBase {
      focus;
      distance = 5;
      _camera;
      constructor() {
        super();
      }
      start() {
        this._camera = this.object3D.getOrAddComponent(Camera3D);
        if (!this._camera) {
          console.error("FirstPersonCameraController need camera");
          return;
        }
        if (!this.focus) {
          console.error("FirstPersonCameraController need target");
          return;
        }
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
      }
      mouseDown(e) {
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.mouseMove, this);
      }
      mouseUp(e) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_MOVE, this.mouseMove, this);
      }
      mouseMove(e) {
        let temp = this.transform.localRotation;
        temp.y += e.movementX * 0.01;
        temp.x += e.movementY * 0.01;
        this.transform.localRotation = temp;
      }
      mouseWheel(e) {
        this.distance += Engine3D.inputSystem.wheelDelta * 0.1;
      }
      onUpdate() {
        let vec = new Vector3();
        this._camera.transform.forward.scaleToRef(this.distance, vec);
        var focusPoint = this.focus.transform.worldPosition;
        this._camera.transform.localPosition = focusPoint;
      }
      destroy(force) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
        super.destroy(force);
      }
    }

    var KeyCode = /* @__PURE__ */ ((KeyCode2) => {
      KeyCode2[KeyCode2["Key_BackSpace"] = 8] = "Key_BackSpace";
      KeyCode2[KeyCode2["Key_Tab"] = 9] = "Key_Tab";
      KeyCode2[KeyCode2["Key_Clear"] = 12] = "Key_Clear";
      KeyCode2[KeyCode2["Key_Enter"] = 13] = "Key_Enter";
      KeyCode2[KeyCode2["Key_Shift_L"] = 16] = "Key_Shift_L";
      KeyCode2[KeyCode2["Key_Control_L"] = 17] = "Key_Control_L";
      KeyCode2[KeyCode2["Key_Alt_L"] = 18] = "Key_Alt_L";
      KeyCode2[KeyCode2["Key_Pause"] = 19] = "Key_Pause";
      KeyCode2[KeyCode2["Key_CapsLock"] = 20] = "Key_CapsLock";
      KeyCode2[KeyCode2["Key_Escape"] = 21] = "Key_Escape";
      KeyCode2[KeyCode2["Key_Esc"] = 27] = "Key_Esc";
      KeyCode2[KeyCode2["Key_Space"] = 32] = "Key_Space";
      KeyCode2[KeyCode2["Key_Prior"] = 33] = "Key_Prior";
      KeyCode2[KeyCode2["Key_Next"] = 34] = "Key_Next";
      KeyCode2[KeyCode2["Key_End"] = 35] = "Key_End";
      KeyCode2[KeyCode2["Key_Home"] = 36] = "Key_Home";
      KeyCode2[KeyCode2["Key_Left"] = 37] = "Key_Left";
      KeyCode2[KeyCode2["Key_Up"] = 38] = "Key_Up";
      KeyCode2[KeyCode2["Key_Right"] = 39] = "Key_Right";
      KeyCode2[KeyCode2["Key_Down"] = 40] = "Key_Down";
      KeyCode2[KeyCode2["Key_Select"] = 41] = "Key_Select";
      KeyCode2[KeyCode2["Key_Print"] = 42] = "Key_Print";
      KeyCode2[KeyCode2["Key_Execute"] = 43] = "Key_Execute";
      KeyCode2[KeyCode2["Key_Insert"] = 45] = "Key_Insert";
      KeyCode2[KeyCode2["Key_Delete"] = 46] = "Key_Delete";
      KeyCode2[KeyCode2["Key_Help"] = 47] = "Key_Help";
      KeyCode2[KeyCode2["Key_0"] = 48] = "Key_0";
      KeyCode2[KeyCode2["Key_1"] = 49] = "Key_1";
      KeyCode2[KeyCode2["Key_2"] = 50] = "Key_2";
      KeyCode2[KeyCode2["Key_3"] = 51] = "Key_3";
      KeyCode2[KeyCode2["Key_4"] = 52] = "Key_4";
      KeyCode2[KeyCode2["Key_5"] = 53] = "Key_5";
      KeyCode2[KeyCode2["Key_6"] = 54] = "Key_6";
      KeyCode2[KeyCode2["Key_7"] = 55] = "Key_7";
      KeyCode2[KeyCode2["Key_8"] = 56] = "Key_8";
      KeyCode2[KeyCode2["Key_9"] = 57] = "Key_9";
      KeyCode2[KeyCode2["Key_A"] = 65] = "Key_A";
      KeyCode2[KeyCode2["Key_B"] = 66] = "Key_B";
      KeyCode2[KeyCode2["Key_C"] = 67] = "Key_C";
      KeyCode2[KeyCode2["Key_D"] = 68] = "Key_D";
      KeyCode2[KeyCode2["Key_E"] = 69] = "Key_E";
      KeyCode2[KeyCode2["Key_F"] = 70] = "Key_F";
      KeyCode2[KeyCode2["Key_G"] = 71] = "Key_G";
      KeyCode2[KeyCode2["Key_H"] = 72] = "Key_H";
      KeyCode2[KeyCode2["Key_I"] = 73] = "Key_I";
      KeyCode2[KeyCode2["Key_J"] = 74] = "Key_J";
      KeyCode2[KeyCode2["Key_K"] = 75] = "Key_K";
      KeyCode2[KeyCode2["Key_L"] = 76] = "Key_L";
      KeyCode2[KeyCode2["Key_M"] = 77] = "Key_M";
      KeyCode2[KeyCode2["Key_N"] = 78] = "Key_N";
      KeyCode2[KeyCode2["Key_O"] = 79] = "Key_O";
      KeyCode2[KeyCode2["Key_P"] = 80] = "Key_P";
      KeyCode2[KeyCode2["Key_Q"] = 81] = "Key_Q";
      KeyCode2[KeyCode2["Key_R"] = 82] = "Key_R";
      KeyCode2[KeyCode2["Key_S"] = 83] = "Key_S";
      KeyCode2[KeyCode2["Key_T"] = 84] = "Key_T";
      KeyCode2[KeyCode2["Key_U"] = 85] = "Key_U";
      KeyCode2[KeyCode2["Key_V"] = 86] = "Key_V";
      KeyCode2[KeyCode2["Key_W"] = 87] = "Key_W";
      KeyCode2[KeyCode2["Key_X"] = 88] = "Key_X";
      KeyCode2[KeyCode2["Key_Y"] = 89] = "Key_Y";
      KeyCode2[KeyCode2["Key_Z"] = 90] = "Key_Z";
      KeyCode2[KeyCode2["Key_KP_0"] = 96] = "Key_KP_0";
      KeyCode2[KeyCode2["Key_KP_1"] = 97] = "Key_KP_1";
      KeyCode2[KeyCode2["Key_KP_2"] = 98] = "Key_KP_2";
      KeyCode2[KeyCode2["Key_KP_3"] = 99] = "Key_KP_3";
      KeyCode2[KeyCode2["Key_KP_4"] = 100] = "Key_KP_4";
      KeyCode2[KeyCode2["Key_KP_5"] = 101] = "Key_KP_5";
      KeyCode2[KeyCode2["Key_KP_6"] = 102] = "Key_KP_6";
      KeyCode2[KeyCode2["Key_KP_7"] = 103] = "Key_KP_7";
      KeyCode2[KeyCode2["Key_KP_8"] = 104] = "Key_KP_8";
      KeyCode2[KeyCode2["Key_KP_9"] = 105] = "Key_KP_9";
      KeyCode2[KeyCode2["Key_Multiply"] = 106] = "Key_Multiply";
      KeyCode2[KeyCode2["Key_Add"] = 107] = "Key_Add";
      KeyCode2[KeyCode2["Key_Separator"] = 108] = "Key_Separator";
      KeyCode2[KeyCode2["Key_Subtract"] = 109] = "Key_Subtract";
      KeyCode2[KeyCode2["Key_Decimal"] = 110] = "Key_Decimal";
      KeyCode2[KeyCode2["Key_Divide"] = 111] = "Key_Divide";
      KeyCode2[KeyCode2["Key_F1"] = 112] = "Key_F1";
      KeyCode2[KeyCode2["Key_F2"] = 113] = "Key_F2";
      KeyCode2[KeyCode2["Key_F3"] = 114] = "Key_F3";
      KeyCode2[KeyCode2["Key_F4"] = 115] = "Key_F4";
      KeyCode2[KeyCode2["Key_F5"] = 116] = "Key_F5";
      KeyCode2[KeyCode2["Key_F6"] = 117] = "Key_F6";
      KeyCode2[KeyCode2["Key_F7"] = 118] = "Key_F7";
      KeyCode2[KeyCode2["Key_F8"] = 119] = "Key_F8";
      KeyCode2[KeyCode2["Key_F9"] = 120] = "Key_F9";
      KeyCode2[KeyCode2["Key_F10"] = 121] = "Key_F10";
      KeyCode2[KeyCode2["Key_F11"] = 122] = "Key_F11";
      KeyCode2[KeyCode2["Key_F12"] = 123] = "Key_F12";
      KeyCode2[KeyCode2["Key_F13"] = 124] = "Key_F13";
      KeyCode2[KeyCode2["Key_F14"] = 125] = "Key_F14";
      KeyCode2[KeyCode2["Key_F15"] = 126] = "Key_F15";
      KeyCode2[KeyCode2["Key_F16"] = 127] = "Key_F16";
      KeyCode2[KeyCode2["Key_F17"] = 128] = "Key_F17";
      KeyCode2[KeyCode2["Key_F18"] = 129] = "Key_F18";
      KeyCode2[KeyCode2["Key_F19"] = 130] = "Key_F19";
      KeyCode2[KeyCode2["Key_F20"] = 131] = "Key_F20";
      KeyCode2[KeyCode2["Key_F21"] = 132] = "Key_F21";
      KeyCode2[KeyCode2["Key_F22"] = 133] = "Key_F22";
      KeyCode2[KeyCode2["Key_F23"] = 134] = "Key_F23";
      KeyCode2[KeyCode2["Key_F24"] = 135] = "Key_F24";
      KeyCode2[KeyCode2["Key_Num_Lock"] = 136] = "Key_Num_Lock";
      KeyCode2[KeyCode2["Key_Scroll_Lock"] = 137] = "Key_Scroll_Lock";
      return KeyCode2;
    })(KeyCode || {});

    class FlyCameraController extends ComponentBase {
      /**
       *  Camera movement speed
       */
      moveSpeed = 2;
      /**
       *
       * Coordinates of specific objects
       */
      targetPos = new Vector3(0, 0, 10);
      /**
       *
       * Camera orientation coordinates
       */
      lookAtPos = new Vector3(0, 0, 0);
      /**
       * @internal
       */
      config = { shiftMoveScale: 20 };
      _moveScale = 1;
      _dir;
      _mouseFactory = 25;
      _factory = 1.5;
      _mouseDown = false;
      _lastPos;
      _keyState;
      constructor() {
        super();
        this._lastPos = new Vector3();
        this._keyState = {
          front: false,
          back: false,
          left: false,
          right: false,
          q: false,
          e: false
        };
        this.setCamera(new Vector3(0, 0, 100), new Vector3(0, 0, 0));
      }
      /**
       *
       * Initialize camera data
       * @param cameraPos source position 
       * @param lookAt target position
       */
      setCamera(cameraPos, lookAt) {
        this.targetPos.copyFrom(cameraPos);
        this.lookAtPos.copyFrom(lookAt);
        this.Reset();
      }
      /**
       * @internal
       */
      start() {
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
        Engine3D.inputSystem.addEventListener(KeyEvent.KEY_UP, this.keyUp, this);
        Engine3D.inputSystem.addEventListener(KeyEvent.KEY_DOWN, this.keyDown, this);
        this.transform.lookAt(this.targetPos, this.lookAtPos);
      }
      mouseWheel(e) {
      }
      keyUp(e) {
        switch (e.keyCode) {
          case KeyCode.Key_W:
            this._keyState.front = false;
            break;
          case KeyCode.Key_S:
            this._keyState.back = false;
            break;
          case KeyCode.Key_A:
            this._keyState.left = false;
            break;
          case KeyCode.Key_D:
            this._keyState.right = false;
            break;
          case KeyCode.Key_Shift_L:
            this._moveScale = 1;
            break;
          case KeyCode.Key_Q:
            this._keyState.q = false;
            break;
          case KeyCode.Key_E:
            this._keyState.e = false;
            break;
          case KeyCode.Key_F:
            this.transform.lookAt(this.targetPos, this.lookAtPos);
            break;
        }
      }
      keyDown(e) {
        switch (e.keyCode) {
          case KeyCode.Key_W:
            this._keyState.front = true;
            break;
          case KeyCode.Key_S:
            this._keyState.back = true;
            break;
          case KeyCode.Key_A:
            this._keyState.left = true;
            break;
          case KeyCode.Key_D:
            this._keyState.right = true;
            break;
          case KeyCode.Key_Q:
            this._keyState.q = true;
            break;
          case KeyCode.Key_E:
            this._keyState.e = true;
            break;
          case KeyCode.Key_Shift_L:
            this._moveScale = this.config.shiftMoveScale;
        }
      }
      Reset() {
        this._lastPos.x = Engine3D.inputSystem.mouseLastX;
        this._lastPos.y = Engine3D.inputSystem.mouseLastY;
      }
      mouseDown(e) {
        this.Reset();
        this._mouseDown = true;
      }
      mouseUp(e) {
        this.Reset();
        this._mouseDown = false;
      }
      /**
       *
       * Get the smoothness of the camera by keyboard control
       */
      get factory() {
        return this._factory;
      }
      /**
       *
       * Set the smoothness of the camera by keyboard control
       */
      set factory(value) {
        this._factory = value;
      }
      /**
       *
       * Get the smoothness of the camera by mouse control
       */
      get mouseFactory() {
        return this._mouseFactory;
      }
      /**
       *
       * Set the smoothness of the camera by mouse control
       */
      set mouseFactory(value) {
        this._mouseFactory = value;
      }
      /**
       * @internal
       * @param target 
       * @param current 
       * @param t 
       * @returns 
       */
      internal(target, current, t) {
        return (current - target) * t;
      }
      onUpdate() {
        let transform = this.transform;
        let dt = clamp(Time.delta, 0, 0.016);
        if (this._mouseDown) {
          transform.rotationY -= this.internal(transform.rotationY + (Engine3D.inputSystem.mouseLastX - this._lastPos.x) * 0.25, transform.rotationY, dt * this._mouseFactory);
          transform.rotationX -= this.internal(transform.rotationX + (Engine3D.inputSystem.mouseLastY - this._lastPos.y) * 0.25, transform.rotationX, dt * this._mouseFactory);
          this.Reset();
        }
        if (this._keyState.front) {
          let forward = transform.forward;
          transform.x -= this.internal(transform.x + forward.x * this.moveSpeed * this._moveScale, transform.x, dt * this._factory);
          transform.y -= this.internal(transform.y + forward.y * this.moveSpeed * this._moveScale, transform.y, dt * this._factory);
          transform.z -= this.internal(transform.z + forward.z * this.moveSpeed * this._moveScale, transform.z, dt * this._factory);
        }
        if (this._keyState.back) {
          let forward = transform.forward;
          transform.x += this.internal(transform.x + forward.x * this.moveSpeed * this._moveScale, transform.x, dt * this._factory);
          transform.y += this.internal(transform.y + forward.y * this.moveSpeed * this._moveScale, transform.y, dt * this._factory);
          transform.z += this.internal(transform.z + forward.z * this.moveSpeed * this._moveScale, transform.z, dt * this._factory);
        }
        if (this._keyState.left) {
          let right = transform.left;
          transform.x += this.internal(transform.x + right.x * this.moveSpeed * this._moveScale, transform.x, dt * this._factory);
          transform.y += this.internal(transform.y + right.y * this.moveSpeed * this._moveScale, transform.y, dt * this._factory);
          transform.z += this.internal(transform.z + right.z * this.moveSpeed * this._moveScale, transform.z, dt * this._factory);
        }
        if (this._keyState.right) {
          let right = transform.left;
          transform.x -= this.internal(transform.x + right.x * this.moveSpeed * this._moveScale, transform.x, dt * this._factory);
          transform.y -= this.internal(transform.y + right.y * this.moveSpeed * this._moveScale, transform.y, dt * this._factory);
          transform.z -= this.internal(transform.z + right.z * this.moveSpeed * this._moveScale, transform.z, dt * this._factory);
        }
        if (this._keyState.q) {
          transform.y = lerp(transform.y, transform.y - this.moveSpeed * this._moveScale, dt * this._factory);
        }
        if (this._keyState.e) {
          transform.y = lerp(transform.y, transform.y + this.moveSpeed * this._moveScale, dt * this._factory);
        }
      }
      /**
       * @internal
       */
      destroy(force) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
        Engine3D.inputSystem.removeEventListener(KeyEvent.KEY_UP, this.keyUp, this);
        Engine3D.inputSystem.removeEventListener(KeyEvent.KEY_DOWN, this.keyDown, this);
        super.destroy(force);
      }
    }

    class Vector3Ex {
      /**
       * vector3 add
       * @param v1
       * @param v2
       * @param target
       * @returns
       */
      static add(v1, v2, target) {
        if (!target) {
          target = new Vector3();
        }
        target.x = v1.x + v2.x;
        target.y = v1.y + v2.y;
        target.z = v1.z + v2.z;
        return target;
      }
      /**
       * vector3 sub
       * @param v1
       * @param v2
       * @param target
       * @returns
       */
      static sub(v1, v2, target) {
        if (!target) {
          target = new Vector3();
        }
        target.x = v1.x - v2.x;
        target.y = v1.y - v2.y;
        target.z = v1.z - v2.z;
        return target;
      }
      /**
       * vector3 mul
       * @param v1
       * @param v2
       * @param target
       * @returns
       */
      static mul(v1, v2, target) {
        if (!target) {
          target = new Vector3();
        }
        target.x = v1.x * v2.x;
        target.y = v1.y * v2.y;
        target.z = v1.z * v2.z;
        return target;
      }
      /**
       * vector3 mul
       * @param v1
       * @param v2
       * @param target
       * @returns
       */
      static mulScale(v1, v, target) {
        if (!target) {
          target = new Vector3();
        }
        target.x = v1.x * v;
        target.y = v1.y * v;
        target.z = v1.z * v;
        return target;
      }
      /**
       * vector3 div
       * @param v1
       * @param v2
       * @param target
       * @returns
       */
      static div(v1, v2, target) {
        if (!target) {
          target = new Vector3();
        }
        target.x = v1.x / v2.x;
        target.y = v1.y / v2.y;
        target.z = v1.z / v2.z;
        return target;
      }
      /**
       * normalize
       * @param v1 source vector
       * @returns result vector
       */
      static normalize(v1) {
        let t = v1.clone();
        return t.normalize();
      }
      /**
       * dot
       * @param v1 first vector
       * @param v2 second vector
       * @returns result
       */
      static dot(v1, v2) {
        let v = Vector3.HELP_0;
        v.copyFrom(v1);
        return v.dotProduct(v2);
      }
      /**
       * Calculate the angle between two vectors
       * @param v1 first vector
       * @param v2 second vector
       * @returns Angle result in radians
       */
      static calculateVectorAngle_xz(v1, v2) {
        return Math.acos((v1.x * v2.x + v1.y * v2.y) / Math.sqrt((v1.x * v1.x + v1.y * v1.y) * (v2.x * v2.x + v2.y * v2.y)));
      }
      /**
       *
       * Calculate the distance between two points
       * @static
       * @param {Vector3} v1 first vector
       * @param {Vector3} v2 second vector
       * @return {*} distance
       */
      static distance(v1, v2) {
        return Vector3.distance(v1, v2);
      }
      /**
       * make a Random 3D Vector
       * @param min The min random value of vector components
       * @param max The max random value of vector components
       * @returns random vector
       */
      static getRandomXYZ(min = -100, max = 100) {
        return new Vector3(Math.random() * (max - min) + min, Math.random() * (max - min) + min, Math.random() * (max - min) + min);
      }
      /**
       * make a Random 3D Vector
       * @param min The min random value of vector component-x
       * @param max The max random value of vector component-x
       * @param yMin The min random value of vector component-y
       * @param yMax The max random value of vector component-y
       * @returns random vector
       */
      static getRandomV3(min = -100, max = 100, yMin, yMax) {
        return new Vector3(Math.random() * max + min, Math.random() * yMax + yMin, Math.random() * max + min);
      }
      static sphere(radius) {
        let r = radius * Math.random();
        let randomDir = new Vector3(Math.random() * 1 - 0.5, Math.random() * 1 - 0.5, Math.random() * 1 - 0.5);
        randomDir.normalize();
        randomDir.scaleBy(r);
        return randomDir;
      }
      static sphereXYZ(radiusMin, radiusMax, x = 1, y = 1, z = 1) {
        let r = radiusMin + (radiusMax - radiusMin) * Math.random();
        let randomDir = new Vector3(Math.random() * x - x * 0.5, Math.random() * y - y * 0.5, Math.random() * z - z * 0.5);
        randomDir.normalize();
        randomDir.scaleBy(r);
        return randomDir;
      }
    }

    class HoverCameraController extends ComponentBase {
      /**
       * camera controlling
       */
      camera;
      /**
       * The closest distance that the mouse wheel can operate
       */
      minDistance = 0.1;
      /**
       * The farthest distance that the mouse wheel can operate
       */
      maxDistance = 500;
      /**
       * Smoothing coefficient of rolling angle
       */
      rollSmooth = 15;
      /**
       * Smoothing coefficient of dragging
       */
      dragSmooth = 20;
      /**
       * Smoothing coefficient of rolling
       */
      wheelSmooth = 10;
      /**
       * Mouse scrolling step coefficient
       */
      wheelStep = 2e-3;
      /**
       * Right mouse movement coefficient
       */
      mouseRightFactor = 0.5;
      /**
       * Left mouse movement coefficient
       */
      mouseLeftFactor = 20;
      /**
       * Whether to enable smooth mode
       */
      smooth = true;
      /**
       * @internal
       */
      _wheelStep = 2e-3;
      _distance = 0;
      /**
       * Distance between camera and target
       */
      distance = 10;
      _roll = 0;
      /**
       * Roll angle around y-axis
       */
      roll = 0;
      _pitch = 0;
      /**
       * Pitch angle around x-axis
       */
      pitch = 0;
      _currentPos;
      /**
       * @internal
       */
      _targetPos;
      _flowTarget;
      _flowOffset;
      _mouseLeftDown = false;
      _mouseRightDown = false;
      _bottomClamp = 89.99;
      _topClamp = -89.99;
      _tempDir = new Vector3();
      _tempPos = new Vector3();
      /**
       * @constructor
       */
      constructor() {
        super();
        this._currentPos = new exports.Object3D();
        this._targetPos = new exports.Object3D();
      }
      /**
       * @internal
       */
      start() {
        this.camera = this.object3D.getOrAddComponent(Camera3D);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.onMouseDown, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.onMouseMove, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.onMouseUp, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_WHEEL, this.onMouseWheel, this);
      }
      flowTarget(target, offset = Vector3.ZERO) {
        this._flowTarget = target;
        this._flowOffset ||= new Vector3();
        this._flowOffset.copyFrom(offset);
      }
      getFlowTarget() {
        return this._flowTarget;
      }
      /**
       * Initialize Camera
       * @param roll  Roll angle around y-axis
       * @param pitch Pitch angle around x-axis
       * @param distance max distance to target
       * @param target coordinates of the target
       */
      setCamera(roll, pitch, distance, target) {
        this.roll = roll;
        this.pitch = pitch;
        this.distance = distance;
        if (this.maxDistance < distance * 1.5) {
          this.maxDistance = distance * 1.5;
        }
        if (target) {
          this._targetPos.transform.localPosition.copy(target);
        }
      }
      focusByBounds(obj) {
        let bounds = BoundUtil.genMeshBounds(obj);
        this.target = bounds.center;
      }
      /**
       * Set target position
       */
      set target(target) {
        this._targetPos.transform.localPosition.copy(target);
      }
      /**
       * Get target position
       * @return {Vector3}
       */
      get target() {
        return this._targetPos.transform.localPosition;
      }
      onMouseWheel(e) {
        if (!this.enable)
          return;
        this._wheelStep = this.wheelStep * Vector3Ex.distance(this._currentPos.transform.worldPosition, this.camera.transform.worldPosition) / 10;
        this.distance -= Engine3D.inputSystem.wheelDelta * this._wheelStep;
        this.distance = clamp(this.distance, this.minDistance, this.maxDistance);
      }
      onMouseDown(e) {
        if (!this.enable)
          return;
        switch (e.mouseCode) {
          case 0:
            this._mouseLeftDown = true;
            break;
          case 1:
            break;
          case 2:
            this._mouseRightDown = true;
            break;
        }
      }
      onMouseUp(e) {
        this._mouseLeftDown = false;
        this._mouseRightDown = false;
      }
      /**
       * @internal
       */
      onMouseMove(e) {
        if (!this.enable)
          return;
        if (this._mouseRightDown) {
          let p = 0.25;
          let f = this.camera.transform.forward;
          Vector3Ex.mulScale(f, e.movementY * p * this.camera.aspect, Vector3.HELP_1);
          this._targetPos.x += Vector3.HELP_1.x * this.mouseRightFactor;
          this._targetPos.z += Vector3.HELP_1.z * this.mouseRightFactor;
          let f2 = this.camera.transform.right;
          Vector3Ex.mulScale(f2, -e.movementX * p, Vector3.HELP_1);
          this._targetPos.x -= Vector3.HELP_1.x * this.mouseRightFactor;
          this._targetPos.z -= Vector3.HELP_1.z * this.mouseRightFactor;
        }
        if (this._mouseLeftDown) {
          this.roll -= e.movementX * Time.delta * 1e-3 * this.mouseLeftFactor;
          this.pitch -= e.movementY * Time.delta * 1e-3 * this.mouseLeftFactor;
          this.pitch = clamp(this.pitch, this._topClamp, this._bottomClamp);
        }
      }
      onBeforeUpdate(view) {
        if (!this.enable)
          return;
        if (this._flowTarget) {
          Vector3.HELP_0.copyFrom(this._flowTarget.transform.worldPosition);
          Vector3.HELP_0.add(this._flowOffset, Vector3.HELP_0);
          this.target = Vector3.HELP_0;
        }
        let dt = clamp(Time.delta, 0, 0.016);
        if (this.smooth) {
          this._currentPos.x += (this._targetPos.x - this._currentPos.x) * dt * this.dragSmooth;
          this._currentPos.y += (this._targetPos.y - this._currentPos.y) * dt * this.dragSmooth;
          this._currentPos.z += (this._targetPos.z - this._currentPos.z) * dt * this.dragSmooth;
          this._distance += (this.distance - this._distance) * dt * this.wheelSmooth;
          this._roll += (this.roll - this._roll) * dt * this.rollSmooth;
          this._pitch += (this.pitch - this._pitch) * dt * this.rollSmooth;
        } else {
          this._currentPos.x = this._targetPos.x;
          this._currentPos.y = this._targetPos.y;
          this._currentPos.z = this._targetPos.z;
          this._distance = this.distance;
          this._roll = this.roll;
          this._pitch = this.pitch;
        }
        this._tempDir.set(0, 0, 1);
        let q = Quaternion.HELP_0;
        q.fromEulerAngles(this._pitch, this._roll, 0);
        this._tempDir.applyQuaternion(q);
        this._tempPos = Vector3Ex.mulScale(this._tempDir, this._distance, this._tempPos);
        this._tempPos.add(this._currentPos.transform.localPosition, this._tempPos);
        this.transform.lookAt(this._tempPos, this._currentPos.transform.localPosition, Vector3.UP);
        this.camera.lookTarget.copy(this._currentPos.transform.localPosition);
      }
      /**
       * @internal
       */
      destroy(force) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.onMouseDown, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_MOVE, this.onMouseMove, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.onMouseUp, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_WHEEL, this.onMouseWheel, this);
        super.destroy(force);
        this.camera = null;
        this._flowTarget = null;
      }
    }

    class OrbitController extends ComponentBase {
      /**
       * internal camera
       */
      _camera;
      /**
       * Whether to enable automatic rotation
       */
      autoRotate = false;
      /**
       * Automatic rotation speed coefficient
       */
      autoRotateSpeed = 0.1;
      /**
       * Rotation speed coefficient
       */
      rotateFactor = 0.5;
      /**
       * Scale speed coefficient
       */
      zoomFactor = 0.1;
      /**
       * Angle translation velocity coefficient
       */
      panFactor = 0.25;
      _smooth = 5;
      _minDistance = 1;
      _maxDistance = 1e5;
      _maxPolarAngle = 90;
      _minPolarAngle = -90;
      _target = new Vector3(0, 0, 0);
      _cTarget = new Vector3(0, 0, 0);
      _position = new Vector3(0, 0, 0);
      _cPosition = new Vector3(0, 0, 0);
      _spherical = new Spherical();
      _isMouseDown = false;
      _lastMouseX = -1;
      _lastMouseY = -1;
      _isPanning = false;
      /**
       * @constructor
       */
      constructor() {
        super();
      }
      /**
       * Get the target position
       */
      get target() {
        return this._target;
      }
      /**
       * Set the target position
       */
      set target(v) {
        this._target = v;
      }
      /**
       * Set smoothing coefficient of controller
       */
      get smooth() {
        return this._smooth;
      }
      /**
       * Get smoothing coefficient of controller
       */
      set smooth(v) {
        this._smooth = Math.max(v, 1);
      }
      /**
       * Get the minimum distance between the camera and the target coordinate
       * @defaultValue 1
       */
      get minDistance() {
        return this._minDistance;
      }
      /**
       * Set the minimum distance between the camera and the target position
       * min value: 0.000002
       * max value: `this._maxDistance` {@link maxDistance}
       */
      set minDistance(v) {
        this._minDistance = clamp(v, 2e-6, this._maxDistance);
      }
      /**
       * Get the max distance between the camera and the target position
       * @defaultValue 100000
       */
      get maxDistance() {
        return this._maxDistance;
      }
      /**
       * Set the max distance between the camera and the target position
       * min - `this._maxDistance`
       * max - Infinity
       */
      set maxDistance(v) {
        this._maxDistance = clamp(v, this._minDistance, Infinity);
      }
      /**
       * Get the lower elevation limit of the camera from the xz plane
       * @defaultValue -90
       */
      get minPolarAngle() {
        return this._minPolarAngle;
      }
      /**
       * Set the lower elevation limit of the camera from the xz plane
       * min - -90
       * max - {@link maxPolarAngle}
       */
      set minPolarAngle(v) {
        this._minPolarAngle = clamp(v, -90, this._maxPolarAngle);
      }
      /**
       * Get the upper elevation limit of the camera from the xz plane
       * @defaultValue 90
       */
      get maxPolarAngle() {
        return this._maxPolarAngle;
      }
      /**
       * Set the upper elevation limit of the camera to the xz plane
       * min - less than {@link minPolarAngle}   
       * max - 90
       */
      set maxPolarAngle(v) {
        this._maxPolarAngle = clamp(v, this._minPolarAngle, 90);
      }
      /**
       * @internal
       */
      start() {
        this._camera = this.object3D.getComponent(Camera3D);
        this._position = this.object3D.transform.localPosition.clone();
        this._cPosition = this._position.clone();
        this._target = this._camera.lookTarget.clone();
        this._cTarget = this._target.clone();
        this._spherical.setCoords(this._position.x - this._target.x, this._position.y - this._target.y, this._position.z - this._target.z);
        this._camera.lookAt(this._cPosition, this._cTarget, Vector3.UP);
        this.addEventListener();
      }
      /**
       * @internal
       */
      onEnable() {
        this.addEventListener();
      }
      /**
       * @internal
       */
      onDisable() {
        this.removeEventListener();
      }
      /**
       * @internal
       */
      onUpdate() {
        let step = this._isPanning ? 1 : this.smooth;
        let changed = false;
        if (!this._cPosition.equals(this.object3D.transform.localPosition)) {
          this._position.copyFrom(this.object3D.transform.localPosition);
          step = 1;
          changed = true;
        }
        if (!this._cTarget.equals(this._target)) {
          this._cTarget.copyFrom(this._target);
          step = 1;
          changed = true;
        }
        if (changed) {
          this._spherical.setCoords(this._position.x - this._target.x, this._position.y - this._target.y, this._position.z - this._target.z);
        } else if (!this._isMouseDown && this.autoRotate) {
          this._spherical.theta -= this.autoRotateSpeed * Math.PI / 180;
          this.updateCamera();
        }
        let x = (this._position.x - this._cPosition.x) / step;
        let y = (this._position.y - this._cPosition.y) / step;
        let z = (this._position.z - this._cPosition.z) / step;
        this._cPosition.x = Math.abs(x) > 1e-10 ? this._cPosition.x + x : this._position.x;
        this._cPosition.y = Math.abs(y) > 1e-10 ? this._cPosition.y + y : this._position.y;
        this._cPosition.z = Math.abs(z) > 1e-10 ? this._cPosition.z + z : this._position.z;
        this._camera.lookAt(this._cPosition, this._cTarget, Vector3.UP);
      }
      /**
       * @internal
       */
      onWheel(e) {
        e.deltaY = clamp(e.deltaY, -this._spherical.radius, this._spherical.radius);
        this._spherical.radius += e.deltaY * this.zoomFactor;
        this._spherical.radius = clamp(this._spherical.radius, this.minDistance, this.maxDistance);
        this.updateCamera();
      }
      /**
       * @internal
       */
      onPointerDown(e) {
        this._isMouseDown = true;
        this._lastMouseX = e.mouseX;
        this._lastMouseY = e.mouseY;
        if (e.mouseCode === 2)
          this._isPanning = true;
      }
      /**
       * @internal
       */
      onPointerMove(e) {
        if (!this._isMouseDown || !this.enable)
          return;
        let mousex = e.mouseX;
        let mousey = e.mouseY;
        if (e.mouseCode === 0 && this._lastMouseX > 0 && this._lastMouseY > 0) {
          const ra = -(mousex - this._lastMouseX) * this.rotateFactor;
          const rb = (mousey - this._lastMouseY) * this.rotateFactor;
          this._spherical.theta += ra * Math.PI / 180;
          this._spherical.phi -= rb * Math.PI / 180;
          this._spherical.phi = clamp(this._spherical.phi, this.minPolarAngle, this.maxPolarAngle);
          this.updateCamera();
        } else if (e.mouseCode === 2) {
          Vector3Ex.mulScale(this.object3D.transform.up, e.movementY * this.panFactor * this._camera.aspect, Vector3.HELP_1);
          this._target.y += Vector3.HELP_1.y;
          Vector3Ex.mulScale(this.object3D.transform.right, -e.movementX * this.panFactor, Vector3.HELP_1);
          this._target.x -= Vector3.HELP_1.x;
          this._target.z -= Vector3.HELP_1.z;
          this._cTarget.copyFrom(this._target);
          this.updateCamera();
        }
        this._lastMouseX = mousex;
        this._lastMouseY = mousey;
      }
      /**
       * @internal
       */
      onPointerUp(e) {
        this._isMouseDown = false;
        if (e.mouseCode === 2) {
          this._isPanning = false;
        }
      }
      onPointerLeave() {
        this._isMouseDown = false;
        this._isPanning = false;
      }
      /**
       * @internal
       */
      updateCamera() {
        this._spherical.makeSafe();
        let pos = this._spherical.getCoords();
        this._position.set(pos.x + this._target.x, pos.y + this._target.y, pos.z + this._target.z);
      }
      /**
       * @internal
       */
      addEventListener() {
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_WHEEL, this.onWheel, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.onPointerDown, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.onPointerMove, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.onPointerUp, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_OUT, this.onPointerLeave, this);
      }
      /**
       * @internal
       */
      removeEventListener() {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_WHEEL, this.onWheel, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.onPointerDown, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_MOVE, this.onPointerMove, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.onPointerUp, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_OUT, this.onPointerLeave, this);
      }
    }
    class Spherical {
      radius;
      phi;
      theta;
      coords;
      constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        this.coords = new Vector3();
        return this;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      // restrict phi to be between EPS and PI-EPS
      makeSafe() {
        const EPS = 2e-4;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      }
      setFromVector3(v) {
        return this.setCoords(v.x, v.y, v.z);
      }
      setCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(clamp(y / this.radius, -1, 1));
        }
        return this;
      }
      getCoords() {
        const sinPhiRadius = Math.sin(this.phi) * this.radius;
        this.coords.x = sinPhiRadius * Math.sin(this.theta);
        this.coords.y = Math.cos(this.phi) * this.radius;
        this.coords.z = sinPhiRadius * Math.cos(this.theta);
        return this.coords;
      }
    }

    class ThirdPersonCameraController extends ComponentBase {
      focus;
      _rotation = new Vector3(45, 0, 0);
      distance = 5;
      _camera;
      constructor() {
        super();
      }
      start() {
        this._camera = this.object3D.getOrAddComponent(Camera3D);
        if (!this._camera) {
          console.error("ThirdPersonCameraController need camera");
          return;
        }
        if (!this.focus) {
          console.error("ThirdPersonCameraController need target");
          return;
        }
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
      }
      mouseDown(e) {
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.mouseMove, this);
      }
      mouseUp(e) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_MOVE, this.mouseMove, this);
      }
      mouseMove(e) {
        this._rotation.y += e.movementX * 0.01;
        this._rotation.x += e.movementY * 0.01;
      }
      mouseWheel(e) {
        this.distance += Engine3D.inputSystem.wheelDelta * 0.1;
      }
      onUpdate() {
        let vec = new Vector3();
        this._camera.transform.forward.scaleToRef(this.distance, vec);
        var focusPoint = this.focus.transform.worldPosition;
        this._camera.transform.localPosition = focusPoint.subtract(vec);
      }
      destroy(force) {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_WHEEL, this.mouseWheel, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.mouseUp, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.mouseDown, this);
        super.destroy(force);
      }
    }

    var UIInteractiveStyle = /* @__PURE__ */ ((UIInteractiveStyle2) => {
      UIInteractiveStyle2[UIInteractiveStyle2["NORMAL"] = 0] = "NORMAL";
      UIInteractiveStyle2[UIInteractiveStyle2["DOWN"] = 1] = "DOWN";
      UIInteractiveStyle2[UIInteractiveStyle2["OVER"] = 2] = "OVER";
      UIInteractiveStyle2[UIInteractiveStyle2["DISABLE"] = 3] = "DISABLE";
      return UIInteractiveStyle2;
    })(UIInteractiveStyle || {});

    let PI = Math.PI;
    let TwoPI = PI * 2;
    class Matrix3 {
      /**
       * The width of x
       */
      a;
      /**
       * The slope of y
       */
      b;
      /**
       * The slope of x
       */
      c;
      /**
       * The height of y
       */
      d;
      /**
       * The position of the x coordinate
       */
      tx;
      /**
       * The position of the y coordinate
       */
      ty;
      /**
       * Create a Matrix3
       * @param a The width of x
       * @param b The slope of y
       * @param c The slope of x
       * @param d The height of y
       * @param tx The position of the x coordinate
       * @param ty The position of the y coordinate
       */
      constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Clone an Matrix3 object
       * @returns New Matrix3 object
       */
      clone() {
        return new Matrix3(this.a, this.b, this.c, this.d, this.tx, this.ty);
      }
      /**
       * Merges the current matrix with the target matrix
       * @param matrix target matrix
       */
      concat(matrix) {
        let a = this.a;
        let c = this.c;
        let tx = this.tx;
        this.a = a * matrix.a + this.b * matrix.c;
        this.b = a * matrix.b + this.b * matrix.d;
        this.c = c * matrix.a + this.d * matrix.c;
        this.d = c * matrix.b + this.d * matrix.d;
        this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
      }
      /**
       * The current matrix value is overwritten by the target matrix value
       * @param other  target matrix value
       * @returns current matrix
       */
      copyFrom(other) {
        this.a = other.a;
        this.b = other.b;
        this.c = other.c;
        this.d = other.d;
        this.tx = other.tx;
        this.ty = other.ty;
        return this;
      }
      /**
       * Reset to the identity matrix
       */
      identity() {
        this.a = this.d = 1;
        this.b = this.c = this.tx = this.ty = 0;
        return this;
      }
      /**
       * Invert this matrix
       */
      invert() {
        this._invertInto(this);
      }
      /**
       * Rotate according to Angle
       * @param angle rotation angle
       */
      rotate(angle) {
        angle = +angle;
        if (angle !== 0) {
          angle = angle * DEGREES_TO_RADIANS;
          let u = Math.cos(angle);
          let v = Math.sin(angle);
          let ta = this.a;
          let tb = this.b;
          let tc = this.c;
          let td = this.d;
          let ttx = this.tx;
          let tty = this.ty;
          this.a = ta * u - tb * v;
          this.b = ta * v + tb * u;
          this.c = tc * u - td * v;
          this.d = tc * v + td * u;
          this.tx = ttx * u - tty * v;
          this.ty = ttx * v + tty * u;
        }
      }
      /**
       * Scale by offset
       * @param sx x axis scaling
       * @param sy y axis scaling
       */
      scale(sx, sy) {
        if (sx !== 1) {
          this.a *= sx;
          this.c *= sx;
          this.tx *= sx;
        }
        if (sy !== 1) {
          this.b *= sy;
          this.d *= sy;
          this.ty *= sy;
        }
      }
      /**
       * Reset the matrix value
       * @param a Matrix element a
       * @param b Matrix element b
       * @param c Matrix element c
       * @param d Matrix element d
       * @param tx Matrix element tx
       * @param ty Matrix element ty
       * @returns The modified matrix
       */
      setTo(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * transformation of coordinates
       * @param pointX x coordinate
       * @param pointY y coordinate
       * @param resultPoint Vector of results
       * @returns Vector of results
       */
      transformPoint(pointX, pointY, resultPoint) {
        let x = this.a * pointX + this.c * pointY + this.tx;
        let y = this.b * pointX + this.d * pointY + this.ty;
        if (resultPoint) {
          resultPoint.setTo(x, y, 0, 1);
          return resultPoint;
        }
        return new Vector3(x, y, 0, 1);
      }
      /**
       * translation
       * @param x x coordinate
       * @param y y coordinate
       */
      setTranslate(x, y) {
        this.tx = x;
        this.ty = y;
      }
      /**
       * Translates the specified offset
       * @param dx The x-coordinate offset
       * @param dy The y-coordinate offset
       */
      translate(dx, dy) {
        this.tx += dx;
        this.ty += dy;
      }
      /**
       * multiply
       * @param t target matrix
       */
      mul(t) {
        let m1 = this;
        let m2 = t;
        let aa = m1.a;
        let ab = m1.b;
        let ac = m1.c;
        let ad = m1.d;
        let atx = m1.tx;
        let aty = m1.ty;
        let ba = m2.a;
        let bb = m2.b;
        let bc = m2.c;
        let bd = m2.d;
        let btx = m2.tx;
        let bty = m2.ty;
        if (bb !== 0 || bc !== 0) {
          this.a = aa * ba + ab * bc;
          this.b = aa * bb + ab * bd;
          this.c = ac * ba + ad * bc;
          this.d = ac * bb + ad * bd;
          this.tx = ba * atx + bc * aty + btx;
          this.ty = bb * atx + bd * aty + bty;
        } else {
          this.a = aa * ba;
          this.b = ab * bd;
          this.c = ac * ba;
          this.d = ad * bd;
          this.tx = ba * atx + btx;
          this.ty = bd * aty + bty;
        }
      }
      /**
       * Is equal to the given matrix
       * @param other matrix
       * @returns 
       */
      equals(other) {
        return this.a == other.a && this.b == other.b && this.c == other.c && this.d == other.d && this.tx == other.tx && this.ty == other.ty;
      }
      /**
       * get a front matrix by multiplication
       * @param a Multiply by a
       * @param b Multiply by b
       * @param c Multiply by c
       * @param d Multiply by d
       * @param tx Multiply by tx
       * @param ty Multiply by ty
       * @returns prematrix
       */
      prepend(a, b, c, d, tx, ty) {
        let tx1 = this.tx;
        if (a != 1 || b != 0 || c != 0 || d != 1) {
          let a1 = this.a;
          let c1 = this.c;
          this.a = a1 * a + this.b * c;
          this.b = a1 * b + this.b * d;
          this.c = c1 * a + this.d * c;
          this.d = c1 * b + this.d * d;
        }
        this.tx = tx1 * a + this.ty * c + tx;
        this.ty = tx1 * b + this.ty * d + ty;
        return this;
      }
      /**
       * Obtain a post-multiplication matrix by multiplication.
       * @param mat Matrix
       * @returns result
       */
      append(mat) {
        let a1 = this.a;
        let b1 = this.b;
        let c1 = this.c;
        let d1 = this.d;
        if (mat.a != 1 || mat.b != 0 || mat.c != 0 || mat.d != 1) {
          this.a = mat.a * a1 + mat.b * c1;
          this.b = mat.a * b1 + mat.b * d1;
          this.c = mat.c * a1 + mat.d * c1;
          this.d = mat.c * b1 + mat.d * d1;
        }
        this.tx = mat.tx * a1 + mat.ty * c1 + this.tx;
        this.ty = mat.tx * b1 + mat.ty * d1 + this.ty;
        return this;
      }
      /**
       * Use the given point for the transformation, ignoring the x, y coordinates
       * @param point A given point
       * @returns 
       */
      deltaTransformPoint(point) {
        let self = this;
        let x = self.a * point.x + self.c * point.y;
        let y = self.b * point.x + self.d * point.y;
        return new Vector3(x, y);
      }
      /**
       * Converts the current matrix to string form
       * @returns 
       */
      toString() {
        return "(a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
      }
      /**
       * Set the matrix scaling, rotation, and conversion parameters
       * @param scaleX x axis scaling
       * @param scaleY y axis scaling
       * @param rotation rotation
       * @param tx x-coordinate
       * @param ty y-coordinate
       */
      createBox(scaleX, scaleY, rotation = 0, tx = 0, ty = 0) {
        let self = this;
        if (rotation !== 0) {
          rotation = rotation * DEGREES_TO_RADIANS;
          let u = Math.cos(rotation);
          let v = Math.sin(rotation);
          self.a = u * scaleX;
          self.b = v * scaleY;
          self.c = -v * scaleX;
          self.d = u * scaleY;
        } else {
          self.a = scaleX;
          self.b = 0;
          self.c = 0;
          self.d = scaleY;
        }
        self.tx = tx;
        self.ty = ty;
      }
      /**
       * Create a gradient box
       * @param width width
       * @param height height
       * @param rotation rotation
       * @param tx x-coordinate
       * @param ty y-coordinate
       */
      createGradientBox(width, height, rotation = 0, tx = 0, ty = 0) {
        this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
      }
      /**
       * Invert the given matrix
       * @param target matrix
       * @returns 
       */
      _invertInto(target) {
        let a = this.a;
        let b = this.b;
        let c = this.c;
        let d = this.d;
        let tx = this.tx;
        let ty = this.ty;
        if (b == 0 && c == 0) {
          target.b = target.c = 0;
          if (a == 0 || d == 0) {
            target.a = target.d = target.tx = target.ty = 0;
          } else {
            a = target.a = 1 / a;
            d = target.d = 1 / d;
            target.tx = -a * tx;
            target.ty = -d * ty;
          }
          return;
        }
        let determinant = a * d - b * c;
        if (determinant == 0) {
          target.identity();
          return;
        }
        determinant = 1 / determinant;
        let k = target.a = d * determinant;
        b = target.b = -b * determinant;
        c = target.c = -c * determinant;
        d = target.d = a * determinant;
        target.tx = -(k * tx + c * ty);
        target.ty = -(b * tx + d * ty);
      }
      /**
       * @private
       */
      getScaleX() {
        let m = this;
        if (m.a == 1 && m.b == 0) {
          return 1;
        }
        let result = Math.sqrt(m.a * m.a + m.b * m.b);
        return this.getDeterminant() < 0 ? -result : result;
      }
      /**
       * @private
       */
      getScaleY() {
        let m = this;
        if (m.c == 0 && m.d == 1) {
          return 1;
        }
        let result = Math.sqrt(m.c * m.c + m.d * m.d);
        return this.getDeterminant() < 0 ? -result : result;
      }
      /**
       * @private
       */
      getSkewX() {
        return Math.atan2(this.d, this.c) - Math.PI / 2;
      }
      /**
       * @private
       */
      getSkewY() {
        return Math.atan2(this.b, this.a);
      }
      /**
       * @private
       */
      updateScaleAndRotation(scaleX, scaleY, skewX, skewY) {
        if ((skewX == 0 || skewX == TwoPI) && (skewY == 0 || skewY == TwoPI)) {
          this.a = scaleX;
          this.b = this.c = 0;
          this.d = scaleY;
          return;
        }
        skewX = skewX * DEGREES_TO_RADIANS;
        skewY = skewY * DEGREES_TO_RADIANS;
        let u = Math.cos(skewX);
        let v = Math.sin(skewX);
        if (skewX == skewY) {
          this.a = u * scaleX;
          this.b = v * scaleX;
        } else {
          this.a = Math.cos(skewY) * scaleX;
          this.b = Math.sin(skewY) * scaleX;
        }
        this.c = -v * scaleY;
        this.d = u * scaleY;
      }
      /**
       * @private
       * target = other * this
       */
      preMultiplyInto(other, target) {
        let a = other.a * this.a;
        let b = 0;
        let c = 0;
        let d = other.d * this.d;
        let tx = other.tx * this.a + this.tx;
        let ty = other.ty * this.d + this.ty;
        if (other.b !== 0 || other.c !== 0 || this.b !== 0 || this.c !== 0) {
          a += other.b * this.c;
          d += other.c * this.b;
          b += other.a * this.b + other.b * this.d;
          c += other.c * this.a + other.d * this.c;
          tx += other.ty * this.c;
          ty += other.tx * this.b;
        }
        target.a = a;
        target.b = b;
        target.c = c;
        target.d = d;
        target.tx = tx;
        target.ty = ty;
      }
      /**
       * @private
       */
      $transformBounds(bounds) {
        let a = this.a;
        let b = this.b;
        let c = this.c;
        let d = this.d;
        let tx = this.tx;
        let ty = this.ty;
        let x = bounds.x;
        let y = bounds.y;
        let xMax = x + bounds.width;
        let yMax = y + bounds.height;
        let x0 = a * x + c * y + tx;
        let y0 = b * x + d * y + ty;
        let x1 = a * xMax + c * y + tx;
        let y1 = b * xMax + d * y + ty;
        let x2 = a * xMax + c * yMax + tx;
        let y2 = b * xMax + d * yMax + ty;
        let x3 = a * x + c * yMax + tx;
        let y3 = b * x + d * yMax + ty;
        let tmp = 0;
        if (x0 > x1) {
          tmp = x0;
          x0 = x1;
          x1 = tmp;
        }
        if (x2 > x3) {
          tmp = x2;
          x2 = x3;
          x3 = tmp;
        }
        bounds.x = Math.floor(x0 < x2 ? x0 : x2);
        bounds.width = Math.ceil((x1 > x3 ? x1 : x3) - bounds.x);
        if (y0 > y1) {
          tmp = y0;
          y0 = y1;
          y1 = tmp;
        }
        if (y2 > y3) {
          tmp = y2;
          y2 = y3;
          y3 = tmp;
        }
        bounds.y = Math.floor(y0 < y2 ? y0 : y2);
        bounds.height = Math.ceil((y1 > y3 ? y1 : y3) - bounds.y);
      }
      /**
       * @private
       */
      getDeterminant() {
        return this.a * this.d - this.b * this.c;
      }
    }

    class GUICanvas extends ComponentBase {
      isGUICanvas = true;
      index = 0;
      /**
       *
       * Add an Object3D
       * @param child Object3D
       * @returns
       */
      addChild(child) {
        this.object3D.addChild(child);
        return this;
      }
      /**
      *
      * Remove the child
      * @param child Removed Object3D
      */
      removeChild(child) {
        this.object3D.removeChild(child);
        return this;
      }
      cloneTo(obj) {
        let canvas = obj.getOrAddComponent(GUICanvas);
        canvas.copyComponent(this);
      }
      copyComponent(from) {
        from.index = from.index;
        return this;
      }
    }

    var GUIQuadAttrEnum = /* @__PURE__ */ ((GUIQuadAttrEnum2) => {
      GUIQuadAttrEnum2[GUIQuadAttrEnum2["NONE"] = 0] = "NONE";
      GUIQuadAttrEnum2[GUIQuadAttrEnum2["POSITION"] = 1] = "POSITION";
      GUIQuadAttrEnum2[GUIQuadAttrEnum2["SPRITE"] = 2] = "SPRITE";
      GUIQuadAttrEnum2[GUIQuadAttrEnum2["COLOR"] = 4] = "COLOR";
      GUIQuadAttrEnum2[GUIQuadAttrEnum2["MAX"] = 7] = "MAX";
      return GUIQuadAttrEnum2;
    })(GUIQuadAttrEnum || {});

    class GUIAttribute {
      array;
      buffer;
      constructor(count) {
        this.buffer = new StorageGPUBuffer(count, 0);
        this.array = new Float32Array(this.buffer.memory.shareDataBuffer);
      }
    }
    class GUIGeometry extends GeometryBase {
      _attributeUV;
      _attributeVIndex;
      _faceIndexes;
      _uvSize = 2;
      _vIndexSize = 1;
      _posAttribute;
      //Position data per vertex
      _spriteAttribute;
      //data per quad,texture id...
      _colorAttribute;
      //data per quad: Color
      _onPositionChange = true;
      _onSpriteChange = true;
      _onColorChange = true;
      maxQuadCount;
      /**
       * constructor
       * @param max max quad of a geometry
       * @returns GUIGeometry
       */
      constructor(max) {
        super();
        this.maxQuadCount = max;
      }
      updateSubGeometry(index, start, count) {
        let geom = this.subGeometries[index];
        if (geom) {
          let desc = geom.lodLevels[0];
          desc.indexStart = start;
          desc.indexCount = count;
          desc.index = index;
        } else {
          geom = this.addSubGeometry({
            indexStart: start,
            indexCount: count,
            vertexStart: 0,
            vertexCount: 0,
            firstStart: 0,
            index,
            topology: 0
          });
        }
        return geom;
      }
      resetSubGeometries() {
        for (let item of this.subGeometries) {
          let desc = item.lodLevels[0];
          desc.indexStart = 0;
          desc.indexCount = 0;
          desc.index = 0;
        }
      }
      /**
       * the bounds will be set to infinity
       * @returns GUIGeometry
       */
      updateBounds(min, max) {
        let halfMax = Number.MAX_VALUE * 0.1;
        min = new Vector3(-halfMax, -halfMax, -halfMax);
        max = new Vector3(halfMax, halfMax, halfMax);
        this.bounds.setFromMinMax(min, max);
        return this;
      }
      getPositionBuffer() {
        if (this._onPositionChange) {
          this._posAttribute.buffer.apply();
          this._onPositionChange = false;
        }
        return this._posAttribute.buffer;
      }
      getSpriteBuffer() {
        if (this._onSpriteChange) {
          this._spriteAttribute.buffer.apply();
          this._onSpriteChange = false;
        }
        return this._spriteAttribute.buffer;
      }
      getColorBuffer() {
        if (this._onColorChange) {
          this._colorAttribute.buffer.apply();
          this._onColorChange = false;
        }
        return this._colorAttribute.buffer;
      }
      create() {
        this.createBuffer();
        this.updateBounds();
        let quadNum = this.maxQuadCount;
        let uvList = [];
        let vIndexList = [];
        for (let i = 0; i < quadNum; i++) {
          uvList.push(...QuadStruct.attUV);
        }
        for (let i = 0, count = this.maxQuadCount * QuadStruct.vertexCount; i < count; i++) {
          vIndexList[i] = i;
        }
        this._attributeUV = new Float32Array(QuadStruct.vertexCount * quadNum * this._uvSize);
        this._attributeVIndex = new Float32Array(QuadStruct.vertexCount * quadNum * this._vIndexSize);
        this._attributeUV.set(uvList, 0);
        this._attributeVIndex.set(vIndexList, 0);
        let indexList = [];
        for (let i = 0; i < quadNum; i++) {
          for (let j = 0; j < QuadStruct.indecies.length; j++) {
            const ind = QuadStruct.indecies[j] + i * 4;
            indexList.push(ind);
          }
        }
        this._faceIndexes = new Uint32Array(quadNum * 6);
        this._faceIndexes.set(indexList, 0);
        this.setIndices(this._faceIndexes);
        this.setAttribute(VertexAttributeName.uv, this._attributeUV);
        this.setAttribute(VertexAttributeName.vIndex, this._attributeVIndex);
        this.updateSubGeometry(0, 0, this._faceIndexes.length);
        return this;
      }
      createBuffer() {
        let quadNum = this.maxQuadCount;
        this._posAttribute = new GUIAttribute(quadNum * 4);
        this._spriteAttribute = new GUIAttribute(quadNum * (4 + 4 + 2 + 2));
        this._colorAttribute = new GUIAttribute(quadNum * 4);
      }
      fillQuad(quad, transform) {
        if (quad.dirtyAttributes & GUIQuadAttrEnum.POSITION) {
          this.fillQuadPosition(quad, transform);
        }
        if (quad.dirtyAttributes & GUIQuadAttrEnum.COLOR) {
          this.fillQuadColor(quad, transform);
        }
        if (quad.dirtyAttributes & GUIQuadAttrEnum.SPRITE) {
          this.fillQuadSprite(quad, transform);
        }
      }
      fillQuadPosition(quad, transform) {
        SetBufferDataV4.setXYZW(this._posAttribute.array, quad.z, quad.left, quad.bottom, quad.right, quad.top);
        this._onPositionChange = true;
      }
      fillQuadColor(quad, transform) {
        let color = quad.color;
        let array = this._colorAttribute.array;
        SetBufferDataV4.setXYZW(array, quad.z, color.r, color.g, color.b, color.a);
        this._onColorChange = true;
      }
      fillQuadSprite(quad, transform) {
        let texture = quad.sprite;
        let uvSliceWidth = 0;
        let uvSliceHeight = 0;
        if (texture.isSliced && quad.imageType == ImageType.Sliced) {
          uvSliceWidth = texture.trimSize.x;
          uvSliceWidth = (transform.width - (texture.offsetSize.z - texture.trimSize.x)) / uvSliceWidth;
          uvSliceHeight = texture.trimSize.y;
          uvSliceHeight = (transform.height - (texture.offsetSize.w - texture.trimSize.y)) / uvSliceHeight;
        }
        let textureID = texture.guiTexture.dynamicId;
        let uvRec = texture.uvRec;
        let uvBorder = texture.uvBorder;
        let spriteArray = this._spriteAttribute.array;
        let offset = (4 + 4 + 2 + 2) * quad.z;
        spriteArray[offset + 0] = uvRec.x;
        spriteArray[offset + 1] = uvRec.y;
        spriteArray[offset + 2] = uvRec.z;
        spriteArray[offset + 3] = uvRec.w;
        spriteArray[offset + 4] = uvBorder.x;
        spriteArray[offset + 5] = uvBorder.y;
        spriteArray[offset + 6] = uvBorder.z;
        spriteArray[offset + 7] = uvBorder.w;
        spriteArray[offset + 8] = uvSliceWidth;
        spriteArray[offset + 9] = uvSliceHeight;
        spriteArray[offset + 10] = textureID;
        spriteArray[offset + 11] = quad.visible ? 1 : 0;
        this._onSpriteChange = true;
      }
    }
    class SetBufferData {
      static set(array, index, offset, stride, ...args) {
        let from = index * stride + offset;
        for (let i = 0, c = args.length; i < c; i++) {
          array[from + i] = args[i];
        }
      }
    }
    class SetBufferDataV4 extends SetBufferData {
      static setXYZW(array, index, x, y, z, w) {
        this.set(array, index, 0, 4, x, y, z, w);
      }
      static setXYZ(array, index, x, y, z) {
        this.set(array, index, 0, 4, x, y, z);
      }
      static setZ(array, index, z) {
        this.set(array, index, 3, 4, z);
      }
    }
    class QuadStruct {
      static vertexCount = 4;
      static attUV = [0, 0, 1, 0, 1, 1, 0, 1];
      static indecies = [0, 1, 2, 0, 2, 3];
    }

    class GUIGeometryRebuild {
      _textureMap = /* @__PURE__ */ new Map();
      _textureList = [];
      /**
       * Rebuild a specified GUI Mesh
       * Check and rebuild a GUI Mesh, including geometry and materials
       * @param transforms Fill in the UITransform list for the specified GUI Mesh
       * @param panel Specify the GUI Mesh object for reconstructing Geometry
       * @param forceUpdate whether need to force refactoring
       * @returns Return the build result (the maximum number of textures supported by GUIMaterials for a single UIPanel is limited and cannot exceed the limit)
       */
      build(transforms, panel, forceUpdate) {
        let geometry = panel["_geometry"];
        geometry.resetSubGeometries();
        let quadIndex = -1;
        let texIndex = 0;
        let indexStart = 0;
        let indexCount = 0;
        let geometryIndex = 0;
        let textureList = this._textureList;
        let textureMap = this._textureMap;
        function flushPanel() {
          if (indexCount > 0) {
            panel.updateDrawCallSegment(geometryIndex, indexStart, indexCount);
            let material = panel["_uiRenderer"]["materials"][geometryIndex];
            material.setTextures(textureList);
            textureMap.clear();
            textureList.length = 0;
            geometryIndex++;
            indexStart += indexCount;
            indexCount = 0;
            texIndex = 0;
          }
        }
        textureMap.clear();
        textureList.length = 0;
        let collectQuads = [];
        let zMax = panel.quadMaxCount - 1;
        for (let transform of transforms) {
          let needUpdateQuads = transform.needUpdateQuads;
          collectQuads.length = 0;
          const quads = this.collectQuads(transform.object3D, collectQuads);
          for (let quad of quads) {
            let textureSource = quad.sprite.guiTexture;
            if (!textureMap.has(textureSource.staticId)) {
              if (texIndex == 7)
                flushPanel();
              textureMap.set(textureSource.staticId, textureSource);
              textureSource.dynamicId = texIndex;
              textureList[texIndex] = textureSource.texture;
              texIndex += 1;
            }
            quad.z = ++quadIndex;
            indexCount += 6;
            if (quad.cacheTextureId != textureSource.dynamicId) {
              quad.dirtyAttributes = GUIQuadAttrEnum.MAX;
              quad.cacheTextureId = textureSource.dynamicId;
            }
            let updateAllAttr = needUpdateQuads || forceUpdate;
            if (updateAllAttr) {
              quad.dirtyAttributes = GUIQuadAttrEnum.MAX;
            }
            if (quad.dirtyAttributes & GUIQuadAttrEnum.POSITION) {
              quad.applyTransform(transform);
            }
            if (quad.dirtyAttributes) {
              quad.writeToGeometry(geometry, transform);
            }
            if (quadIndex == zMax) {
              flushPanel();
              return true;
            }
          }
        }
        flushPanel();
        return false;
      }
      collectQuads(object3D, list) {
        list ||= [];
        let components = object3D.components.values();
        for (let i of components) {
          let item = i;
          if (item.isUIShadow || !item.mainQuads)
            continue;
          let shadowRender = item.getShadowRender();
          if (shadowRender) {
            this.push(shadowRender.mainQuads, list);
          }
          this.push(item.mainQuads, list);
        }
        return list;
      }
      push(src, dst) {
        src && src.length > 0 && dst.push(...src);
      }
    }

    class GUIShader {
      static bindTextureArray() {
        let value = ``;
        for (let i = 0; i < 7; i++) {
          value += `
        @group(1) @binding(auto)
        var tex_${i}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${i}
        var tex_${i}: texture_external;
#else
        var tex_${i}: texture_2d<f32>;
#endif
`;
        }
        return value;
      }
      static sampleTexture(index) {
        return `
#if VideoTexture${index}
            let size = textureDimensions(tex_${index}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${index}, iuv) ;
#else
            color = textureSampleLevel(tex_${index}, tex_${index}Sampler, uv, 0.0);
#endif        `;
      }
      static fs = (
        /* wgsl */
        `
        ${ColorPassFragmentOutput}
        ${this.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${this.sampleTexture(0)}
            }else if(texId == 1){
                ${this.sampleTexture(1)}
            }else if(texId == 2){
                ${this.sampleTexture(2)}
            }else if(texId == 3){            
                ${this.sampleTexture(3)}
            }else if(texId == 4){            
                ${this.sampleTexture(4)}
            }else if(texId == 5){            
                ${this.sampleTexture(5)}
            }else if(texId == 6){            
                ${this.sampleTexture(6)}
            }
            color *= vColor4;
            color.a *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = color;
            return fragmentOutput ;
        }`
      );
      static GUI_common_vs = (
        /* wgsl */
        `
        ${WorldMatrixUniform}
        ${GlobalUniform}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,
            v3:vec3<f32>
        }
        
        struct VertexOutput {
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(auto) uv: vec2<f32>,
            @location(auto) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `
      );
      static GUI_shader_view = (
        /* wgsl */
        `
        ${this.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${this.fs}
        `
      );
      static GUI_shader_world = (
        /* wgsl */
        `
        ${this.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${this.fs}

        `
      );
    }

    class GUIMaterial extends Material {
      _scissorRect;
      _screenSize = new Vector2(1024, 768);
      _scissorEnable = false;
      constructor(space) {
        super();
        ShaderLib.register("GUI_shader_view", GUIShader.GUI_shader_view);
        ShaderLib.register("GUI_shader_world", GUIShader.GUI_shader_world);
        let newShader = new Shader();
        let shaderKey = space == GUISpace.View ? "GUI_shader_view" : "GUI_shader_world";
        let colorPass = new RenderShaderPass(shaderKey, shaderKey);
        colorPass.passType = PassType.COLOR;
        colorPass.setShaderEntry(`VertMain`, `FragMain`);
        colorPass.setUniformVector4("scissorRect", new Vector4());
        colorPass.setUniformVector2("screenSize", this._screenSize);
        colorPass.setUniformFloat("scissorCornerRadius", 0);
        colorPass.setUniformFloat("scissorFadeOutSize", 0);
        colorPass.setUniformFloat("pixelRatio", 1);
        colorPass.setUniformVector3("v3", Vector3.ZERO);
        let shaderState = colorPass.shaderState;
        shaderState.depthWriteEnabled = false;
        colorPass.blendMode = BlendMode.ALPHA;
        colorPass.depthCompare = space == GUISpace.View ? GPUCompareFunction.always : GPUCompareFunction.less_equal;
        colorPass.cullMode = GPUCullMode.back;
        newShader.addRenderPass(colorPass);
        this.shader = newShader;
      }
      setPanelRatio(pixelRatio) {
        this.shader.setUniformFloat("pixelRatio", pixelRatio);
      }
      setScissorRect(left, bottom, right, top) {
        this._scissorRect ||= new Vector4();
        this._scissorRect.set(left, bottom, right, top);
        this.shader.setUniformVector4("scissorRect", this._scissorRect);
      }
      setScissorEnable(value) {
        if (this._scissorEnable != value) {
          this._scissorEnable = value;
          if (value) {
            this.shader.setDefine("SCISSOR_ENABLE", true);
          } else {
            this.shader.deleteDefine("SCISSOR_ENABLE");
          }
          this.shader.noticeValueChange();
        }
      }
      setScissorCorner(radius, fadeOut) {
        this.shader.setUniformFloat("scissorCornerRadius", radius);
        this.shader.setUniformFloat("scissorFadeOutSize", fadeOut);
      }
      /**
       * Write screenSize size to the shader
       */
      setScreenSize(width, height) {
        this._screenSize.set(width, height);
        this.shader.setUniformVector2("screenSize", this._screenSize);
        return this;
      }
      /**
       * Update texture used in GUI
       */
      setTextures(list) {
        for (let i = 0; i < 7; i++) {
          let texture = list[i] || Engine3D.res.whiteTexture;
          this.shader.setTexture(`tex_${i}`, texture);
          this.setVideoTextureDefine(i, texture.isVideoTexture);
        }
      }
      _videoTextureFlags = {};
      setVideoTextureDefine(i, isVideoTexture) {
        let changed = false;
        if (isVideoTexture != this._videoTextureFlags[i]) {
          if (isVideoTexture) {
            this.shader.setDefine(`VideoTexture${i}`, true);
          } else {
            this.shader.deleteDefine(`VideoTexture${i}`);
          }
          this._videoTextureFlags[i] = isVideoTexture;
          changed = true;
        }
        if (changed) {
          this.shader.noticeValueChange();
        }
      }
      set envMap(texture) {
      }
      set shadowMap(texture) {
      }
      set baseMap(texture) {
      }
      set normalMap(value) {
      }
      set emissiveMap(value) {
      }
      set irradianceMap(value) {
      }
      set irradianceDepthMap(value) {
      }
    }

    class GUIRenderer extends exports.MeshRenderer {
      _guiGeometry;
      /**
       * init renderer
       * @returns
       */
      init(param) {
        super.init();
        this.addRendererMask(RendererMask.UI);
        this.removeRendererMask(RendererMask.Default);
        this.castGI = false;
        this.castShadow = false;
        this.alwaysRender = true;
        this._ignoreEnvMap = this._ignorePrefilterMap = true;
      }
      get geometry() {
        return super.geometry;
      }
      set geometry(value) {
        super.geometry = value;
        this._guiGeometry = value;
      }
      /**
       * @internal
       * @param view
       * @param rendererType
       * @param renderPassState
       * @param clusterLightingBuffer
       */
      nodeUpdate(view, rendererType, renderPassState, clusterLightingBuffer) {
        for (let i = 0; i < this.materials.length; i++) {
          const material = this.materials[i];
          let passes = material.getPass(rendererType);
          let vPosition = this._guiGeometry.getPositionBuffer();
          let vSprite = this._guiGeometry.getSpriteBuffer();
          let vColor = this._guiGeometry.getColorBuffer();
          if (passes) {
            for (let j = 0; j < passes.length; j++) {
              const renderShader = passes[j];
              if (!renderShader.pipeline) {
                renderShader.setStorageBuffer("vPositionBuffer", vPosition);
                renderShader.setStorageBuffer("vSpriteBuffer", vSprite);
                renderShader.setStorageBuffer("vColorBuffer", vColor);
              }
            }
          }
        }
        super.nodeUpdate(view, rendererType, renderPassState, clusterLightingBuffer);
      }
      onUpdate(view) {
      }
    }

    class PoolNode {
      _use;
      _unUse;
      constructor() {
        this._use = [];
        this._unUse = [];
      }
      pushBack(node) {
        let index = this._use.indexOf(node);
        if (index != -1) {
          this._use.splice(index, 1);
          this._unUse.push(node);
        }
      }
      getUseList() {
        return this._use;
      }
      getOne(instance, param) {
        let node;
        if (this._unUse.length > 0) {
          node = this._unUse[0];
          this._unUse.splice(0, 1);
          this._use.push(node);
          return node;
        } else {
          node = new instance(param);
          this._use.push(node);
        }
        return node;
      }
      hasFree() {
        return this._unUse.length > 0;
      }
    }

    let gui_help_mtx3;
    class GUIQuad {
      x = 0;
      y = 0;
      z = 0;
      width = 1;
      height = 1;
      _globalX = 0;
      _globalY = 0;
      _globalWidth = 0;
      _globalHeight = 0;
      _visible = true;
      _offsetX = 0;
      _offsetY = 0;
      _sprite = Engine3D.res.defaultGUISprite;
      _color = new Color(1, 1, 1, 1);
      _imageType = ImageType.Simple;
      dirtyAttributes = GUIQuadAttrEnum.MAX;
      cacheTextureId = -1;
      static textPool;
      static get quadPool() {
        this.textPool ||= new PoolNode();
        return this.textPool;
      }
      static recycleQuad(quad) {
        quad.sprite = null;
        quad.dirtyAttributes = GUIQuadAttrEnum.MAX;
        quad.x = 0;
        quad.y = 0;
        quad.z = -1;
        quad.cacheTextureId = -1;
        GUIQuad.quadPool.pushBack(quad);
      }
      static spawnQuad() {
        let quad = GUIQuad.quadPool.getOne(GUIQuad);
        return quad;
      }
      get imageType() {
        return this._imageType;
      }
      set imageType(value) {
        this._imageType = value;
        this.setAttrChange(GUIQuadAttrEnum.SPRITE | GUIQuadAttrEnum.POSITION);
      }
      get color() {
        return this._color;
      }
      set color(value) {
        this._color.copyFrom(value);
        this.setAttrChange(GUIQuadAttrEnum.COLOR);
      }
      get visible() {
        return this._visible;
      }
      set visible(value) {
        if (value != this._visible) {
          this._visible = value;
          this.setAttrChange(GUIQuadAttrEnum.SPRITE);
        }
      }
      get sprite() {
        return this._sprite;
      }
      set sprite(value) {
        if (this._sprite != value) {
          this._sprite = value;
          this.setAttrChange(GUIQuadAttrEnum.SPRITE | GUIQuadAttrEnum.POSITION);
        }
      }
      get left() {
        return this._globalX - this._offsetX;
      }
      get right() {
        return this.left + this._globalWidth;
      }
      get top() {
        return this._globalY - this._offsetY;
      }
      get bottom() {
        return this.top + this._globalHeight;
      }
      setSize(width, height) {
        this.width = width;
        this.height = height;
        this.setAttrChange(GUIQuadAttrEnum.POSITION);
      }
      setXY(x, y) {
        this.x = x;
        this.y = y;
        this.setAttrChange(GUIQuadAttrEnum.POSITION);
      }
      setAttrChange(attr) {
        this.dirtyAttributes = this.dirtyAttributes | attr;
      }
      applyTransform(transform) {
        this.setAttrChange(GUIQuadAttrEnum.POSITION);
        let item = this._sprite;
        let _worldMatrix = transform.getWorldMatrix();
        if (this.x != 0 || this.y != 0) {
          _worldMatrix = this.getQuadMatrix(_worldMatrix);
        }
        let matrixScaleX = _worldMatrix.getScaleX();
        let matrixScaleY = _worldMatrix.getScaleY();
        let isSliced = item.isSliced && this._imageType == ImageType.Sliced;
        this._offsetX = transform.width * 0.5 * matrixScaleX;
        this._offsetY = transform.height * 0.5 * matrixScaleY;
        if (isSliced) {
          this._globalWidth = matrixScaleX * (transform.width - (item.offsetSize.z - item.trimSize.x));
          this._globalHeight = matrixScaleY * (transform.height - (item.offsetSize.w - item.trimSize.y));
          this._globalX = _worldMatrix.tx + item.offsetSize.x * matrixScaleX;
          this._globalY = _worldMatrix.ty + item.offsetSize.y * matrixScaleY;
        } else {
          let transformScaleX = this.width / item.offsetSize.z;
          let transformScaleY = this.height / item.offsetSize.w;
          this._globalWidth = matrixScaleX * item.trimSize.x * transformScaleX;
          this._globalHeight = matrixScaleY * item.trimSize.y * transformScaleY;
          this._globalX = _worldMatrix.tx + item.offsetSize.x * transformScaleX * matrixScaleX;
          this._globalY = _worldMatrix.ty + item.offsetSize.y * transformScaleY * matrixScaleY;
        }
        return this;
      }
      getQuadMatrix(world) {
        gui_help_mtx3 ||= new Matrix3();
        gui_help_mtx3.identity();
        gui_help_mtx3.setTranslate(this.x, this.y);
        gui_help_mtx3.mul(world);
        return gui_help_mtx3;
      }
      writeToGeometry(guiGeometry, transform) {
        guiGeometry.fillQuad(this, transform);
        this.dirtyAttributes = GUIQuadAttrEnum.NONE;
        return this;
      }
    }

    class UIComponentBase extends ComponentBase {
      _uiTransform;
      _visible = true;
      destroy() {
        this._uiTransform.setNeedUpdateUIPanel();
        super.destroy();
      }
      get uiTransform() {
        return this._uiTransform;
      }
      get visible() {
        return this._visible;
      }
      set visible(value) {
        if (this._visible != value) {
          this._visible = value;
          this.onUIComponentVisible?.(this._visible);
        }
      }
      init(param) {
        super.init?.(param);
        this._uiTransform = this.object3D.getOrAddComponent(UITransform);
        this._uiTransform.setNeedUpdateUIPanel();
      }
      copyComponent(from) {
        this.visible = from.visible;
        return this;
      }
    }

    class UIRenderAble extends UIComponentBase {
      _mainQuads;
      _shadowRender;
      _shadowSource;
      isUIShadow;
      isShadowless;
      //no shadow
      needUpdateShadow;
      init(param) {
        super.init?.(param);
        this._mainQuads = [];
      }
      destroy() {
        this.detachQuads();
        this._shadowRender?.setShadowSource(null);
        this._shadowSource?.setShadowRenderer(null);
        super.destroy();
        this._shadowRender = null;
        this._shadowSource = null;
      }
      start() {
        super.start?.();
        if (this.isUIShadow) {
          this.autoBindShadow(null, this);
        } else if (!this.isShadowless) {
          this.autoBindShadow(this, null);
        }
        this.setShadowDirty();
      }
      setShadowDirty() {
        this._shadowRender && (this._shadowRender.needUpdateShadow = true);
      }
      get mainQuads() {
        return this._mainQuads;
      }
      setShadowRenderer(value) {
        this._shadowRender = value;
      }
      setShadowSource(value) {
        this._shadowSource = value;
      }
      getShadowRender() {
        return this._shadowRender;
      }
      autoBindShadow(source, shadow) {
        let values = this.object3D.components.values();
        if (!source) {
          for (let i of values) {
            let item = i;
            if (item.isShadowless || item.isUIShadow)
              continue;
            if (item.mainQuads) {
              source = item;
              break;
            }
          }
        }
        if (!shadow) {
          for (let i of values) {
            let item = i;
            if (item.isUIShadow && item.mainQuads) {
              shadow = item;
              break;
            }
          }
        }
        if (source && shadow) {
          source.setShadowRenderer(shadow);
          shadow.setShadowSource(source);
          return true;
        }
        return false;
      }
      recycleQuad(quad) {
        if (quad && this._mainQuads) {
          let index = this._mainQuads.indexOf(quad);
          if (index >= 0) {
            this._mainQuads.splice(index, 1);
            GUIQuad.recycleQuad(quad);
          } else {
            quad = null;
          }
        }
        return quad;
      }
      attachQuad(quad) {
        this._mainQuads && this._mainQuads.push(quad);
        return this;
      }
      detachQuads() {
        if (this._mainQuads) {
          while (this._mainQuads.length > 0) {
            let quad = this._mainQuads.shift();
            this.recycleQuad(quad);
          }
        }
        return this;
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.isUIShadow = from.isUIShadow;
        this.isShadowless = from.isShadowless;
        return this;
      }
    }

    class UIImage extends UIRenderAble {
      init(param) {
        super.init?.(param);
        this.attachQuad(GUIQuad.spawnQuad());
        this.sprite = Engine3D.res.defaultGUISprite;
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UIImage);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.sprite = from.sprite;
        this.color = from.color;
        this.imageType = from.imageType;
        return this;
      }
      set sprite(value) {
        value ||= Engine3D.res.defaultGUISprite;
        for (let quad of this._mainQuads) {
          quad.sprite = value;
          quad.setSize(this._uiTransform.width, this._uiTransform.height);
        }
        this.setShadowDirty();
      }
      onTransformResize() {
        this.applyTransformSize();
      }
      applyTransformSize() {
        for (let quad of this._mainQuads) {
          quad.setSize(this._uiTransform.width, this._uiTransform.height);
        }
        this.setShadowDirty();
      }
      get sprite() {
        return this._mainQuads[0].sprite;
      }
      onUIComponentVisible(visible) {
        this.applyComponentVisible();
      }
      onUITransformVisible(visible) {
        this.applyComponentVisible();
      }
      applyComponentVisible() {
        let isHidden = !this._visible || !this._uiTransform.globalVisible;
        for (let item of this._mainQuads) {
          item.visible = !isHidden;
        }
        this.setShadowDirty();
      }
      get color() {
        return this._mainQuads[0].color;
      }
      set color(value) {
        for (let item of this._mainQuads) {
          item.color = value;
        }
        this.setShadowDirty();
      }
      get imageType() {
        return this._mainQuads[0].imageType;
      }
      set imageType(value) {
        for (let item of this._mainQuads) {
          item.imageType = value;
        }
        this.setShadowDirty();
      }
    }

    class UIPanel extends UIImage {
      space = GUISpace.World;
      needUpdateGeometry = true;
      panelOrder = 0;
      needSortOnCameraZ;
      _billboard;
      _rebuild;
      scissorEnable = false;
      scissorCornerRadius = 0;
      scissorFadeOutSize = 0;
      _uiRenderer;
      _geometry;
      _maxCount = 128;
      panelRatio = 1;
      isUIPanel = true;
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UIPanel);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.panelOrder = from.panelOrder;
        this.needSortOnCameraZ = from.needSortOnCameraZ;
        this.cullMode = from.cullMode;
        this.billboard = from.billboard;
        this.scissorEnable = from.scissorEnable;
        this.scissorCornerRadius = from.scissorCornerRadius;
        this.scissorFadeOutSize = from.scissorFadeOutSize;
        return this;
      }
      init(param) {
        super.init(param);
        this._uiTransform.resize(webGPUContext.canvas.width, webGPUContext.canvas.height);
        this.create(this.space);
        this.visible = false;
      }
      updateDrawCallSegment(index, indexStart, indexCount) {
        this._geometry.updateSubGeometry(index, indexStart, indexCount);
        let firstMaterial = this._uiRenderer.material;
        let newMaterial = this._uiRenderer.materials[index];
        if (!newMaterial) {
          newMaterial = new GUIMaterial(this.space);
          let newMaterials = this._uiRenderer.materials.slice();
          newMaterials.push(newMaterial);
          this._uiRenderer.materials = newMaterials;
          newMaterial.cullMode = firstMaterial.cullMode;
          newMaterial.depthCompare = firstMaterial.depthCompare;
        }
      }
      create(space) {
        this._maxCount = this.space == GUISpace.World ? GUIConfig.quadMaxCountForWorld : GUIConfig.quadMaxCountForView;
        this._uiRenderer = this.object3D.addComponent(GUIRenderer);
        this._geometry = this._uiRenderer.geometry = new GUIGeometry(this._maxCount).create();
        this._uiRenderer.material = new GUIMaterial(space);
        this._uiRenderer.renderOrder = GUIConfig.SortOrderStartWorld;
        this._rebuild = new GUIGeometryRebuild();
        this.object3D.bound = new BoundingBox(new Vector3(), new Vector3(1, 1, 1).multiplyScalar(Number.MAX_VALUE * 0.1));
      }
      /**
      * Return How many Quads can a single GUIGeometry support at most
      */
      get quadMaxCount() {
        return this._maxCount;
      }
      set billboard(type) {
        if (this.space == GUISpace.View) {
          type = BillboardType.None;
        } else {
          console.warn("Cannot enable billboard in view space");
        }
        if (type == BillboardType.BillboardXYZ || type == BillboardType.BillboardY) {
          this._billboard = this.object3D.getOrAddComponent(BillboardComponent);
          this._billboard.type = type;
        } else {
          this.object3D.removeComponent(BillboardComponent);
          this._billboard = null;
        }
      }
      get billboard() {
        return this._billboard ? this._billboard.type : BillboardType.None;
      }
      set cullMode(value) {
        if (this.space == GUISpace.World) {
          for (let item of this._uiRenderer.materials) {
            item.cullMode = value;
          }
        } else {
          console.warn("Cannot change cullMode in view space");
        }
      }
      get cullMode() {
        return this._uiRenderer.material.cullMode;
      }
      onUpdate(view) {
        super.onUpdate?.(view);
        this.rebuildGUIMesh(view);
      }
      _collectTransform = [];
      rebuildGUIMesh(view) {
        let panel = this;
        let transforms = panel._collectTransform;
        transforms.length = 0;
        panel.object3D.getComponents(UITransform, transforms);
        if (transforms.length > 0) {
          panel._rebuild.build(transforms, panel, panel.needUpdateGeometry);
          for (const t of transforms) {
            t.needUpdateQuads = false;
          }
        }
        let canvas = panel.object3D.getComponentFromParent(GUICanvas);
        let canvasIndex = canvas ? canvas.index : 0;
        panel._uiRenderer.enable = transforms.length > 0;
        let renderStart = panel["isViewPanel"] ? GUIConfig.SortOrderStartView : GUIConfig.SortOrderStartWorld;
        panel._uiRenderer.renderOrder = canvasIndex * GUIConfig.SortOrderCanvasSpan + renderStart + panel.panelOrder;
        panel._uiRenderer.needSortOnCameraZ = panel.needSortOnCameraZ;
        if (this.space == GUISpace.View) {
          let sW = webGPUContext.canvas.clientWidth;
          let sH = webGPUContext.canvas.clientHeight;
          let pW = this._uiTransform.width;
          let pH = this._uiTransform.height;
          this.panelRatio = this.updateGUIPixelRatio(sW, sH, pW, pH);
        } else {
          this.panelRatio = 1;
        }
        for (let item of panel["_uiRenderer"].materials) {
          let material = item;
          material.setPanelRatio(this.panelRatio);
          material.setScreenSize(webGPUContext.canvas.clientWidth, webGPUContext.canvas.clientHeight);
          material.setScissorEnable(panel.scissorEnable);
          if (panel.scissorEnable) {
            let maskQuad = panel.mainQuads[0];
            material.setScissorRect(maskQuad.left, maskQuad.bottom, maskQuad.right, maskQuad.top);
            material.setScissorCorner(panel.scissorCornerRadius, panel.scissorFadeOutSize);
          }
        }
        panel.needUpdateGeometry = false;
      }
      updateGUIPixelRatio(sW, sH, pW, pH) {
        let xyRatioSolution = pW / pH;
        let xyRatioCurrent = sW / sH;
        let panelRatio = 1;
        if (xyRatioSolution < xyRatioCurrent) {
          panelRatio = sH / pH;
        } else {
          panelRatio = sW / pW;
        }
        return panelRatio;
      }
    }

    class ViewPanel extends UIPanel {
      isViewPanel = true;
      space = GUISpace.View;
      constructor() {
        super();
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(ViewPanel);
        component.copyComponent(this);
      }
    }

    class WorldPanel extends UIPanel {
      isWorldPanel = true;
      space = GUISpace.World;
      _depthTest = true;
      constructor() {
        super();
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(WorldPanel);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.depthTest = from.depthTest;
        return this;
      }
      get depthTest() {
        return this._depthTest;
      }
      set depthTest(value) {
        if (this._depthTest != value) {
          this._depthTest = value;
          let compare = this.depthTest ? GPUCompareFunction.less_equal : GPUCompareFunction.always;
          for (let item of this._uiRenderer.materials) {
            item.depthCompare = compare;
          }
        }
      }
    }

    let help_matrix3;
    class UITransform extends ComponentBase {
      useParentPivot = false;
      parent;
      pivotX = 0.5;
      pivotY = 0.5;
      _width = 100;
      _height = 100;
      _localVisible = true;
      _globalVisible = true;
      _uiInteractiveList;
      get uiInteractiveList() {
        return this._uiInteractiveList;
      }
      constructor() {
        super();
        this._localMatrix = new Matrix3();
        this._worldMatrix = new Matrix3();
      }
      init(param) {
        super.init(param);
        this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type, this.onTransformChange, this);
        this.onParentChange(null, this.object3D.parent?.object3D);
      }
      onTransformChange(e) {
        this.onChange = true;
      }
      addUIInteractive(item) {
        this._uiInteractiveList ||= [];
        this._uiInteractiveList.push(item);
        return this;
      }
      removeUIInteractive(item) {
        if (this._uiInteractiveList) {
          let index = this._uiInteractiveList.indexOf(item);
          if (index >= 0) {
            this._uiInteractiveList.slice(index, 1);
            return item;
          }
        }
        return null;
      }
      get globalVisible() {
        return this._globalVisible;
      }
      set visible(value) {
        if (this._localVisible != value) {
          this._localVisible = value;
          let parentGlobal = this.parent ? this.parent._globalVisible : true;
          this.onUITransformVisible(this._localVisible && parentGlobal);
        }
      }
      get visible() {
        return this._localVisible;
      }
      onUITransformVisible(global) {
        let newGlobalVisible = this._localVisible && global;
        if (newGlobalVisible != this._globalVisible) {
          this._globalVisible = newGlobalVisible;
          this.object3D.components.forEach((v, k) => {
            let ui = v;
            if (!ui.onUITransformVisible)
              return;
            if (ui == this) {
              for (let child of this.object3D.entityChildren) {
                let transform = child.getComponent(UITransform);
                if (transform) {
                  transform.onUITransformVisible(this._globalVisible);
                }
              }
            } else {
              ui.onUITransformVisible(this._globalVisible);
            }
          });
        }
      }
      onParentChange(lastParent, currentParent) {
        this.parent?.setNeedUpdateUIPanel();
        this.parent = currentParent?.getComponent(UITransform);
        this.parent?.setNeedUpdateUIPanel();
      }
      get width() {
        return this._width;
      }
      get height() {
        return this._height;
      }
      resize(width, height) {
        if (this._width != width || this._height != height) {
          this._width = width;
          this._height = height;
          this.onChange = true;
          for (let component of this.object3D.components.values()) {
            component["onTransformResize"]?.();
          }
          return true;
        }
        return false;
      }
      get x() {
        return this.object3D.x;
      }
      set x(value) {
        if (value != this.object3D.x) {
          this.object3D.x = value;
          this.onChange = true;
        }
      }
      get y() {
        return this.object3D.y;
      }
      set y(value) {
        if (value != this.object3D.y) {
          this.object3D.y = value;
          this.onChange = true;
        }
      }
      setXY(x, y) {
        let pos = this.object3D.localPosition;
        pos.set(x, y, pos.z);
        this.object3D.localPosition = pos;
        this.onChange = true;
      }
      get z() {
        return this.object3D.z;
      }
      set z(value) {
        if (value != this.object3D.z) {
          this.object3D.z = value;
          this.onChange = true;
        }
      }
      get scaleX() {
        return this.object3D.scaleX;
      }
      set scaleX(value) {
        this.onChange = true;
        this.object3D.scaleX = value;
      }
      get scaleY() {
        return this.object3D.scaleY;
      }
      set scaleY(value) {
        this.onChange = true;
        this.object3D.scaleY = value;
      }
      get scaleZ() {
        return this.object3D.scaleZ;
      }
      set scaleZ(value) {
        this.onChange = true;
        this.object3D.scaleZ = value;
      }
      _localMatrix;
      _worldMatrix;
      _onChange = true;
      needUpdateQuads = true;
      get onChange() {
        return this._onChange;
      }
      _tempTransforms = [];
      set onChange(value) {
        if (this._onChange != value) {
          this._onChange = value;
          if (value) {
            this._tempTransforms.length = 0;
            let components = this.object3D.getComponents(UITransform, this._tempTransforms, true);
            for (let component of components) {
              component._onChange = true;
              component.needUpdateQuads = true;
            }
          }
        }
      }
      onEnable() {
        this.setNeedUpdateUIPanel();
        this.onChange = true;
      }
      onDisable() {
        this.setNeedUpdateUIPanel();
        this.onChange = true;
      }
      setNeedUpdateUIPanel() {
        let panel;
        panel = this.object3D.getComponentFromParent(WorldPanel);
        if (!panel) {
          panel = this.object3D.getComponentFromParent(ViewPanel);
        }
        if (panel) {
          panel.needUpdateGeometry = true;
        }
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UITransform);
        component.visible = this.visible;
        component.x = this.x;
        component.y = this.y;
        component.z = this.z;
        component.resize(this.width, this.height);
        component.pivotX = this.pivotX;
        component.pivotY = this.pivotY;
        component.scaleX = this.scaleX;
        component.scaleY = this.scaleY;
      }
      matrix() {
        let mtx = this._localMatrix;
        let rot = this.object3D.rotationZ;
        if (this.parent) {
          mtx.updateScaleAndRotation(this.object3D.scaleX, this.object3D.scaleY, rot, rot);
          mtx.tx = this.object3D.x;
          mtx.ty = this.object3D.y;
        } else {
          mtx.updateScaleAndRotation(1, 1, 0, 0);
        }
        if (this.pivotX != 0.5 || this.pivotY != 0.5) {
          help_matrix3 ||= new Matrix3().identity();
          mtx.mul(help_matrix3.setTo(1, 0, 0, 1, -(this.pivotX - 0.5) * this.width, -(this.pivotY - 0.5) * this.height));
        }
        return mtx;
      }
      getWorldMatrix() {
        let self = this;
        let worldMtx = self._worldMatrix;
        if (!this._onChange)
          return worldMtx;
        worldMtx.copyFrom(self.matrix());
        if (self.parent) {
          worldMtx.mul(self.parent.getWorldMatrix());
        }
        self._onChange = false;
        return worldMtx;
      }
      beforeDestroy(force) {
        this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type, this.onTransformChange, this);
        super.beforeDestroy?.(force);
      }
    }

    class GUIPick {
      // The ray used for bounding box pickup
      _ray;
      _mouseCode;
      _clickEvent;
      _outEvent;
      _overEvent;
      _upEvent;
      _downEvent;
      _view;
      // private mouseMove: PointerEvent3D;
      /**
       * Initialize the pickup and call it internally during engine initialization
       */
      init(view) {
        this._view = view;
        this._ray = new Ray();
        this._clickEvent = new PointerEvent3D(PointerEvent3D.PICK_CLICK_GUI);
        this._outEvent = new PointerEvent3D(PointerEvent3D.PICK_OUT_GUI);
        this._overEvent = new PointerEvent3D(PointerEvent3D.PICK_OVER_GUI);
        this._upEvent = new PointerEvent3D(PointerEvent3D.PICK_UP_GUI);
        this._downEvent = new PointerEvent3D(PointerEvent3D.PICK_DOWN_GUI);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.onTouchDown, this, null, 1);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.onTouchUp, this, null, 1);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.onTouchMove, this, null, 1);
        Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_CLICK, this.onTouchClick, this, null, 1);
      }
      _lastDownTarget;
      _lastOverTarget;
      onTouchClick(e) {
        if (this._lastOverTarget) {
          e.stopImmediatePropagation();
        }
      }
      onTouchMove(e) {
        this._mouseCode = e.mouseCode;
        this.collectEntities();
        let ret = this.pick(this._colliderOut);
        ret && e.stopImmediatePropagation();
        let target = ret ? ret.collider : null;
        if (target != this._lastOverTarget) {
          if (this._lastOverTarget && this._lastOverTarget.enable) {
            this._lastOverTarget.mouseStyle = UIInteractiveStyle.NORMAL;
            this._outEvent.data = this._lastOverTarget;
            this._lastOverTarget.object3D.dispatchEvent(this._outEvent);
          }
          if (target) {
            target.mouseStyle = UIInteractiveStyle.OVER;
            this._overEvent.data = target;
            target.object3D.dispatchEvent(this._overEvent);
          }
          this._lastOverTarget = target;
        }
      }
      _lastDownPosition = new Vector2();
      _calcDistanceVec2 = new Vector2();
      _lastDownTime = 0;
      _clickTimeSpan = 200;
      //ms
      _clickDistanceSpan = 10;
      onTouchDown(e) {
        this._lastDownTime = Time.time;
        this._lastDownPosition.set(e.mouseX, e.mouseY);
        this._mouseCode = e.mouseCode;
        this.collectEntities();
        let ret = this.pick(this._colliderOut);
        ret && e.stopImmediatePropagation();
        let target = ret ? ret.collider : null;
        if (target) {
          target.mouseStyle = UIInteractiveStyle.DOWN;
          this._overEvent.data = target;
          target.object3D.dispatchEvent(this._overEvent);
        }
        this._lastDownTarget = target;
      }
      onTouchUp(e) {
        this._calcDistanceVec2.set(e.mouseX, e.mouseY);
        this._mouseCode = e.mouseCode;
        this.collectEntities();
        let ret = this.pick(this._colliderOut);
        ret && e.stopImmediatePropagation();
        let target = ret ? ret.collider : null;
        if (this._lastDownTarget && this._lastDownTarget.enable) {
          this._lastDownTarget.mouseStyle = UIInteractiveStyle.NORMAL;
        }
        if (target && target == this._lastDownTarget) {
          if (Time.time - this._lastDownTime <= this._clickTimeSpan) {
            this._calcDistanceVec2.set(e.mouseX, e.mouseY);
            if (this._calcDistanceVec2.distance(this._lastDownPosition) <= this._clickDistanceSpan) {
              this._clickEvent.data = { pick: target, pickInfo: ret, mouseCode: this._mouseCode };
              target.object3D.dispatchEvent(this._clickEvent);
            }
          }
        }
        this._lastDownTarget = null;
      }
      _colliderOut = [];
      _transformList = [];
      _sortWorldPanelList = [];
      _iteractive2PanelDict = /* @__PURE__ */ new Map();
      collectEntities() {
        this._colliderOut.length = 0;
        this._sortWorldPanelList.length = 0;
        this._iteractive2PanelDict.clear();
        let reversedCanvasList = this._view.canvasList.slice().reverse();
        reversedCanvasList.forEach((canvas) => {
          if (canvas && canvas.transform && canvas.transform.parent) {
            let panels = canvas.object3D.getComponentsByProperty("isUIPanel", true, true);
            panels.sort((a, b) => {
              let aOrder = a["_uiRenderer"]["__renderOrder"];
              let bOrder = b["_uiRenderer"]["__renderOrder"];
              return aOrder > bOrder ? -1 : 1;
            });
            for (let panel of panels) {
              this._transformList.length = 0;
              panel.object3D.getComponents(UITransform, this._transformList);
              this._transformList.reverse();
              for (const uiTransform of this._transformList) {
                let interactiveList = uiTransform.uiInteractiveList;
                if (interactiveList && interactiveList.length > 0) {
                  for (let item of interactiveList) {
                    this._colliderOut.push(item);
                    this._iteractive2PanelDict.set(item, panel);
                  }
                }
              }
            }
          }
        });
        return this._colliderOut;
      }
      pick(colliders) {
        this._ray = this._view.camera.screenPointToRay(Engine3D.inputSystem.mouseX, Engine3D.inputSystem.mouseY);
        let screenPos = new Vector2(Engine3D.inputSystem.mouseX, Engine3D.inputSystem.mouseY);
        let screenSize = new Vector2(webGPUContext.canvas.clientWidth, webGPUContext.canvas.clientHeight);
        let hitInfo;
        for (const iterator of colliders) {
          if (iterator.interactive && iterator.enable && iterator.interactiveVisible) {
            let panel = this._iteractive2PanelDict.get(iterator);
            hitInfo = iterator.rayPick(this._ray, panel, screenPos, screenSize);
            if (hitInfo) {
              hitInfo.collider = iterator;
              return hitInfo;
            }
          }
        }
        return null;
      }
    }

    var LineClassification = /* @__PURE__ */ ((LineClassification2) => {
      LineClassification2[LineClassification2["COLLINEAR"] = 0] = "COLLINEAR";
      LineClassification2[LineClassification2["LINES_INTERSECT"] = 1] = "LINES_INTERSECT";
      LineClassification2[LineClassification2["SEGMENTS_INTERSECT"] = 2] = "SEGMENTS_INTERSECT";
      LineClassification2[LineClassification2["A_BISECTS_B"] = 3] = "A_BISECTS_B";
      LineClassification2[LineClassification2["B_BISECTS_A"] = 4] = "B_BISECTS_A";
      LineClassification2[LineClassification2["PARALELL"] = 5] = "PARALELL";
      return LineClassification2;
    })(LineClassification || {});
    var PointClassification = /* @__PURE__ */ ((PointClassification2) => {
      PointClassification2[PointClassification2["ON_LINE"] = 0] = "ON_LINE";
      PointClassification2[PointClassification2["LEFT_SIDE"] = 1] = "LEFT_SIDE";
      PointClassification2[PointClassification2["RIGHT_SIDE"] = 2] = "RIGHT_SIDE";
      return PointClassification2;
    })(PointClassification || {});
    class Line {
      static cacluteLine0 = new Line(null, null);
      static cacluteLine1 = new Line(null, null);
      start;
      end;
      color = new Color(1, 1, 1, 1);
      _normal;
      _normalCalculated = false;
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
      set(start, end) {
        this.start = start;
        this.end = end;
      }
      getCenter() {
        let help = Vector3.HELP_0;
        this.start.subtract(this.end, help);
        help.scaleBy(0.5);
        help.add(this.end);
        return help;
      }
      inverse() {
        let tmp = this.start;
        this.start = this.end;
        this.end = tmp;
      }
      equals(l) {
        if (this.start == l.start && this.end == l.end || this.start == l.end && this.end == l.start)
          return true;
        return false;
      }
      /**
       */
      toArray() {
        return [this.start.x, this.start.y, this.start.z, this.end.x, this.end.y, this.end.z];
      }
      /**
       * @param ps
       */
      static getLines(ps) {
        let arr = [];
        for (let index = 0; index < ps.length; index++) {
          let i0 = index;
          let i1 = repeat(index + 1, ps.length);
          let p0 = ps[i0];
          let p1 = ps[i1];
          arr.push(new Line(p0, p1));
        }
        return arr;
      }
      /**
       * Determine the relationship between two straight lines
       * this line A = x0, y0 and B = x1, y1
       * other is A = x2, y2 and B = x3, y3
       * @param other compare other line
       * @param pIntersectPoint (out)Returns the intersection point of two line segments
       * @return
       */
      intersection(other, pIntersectPoint = null) {
        var denom = (other.end.z - other.start.z) * (this.end.x - this.start.x) - (other.end.x - other.start.x) * (this.end.z - this.start.z);
        var u0 = (other.end.x - other.start.x) * (this.start.z - other.start.z) - (other.end.z - other.start.z) * (this.start.x - other.start.x);
        var u1 = (other.start.x - this.start.x) * (this.end.z - this.start.z) - (other.start.z - this.start.z) * (this.end.x - this.start.x);
        if (denom == 0) {
          if (u0 == 0 && u1 == 0)
            return 0 /* COLLINEAR */;
          else
            return 5 /* PARALELL */;
        } else {
          u0 = u0 / denom;
          u1 = u1 / denom;
          var x = this.start.x + u0 * (this.end.x - this.start.x);
          var z = this.start.z + u0 * (this.end.z - this.start.z);
          if (pIntersectPoint != null) {
            pIntersectPoint.x = x;
            pIntersectPoint.y = 0;
            pIntersectPoint.z = z;
          }
          if (u0 >= 0 && u0 <= 1 && u1 >= 0 && u1 <= 1) {
            return 2 /* SEGMENTS_INTERSECT */;
          } else if (u1 >= 0 && u1 <= 1) {
            return 3 /* A_BISECTS_B */;
          } else if (u0 >= 0 && u0 <= 1) {
            return 4 /* B_BISECTS_A */;
          }
          return 1 /* LINES_INTERSECT */;
        }
      }
      /**
       * Straight direction
       * @return
       */
      getDirection() {
        var pt = this.end.subtract(this.start);
        var direction = new Vector3(pt.x, pt.y);
        return direction.normalize();
      }
      copyFrom(line) {
        if (!this.start)
          this.start = new Vector3();
        if (!this.end)
          this.end = new Vector3();
        this.start.copyFrom(line.start);
        this.end.copyFrom(line.end);
      }
      static IsEqual(d1, d2) {
        if (Math.abs(d1 - d2) < 1e-7)
          return true;
        return false;
      }
      static squreDistanceSegmentToSegment(lineA, lineB, mat) {
        let a_po = lineA.start;
        let a_p1 = lineA.end;
        let b_po = lineB.start;
        let b_p1 = lineB.end;
        let x1 = a_po.x;
        let y1 = a_po.y;
        let z1 = a_po.z;
        let x2 = a_p1.x;
        let y2 = a_p1.y;
        let z2 = a_p1.z;
        let x3 = b_po.x;
        let y3 = b_po.y;
        let z3 = b_po.z;
        let x4 = b_p1.x;
        let y4 = b_p1.y;
        let z4 = b_p1.z;
        let ux = x2 - x1;
        let uy = y2 - y1;
        let uz = z2 - z1;
        let vx = x4 - x3;
        let vy = y4 - y3;
        let vz = z4 - z3;
        let wx = x1 - x3;
        let wy = y1 - y3;
        let wz = z1 - z3;
        let a = ux * ux + uy * uy + uz * uz;
        let b = ux * vx + uy * vy + uz * vz;
        let c = vx * vx + vy * vy + vz * vz;
        let d = ux * wx + uy * wy + uz * wz;
        let e = vx * wx + vy * wy + vz * wz;
        let dt = a * c - b * b;
        let sd = dt;
        let td = dt;
        let sn = 0;
        let tn = 0;
        if (this.IsEqual(dt, 0)) {
          sn = 0;
          sd = 1;
          tn = e;
          td = c;
        } else {
          sn = b * e - c * d;
          tn = a * e - b * d;
          if (sn < 0) {
            sn = 0;
            tn = e;
            td = c;
          } else if (sn > sd) {
            sn = sd;
            tn = e + b;
            td = c;
          }
        }
        if (tn < 0) {
          tn = 0;
          if (-d < 0)
            sn = 0;
          else if (-d > a)
            sn = sd;
          else {
            sn = -d;
            sd = a;
          }
        } else if (tn > td) {
          tn = td;
          if (-d + b < 0)
            sn = 0;
          else if (-d + b > a)
            sn = sd;
          else {
            sn = -d + b;
            sd = a;
          }
        }
        let sc = 0;
        let tc = 0;
        if (this.IsEqual(sn, 0))
          sc = 0;
        else
          sc = sn / sd;
        if (this.IsEqual(tn, 0))
          tc = 0;
        else
          tc = tn / td;
        let dx = wx + sc * ux - tc * vx;
        let dy = wy + sc * uy - tc * vy;
        let dz = wz + sc * uz - tc * vz;
        return dx * dx + dy * dy + dz * dz;
      }
      /**
       * isNearLine
       */
      isNear(ray, maxDistance = 0, mat) {
        let tmpP0 = Vector3.HELP_0;
        let tmpP1 = Vector3.HELP_1;
        tmpP0.copyFrom(ray.origin);
        tmpP1.copyFrom(ray.direction);
        tmpP1.scaleBy(9999);
        tmpP1.add(tmpP0, tmpP1);
        Line.cacluteLine0.set(tmpP0, tmpP1);
        Line.cacluteLine1.copyFrom(this);
        if (mat) {
          mat.perspectiveMultiplyPoint3(Line.cacluteLine1.start, Line.cacluteLine1.start);
          mat.perspectiveMultiplyPoint3(Line.cacluteLine1.end, Line.cacluteLine1.end);
        }
        let dis = Line.squreDistanceSegmentToSegment(Line.cacluteLine0, Line.cacluteLine1, mat);
        if (dis + 1e-4 <= maxDistance) {
          ray.length = dis;
          return true;
        }
        ray.length = -999999;
        return false;
      }
    }

    class Triangle {
      static ID = -1;
      v1;
      v2;
      v3;
      u1;
      u2;
      u3;
      n1;
      n2;
      n3;
      t0;
      t;
      u;
      v;
      min = new Vector3();
      max = new Vector3();
      id = 0;
      constructor(v1, v2, v3) {
        this.id = Triangle.ID++ + 200;
        v1 && v2 && v3 && this.set(v1, v2, v3);
      }
      set(v1, v2, v3) {
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
        let min = this.min;
        let max = this.max;
        min.x = Math.min(this.v1.x, this.v2.x, this.v3.x);
        min.y = Math.min(this.v1.y, this.v2.y, this.v3.y);
        min.z = Math.min(this.v1.z, this.v2.z, this.v3.z);
        max.x = Math.max(this.v1.x, this.v2.x, this.v3.x);
        max.y = Math.max(this.v1.y, this.v2.y, this.v3.y);
        max.z = Math.max(this.v1.z, this.v2.z, this.v3.z);
        return this;
      }
      getNormal() {
        let v1 = this.v1;
        let v2 = this.v2;
        let v3 = this.v3;
        let edge1 = new Vector3(v2.x - v1.x, v2.y - v1.y, v2.z - v1.z);
        let edge2 = new Vector3(v3.x - v1.x, v3.y - v1.y, v3.z - v1.z);
        let normal = edge2.crossProduct(edge1);
        normal.normalize();
        return normal;
      }
      turnBack() {
        let tmp = this.v3;
        this.v3 = this.v1;
        this.v1 = tmp;
      }
      getLines() {
        let v1 = this.v1;
        let v2 = this.v2;
        let v3 = this.v3;
        let l = [new Line(v1, v2), new Line(v2, v3), new Line(v3, v1)];
        return l;
      }
      equals(t) {
        let lines1 = this.getLines();
        let lines2 = t.getLines();
        let cnt = 0;
        for (let i = 0; i < lines1.length; i++) {
          for (let j = 0; j < lines2.length; j++) {
            if (lines1[i].equals(lines2[j]))
              cnt++;
          }
        }
        if (cnt == 3)
          return true;
        else
          return false;
      }
      /**
       * name
       */
      getCenter() {
        let min = this.min;
        let max = this.max;
        let center = new Vector3();
        center.x = (min.x + max.x) * 0.5;
        center.y = (min.y + max.y) * 0.5;
        center.z = (min.z + max.z) * 0.5;
        return center;
      }
      /**
       * @function
       * @returns {Boolean} return intersection.
       */
      intersects(other) {
        var aMax = this.max;
        var aMin = this.min;
        var bMax = other.max;
        var bMin = other.min;
        return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
      }
      sign2D(p1, p2, p3) {
        return (p1.x - p3.x) * (p2.z - p3.z) - (p2.x - p3.x) * (p1.z - p3.z);
      }
      pointInTriangle2D(pt) {
        let v1 = this.v1;
        let v2 = this.v2;
        let v3 = this.v3;
        let d1, d2, d3;
        let has_neg, has_pos;
        d1 = this.sign2D(pt, v1, v2);
        d2 = this.sign2D(pt, v2, v3);
        d3 = this.sign2D(pt, v3, v1);
        has_neg = d1 < 0 || d2 < 0 || d3 < 0;
        has_pos = d1 > 0 || d2 > 0 || d3 > 0;
        return !(has_neg && has_pos);
      }
      toArray() {
        return [this.v1.x, this.v1.y, this.v1.z, this.v2.x, this.v2.y, this.v2.z, this.v3.x, this.v3.y, this.v3.z];
      }
    }

    class GUIPickHelper {
      static _pt0;
      static _pt1;
      static _pt2;
      static _pt3;
      static _hitPoint;
      static _worldMatrix;
      static _ray;
      static _triangle;
      static _isInit;
      static init() {
        this._pt0 = new Vector3();
        this._pt1 = new Vector3();
        this._pt2 = new Vector3();
        this._pt3 = new Vector3();
        this._ray = new Ray();
        this._triangle = new Triangle();
        this._hitPoint = new Vector3();
        this._worldMatrix = new Matrix4();
      }
      static rayPick(ray, screenPos, screenSize, space, panelRatio, uiTransform, worldMatrix) {
        if (!this._isInit) {
          this.init();
          this._isInit = true;
        }
        let helpMatrix = this._worldMatrix;
        if (space == GUISpace.World) {
          let pickPoint;
          this.calculateHotArea_World(uiTransform, this._pt0, this._pt1, this._pt2, this._pt3);
          helpMatrix.copyFrom(worldMatrix).invert();
          let helpRay = this._ray;
          helpRay.copy(ray).applyMatrix(helpMatrix);
          this._triangle.set(this._pt0, this._pt1, this._pt2);
          pickPoint = helpRay.intersectTriangle(helpRay.origin, helpRay.direction, this._triangle);
          if (!pickPoint) {
            this._triangle.set(this._pt1, this._pt2, this._pt3);
            pickPoint = helpRay.intersectTriangle(helpRay.origin, helpRay.direction, this._triangle);
          }
          if (pickPoint) {
            return {
              distance: 0,
              intersectPoint: pickPoint
            };
          }
        } else {
          this.calculateHotArea_View(uiTransform, panelRatio, this._pt0, this._pt1, this._pt2, this._pt3);
          let screenSizeX = screenSize.x;
          let screenSizeY = screenSize.y;
          let minX = Math.min(this._pt0.x, this._pt1.x, this._pt2.x, this._pt3.x) + screenSizeX * 0.5;
          let minY = Math.min(this._pt0.y, this._pt1.y, this._pt2.y, this._pt3.y) + screenSizeY * 0.5;
          let maxX = Math.max(this._pt0.x, this._pt1.x, this._pt2.x, this._pt3.x) + screenSizeX * 0.5;
          let maxY = Math.max(this._pt0.y, this._pt1.y, this._pt2.y, this._pt3.y) + screenSizeY * 0.5;
          let pick = screenPos.x <= maxX && screenPos.x >= minX && screenPos.y <= maxY && screenPos.y >= minY;
          if (pick) {
            this._hitPoint.set(screenPos.x, screenPos.y, 0);
            return {
              distance: 0,
              intersectPoint: this._hitPoint
            };
          }
          return null;
        }
        return null;
      }
      static calculateHotArea_View(transform, panelRatio, pt0, pt1, pt2, pt3) {
        let uiMtx = transform.getWorldMatrix();
        let scaleX = uiMtx.getScaleX();
        let scaleY = uiMtx.getScaleY();
        let w = transform.width * 0.5 * scaleX;
        let h = transform.height * 0.5 * scaleY;
        pt0.set(-w, -h, 0);
        pt1.set(w, -h, 0);
        pt2.set(-w, h, 0);
        pt3.set(w, h, 0);
        let offset = uiMtx.tx;
        pt0.x += offset;
        pt1.x += offset;
        pt2.x += offset;
        pt3.x += offset;
        offset = uiMtx.ty;
        pt0.y -= offset;
        pt1.y -= offset;
        pt2.y -= offset;
        pt3.y -= offset;
        pt0.multiplyScalar(panelRatio);
        pt1.multiplyScalar(panelRatio);
        pt2.multiplyScalar(panelRatio);
        pt3.multiplyScalar(panelRatio);
      }
      static calculateHotArea_World(transform, pt0, pt1, pt2, pt3) {
        let uiMtx = transform.getWorldMatrix();
        let scaleX = uiMtx.getScaleX();
        let scaleY = uiMtx.getScaleY();
        let w = transform.width * 0.5 * scaleX;
        let h = transform.height * 0.5 * scaleY;
        pt0.set(-w, h, 0);
        pt1.set(w, h, 0);
        pt2.set(-w, -h, 0);
        pt3.set(w, -h, 0);
        let offset = uiMtx.tx;
        pt0.x += offset;
        pt1.x += offset;
        pt2.x += offset;
        pt3.x += offset;
        offset = uiMtx.ty;
        pt0.y += offset;
        pt1.y += offset;
        pt2.y += offset;
        pt3.y += offset;
      }
    }

    var TextAnchor = /* @__PURE__ */ ((TextAnchor2) => {
      TextAnchor2[TextAnchor2["UpperLeft"] = 0] = "UpperLeft";
      TextAnchor2[TextAnchor2["UpperCenter"] = 1] = "UpperCenter";
      TextAnchor2[TextAnchor2["UpperRight"] = 2] = "UpperRight";
      TextAnchor2[TextAnchor2["MiddleLeft"] = 3] = "MiddleLeft";
      TextAnchor2[TextAnchor2["MiddleCenter"] = 4] = "MiddleCenter";
      TextAnchor2[TextAnchor2["MiddleRight"] = 5] = "MiddleRight";
      TextAnchor2[TextAnchor2["LowerLeft"] = 6] = "LowerLeft";
      TextAnchor2[TextAnchor2["LowerCenter"] = 7] = "LowerCenter";
      TextAnchor2[TextAnchor2["LowerRight"] = 8] = "LowerRight";
      return TextAnchor2;
    })(TextAnchor || {});
    var Vertical = /* @__PURE__ */ ((Vertical2) => {
      Vertical2[Vertical2["Upper"] = 0] = "Upper";
      Vertical2[Vertical2["Middle"] = 1] = "Middle";
      Vertical2[Vertical2["Lower"] = 2] = "Lower";
      return Vertical2;
    })(Vertical || {});
    var Horizontal = /* @__PURE__ */ ((Horizontal2) => {
      Horizontal2[Horizontal2["Left"] = 0] = "Left";
      Horizontal2[Horizontal2["Center"] = 1] = "Center";
      Horizontal2[Horizontal2["Right"] = 2] = "Right";
      return Horizontal2;
    })(Horizontal || {});
    class TextFieldLine {
      charList = [];
      quadList = [];
      width = 0;
      index = 0;
    }
    class TextFieldLayout {
      layout(target) {
        let lineList = [];
        let originSize = target.originSize;
        let fontData = fonts.getFontData(target.font, originSize);
        let realSize = target.fontSize / originSize;
        this.makeTextLine(target.uiTransform, target.alignment, lineList, target.font, fontData, target.text, realSize, originSize, target.lineSpacing);
        return lineList;
      }
      makeTextLine(transform, alignment, lineList, fontName, fontData, text, realSize, originSize, lineSpacing) {
        let curLineIndex = -1;
        let offsetX = 0;
        let unitSize = originSize * realSize;
        let halfUnitSize = unitSize * 0.5;
        let maxTextWidthReal = transform.width / realSize;
        let maxTextHeightReal = transform.height / realSize;
        let transformOffsetX = 0;
        let transformOffsetY = transform.height;
        let makeLine = () => {
          offsetX = 0;
          curLineIndex++;
          let line = new TextFieldLine();
          line.index = curLineIndex;
          lineList.push(line);
          return line;
        };
        let makeQuad = (char, line) => {
          const code = char.charCodeAt(0).toString();
          let charSprite = fonts.getFnt(fontName, originSize, code);
          let quad = null;
          if (charSprite) {
            quad = GUIQuad.spawnQuad();
            quad.sprite = charSprite;
            quad.x = (offsetX + charSprite.xoffset) * realSize - transformOffsetX;
            quad.y = (fontData.base - charSprite.height - charSprite.yoffset - fontData.base) * realSize + transformOffsetY;
            quad.width = charSprite.offsetSize.width * realSize;
            quad.height = charSprite.offsetSize.height * realSize;
            offsetX += charSprite.xadvance;
          } else {
            if (char == "\n") ; else if (char == "	") {
              offsetX += unitSize;
            } else {
              offsetX += halfUnitSize;
            }
          }
          line.width = offsetX;
          line.quadList.push(quad);
          line.charList.push(char);
          return quad;
        };
        let alignTextLine = () => {
          let tuple = this.getAlignment(alignment);
          switch (tuple.v) {
            case 0 /* Upper */:
              for (let i = 0, countI = lineList.length; i < countI; i++) {
                let line = lineList[i];
                if (i > 0) {
                  let lineOffsetY = i * unitSize * lineSpacing;
                  for (let j = 0, countJ = line.quadList.length; j < countJ; j++) {
                    let quad = line.quadList[j];
                    if (quad) {
                      quad.y -= lineOffsetY;
                    }
                  }
                }
              }
              break;
            case 1 /* Middle */:
              for (let i = 0, countI = lineList.length; i < countI; i++) {
                let line = lineList[i];
                let lineOffsetY = (maxTextHeightReal - countI * originSize * lineSpacing) * 0.5 * realSize + i * unitSize * lineSpacing;
                for (let j = 0, countJ = line.quadList.length; j < countJ; j++) {
                  let quad = line.quadList[j];
                  if (quad) {
                    quad.y -= lineOffsetY;
                  }
                }
              }
              break;
            case 2 /* Lower */:
              for (let i = 0, countI = lineList.length; i < countI; i++) {
                let line = lineList[i];
                let lineOffsetY = (maxTextHeightReal - countI * originSize * lineSpacing) * realSize + i * unitSize * lineSpacing;
                for (let j = 0, countJ = line.quadList.length; j < countJ; j++) {
                  let quad = line.quadList[j];
                  if (quad) {
                    quad.y -= lineOffsetY;
                  }
                }
              }
              break;
          }
          switch (tuple.h) {
            case 0 /* Left */:
              break;
            case 1 /* Center */:
              for (let i = 0, countI = lineList.length; i < countI; i++) {
                let line = lineList[i];
                let lineOffsetX = (maxTextWidthReal - line.width) * 0.5 * realSize;
                for (let j = 0, countJ = line.quadList.length; j < countJ; j++) {
                  let quad = line.quadList[j];
                  if (quad) {
                    quad.x += lineOffsetX;
                  }
                }
              }
              break;
            case 2 /* Right */:
              for (let i = 0, countI = lineList.length; i < countI; i++) {
                let line = lineList[i];
                let lineOffsetX = (maxTextWidthReal - line.width) * realSize;
                for (let j = 0, countJ = line.quadList.length; j < countJ; j++) {
                  let quad = line.quadList[j];
                  if (quad) {
                    quad.x += lineOffsetX;
                  }
                }
              }
              break;
          }
        };
        let parseText = () => {
          let curLine = null;
          let totalLength = text.length;
          for (let i = 0; i < totalLength; i++) {
            curLine ||= makeLine();
            let char = text.charAt(i);
            if (char == "\n" || char == "	") {
              curLine = null;
            } else {
              makeQuad(char, curLine);
              let autoWrap = curLine.width + halfUnitSize >= maxTextWidthReal;
              if (autoWrap) {
                curLine = makeLine();
              }
            }
          }
        };
        parseText();
        alignTextLine();
      }
      getAlignment(alignment) {
        let ret = { v: 0 /* Upper */, h: 0 /* Left */ };
        switch (alignment) {
          case 1 /* UpperCenter */:
            ret.v = 0 /* Upper */;
            ret.h = 1 /* Center */;
            break;
          case 0 /* UpperLeft */:
            ret.v = 0 /* Upper */;
            ret.h = 0 /* Left */;
            break;
          case 2 /* UpperRight */:
            ret.v = 0 /* Upper */;
            ret.h = 2 /* Right */;
            break;
          case 4 /* MiddleCenter */:
            ret.v = 1 /* Middle */;
            ret.h = 1 /* Center */;
            break;
          case 3 /* MiddleLeft */:
            ret.v = 1 /* Middle */;
            ret.h = 0 /* Left */;
            break;
          case 5 /* MiddleRight */:
            ret.v = 1 /* Middle */;
            ret.h = 2 /* Right */;
            break;
          case 7 /* LowerCenter */:
            ret.v = 2 /* Lower */;
            ret.h = 1 /* Center */;
            break;
          case 6 /* LowerLeft */:
            ret.v = 2 /* Lower */;
            ret.h = 0 /* Left */;
            break;
          case 8 /* LowerRight */:
            ret.v = 2 /* Lower */;
            ret.h = 2 /* Right */;
            break;
        }
        return ret;
      }
    }

    class UIInteractive extends UIComponentBase {
      _style = UIInteractiveStyle.NORMAL;
      _interactive = false;
      set interactive(value) {
        this._interactive = value;
      }
      get interactive() {
        return this._interactive;
      }
      set mouseStyle(value) {
        this._style = value;
      }
      get interactiveVisible() {
        return this._uiTransform.globalVisible && this._visible;
      }
      init(param) {
        super.init(param);
        this._uiTransform.addUIInteractive(this);
      }
      destroy() {
        this._uiTransform.removeUIInteractive(this);
        super.destroy();
      }
      rayPick(ray, panel, screenPos, screenSize) {
        return GUIPickHelper.rayPick(ray, screenPos, screenSize, panel.space, panel.panelRatio, this._uiTransform, panel.transform.worldMatrix);
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UIInteractive);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.enable = from._enable;
        this.interactive = from._interactive;
        this.mouseStyle = from._style;
        return this;
      }
    }

    var UIButtonTransition = /* @__PURE__ */ ((UIButtonTransition2) => {
      UIButtonTransition2[UIButtonTransition2["NONE"] = 0] = "NONE";
      UIButtonTransition2[UIButtonTransition2["COLOR"] = 1] = "COLOR";
      UIButtonTransition2[UIButtonTransition2["SPRITE"] = 2] = "SPRITE";
      return UIButtonTransition2;
    })(UIButtonTransition || {});
    class UIButton extends UIInteractive {
      _spriteMap;
      _colorMap;
      _image;
      _isCreateImage;
      _transition = 2 /* SPRITE */;
      init(param) {
        super.init(param);
        this._interactive = true;
        this._spriteMap = /* @__PURE__ */ new Map();
        this._colorMap = /* @__PURE__ */ new Map();
        this._image = this.object3D.getComponent(UIImage);
        this._isCreateImage = this._image == null;
        if (!this._image) {
          this._image = this.object3D.addComponent(UIImage);
        }
        this.imageType = ImageType.Sliced;
      }
      onEnable() {
        this.mouseStyle = UIInteractiveStyle.NORMAL;
      }
      onDisable() {
        this.mouseStyle = UIInteractiveStyle.DISABLE;
      }
      set transition(value) {
        if (this._transition != value) {
          this._transition = value;
          this.validateStyle(this._style, true);
        }
      }
      get transition() {
        return this._transition;
      }
      get imageType() {
        return this._image.imageType;
      }
      set imageType(value) {
        this._image.imageType = value;
      }
      setStyleColor(style, color) {
        this._colorMap.set(style, color);
        if (this._style == style) {
          this.validateStyle(this._style, true);
        }
        return this;
      }
      getStyleColor(style) {
        return this._colorMap.get(style);
      }
      set mouseStyle(value) {
        super.mouseStyle = value;
        this.validateStyle(value, true);
      }
      get normalSprite() {
        return this._spriteMap.get(UIInteractiveStyle.NORMAL);
      }
      set normalSprite(value) {
        this._spriteMap.set(UIInteractiveStyle.NORMAL, value);
        if (this._style == UIInteractiveStyle.NORMAL) {
          this.validateStyle(this._style, true);
        }
      }
      get overSprite() {
        return this._spriteMap.get(UIInteractiveStyle.OVER);
      }
      set overSprite(value) {
        this._spriteMap.set(UIInteractiveStyle.OVER, value);
        if (this._style == UIInteractiveStyle.OVER) {
          this.validateStyle(this._style, true);
        }
      }
      set downSprite(value) {
        this._spriteMap.set(UIInteractiveStyle.DOWN, value);
        if (this._style == UIInteractiveStyle.DOWN) {
          this.validateStyle(this._style, true);
        }
      }
      get downSprite() {
        return this._spriteMap.get(UIInteractiveStyle.DOWN);
      }
      set disableSprite(value) {
        this._spriteMap.set(UIInteractiveStyle.DISABLE, value);
        if (this._style == UIInteractiveStyle.DISABLE) {
          this.validateStyle(this._style, true);
        }
      }
      get disableSprite() {
        return this._spriteMap.get(UIInteractiveStyle.DISABLE);
      }
      validateStyle(style, force) {
        if (this._transition & 2 /* SPRITE */) {
          let texture = this._spriteMap.get(style);
          this._image.sprite = texture;
        }
        if (this._transition & 1 /* COLOR */) {
          let color = this._colorMap.get(style);
          color && (this._image.color = color);
        }
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UIButton);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this.imageType = from.imageType;
        this.transition = from.transition;
        from._spriteMap.forEach((v, k) => {
          v && this._spriteMap.set(k, v);
        });
        from._colorMap.forEach((v, k) => {
          v && this._colorMap.set(k, v.clone());
        });
        this.mouseStyle = from.mouseStyle;
        return this;
      }
      destroy() {
        if (this._isCreateImage && this._image) {
          this.object3D.removeComponent(UIImage);
          this._image = null;
        }
        super.destroy();
      }
    }

    class UIImageGroup extends UIRenderAble {
      _count = 0;
      constructor() {
        super();
      }
      init(param) {
        super.init?.(param);
        this._count = param ? param.count : 1;
        for (let i = 0; i < this._count; i++) {
          this.attachQuad(GUIQuad.spawnQuad());
        }
        this._uiTransform.resize(0, 0);
      }
      getQuad(index) {
        return this._mainQuads[index];
      }
      cloneTo(obj) {
        let component = obj.addComponent(UIImageGroup, { count: this._count });
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        for (let i = 0; i < from._count; i++) {
          this.setSprite(i, from.getSprite(i));
          this.setColor(i, from.getColor(i));
          this.setImageType(i, from.getImageType(i));
        }
        return this;
      }
      setSprite(index, value) {
        this._mainQuads[index].sprite = value || Engine3D.res.defaultGUISprite;
        this.setShadowDirty();
      }
      getSprite(index) {
        return this._mainQuads[index].sprite;
      }
      onUIComponentVisible(visible) {
        this.applyComponentVisible();
      }
      onUITransformVisible(visible) {
        this.applyComponentVisible();
      }
      applyComponentVisible() {
        let isHidden = !this._visible || !this._uiTransform.globalVisible;
        for (let item of this._mainQuads) {
          item.visible = !isHidden;
        }
        this.setShadowDirty();
      }
      getColor(index) {
        return this._mainQuads[index].color;
      }
      setColor(index, value) {
        this._mainQuads[index].color = value;
        this.setShadowDirty();
      }
      getImageType(index) {
        return this._mainQuads[index].imageType;
      }
      setImageType(index, value) {
        this._mainQuads[index].imageType = value;
        this.setShadowDirty();
      }
      setSize(index, width, height) {
        this._mainQuads[index].setSize(width, height);
        this.setShadowDirty();
      }
      setXY(index, x, y) {
        this._mainQuads[index].setXY(x, y);
        this.setShadowDirty();
      }
      getXY(index, ret) {
        ret ||= new Vector2();
        let quad = this._mainQuads[index];
        ret.x = quad.x;
        ret.y = quad.y;
        return ret;
      }
    }

    class UIShadow extends UIRenderAble {
      _shadowQuality = 1;
      _shadowOffset;
      _shadowRadius;
      _shadowColor;
      _subShadowColor;
      needUpdateShadow = false;
      init(param) {
        super.init?.(param);
        this._shadowRadius = 2;
        this._shadowQuality = 1;
        this._shadowOffset = new Vector2(4, -4);
        this._shadowColor = new Color(0.1, 0.1, 0.1, 0.8);
        this._subShadowColor = this._shadowColor.clone();
        this.isUIShadow = true;
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UIShadow);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(this);
        this._shadowColor = from._shadowColor;
        this._shadowOffset = from._shadowOffset;
        this._shadowRadius = from._shadowRadius;
        this._shadowQuality = from.shadowQuality;
        return this;
      }
      get shadowColor() {
        return this._shadowColor;
      }
      set shadowColor(value) {
        this._shadowColor.copyFrom(value);
        this.needUpdateShadow = true;
      }
      set shadowQuality(value) {
        value = clamp(value, 0, 4);
        if (this._shadowQuality != value) {
          this._shadowQuality = value;
          this.needUpdateShadow = true;
        }
      }
      get shadowQuality() {
        return this._shadowQuality;
      }
      set shadowOffset(value) {
        this._shadowOffset = value;
        this.needUpdateShadow = true;
      }
      get shadowOffset() {
        this._shadowOffset ||= new Vector2(4, -4);
        return this._shadowOffset;
      }
      set shadowRadius(value) {
        if (this._shadowRadius != value) {
          this._shadowRadius = value;
          this.applyShadow();
        }
      }
      get shadowRadius() {
        return this._shadowRadius;
      }
      onUpdate(view) {
        if (this.needUpdateShadow) {
          this.applyShadow();
          this.needUpdateShadow = false;
        }
      }
      applyShadow() {
        this.detachQuads();
        if (this._shadowSource) {
          if (this._shadowQuality > 0) {
            let quads = this._shadowSource.mainQuads;
            if (quads.length > 0) {
              for (let quad of quads) {
                this.createQuadShadow(quad);
              }
            }
          }
        }
        this._uiTransform.setNeedUpdateUIPanel();
      }
      createQuadShadow(sourceQuad) {
        let shadowCount = this._shadowQuality;
        let pi2 = Math.PI * 2;
        this._subShadowColor.copyFrom(this._shadowColor);
        this._subShadowColor.a = 1 / Math.max(1, shadowCount);
        for (let i = 0; i < shadowCount; i++) {
          let item = GUIQuad.spawnQuad();
          let offsetX = 0;
          let offsetY = 0;
          if (i == 0) {
            item.color = this._shadowColor;
          } else {
            let angle = pi2 * (i - 1) / (shadowCount - 1);
            offsetX = Math.sin(angle) * this._shadowRadius;
            offsetY = Math.cos(angle) * this._shadowRadius;
            item.color = this._subShadowColor;
          }
          item.setXY(offsetX + this._shadowOffset.x + sourceQuad.x, offsetY + this._shadowOffset.y + sourceQuad.y);
          item.setSize(sourceQuad.width, sourceQuad.height);
          item.sprite = sourceQuad.sprite;
          item.visible = sourceQuad.visible;
          item.imageType = sourceQuad.imageType;
          this.attachQuad(item);
        }
      }
    }

    class UITextField extends UIRenderAble {
      _font = "微软雅黑";
      _fontSize = 14;
      _originSize = 42;
      _alignment = 0;
      _lineSpacing = 1;
      _text = "";
      _color = new Color(1, 1, 1, 1);
      constructor() {
        super();
      }
      cloneTo(obj) {
        let component = obj.getOrAddComponent(UITextField);
        component.copyComponent(this);
      }
      copyComponent(from) {
        super.copyComponent(from);
        this._font = from._font;
        this._fontSize = from._fontSize;
        this._originSize = from._originSize;
        this._alignment = from._alignment;
        this._lineSpacing = from._lineSpacing;
        this._color.copyFrom(from._color);
        this.text = from.text;
        return this;
      }
      get originSize() {
        return this._originSize;
      }
      get font() {
        return this._font;
      }
      set font(value) {
        this._font = value;
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        if (this._fontSize != value) {
          this._fontSize = value;
          this.layoutText();
        }
      }
      get text() {
        return this._text;
      }
      set text(value) {
        if (this._text != value) {
          if (!value)
            value = "";
          this._text = value;
          this.layoutText();
        }
      }
      textLine = null;
      layoutProxy = new TextFieldLayout();
      layoutText() {
        this.detachQuads();
        this.textLine = this.layoutProxy.layout(this);
        for (let i = 0, count = this.textLine.length; i < count; i++) {
          let line = this.textLine[i];
          for (let j = 0, count2 = line.quadList.length; j < count2; j++) {
            let quad = line.quadList[j];
            if (quad) {
              this.attachQuad(quad);
            }
          }
        }
        this.color = this._color;
        this._uiTransform.setNeedUpdateUIPanel();
        this.onUIComponentVisible(this._visible);
        this.setShadowDirty();
      }
      onUIComponentVisible(visible) {
        this.applyComponentVisible();
      }
      onUITransformVisible(visible) {
        this.applyComponentVisible();
      }
      applyComponentVisible() {
        let isHidden = !this._visible || !this._uiTransform.globalVisible;
        for (let quad of this._mainQuads) {
          quad && (quad.visible = !isHidden);
        }
        this.setShadowDirty();
      }
      onTransformResize() {
        this.layoutText();
      }
      get color() {
        return this._color;
      }
      set color(value) {
        this._color.copyFrom(value);
        for (let quad of this._mainQuads) {
          quad.color = value;
        }
        this.setShadowDirty();
      }
      get alignment() {
        return this._alignment;
      }
      set alignment(value) {
        if (this._alignment != value) {
          this._alignment = value;
          this.layoutText();
        }
      }
      get lineSpacing() {
        return this._lineSpacing;
      }
      set lineSpacing(value) {
        if (this._lineSpacing != value) {
          this._lineSpacing = value;
          this.layoutText();
        }
      }
    }

    var __defProp$9 = Object.defineProperty;
    var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
    var __decorateClass$9 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$9(target, key, result);
      return result;
    };
    exports.Light = class Light extends LightBase {
      constructor() {
        super();
      }
      init() {
        super.init();
        this.lightData.lightType = LightType.PointLight;
        if (this.object3D.name == "") {
          this.object3D.name = "PointLight" + UUID();
        }
      }
      /**
       *
       * Get the range of the light source
       * @return {number}
       */
      get range() {
        return this.lightData.range;
      }
      /**
       *
       * Set the range of the light source
       * @param {number}
       */
      set range(value) {
        this.lightData.range = value;
        this.onChange();
      }
      /**
       *
       * Get the illumination distance of the light source
       * @type {number}
       * @memberof PointLight
       */
      get at() {
        return this.lightData.linear;
      }
      /**
       *
       * Set the illumination distance of the light source
       * @param {value} It will decay linearly from the maximum value to the current light position at a distance of 0, 
       * with a default value of 0. This means that the intensity of the light will not decrease due to distance
       * @memberof PointLight
       */
      set at(value) {
        this.lightData.linear = value;
        this.onChange();
      }
      /**
       * Get the radius to control the light
       */
      get radius() {
        return this.lightData.radius;
      }
      /**
       * Set the radius of the control light
       */
      set radius(value) {
        this.lightData.radius = value;
        this.onChange();
      }
      /**
       * Get the radius to control the light
       */
      get quadratic() {
        return this.lightData.quadratic;
      }
      /**
       * Set the radius of the control light
       */
      set quadratic(value) {
        this.lightData.quadratic = value;
        this.onChange();
      }
      start() {
        this.transform.rotationX = 90;
        super.start();
      }
      onUpdate() {
      }
      onGraphic(view) {
        let custom = view.graphic3D.createCustomShape(
          `PointLight_${this.object3D.instanceID}`,
          this.transform
        );
        custom.buildAxis();
        custom.buildCircle(Vector3.ZERO, this.range, 32, Vector3.X_AXIS);
        custom.buildCircle(Vector3.ZERO, this.range, 32, Vector3.Y_AXIS);
        custom.buildCircle(Vector3.ZERO, this.range, 32, Vector3.Z_AXIS);
      }
      /**
       *  enable GUI debug
       */
      debug() {
      }
      debugDraw(show) {
      }
    };
    exports.Light = __decorateClass$9([
      RegisterComponent(exports.Light, "Light")
    ], exports.Light);

    class Probe extends exports.Object3D {
      index = 0;
      drawCallFrame = -1;
      constructor() {
        super();
      }
    }

    var GIProbeMaterialType = /* @__PURE__ */ ((GIProbeMaterialType2) => {
      GIProbeMaterialType2[GIProbeMaterialType2["CastGI"] = 0] = "CastGI";
      GIProbeMaterialType2[GIProbeMaterialType2["ReceiveGI"] = 1] = "ReceiveGI";
      GIProbeMaterialType2[GIProbeMaterialType2["CastDepth"] = 2] = "CastDepth";
      GIProbeMaterialType2[GIProbeMaterialType2["Other"] = 3] = "Other";
      return GIProbeMaterialType2;
    })(GIProbeMaterialType || {});
    class GIProbeMaterial extends Material {
      static count = 0;
      constructor(type = 0 /* CastGI */, index = 0) {
        super();
        ShaderLib.register("GIProbeShader", GIProbeShader);
        let newShader = new Shader();
        let colorShader = new RenderShaderPass("GIProbeShader", "GIProbeShader");
        colorShader.passType = PassType.COLOR;
        newShader.addRenderPass(colorShader);
        colorShader.setDefine("USE_BRDF", true);
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        colorShader.setUniformVector4("probeUniform", new Vector4(index, type, 0, 0));
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = false;
        shaderState.castShadow = false;
        shaderState.receiveEnv = false;
        shaderState.acceptGI = false;
        shaderState.useLight = false;
        newShader.setTexture("baseMap", Engine3D.res.whiteTexture);
        newShader.setTexture("normalMap", Engine3D.res.normalTexture);
        newShader.setTexture("emissiveMap", Engine3D.res.blackTexture);
        this.shader = newShader;
      }
    }

    class GlobalIlluminationComponent extends ComponentBase {
      _probes;
      _volume;
      _debugMr = [];
      init() {
        Engine3D.setting.gi.enable = true;
      }
      start() {
        this._volume = GlobalBindGroup.getLightEntries(this.transform.scene3D).irradianceVolume;
        this.initProbe();
      }
      initProbe() {
        let xCount = this._volume.setting.probeXCount;
        let yCount = this._volume.setting.probeYCount;
        let zCount = this._volume.setting.probeZCount;
        let debugGeo = new SphereGeometry(4, 16, 16);
        let position = new Vector3();
        this._probes = [];
        for (let x = 0; x < xCount; x++) {
          for (let y = 0; y < yCount; y++) {
            for (let z = 0; z < zCount; z++) {
              let index = x + z * xCount + y * (xCount * zCount);
              let probe = new Probe();
              probe.index = index;
              probe.name = `${x}_${y}_${z}`;
              let mr = probe.addComponent(exports.MeshRenderer);
              mr.material = new GIProbeMaterial(GIProbeMaterialType.CastGI, index);
              mr.geometry = debugGeo;
              mr.castGI = false;
              mr.castShadow = false;
              this._debugMr.push(mr);
              this.object3D.addChild(probe);
              this._volume.calcPosition(x, y, z, position);
              probe.x = position.x;
              probe.y = position.y;
              probe.z = position.z;
              this._probes[index] = probe;
              this._debugMr.push(mr);
            }
          }
        }
        for (let i = 0; i < this._probes.length; i++) {
          EntityCollect.instance.addGIProbe(this.transform.scene3D, this._probes[i]);
        }
        this.object3D.transform.enable = false;
        if (this._volume.setting.debug) {
          this.debug();
        }
      }
      debug() {
      }
      debugProbeRay(probeIndex, array) {
        const rayNumber = Engine3D.setting.gi.rayNumber;
        let quat = new Quaternion(0, -0.7071067811865475, 0.7071067811865475, 0);
        for (let i = 0; i < rayNumber; i++) {
          let ii = probeIndex * rayNumber + i;
          let dir = new Vector3(
            -array[ii * 4 + 0],
            -array[ii * 4 + 1],
            -array[ii * 4 + 2],
            0
          );
          quat.transformVector(dir, dir);
          let len = array[ii * 4 + 3];
          let start = this._probes[probeIndex].transform.worldPosition.clone();
          let end = dir.scaleBy(len);
          end.add(start, end);
        }
      }
      changeProbesVolumeData() {
        this._volume.setVolumeDataChange();
      }
      changeProbesPosition() {
        this._volume.setVolumeDataChange();
        let xCount = this._volume.setting.probeXCount;
        let yCount = this._volume.setting.probeYCount;
        let zCount = this._volume.setting.probeZCount;
        let position = new Vector3();
        for (let x = 0; x < xCount; x++) {
          for (let y = 0; y < yCount; y++) {
            for (let z = 0; z < zCount; z++) {
              let index = x + z * xCount + y * (xCount * zCount);
              let probe = this._probes[index];
              this._volume.calcPosition(x, y, z, position);
              probe.x = position.x;
              probe.y = position.y;
              probe.z = position.z;
            }
          }
        }
      }
      onUpdate() {
        Engine3D.setting.gi.maxDistance = Engine3D.setting.gi.probeSpace * 1.5;
        let camera = this.transform.scene3D.view.camera;
        let scale = Vector3.distance(camera.transform.worldPosition, camera.transform.targetPos) / 300;
        if (this._debugMr && this._debugMr.length > 0) {
          for (let i = 0; i < this._debugMr.length; i++) {
            const debugOBJ = this._debugMr[i].transform;
            debugOBJ.scaleX = scale;
            debugOBJ.scaleY = scale;
            debugOBJ.scaleZ = scale;
          }
        }
      }
    }

    class InstanceDrawComponent extends RenderNode {
      _keyRenderGroup;
      _keyBufferGroup;
      _keyIdsGroup;
      init(param) {
        this._keyRenderGroup = /* @__PURE__ */ new Map();
        this._keyBufferGroup = /* @__PURE__ */ new Map();
        this._keyIdsGroup = /* @__PURE__ */ new Map();
      }
      start() {
        let meshRenders = [];
        this.object3D.getComponents(exports.MeshRenderer, meshRenders, true);
        for (let i = 0; i < meshRenders.length; i++) {
          const mr = meshRenders[i];
          mr.transform.updateWorldMatrix(true);
          mr.enable = false;
          let key = mr.geometry.instanceID;
          for (let j = 0; j < mr.materials.length; j++) {
            const mat = mr.materials[j];
            key += mat.instanceID;
          }
          if (!this._keyRenderGroup.has(key)) {
            let matrixBuffer = new StorageGPUBuffer(meshRenders.length);
            matrixBuffer.visibility = GPUShaderStage.VERTEX;
            this._keyRenderGroup.set(key, [mr]);
            this._keyBufferGroup.set(key, matrixBuffer);
            this._keyIdsGroup.set(key, [mr.transform.worldMatrix.index]);
          } else {
            this._keyRenderGroup.get(key).push(mr);
            this._keyIdsGroup.get(key).push(mr.transform.worldMatrix.index);
          }
        }
        this._keyBufferGroup.forEach((v, k) => {
          let ids = this._keyIdsGroup.get(k);
          let instanceMatrixBuffer = this._keyBufferGroup.get(k);
          instanceMatrixBuffer.setInt32Array("matrixIDs", new Int32Array(ids));
          instanceMatrixBuffer.apply();
        });
      }
      stop() {
      }
      nodeUpdate(view, passType, renderPassState, clusterLightingBuffer) {
        this._keyRenderGroup.forEach((v, k) => {
          let instanceMatrixBuffer = this._keyBufferGroup.get(k);
          let renderNode = v[0];
          for (let i = 0; i < renderNode.materials.length; i++) {
            let material = renderNode.materials[i];
            let passes = material.getPass(passType);
            if (passes) {
              for (let i2 = 0; i2 < passes.length; i2++) {
                const renderShader = passes[i2];
                renderShader.setDefine("USE_INSTANCEDRAW", true);
                renderShader.setStorageBuffer(`instanceDrawID`, instanceMatrixBuffer);
              }
            }
          }
          renderNode.nodeUpdate(view, passType, renderPassState, clusterLightingBuffer);
        });
        this.preInit = false;
      }
      renderPass(view, passType, renderContext) {
        this._keyRenderGroup.forEach((v, k) => {
          let renderNode = v[0];
          renderNode.instanceCount = v.length;
          this.renderItem(view, passType, renderNode, renderContext);
        });
      }
      renderItem(view, passType, renderNode, renderContext) {
        let worldMatrix = renderNode.transform._worldMatrix;
        for (let i = 0; i < renderNode.materials.length; i++) {
          const material = renderNode.materials[i];
          let passes = material.getPass(passType);
          if (!passes || passes.length == 0)
            continue;
          for (let j = 0; j < passes.length; j++) {
            if (!passes || passes.length == 0)
              continue;
            let matPass = passes[j];
            GPUContext.bindGeometryBuffer(renderContext.encoder, renderNode.geometry);
            const renderShader = matPass;
            if (renderShader.shaderState.splitTexture) {
              renderContext.endRenderPass();
              RTResourceMap.WriteSplitColorTexture(renderNode.instanceID);
              renderContext.beginOpaqueRenderPass();
              GPUContext.bindCamera(renderContext.encoder, view.camera);
              GPUContext.bindGeometryBuffer(renderContext.encoder, renderNode.geometry);
            }
            GPUContext.bindPipeline(renderContext.encoder, renderShader);
            let subGeometries = renderNode.geometry.subGeometries;
            const subGeometry = subGeometries[i];
            let lodInfos = subGeometry.lodLevels;
            let lodInfo = lodInfos[renderNode.lodLevel];
            if (renderNode.instanceCount > 0) {
              GPUContext.drawIndexed(renderContext.encoder, lodInfo.indexCount, renderNode.instanceCount, lodInfo.indexStart, 0, 0);
            } else {
              GPUContext.drawIndexed(renderContext.encoder, lodInfo.indexCount, 1, lodInfo.indexStart, 0, worldMatrix.index);
            }
          }
        }
      }
    }

    var __defProp$8 = Object.defineProperty;
    var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
    var __decorateClass$8 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$8(target, key, result);
      return result;
    };
    exports.MeshFilter = class MeshFilter extends exports.MeshRenderer {
      constructor() {
        super();
      }
      get geometry() {
        return null;
      }
      set geometry(value) {
      }
      cloneTo(obj) {
      }
      set meshURL(value) {
        let geometry = Engine3D.res.getGeometry(value);
        if (geometry) {
          this.geometry = geometry;
        } else {
          console.error("no geometry set", value);
        }
      }
    };
    exports.MeshFilter = __decorateClass$8([
      RegisterComponent(exports.MeshFilter, "MeshFilter")
    ], exports.MeshFilter);

    class CapsuleColliderShape extends ColliderShape {
      /**
       * The radius of the local width of the collision body.
       */
      radius = 2.5;
      /**
       * The total height of the collision body.
       */
      height = 10;
      constructor() {
        super();
        this._shapeType = ColliderShapeType.Capsule;
      }
      // constructor(center: Vector3, radius: number, height: number) {
      //   super(center, new Vector3(radius, radius, radius));
      //   this.radius = radius;
      //   this.height = height;
      // }
    }

    class MeshColliderShape extends ColliderShape {
      /**
       * meshComponent
       */
      mesh;
      static triangle;
      _pickRet;
      constructor() {
        super();
        this._shapeType = ColliderShapeType.Mesh;
      }
      rayPick(ray, fromMatrix) {
        if (this.mesh) {
          MeshColliderShape.triangle ||= new Triangle(new Vector3(), new Vector3(), new Vector3());
          let positionAttribute = this.mesh.getAttribute(`position`);
          let indexAttribute = this.mesh.getAttribute(`indices`);
          let helpMatrix = ColliderShape.helpMatrix;
          helpMatrix.copyFrom(fromMatrix).invert();
          let helpRay = ColliderShape.helpRay.copy(ray);
          helpRay.applyMatrix(helpMatrix);
          helpRay.intersectBox(this.mesh.bounds);
          let pick = helpRay.intersectBox(this.mesh.bounds, ColliderShape.v3_help_0);
          if (!pick) {
            return null;
          }
          if (indexAttribute && positionAttribute && indexAttribute.data.length > 0) {
            let vertexData = positionAttribute.data;
            for (let i = 0, c = indexAttribute.data.length / 3; i < c; i++) {
              let offsetIndex = i * 3;
              const i1 = indexAttribute.data[offsetIndex + 0] * 3;
              const i2 = indexAttribute.data[offsetIndex + 1] * 3;
              const i3 = indexAttribute.data[offsetIndex + 2] * 3;
              let triangle = MeshColliderShape.triangle;
              let p1 = triangle.v1.set(vertexData[i1 + 0], vertexData[i1 + 1], vertexData[i1 + 2]);
              let p2 = triangle.v2.set(vertexData[i2 + 0], vertexData[i2 + 1], vertexData[i2 + 2]);
              let p3 = triangle.v3.set(vertexData[i3 + 0], vertexData[i3 + 1], vertexData[i3 + 2]);
              triangle.set(p1, p2, p3);
              let pick2 = helpRay.intersectTriangle(helpRay.origin, helpRay.direction, triangle);
              if (pick2) {
                this._pickRet ||= { intersectPoint: new Vector3(), distance: 0 };
                this._pickRet.intersectPoint = pick2;
                this._pickRet.distance = Vector3.distance(helpRay.origin, pick2);
                return this._pickRet;
              }
            }
          }
        }
        return null;
      }
    }

    class BoundingSphere {
      center = new Vector3();
      extents;
      //= new Vector3();
      max;
      //= new Vector3();
      min;
      // = new Vector3();
      size;
      //= new Vector3();
      tmpVecA = new Vector3();
      tmpVecB = new Vector3();
      tmpVecC = new Vector3();
      tmpVecD = new Vector3();
      radius = 0;
      diffBetweenPoints = new Vector3();
      owner;
      forward = new Vector3(0, 0, 1);
      worldCenter;
      worldSize;
      /**
       * @internal
       */
      _center = new Vector3();
      constructor(center, radius) {
        this.center = center || new Vector3(0, 0, 0);
        this.radius = radius === void 0 ? 0.5 : radius;
      }
      updateBound() {
        throw new Error("Method not implemented.");
      }
      containsPoint(point) {
        var lenSq = this.tmpVecA.subtract(point, this.center).lengthSquared;
        var r = this.radius;
        return lenSq < r * r;
      }
      /**
       * @function
       * @name pc.BoundingSphere#intersectsRay
       * @description Test if a ray intersects with the sphere.
       * @param {pc.Ray} ray Ray to test against (direction must be normalized).
       * @param {pc.Vec3} [point] If there is an intersection, the intersection point will be copied into here.
       * @returns {Boolean} True if there is an intersection.
       */
      intersectsRay(ray, point) {
        var m = this.tmpVecA.copyFrom(ray.origin).subtract(this.center);
        var b = m.dotProduct(this.tmpVecB.copyFrom(ray.direction).normalize());
        var c = m.dotProduct(m) - this.radius * this.radius;
        if (c > 0 && b > 0)
          return null;
        var discr = b * b - c;
        if (discr < 0)
          return false;
        var t = Math.abs(-b - Math.sqrt(discr));
        if (point)
          point.copyFrom(ray.direction).scaleBy(t).add(ray.origin);
        return true;
      }
      /**
       * @function
       * @name pc.BoundingSphere#intersectsBoundingSphere
       * @description Test if a Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere.
       * @param {pc.BoundingSphere} sphere Bounding Sphere to test.
       * @returns {Boolean} true if the Bounding Sphere is overlapping, enveloping, or inside this Bounding Sphere and false otherwise.
       */
      intersectsBoundingSphere(sphere) {
        this.tmpVecA.subtract(sphere.center, this.center);
        var totalRadius = sphere.radius + this.radius;
        if (this.tmpVecA.lengthSquared <= totalRadius * totalRadius) {
          return true;
        }
        return false;
      }
      calculateTransform(obj) {
        this.update(obj);
      }
      inFrustum(obj, frustum) {
        return frustum.containsSphere(obj);
      }
      clone() {
        return new BoundingSphere(this.center.clone(), this.radius);
      }
      update(obj) {
        this.owner = obj;
        this._center.add(obj.transform.worldMatrix.position, this.center);
        this.forward = obj.transform.forward;
      }
      /**
       * @internal
       */
      merge(bound) {
        throw new Error("BoundingSphere merge is not ready!");
      }
      setFromCenterAndSize(center, size) {
        this.center.copy(center);
        this.radius = size;
      }
    }

    class SphereColliderShape extends ColliderShape {
      _pickRet;
      box;
      /**
       * radius of this collider
       */
      radius = 0.5;
      /**
       * @constructor
       * @param radius radius of this collider
       */
      constructor(radius) {
        super();
        this._shapeType = ColliderShapeType.Sphere;
        this.radius = radius;
        this.box = new BoundingSphere(new Vector3(), 1);
      }
      rayPick(ray, fromMatrix) {
        let box = this.box;
        box.setFromCenterAndSize(this.center, this.radius);
        let helpMatrix = ColliderShape.helpMatrix;
        helpMatrix.copyFrom(fromMatrix).invert();
        let helpRay = ColliderShape.helpRay.copy(ray);
        helpRay.applyMatrix(helpMatrix);
        let pick = helpRay.intersectSphere(helpRay.origin, helpRay.direction, this.box.center, this.box.radius);
        if (pick) {
          if (!this._pickRet) {
            this._pickRet = { intersect: false, intersectPoint: new Vector3(), distance: 0 };
          }
          this._pickRet.intersect = true;
          this._pickRet.intersectPoint = pick;
          this._pickRet.distance = Vector3.distance(helpRay.origin, ColliderShape.v3_help_0);
          return this._pickRet;
        }
        return null;
      }
    }

    class Scene3D extends exports.Object3D {
      _envMap;
      skyObject;
      envMapChange = true;
      view;
      /**
       *
       * @constructor
       */
      constructor() {
        super();
        this.transform.scene3D = this;
        this.skyObject = new exports.Object3D();
        this.addChild(this.skyObject);
        this._isScene3D = true;
        this.envMap ||= Engine3D.res.defaultSky;
      }
      /**
       *
       * get environment texture
       */
      get envMap() {
        return this._envMap;
      }
      /**
       * set environment texture
       */
      set envMap(value) {
        if (this._envMap != value) {
          this.envMapChange = true;
        }
        this._envMap = value;
        if (EntityCollect.instance.sky && `map` in EntityCollect.instance.sky)
          EntityCollect.instance.sky.map = value;
      }
      /**
       * Exposure of Sky Box. A larger value produces a sky box with stronger exposure and a brighter appearance.
       *  A smaller value produces a sky box with weaker exposure and a darker appearance.
       */
      get exposure() {
        if (EntityCollect.instance.sky && `exposure` in EntityCollect.instance.sky)
          return EntityCollect.instance.sky.exposure;
        return 0;
      }
      /**
       * Set the exposure of the Sky Box.
       */
      set exposure(value) {
        if (EntityCollect.instance.sky && `exposure` in EntityCollect.instance.sky) {
          EntityCollect.instance.sky.exposure = value;
          Engine3D.setting.sky.skyExposure = value;
        }
      }
      /**
       * Get the roughness of the Sky Box.
       */
      get roughness() {
        if (EntityCollect.instance.sky && `roughness` in EntityCollect.instance.sky) {
          return EntityCollect.instance.sky.roughness;
        }
      }
      /**
       * Set the roughness of the Sky Box.
       */
      set roughness(value) {
        if (EntityCollect.instance.sky && `roughness` in EntityCollect.instance.sky) {
          EntityCollect.instance.sky.roughness = value;
        }
      }
    }

    class Graphic3DFillRenderer extends Graphic3DBatchRenderer {
      constructor() {
        super(3, GPUPrimitiveTopology.triangle_list);
      }
    }

    class Graphic3DLineRenderer extends Graphic3DBatchRenderer {
      constructor() {
        super(2, GPUPrimitiveTopology.line_list);
      }
    }

    class Graphic3D extends exports.Object3D {
      mLineRender;
      mFillRender;
      constructor() {
        super();
        this.mLineRender = this.addComponent(Graphic3DLineRenderer);
        this.mFillRender = this.addComponent(Graphic3DFillRenderer);
      }
      /**
       * Draw the 3 - dimensional axes
       * @param uuid Graphic identification ID
       * @param origin original point
       * @param size Length of axis
       */
      drawAxis(uuid, origin = new Vector3(0, 0, 0), size = 10) {
        this.createCustomShape(uuid).buildAxis(
          origin,
          size
        );
      }
      /**
       * Draw a line
       * @param uuid Graphic identification ID
       * @param points Line path point
       * @param color Color
       */
      drawLines(uuid, points, colors = Color.COLOR_WHITE) {
        this.createCustomShape(uuid).buildLines(
          points,
          colors
        );
      }
      /**
       * drawing curve
       * @param uuid Graphic identification ID
       * @param points Curve position point
       * @param samples Number of Samples
       * @param tension Strength of curve
       * @param color Color of curve
       */
      drawCurve(uuid, points, samples = 10, tension = 0.5, color = Color.COLOR_WHITE) {
        var result = [];
        let u = new Vector3(), v = new Vector3();
        for (let i = 0; i < points.length - 1; ++i) {
          result.push(points[i]);
          const p0 = points[Math.max(i - 1, 0)];
          const p1 = points[i];
          const p2 = points[i + 1];
          const p3 = points[Math.min(i + 2, points.length - 1)];
          p2.subtract(p0, u).multiplyScalar(tension / 3).add(p1, u);
          p1.subtract(p3, v).multiplyScalar(tension / 3).add(p2, v);
          result.push(...this.calculateBezierCurve(p1, u, v, p2, samples));
        }
        result.push(points[points.length - 1]);
        this.drawLines(uuid, result, color);
      }
      calculateBezierCurve(p0, p1, p2, p3, samples) {
        var result = new Array(samples);
        for (let i = 0; i < samples; ++i) {
          let t = (i + 1) / (samples + 1);
          let _1t = 1 - t;
          let v0 = p0.mul(_1t * _1t * _1t);
          let v1 = p1.mul(3 * t * _1t * _1t);
          let v2 = p2.mul(3 * t * t * _1t);
          let v3 = p3.mul(t * t * t);
          result[i] = v0.add(v1).add(v2).add(v3);
        }
        return result;
      }
      /**
       * Draw a rectangle
       * @param uuid Graphic identification ID
       * @param origin original point
       * @param width Width of rectangle
       * @param height Height of rectangle
       * @param color The color of the rectangle
       */
      drawRect(uuid, origin, width, height, color = Color.COLOR_WHITE) {
        this.drawLines(uuid, [
          origin,
          new Vector3(origin.x + width, origin.y, origin.z),
          new Vector3(origin.x + width, origin.y + height, origin.z),
          new Vector3(origin.x, origin.y + height, origin.z),
          origin
        ], color);
      }
      /**
       * Draw a circle
       * @param uuid Graphic identification ID
       * @param center centre point
       * @param radius radius
       * @param segments Number of line segments
       * @param up Direction of plane
       * @param color The color of the circle
       */
      drawCircle(uuid, center, radius, segments = 32, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        this.createCustomShape(uuid).buildCircle(
          center,
          radius,
          segments,
          up,
          color
        );
      }
      /**
       * Draw a Sector
       * @param uuid Graphic identification ID
       * @param center centre point
       * @param radius radius
       * @param startAngle Angle of onset
       * @param endAngle Angle of end
       * @param segments number of segments
       * @param up Direction of plane
       * @param color The color of the sector
       */
      drawSector(uuid, center, radius, startAngle, endAngle, segments = 16, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        const totalAngle = (endAngle - startAngle) * DEGREES_TO_RADIANS;
        startAngle *= DEGREES_TO_RADIANS;
        var points = [];
        points.push(center);
        for (let i = 0; i <= segments; ++i) {
          if (i > 0) {
            points.push(points[points.length - 1]);
          }
          var verAngle = totalAngle * (i / segments) + startAngle;
          var x = radius * Math.cos(verAngle);
          var y = radius * Math.sin(verAngle);
          switch (up) {
            case Vector3.X_AXIS:
              points.push(center.add(new Vector3(0, x, y)));
              break;
            case Vector3.Y_AXIS:
              points.push(center.add(new Vector3(x, 0, y)));
              break;
            case Vector3.Z_AXIS:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
            default:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
          }
        }
        points.push(points[points.length - 1]);
        points.push(center);
        this.mLineRender.fillShapeData(uuid, "line", color, points);
      }
      /**
       * Draw a ArcLine
       * @param uuid Graphic identification ID
       * @param center centre point
       * @param radius radius
       * @param startAngle  Angle of onset
       * @param endAngle Angle of end
       * @param segments  number of segments
       * @param up Direction of plane
       * @param color The color of the sector
       */
      drawArcLine(uuid, center, radius, startAngle, endAngle, segments = 16, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        this.mLineRender.allocGraphics3DShape(uuid, this.transform._worldMatrix.index).buildArcLine(
          center,
          radius,
          startAngle,
          endAngle,
          segments,
          up,
          color
        );
      }
      /**
       * Creates a custom line segment graph and returns a Shape with the same uuid from the pool if it already exists.
       * @param uuid Graphic identification ID
       * @param parentTransform Parent node Transform
       * @returns Graphics3DShape
       */
      createCustomShape(uuid, parentTransform = this.transform) {
        return this.mLineRender.allocGraphics3DShape(uuid, parentTransform._worldMatrix.index);
      }
      /**
       * Draw the box
       * @param uuid Graphic identification ID
       * @param minPoint Point of minimum
       * @param maxPoint Point of maximum
       * @param color The color of the box
       */
      drawBox(uuid, minPoint, maxPoint, color = Color.COLOR_WHITE) {
        var points = [];
        points.push(minPoint);
        points.push(new Vector3(maxPoint.x, minPoint.y, minPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(maxPoint.x, maxPoint.y, minPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(minPoint.x, maxPoint.y, minPoint.z));
        points.push(points[points.length - 1]);
        points.push(minPoint);
        points.push(points[points.length - 1]);
        points.push(new Vector3(minPoint.x, minPoint.y, maxPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(maxPoint.x, minPoint.y, maxPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(maxPoint.x, maxPoint.y, maxPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(minPoint.x, maxPoint.y, maxPoint.z));
        points.push(points[points.length - 1]);
        points.push(new Vector3(minPoint.x, minPoint.y, maxPoint.z));
        points.push(new Vector3(minPoint.x, maxPoint.y, minPoint.z));
        points.push(new Vector3(minPoint.x, maxPoint.y, maxPoint.z));
        points.push(new Vector3(maxPoint.x, maxPoint.y, minPoint.z));
        points.push(new Vector3(maxPoint.x, maxPoint.y, maxPoint.z));
        points.push(new Vector3(maxPoint.x, minPoint.y, minPoint.z));
        points.push(new Vector3(maxPoint.x, minPoint.y, maxPoint.z));
        this.mLineRender.fillShapeData(uuid, "line", color, points);
      }
      /**
       * Draw the fill rectangle
       * @param uuid Graphic identification ID
       * @param minPoint Point of minimum
       * @param maxPoint Point of maximum
       * @param color The color of the fill rectangle
       */
      drawFillRect(uuid, origin, width, height, color = Color.COLOR_WHITE) {
        this.mFillRender.fillShapeData(uuid, "fill", color, [
          origin,
          new Vector3(origin.x + width, origin.y, origin.z),
          new Vector3(origin.x + width, origin.y, origin.z + height),
          new Vector3(origin.x + width, origin.y, origin.z + height),
          new Vector3(origin.x, origin.y, origin.z + height),
          origin
        ]);
      }
      /**
       * Draw the fill circle
       * @param uuid Graphic identification ID
       * @param center centre point
       * @param radius radius
       * @param segments number of segments
       * @param up Direction of plane
       * @param color The color of the fill circle
       */
      drawFillCircle(uuid, center, radius, segments = 32, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        var points = [];
        points.push(center);
        for (let i = 0; i <= segments; ++i) {
          if (i >= 2) {
            points.push(center);
            points.push(points[points.length - 2]);
          }
          var verAngle = 2 * Math.PI * i / segments;
          var x = radius * Math.cos(verAngle);
          var y = radius * Math.sin(verAngle);
          switch (up) {
            case Vector3.X_AXIS:
              points.push(center.add(new Vector3(0, x, y)));
              break;
            case Vector3.Y_AXIS:
              points.push(center.add(new Vector3(x, 0, y)));
              break;
            case Vector3.Z_AXIS:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
            default:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
          }
        }
        this.mFillRender.fillShapeData(uuid, "fill", color, points);
      }
      /**
       * Draw wire frame for geometry
       * @param uuid Graphic identification ID
       * @param geometry Geometric object
       * @param transform The Transform that needs to be bound
       * @param color The color of the wire frame
       */
      drawMeshWireframe(uuid, geometry, transform, color = Color.COLOR_WHITE, forceUpdate = false) {
        if (geometry)
          this.createCustomShape(uuid, transform ? transform : this.transform).fillShapeData(
            geometry.genWireframe(),
            color,
            forceUpdate
          );
      }
      /**
       * Draw the fill sector
       * @param uuid Graphic identification ID
       * @param center centre point
       * @param radius radius
       * @param startAngle Angle of onset
       * @param endAngle Angle of end
       * @param segments number of segments
       * @param up Direction of plane
       * @param color The color of the fill sector
       */
      drawFillSector(uuid, center, radius, startAngle, endAngle, segments = 16, up = Vector3.Y_AXIS, color = Color.COLOR_WHITE) {
        const totalAngle = (endAngle - startAngle) * DEGREES_TO_RADIANS;
        startAngle *= DEGREES_TO_RADIANS;
        var points = [];
        points.push(center);
        for (let i = 0; i <= segments; ++i) {
          if (i >= 2) {
            points.push(center);
            points.push(points[points.length - 2]);
          }
          var verAngle = totalAngle * (i / segments) + startAngle;
          var x = radius * Math.cos(verAngle);
          var y = radius * Math.sin(verAngle);
          switch (up) {
            case Vector3.X_AXIS:
              points.push(center.add(new Vector3(0, x, y)));
              break;
            case Vector3.Y_AXIS:
              points.push(center.add(new Vector3(x, 0, y)));
              break;
            case Vector3.Z_AXIS:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
            default:
              points.push(center.add(new Vector3(x, y, 0)));
              break;
          }
        }
        this.mFillRender.fillShapeData(uuid, "fill", color, points);
      }
      /**
       * Draw bounding box
       * @param uuid Graphic identification ID
       * @param boundingBox Bounding box object, please use world boundingbox
       * @param color The color of the bounding box
       */
      drawBoundingBox(uuid, boundingBox, color = Color.COLOR_WHITE) {
        this.drawBox(uuid, boundingBox.min, boundingBox.max, color);
      }
      /**
       * Draw the camera cone
       * @param camera The camera to display the cone
       * @param color The color of the camera cone
       */
      drawCameraFrustum(camera, color = Color.COLOR_WHITE) {
        if (camera.type == CameraType.perspective) {
          let y = Math.tan(camera.fov / 2 * DEGREES_TO_RADIANS);
          let x = y * camera.aspect;
          let worldMatrix = camera.transform._worldMatrix;
          let f0 = worldMatrix.transformVector(new Vector3(-x, -y, 1));
          let f1 = worldMatrix.transformVector(new Vector3(-x, y, 1));
          let f2 = worldMatrix.transformVector(new Vector3(x, -y, 1));
          let f3 = worldMatrix.transformVector(new Vector3(x, y, 1));
          let far = camera.far;
          let near = camera.near;
          let pos = camera.transform.worldPosition;
          let farLB = new Vector3().copyFrom(f0).multiplyScalar(far).add(pos);
          let farLT = new Vector3().copyFrom(f1).multiplyScalar(far).add(pos);
          let farRB = new Vector3().copyFrom(f2).multiplyScalar(far).add(pos);
          let farRT = new Vector3().copyFrom(f3).multiplyScalar(far).add(pos);
          let nearLB = new Vector3().copyFrom(f0).multiplyScalar(near).add(pos);
          let nearLT = new Vector3().copyFrom(f1).multiplyScalar(near).add(pos);
          let nearRB = new Vector3().copyFrom(f2).multiplyScalar(near).add(pos);
          let nearRT = new Vector3().copyFrom(f3).multiplyScalar(near).add(pos);
          let custom = this.createCustomShape(`CameraFrustum_${camera.object3D.instanceID}`);
          custom.buildLines([nearLT, farLT], color);
          custom.buildLines([nearLB, farLB], color);
          custom.buildLines([nearRT, farRT], color);
          custom.buildLines([nearRB, farRB], color);
          custom.buildLines([farLT, farRT, farRB, farLB, farLT], color);
          custom.buildLines([nearLT, nearRT, nearRB, nearLB, nearLT], color);
        } else if (camera.type == CameraType.ortho) {
          camera.viewPort;
          camera.viewPort.height;
          let worldMatrix = camera.transform.worldMatrix;
          let farLT = worldMatrix.transformVector(new Vector3(camera.viewPort.width * -0.5, camera.viewPort.height * 0.5, camera.far));
          let farLB = worldMatrix.transformVector(new Vector3(camera.viewPort.width * -0.5, camera.viewPort.height * -0.5, camera.far));
          let farRT = worldMatrix.transformVector(new Vector3(camera.viewPort.width * 0.5, camera.viewPort.height * 0.5, camera.far));
          let farRB = worldMatrix.transformVector(new Vector3(camera.viewPort.width * 0.5, camera.viewPort.height * -0.5, camera.far));
          let nearLT = worldMatrix.transformVector(new Vector3(camera.viewPort.width * -0.5, camera.viewPort.height * 0.5, camera.near));
          let nearLB = worldMatrix.transformVector(new Vector3(camera.viewPort.width * -0.5, camera.viewPort.height * -0.5, camera.near));
          let nearRT = worldMatrix.transformVector(new Vector3(camera.viewPort.width * 0.5, camera.viewPort.height * 0.5, camera.near));
          let nearRB = worldMatrix.transformVector(new Vector3(camera.viewPort.width * 0.5, camera.viewPort.height * -0.5, camera.near));
          let custom = this.createCustomShape(`CameraFrustum_${camera.object3D.instanceID}`);
          custom.buildLines([nearLT, farLT], color);
          custom.buildLines([nearLB, farLB], color);
          custom.buildLines([nearRT, farRT], color);
          custom.buildLines([nearRB, farRB], color);
          custom.buildLines([farLT, farRT, farRB, farLB, farLT], color);
          custom.buildLines([nearLT, nearRT, nearRB, nearLB, nearLT], color);
        }
      }
      /**
       * Draws the bounding box of the object
       * @param obj The object to display the bounding box
       * @param color The color of the bounding box
       */
      drawObjectBoundingBox(obj, color = Color.COLOR_WHITE) {
        let boundingBox = BoundUtil.genMeshBounds(obj);
        this.drawBox(`Bounds_${obj.instanceID}`, boundingBox.min, boundingBox.max, color);
      }
      /**
       * Erases the specified graph
       * @param uuid Graphic identification ID
       */
      Clear(uuid) {
        if (this.mLineRender.shapes.has(uuid)) {
          this.mLineRender.removeShape(uuid);
        } else if (this.mFillRender.shapes.has(uuid)) {
          this.mFillRender.removeShape(uuid);
        }
      }
      /**
       * Erase all drawn graphics
       */
      ClearAll() {
        this.mLineRender.shapes.clear();
        this.mFillRender.shapes.clear();
      }
      /**
       * Changes the specified graphics color
       * @param uuid Graphic identification ID
       * @param color New color value
       */
      ChangeColor(uuid, color) {
        var shape;
        if (this.mLineRender.shapes.has(uuid)) {
          shape = this.mLineRender.shapes.get(uuid);
        } else if (this.mFillRender.shapes.has(uuid)) {
          shape = this.mFillRender.shapes.get(uuid);
        } else
          return;
        const colorData = shape.colorData;
        for (let i = 0; i < colorData.length; i += 4) {
          colorData[i + 0] = color.r;
          colorData[i + 1] = color.g;
          colorData[i + 2] = color.b;
          colorData[i + 3] = color.a;
        }
      }
    }

    class PickCompute {
      _computeShader;
      _outBuffer;
      constructor() {
      }
      init() {
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        this._computeShader = new ComputeShader(Picker_cs);
        this._outBuffer = new ComputeGPUBuffer(32);
        this._computeShader.setStorageBuffer("outBuffer", this._outBuffer);
        this._computeShader.setSamplerTexture("visibleMap", rtFrame.getPositionMap());
      }
      compute(view) {
        let stand = GlobalBindGroup.getCameraGroup(view.camera);
        this._computeShader.setStorageBuffer("globalUniform", stand.uniformGPUBuffer);
        let command = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(command, [this._computeShader]);
        GPUContext.endCommandEncoder(command);
        this._outBuffer.readBuffer();
      }
      /**
       * Returns matrix id belongs to this model
       * @returns
       */
      getPickMeshID() {
        var meshID = this._outBuffer.outFloat32Array[0] + 0.1;
        return Math.floor(meshID);
      }
      /**
       * Returns world position of pick result
       * @returns
       */
      getPickWorldPosition(target) {
        target ||= new Vector3();
        var x = this._outBuffer.outFloat32Array[4];
        var y = this._outBuffer.outFloat32Array[5];
        var z = this._outBuffer.outFloat32Array[6];
        target.set(x, y, z);
        return target;
      }
      /**
       * Returns screen coord of mouse
       * @returns
       */
      getPickScreenUV(target) {
        target ||= new Vector2();
        var x = this._outBuffer.outFloat32Array[2];
        var y = this._outBuffer.outFloat32Array[3];
        target.set(x, y);
        return target;
      }
    }

    class PickFire extends CEventDispatcher {
      /**
       * The ray used to pick 3D objects
       */
      ray;
      /**
       * whether it's touching
       */
      isTouching = false;
      _mouseCode;
      _pickEvent;
      _outEvent;
      _overEvent;
      _upEvent;
      _downEvent;
      _mouseMove;
      _pickCompute;
      //Recently Objects, picked by mousedown
      _lastDownTarget;
      /**
       * a map records the association information between meshID(matrix id) and ColliderComponent
       */
      mouseEnableMap;
      _view;
      constructor(view) {
        super();
        this._view = view;
        this.init();
      }
      /**
       * Initialize the pickup initiator and call it internally during engine initialization
       */
      init() {
        this.ray = new Ray();
        this.mouseEnableMap = /* @__PURE__ */ new Map();
        this._pickEvent = new PointerEvent3D(PointerEvent3D.PICK_CLICK);
        this._outEvent = new PointerEvent3D(PointerEvent3D.PICK_OUT);
        this._overEvent = new PointerEvent3D(PointerEvent3D.PICK_OVER);
        this._mouseMove = new PointerEvent3D(PointerEvent3D.PICK_MOVE);
        this._upEvent = new PointerEvent3D(PointerEvent3D.PICK_UP);
        this._downEvent = new PointerEvent3D(PointerEvent3D.PICK_DOWN);
      }
      /**
      * start this manager
      */
      start() {
        if (Engine3D.setting.pick.enable) {
          Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_DOWN, this.onTouchStart, this);
          Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_UP, this.onTouchEnd, this);
          Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_CLICK, this.onTouchOnce, this);
          Engine3D.inputSystem.addEventListener(PointerEvent3D.POINTER_MOVE, this.onTouchMove, this);
        }
        if (Engine3D.setting.pick.mode == `pixel`) {
          this._pickCompute = new PickCompute();
          this._pickCompute.init();
        }
      }
      /**
       * stop this manager
       */
      stop() {
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_DOWN, this.onTouchStart, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_UP, this.onTouchEnd, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_CLICK, this.onTouchOnce, this);
        Engine3D.inputSystem.removeEventListener(PointerEvent3D.POINTER_MOVE, this.onTouchMove, this);
      }
      onTouchStart(e) {
        this.isTouching = true;
        this._mouseCode = e.mouseCode;
        this.pick(this._view.camera);
        let target = this.findNearestObj(this._interestList, this._view.camera);
        this._lastDownTarget = target;
        if (target) {
          this._downEvent.target = target.object3D;
          this._downEvent.ctrlKey = e.ctrlKey;
          this._downEvent.data = { pick: target, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode };
          this.dispatchEvent(this._downEvent);
          if (target.object3D.containEventListener(PointerEvent3D.PICK_DOWN)) {
            target.object3D.dispatchEvent(this._downEvent);
          }
        }
      }
      onTouchEnd(e) {
        this.isTouching = false;
        this._mouseCode = e.mouseCode;
        this.pick(this._view.camera);
        let target = this.findNearestObj(this._interestList, this._view.camera);
        if (target) {
          this._upEvent.target = target.object3D;
          this._upEvent.ctrlKey = e.ctrlKey;
          this._upEvent.data = { pick: target, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode };
          this.dispatchEvent(this._upEvent);
          if (target.object3D.containEventListener(PointerEvent3D.PICK_UP)) {
            target.object3D.dispatchEvent(this._upEvent);
          }
        }
      }
      _lastFocus;
      getPickInfo() {
        return {
          worldPos: this._pickCompute.getPickWorldPosition(),
          screenUv: this._pickCompute.getPickScreenUV(),
          meshID: this._pickCompute.getPickMeshID()
        };
      }
      onTouchMove(e) {
        this.isTouching = true;
        this._mouseCode = e.mouseCode;
        this.pick(this._view.camera);
        let target = this.findNearestObj(this._interestList, this._view.camera);
        if (target) {
          this._mouseMove.target = target.object3D;
          this._mouseMove.ctrlKey = e.ctrlKey;
          this._mouseMove.data = { pick: target, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode };
          this.dispatchEvent(this._mouseMove);
          if (target.object3D.containEventListener(PointerEvent3D.PICK_MOVE)) {
            target.object3D.dispatchEvent(this._mouseMove);
          }
        }
        if (target != this._lastFocus) {
          if (this._lastFocus && this._lastFocus.object3D) {
            this._outEvent.target = this._lastFocus.object3D;
            this._outEvent.data = { pick: this._lastFocus, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode };
            this._outEvent.ctrlKey = e.ctrlKey;
            this.dispatchEvent(this._outEvent);
            if (this._lastFocus.object3D.containEventListener(PointerEvent3D.PICK_OUT)) {
              this._lastFocus.object3D.dispatchEvent(this._outEvent);
            }
          }
          if (target) {
            this._overEvent.target = target.object3D;
            this._overEvent.ctrlKey = e.ctrlKey;
            this._overEvent.data = { pick: target, pickInfo: this.getPickInfo(), mouseCode: this._mouseCode };
            this.dispatchEvent(this._overEvent);
            if (target.object3D.containEventListener(PointerEvent3D.PICK_OVER)) {
              target.object3D.dispatchEvent(this._overEvent);
            }
          }
        }
        this._lastFocus = target;
      }
      onTouchOnce(e) {
        this.isTouching = true;
        this._mouseCode = e.mouseCode;
        this.pick(this._view.camera);
        let target = this.findNearestObj(this._interestList, this._view.camera);
        if (target) {
          let info = Engine3D.setting.pick.mode == `pixel` ? this.getPickInfo() : null;
          this._pickEvent.target = target.object3D;
          this._pickEvent.ctrlKey = e.ctrlKey;
          this._pickEvent.data = { pick: target, pickInfo: info, mouseCode: this._mouseCode };
          this.dispatchEvent(this._pickEvent);
          if (target === this._lastDownTarget && target.object3D.containEventListener(PointerEvent3D.PICK_CLICK)) {
            target.object3D.dispatchEvent(this._pickEvent);
          }
        }
        this._lastDownTarget = null;
      }
      findNearestObj(list, camera) {
        list.sort((a, b) => {
          return a.distance > b.distance ? 1 : -1;
        });
        return list[0]?.collider;
      }
      _interestList = [];
      pick(camera) {
        this._interestList.length = 0;
        if (Engine3D.setting.pick.mode == `pixel`) {
          this._pickCompute.compute(this._view);
          let meshID = this._pickCompute.getPickMeshID();
          let iterator = this.mouseEnableMap.get(meshID);
          if (iterator) {
            let position = this._pickCompute.getPickWorldPosition();
            let distance = Vector3.distance(position, this.ray.origin);
            this._interestList.push({ distance, collider: iterator, intersectPoint: position });
          }
        } else if (Engine3D.setting.pick.mode == `bound`) {
          this.ray = camera.screenPointToRay(Engine3D.inputSystem.mouseX, Engine3D.inputSystem.mouseY);
          let intersect;
          let colliders = ComponentCollect.componentsEnablePickerList.get(this._view);
          if (colliders) {
            for (const item of colliders) {
              let collider = item[0];
              if (collider.enable) {
                intersect = collider.rayPick(this.ray);
                if (intersect) {
                  intersect.collider = collider;
                  this._interestList.push(intersect);
                }
              }
            }
          }
        }
      }
    }

    class View3D extends CEventListener {
      _camera;
      _scene;
      _viewPort;
      _enablePick = false;
      _enable = true;
      pickFire;
      guiPick;
      canvasList;
      /**
      * Graphics renderers (lines, rectangles, etc.)
      */
      graphic3D;
      constructor(x = 0, y = 0, width = 0, height = 0) {
        super();
        this.canvasList = [];
        this._viewPort = new Vector4(x, y, width, height);
        this.graphic3D = new Graphic3D();
      }
      get enable() {
        return this._enable;
      }
      set enable(value) {
        this._enable = value;
      }
      get enablePick() {
        return this._enablePick;
      }
      set enablePick(value) {
        if (this._enablePick != value) {
          this.pickFire = new PickFire(this);
          this.pickFire.start();
        }
        this._enablePick = value;
      }
      get scene() {
        return this._scene;
      }
      set scene(value) {
        this._scene = value;
        value.view = this;
        ShadowLightsCollect.createBuffer(this);
        if (this.graphic3D)
          value.addChild(this.graphic3D);
        if (value) {
          this.canvasList.forEach((canvas) => {
            canvas && value.addChild(canvas.object3D);
          });
        }
      }
      get camera() {
        return this._camera;
      }
      set camera(value) {
        this._camera = value;
      }
      get viewPort() {
        return this._viewPort;
      }
      set viewPort(value) {
        this._viewPort = value;
      }
      enableUICanvas(index = 0) {
        let canvas = this.canvasList[index];
        if (!canvas) {
          let obj = new exports.Object3D();
          obj.name = "Canvas " + index;
          canvas = obj.addComponent(GUICanvas);
          canvas.index = index;
          this.canvasList[index] = canvas;
        }
        this.scene.addChild(canvas.object3D);
        if (!this.guiPick) {
          this.guiPick = new GUIPick();
          this.guiPick.init(this);
        }
        return canvas;
      }
      disableUICanvas(index = 0) {
        let canvas = this.canvasList[index];
        if (canvas && canvas.object3D) {
          canvas.object3D.removeFromParent();
        }
      }
      // public get graphic3D(): Graphic3D {
      //     return Engine3D.getRenderJob(this).graphic3D;
      // }
    }

    class Section {
      normal;
      fixNormal;
      center;
      rotateShape;
      distance = 0;
      index;
      constructor(i) {
        this.index = i;
        this.rotateShape = [];
      }
    }
    class ExtrudeGeometry extends GeometryBase {
      vScale;
      uNegate;
      sections;
      /**
       * for the points of start and end:
       * Please ensure that you do not actively clone the starting point to the end of the shape array;
       * closed: true.
       *       if you want them closed, it'll auto clone start point.
       * closed: false.
       *  
       * @param shaderReflection ShaderReflection
       */
      build(shape, isShapeClosed, path, vScale = 1, uNegate = true) {
        if (path.length < 2) {
          throw new Error("path length is not enough");
        }
        this.vScale = vScale;
        this.uNegate = uNegate;
        shape = shape.slice();
        isShapeClosed && shape.push(shape[0]);
        this.sections = this.buildSections(shape, path);
        this.buildGeometry(shape, this.sections);
        this.bounds = new BoundingBox(Vector3.ZERO.clone(), new Vector3(100, 100, 100));
        return this;
      }
      buildSections(shape, path) {
        let curPoint;
        let nextPoint;
        let normal;
        let sections = [];
        let sectionCount = path.length;
        for (let i = 0; i < sectionCount; i++) {
          let section = new Section(i);
          curPoint = path[i];
          nextPoint = path[i + 1];
          section.center = curPoint.clone();
          if (nextPoint == null) {
            section.normal = normal.clone();
            section.distance = 0;
          } else {
            normal = nextPoint.subtract(curPoint);
            section.distance = normal.length;
            section.normal = normal.normalize();
          }
          sections.push(section);
        }
        sections[0].fixNormal = sections[0].normal.clone();
        for (let i = 1; i < sectionCount; i++) {
          let lastSection = sections[i - 1];
          let curSection = sections[i];
          curSection.fixNormal = curSection.normal.add(lastSection.normal).normalize();
        }
        let matrixRotate = new Matrix4().identity();
        for (let i = 0; i < sectionCount; i++) {
          let curSection = sections[i];
          let fromDirection;
          let sourceShape;
          if (i == 0) {
            fromDirection = Vector3.UP;
            sourceShape = shape;
          } else {
            let lastSection = sections[i - 1];
            fromDirection = lastSection.fixNormal;
            sourceShape = lastSection.rotateShape;
          }
          Matrix4.fromToRotation(fromDirection, curSection.fixNormal, matrixRotate);
          for (let i2 = 0, count = shape.length; i2 < count; i2++) {
            let newPoint = matrixRotate.multiplyPoint3(sourceShape[i2]);
            curSection.rotateShape.push(newPoint);
          }
        }
        return sections;
      }
      buildGeometry(shape, sections) {
        let sectionCount = sections.length;
        let shapeVertexCount = shape.length;
        let totalVertexCount = sectionCount * shapeVertexCount;
        let segmentCount = sectionCount - 1;
        let position_arr = new Float32Array(totalVertexCount * 3);
        let normal_arr = new Float32Array(totalVertexCount * 3);
        let uv_arr = new Float32Array(totalVertexCount * 2);
        let indices_arr = new Uint32Array(segmentCount * (shapeVertexCount - 1) * 6);
        let quadCount = shapeVertexCount - 1;
        let vDistance = 0;
        let uDistance = 0;
        let uList = [0];
        for (let i = 1; i < shapeVertexCount; i++) {
          uDistance += shape[i - 1].subtract(shape[i]).length;
          uList.push(uDistance);
        }
        for (let i = 0; i < sectionCount; i++) {
          let section = sections[i];
          for (let j = 0; j < shapeVertexCount; j++) {
            let pos_offset = (i * shapeVertexCount + j) * 3;
            let vertex = section.rotateShape[j].add(section.center);
            position_arr[pos_offset] = vertex.x;
            position_arr[pos_offset + 1] = vertex.y;
            position_arr[pos_offset + 2] = vertex.z;
            normal_arr[pos_offset + 1] = 1;
            let uv_offset = (i * shapeVertexCount + j) * 2;
            let u = uList[j] / uDistance;
            uv_arr[uv_offset] = this.uNegate ? 1 - u : u;
            uv_arr[uv_offset + 1] = vDistance * this.vScale;
          }
          vDistance += section.distance;
        }
        let index = 0;
        for (let i = 0; i < segmentCount; i++) {
          let vertexOffset = i * shapeVertexCount;
          for (let j = 0; j < quadCount; j++) {
            let vertex_rb = j;
            let vertex_lb = j + 1;
            let vertex_rt = vertex_rb + shapeVertexCount;
            let vertex_lt = vertex_lb + shapeVertexCount;
            indices_arr[index++] = vertex_rb + vertexOffset;
            indices_arr[index++] = vertex_lb + vertexOffset;
            indices_arr[index++] = vertex_rt + vertexOffset;
            indices_arr[index++] = vertex_lb + vertexOffset;
            indices_arr[index++] = vertex_lt + vertexOffset;
            indices_arr[index++] = vertex_rt + vertexOffset;
          }
        }
        this.setIndices(indices_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
        this.computeNormals();
        return this;
      }
    }

    class VertexBufferLayout {
      name;
      offset;
      size;
      arrayStride;
      stepMode;
      attributes;
    }
    class VertexAttribute {
      name;
      format;
      offset;
      shaderLocation;
      stride;
    }

    var VertexAttributeStride = /* @__PURE__ */ ((VertexAttributeStride2) => {
      VertexAttributeStride2[VertexAttributeStride2["position"] = 3] = "position";
      VertexAttributeStride2[VertexAttributeStride2["normal"] = 3] = "normal";
      VertexAttributeStride2[VertexAttributeStride2["TANGENT"] = 4] = "TANGENT";
      VertexAttributeStride2[VertexAttributeStride2["uv"] = 2] = "uv";
      VertexAttributeStride2[VertexAttributeStride2["TEXCOORD_1"] = 2] = "TEXCOORD_1";
      VertexAttributeStride2[VertexAttributeStride2["color"] = 4] = "color";
      VertexAttributeStride2[VertexAttributeStride2["joints0"] = 4] = "joints0";
      VertexAttributeStride2[VertexAttributeStride2["weights0"] = 4] = "weights0";
      VertexAttributeStride2[VertexAttributeStride2["joints1"] = 4] = "joints1";
      VertexAttributeStride2[VertexAttributeStride2["weights1"] = 4] = "weights1";
      VertexAttributeStride2[VertexAttributeStride2["vIndex"] = 1] = "vIndex";
      VertexAttributeStride2[VertexAttributeStride2["weight"] = 1] = "weight";
      VertexAttributeStride2[VertexAttributeStride2["a_morphPositions_0"] = 3] = "a_morphPositions_0";
      return VertexAttributeStride2;
    })(VertexAttributeStride || {});

    class MatrixDO {
      constructor() {
      }
    }

    class IKDTreeUserData {
      get data() {
        return null;
      }
      entity;
    }

    class KDTreeRange {
      min = 0;
      max = 0;
      set(min, max) {
        this.max = max;
        this.min = min;
        return this;
      }
      copy(src) {
        this.max = src.max;
        this.min = src.min;
        return this;
      }
      isInterestRange(src) {
        let fail = this.max > src.min || src.max < this.min;
        return !fail;
      }
    }
    class KDTreeSpace {
      _spaceDesc;
      getRange(dimension) {
        return this._spaceDesc[dimension];
      }
      initSpace(dimensions) {
        this._spaceDesc = {};
        for (let dimension of dimensions) {
          let range = this._spaceDesc[dimension] = new KDTreeRange();
          range.set(-Number.MAX_VALUE, Number.MAX_VALUE);
        }
        return this;
      }
      isContain(dimension, value) {
        let range = this._spaceDesc[dimension];
        return value >= range.min && value < range.max;
      }
      isInterestRange(dimension, range1) {
        let range2 = this._spaceDesc[dimension];
        if (range2)
          return range1.isInterestRange(range2);
        return false;
      }
      splitSpace(dimension, less, value) {
        let range = this._spaceDesc[dimension];
        if (less)
          range.max = value;
        else
          range.min = value;
        return this;
      }
      copySpace(space) {
        for (let key in space._spaceDesc) {
          let d = space._spaceDesc[key];
          this._spaceDesc[key].copy(d);
        }
        return this;
      }
    }

    class KDTreeConfig {
      static MaxEntityCountInLeaf = 4;
      static MaxLayer = 10;
      static ClearLeafLayer = KDTreeConfig.MaxLayer - 4;
    }
    class KDTreeUUID {
      static UUID = 0;
      uuid = "0";
      constructor() {
        this.uuid = (KDTreeUUID.UUID++).toString();
      }
    }
    class KDTreeNodeMap {
      map = {};
      _count = 0;
      get count() {
        return this._count;
      }
      push(entity) {
        let last = this.map[entity.uuid];
        if (!last) {
          this.map[entity.uuid] = entity;
          this._count++;
          return true;
        }
        return false;
      }
      remove(uuid) {
        let last = this.map[uuid];
        if (last) {
          delete this.map[uuid];
          this._count--;
          return true;
        }
        return false;
      }
    }
    class KDTreeNode extends KDTreeUUID {
      _dimensionIndex = 0;
      _dimensions;
      _dimension;
      _left;
      _right;
      _space;
      _parent;
      _entities;
      layer;
      get dimension() {
        return this._dimension;
      }
      constructor(layer = 0) {
        super();
        this.layer = layer;
        KDTreeNode.nodeCount++;
      }
      initNode(parent, dimensions, index) {
        this._dimensions = dimensions;
        this._dimensionIndex = index;
        this._dimension = dimensions[index];
        this._space = new KDTreeSpace().initSpace(dimensions);
        if (parent)
          this._space.copySpace(parent._space);
        this._parent = parent;
        this._entities = new KDTreeNodeMap();
        return this;
      }
      updateEntity(entity) {
        if (entity.isInNode(this, this._dimension)) {
          entity.attachTreeNode(this);
          this.autoSplit();
          if (this._left && this._right) {
            let nextIndex = (this._dimensionIndex + 1) % this._dimensions.length;
            let nextDimension = this._dimensions[nextIndex];
            if (entity.isInNode(this._right, nextDimension)) {
              this._right.updateEntity(entity);
            } else if (entity.isInNode(this._left, nextDimension)) {
              this._left.updateEntity(entity);
            }
          }
        }
      }
      buildRoot(list) {
        for (const obj of list) {
          obj.entity.attachTreeNode(this);
        }
        this.autoSplit();
      }
      _splitEntityList = [];
      autoSplit() {
        if (this._entities.count > KDTreeConfig.MaxEntityCountInLeaf && !this._right && !this._left && this.layer < KDTreeConfig.MaxLayer) {
          let tempList = this._splitEntityList;
          let nextIndex = (this._dimensionIndex + 1) % this._dimensions.length;
          let nextDimension = this._dimensions[nextIndex];
          let divide = 0;
          for (const key in this._entities.map) {
            let entity = this._entities.map[key];
            divide += entity.centerValue(nextDimension);
            tempList.push(entity);
          }
          divide /= this._entities.count;
          this._left = new KDTreeNode(this.layer + 1);
          this._right = new KDTreeNode(this.layer + 1);
          this._left.initNode(this, this._dimensions, nextIndex);
          this._right.initNode(this, this._dimensions, nextIndex);
          this._left.setSpace(true, divide);
          this._right.setSpace(false, divide);
          for (let entity of tempList) {
            if (entity.isInNode(this._right, nextDimension)) {
              entity.attachTreeNode(this._right);
            } else if (entity.isInNode(this._left, nextDimension)) {
              entity.attachTreeNode(this._left);
            }
          }
        }
        this._left && this._left.autoSplit();
        this._right && this._right.autoSplit();
      }
      setSpace(less, value) {
        if (this._parent) {
          this._space.splitSpace(this._dimension, less, value);
        }
        return this;
      }
      isEmpty() {
        return this._left == null && this._right == null && this._entities.count == 0;
      }
      pushEntity(entity) {
        return this._entities.push(entity);
      }
      removeEntity(entity) {
        return this._entities.remove(entity.uuid);
      }
      static nodeCount = 0;
      autoClear() {
        let that = this;
        while (that && that.layer > KDTreeConfig.ClearLeafLayer && that.clearLeaf()) {
          that = that._parent;
        }
      }
      clearLeaf() {
        let isEmpty0 = !this._left && !this._right;
        let isEmpty1 = !isEmpty0 && this._left.isEmpty() && this._right.isEmpty();
        if (isEmpty1) {
          this._left = this._right = null;
          KDTreeNode.nodeCount -= 2;
        }
        return isEmpty0 || isEmpty1;
      }
      isContain(value) {
        return this._space.isContain(this._dimension, value);
      }
      static rangeBox = new BoundingBox(new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE));
      nodeIntersectsBox(box) {
        let x = this._space.getRange("x");
        let y = this._space.getRange("y");
        let z = this._space.getRange("z");
        let rangeBox = KDTreeNode.rangeBox;
        rangeBox.min.set(x.min, y.min, z.min);
        rangeBox.max.set(x.max, y.max, z.max);
        return rangeBox.intersectsBox(box);
      }
      nodeIntersectsRay(ray) {
        let x = this._space.getRange("x");
        let y = this._space.getRange("y");
        let z = this._space.getRange("z");
        let rangeBox = KDTreeNode.rangeBox;
        rangeBox.min.set(x.min, y.min, z.min);
        rangeBox.max.set(x.max, y.max, z.max);
        return true;
      }
      pointCast(point, squareDistance = 0, ret) {
        ret = ret || [];
        if (this._entities.count > 0) {
          let map = this._entities.map;
          for (let key in map) {
            let entity = map[key];
            let success = entity.entityContainPoint(point);
            if (!success && squareDistance > 0) {
              success = entity.squareDistanceTo(point, this._dimensions) <= squareDistance;
            }
            if (success) {
              ret.push(entity);
            }
          }
        }
        if (this._left && this._left.isContain(point[this._left.dimension])) {
          this._left.pointCast(point, squareDistance, ret);
        }
        if (this._right && this._right.isContain(point[this._right.dimension])) {
          this._right.pointCast(point, squareDistance, ret);
        }
      }
      boxCast(box, ret) {
        ret = ret || [];
        if (this._entities.count > 0) {
          let map = this._entities.map;
          for (let key in map) {
            let entity = map[key];
            if (entity.entityIntersectsBox(box)) {
              ret.push(entity);
            }
          }
        }
        if (this._left && this._left.nodeIntersectsBox(box)) {
          this._left.boxCast(box, ret);
        }
        if (this._right && this._right.nodeIntersectsBox(box)) {
          this._right.boxCast(box, ret);
        }
      }
      pointIntersect = new Vector3();
      rayCast(ray, ret, pts) {
        ret = ret || [];
        pts = pts || [];
        let target = this.pointIntersect;
        if (this._entities.count > 0) {
          let map = this._entities.map;
          for (let key in map) {
            let entity = map[key];
            if (entity.entityIntersectsRay(ray, target)) {
              pts.push(new Vector3().copyFrom(target));
              ret.push(entity);
            }
          }
        }
        if (this._left && this._left.nodeIntersectsRay(ray)) {
          this._left.rayCast(ray, ret, pts);
        }
        if (this._right && this._right.nodeIntersectsRay(ray)) {
          this._right.rayCast(ray, ret, pts);
        }
      }
    }

    class KDTreeEntity extends KDTreeUUID {
      userData;
      node;
      constructor(data) {
        super();
        this.userData = data;
      }
      centerValue(dimension) {
        return 0;
      }
      isInNode(node, dimension) {
        return false;
      }
      entityContainPoint(point) {
        return false;
      }
      squareDistanceTo(point, dimensions) {
        return Number.MAX_VALUE;
      }
      entityIntersectsBox(box) {
        return false;
      }
      entityIntersectsRay(ray, target) {
        return false;
      }
      attachTreeNode(node) {
        if (this.node)
          this.detachTreeNode();
        this.node = node;
        return this.node.pushEntity(this);
      }
      detachTreeNode() {
        let success = this.node.removeEntity(this);
        this.node = null;
        return success;
      }
      updateNode(root) {
        let lastNode = this.node;
        if (lastNode)
          this.detachTreeNode();
        root.updateEntity(this);
        if (lastNode)
          lastNode.autoClear();
      }
    }

    class QuadAABB {
      minPosX = 0;
      minPosY = 0;
      maxPosX = 0;
      maxPosY = 0;
      testID = 0;
      points;
      offsetPosition;
      static TINY = 1e-6;
      constructor() {
        this.points = new Array();
        this.offsetPosition = new Vector3(0, 0, 0, 0);
        this.clear();
      }
      setAABox(cx, cy, sideX, sideY) {
        this.minPosX = cx - sideX / 2 - QuadAABB.TINY;
        this.maxPosX = cx + sideX / 2 + QuadAABB.TINY;
        this.minPosY = cy - sideY / 2 - QuadAABB.TINY;
        this.maxPosY = cy + sideY / 2 + QuadAABB.TINY;
        this.offsetPosition.setTo(0, 0, 0);
      }
      setOffset(vec) {
        this.maxPosX += vec.x - this.offsetPosition.x;
        this.minPosX += vec.x - this.offsetPosition.x;
        this.minPosY += vec.z - this.offsetPosition.z;
        this.maxPosY += vec.z - this.offsetPosition.z;
        this.offsetPosition.copyFrom(vec);
      }
      setContainRect(minX, minY, maxX, maxY) {
        if (this.minPosX > minX)
          this.minPosX = minX;
        if (this.minPosY > minY)
          this.minPosY = minY;
        if (this.maxPosX < maxX)
          this.maxPosX = maxX;
        if (this.maxPosY < maxY)
          this.maxPosY = maxY;
      }
      clear() {
        var huge = 1e9;
        this.minPosX = this.minPosY = huge;
        this.maxPosX = this.maxPosY = -huge;
        this.points.length = 0;
        this.testID = 0;
        this.offsetPosition.setTo(0, 0, 0);
      }
      addPoint(pos) {
        if (this.points.indexOf(pos) == -1) {
          if (pos.x < this.minPosX)
            this.minPosX = pos.x - QuadAABB.TINY;
          if (pos.x > this.maxPosX)
            this.maxPosX = pos.x + QuadAABB.TINY;
          if (pos.z < this.minPosY)
            this.minPosY = pos.z - QuadAABB.TINY;
          if (pos.z > this.maxPosY)
            this.maxPosY = pos.z + QuadAABB.TINY;
          this.points.push(pos);
        }
      }
      clone() {
        var aabb = new QuadAABB();
        aabb.minPosX = this.minPosX;
        aabb.minPosY = this.minPosY;
        aabb.maxPosX = this.maxPosX;
        aabb.maxPosY = this.maxPosY;
        return aabb;
      }
      get radius() {
        return Math.sqrt((this.maxPosY - this.minPosY) * (this.maxPosY - this.minPosY) + (this.maxPosX - this.minPosX) * (this.maxPosX - this.minPosX));
      }
      get sideX() {
        return this.maxPosX - this.minPosX;
      }
      get sideY() {
        return this.maxPosY - this.minPosY;
      }
      get centreX() {
        return (this.maxPosX - this.minPosX) * 0.5 + this.minPosX;
      }
      get centreY() {
        return (this.maxPosY - this.minPosY) * 0.5 + this.minPosY;
      }
      overlapTest(box) {
        return this.minPosY >= box.maxPosY || this.maxPosY <= box.minPosY || this.minPosX >= box.maxPosX || this.maxPosX <= box.minPosX ? false : true;
      }
      isPointInside(pos) {
        return pos.x >= this.minPosX && pos.x <= this.maxPosX && pos.z >= this.minPosY && pos.z <= this.maxPosY;
      }
      isIntersectLineSegment(p1x, p1y, p2x, p2y) {
        var isIntersect = false;
        var A1 = p1y - p2y;
        var B1 = p2x - p1x;
        var C1 = p1x * p2y - p2x * p1y;
        var LineIntersectY = (-C1 - A1 * this.minPosX) / B1;
        if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
          isIntersect = true;
        LineIntersectY = (-C1 - A1 * this.maxPosX) / B1;
        if (LineIntersectY <= this.maxPosY && LineIntersectY >= this.minPosY)
          isIntersect = true;
        var LineIntersectX = (-C1 - B1 * this.minPosY) / A1;
        if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
          isIntersect = true;
        LineIntersectX = (-C1 - B1 * this.maxPosY) / A1;
        if (LineIntersectX <= this.maxPosX && LineIntersectX >= this.minPosX)
          isIntersect = true;
        return isIntersect;
      }
    }

    class QuadTreeCell {
      static NUM_CHILDREN = 4;
      childCellIndices;
      nodeIndices;
      aabb;
      points;
      constructor(aabox) {
        this.childCellIndices = new Array();
        this.childCellIndices.length = QuadTreeCell.NUM_CHILDREN;
        this.nodeIndices = new Array();
        this.clear();
        if (aabox) {
          this.aabb = aabox.clone();
        } else {
          this.aabb = new QuadAABB();
        }
      }
      /**
      * @language zh_CN
      * Indicates if we contain triangles (if not then we should/might have children)
      */
      isLeaf() {
        return this.childCellIndices[0] == -1;
      }
      clear() {
        for (var i = 0; i < QuadTreeCell.NUM_CHILDREN; i++) {
          this.childCellIndices[i] = -1;
        }
        this.nodeIndices.splice(0, this.nodeIndices.length);
      }
    }

    class QuadTree {
      _cells;
      _rootCell;
      _quadNodes;
      _aabb;
      _cellsToTest;
      _testID;
      constructor() {
        this._testID = 0;
        this._cells = new Array();
        this._quadNodes = new Array();
        this._cellsToTest = new Array();
        this._aabb = new QuadAABB();
      }
      getQuadNode(idx) {
        return this._quadNodes[idx];
      }
      clear() {
        this._cells.length = 0;
        this._quadNodes.length = 0;
      }
      initNodes(nodes) {
        this.clear();
        var i = 0;
        var count = nodes.length;
        while (i < count) {
          nodes[i].calcGlobalQuadAABB();
          this._quadNodes.push(nodes[i]);
          i++;
        }
      }
      buildQuadTree(maxNodesPerCell, minCellSize) {
        this._aabb.clear();
        for (var node of this._quadNodes) {
          if (node.isTriangle) {
            for (var vt of node.aabb.points) {
              this._aabb.addPoint(vt);
            }
          } else {
            this._aabb.setContainRect(node.aabb.minPosX, node.aabb.minPosY, node.aabb.maxPosX, node.aabb.maxPosY);
          }
        }
        this._cells.length = 0;
        this._rootCell = new QuadTreeCell(this._aabb);
        this._cells.push(this._rootCell);
        var numTriangles = this._quadNodes.length;
        for (var i = 0; i < numTriangles; i++) {
          this._cells[0].nodeIndices[i] = i;
        }
        var cellsToProcess = new Array();
        cellsToProcess.push(0);
        var iTri;
        var cellIndex;
        var childCell;
        while (cellsToProcess.length != 0) {
          cellIndex = cellsToProcess.pop();
          if (this._cells[cellIndex].nodeIndices.length <= maxNodesPerCell || this._cells[cellIndex].aabb.radius < minCellSize) {
            continue;
          }
          for (i = 0; i < QuadTreeCell.NUM_CHILDREN; i++) {
            this._cells[cellIndex].childCellIndices[i] = this._cells.length;
            cellsToProcess.push(this._cells.length);
            this._cells.push(new QuadTreeCell(this.createAABox(this._cells[cellIndex].aabb, i)));
            childCell = this._cells[this._cells.length - 1];
            numTriangles = this._cells[cellIndex].nodeIndices.length;
            for (var j = 0; j < numTriangles; j++) {
              iTri = this._cells[cellIndex].nodeIndices[j];
              if (this.doesNodeIntersectCell(this._quadNodes[iTri], childCell)) {
                childCell.nodeIndices.push(iTri);
              }
            }
          }
          this._cells[cellIndex].nodeIndices.length = 0;
        }
      }
      createAABox(aabb, id) {
        var centerX = aabb.centreX;
        var centerY = aabb.centreY;
        var dimX = aabb.sideX;
        var dimY = aabb.sideY;
        var result = new QuadAABB();
        switch (id) {
          case 0:
            result.setAABox(centerX + dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
            break;
          case 1:
            result.setAABox(centerX - dimX / 4, centerY + dimY / 4, dimX / 2, dimY / 2);
            break;
          case 2:
            result.setAABox(centerX - dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
            break;
          case 3:
            result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
            break;
          default:
            result.setAABox(centerX + dimX / 4, centerY - dimY / 4, dimX / 2, dimY / 2);
            break;
        }
        return result;
      }
      doesNodeIntersectCell(node, cell) {
        var box = node.aabb;
        if (!box.overlapTest(cell.aabb)) {
          return false;
        }
        if (!node.isTriangle)
          return true;
        var points = box.points;
        var p1 = points[0];
        var p2 = points[1];
        var p3 = points[2];
        if (cell.aabb.isPointInside(p1) || cell.aabb.isPointInside(p2) || cell.aabb.isPointInside(p3)) {
          return true;
        }
        var isIntersect = this.pointInTriangle(cell.aabb.minPosX, cell.aabb.minPosY, p1, p2, p3) || this.pointInTriangle(cell.aabb.minPosX, cell.aabb.maxPosY, p1, p2, p3) || this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.maxPosY, p1, p2, p3) || this.pointInTriangle(cell.aabb.maxPosX, cell.aabb.minPosY, p1, p2, p3);
        if (isIntersect)
          return true;
        isIntersect = cell.aabb.isIntersectLineSegment(p1.x, p1.z, p2.x, p2.z) || cell.aabb.isIntersectLineSegment(p1.x, p1.z, p3.x, p3.z) || cell.aabb.isIntersectLineSegment(p2.x, p2.z, p3.x, p3.z);
        return isIntersect;
      }
      getNodesIntersectingtAABox(result, aabb) {
        if (this._cells.length == 0)
          return 0;
        this._cellsToTest.length = 0;
        this._cellsToTest.push(0);
        this.incrementTestCounter();
        var cellIndex, nTris, cell;
        var nodeBox;
        var i = 0;
        while (this._cellsToTest.length != 0) {
          cellIndex = this._cellsToTest.pop();
          cell = this._cells[cellIndex];
          if (!aabb.overlapTest(cell.aabb)) {
            continue;
          }
          if (cell.isLeaf()) {
            nTris = cell.nodeIndices.length;
            for (i = 0; i < nTris; i++) {
              nodeBox = this.getQuadNode(cell.nodeIndices[i]).aabb;
              if (nodeBox.testID != this._testID) {
                nodeBox.testID = this._testID;
                if (aabb.overlapTest(nodeBox)) {
                  result.push(cell.nodeIndices[i]);
                }
              }
            }
          } else {
            for (i = 0; i < QuadTreeCell.NUM_CHILDREN; i++) {
              this._cellsToTest.push(cell.childCellIndices[i]);
            }
          }
        }
        return result.length;
      }
      pointInTriangle(x, y, triP1, triP2, triP3) {
        var p1 = triP1;
        var p2 = triP2;
        var p3 = triP3;
        var A1 = p1.z - p2.z;
        var B1 = p2.x - p1.x;
        var C1 = p1.x * p2.z - p2.x * p1.z;
        var A2 = p2.z - p3.z;
        var B2 = p3.x - p2.x;
        var C2 = p2.x * p3.z - p3.x * p2.z;
        var A3 = p3.z - p1.z;
        var B3 = p1.x - p3.x;
        var C3 = p3.x * p1.z - p1.x * p3.z;
        var isInTri = false;
        var D1 = A1 * x + B1 * y + C1;
        var D2 = A2 * x + B2 * y + C2;
        var D3 = A3 * x + B3 * y + C3;
        const Tiny = 0.01;
        if (D1 >= -Tiny && D2 >= -Tiny && D3 >= -Tiny || D1 <= Tiny && D2 <= Tiny && D3 <= Tiny)
          isInTri = true;
        return isInTri;
      }
      incrementTestCounter() {
        ++this._testID;
        if (this._testID == 0) {
          var numTriangles = this._quadNodes.length;
          for (var i = 0; i < numTriangles; i++) {
            this._quadNodes[i].aabb.testID = 0;
          }
          this._testID = 1;
        }
      }
      logDeep = 0;
      logTree(cellIndex) {
        if (cellIndex < 0)
          return;
        this.logDeep++;
        var cell = this._cells[cellIndex];
        var spaces = "";
        for (var si = 0; si < this.logDeep - 1; si++)
          spaces += "-|";
        console.log(spaces + "i=" + cellIndex + " " + cell.aabb.minPosX.toFixed(2) + " " + cell.aabb.maxPosX.toFixed(2) + " " + cell.aabb.minPosY.toFixed(2) + " " + cell.aabb.maxPosY.toFixed(2));
        var i;
        for (i = 0; i < cell.nodeIndices.length; i++) {
          if (cell.nodeIndices[i] >= 0) {
            var tri = this._quadNodes[cell.nodeIndices[i]];
            console.log(spaces + " t=" + cell.nodeIndices[i] + " " + tri.aabb.minPosX.toFixed(2) + " " + tri.aabb.maxPosX.toFixed(2) + " " + tri.aabb.minPosY.toFixed(2) + " " + tri.aabb.maxPosY.toFixed(2));
          }
        }
        for (i = 0; i < cell.childCellIndices.length; i++) {
          if (cell.childCellIndices[i] >= 0) {
            this.logTree(cell.childCellIndices[i]);
          }
        }
        this.logDeep--;
      }
    }

    class QuadRoot {
      _maxNodesPerCell;
      _minCellSize;
      _quadTree;
      _collisionNodesIdx;
      _segBox;
      _collisionNodes;
      constructor(maxNodesPerCell = 10, minCellSize = 500) {
        this._maxNodesPerCell = maxNodesPerCell;
        this._minCellSize = minCellSize;
        this._segBox = new QuadAABB();
        this._collisionNodesIdx = new Array();
        this._collisionNodes = new Array();
      }
      createQuadTree(nodes) {
        this._quadTree = new QuadTree();
        this._quadTree.initNodes(nodes);
        this._quadTree.buildQuadTree(this._maxNodesPerCell, this._minCellSize);
      }
      getNodesByAABB(minX, minY, maxX, maxY) {
        this._segBox.clear();
        this._segBox.maxPosX = maxX;
        this._segBox.maxPosY = maxY;
        this._segBox.minPosX = minX;
        this._segBox.minPosY = minY;
        this._collisionNodesIdx.length = 0;
        this._collisionNodes.length = 0;
        this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
        var quadNode;
        for (var i = 0; i < this._collisionNodesIdx.length; i++) {
          quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
          this._collisionNodes.push(quadNode);
        }
        return this._collisionNodes;
      }
      getTriangleAtPoint(point, threshold = 5) {
        this._segBox.clear();
        this._segBox.setAABox(point.x, point.z, 1, 1);
        this._collisionNodesIdx.length = 0;
        this._collisionNodes.length = 0;
        this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx, this._segBox);
        var minDistance = 4294967295;
        var curDistance = 0;
        var minTriangle;
        var quadNode;
        var triangle;
        var box;
        for (var i = 0; i < this._collisionNodesIdx.length; i++) {
          quadNode = this._quadTree.getQuadNode(this._collisionNodesIdx[i]);
          box = quadNode.aabb;
          if (!Vector3.pointInsideTriangle(point, box.points[0], box.points[1], box.points[2])) {
            continue;
          }
          triangle = quadNode;
          curDistance = Math.abs(triangle.plane.distance(point));
          if (curDistance > threshold)
            continue;
          if (quadNode == null || curDistance <= minDistance) {
            minTriangle = triangle;
            minDistance = curDistance;
          }
        }
        return minTriangle;
      }
    }

    var MouseCode = /* @__PURE__ */ ((MouseCode2) => {
      MouseCode2[MouseCode2["MOUSE_LEFT"] = 0] = "MOUSE_LEFT";
      MouseCode2[MouseCode2["MOUSE_MID"] = 1] = "MOUSE_MID";
      MouseCode2[MouseCode2["MOUSE_RIGHT"] = 2] = "MOUSE_RIGHT";
      return MouseCode2;
    })(MouseCode || {});

    class LoaderEvent extends CEvent {
      static LOADER_PROGRESS = "loaderProgress";
      static LOADER_COMPLETE = "loaderComplete";
    }

    class Object3DEvent extends CEvent {
      static ADDED = "added";
      static REMOVED = "removed";
      static CHILD_ADD_EVENT = "childAddEvent";
      static CHILD_REMOVED = "childRemoved";
    }

    class UIEvent extends CEvent {
      static SHOW = "show";
      static HIDE = "hide";
      static UPDATE = "update";
    }

    class MergeRGBACreator {
      static merge(textureR, textureG, textureB, textureA) {
        let w = 0;
        let h = 0;
        w = Math.max(textureR.width, w);
        w = Math.max(textureG.width, w);
        w = Math.max(textureB.width, w);
        w = Math.max(textureA.width, w);
        h = Math.max(textureR.height, h);
        h = Math.max(textureG.height, h);
        h = Math.max(textureB.height, h);
        h = Math.max(textureA.height, h);
        let outTex = new VirtualTexture(w, h, GPUTextureFormat.rgba8unorm);
        let compute = new ComputeShader(MergeRGBA_cs);
        compute.setSamplerTexture("textureR", textureR);
        compute.setSamplerTexture("textureG", textureG);
        compute.setSamplerTexture("textureB", textureB);
        compute.setSamplerTexture("textureA", textureA);
        compute.setStorageTexture("outTex", outTex);
        compute.workerSizeX = Math.ceil(w / 8);
        compute.workerSizeY = Math.ceil(h / 8);
        let command = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(command, [compute]);
        GPUContext.endCommandEncoder(command);
        return outTex;
      }
    }

    class RenderShaderCompute {
      sourceShader;
      compute;
      needUpdate = true;
      constructor(shaderStr, sourceShader) {
        this.sourceShader = sourceShader;
        this.compute = new ComputeShader(shaderStr);
        this.init();
      }
      init() {
      }
      onUpdate() {
        if (this.onFrame) {
          this.onFrame();
        }
        if (this.onOnce && this.needUpdate) {
          this.needUpdate = false;
          this.onFrame();
        }
      }
    }

    class PreIntegratedLutCompute extends RenderShaderCompute {
      constructor(shader) {
        super(PreIntegratedLut, shader);
      }
      init() {
        let texture = new VirtualTexture(256, 256, GPUTextureFormat.rgba8unorm, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        this.compute.setStorageTexture("sssMap", texture);
        this.sourceShader.setTexture("lutMap", texture);
        return texture;
      }
      onFrame() {
        this.compute.workerSizeX = 256 / 8;
        this.compute.workerSizeY = 256 / 8;
        let commandEncoder = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(commandEncoder, [this.compute]);
        GPUContext.endCommandEncoder(commandEncoder);
      }
    }

    class StructStorageGPUBuffer extends GPUBufferBase {
      constructor(struct, count, usage = 0) {
        super();
        this.bufferType = GPUBufferType.StructStorageGPUBuffer;
        this.createBufferByStruct(GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | usage, struct, count);
      }
    }

    class TextureMipmapCompute {
      static codeMax = `
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            //fromColor = vec4<f32>(0.0, 0.0, 0.0, 1.0);
            //if(dstSize.x == 512){
            //    fromColor.x = 1.0;
            //}else  if(dstSize.x == 256){
            //    fromColor.y = 1.0;
            //}else if(dstSize.x == 128){
            //    fromColor.z = 1.0;
            //}
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `;
      static codeMin = `
        @group(0) @binding(0) var inputTexture : texture_2d<f32>;
        @group(0) @binding(1) var inputTextureSampler : sampler;
        @group(0) @binding(2) var outputTexture : texture_storage_2d<rgba8unorm, write>;
        
        @compute @workgroup_size(1, 1)
        fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
            let dstSize = textureDimensions(outputTexture).xy;
            let uv01 = vec2<f32>(f32(GlobalInvocationID.x) / f32(dstSize.x - 1), f32(GlobalInvocationID.y) / f32(dstSize.y - 1));
            var fromColor = textureSampleLevel(inputTexture, inputTextureSampler, uv01, 0.0);
            let dstCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
            
            textureStore(outputTexture, dstCoord, fromColor);
        }
    `;
      static _pipelineMax;
      static _pipelineMin;
      static createMipmap(texture, mipmapCount) {
        const device = webGPUContext.device;
        this._pipelineMax ||= device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code: this.codeMax
            }),
            entryPoint: "main"
          }
        });
        this._pipelineMin ||= device.createComputePipeline({
          layout: `auto`,
          compute: {
            module: device.createShaderModule({
              code: this.codeMin
            }),
            entryPoint: "main"
          }
        });
        let dstWidth = Math.ceil(texture.width * 0.5);
        let dstHeight = Math.ceil(texture.height * 0.5);
        let mipmapData = { mipmapCount, texture, srcView: null, mipLevel: 1, dstHeight, dstWidth };
        mipmapData.srcView = texture.getGPUTexture().createView({
          format: texture.format,
          dimension: "2d",
          baseMipLevel: 0,
          // Make sure we're getting the right mip level...
          mipLevelCount: 1
          // And only selecting one mip level
        });
        let isMax = texture.width > 1024 && texture.height > 1024;
        if (isMax) {
          this.mipmap(this._pipelineMax, mipmapData);
        } else {
          this.mipmap(this._pipelineMin, mipmapData);
        }
      }
      static mipmap(computePipeline, data) {
        const device = webGPUContext.device;
        const commandEncoder = GPUContext.beginCommandEncoder();
        let isCurrentMax = computePipeline == this._pipelineMax;
        let dstView;
        let isBreakToMin;
        for (let i = data.mipLevel; i < data.mipmapCount; i++) {
          let entries = [];
          let binding = 0;
          entries.push({
            binding: binding++,
            resource: data.srcView
          });
          entries.push({
            binding: binding++,
            resource: data.texture.gpuSampler
          });
          dstView = data.texture.getGPUTexture().createView({
            format: data.texture.format,
            dimension: "2d",
            baseMipLevel: i,
            mipLevelCount: 1
          });
          entries.push({
            binding: binding++,
            resource: dstView
          });
          const computeBindGroup = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries
          });
          const computePass = commandEncoder.beginComputePass();
          computePass.setPipeline(computePipeline);
          computePass.setBindGroup(0, computeBindGroup);
          let groupX = data.dstWidth;
          let groupY = data.dstHeight;
          if (isCurrentMax) {
            groupX = Math.max(1, Math.floor(data.dstWidth / 8));
            groupY = Math.max(1, Math.floor(data.dstHeight / 8));
          }
          computePass.dispatchWorkgroups(groupX, groupY);
          data.dstHeight *= 0.5;
          data.dstWidth *= 0.5;
          data.srcView = dstView;
          data.mipLevel = i + 1;
          isBreakToMin = isCurrentMax && (data.dstWidth < 8 || data.dstHeight < 8);
          computePass.end();
          if (isBreakToMin) {
            break;
          }
        }
        GPUContext.endCommandEncoder(commandEncoder);
        if (isBreakToMin) {
          this.mipmap(this._pipelineMin, data);
        }
      }
    }

    class MorePassShader {
      name = "";
      passMap = /* @__PURE__ */ new Map();
    }
    class PassShader {
      passType = "";
      shaderState = /* @__PURE__ */ new Map();
      vertexShader = "";
      fragmentShader = "";
    }
    class MorePassParser {
      static passKeyword = "pass";
      static shaderKeyword = "Shader";
      static vertexKeyword = "vertex";
      static fragmentKeyword = "fragment";
      static passTypeKeyword = "PassType";
      static parser(code, defineValue) {
        code = Preprocessor.filterComment(code);
        let result = new MorePassShader();
        let index1 = code.indexOf(this.shaderKeyword);
        let index2 = code.indexOf("{", index1);
        let block = code.substring(index1 + this.shaderKeyword.length, index2).trim();
        result.name = block.substring(1, block.length - 1);
        block = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}"));
        let passBlocks = this.splitPassBlock(block);
        for (let passCode of passBlocks) {
          let passShader = this.parserPassBlock(passCode);
          let passshaderList;
          if (result.passMap.has(passShader.passType)) {
            passshaderList = result.passMap.get(passShader.passType);
          } else {
            passshaderList = [];
            result.passMap.set(passShader.passType, passshaderList);
          }
          passshaderList.push(passShader);
          if (passShader.vertexShader.length > 0) {
            passShader.vertexShader = Preprocessor.parse(passShader.vertexShader, defineValue);
          }
          if (passShader.fragmentShader.length > 0) {
            passShader.fragmentShader = Preprocessor.parse(passShader.fragmentShader, defineValue);
          }
        }
        return result;
      }
      static splitPassBlock(code) {
        let offset = 0;
        let result = [];
        while (offset < code.length) {
          let index = code.indexOf(this.passKeyword, offset);
          if (index == -1) {
            result.push(code.substring(offset));
            break;
          }
          if (offset != 0) {
            result.push(code.substring(offset, index));
          }
          offset = index + this.passKeyword.length;
        }
        return result;
      }
      static parserPassBlock(code) {
        let passShader = new PassShader();
        let index1 = code.indexOf(this.passTypeKeyword);
        let index2 = code.indexOf('"', index1);
        index1 = code.indexOf('"', index2 + 1);
        passShader.passType = code.substring(index1 + 1, index2).trim();
        this.parserShaderState(passShader, code);
        index1 = code.indexOf(this.vertexKeyword);
        if (index1 != -1) {
          passShader.vertexShader = this.extractBlock(code.substring(index1 + this.vertexKeyword.length), "{", "}");
        }
        index1 = code.indexOf(this.fragmentKeyword);
        if (index1 != -1) {
          passShader.fragmentShader = this.extractBlock(code.substring(index1 + this.fragmentKeyword.length), "{", "}");
        }
        return passShader;
      }
      static parserShaderState(passShader, code) {
        let indexL = code.indexOf("ShaderState");
        if (indexL == -1)
          return false;
        indexL = code.indexOf("{", indexL);
        let indexR = code.indexOf("}", indexL);
        let codeBlock = code.substring(indexL + 1, indexR);
        let fields = codeBlock.split(",");
        for (let item of fields) {
          let keyValue = item.split(":");
          let key = keyValue[0].trim();
          let value = this.convertValue(keyValue[1].trim());
          passShader.shaderState.set(key, value);
        }
        return true;
      }
      static convertValue(str) {
        if (str.length == 4 && str.toLowerCase() == "true")
          return true;
        else if (str.length == 5 && str.toLowerCase() == "false")
          return false;
        else if (str[0] == '"')
          return str.substring(1, str.length - 1);
        return Number.parseInt(str);
      }
      static extractBlock(str, leftStr, rightStr) {
        let indexL = str.indexOf(leftStr);
        if (indexL == -1) {
          return "";
        }
        let depth = 0;
        let indexR = 0;
        str = str.substring(indexL);
        for (let char of str) {
          if (char == leftStr) {
            depth++;
          } else if (char == rightStr) {
            depth--;
          }
          if (depth <= 0) {
            break;
          }
          indexR++;
        }
        let block = str.substring(1, indexR).trim();
        return block;
      }
    }

    let IrradianceDataReaderCompleteEvent = new CEvent("IrradianceDataReaderCompleteEvent");
    class DDGIIrradianceGPUBufferReader extends CEventDispatcher {
      readFlag = false;
      probeRenderer;
      opColorBuffer;
      opDepthBuffer;
      srcColorMap;
      srcDepthMap;
      opDepthArray;
      opColorArray;
      initReader(probeRender, colorMap, depthMap) {
        this.probeRenderer = probeRender;
        this.srcColorMap = colorMap;
        this.srcDepthMap = depthMap;
        let giSetting = Engine3D.setting.gi;
        let pixelCount = giSetting.octRTMaxSize * giSetting.octRTMaxSize;
        this.opColorBuffer = webGPUContext.device.createBuffer({
          size: pixelCount * 4 * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
          mappedAtCreation: false
        });
        this.opColorArray = new Float32Array(pixelCount * 4);
        this.opDepthBuffer = webGPUContext.device.createBuffer({
          size: pixelCount * 4 * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
          mappedAtCreation: false
        });
        this.opDepthArray = new Float32Array(pixelCount * 4);
        this.probeRenderer.addEventListener(
          GIRenderCompleteEvent.type,
          () => {
            this.onProbeRenderComplete();
          },
          this
        );
        this.probeRenderer.addEventListener(
          GIRenderStartEvent.type,
          () => {
            console.log("GIRenderStartEvent");
          },
          this
        );
      }
      async onProbeRenderComplete() {
        console.log("GIRenderCompleteEvent");
        if (!this.readFlag) {
          this.readFlag = true;
          let startTime = Date.now();
          console.log("irradianceDataReader start reading ");
          await DDGIIrradianceGPUBufferReader.read(this.srcColorMap.getGPUTexture(), this.opColorBuffer, this.opColorArray);
          await DDGIIrradianceGPUBufferReader.read(this.srcDepthMap.getGPUTexture(), this.opDepthBuffer, this.opDepthArray);
          this.readFlag = false;
          console.log("process time :", Date.now() - startTime);
          console.log("irradianceDataReader read complete");
          this.dispatchEvent(IrradianceDataReaderCompleteEvent);
        } else {
          console.log("irradianceDataReader is reading yet!!!");
        }
      }
      static async read(srcTexture, dstBuffer, output) {
        let command = GPUContext.beginCommandEncoder();
        command.copyTextureToBuffer({ texture: srcTexture }, { buffer: dstBuffer, bytesPerRow: srcTexture.width * 16 }, [srcTexture.width, srcTexture.height]);
        GPUContext.endCommandEncoder(command);
        await dstBuffer.mapAsync(GPUMapMode.READ);
        const copyArrayBuffer = dstBuffer.getMappedRange();
        output.set(new Float32Array(copyArrayBuffer), 0);
        dstBuffer.unmap();
      }
    }
    let irradianceDataReader = new DDGIIrradianceGPUBufferReader();

    class Graphic3DFixedRenderMaterial extends Material {
      /**
       * @constructor
       */
      constructor(topology = GPUPrimitiveTopology.triangle_list) {
        super();
        ShaderLib.register("Graphic3DShader", Graphic3DShader);
        let colorPass = new RenderShaderPass("Graphic3DShader", "Graphic3DShader");
        colorPass.setShaderEntry(`VertMain`, `FragMain`);
        colorPass.noticeValueChange();
        let shader = new Shader();
        shader.addRenderPass(colorPass);
        this.shader = shader;
        let shaderState = colorPass.shaderState;
        shaderState.acceptShadow = false;
        shaderState.castShadow = false;
        shaderState.receiveEnv = false;
        shaderState.acceptGI = false;
        shaderState.useLight = false;
        shaderState.topology = topology;
      }
    }

    class DynamicDrawStruct extends Struct {
      // @NonSerialize
    }

    class DynamicFaceRenderer extends exports.MeshRenderer {
      texture;
      transformBuffer;
      nodeStructBuffer;
      drawAtomicBuffer;
      object3Ds;
      nodes;
      _initCompute = false;
      _needCompute = false;
      _onBufferChange = false;
      _onStartKernel;
      _onChangeKernelGroup;
      _onFrameKernelGroup;
      nodeMat;
      maxFaceCount;
      maxNodeCount;
      _nodeStruct;
      init(param) {
        super.init(param);
        let { maxFaceCount, maxNodeCount } = param;
        this.maxFaceCount = maxFaceCount;
        this.maxNodeCount = maxNodeCount;
        this._onStartKernel = [];
        this._onChangeKernelGroup = [];
        this._onFrameKernelGroup = [];
        this.initGeometryBuffer();
        this.initMaterial();
        this.initBaseBuffer();
        this.createComputeKernel();
      }
      initGeometryBuffer() {
        let geo = new TriGeometry(this.maxFaceCount);
        this.geometry = geo;
      }
      initMaterial() {
        this.material = this.nodeMat = new UnLitTexArrayMaterial();
        this.transformBuffer = new StorageGPUBuffer(this.maxNodeCount * (8 * 4), 0);
        this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
      }
      initBaseBuffer() {
        this.drawAtomicBuffer = new StorageGPUBuffer(4);
        this.drawAtomicBuffer.setUint32("skipFace", 0);
        this.drawAtomicBuffer.setUint32("skipFace2", this.maxNodeCount);
        this.drawAtomicBuffer.setUint32("skipFace3", this.maxFaceCount);
        this.drawAtomicBuffer.setUint32("skipFace4", 0);
      }
      createComputeKernel() {
      }
      set(nodeStruct, tex, standAloneMatrix) {
        this._nodeStruct = nodeStruct;
        this.nodeMat.baseMap = tex;
        this.nodes = [];
        this.nodeStructBuffer = new StructStorageGPUBuffer(nodeStruct, this.maxNodeCount);
        for (let i = 0; i < this.maxNodeCount; i++) {
          this.nodes.push(new nodeStruct());
        }
        this.nodeStructBuffer.setStructArray(nodeStruct, this.nodes);
        this.nodeStructBuffer.apply();
        this.object3Ds = [];
        let bindObject3D;
        let white = new Color(1, 1, 1, 1);
        let black = new Color(0, 0, 0, 0);
        let uvRect = new Vector4(0, 0, 0.1, 0.1);
        let uvSpeed = new Vector4(0, 0, 0, 0);
        let vec3Zero = new Vector3(0, 0, 0);
        for (let i = 0; i < this.maxNodeCount; i++) {
          if (standAloneMatrix) {
            const element = new exports.Object3D();
            this.object3Ds.push(element);
            this.object3D.addChild(element);
            bindObject3D = element;
          } else {
            bindObject3D = this.object3D;
          }
          this.transformBuffer.setFloat("matrix_" + i, bindObject3D.transform.worldMatrix.index);
          this.transformBuffer.setFloat("texId_" + i, 0);
          this.transformBuffer.setFloat("texId2_" + i, 0);
          this.transformBuffer.setFloat("texId3_" + i, 0);
          this.transformBuffer.setFloat("fillRotation_" + i, 0);
          this.transformBuffer.setVector3("empty_" + i, vec3Zero);
          this.transformBuffer.setColor("baseColor_" + i, white);
          this.transformBuffer.setColor("lineColor_" + i, white);
          this.transformBuffer.setColor("emissiveColor_" + i, black);
          this.transformBuffer.setVector4("uvRect_" + i, uvRect);
          this.transformBuffer.setVector4("uvRect2_" + i, uvRect);
          this.transformBuffer.setVector4("uvSpeed_" + i, uvSpeed);
        }
        this.transformBuffer.apply();
        this.start = () => {
          for (const compute of this._onStartKernel) {
            compute.setStorageBuffer("globalUniform", GlobalBindGroup.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
            compute.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer);
            compute.setStorageBuffer("drawBuffer", this.drawAtomicBuffer);
            compute.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
          }
          for (const compute of this._onChangeKernelGroup) {
            compute.setStorageBuffer("globalUniform", GlobalBindGroup.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
            compute.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer);
            compute.setStorageBuffer("drawBuffer", this.drawAtomicBuffer);
            compute.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
          }
          for (const compute of this._onFrameKernelGroup) {
            compute.setStorageBuffer("globalUniform", GlobalBindGroup.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
            compute.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer);
            compute.setStorageBuffer("drawBuffer", this.drawAtomicBuffer);
            compute.setStructStorageBuffer("nodeBuffer", this.nodeStructBuffer);
          }
        };
      }
      setNodeStruct(index, shape) {
        this.nodeStructBuffer.setStruct(this._nodeStruct, index, shape);
        this.nodes ||= [];
        this.nodes[index] = shape;
        this.nodeStructBuffer.apply();
      }
      updateShape() {
        for (let i = 0; i < this.nodes.length; i++) {
          const shapeInfo = this.nodes[i];
          this.nodeStructBuffer.setStruct(this._nodeStruct, i, shapeInfo);
        }
        this.nodeStructBuffer.apply();
        this._needCompute = true;
      }
      setTextureID(i, id) {
        this.transformBuffer.setFloat("texId_" + i, id);
        this._onBufferChange = true;
      }
      setLineTextureID(i, id) {
        this.transformBuffer.setFloat("texId2_" + i, id);
        this._onBufferChange = true;
      }
      setBaseColor(i, color) {
        this.transformBuffer.setColor("baseColor_" + i, color);
        this._onBufferChange = true;
      }
      setLineColor(index, color) {
        this.transformBuffer.setColor("lineColor_" + index, color);
        this._onBufferChange = true;
      }
      setEmissiveColor(i, color) {
        this.transformBuffer.setColor("emissiveColor_" + i, color);
        this._onBufferChange = true;
      }
      setFillRotation(i, radians) {
        this.transformBuffer.setFloat("fillRotation_" + i, radians);
        this._onBufferChange = true;
      }
      setUVRect(i, v) {
        this.transformBuffer.setVector4("uvRect_" + i, v);
        this._onBufferChange = true;
      }
      setUVRect2(i, v) {
        this.transformBuffer.setVector4("uvRect2_" + i, v);
        this._onBufferChange = true;
      }
      /**
       *
       * @param {number} i index
       * @param {Vector4} v {x:fill speed u, y: fill speed v, z:line speed u, w: line speed v}
       * @memberof DynamicFaceRenderer
       */
      setUVSpeed(i, v) {
        this.transformBuffer.setVector4("uvSpeed_" + i, v);
        this._onBufferChange = true;
      }
      onUpdate(view) {
        if (this._onBufferChange) {
          this._onBufferChange = false;
          this.transformBuffer.apply();
        }
      }
      onCompute(view, command) {
        this.drawAtomicBuffer.apply();
        if (!this._initCompute) {
          this._initCompute = true;
          this.onStartCompute(view, command);
        }
        if (this._needCompute) {
          this._needCompute = false;
          this.onChangeCompute(view, command);
        }
        this.onFrameCompute(view, command);
      }
      onStartCompute(view, command) {
        GPUContext.computeCommand(command, this._onStartKernel);
      }
      onChangeCompute(view, command) {
        GPUContext.computeCommand(command, this._onChangeKernelGroup);
      }
      onFrameCompute(view, command) {
        GPUContext.computeCommand(command, this._onFrameKernelGroup);
      }
    }

    class Float32ArrayUtil {
      static wirteVec4(array, index, value) {
        array[index * 4 + 0] = value.x;
        array[index * 4 + 1] = value.y;
        array[index * 4 + 2] = value.z;
        array[index * 4 + 3] = value.w;
      }
    }

    var __defProp$7 = Object.defineProperty;
    var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
    var __decorateClass$7 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$7(target, key, result);
      return result;
    };
    exports.UnLitTexArrayShader = class UnLitTexArrayShader extends Shader {
      constructor() {
        super();
        ShaderLib.register("VertexAttributeIndexShader", VertexAttributeIndexShader);
        ShaderLib.register("UnLitTextureArray", UnLitTextureArray);
        let colorShader = new RenderShaderPass("UnLitTextureArray", "UnLitTextureArray");
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = false;
        shaderState.castShadow = false;
        shaderState.receiveEnv = false;
        shaderState.acceptGI = false;
        shaderState.useLight = false;
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefault();
      }
      setDefault() {
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor`, new Color());
        this.setUniformFloat(`alphaCutoff`, 0);
      }
      set _MainTex(value) {
        this.setTexture("baseMap", value);
      }
      set _BumpMap(value) {
        this.setTexture("normalMap", value);
      }
      set _MaskTex(value) {
        this.setTexture("maskMap", value);
      }
      set _UVTransform(value) {
        this.setUniformVector4("transformUV1", value);
      }
      set _Metallic(value) {
        this.setUniformFloat("metallic", value);
      }
      set _Roughness(value) {
        this.setUniformFloat("roughness", value);
      }
      set _MainColor(value) {
        this.setUniformColor("baseColor", value);
      }
      set _AlphaCutoff(value) {
        this.setUniformFloat("alphaCutoff", value);
      }
      set _DoubleSidedEnable(value) {
        let defaultShader = this.getDefaultColorShader();
        defaultShader.shaderState.cullMode = value ? GPUCullMode.none : defaultShader.shaderState.cullMode;
      }
      set _SurfaceType(value) {
        let defaultShader = this.getDefaultColorShader();
        if (value == 0) {
          defaultShader.blendMode = BlendMode.NONE;
        } else {
          defaultShader.blendMode = BlendMode.ALPHA;
        }
      }
      set _AlphaCutoffEnable(value) {
        if (value == 0) {
          this.setDefine("USE_ALPHACUT", false);
        } else {
          this.setDefine("USE_ALPHACUT", true);
        }
      }
    };
    exports.UnLitTexArrayShader = __decorateClass$7([
      RegisterShader
    ], exports.UnLitTexArrayShader);

    class UnLitTexArrayMaterial extends Material {
      /**
       * @constructor
       */
      constructor() {
        super();
        this.shader = new exports.UnLitTexArrayShader();
        this.baseMap = Engine3D.res.whiteTexture;
      }
      set baseMap(texture) {
        this.shader.setTexture(`baseMap`, texture);
      }
      get baseMap() {
        return this.shader.getTexture(`baseMap`);
      }
      /**
       * set base color (tint color)
       */
      set baseColor(color) {
        this.shader.setUniformColor(`baseColor`, color);
      }
      /**
       * get base color (tint color)
       */
      get baseColor() {
        return this.shader.getUniformColor("baseColor");
      }
      // /**
      //  * set environment texture, usually referring to cubemap
      //  */
      // public set envMap(texture: Texture) {
      //     //not need env texture
      // }
      /**
       * @internal
       * set shadow map
       */
      set shadowMap(texture) {
      }
    }

    class TriGeometry extends GeometryBase {
      faceCount = 0;
      /**
       *
       * @constructor
       */
      constructor(count) {
        super();
        this.faceCount = count;
        this.buildGeometry();
      }
      buildGeometry() {
        let indices_arr = new Uint32Array(this.faceCount * 3);
        let position_arr = new Float32Array(this.faceCount * 3 * 3);
        let normal_arr = new Float32Array(this.faceCount * 3 * 3);
        let uv_arr = new Float32Array(this.faceCount * 3 * 2);
        let meshIndexList = new Float32Array(this.faceCount * 3 * 1);
        for (let index = 0; index < this.faceCount; index++) {
          let i1 = index * 3 + 0;
          let i2 = index * 3 + 1;
          let i3 = index * 3 + 2;
          indices_arr[i1] = i1;
          indices_arr[i2] = i2;
          indices_arr[i3] = i3;
        }
        this.setIndices(indices_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.setAttribute(VertexAttributeName.vIndex, meshIndexList);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
      }
    }

    var __defProp$6 = Object.defineProperty;
    var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
    var __decorateClass$6 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$6(target, key, result);
      return result;
    };
    class ShapeInfo extends Struct {
      shapeIndex = 0;
      //face,poly,line,cycle,rectangle,box,sphere
      shapeType = 0;
      width = 0;
      lineCap = 0;
      pathCount = 0;
      uScale = 0;
      vScale = 0;
      lineJoin = 0;
      startPath = 0;
      endPath = 0;
      uSpeed = 0;
      vSpeed = 0;
      paths = [];
    }
    __decorateClass$6([
      NonSerialize
    ], ShapeInfo.prototype, "paths", 2);

    var LineJoin = /* @__PURE__ */ ((LineJoin2) => {
      LineJoin2[LineJoin2["bevel"] = 0] = "bevel";
      LineJoin2[LineJoin2["miter"] = 1] = "miter";
      LineJoin2[LineJoin2["round"] = 2] = "round";
      return LineJoin2;
    })(LineJoin || {});
    var LineCap = /* @__PURE__ */ ((LineCap2) => {
      LineCap2[LineCap2["butt"] = 0] = "butt";
      LineCap2[LineCap2["square"] = 1] = "square";
      LineCap2[LineCap2["round"] = 2] = "round";
      return LineCap2;
    })(LineCap || {});
    class DrawInfo extends Struct {
      skipFace = 0;
      skipFace2 = 0;
      skipFace3 = 0;
      skipFace4 = 0;
    }
    class GeometryInfo extends Struct {
      index = 0;
      faceStart = 0;
      faceEnd = 0;
      faceCount = 0;
    }
    class Graphic3DFaceRenderer extends exports.MeshRenderer {
      static maxFaceCount = 1e6;
      static maxGeometryCount = 1;
      static maxPathPointCount = 1e5;
      static maxShapeCount = 1024;
      texture;
      transformBuffer;
      _onChange = false;
      _computeGeoShader;
      geometryInfoBuffer;
      shapeBuffer;
      pathBuffer;
      drawBuffer;
      object3Ds;
      shapes;
      realDrawShape;
      needUpdate = false;
      init() {
        super.init();
      }
      create(tex, num) {
        this._computeGeoShader = new ComputeShader(GraphicLineCompute());
        this.geometryInfoBuffer = new StructStorageGPUBuffer(GeometryInfo, Graphic3DFaceRenderer.maxGeometryCount);
        this.shapeBuffer = new StructStorageGPUBuffer(ShapeInfo, Graphic3DFaceRenderer.maxShapeCount);
        this.pathBuffer = new StorageGPUBuffer(Graphic3DFaceRenderer.maxPathPointCount * 4);
        this.drawBuffer = new StorageGPUBuffer(4);
        let geo = new TriGeometry(Graphic3DFaceRenderer.maxFaceCount);
        let mat = new UnLitTexArrayMaterial();
        mat.baseMap = tex;
        this.material = mat;
        this.transformBuffer = new StorageGPUBuffer(num * (7 * 4), 0);
        this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
        this.object3Ds = [];
        for (let i = 0; i < num; i++) {
          const element = new exports.Object3D();
          this.object3Ds.push(element);
          this.object3D.addChild(element);
          this.transformBuffer.setFloat("matrix_" + i, element.transform.worldMatrix.index);
          this.transformBuffer.setFloat("texId_" + i, 1);
          this.transformBuffer.setFloat("texId2_" + i, 1);
          this.transformBuffer.setFloat("texId3_" + i, 1);
          this.transformBuffer.setColor("baseColor_" + i, new Color());
          this.transformBuffer.setColor("lineColor_" + i, new Color());
          this.transformBuffer.setColor("emissiveColor_" + i, new Color(0, 0, 0, 0));
          this.transformBuffer.setVector4("uvRect_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvRect2_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvSpeed_" + i, new Vector4(0, 0, 0, 0));
          console.log("create dynamic geometry", i);
        }
        this.transformBuffer.apply();
        this.geometry = geo;
      }
      startShape(texture) {
        this.create(texture, Graphic3DFaceRenderer.maxGeometryCount);
        let geos = [];
        for (let i = 0; i < Graphic3DFaceRenderer.maxGeometryCount; i++) {
          const geometryInfo = new GeometryInfo();
          geos.push(geometryInfo);
        }
        this.geometryInfoBuffer.setStructArray(GeometryInfo, geos);
        this.geometryInfoBuffer.apply();
        this.shapes = [];
        for (let i = 0; i < Graphic3DFaceRenderer.maxShapeCount; i++) {
          this.shapes.push(new ShapeInfo());
        }
        this.shapeBuffer.setStructArray(ShapeInfo, this.shapes);
        this.shapeBuffer.apply();
        this.start = () => {
          this._computeGeoShader.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer);
          this._computeGeoShader.setStructStorageBuffer("geometryInfoBuffer", this.geometryInfoBuffer);
          this._computeGeoShader.setStructStorageBuffer("shapeBuffer", this.shapeBuffer);
          this._computeGeoShader.setStorageBuffer("pathBuffer", this.pathBuffer);
          this._computeGeoShader.setStorageBuffer("drawBuffer", this.drawBuffer);
          this._computeGeoShader.setStorageBuffer("globalUniform", GlobalBindGroup.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
        };
      }
      setShape(index, shape) {
        this.shapeBuffer.setStruct(ShapeInfo, index, shape);
        this.shapes ||= [];
        this.shapes[index] = shape;
        this.shapeBuffer.apply();
      }
      updateShape() {
        let offset = 0;
        this.realDrawShape = 0;
        for (let i = 0; i < this.shapes.length; i++) {
          const shapeInfo = this.shapes[i];
          shapeInfo.pathCount = shapeInfo.paths.length;
          if (shapeInfo.pathCount > 0) {
            this.realDrawShape++;
          }
          shapeInfo.startPath = offset;
          offset += shapeInfo.paths.length;
          for (let j = 0; j < shapeInfo.pathCount; j++) {
            this.pathBuffer.setVector4(`${i}_path_${j}`, shapeInfo.paths[j]);
          }
          this.shapeBuffer.setStruct(ShapeInfo, i, shapeInfo);
        }
        this.shapeBuffer.apply();
        this.pathBuffer.apply();
        this.needUpdate = true;
      }
      setTextureID(i, id) {
        this.transformBuffer.setFloat("texId_" + i, id);
        this._onChange = true;
      }
      // public setTexture2ID(i: number, id: number) {
      //     this.transformBuffer.setFloat("texId_" + i, id);
      //     this._onChange = true;
      // }
      // public setTexture3ID(i: number, id: number) {
      //     this.transformBuffer.setFloat("texId_" + i, id);
      //     this._onChange = true;
      // }
      setBaseColor(i, color) {
        this.transformBuffer.setColor("baseColor_" + i, color);
        this._onChange = true;
      }
      setEmissiveColor(i, color) {
        this.transformBuffer.setColor("emissiveColor_" + i, color);
        this._onChange = true;
      }
      setUVRect(i, v) {
        this.transformBuffer.setVector4("uvRect_" + i, v);
        this._onChange = true;
      }
      onUpdate(view) {
        if (this._onChange) {
          this._onChange = false;
          this.transformBuffer.apply();
        }
      }
      onCompute(view, command) {
        if (this.needUpdate) {
          this.needUpdate = false;
          this.computeTrail(view, command);
        }
      }
      computeTrail(view, command) {
        this._computeGeoShader.workerSizeX = this.realDrawShape;
        this._computeGeoShader.workerSizeY = Math.floor(Graphic3DFaceRenderer.maxPathPointCount / 256 + 1);
        this._computeGeoShader.workerSizeZ = 1;
        GPUContext.computeCommand(command, [this._computeGeoShader]);
      }
    }

    class GeometryUtil {
      static merge(geometries, matrixes, target) {
      }
      static mergeNumber(geometries, num, target) {
        let targetGeo = target || new GeometryBase();
        let posLen = geometries.getAttribute(VertexAttributeName.position).data.length / 3;
        let meshIndexList = new Float32Array(posLen * num);
        for (const iterator of geometries.vertexAttributeMap) {
          let attName = iterator[1].attribute;
          if (attName == VertexAttributeName.indices)
            continue;
          let data = geometries.getAttribute(attName).data;
          let len = data.length;
          let attData = new Float32Array(len * num);
          for (let i = 0; i < num; i++) {
            attData.set(data, len * i);
            for (let ii = 0; ii < posLen; ii++) {
              meshIndexList[posLen * i + ii] = i;
            }
          }
          targetGeo.setAttribute(attName, attData);
        }
        targetGeo.setAttribute(VertexAttributeName.vIndex, meshIndexList);
        let indexArray = geometries.getAttribute(VertexAttributeName.indices).data;
        let indexLen = indexArray.length;
        let newIndexArray = new Uint32Array(indexArray.length * num);
        for (let i = 0; i < num; i++) {
          for (let j = 0; j < indexLen; j++) {
            let skipFace = i * posLen;
            let index = i * indexLen;
            const ii = indexArray[j] + skipFace;
            newIndexArray[index + j] = ii;
          }
        }
        targetGeo.setIndices(newIndexArray);
        targetGeo.addSubGeometry({
          indexStart: 0,
          indexCount: newIndexArray.length,
          vertexStart: 0,
          index: 0,
          vertexCount: 0,
          firstStart: 0,
          topology: 0
        });
        return targetGeo;
      }
      static generateNormal() {
      }
      static generateTangent() {
      }
      static packUV() {
      }
    }

    class Graphic3DMeshRenderer extends exports.MeshRenderer {
      transformBuffer;
      sourceGeometry;
      texture;
      object3Ds;
      _onChange = false;
      _computeShader;
      init() {
        super.init();
      }
      create(source, tex, num) {
        let mat = new UnLitTexArrayMaterial();
        mat.baseMap = tex;
        this.material = mat;
        this.transformBuffer = new StorageGPUBuffer(num * (8 * 4), 0);
        this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
        let vec3Zero = new Vector3(0, 0, 0);
        this.object3Ds = [];
        for (let i = 0; i < num; i++) {
          const element = new exports.Object3D();
          this.object3Ds.push(element);
          this.object3D.addChild(element);
          this.transformBuffer.setFloat("matrix_" + i, element.transform.worldMatrix.index);
          this.transformBuffer.setFloat("texId_" + i, 1);
          this.transformBuffer.setFloat("texId2_" + i, 1);
          this.transformBuffer.setFloat("texId3_" + i, 1);
          this.transformBuffer.setFloat("texId3_" + i, 1);
          this.transformBuffer.setFloat("fillRotation_" + i, 0);
          this.transformBuffer.setVector3("empty_" + i, vec3Zero);
          this.transformBuffer.setColor("baseColor_" + i, new Color());
          this.transformBuffer.setColor("lineColor_" + i, new Color());
          this.transformBuffer.setColor("emissiveColor_" + i, new Color(0, 0, 0, 0));
          this.transformBuffer.setVector4("uvRect_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvRect2_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvSpeed_" + i, new Vector4(0, 0, 0, 0));
        }
        this.transformBuffer.apply();
        this.geometry = GeometryUtil.mergeNumber(source, num);
      }
      setTextureID(i, id) {
        this.transformBuffer.setFloat("texId_" + i, id);
        this._onChange = true;
      }
      setBaseColor(i, color) {
        this.transformBuffer.setColor("baseColor_" + i, color);
        this._onChange = true;
      }
      setEmissiveColor(i, color) {
        this.transformBuffer.setColor("emissiveColor_" + i, color);
        this._onChange = true;
      }
      setUVRect(i, v) {
        this.transformBuffer.setVector4("uvRect_" + i, v);
        this._onChange = true;
      }
      onUpdate(view) {
        if (this._onChange) {
          this._onChange = false;
          this.transformBuffer.apply();
        }
      }
      computeTrail(view, command) {
        GPUContext.computeCommand(command, [this._computeShader]);
      }
    }

    class TrailGeometry extends GeometryBase {
      /**
       * Number of trail segments of a plane
       */
      segment;
      row = 0;
      /**
       *
       * @constructor
       */
      constructor(segment) {
        super();
        this.segment = segment;
        this.buildGeometry();
      }
      buildGeometry() {
        this.row = this.segment + 1;
        let indices_arr = new Uint32Array(this.segment * 6);
        let position_arr = new Float32Array(this.row * 3 * 2);
        let normal_arr = new Float32Array(this.row * 3 * 2);
        let uv_arr = new Float32Array(this.row * 2 * 2);
        for (let i = 0; i < this.row; i++) {
          position_arr[i * 3 * 2 + 0] = 0;
          position_arr[i * 3 * 2 + 1] = 0;
          position_arr[i * 3 * 2 + 2] = 0;
          position_arr[i * 3 * 2 + 3] = 0;
          position_arr[i * 3 * 2 + 4] = 0;
          position_arr[i * 3 * 2 + 5] = 0;
          normal_arr[i * 3 * 2 + 0] = 0;
          normal_arr[i * 3 * 2 + 1] = 0;
          normal_arr[i * 3 * 2 + 2] = 1;
          normal_arr[i * 3 * 2 + 3] = 0;
          normal_arr[i * 3 * 2 + 4] = 0;
          normal_arr[i * 3 * 2 + 5] = 1;
          uv_arr[i * 2 * 2 + 0] = 0;
          uv_arr[i * 2 * 2 + 1] = i / this.segment;
          uv_arr[i * 2 * 2 + 2] = 1;
          uv_arr[i * 2 * 2 + 3] = i / this.segment;
          let c = i * 2;
          let f0 = c;
          let f1 = c + 1;
          let f2 = c + 2;
          let f3 = c + 3;
          indices_arr[i * 6 + 0] = f0;
          indices_arr[i * 6 + 1] = f1;
          indices_arr[i * 6 + 2] = f2;
          indices_arr[i * 6 + 3] = f1;
          indices_arr[i * 6 + 4] = f3;
          indices_arr[i * 6 + 5] = f2;
        }
        this.setIndices(indices_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
      }
    }

    var __defProp$5 = Object.defineProperty;
    var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
    var __decorateClass$5 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$5(target, key, result);
      return result;
    };
    var FaceMode = /* @__PURE__ */ ((FaceMode2) => {
      FaceMode2[FaceMode2["FaceToCamera"] = 0] = "FaceToCamera";
      FaceMode2[FaceMode2["FaceToPath"] = 1] = "FaceToPath";
      FaceMode2[FaceMode2["FaceToUp"] = 2] = "FaceToUp";
      return FaceMode2;
    })(FaceMode || {});
    class RibbonStruct extends Struct {
      index = 1;
      segment = 5;
      visible = 1;
      width = 0.25;
      uv = new Vector4(0, 0, 1, 30);
      uvSpeed = new Vector2(0, 2.1);
      smooth = 0;
      faceMode = 0 /* FaceToCamera */;
      up = new Vector4(0, 1, 0);
      ids = new Float32Array(Graphic3DRibbonRenderer.maxRibbonSegment);
      ribbonPoint = [];
    }
    __decorateClass$5([
      NonSerialize
    ], RibbonStruct.prototype, "ribbonPoint", 2);
    class Graphic3DRibbonRenderer extends exports.MeshRenderer {
      static maxRibbonSegment = 256;
      transformBuffer;
      sourceGeometry;
      texture;
      object3Ds;
      // public ribbon3Ds: Object3D[][];
      ribbons;
      ribbonCount = 10;
      _onChange = false;
      _computeShader;
      _ribbonBuffer;
      ribbonSegment;
      init() {
        super.init();
      }
      create(ribbonSegment, tex, num) {
        this.ribbons = [];
        this.ribbonSegment = ribbonSegment;
        for (let i = 0; i < num; i++) {
          this.ribbons[i] = new RibbonStruct();
          this.ribbons[i].index = i;
          this.ribbons[i].segment = ribbonSegment;
          this.ribbons[i].width = 0.5;
          this.ribbons[i].faceMode = 0 /* FaceToCamera */;
        }
        let geo = new TrailGeometry(ribbonSegment);
        let mat = new UnLitTexArrayMaterial();
        mat.baseMap = tex;
        this.material = mat;
        this.transformBuffer = new StorageGPUBuffer(num * (7 * 4), 0);
        this.material.setStorageBuffer("graphicBuffer", this.transformBuffer);
        this.object3Ds = [];
        for (let i = 0; i < num; i++) {
          const element = new exports.Object3D();
          this.object3Ds.push(element);
          this.object3D.addChild(element);
          this.transformBuffer.setFloat("matrix_" + i, element.transform.worldMatrix.index);
          this.transformBuffer.setFloat("texId_" + i, 1);
          this.transformBuffer.setFloat("texId2_" + i, 1);
          this.transformBuffer.setFloat("texId3_" + i, 1);
          this.transformBuffer.setColor("baseColor_" + i, new Color());
          this.transformBuffer.setColor("lineColor_" + i, new Color());
          this.transformBuffer.setColor("emissiveColor_" + i, new Color(0, 0, 0, 0));
          this.transformBuffer.setVector4("uvRect_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvRect2_" + i, new Vector4(0, 0, 1, 1));
          this.transformBuffer.setVector4("uvSpeed_" + i, new Vector4(0, 0, 0, 0));
        }
        this.transformBuffer.apply();
        this.geometry = GeometryUtil.mergeNumber(geo, num);
      }
      startRibbon(texture, ribonSegment, count) {
        this.ribbonCount = count;
        this.create(ribonSegment, texture, count);
        this._computeShader = new ComputeShader(graphicTrailCompute(Graphic3DRibbonRenderer.maxRibbonSegment));
        this._ribbonBuffer = new StructStorageGPUBuffer(RibbonStruct, count);
        for (let i = 0; i < count; i++) {
          this.ribbons[i].ribbonPoint = [];
          for (let j = 0; j < Graphic3DRibbonRenderer.maxRibbonSegment; j++) {
            const element = new exports.Object3D();
            this.object3D.addChild(element);
            this.ribbons[i].ribbonPoint[j] = element;
            this.ribbons[i].ids[j] = element.transform.worldMatrix.index;
          }
        }
        this._ribbonBuffer.setStructArray(RibbonStruct, this.ribbons);
        this._ribbonBuffer.apply();
        this.start = () => {
          this._computeShader.setStorageBuffer("vertexBuffer", this.geometry.vertexBuffer.vertexGPUBuffer);
          this._computeShader.setStorageBuffer("trailBuffer", this._ribbonBuffer);
          this._computeShader.setStorageBuffer("models", GlobalBindGroup.modelMatrixBindGroup.matrixBufferDst);
          this._computeShader.setStorageBuffer("globalUniform", GlobalBindGroup.getCameraGroup(this.transform.scene3D.view.camera).uniformGPUBuffer);
        };
        this.onCompute = (view, command) => this.computeTrail(view, command);
      }
      setTextureID(i, id) {
        this.transformBuffer.setFloat("texId_" + i, id);
        this._onChange = true;
      }
      // public setTexture2ID(i: number, id: number) {
      //     this.transformBuffer.setFloat("texId_" + i, id);
      //     this._onChange = true;
      // }
      // public setTexture3ID(i: number, id: number) {
      //     this.transformBuffer.setFloat("texId_" + i, id);
      //     this._onChange = true;
      // }
      setBaseColor(i, color) {
        this.transformBuffer.setColor("baseColor_" + i, color);
        this._onChange = true;
      }
      setEmissiveColor(i, color) {
        this.transformBuffer.setColor("emissiveColor_" + i, color);
        this._onChange = true;
      }
      setUVRect(i, v) {
        this.transformBuffer.setVector4("uvRect_" + i, v);
        this._onChange = true;
      }
      setLineUVRect(i, v) {
        this.transformBuffer.setVector4("uvRect1_" + i, v);
        this._onChange = true;
      }
      onUpdate(view) {
        if (this._onChange) {
          this._onChange = false;
          this.transformBuffer.apply();
        }
      }
      computeTrail(view, command) {
        this._computeShader.workerSizeX = this.ribbonCount;
        this._computeShader.workerSizeY = 1;
        GPUContext.computeCommand(command, [this._computeShader]);
      }
    }

    class Graphic3DMesh {
      static meshMap = /* @__PURE__ */ new Map();
      static meshDrawGroup = /* @__PURE__ */ new Map();
      static ribbonMap = /* @__PURE__ */ new Map();
      static nodeMap = /* @__PURE__ */ new Map();
      static faceMap = /* @__PURE__ */ new Map();
      static draw(scene, geo, texture, count) {
        if (!this.meshMap.has(geo)) {
          let object = new exports.Object3D();
          let renderNode = object.addComponent(Graphic3DMeshRenderer);
          renderNode.create(geo, texture, count);
          this.meshMap.set(geo, renderNode);
          scene.addChild(object);
          return renderNode;
        }
      }
      static drawRibbon(id, scene, texture, trailSegment, count) {
        if (!this.ribbonMap.has(id)) {
          let object = new exports.Object3D();
          let renderNode = object.addComponent(Graphic3DRibbonRenderer);
          renderNode.startRibbon(texture, trailSegment, count);
          this.ribbonMap.set(id, renderNode);
          scene.addChild(object);
          return renderNode;
        }
      }
      static drawShape(id, scene, texture) {
        if (!this.faceMap.has(id)) {
          let object = new exports.Object3D();
          let renderNode = object.addComponent(Graphic3DFaceRenderer);
          renderNode.startShape(texture);
          this.faceMap.set(id, renderNode);
          scene.addChild(object);
          return renderNode;
        }
      }
      static drawNode(id, c, nodeStruct, scene, texture, maxNodeCount, maxFaceCount, standAloneMatrix) {
        if (!this.nodeMap.has(id)) {
          let object = new exports.Object3D();
          let renderNode = object.addComponent(c, {
            maxFaceCount: maxFaceCount ? maxFaceCount : 4294967295 / 3,
            //use index buffer u32
            maxNodeCount
          });
          renderNode.set(nodeStruct, texture, standAloneMatrix);
          this.nodeMap.set(id, renderNode);
          scene.addChild(object);
          return renderNode;
        }
      }
    }

    class ZCullingCompute {
      computeShader;
      visibleBuffer;
      texture;
      constructor() {
        this.computeShader = new ComputeShader(ZPassShader_cs);
        this.visibleBuffer = new ComputeGPUBuffer(8192 * 2);
        this.computeShader.setStorageBuffer(`visibleBuffer`, this.visibleBuffer);
        this.texture = RTResourceMap.getTexture(RTResourceConfig.zBufferTexture_NAME);
        this.computeShader.setSamplerTexture(`zBufferTexture`, this.texture);
        this.computeShader.workerSizeX = Math.ceil(this.texture.width / 8);
        this.computeShader.workerSizeY = Math.ceil(this.texture.height / 8);
        this.computeShader.workerSizeZ = 1;
      }
      compute(scene, occlusionSystem) {
        this.visibleBuffer.reset(true, 0);
        this.visibleBuffer.apply();
        let command = GPUContext.beginCommandEncoder();
        GPUContext.computeCommand(command, [this.computeShader]);
        this.visibleBuffer.readBuffer();
        occlusionSystem.zVisibleList = this.visibleBuffer.outFloat32Array;
      }
    }

    class BloomPost extends PostBase {
      /**
       * @internal
       */
      RT_BloomUp;
      RT_BloomDown;
      RT_threshold;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      thresholdCompute;
      downSampleComputes;
      upSampleComputes;
      postCompute;
      /**
       * @internal
       */
      bloomSetting;
      /**
       * @internal
       */
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.bloom.enable = true;
        this.createGUI();
      }
      /**
       * @internal
       */
      Render;
      onDetach(view) {
        Engine3D.setting.render.postProcessing.bloom.enable = false;
        this.removeGUI();
      }
      createGUI() {
      }
      removeGUI() {
      }
      get downSampleBlurSize() {
        return Engine3D.setting.render.postProcessing.bloom.downSampleBlurSize;
      }
      set downSampleBlurSize(value) {
        Engine3D.setting.render.postProcessing.bloom.downSampleBlurSize = value;
      }
      get downSampleBlurSigma() {
        return Engine3D.setting.render.postProcessing.bloom.downSampleBlurSigma;
      }
      set downSampleBlurSigma(value) {
        Engine3D.setting.render.postProcessing.bloom.downSampleBlurSigma = value;
      }
      get upSampleBlurSize() {
        return Engine3D.setting.render.postProcessing.bloom.upSampleBlurSize;
      }
      set upSampleBlurSize(value) {
        Engine3D.setting.render.postProcessing.bloom.upSampleBlurSize = value;
      }
      get upSampleBlurSigma() {
        return Engine3D.setting.render.postProcessing.bloom.upSampleBlurSigma;
      }
      set upSampleBlurSigma(value) {
        Engine3D.setting.render.postProcessing.bloom.upSampleBlurSigma = value;
      }
      get luminanceThreshole() {
        return Engine3D.setting.render.postProcessing.bloom.luminanceThreshole;
      }
      set luminanceThreshole(value) {
        Engine3D.setting.render.postProcessing.bloom.luminanceThreshole = value;
      }
      get bloomIntensity() {
        return Engine3D.setting.render.postProcessing.bloom.bloomIntensity;
      }
      set bloomIntensity(value) {
        Engine3D.setting.render.postProcessing.bloom.bloomIntensity = value;
      }
      createThreshouldCompute() {
        this.thresholdCompute = new ComputeShader(threshold);
        this.autoSetColorTexture("inTex", this.thresholdCompute);
        this.thresholdCompute.setStorageTexture(`outTex`, this.RT_threshold);
        this.thresholdCompute.setUniformBuffer("bloomCfg", this.bloomSetting);
        this.thresholdCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8);
        this.thresholdCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8);
        this.thresholdCompute.workerSizeZ = 1;
      }
      createDownSampleComputes() {
        let setting = Engine3D.setting.render.postProcessing.bloom;
        const N = setting.downSampleStep;
        this.downSampleComputes = [];
        for (let i = 0; i < N; i++) {
          let compute = new ComputeShader(downSample);
          let dstTexture = this.RT_BloomDown[i];
          let srcTexture = i == 0 ? this.RT_threshold : this.RT_BloomDown[i - 1];
          compute.setSamplerTexture(`inTex`, srcTexture);
          compute.setStorageTexture(`outTex`, dstTexture);
          compute.setUniformBuffer("bloomCfg", this.bloomSetting);
          compute.workerSizeX = Math.ceil(dstTexture.width / 8);
          compute.workerSizeY = Math.ceil(dstTexture.height / 8);
          compute.workerSizeZ = 1;
          this.downSampleComputes.push(compute);
        }
      }
      createUpSampleComputes() {
        let setting = Engine3D.setting.render.postProcessing.bloom;
        const N = setting.downSampleStep;
        this.upSampleComputes = [];
        {
          let compute = new ComputeShader(upSample);
          let dstTexture = this.RT_BloomUp[0];
          let srcTexture = this.RT_BloomDown[N - 2];
          compute.setSamplerTexture(`_MainTex`, srcTexture);
          compute.setSamplerTexture(`_PrevMip`, this.RT_BloomDown[N - 1]);
          compute.setStorageTexture(`outTex`, dstTexture);
          compute.setUniformBuffer("bloomCfg", this.bloomSetting);
          compute.workerSizeX = Math.ceil(dstTexture.width / 8);
          compute.workerSizeY = Math.ceil(dstTexture.height / 8);
          compute.workerSizeZ = 1;
          this.upSampleComputes.push(compute);
        }
        for (let i = 1; i < N - 1; i++) {
          let compute = new ComputeShader(upSample);
          let dstTexture = this.RT_BloomUp[i];
          let srcTexture = this.RT_BloomDown[N - 2 - i];
          compute.setSamplerTexture(`_MainTex`, srcTexture);
          compute.setSamplerTexture(`_PrevMip`, this.RT_BloomUp[i - 1]);
          compute.setStorageTexture(`outTex`, dstTexture);
          compute.setUniformBuffer("bloomCfg", this.bloomSetting);
          compute.workerSizeX = Math.ceil(dstTexture.width / 8);
          compute.workerSizeY = Math.ceil(dstTexture.height / 8);
          compute.workerSizeZ = 1;
          this.upSampleComputes.push(compute);
        }
      }
      createPostCompute() {
        let setting = Engine3D.setting.render.postProcessing.bloom;
        const N = setting.downSampleStep;
        this.postCompute = new ComputeShader(post);
        this.autoSetColorTexture("_MainTex", this.postCompute);
        this.postCompute.setSamplerTexture(`_BloomTex`, this.RT_BloomUp[N - 2]);
        this.postCompute.setStorageTexture(`outTex`, this.RT_threshold);
        this.postCompute.setUniformBuffer("bloomCfg", this.bloomSetting);
        this.postCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8);
        this.postCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8);
        this.postCompute.workerSizeZ = 1;
      }
      createResource() {
        let setting = Engine3D.setting.render.postProcessing.bloom;
        this.bloomSetting = new UniformGPUBuffer(4 * 2);
        let presentationSize = webGPUContext.presentationSize;
        let screenWidth = presentationSize[0];
        let screenHeight = presentationSize[1];
        this.RT_threshold = new VirtualTexture(screenWidth, screenHeight, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        const N = setting.downSampleStep;
        {
          let downSize = 2;
          this.RT_BloomDown = [];
          for (let i = 0; i < N; i++) {
            let w = Math.ceil(screenWidth / downSize);
            let h = Math.ceil(screenHeight / downSize);
            this.RT_BloomDown[i] = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
            downSize *= 2;
          }
        }
        {
          this.RT_BloomUp = [];
          for (let i = 0; i < N - 1; i++) {
            let w = this.RT_BloomDown[N - 2 - i].width;
            let h = this.RT_BloomDown[N - 2 - i].height;
            this.RT_BloomUp[i] = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
          }
        }
        let bloomDesc = new RTDescriptor();
        bloomDesc.loadOp = `load`;
        this.rtFrame = new RTFrame([this.RT_threshold], [bloomDesc]);
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.thresholdCompute) {
          this.createResource();
          this.createThreshouldCompute();
          this.createDownSampleComputes();
          this.createUpSampleComputes();
          this.createPostCompute();
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
          this.rendererPassState.label = "Bloom";
        }
        let cfg = Engine3D.setting.render.postProcessing.bloom;
        this.bloomSetting.setFloat("downSampleStep", cfg.downSampleStep);
        this.bloomSetting.setFloat("downSampleBlurSize", cfg.downSampleBlurSize);
        this.bloomSetting.setFloat("downSampleBlurSigma", cfg.downSampleBlurSigma);
        this.bloomSetting.setFloat("upSampleBlurSize", cfg.upSampleBlurSize);
        this.bloomSetting.setFloat("upSampleBlurSigma", cfg.upSampleBlurSigma);
        this.bloomSetting.setFloat("luminanceThreshole", cfg.luminanceThreshole);
        this.bloomSetting.setFloat("bloomIntensity", cfg.bloomIntensity);
        this.bloomSetting.apply();
        GPUContext.computeCommand(command, [this.thresholdCompute, ...this.downSampleComputes, ...this.upSampleComputes, this.postCompute]);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
      onResize() {
        let cfg = Engine3D.setting.render.postProcessing.bloom;
        let presentationSize = webGPUContext.presentationSize;
        let screenWidth = presentationSize[0];
        let screenHeight = presentationSize[1];
        this.RT_threshold.resize(screenWidth, screenHeight);
        const N = cfg.downSampleStep;
        let downSize = 2;
        for (let i = 0; i < N; i++) {
          let w = Math.ceil(screenWidth / downSize);
          let h = Math.ceil(screenHeight / downSize);
          this.RT_BloomDown[i].resize(w, h);
          downSize *= 2;
        }
        for (let i = 0; i < N - 1; i++) {
          let w = this.RT_BloomDown[N - 2 - i].width;
          let h = this.RT_BloomDown[N - 2 - i].height;
          this.RT_BloomUp[i].resize(w, h);
        }
        this.thresholdCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8);
        this.thresholdCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8);
        this.thresholdCompute.workerSizeZ = 1;
        for (let i = 0; i < N; i++) {
          let compute = this.downSampleComputes[i];
          let dstTexture = this.RT_BloomDown[i];
          compute.workerSizeX = Math.ceil(dstTexture.width / 8);
          compute.workerSizeY = Math.ceil(dstTexture.height / 8);
          compute.workerSizeZ = 1;
        }
        {
          let dstTexture = this.RT_BloomUp[0];
          let compute = this.upSampleComputes[0];
          compute.workerSizeX = Math.ceil(dstTexture.width / 8);
          compute.workerSizeY = Math.ceil(dstTexture.height / 8);
          compute.workerSizeZ = 1;
        }
        {
          for (let i = 1; i < N - 1; i++) {
            let dstTexture = this.RT_BloomUp[i];
            let compute = this.upSampleComputes[i];
            compute.workerSizeX = Math.ceil(dstTexture.width / 8);
            compute.workerSizeY = Math.ceil(dstTexture.height / 8);
            compute.workerSizeZ = 1;
          }
        }
        this.postCompute.workerSizeX = Math.ceil(this.RT_threshold.width / 8);
        this.postCompute.workerSizeY = Math.ceil(this.RT_threshold.height / 8);
        this.postCompute.workerSizeZ = 1;
      }
    }

    class DepthOfFieldPost extends PostBase {
      /**
       * @internal
       */
      blurTexture1;
      /**
       * @internal
       */
      blurTexture2;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      blurComputes;
      /**
       * @internal
       */
      blurSettings;
      /**
       * @internal
       */
      outTexture;
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.depthOfView.enable = true;
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.depthOfView.enable = false;
      }
      get pixelOffset() {
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        return setting.pixelOffset;
      }
      set pixelOffset(value) {
        value = Math.max(0, value);
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        setting.pixelOffset = value;
      }
      get near() {
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        return setting.near;
      }
      set near(value) {
        value = Math.max(0, value);
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        setting.near = value;
      }
      get far() {
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        return setting.far;
      }
      set far(value) {
        value = Math.max(0, value);
        let setting = Engine3D.setting.render.postProcessing.depthOfView;
        setting.far = value;
      }
      createBlurCompute() {
        this.blurSettings = [];
        this.blurComputes = [];
        let cfg = Engine3D.setting.render.postProcessing.depthOfView;
        for (let i = 0; i < cfg.iterationCount; i++) {
          let blurSetting = new UniformGPUBuffer(4);
          let blurCompute = new ComputeShader(DepthOfView_cs);
          this.blurComputes.push(blurCompute);
          this.blurSettings.push(blurSetting);
          blurCompute.setUniformBuffer("blurSetting", blurSetting);
          let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
          blurCompute.setSamplerTexture(RTResourceConfig.positionBufferTex_NAME, rtFrame.getPositionMap());
          blurCompute.setSamplerTexture(RTResourceConfig.normalBufferTex_NAME, rtFrame.getNormalMap());
          let input = i % 2 == 0 ? this.blurTexture1 : this.blurTexture2;
          let output = i % 2 == 1 ? this.blurTexture1 : this.blurTexture2;
          blurCompute.setSamplerTexture("inTex", input);
          blurCompute.setStorageTexture(`outTex`, output);
          blurCompute.workerSizeX = Math.ceil(this.blurTexture1.width / 8);
          blurCompute.workerSizeY = Math.ceil(this.blurTexture1.height / 8);
          blurCompute.workerSizeZ = 1;
          this.outTexture = output;
        }
      }
      createResource() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.blurTexture1 = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.blurTexture1.name = "dof1";
        let blur1Dec = new RTDescriptor();
        blur1Dec.clearValue = [0, 0, 0, 1];
        blur1Dec.loadOp = `clear`;
        this.blurTexture2 = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.blurTexture2.name = "dof2";
        let blur2Dec = new RTDescriptor();
        blur2Dec.clearValue = [0, 0, 0, 1];
        blur2Dec.loadOp = `clear`;
        this.rtFrame = new RTFrame([
          this.blurTexture1,
          this.blurTexture2
        ], [
          blur1Dec,
          blur2Dec
        ]);
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.blurComputes) {
          this.createResource();
          this.createBlurCompute();
          let standUniform = GlobalBindGroup.getCameraGroup(view.camera);
          for (let i = 0; i < this.blurComputes.length; i++) {
            const blurCompute = this.blurComputes[i];
            blurCompute.setUniformBuffer("globalUniform", standUniform.uniformGPUBuffer);
          }
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
        }
        this.autoSetColorTexture("inTex", this.blurComputes[0]);
        let cfg = Engine3D.setting.render.postProcessing.depthOfView;
        cfg.far = Math.max(cfg.near, cfg.far) + 1e-4;
        for (let i = 0; i < cfg.iterationCount; i++) {
          let blurCompute = this.blurComputes[i];
          let blurSetting = this.blurSettings[i];
          blurSetting.setFloat("near", cfg.near);
          blurSetting.setFloat("far", cfg.far);
          blurSetting.setFloat("pixelOffset", (i + 1) * cfg.pixelOffset);
          blurSetting.apply();
          blurCompute.setStorageBuffer("blurSetting", blurSetting);
        }
        GPUContext.computeCommand(command, this.blurComputes);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        let cfg = Engine3D.setting.render.postProcessing.depthOfView;
        cfg.far = Math.max(cfg.near, cfg.far) + 1e-4;
        this.blurTexture1.resize(w, h);
        this.blurTexture2.resize(w, h);
        for (let i = 0; i < cfg.iterationCount; i++) {
          let compute = this.blurComputes[i];
          compute.workerSizeX = Math.ceil(this.blurTexture1.width / 8);
          compute.workerSizeY = Math.ceil(this.blurTexture1.height / 8);
          compute.workerSizeZ = 1;
        }
      }
    }

    class GTAOPost extends PostBase {
      /**
       * @internal
       */
      gtaoTexture;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      gtaoCompute;
      /**
       * @internal
       */
      gtaoSetting;
      /**
       * @internal
       */
      aoBuffer;
      /**
       * @internal
       */
      directionsBuffer;
      /**
       * @internal
       */
      directionsArray;
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.gtao.enable = true;
      }
      /**
       * @internal
       */
      Render;
      onDetach(view) {
        Engine3D.setting.render.postProcessing.gtao.enable = false;
      }
      get maxDistance() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.maxDistance;
      }
      set maxDistance(value) {
        value = clamp(value, 0.1, 50);
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.maxDistance = value;
      }
      get maxPixel() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.maxPixel;
      }
      set maxPixel(value) {
        value = clamp(value, 5, 100);
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.maxPixel = value;
      }
      get darkFactor() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.darkFactor;
      }
      set darkFactor(value) {
        value = clamp(value, 0.01, 1);
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.darkFactor = value;
      }
      get rayMarchSegment() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.rayMarchSegment;
      }
      set rayMarchSegment(value) {
        value = clamp(value, 4, 10);
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.rayMarchSegment = value;
      }
      get multiBounce() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.multiBounce;
      }
      set multiBounce(value) {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.multiBounce = value;
      }
      get blendColor() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.blendColor;
      }
      set blendColor(value) {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.blendColor = value;
      }
      get usePosFloat32() {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        return setting.usePosFloat32;
      }
      set usePosFloat32(value) {
        let setting = Engine3D.setting.render.postProcessing.gtao;
        setting.usePosFloat32 = value;
      }
      createCompute() {
        Engine3D.setting.render.postProcessing.gtao;
        this.gtaoCompute = new ComputeShader(GTAO_cs);
        let gtaoSetting = new UniformGPUBuffer(4 * 2);
        this.gtaoCompute.setUniformBuffer("gtaoData", gtaoSetting);
        this.directionsArray = new Float32Array(8 * 2);
        this.directionsBuffer = new StorageGPUBuffer(8 * 2);
        this.directionsBuffer.setFloat32Array("array", this.randomDirection());
        this.directionsBuffer.apply();
        this.gtaoCompute.setStorageBuffer("directions", this.directionsBuffer);
        this.aoBuffer = new StorageGPUBuffer(this.gtaoTexture.width * this.gtaoTexture.height);
        this.gtaoCompute.setStorageBuffer("aoBuffer", this.aoBuffer);
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        let posTexture = rtFrame.getPositionMap();
        this.gtaoCompute.setSamplerTexture(`posTex`, posTexture);
        this.gtaoCompute.setSamplerTexture(`normalTex`, rtFrame.renderTargets[2]);
        this.autoSetColorTexture("inTex", this.gtaoCompute);
        this.gtaoCompute.setStorageTexture(`outTex`, this.gtaoTexture);
        this.gtaoSetting = gtaoSetting;
      }
      createResource() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.gtaoTexture = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.gtaoTexture.name = "gtaoTex";
        let gtaoDec = new RTDescriptor();
        gtaoDec.loadOp = `load`;
        this.rtFrame = new RTFrame([
          this.gtaoTexture
        ], [
          gtaoDec
        ]);
      }
      randomCount = 0;
      randomDirection() {
        this.randomCount++;
        if (this.randomCount > 1)
          this.randomCount = 0;
        let offsetAngle = Math.PI * 2 * this.randomCount / 16;
        let angleSegment = Math.PI * 2 / 8;
        for (let i = 0; i < 8; i++) {
          let angle = offsetAngle + i * angleSegment;
          this.directionsArray[i * 2] = Math.sin(angle);
          this.directionsArray[i * 2 + 1] = Math.cos(angle);
        }
        return this.directionsArray;
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.gtaoCompute) {
          this.createResource();
          this.createCompute();
          this.onResize();
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
          this.rendererPassState.label = "GTAO";
          let globalUniform = GlobalBindGroup.getCameraGroup(view.camera);
          this.gtaoCompute.setUniformBuffer("globalUniform", globalUniform.uniformGPUBuffer);
        }
        let cfg = Engine3D.setting.render.postProcessing.gtao;
        this.directionsBuffer.setFloat32Array("array", this.randomDirection());
        this.directionsBuffer.apply();
        let scaleFactor = 1 - 0.2 * (Time.frame % 2);
        let maxDistance = cfg.maxDistance * scaleFactor;
        let maxPixel = cfg.maxPixel * scaleFactor;
        this.gtaoSetting.setFloat("maxDistance", maxDistance);
        this.gtaoSetting.setFloat("maxPixel", maxPixel);
        this.gtaoSetting.setFloat("darkFactor", cfg.darkFactor);
        this.gtaoSetting.setFloat("rayMarchSegment", cfg.rayMarchSegment);
        let camera = view.camera;
        this.gtaoSetting.setFloat("cameraNear", camera.near);
        this.gtaoSetting.setFloat("cameraFar", camera.far);
        this.gtaoSetting.setFloat("multiBounce", cfg.multiBounce ? 1 : 0);
        this.gtaoSetting.setFloat("blendColor", cfg.blendColor ? 1 : 0);
        this.gtaoSetting.apply();
        GPUContext.computeCommand(command, [this.gtaoCompute]);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.gtaoTexture.resize(w, h);
        this.gtaoCompute.workerSizeX = Math.ceil(this.gtaoTexture.width / 8);
        this.gtaoCompute.workerSizeY = Math.ceil(this.gtaoTexture.height / 8);
        this.gtaoCompute.workerSizeZ = 1;
      }
    }

    class GlobalFog extends PostBase {
      /**
       * @internal
       */
      viewQuad;
      /**
       * @internal
       */
      rtTexture;
      _globalFog;
      constructor() {
        super();
        let globalFog = this._globalFog = Engine3D.setting.render.postProcessing.globalFog;
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        let presentationSize = webGPUContext.presentationSize;
        ShaderLib.register("GlobalFog_shader", GlobalFog_shader);
        this.rtTexture = this.createRTTexture(`GlobalFog`, presentationSize[0], presentationSize[1], GPUTextureFormat.rgba16float);
        this.viewQuad = this.createViewQuad(`GlobalFog`, "GlobalFog_shader", this.rtTexture);
        let shader = this.viewQuad.quadShader;
        shader.setUniformColor("fogColor", new Color(globalFog.fogColor.r, globalFog.fogColor.g, globalFog.fogColor.b, globalFog.fogColor.a));
        shader.setUniform("fogType", globalFog.fogType);
        shader.setUniform("fogHeightScale", globalFog.fogHeightScale);
        shader.setUniform("start", globalFog.start);
        shader.setUniform("end", globalFog.end);
        shader.setUniform("density", globalFog.density);
        shader.setUniform("ins", globalFog.ins);
        shader.setUniform("falloff", globalFog.falloff);
        shader.setUniform("rayLength", globalFog.rayLength);
        shader.setUniform("scatteringExponent", globalFog.scatteringExponent);
        shader.setUniform("dirHeightLine", globalFog.dirHeightLine);
        shader.setUniform("skyFactor", globalFog.skyFactor);
        shader.setUniform("skyRoughness", globalFog.skyRoughness);
        shader.setUniform("overrideSkyFactor", globalFog.overrideSkyFactor);
        shader.setUniform("isSkyHDR", 0);
        let ptex = rtFrame.getPositionMap();
        let ntex = rtFrame.getNormalMap();
        this.setInputTexture(ptex, ntex);
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.globalFog.enable = true;
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.globalFog.enable = false;
      }
      set fogType(v) {
        this._globalFog.fogType = v;
        this.viewQuad.quadShader.setUniform("fogType", v);
      }
      get fogType() {
        return this._globalFog.fogType;
      }
      set fogHeightScale(v) {
        this._globalFog.fogHeightScale = v;
        this.viewQuad.quadShader.setUniform("fogHeightScale", v);
      }
      get fogHeightScale() {
        return this.viewQuad.quadShader.getUniform("fogHeightScale");
      }
      set start(v) {
        this._globalFog.start = v;
        this.viewQuad.quadShader.setUniform("start", v);
      }
      get start() {
        return this.viewQuad.quadShader.getUniform("start");
      }
      set end(v) {
        this._globalFog.end = v;
        this.viewQuad.quadShader.setUniform("end", v);
      }
      get end() {
        return this.viewQuad.quadShader.getUniform("end");
      }
      set ins(v) {
        this._globalFog.ins = v;
        this.viewQuad.quadShader.setUniform("ins", v);
      }
      get ins() {
        return this.viewQuad.quadShader.getUniform("ins");
      }
      set density(v) {
        this._globalFog.density = v;
        this.viewQuad.quadShader.setUniform("density", v);
      }
      get density() {
        return this.viewQuad.quadShader.getUniform("density");
      }
      set skyRoughness(v) {
        this._globalFog.skyRoughness = v;
        this.viewQuad.quadShader.setUniform("skyRoughness", v);
      }
      get skyRoughness() {
        return this._globalFog.skyRoughness;
      }
      set skyFactor(v) {
        this._globalFog.skyFactor = v;
        this.viewQuad.quadShader.setUniform("skyFactor", v);
      }
      get skyFactor() {
        return this._globalFog.skyFactor;
      }
      set overrideSkyFactor(v) {
        this._globalFog.overrideSkyFactor = v;
        this.viewQuad.quadShader.setUniform("overrideSkyFactor", v);
      }
      get overrideSkyFactor() {
        return this._globalFog.overrideSkyFactor;
      }
      /**
       * @internal
       */
      get fogColor() {
        return this._globalFog.fogColor;
      }
      /**
       * @internal
       */
      set fogColor(value) {
        this._globalFog.fogColor.copyFrom(value);
        this.viewQuad.quadShader.setUniformColor("fogColor", value);
      }
      set falloff(v) {
        this._globalFog.falloff = v;
        this.viewQuad.quadShader.setUniform("falloff", v);
      }
      get falloff() {
        return this.viewQuad.quadShader.getUniform("falloff");
      }
      set rayLength(v) {
        this._globalFog.rayLength = v;
        this.viewQuad.quadShader.setUniform("rayLength", v);
      }
      get rayLength() {
        return this._globalFog.rayLength;
      }
      set scatteringExponent(v) {
        this._globalFog.scatteringExponent = v;
        this.viewQuad.quadShader.setUniform("scatteringExponent", v);
      }
      get scatteringExponent() {
        return this._globalFog.scatteringExponent;
      }
      set dirHeightLine(v) {
        this._globalFog.dirHeightLine = v;
        this.viewQuad.quadShader.setUniform("dirHeightLine", v);
      }
      get dirHeightLine() {
        return this._globalFog.dirHeightLine;
      }
      /**
       * @internal
       */
      setInputTexture(positionMap, normalMap) {
        const pass = this.viewQuad.quadShader;
        pass.setTexture("positionMap", positionMap);
        pass.setTexture("normalMap", normalMap);
        this._lastSkyTexture = this.getSkyTexture();
        pass.setTexture(`prefilterMap`, this._lastSkyTexture);
      }
      _lastSkyTexture;
      getSkyTexture() {
        let texture = Engine3D.res.defaultSky;
        if (EntityCollect.instance.sky instanceof SkyRenderer) {
          texture = EntityCollect.instance.sky.map;
        }
        return texture;
      }
      /**
       * @internal
       */
      render(view, command) {
        const pass = this.viewQuad.quadShader;
        let skyTexture = this.getSkyTexture();
        if (skyTexture != this._lastSkyTexture) {
          this._lastSkyTexture = skyTexture;
          pass.setTexture(`prefilterMap`, this._lastSkyTexture);
        }
        pass.setTexture("colorMap", this.getOutTexture());
        pass.setUniformFloat("isSkyHDR", skyTexture.isHDRTexture ? 1 : 0);
        this.viewQuad.renderTarget(view, this.viewQuad, command);
      }
    }

    class GodRayPost extends PostBase {
      /**
       * @internal
       */
      godRayTexture;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      godRayCompute;
      /**
       * @internal
       */
      historyGodRayData;
      /**
       * @internal
       */
      godRaySetting;
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.godRay.enable = true;
        this.createGUI();
      }
      /**
       * @internal
       */
      Render;
      onDetach(view) {
        Engine3D.setting.render.postProcessing.godRay.enable = false;
        this.removeGUI();
      }
      get blendColor() {
        return Engine3D.setting.render.postProcessing.godRay.blendColor;
      }
      set blendColor(value) {
        Engine3D.setting.render.postProcessing.godRay.blendColor = value;
      }
      get rayMarchCount() {
        return Engine3D.setting.render.postProcessing.godRay.rayMarchCount;
      }
      set rayMarchCount(value) {
        value = clamp(value, 8, 20);
        Engine3D.setting.render.postProcessing.godRay.rayMarchCount = value;
      }
      get scatteringExponent() {
        return Engine3D.setting.render.postProcessing.godRay.scatteringExponent;
      }
      set scatteringExponent(value) {
        value = clamp(value, 1, 40);
        Engine3D.setting.render.postProcessing.godRay.scatteringExponent = value;
      }
      get intensity() {
        return Engine3D.setting.render.postProcessing.godRay.intensity;
      }
      set intensity(value) {
        value = clamp(value, 0.01, 5);
        Engine3D.setting.render.postProcessing.godRay.intensity = value;
      }
      createGUI() {
      }
      removeGUI() {
      }
      createCompute(view) {
        Engine3D.setting.render.postProcessing.godRay;
        this.godRayCompute = new ComputeShader(GodRay_cs);
        let godRaySetting = new UniformGPUBuffer(4 * 3);
        this.godRayCompute.setUniformBuffer("godRayUniform", godRaySetting);
        this.historyGodRayData = new StorageGPUBuffer(4 * this.godRayTexture.width * this.godRayTexture.height);
        this.godRayCompute.setStorageBuffer("historyGodRayData", this.historyGodRayData);
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        this.godRayCompute.setSamplerTexture(`posTex`, rtFrame.renderTargets[1]);
        this.godRayCompute.setSamplerTexture(`normalTex`, rtFrame.renderTargets[2]);
        this.autoSetColorTexture("inTex", this.godRayCompute);
        this.godRayCompute.setStorageTexture(`outTex`, this.godRayTexture);
        let shadowRenderer = Engine3D.getRenderJob(view).shadowMapPassRenderer;
        this.godRayCompute.setSamplerTexture(`shadowMap`, shadowRenderer.depth2DArrayTexture);
        this.godRaySetting = godRaySetting;
        this.onResize();
      }
      createResource() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.godRayTexture = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.godRayTexture.name = "godRayTexture";
        let gtaoDec = new RTDescriptor();
        gtaoDec.loadOp = `load`;
        this.rtFrame = new RTFrame([this.godRayTexture], [gtaoDec]);
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.godRayTexture.resize(w, h);
        this.historyGodRayData.resizeBuffer(4 * this.godRayTexture.width * this.godRayTexture.height);
        this.godRayCompute.setStorageBuffer("historyGodRayData", this.historyGodRayData);
        this.godRayCompute.workerSizeX = Math.ceil(this.godRayTexture.width / 8);
        this.godRayCompute.workerSizeY = Math.ceil(this.godRayTexture.height / 8);
        this.godRayCompute.workerSizeZ = 1;
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.godRayCompute) {
          this.createResource();
          this.createCompute(view);
          let lightUniformEntries = GlobalBindGroup.getLightEntries(view.scene);
          this.godRayCompute.setStorageBuffer("lightBuffer", lightUniformEntries.storageGPUBuffer);
          this.godRayCompute.setStorageBuffer("models", GlobalBindGroup.modelMatrixBindGroup.matrixBufferDst);
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
          this.rendererPassState.label = "GodRay";
          let globalUniform = GlobalBindGroup.getCameraGroup(view.camera);
          this.godRayCompute.setUniformBuffer("globalUniform", globalUniform.uniformGPUBuffer);
        }
        let setting = Engine3D.setting.render.postProcessing.godRay;
        this.godRaySetting.setFloat("intensity", setting.intensity);
        this.godRaySetting.setFloat("rayMarchCount", setting.rayMarchCount);
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.godRaySetting.setFloat("viewPortWidth", w);
        this.godRaySetting.setFloat("viewPortHeight", h);
        this.godRaySetting.setFloat("blendColor", setting.blendColor ? 1 : 0);
        this.godRaySetting.setFloat("scatteringExponent", setting.scatteringExponent);
        this.godRaySetting.apply();
        GPUContext.computeCommand(command, [this.godRayCompute]);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
    }

    class OutlinePostSlot {
      indexList;
      color;
      count;
    }
    class OutlinePostData {
      //Supports up to 8 sets of colors
      SlotCount = 8;
      MaxEntities = 16;
      defaultColor = new Color(0.2, 1, 1, 1);
      slots = [];
      dataDirty = true;
      constructor() {
        let groupCount = Engine3D.setting.render.postProcessing.outline.groupCount;
        this.SlotCount = Math.max(1, Math.min(groupCount, this.SlotCount));
        for (let i = 0; i < this.SlotCount; i++) {
          let slot = this.slots[i] = new OutlinePostSlot();
          slot.indexList = new Float32Array(this.MaxEntities);
          slot.color = this.defaultColor.clone();
          slot.count = 0;
        }
      }
      clear() {
        for (let i = 0; i < this.SlotCount; i++) {
          this.clearAt(i);
        }
      }
      clearAt(slotIndex) {
        this.dataDirty = true;
        let slot = this.slots[slotIndex];
        slot.color.copyFrom(this.defaultColor);
        slot.indexList.fill(-1);
        slot.count = 0;
        return this;
      }
      fillDataAt(slot, indexList, color) {
        this.dataDirty = true;
        let data = this.slots[slot];
        if (data) {
          data.indexList.fill(-1);
          for (let i = 0, c = indexList.length; i < c; i++) {
            data.indexList[i] = indexList[i];
          }
          data.count = indexList.length;
          data.color.copyFrom(color);
        }
        return this;
      }
      fetchData(target) {
        target.dirty = this.dataDirty;
        target.slots = this.slots;
        this.dataDirty = false;
        return this;
      }
    }
    let outlinePostData = new OutlinePostData();

    class OutlinePost extends PostBase {
      /**
       * @internal
       */
      outlineTex;
      /**
        * @internal
        */
      lowTex;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      calcWeightCompute;
      /**
       * @internal
       */
      outlineCompute;
      /**
      * @internal
      */
      blendCompute;
      /**
       * @internal
       */
      outlineSetting;
      /**
       * @internal
       */
      slotsBuffer;
      /**
       * @internal
       */
      slotsArray;
      /**
       * @internal
       */
      entitiesArray;
      /**
       * @internal
       */
      entitiesBuffer;
      /**
       * @internal
       */
      weightBuffer;
      /**
       * @internal
       */
      lowTexSize;
      /**
       * @internal
       */
      oldOutlineColor;
      /**
       * @internal
       */
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.outline.enable = true;
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.outline.enable = false;
      }
      set outlinePixel(value) {
        value = clamp(value, 0, 8);
        let cfg = Engine3D.setting.render.postProcessing.outline;
        if (cfg.outlinePixel != value) {
          cfg.outlinePixel = value;
        }
      }
      get outlinePixel() {
        return Engine3D.setting.render.postProcessing.outline.outlinePixel;
      }
      set fadeOutlinePixel(value) {
        let cfg = Engine3D.setting.render.postProcessing.outline;
        value = clamp(value, 0, 8);
        if (cfg.fadeOutlinePixel != value) {
          cfg.fadeOutlinePixel = value;
        }
      }
      get fadeOutlinePixel() {
        return Engine3D.setting.render.postProcessing.outline.fadeOutlinePixel;
      }
      set strength(value) {
        value = clamp(value, 0, 1);
        let cfg = Engine3D.setting.render.postProcessing.outline;
        if (cfg.strength != value) {
          cfg.strength = value;
        }
      }
      get strength() {
        return Engine3D.setting.render.postProcessing.outline.strength;
      }
      set useAddMode(value) {
        Engine3D.setting.render.postProcessing.outline.useAddMode = value;
      }
      get useAddMode() {
        return Engine3D.setting.render.postProcessing.outline.useAddMode;
      }
      createGUI() {
      }
      createCompute() {
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        let visibleMap = rtFrame.getPositionMap();
        this.calcWeightCompute = new ComputeShader(OutlineCalcOutline_cs);
        this.calcWeightCompute.setStorageBuffer("outlineSetting", this.outlineSetting);
        this.calcWeightCompute.setStorageBuffer("slotsBuffer", this.slotsBuffer);
        this.calcWeightCompute.setStorageBuffer(`weightBuffer`, this.weightBuffer);
        this.calcWeightCompute.setStorageBuffer(`entitiesBuffer`, this.entitiesBuffer);
        this.calcWeightCompute.setSamplerTexture(`indexTexture`, visibleMap);
        this.calcWeightCompute.workerSizeX = Math.ceil(this.lowTex.width / 8);
        this.calcWeightCompute.workerSizeY = Math.ceil(this.lowTex.height / 8);
        this.calcWeightCompute.workerSizeZ = 1;
        this.outlineCompute = new ComputeShader(Outline_cs);
        this.outlineCompute.setStorageBuffer("outlineSetting", this.outlineSetting);
        this.outlineCompute.setStorageBuffer("slotsBuffer", this.slotsBuffer);
        this.outlineCompute.setStorageBuffer(`weightBuffer`, this.weightBuffer);
        this.outlineCompute.setStorageBuffer(`oldOutlineColor`, this.oldOutlineColor);
        this.outlineCompute.setStorageTexture(`lowTex`, this.lowTex);
        this.outlineCompute.workerSizeX = Math.ceil(this.lowTex.width / 8);
        this.outlineCompute.workerSizeY = Math.ceil(this.lowTex.height / 8);
        this.outlineCompute.workerSizeZ = 1;
        this.blendCompute = new ComputeShader(OutLineBlendColor_cs);
        this.blendCompute.setStorageBuffer("outlineSetting", this.outlineSetting);
        this.autoSetColorTexture("inTex", this.blendCompute);
        this.blendCompute.setSamplerTexture(`lowTex`, this.lowTex);
        this.blendCompute.setStorageTexture(`outlineTex`, this.outlineTex);
        this.blendCompute.workerSizeX = Math.ceil(this.outlineTex.width / 8);
        this.blendCompute.workerSizeY = Math.ceil(this.outlineTex.height / 8);
        this.blendCompute.workerSizeZ = 1;
      }
      createResource() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        let textureScale = Engine3D.setting.render.postProcessing.outline.textureScale;
        this.lowTexSize = new Vector2(Math.ceil(w * textureScale), Math.ceil(h * textureScale));
        this.lowTex = new VirtualTexture(this.lowTexSize.x, this.lowTexSize.y, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.lowTex.name = "lowTex";
        let lowDec = new RTDescriptor();
        lowDec.clearValue = [0, 0, 0, 1];
        lowDec.loadOp = `clear`;
        this.outlineTex = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.outlineTex.name = "outlineTex";
        let outDec = new RTDescriptor();
        outDec.clearValue = [0, 0, 0, 1];
        outDec.loadOp = `clear`;
        this.rtFrame = new RTFrame([this.outlineTex], [outDec]);
        this.outlineSetting = new UniformGPUBuffer(8);
        this.weightBuffer = new StorageGPUBuffer(this.lowTexSize.x * this.lowTexSize.y * 4, GPUBufferUsage.COPY_SRC);
        this.oldOutlineColor = new StorageGPUBuffer(this.lowTexSize.x * this.lowTexSize.y * 4, GPUBufferUsage.COPY_SRC);
        this.slotsArray = new Float32Array(outlinePostData.SlotCount * 4);
        this.slotsBuffer = new StorageGPUBuffer(this.slotsArray.length);
        this.slotsBuffer.setFloat32Array("slotsArray", this.slotsArray);
        this.slotsBuffer.apply();
        this.entitiesArray = new Float32Array(outlinePostData.SlotCount * outlinePostData.MaxEntities);
        this.entitiesBuffer = new StorageGPUBuffer(this.entitiesArray.length);
        this.entitiesBuffer.setFloat32Array("entitiesArray", this.entitiesArray);
        this.slotsBuffer.apply();
        this.fetchData ||= {};
      }
      fetchData;
      fetchOutlineData() {
        outlinePostData.fetchData(this.fetchData);
        if (this.fetchData.dirty) {
          let slotCount = outlinePostData.SlotCount;
          let maxEntities = outlinePostData.MaxEntities;
          for (let i = 0; i < slotCount; i++) {
            let offset = 4 * i;
            let slot = this.fetchData.slots[i];
            this.slotsArray[offset + 0] = slot.color.r;
            this.slotsArray[offset + 1] = slot.color.g;
            this.slotsArray[offset + 2] = slot.color.b;
            this.slotsArray[offset + 3] = slot.count;
            offset = maxEntities * i;
            this.entitiesArray.set(slot.indexList, offset);
          }
          this.slotsBuffer.setFloat32Array("slotsArray", this.slotsArray);
          this.slotsBuffer.apply();
          this.entitiesBuffer.setFloat32Array("entitiesArray", this.entitiesArray);
          this.entitiesBuffer.apply();
        }
      }
      computeList;
      /**
       * @internal
       */
      render(view, command) {
        if (!this.calcWeightCompute) {
          this.createResource();
          this.createCompute();
          this.createGUI();
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
        }
        this.computeList ||= [this.calcWeightCompute, this.outlineCompute, this.blendCompute];
        let cfg = Engine3D.setting.render.postProcessing.outline;
        this.outlineSetting.setFloat("strength", cfg.strength);
        this.outlineSetting.setFloat("useAddMode", cfg.useAddMode ? 1 : 0);
        this.outlineSetting.setFloat("outlinePixel", cfg.outlinePixel);
        this.outlineSetting.setFloat("fadeOutlinePixel", cfg.fadeOutlinePixel);
        this.outlineSetting.setFloat("lowTexWidth", this.lowTexSize.x);
        this.outlineSetting.setFloat("lowTexHeight", this.lowTexSize.y);
        this.outlineSetting.apply();
        this.fetchOutlineData();
        GPUContext.computeCommand(command, this.computeList);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        let textureScale = Engine3D.setting.render.postProcessing.outline.textureScale;
        this.lowTexSize = new Vector2(Math.ceil(w * textureScale), Math.ceil(h * textureScale));
        this.lowTex.resize(this.lowTexSize.x, this.lowTexSize.y);
        this.outlineTex.resize(w, h);
        this.weightBuffer.resizeBuffer(this.lowTexSize.x * this.lowTexSize.y * 4);
        this.oldOutlineColor.resizeBuffer(this.lowTexSize.x * this.lowTexSize.y * 4);
        this.calcWeightCompute.workerSizeX = Math.ceil(this.lowTex.width / 8);
        this.calcWeightCompute.workerSizeY = Math.ceil(this.lowTex.height / 8);
        this.calcWeightCompute.workerSizeZ = 1;
        this.outlineCompute.workerSizeX = Math.ceil(this.lowTex.width / 8);
        this.outlineCompute.workerSizeY = Math.ceil(this.lowTex.height / 8);
        this.outlineCompute.workerSizeZ = 1;
        this.blendCompute.workerSizeX = Math.ceil(this.outlineTex.width / 8);
        this.blendCompute.workerSizeY = Math.ceil(this.outlineTex.height / 8);
        this.blendCompute.workerSizeZ = 1;
      }
    }

    class SSRPost extends PostBase {
      SSR_RayTraceCompute;
      SSR_IS_Compute;
      SSR_Blend_Compute;
      /**
       * @internal
       */
      isRetTexture;
      /**
       * @internal
       */
      finalTexture;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      ssrUniformBuffer;
      /**
       * @internal
       */
      rayTraceData;
      /**
       * @internal
       */
      ssrColorData;
      /**
       * @internal
       */
      isKernelFloat32Array;
      rtFrame;
      historyPosition;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.ssr.enable = true;
        this.debug();
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.ssr.enable = false;
      }
      reflectionRatio = 0.5;
      //sqrt
      get fadeEdgeRatio() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.fadeEdgeRatio;
      }
      set fadeEdgeRatio(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.fadeEdgeRatio = value;
      }
      get rayMarchRatio() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.rayMarchRatio;
      }
      set rayMarchRatio(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.rayMarchRatio = value;
      }
      get roughnessThreshold() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.roughnessThreshold;
      }
      set roughnessThreshold(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.roughnessThreshold = value;
      }
      get fadeDistanceMin() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.fadeDistanceMin;
      }
      set fadeDistanceMin(value) {
        value = clamp(value, 0, 1e4);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.fadeDistanceMin = value;
      }
      get fadeDistanceMax() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.fadeDistanceMax;
      }
      set fadeDistanceMax(value) {
        value = clamp(value, 0, 1e4);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.fadeDistanceMax = value;
      }
      get powDotRN() {
        let setting = Engine3D.setting.render.postProcessing.ssr;
        return setting.powDotRN;
      }
      set powDotRN(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.ssr;
        setting.powDotRN = value;
      }
      debug() {
      }
      createRayTraceShader() {
        this.SSR_RayTraceCompute = new ComputeShader(SSR_RayTrace_cs);
        this.SSR_RayTraceCompute.setStorageBuffer("ssrUniform", this.ssrUniformBuffer);
        this.SSR_RayTraceCompute.setStorageBuffer(`rayTraceBuffer`, this.rayTraceData);
        this.SSR_RayTraceCompute.setStorageBuffer(`historyPosition`, this.historyPosition);
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        this.SSR_RayTraceCompute.setSamplerTexture("zBufferTexture", rtFrame.getPositionMap());
        this.SSR_RayTraceCompute.setSamplerTexture(RTResourceConfig.normalBufferTex_NAME, rtFrame.renderTargets[2]);
        this.SSR_RayTraceCompute.setSamplerTexture(RTResourceConfig.materialBufferTex_NAME, rtFrame.renderTargets[3]);
        if (EntityCollect.instance.sky instanceof SkyRenderer)
          this.SSR_RayTraceCompute.setSamplerTexture(`prefilterMap`, EntityCollect.instance.sky.map);
        this.SSR_RayTraceCompute.workerSizeX = Math.ceil(this.isRetTexture.width / 8);
        this.SSR_RayTraceCompute.workerSizeY = Math.ceil(this.isRetTexture.height / 8);
        this.SSR_RayTraceCompute.workerSizeZ = 1;
      }
      createISShader() {
        this.SSR_IS_Compute = new ComputeShader(SSR_IS_cs);
        this.SSR_IS_Compute.setStorageBuffer("ssrUniform", this.ssrUniformBuffer);
        this.SSR_IS_Compute.setStorageBuffer(`rayTraceBuffer`, this.rayTraceData);
        this.SSR_IS_Compute.setStorageBuffer(`ssrColorData`, this.ssrColorData);
        this.SSR_IS_Compute.setStorageBuffer(`historyPosition`, this.historyPosition);
        this.autoSetColorTexture("colorMap", this.SSR_IS_Compute);
        this.SSR_IS_Compute.setStorageTexture(`outTex`, this.isRetTexture);
        this.SSR_IS_Compute.workerSizeX = Math.ceil(this.isRetTexture.width / 8);
        this.SSR_IS_Compute.workerSizeY = Math.ceil(this.isRetTexture.height / 8);
        this.SSR_IS_Compute.workerSizeZ = 1;
      }
      createBlendShader(input) {
        this.SSR_Blend_Compute = new ComputeShader(SSR_BlendColor_cs);
        this.SSR_Blend_Compute.setStorageBuffer(`rayTraceBuffer`, this.rayTraceData);
        this.autoSetColorTexture("colorMap", this.SSR_Blend_Compute);
        this.SSR_Blend_Compute.setSamplerTexture(`ssrMap`, input);
        this.SSR_Blend_Compute.setStorageTexture(`outTex`, this.finalTexture);
        this.SSR_Blend_Compute.workerSizeX = Math.ceil(this.finalTexture.width / 8);
        this.SSR_Blend_Compute.workerSizeY = Math.ceil(this.finalTexture.height / 8);
        this.SSR_Blend_Compute.workerSizeZ = 1;
      }
      createResource() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.finalTexture = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        this.finalTexture.name = "ssrOutTex";
        let rtDec = new RTDescriptor();
        rtDec.clearValue = [0, 0, 0, 0];
        rtDec.loadOp = `clear`;
        let ssrWidth = Math.ceil(w * Engine3D.setting.render.postProcessing.ssr.pixelRatio);
        let ssrHeight = Math.ceil(h * Engine3D.setting.render.postProcessing.ssr.pixelRatio);
        this.isRetTexture = new VirtualTexture(ssrWidth, ssrHeight, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING);
        this.isRetTexture.name = "ssrTextureIn";
        let isRetDec = new RTDescriptor();
        isRetDec.clearValue = [0, 0, 0, 0];
        isRetDec.loadOp = `clear`;
        this.rtFrame = new RTFrame([
          this.finalTexture,
          this.isRetTexture
        ], [
          rtDec,
          isRetDec
        ]);
        this.rayTraceData = new StorageGPUBuffer(ssrWidth * ssrHeight * 8, GPUBufferUsage.COPY_SRC);
        this.ssrColorData = new StorageGPUBuffer(ssrWidth * ssrHeight * 4, GPUBufferUsage.COPY_SRC);
        this.historyPosition = new StorageGPUBuffer(ssrWidth * ssrHeight * 4, GPUBufferUsage.COPY_SRC);
        this.ssrUniformBuffer = new UniformGPUBuffer(4 * 8);
        this.ssrUniformBuffer.setFloat("ssrBufferSizeX", this.isRetTexture.width);
        this.ssrUniformBuffer.setFloat("ssrBufferSizeY", this.isRetTexture.height);
        this.ssrUniformBuffer.setFloat("colorMapSizeX", this.finalTexture.width);
        this.ssrUniformBuffer.setFloat("colorMapSizeY", this.finalTexture.height);
        this.ssrUniformBuffer.apply();
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.SSR_RayTraceCompute) {
          this.createResource();
          this.createISShader();
          this.createRayTraceShader();
          this.createBlendShader(this.isRetTexture);
          this.finalTexture;
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
          let standUniform = GlobalBindGroup.getCameraGroup(view.camera);
          this.SSR_RayTraceCompute.setUniformBuffer("standUniform", standUniform.uniformGPUBuffer);
        }
        let setting = Engine3D.setting.render.postProcessing.ssr;
        this.ssrUniformBuffer.setFloat("fadeEdgeRatio", setting.fadeEdgeRatio);
        this.ssrUniformBuffer.setFloat("rayMarchRatio", setting.rayMarchRatio);
        this.ssrUniformBuffer.setFloat("fadeDistanceMin", setting.fadeDistanceMin);
        this.ssrUniformBuffer.setFloat("fadeDistanceMax", setting.fadeDistanceMax);
        this.ssrUniformBuffer.setFloat("mixThreshold", setting.mixThreshold);
        this.ssrUniformBuffer.setFloat("roughnessThreshold", setting.roughnessThreshold);
        this.ssrUniformBuffer.setFloat("reflectionRatio", this.reflectionRatio);
        this.ssrUniformBuffer.setFloat("powDotRN", setting.powDotRN);
        this.ssrUniformBuffer.setFloat("randomSeedX", Math.random());
        this.ssrUniformBuffer.setFloat("randomSeedY", Math.random());
        this.ssrUniformBuffer.apply();
        let computes = [this.SSR_RayTraceCompute, this.SSR_IS_Compute, this.SSR_Blend_Compute];
        GPUContext.computeCommand(command, computes);
        GPUContext.lastRenderPassState = this.rendererPassState;
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        let ssrWidth = Math.ceil(w * Engine3D.setting.render.postProcessing.ssr.pixelRatio);
        let ssrHeight = Math.ceil(h * Engine3D.setting.render.postProcessing.ssr.pixelRatio);
        this.finalTexture.resize(w, h);
        this.isRetTexture.resize(ssrWidth, ssrHeight);
        this.rayTraceData.resizeBuffer(ssrWidth * ssrHeight * 8);
        this.ssrColorData.resizeBuffer(ssrWidth * ssrHeight * 4);
        this.historyPosition.resizeBuffer(ssrWidth * ssrHeight * 4);
        this.ssrUniformBuffer.setFloat("ssrBufferSizeX", this.isRetTexture.width);
        this.ssrUniformBuffer.setFloat("ssrBufferSizeY", this.isRetTexture.height);
        this.ssrUniformBuffer.setFloat("colorMapSizeX", this.finalTexture.width);
        this.ssrUniformBuffer.setFloat("colorMapSizeY", this.finalTexture.height);
        this.SSR_RayTraceCompute.workerSizeX = Math.ceil(this.isRetTexture.width / 8);
        this.SSR_RayTraceCompute.workerSizeY = Math.ceil(this.isRetTexture.height / 8);
        this.SSR_RayTraceCompute.workerSizeZ = 1;
        this.SSR_IS_Compute.workerSizeX = Math.ceil(this.isRetTexture.width / 8);
        this.SSR_IS_Compute.workerSizeY = Math.ceil(this.isRetTexture.height / 8);
        this.SSR_IS_Compute.workerSizeZ = 1;
        this.SSR_Blend_Compute.workerSizeX = Math.ceil(this.finalTexture.width / 8);
        this.SSR_Blend_Compute.workerSizeY = Math.ceil(this.finalTexture.height / 8);
        this.SSR_Blend_Compute.workerSizeZ = 1;
      }
    }
    class SSR_IS_Kernel {
      static createSeeds() {
        let scaler = 20;
        let count = 32;
        let list = [new Vector3(0, 0, scaler)];
        let angle = 0;
        let radius = 0.02;
        for (let i = 1; i < count; i++) {
          let pt = new Vector3();
          list.push(pt);
          angle += 1 - (1 - 0.618) * i / count;
          radius += i * 0.01;
          pt.x = Math.sin(angle) * radius;
          pt.y = Math.cos(angle) * radius;
          pt.z = 1 - i / count;
          pt.multiplyScalar(scaler);
        }
        return list;
      }
    }

    class TAAPost extends PostBase {
      /**
       * @internal
       */
      taaTexture;
      outTexture;
      /**
       * @internal
       */
      rendererPassState;
      /**
       * @internal
       */
      taaCompute;
      copyTexCompute;
      sharpCompute;
      /**
       * @internal
       */
      taaSetting;
      /**
       * @internal
       */
      preColorBuffer;
      preColorTex;
      /**
       * @internal
       */
      preProjMatrix;
      preViewMatrix;
      rtFrame;
      constructor() {
        super();
      }
      /**
       * @internal
       */
      onAttach(view) {
        Engine3D.setting.render.postProcessing.taa.enable = true;
        view.camera.enableJitterProjection(true);
        this.createGUI();
      }
      /**
       * @internal
       */
      onDetach(view) {
        Engine3D.setting.render.postProcessing.taa.enable = false;
        view.camera.enableJitterProjection(false);
      }
      get jitterSeedCount() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        return setting.jitterSeedCount;
      }
      set jitterSeedCount(value) {
        value = clamp(value, 2, 8);
        value = Math.round(value);
        let setting = Engine3D.setting.render.postProcessing.taa;
        setting.jitterSeedCount = value;
      }
      get blendFactor() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        return setting.blendFactor;
      }
      set blendFactor(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.taa;
        setting.blendFactor = value;
      }
      get sharpFactor() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        return setting.sharpFactor;
      }
      set sharpFactor(value) {
        value = clamp(value, 0.1, 0.9);
        let setting = Engine3D.setting.render.postProcessing.taa;
        setting.sharpFactor = value;
      }
      get sharpPreBlurFactor() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        return setting.sharpPreBlurFactor;
      }
      set sharpPreBlurFactor(value) {
        value = clamp(value, 0.1, 0.9);
        let setting = Engine3D.setting.render.postProcessing.taa;
        setting.sharpPreBlurFactor = value;
      }
      get temporalJitterScale() {
        let setting = Engine3D.setting.render.postProcessing.taa;
        return setting.temporalJitterScale;
      }
      set temporalJitterScale(value) {
        value = clamp(value, 0, 1);
        let setting = Engine3D.setting.render.postProcessing.taa;
        setting.temporalJitterScale = value;
      }
      createGUI() {
      }
      createCompute(view) {
        let computeShader = new ComputeShader(TAA_cs);
        Engine3D.setting.render.postProcessing.taa;
        let taaSetting = new UniformGPUBuffer(16 * 2 + 4 * 3);
        let standUniform = GlobalBindGroup.getCameraGroup(view.camera);
        computeShader.setUniformBuffer("standUniform", standUniform.uniformGPUBuffer);
        computeShader.setUniformBuffer("taaData", taaSetting);
        computeShader.setStorageBuffer(`preColorBuffer`, this.preColorBuffer);
        let rtFrame = GBufferFrame.getGBufferFrame("ColorPassGBuffer");
        computeShader.setSamplerTexture(`preColorTex`, this.preColorTex);
        computeShader.setSamplerTexture(`posTex`, rtFrame.getPositionMap());
        this.autoSetColorTexture("inTex", computeShader);
        computeShader.setStorageTexture(`outTex`, this.taaTexture);
        computeShader.workerSizeX = Math.ceil(this.taaTexture.width / 8);
        computeShader.workerSizeY = Math.ceil(this.taaTexture.height / 8);
        computeShader.workerSizeZ = 1;
        this.taaCompute = computeShader;
        this.taaSetting = taaSetting;
        this.copyTexCompute = new ComputeShader(TAACopyTex_cs);
        this.copyTexCompute.setStorageBuffer(`preColor`, this.preColorBuffer);
        this.copyTexCompute.setStorageTexture(`preColorTex`, this.preColorTex);
        this.copyTexCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8);
        this.copyTexCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8);
        this.copyTexCompute.workerSizeZ = 1;
        this.sharpCompute = new ComputeShader(TAASharpTex_cs);
        this.sharpCompute.setUniformBuffer("taaData", taaSetting);
        this.sharpCompute.setSamplerTexture(`inTex`, this.taaTexture);
        this.sharpCompute.setStorageTexture(`outTex`, this.outTexture);
        this.sharpCompute.workerSizeX = Math.ceil(this.outTexture.width / 8);
        this.sharpCompute.workerSizeY = Math.ceil(this.outTexture.height / 8);
        this.sharpCompute.workerSizeZ = 1;
      }
      createResource() {
        this.preProjMatrix = new Matrix4().identity();
        this.preViewMatrix = new Matrix4().identity();
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.preColorBuffer = new StorageGPUBuffer(w * h * 4, GPUBufferUsage.COPY_SRC);
        this.preColorTex = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.preColorTex.name = "taaTex";
        let preColorDec = new RTDescriptor();
        preColorDec.clearValue = [0, 0, 0, 1];
        preColorDec.loadOp = `clear`;
        this.taaTexture = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.taaTexture.name = "taaTex";
        let taaDec = new RTDescriptor();
        taaDec.clearValue = [0, 0, 0, 1];
        taaDec.loadOp = `clear`;
        this.outTexture = new VirtualTexture(w, h, GPUTextureFormat.rgba16float, false, GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING);
        this.outTexture.name = "sharpTaaTex";
        let outDec = new RTDescriptor();
        outDec.clearValue = [0, 0, 0, 1];
        outDec.loadOp = `clear`;
        this.rtFrame = new RTFrame([
          this.preColorTex,
          this.taaTexture,
          this.outTexture
        ], [
          preColorDec,
          taaDec,
          outDec
        ]);
      }
      /**
       * @internal
       */
      render(view, command) {
        if (!this.taaCompute) {
          this.createResource();
          this.createCompute(view);
          this.rendererPassState = WebGPUDescriptorCreator.createRendererPassState(this.rtFrame, null);
        }
        let cfg = Engine3D.setting.render.postProcessing.taa;
        this.taaSetting.setMatrix("preProjMatrix", this.preProjMatrix);
        this.taaSetting.setMatrix("preViewMatrix", this.preViewMatrix);
        this.taaSetting.setFloat("jitterFrameIndex", view.camera.jitterFrameIndex);
        this.taaSetting.setFloat("blendFactor", cfg.blendFactor);
        this.taaSetting.setFloat("sharpFactor", cfg.sharpFactor);
        this.taaSetting.setFloat("sharpPreBlurFactor", cfg.sharpPreBlurFactor);
        this.taaSetting.setFloat("jitterX", view.camera.jitterX);
        this.taaSetting.setFloat("jitterY", view.camera.jitterY);
        this.taaSetting.apply();
        GPUContext.computeCommand(command, [this.copyTexCompute, this.taaCompute, this.sharpCompute]);
        GPUContext.lastRenderPassState = this.rendererPassState;
        this.preProjMatrix.copyFrom(view.camera.projectionMatrix);
        this.preViewMatrix.copyFrom(view.camera.viewMatrix);
      }
      onResize() {
        let presentationSize = webGPUContext.presentationSize;
        let w = presentationSize[0];
        let h = presentationSize[1];
        this.preColorBuffer.resizeBuffer(w * h * 4);
        this.taaTexture.resize(w, h);
        this.outTexture.resize(w, h);
        this.preColorTex.resize(w, h);
        this.taaCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8);
        this.taaCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8);
        this.taaCompute.workerSizeZ = 1;
        this.copyTexCompute.workerSizeX = Math.ceil(this.taaTexture.width / 8);
        this.copyTexCompute.workerSizeY = Math.ceil(this.taaTexture.height / 8);
        this.copyTexCompute.workerSizeZ = 1;
        this.sharpCompute.workerSizeX = Math.ceil(this.outTexture.width / 8);
        this.sharpCompute.workerSizeY = Math.ceil(this.outTexture.height / 8);
        this.sharpCompute.workerSizeZ = 1;
      }
    }

    class OutlinePostManager {
      _tempIndexArray = [];
      /**
       * config outline manager.
       * Specify specific 3D objects to use the specified color for display outline
       * @param objectList A set of 3D objects
       * @param color Specified color for outline
       */
      setOutline(objectList, color) {
        this.setOutlineList([objectList], color ? [color] : null);
      }
      /**
       * config outline manager.
       * The first set of objects uses the first color to display outline, and so on
       * @param groupList A group of 3D objects set
       * @param colorList Specified color list for outline
       */
      setOutlineList(groupList, colorList) {
        groupList ||= [];
        let defaultColor = outlinePostData.defaultColor;
        let maxGroup = outlinePostData.SlotCount;
        for (let i = 0; i < maxGroup; i++) {
          this._tempIndexArray.length = 0;
          let group = groupList[i];
          let color = (colorList ? colorList[i] : null) || defaultColor;
          if (group) {
            for (const item of group) {
              this.getEntityIdList(item, this._tempIndexArray);
            }
          }
          outlinePostData.fillDataAt(i, this._tempIndexArray, color);
        }
      }
      /**
       * clear outline effect
       */
      clearOutline() {
        outlinePostData.clear();
        return this;
      }
      _rendererList = [];
      getEntityIdList(item, target) {
        this._rendererList.length = 0;
        let renderers = item.getComponents(exports.MeshRenderer, this._rendererList);
        for (const render of renderers) {
          target.push(render.object3D.transform._worldMatrix.index);
        }
      }
    }
    let outlinePostManager = new OutlinePostManager();

    class PickResult {
      /**
       * the intersection point (local coordinates) on the model.
       */
      localPosition = new Vector3();
      /**
       * the intersection point (world coordinates) on the model.
       */
      worldPosition = new Vector3();
      /**
       * the uv on the model.
       * Only when the PickType of the object is UVPick and the model has UV will it be valid
       * @see PickType
       */
      uv = new Vector2();
      /**
       * the triangle index at the intersection position of mesh
       */
      faceIndex;
      isIn = false;
      t = 0;
      u = 0;
      v = 0;
      /**
       * the triangle at the intersection position of mesh
       */
      triangle;
      /**
       * @internal
       * the uv0 at the intersection position of mesh
       */
      v0;
      /**
       * @internal
       * the uv1 at the intersection position of mesh
       */
      v1;
      /**
       * @internal
       */
      v2;
      /**
       * @internal
       */
      pickList;
      /**
      * @internal
      */
      color;
      //= new Color();
    }

    class RayCastMeshDetail {
      /**
       * define a tiny number
       */
      static EPS = 1e-4;
      /**
       * define a maximum float
       */
      static FLT_MAX = 3402823466e29;
      /**
       * calculate the distance between a point and a plane(defined by point a, point b, point c)
       */
      static distPtTri(p, a, b, c) {
        let v0 = new Vector3();
        let v1 = new Vector3();
        let v2 = new Vector3();
        c.subtract(a, v0);
        b.subtract(a, v1);
        p.subtract(a, v2);
        let dot00 = dot(v0, v0);
        let dot01 = dot(v0, v1);
        let dot02 = dot(v0, v2);
        let dot11 = dot(v1, v1);
        let dot12 = dot(v1, v2);
        let invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        let u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        let v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        if (u >= -RayCastMeshDetail.EPS && v >= -RayCastMeshDetail.EPS && u + v <= 1 + RayCastMeshDetail.EPS) {
          let y = a[1] + v0[1] * u + v1[1] * v;
          return Math.abs(y - p[1]);
        }
        return RayCastMeshDetail.FLT_MAX;
      }
      static _info = new PickResult();
      // Determine whether a ray intersect with a triangle
      // Parameters
      // orig: origin of the ray
      // dir: direction of the ray
      // v0, v1, v2: vertices of triangle
      // t(out): weight of the intersection for the ray
      // u(out), v(out): barycentric coordinate of intersection
      static IntersectTriangle(ray, face, backfaceCulling) {
        let v0 = face.v1;
        let v1 = face.v2;
        let v2 = face.v3;
        let E1 = v1.subtract(v0, Vector3.HELP_3);
        let E2 = v2.subtract(v0, Vector3.HELP_4);
        let P = ray.direction.crossProduct(E2, Vector3.HELP_5);
        let det = dot(E1, P);
        let T;
        if (det > 0) {
          if (backfaceCulling) {
            return null;
          }
          T = ray.origin.subtract(v0, Vector3.HELP_2);
        } else {
          T = v0.subtract(ray.origin, Vector3.HELP_2);
          det = -det;
        }
        if (det < 1e-4) {
          this._info.isIn = false;
          this._info.t = 0;
          this._info.u = 0;
          this._info.v = 0;
          return this._info;
        }
        let u = dot(T, P);
        if (u < 0 || u > det) {
          this._info.isIn = false;
          this._info.t = 0;
          this._info.u = 0;
          this._info.v = 0;
          return this._info;
        }
        let Q = T.crossProduct(E1, Vector3.HELP_1);
        let v = dot(ray.direction, Q);
        if (v < 0 || u + v > det) {
          this._info.isIn = false;
          this._info.t = 0;
          this._info.u = 0;
          this._info.v = 0;
          return this._info;
        }
        let t = dot(E2, Q);
        let fInvDet = 1 / det;
        t *= fInvDet;
        u *= fInvDet;
        v *= fInvDet;
        this._info.isIn = true;
        this._info.t = t;
        this._info.u = u;
        this._info.v = v;
        let d = 1 - u - v;
        this._u0.copyFrom(face.u1);
        this._u0.scale(d);
        this._u1.copyFrom(face.u2);
        this._u1.scale(u);
        this._u2.copyFrom(face.u3);
        this._u2.scale(v);
        this._info.uv.copyFrom(this._u0);
        this._info.uv.add(this._u1, this._info.uv);
        this._info.uv.add(this._u2, this._info.uv);
        this._info.localPosition.copyFrom(ray.direction).multiplyScalar(t);
        this._info.localPosition.add(ray.origin, this._info.localPosition);
        return this._info;
      }
      static _u0 = new Vector2();
      static _u1 = new Vector2();
      static _u2 = new Vector2();
    }

    class LoaderManager extends CEventDispatcher {
      static _instance;
      _maxRetry = 3;
      /**
       * Load multiple resources of the same type simultaneously
       * @param urls URL list
       * @param c Type of resource parser
       * @returns
       */
      loadAll(urls, c) {
        return new Promise((succ, fail) => {
          let count = urls.length;
          let ret = [];
          urls.forEach((url, index) => {
            let parser = new c();
            this.load(url, c).then((data) => {
              parser.parse(data);
              ret.push(parser);
              count--;
              if (count === 0) {
                succ(ret);
              }
            });
          });
        });
      }
      constructor() {
        super();
        if (LoaderManager._instance) {
          throw new Error("LoadManager is singleton class...");
        }
      }
      static getInstance() {
        return this._instance || (this._instance = new LoaderManager());
      }
      loadUrls(urls, c) {
        return new Promise((succ, fail) => {
          let count = urls.length;
          let ret = [];
          urls.forEach((url, index) => {
            this.load(url, c).then((data) => {
              ret.push(data);
              count--;
              if (count === 0) {
                succ(ret);
              }
              if (count < 0) {
                console.error(`loadUrls ${urls} error`);
              }
            });
          });
        });
      }
      get maxRetry() {
        return this._maxRetry;
      }
      set maxRetry(value) {
        this._maxRetry = value;
      }
      // public set retry(value: number) {
      //   this._maxRetry = value;
      // }
      // public get retry():number {
      //   return this._maxRetry;
      // }
      load(url, c) {
        return new Promise((succ, fail) => {
          switch (c[`format`]) {
                  }
        });
      }
    }

    var GeoType = /* @__PURE__ */ ((GeoType2) => {
      GeoType2["Point"] = "Point";
      GeoType2["LineString"] = "LineString";
      GeoType2["MultiPolygon"] = "MultiPolygon";
      return GeoType2;
    })(GeoType || {});
    class GeoJsonParser extends ParserBase {
      static format = ParserFormat.JSON;
      json;
      async parseString(data) {
        this.json = data;
        this.data = JSON.parse(data);
      }
    }

    class GeoJsonUtil {
      static getPath(data) {
        let lineArray = [];
        for (let i = 0; i < data.features.length; i++) {
          const element = data.features[i];
          switch (element.geometry.type) {
            case GeoType.LineString:
              break;
            case GeoType.MultiPolygon:
              let point3s = [];
              for (let i2 = 0; i2 < element.geometry.coordinates.length; i2++) {
                const pointArray = element.geometry.coordinates[i2];
                for (const list of pointArray) {
                  for (const iterator of list) {
                    let point3 = new Vector3(iterator[0], 0, iterator[1]);
                    point3s.push(point3);
                  }
                }
              }
              lineArray.push(point3s);
              break;
          }
        }
        return lineArray;
      }
    }

    class KHR_lights_punctual {
    }

    class KHR_materials_ior {
    }

    class KHR_materials_sheen {
    }

    class KHR_materials_specular {
    }

    class KHR_materials_transmission {
    }

    class KHR_materials_variants {
    }

    class KHR_materials_volume {
    }

    class KHR_mesh_quantization {
    }

    class KHR_texture_basisu {
    }

    class KHR_texture_transform {
    }

    class PrefabBoneData {
      boneName;
      bonePath;
      parentBoneName;
      boneID;
      parentBoneID;
      instanceID;
      parentInstanceID;
      t;
      q;
      s;
      formBytes(bytes) {
        this.boneName = bytes.readUTF();
        this.bonePath = bytes.readUTF();
        this.parentBoneName = bytes.readUTF();
        this.boneID = bytes.readInt32();
        this.parentBoneID = bytes.readInt32();
        this.instanceID = bytes.readUTF();
        this.parentInstanceID = bytes.readUTF();
        this.t = bytes.readVector3();
        this.q = bytes.readQuaternion();
        this.s = bytes.readVector3();
      }
    }

    class PrefabAvatarData {
      name;
      count;
      boneData;
      boneMap;
      formBytes(bytes) {
        this.boneData = [];
        this.boneMap = /* @__PURE__ */ new Map();
        this.name = bytes.readUTF();
        this.count = bytes.readInt32();
        for (let i = 0; i < this.count; i++) {
          let boneData = new PrefabBoneData();
          boneData.formBytes(bytes.readBytesArray());
          this.boneData[i] = boneData;
          this.boneMap.set(boneData.boneName, boneData);
        }
      }
    }

    class PrefabAvatarParser extends ParserBase {
      static format = ParserFormat.BIN;
      static parser(bytesStream, prefabParser) {
        let avatarCount = bytesStream.readInt32();
        for (let j = 0; j < avatarCount; j++) {
          let prefabAvatarData = new PrefabAvatarData();
          prefabAvatarData.formBytes(bytesStream.readBytesArray());
          Engine3D.res.addObj(prefabAvatarData.name, prefabAvatarData);
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
    }
    ({
      "Position": VertexAttributeName.position,
      "Normal": VertexAttributeName.normal,
      "Color": VertexAttributeName.color,
      "Tangent": VertexAttributeName.TANGENT,
      "TexCoord0": VertexAttributeName.uv,
      "TexCoord1": VertexAttributeName.TEXCOORD_1,
      "TexCoord2": VertexAttributeName.TEXCOORD_2,
      "TexCoord3": VertexAttributeName.TEXCOORD_2,
      "TexCoord4": VertexAttributeName.TEXCOORD_4,
      "TexCoord5": VertexAttributeName.TEXCOORD_5,
      "TexCoord6": VertexAttributeName.TEXCOORD_6,
      "TexCoord7": VertexAttributeName.TEXCOORD_7,
      "BlendIndices": VertexAttributeName.joints0,
      "BlendWeight": VertexAttributeName.weights0
    });

    var ValueEnumType = /* @__PURE__ */ ((ValueEnumType2) => {
      ValueEnumType2[ValueEnumType2["single"] = 0] = "single";
      ValueEnumType2[ValueEnumType2["boolean"] = 1] = "boolean";
      ValueEnumType2[ValueEnumType2["int"] = 2] = "int";
      ValueEnumType2[ValueEnumType2["int16"] = 3] = "int16";
      ValueEnumType2[ValueEnumType2["int32"] = 4] = "int32";
      ValueEnumType2[ValueEnumType2["float"] = 5] = "float";
      ValueEnumType2[ValueEnumType2["long"] = 6] = "long";
      ValueEnumType2[ValueEnumType2["uint"] = 7] = "uint";
      ValueEnumType2[ValueEnumType2["uint32"] = 8] = "uint32";
      ValueEnumType2[ValueEnumType2["uint64"] = 9] = "uint64";
      ValueEnumType2[ValueEnumType2["double"] = 10] = "double";
      ValueEnumType2[ValueEnumType2["string"] = 11] = "string";
      ValueEnumType2[ValueEnumType2["singleArray"] = 12] = "singleArray";
      ValueEnumType2[ValueEnumType2["stringArray"] = 13] = "stringArray";
      ValueEnumType2[ValueEnumType2["floatArray"] = 14] = "floatArray";
      ValueEnumType2[ValueEnumType2["vector2"] = 15] = "vector2";
      ValueEnumType2[ValueEnumType2["vector3"] = 16] = "vector3";
      ValueEnumType2[ValueEnumType2["vector4"] = 17] = "vector4";
      ValueEnumType2[ValueEnumType2["color"] = 18] = "color";
      ValueEnumType2[ValueEnumType2["color32"] = 19] = "color32";
      ValueEnumType2[ValueEnumType2["animationCurve"] = 20] = "animationCurve";
      ValueEnumType2[ValueEnumType2["quaternion"] = 21] = "quaternion";
      ValueEnumType2[ValueEnumType2["matrix4x4"] = 22] = "matrix4x4";
      ValueEnumType2[ValueEnumType2["mesh"] = 23] = "mesh";
      ValueEnumType2[ValueEnumType2["texture"] = 24] = "texture";
      ValueEnumType2[ValueEnumType2["material"] = 25] = "material";
      ValueEnumType2[ValueEnumType2["materials"] = 26] = "materials";
      ValueEnumType2[ValueEnumType2["skeleton"] = 27] = "skeleton";
      ValueEnumType2[ValueEnumType2["animClip"] = 28] = "animClip";
      ValueEnumType2[ValueEnumType2["vector2Int"] = 29] = "vector2Int";
      ValueEnumType2[ValueEnumType2["int32List"] = 30] = "int32List";
      ValueEnumType2[ValueEnumType2["colorList"] = 31] = "colorList";
      ValueEnumType2[ValueEnumType2["color32List"] = 32] = "color32List";
      return ValueEnumType2;
    })(ValueEnumType || {});

    class MaterialUtilities {
      static GetMaterial(shaderName) {
        let name = shaderName;
        let list = name.split("/");
        name = list[list.length - 1];
        list = name.split(".");
        name = list[list.length - 1];
        let shader = GetShader(name);
        if (shader) {
          let material = new Material();
          material.shader = new shader();
          return material;
        } else {
          throw new Error("not found shader, shader name is " + name);
        }
      }
      static applyMaterialTexture(mat, textures) {
        for (let ii = 0; ii < textures.length; ii++) {
          const texInfo = textures[ii];
          if (texInfo.property in mat) {
            mat[texInfo.property] = texInfo.texture;
          } else if (texInfo.property in mat.shader) {
            mat.shader[texInfo.property] = texInfo.texture;
          } else {
            mat.setTexture(texInfo.property, texInfo.texture);
          }
        }
      }
      static applyMaterialProperties(mat, properties) {
        for (let ii = 0; ii < properties.length; ii++) {
          const propertyInfo = properties[ii];
          const key = propertyInfo.key;
          switch (propertyInfo.type) {
            case ValueEnumType.color:
            case ValueEnumType.color32:
              {
                let value = propertyInfo.getValue();
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformColor(key, value);
                }
              }
              break;
            case ValueEnumType.single:
            case ValueEnumType.float:
            case ValueEnumType.int:
            case ValueEnumType.int16:
            case ValueEnumType.int32:
            case ValueEnumType.uint:
            case ValueEnumType.uint32:
            case ValueEnumType.uint64:
              {
                let value = propertyInfo.getValue();
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformFloat(key, value);
                }
              }
              break;
            case ValueEnumType.singleArray:
              {
                let value = propertyInfo.getValue()[0];
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformFloat(key, value);
                }
              }
              break;
            case ValueEnumType.vector2:
            case ValueEnumType.vector2Int:
              {
                let value = propertyInfo.getValue();
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformVector2(key, value);
                }
              }
              break;
            case ValueEnumType.vector3:
              {
                let value = propertyInfo.getValue();
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformVector3(key, value);
                }
              }
              break;
            case ValueEnumType.vector4:
              {
                let value = propertyInfo.getValue();
                if (key in mat) {
                  mat[key] = value;
                } else if (key in mat.shader) {
                  mat.shader[key] = value;
                } else {
                  mat.setUniformVector4(key, value);
                }
              }
              break;
          }
        }
      }
    }

    class ValueParser {
      static parser(bytes) {
        let type = bytes.readInt32();
        switch (type) {
          case ValueEnumType.single:
            return { t: ValueEnumType.single, v: bytes.readFloat32() };
          case ValueEnumType.boolean:
            return { t: ValueEnumType.boolean, v: bytes.readBoolean() };
          case ValueEnumType.int:
            return { t: ValueEnumType.int, v: bytes.readInt32() };
          case ValueEnumType.int16:
            return { t: ValueEnumType.int16, v: bytes.readInt16() };
          case ValueEnumType.int32:
            return { t: ValueEnumType.int32, v: bytes.readInt32() };
          case ValueEnumType.float:
            return { t: ValueEnumType.float, v: bytes.readFloat32() };
          case ValueEnumType.long:
            return { t: ValueEnumType.long, v: bytes.readFloat64() };
          case ValueEnumType.uint:
            return { t: ValueEnumType.uint, v: bytes.readUnit32() };
          case ValueEnumType.uint32:
            return { t: ValueEnumType.uint32, v: bytes.readUnit32() };
          case ValueEnumType.uint64:
            return { t: ValueEnumType.uint64, v: bytes.readUnit32() };
          case ValueEnumType.double:
            return { t: ValueEnumType.double, v: bytes.readFloat64() };
          case ValueEnumType.string:
            return { t: ValueEnumType.string, v: bytes.readUTF() };
          case ValueEnumType.singleArray:
            return { t: ValueEnumType.singleArray, v: bytes.readFloatArray() };
          case ValueEnumType.stringArray:
            return { t: ValueEnumType.stringArray, v: bytes.readStringArray() };
          case ValueEnumType.floatArray:
            return { t: ValueEnumType.floatArray, v: bytes.readFloatArray() };
          case ValueEnumType.vector2:
            return { t: ValueEnumType.vector2, v: bytes.readVector2() };
          case ValueEnumType.vector3:
            return { t: ValueEnumType.vector3, v: bytes.readVector3() };
          case ValueEnumType.vector4:
            return { t: ValueEnumType.vector4, v: bytes.readVector4() };
          case ValueEnumType.color:
            return { t: ValueEnumType.color, v: bytes.readColor() };
          case ValueEnumType.color32:
            return { t: ValueEnumType.color32, v: bytes.readColor() };
          case ValueEnumType.animationCurve:
            return { t: ValueEnumType.animationCurve, v: null };
          case ValueEnumType.quaternion:
            return { t: ValueEnumType.quaternion, v: bytes.readQuaternion() };
          case ValueEnumType.matrix4x4:
            return { t: ValueEnumType.matrix4x4, v: null };
          case ValueEnumType.mesh: {
            let id = bytes.readUTF();
            let mesh = Engine3D.res.getGeometry(id);
            return { t: ValueEnumType.mesh, v: mesh };
          }
          case ValueEnumType.texture: {
            let id = bytes.readUTF();
            let texture = Engine3D.res.getTexture(id);
            return { t: ValueEnumType.texture, v: texture };
          }
          case ValueEnumType.material: {
            let id = bytes.readUTF();
            let mat = Engine3D.res.getMat(id);
            return { t: ValueEnumType.material, v: mat };
          }
          case ValueEnumType.materials: {
            let str = bytes.readStringArray();
            let mats = [];
            for (let i = 0; i < str.length; i++) {
              const element = str[i];
              let mat = Engine3D.res.getMat(element);
              mats.push(mat);
            }
            return { t: ValueEnumType.materials, v: mats };
          }
          case ValueEnumType.skeleton:
            break;
          case ValueEnumType.animClip: {
            let animClipDatas = [];
            let animClipCount = bytes.readInt32();
            for (let i = 0; i < animClipCount; i++) {
              let animationClipData = new PropertyAnimationClip();
              animationClipData.formBytes(bytes);
              animClipDatas.push(animationClipData);
            }
            return { t: ValueEnumType.animClip, v: animClipDatas };
          }
          case ValueEnumType.vector2Int:
            return { t: ValueEnumType.vector2Int, v: bytes.readVector2int() };
          case ValueEnumType.int32List:
            return { t: ValueEnumType.int32List, v: bytes.readInt32List() };
          case ValueEnumType.colorList:
            let len = bytes.readInt32();
            let list = [];
            for (let i = 0; i < len; i++) {
              const element = ValueParser.parser(bytes).v;
              list.push(element);
            }
            return { t: ValueEnumType.colorList, v: list };
          case ValueEnumType.color32List:
            let len2 = bytes.readInt32();
            let list2 = [];
            for (let i = 0; i < len2; i++) {
              const element = ValueParser.parser(bytes).v;
              list2.push(element);
            }
            return { t: ValueEnumType.color32List, v: list2 };
        }
      }
    }

    class KV {
      key;
      type;
      _data;
      getValue() {
        return this._data;
      }
      formBytes(matBytes) {
        this.key = matBytes.readUTF();
        let { t, v } = ValueParser.parser(matBytes);
        this.type = t;
        this._data = v;
      }
    }

    class PrefabTextureData {
      property;
      name;
      texture;
      texelSize;
      wrapModeU;
      wrapModeV;
      wrapModeW;
      wrapMode;
      anisoLevel;
      dimension;
      filterMode;
    }

    class PrefabMaterialParser extends ParserBase {
      static format = ParserFormat.TEXT;
      static parserMaterial(bytesStream, prefabParser) {
        let matCount = bytesStream.readInt32();
        for (let i = 0; i < matCount; i++) {
          let matBytes = bytesStream.readBytesArray();
          let matName = matBytes.readUTF();
          let id = matBytes.readUTF();
          matBytes.readUTF();
          let defines = matBytes.readStringArray();
          matBytes.readVector4();
          matBytes.readVector4();
          let shaderName = matBytes.readUTF();
          let properties = [];
          let textures = [];
          let propertyCount = matBytes.readInt32();
          for (let j = 0; j < propertyCount; j++) {
            let kv = new KV();
            kv.formBytes(matBytes);
            properties.push(kv);
          }
          let textureCount = matBytes.readInt32();
          for (let j = 0; j < textureCount; j++) {
            let texBytes = matBytes.readBytesArray();
            let textureData = new PrefabTextureData();
            textureData.property = texBytes.readUTF();
            textureData.name = texBytes.readUTF();
            textureData.texture = Engine3D.res.getTexture(textureData.name);
            textureData.texelSize = texBytes.readVector2();
            textureData.wrapModeU = texBytes.readUnit32();
            textureData.wrapModeV = texBytes.readUnit32();
            textureData.wrapModeW = texBytes.readUnit32();
            textureData.wrapMode = texBytes.readUnit32();
            textureData.anisoLevel = texBytes.readUnit32();
            textureData.dimension = texBytes.readUnit32();
            textureData.filterMode = texBytes.readUnit32();
            textures.push(textureData);
          }
          let mat = MaterialUtilities.GetMaterial(shaderName);
          mat.name = matName;
          for (let i2 = 0; i2 < defines.length; i2++) {
            const define = defines[i2];
            mat.shader.setDefine(define, true);
          }
          MaterialUtilities.applyMaterialTexture(mat, textures);
          MaterialUtilities.applyMaterialProperties(mat, properties);
          Engine3D.res.addMat(id, mat);
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
    }

    class BlendShapePropertyData {
      shapeName;
      shapeIndex;
      frameCount;
      // public blendShapeFrameDatas: BlendShapeFrameData[];
      blendPositionList = new Float32Array();
      blendNormalList = new Float32Array();
      formBytes(byteArray) {
        let bytes = byteArray.readBytesArray();
        this.shapeName = bytes.readUTF();
        this.shapeIndex = bytes.readInt32();
        this.frameCount = bytes.readInt32();
        let len = bytes.readInt32();
        this.blendPositionList = bytes.readFloat32Array(len * 3);
        let len2 = bytes.readInt32();
        this.blendNormalList = bytes.readFloat32Array(len2 * 3);
      }
    }

    class BlendShapeData {
      vertexCount;
      shapeNames;
      shapeIndexs;
      blendCount;
      // public positionList: Float32Array;
      // public normalList: Float32Array;
      blendShapePropertyDatas;
      blendShapeMap;
      formBytes(byteArray) {
        this.blendShapeMap = /* @__PURE__ */ new Map();
        this.blendShapePropertyDatas = [];
        let bytes = byteArray.readBytesArray();
        this.vertexCount = bytes.readInt32();
        this.shapeNames = bytes.readStringArray();
        this.shapeIndexs = bytes.readIntArray();
        this.blendCount = bytes.readInt32();
        for (let i = 0; i < this.blendCount; i++) {
          let propertyData = new BlendShapePropertyData();
          propertyData.formBytes(bytes);
          this.blendShapePropertyDatas.push(propertyData);
          this.blendShapeMap.set(propertyData.shapeName, propertyData);
        }
        return byteArray;
      }
    }

    class PrefabMeshData {
      name;
      meshName;
      meshID;
      vertexCount;
      vertexStrip;
      vertexBuffer;
      indices;
      attributes;
      bones;
      bindPose;
      blendShapeData;
    }

    class PrefabMeshParser extends ParserBase {
      static format = ParserFormat.BIN;
      async parseBuffer(buffer) {
      }
      static parserMeshs(bytesStream, prefabParser) {
        let meshCount = bytesStream.readInt32();
        for (let j = 0; j < meshCount; j++) {
          let prefabMesh = new PrefabMeshData();
          let meshBytesArray = bytesStream.readBytesArray();
          prefabMesh.meshName = meshBytesArray.readUTF();
          prefabMesh.meshID = meshBytesArray.readUTF();
          meshBytesArray.readFloat32() > 0;
          meshBytesArray.readFloat32() > 0;
          meshBytesArray.readFloat32() > 0;
          let useSkeleton = meshBytesArray.readFloat32() > 0;
          let useBlendShape = meshBytesArray.readFloat32() > 0;
          if (useSkeleton) {
            prefabMesh.bones = meshBytesArray.readStringArray();
            prefabMesh.bindPose = meshBytesArray.readMatrix44Array();
          }
          if (useBlendShape) {
            prefabMesh.blendShapeData = new BlendShapeData();
            prefabMesh.blendShapeData.formBytes(meshBytesArray);
          }
          let vertexBlock = meshBytesArray.readBytesArray();
          let vertexBuffer = meshBytesArray.readBytesArray();
          let attCount = vertexBlock.readInt32();
          let vertex_dim = 0;
          let attributes = [];
          for (let i = 0; i < attCount; i++) {
            attributes[i] = {};
            attributes[i].att = MeshVertexAttribute[vertexBlock.readUTF()];
            attributes[i].dim = vertexBlock.readInt32();
            vertex_dim += attributes[i].dim;
            attributes[i].format = vertexBlock.readUTF();
          }
          prefabMesh.vertexCount = vertexBlock.readInt32();
          prefabMesh.vertexBuffer = vertexBuffer.getFloat32Array();
          let tmpIndices = meshBytesArray.readInt32Array();
          let subMesh = [];
          let subMeshCount = meshBytesArray.readInt32();
          for (let jj = 0; jj < subMeshCount; jj++) {
            let subMesh_topology = meshBytesArray.readInt32();
            let subMesh_indexStart = meshBytesArray.readInt32();
            let subMesh_indexCount = meshBytesArray.readInt32();
            let subMesh_baseVertex = meshBytesArray.readInt32();
            let subMesh_firstVertex = meshBytesArray.readInt32();
            let subMesh_vertexCount = meshBytesArray.readInt32();
            meshBytesArray.readVector3();
            meshBytesArray.readVector3();
            let subDes = {
              indexStart: subMesh_indexStart,
              indexCount: subMesh_indexCount,
              vertexStart: subMesh_baseVertex,
              vertexCount: subMesh_vertexCount,
              firstStart: subMesh_firstVertex,
              topology: subMesh_topology,
              index: jj
            };
            subMesh.push(subDes);
          }
          if (tmpIndices.length > 65535) {
            prefabMesh.indices = new Uint32Array(tmpIndices);
          } else {
            prefabMesh.indices = new Uint16Array(tmpIndices);
          }
          let geometry = new GeometryBase();
          geometry.vertexDim = vertex_dim;
          geometry.geometryType = GeometryVertexType.compose_bin;
          geometry.setIndices(prefabMesh.indices);
          geometry.setAttribute(VertexAttributeName.all, prefabMesh.vertexBuffer);
          if (useSkeleton) {
            geometry.skinNames = prefabMesh.bones;
            geometry.bindPose = prefabMesh.bindPose;
          }
          if (useBlendShape) {
            geometry.blendShapeData = prefabMesh.blendShapeData;
            geometry.morphTargetsRelative = true;
            geometry.morphTargetDictionary = {};
            for (let i = 0; i < prefabMesh.blendShapeData.blendCount; i++) {
              geometry.setAttribute("a_morphPositions_" + i, prefabMesh.blendShapeData.blendShapePropertyDatas[i].blendPositionList);
              geometry.setAttribute("a_morphNormals_" + i, prefabMesh.blendShapeData.blendShapePropertyDatas[i].blendNormalList);
              for (let i2 = 0; i2 < prefabMesh.blendShapeData.blendCount; i2++) {
                let blendName = prefabMesh.blendShapeData.shapeNames[i2];
                let blendIndex = prefabMesh.blendShapeData.shapeIndexs[i2];
                geometry.morphTargetDictionary[blendName] = blendIndex;
              }
            }
          }
          for (let ii = 0; ii < attributes.length; ii++) {
            const element = attributes[ii].att;
            geometry.setAttribute(element, null);
          }
          for (let kk = 0; kk < subMesh.length; kk++) {
            const element = subMesh[kk];
            geometry.addSubGeometry(element);
          }
          geometry.name = prefabMesh.meshName;
          Engine3D.res.addGeometry(prefabMesh.meshID, geometry);
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
    }
    let MeshVertexAttribute = {
      "Position": VertexAttributeName.position,
      "Normal": VertexAttributeName.normal,
      "Color": VertexAttributeName.color,
      "Tangent": VertexAttributeName.TANGENT,
      "TexCoord0": VertexAttributeName.uv,
      "TexCoord1": VertexAttributeName.TEXCOORD_1,
      "TexCoord2": VertexAttributeName.TEXCOORD_2,
      "TexCoord3": VertexAttributeName.TEXCOORD_2,
      "TexCoord4": VertexAttributeName.TEXCOORD_4,
      "TexCoord5": VertexAttributeName.TEXCOORD_5,
      "TexCoord6": VertexAttributeName.TEXCOORD_6,
      "TexCoord7": VertexAttributeName.vIndex,
      "BlendIndices": VertexAttributeName.joints0,
      "BlendWeight": VertexAttributeName.weights0
    };

    class BytesArray extends DataView {
      position = 0;
      littleEndian = true;
      constructor(buffer, byteOffset, byteLength) {
        super(buffer, byteOffset, byteLength);
        this.position = 0;
        this.position += this.byteOffset;
      }
      //TODO Improve read/write byte
      readUTF() {
        let len = this.readInt32();
        let b = len % 4;
        if (b > 0 && b < 4) {
          b = 4 - b;
        }
        let ret = "";
        let strBuffer = new Int8Array(this.buffer, this.position, len);
        this.position += len * Int8Array.BYTES_PER_ELEMENT;
        ret += String.fromCharCode.apply(null, strBuffer);
        this.position += b * Int8Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readStringArray() {
        let ret = [];
        let len = this.readInt32();
        for (let i = 0; i < len; i++) {
          ret.push(this.readUTF());
        }
        return ret;
      }
      readByte() {
        let ret = this.buffer[this.position];
        this.position += 1;
        return ret;
      }
      readBoolean() {
        let ret = this.readInt32();
        this.position += 4;
        return ret == 1 ? true : false;
      }
      readBytes(byteLen) {
        let bufferView = new DataView(this.buffer, this.position, byteLen);
        this.position += byteLen;
        return bufferView.buffer;
      }
      readBytesArray() {
        let byteLen = this.readInt32();
        let bufferView = new BytesArray(this.buffer.slice(this.position, this.position + byteLen));
        this.position += byteLen;
        return bufferView;
      }
      readUnit8() {
        let ret = this.getUint8(this.position);
        this.position += Uint8Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readUnit16() {
        let ret = this.getUint16(this.position);
        this.position += Uint16Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readUnit32() {
        let ret = this.getUint32(this.position);
        this.position += Uint32Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readInt8() {
        let ret = this.getInt8(this.position);
        this.position += Int8Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readInt16() {
        let ret = this.getInt16(this.position, this.littleEndian);
        this.position += Int16Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readInt32() {
        let ret = this.getInt32(this.position, this.littleEndian);
        this.position += Int32Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readFloat32() {
        let ret = this.getFloat32(this.position, this.littleEndian);
        this.position += Float32Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readFloat64() {
        let ret = this.getFloat64(this.position, this.littleEndian);
        this.position += Float64Array.BYTES_PER_ELEMENT;
        return ret;
      }
      readInt32Array() {
        let len = this.readInt32();
        let ret = new Int32Array(this.buffer, this.position, len);
        ret = ret.slice(0, len);
        this.position += ret.byteLength;
        return ret;
      }
      readInt32List() {
        let len = this.readInt32();
        let ret = [];
        for (let i = 0; i < len; i++) {
          ret.push(this.readInt32());
        }
        return ret;
      }
      readFloatArray() {
        let len = this.readInt32();
        let ret = [];
        for (let i = 0; i < len; i++) {
          let v = this.readFloat32();
          ret.push(v);
        }
        return ret;
      }
      readIntArray() {
        let len = this.readInt32();
        let ret = [];
        for (let i = 0; i < len; i++) {
          let v = this.readInt32();
          ret.push(v);
        }
        return ret;
      }
      readVector2int() {
        let v = new Vector2();
        v.x = this.readInt32();
        v.y = this.readInt32();
        return v;
      }
      readVector2() {
        let v = new Vector2();
        v.x = this.readFloat32();
        v.y = this.readFloat32();
        return v;
      }
      readVector3() {
        let v = new Vector3();
        v.x = this.readFloat32();
        v.y = this.readFloat32();
        v.z = this.readFloat32();
        return v;
      }
      readVector3Array() {
        let list = [];
        let len = this.readInt32();
        for (let i = 0; i < len; i++) {
          list.push(this.readVector3());
        }
        return list;
      }
      readVector4() {
        let v = new Vector4();
        v.x = this.readFloat32();
        v.y = this.readFloat32();
        v.z = this.readFloat32();
        v.w = this.readFloat32();
        return v;
      }
      readVector4Array() {
        let list = [];
        let len = this.readInt32();
        for (let i = 0; i < len; i++) {
          list.push(this.readVector4());
        }
        return list;
      }
      readColor() {
        let v = new Color();
        v.r = this.readFloat32();
        v.g = this.readFloat32();
        v.b = this.readFloat32();
        v.a = this.readFloat32();
        return v;
      }
      readColorArray() {
        let list = [];
        let len = this.readInt32();
        for (let i = 0; i < len; i++) {
          list.push(this.readColor());
        }
        return list;
      }
      readQuaternion() {
        let v = new Quaternion();
        v.x = this.readFloat32();
        v.y = this.readFloat32();
        v.z = this.readFloat32();
        v.w = this.readFloat32();
        return v;
      }
      readQuaternionArray() {
        let list = [];
        let len = this.readInt32();
        for (let i = 0; i < len; i++) {
          list.push(this.readQuaternion());
        }
        return list;
      }
      readMatrix44() {
        let m = new Matrix4();
        let rawData = m.rawData;
        rawData[0] = this.readFloat32();
        rawData[1] = this.readFloat32();
        rawData[2] = this.readFloat32();
        rawData[3] = this.readFloat32();
        rawData[4] = this.readFloat32();
        rawData[5] = this.readFloat32();
        rawData[6] = this.readFloat32();
        rawData[7] = this.readFloat32();
        rawData[8] = this.readFloat32();
        rawData[9] = this.readFloat32();
        rawData[10] = this.readFloat32();
        rawData[11] = this.readFloat32();
        rawData[12] = this.readFloat32();
        rawData[13] = this.readFloat32();
        rawData[14] = this.readFloat32();
        rawData[15] = this.readFloat32();
        return m;
      }
      readMatrix44Array() {
        let len = this.readInt32();
        let list = [];
        for (let i = 0; i < len; i++) {
          let m = this.readMatrix44();
          list.push(m);
        }
        return list;
      }
      readFloat32Array(len) {
        let ret = new Float32Array(this.buffer, this.position, len);
        ret = ret.slice(0, this.byteLength);
        this.position += len * Float32Array.BYTES_PER_ELEMENT;
        return ret;
      }
      getFloat32Array() {
        let ret = new Float32Array(this.buffer, this.byteOffset, this.byteLength / Float32Array.BYTES_PER_ELEMENT);
        ret = ret.slice(0, this.byteLength);
        return ret;
      }
    }

    class PrefabTextureParser extends ParserBase {
      static format = ParserFormat.TEXT;
      static async parserTexture(bytesStream, prefabParser, loaderFunctions) {
        let preTextureCount = bytesStream.readInt32();
        let textures = [];
        for (let i = 0; i < preTextureCount; i++) {
          let texName = bytesStream.readUTF();
          if (PrefabParser.useWebp) {
            texName = texName.replace("png", "webp");
            texName = texName.replace("jpb", "webp");
            textures.push(prefabParser.baseUrl + `webp/` + texName);
          } else {
            textures.push(prefabParser.baseUrl + texName);
          }
        }
        let textureList = await Engine3D.res.loadBitmapTextures(textures, Engine3D.setting.loader.numConcurrent, loaderFunctions, true);
        for (const tex of textureList) {
          Engine3D.res.addTexture(tex.name, tex);
        }
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
    }

    var __defProp$4 = Object.defineProperty;
    var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
    var __decorateClass$4 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$4(target, key, result);
      return result;
    };
    exports.LitSSSShader = class LitSSSShader extends Shader {
      constructor() {
        super();
        ShaderLib.register("PBRLitSSSShader", PBRLitSSSShader);
        let colorShader = new RenderShaderPass("PBRLitSSSShader", "PBRLitSSSShader");
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefine("USE_CUSTOMUNIFORM", true);
        this.setDefault();
        this.debug();
        this.computes = [
          new PreIntegratedLutCompute(this)
        ];
      }
      debug() {
      }
      setDefault() {
        this.setUniformFloat(`shadowBias`, 35e-5);
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor`, new Color());
        this.setUniformColor(`emissiveColor`, new Color(1, 1, 1));
        this.setUniformVector4(`materialF0`, new Vector4(0.04, 0.04, 0.04, 1));
        this.setUniformColor(`specularColor`, new Color(0.04, 0.04, 0.04));
        this.setUniformFloat(`envIntensity`, 1);
        this.setUniformFloat(`normalScale`, 1);
        this.setUniformFloat(`roughness`, 1);
        this.setUniformFloat(`metallic`, 0);
        this.setUniformFloat(`ao`, 1);
        this.setUniformFloat(`roughness_min`, 0);
        this.setUniformFloat(`roughness_max`, 1);
        this.setUniformFloat(`metallic_min`, 0);
        this.setUniformFloat(`metallic_max`, 1);
        this.setUniformFloat(`emissiveIntensity`, 0);
        this.setUniformFloat(`alphaCutoff`, 0);
        this.setUniformFloat(`ior`, 1.5);
        this.setUniformFloat(`clearcoatFactor`, 0);
        this.setUniformFloat(`clearcoatRoughnessFactor`, 0);
        this.setUniformColor(`clearcoatColor`, new Color(1, 1, 1));
        this.setUniformFloat(`clearcoatWeight`, 0);
        this.setUniformColor(`skinColor`, new Color(1, 0, 0));
        this.setUniformFloat(`skinPower`, 3.4);
        this.setUniformFloat(`skinColorIns`, 0.5);
        this.setUniformFloat(`curveFactor`, 1);
      }
      set _MainTex(value) {
        this.setTexture("baseMap", value);
      }
      set _BumpMap(value) {
        this.setTexture("normalMap", value);
      }
      set _SSSMap(value) {
        this.setTexture("sssMap", value);
      }
      set _MaskTex(value) {
        this.setTexture("maskMap", value);
      }
      set _UVTransform(value) {
        this.setUniformVector4("transformUV1", value);
      }
      set _Metallic(value) {
        this.setUniformFloat("metallic", value);
      }
      set _Roughness(value) {
        this.setUniformFloat("roughness", value);
      }
      set _MainColor(value) {
        this.setUniformColor("baseColor", value);
      }
      set _AlphaCutoff(value) {
        this.setUniformFloat("alphaCutoff", value);
      }
      set _DoubleSidedEnable(value) {
        let shader = this.getDefaultColorShader();
        shader.shaderState.cullMode = value ? GPUCullMode.none : shader.shaderState.cullMode;
      }
      set _SkinColor(value) {
        this.setUniformColor("skinColor", value);
      }
      set _SkinPower(value) {
        this.setUniformFloat("skinPower", value);
      }
      set _SkinColorIns(value) {
        this.setUniformFloat("skinColorIns", value);
      }
      set curveFactor(value) {
        this.setUniformFloat("curveFactor", value);
      }
      set _SurfaceType(value) {
        let shader = this.getDefaultColorShader();
        if (value == 0) {
          shader.blendMode = BlendMode.NONE;
        } else {
          shader.blendMode = BlendMode.ALPHA;
        }
      }
      set _AlphaCutoffEnable(value) {
        if (value == 0) {
          this.setDefine("USE_ALPHACUT", false);
        } else {
          this.setDefine("USE_ALPHACUT", true);
        }
      }
    };
    exports.LitSSSShader = __decorateClass$4([
      RegisterShader
    ], exports.LitSSSShader);

    var __defProp$3 = Object.defineProperty;
    var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
    var __decorateClass$3 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$3(target, key, result);
      return result;
    };
    exports.LitShader = class LitShader extends Shader {
      constructor() {
        super();
        let colorShader = new RenderShaderPass("PBRLItShader", "PBRLItShader");
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefault();
      }
      setDefault() {
        this.setUniformFloat(`shadowBias`, 35e-5);
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor`, new Color());
        this.setUniformColor(`emissiveColor`, new Color(0, 0, 0));
        this.setUniformVector4(`materialF0`, new Vector4(0.04, 0.04, 0.04, 1));
        this.setUniformColor(`specularColor`, new Color(0.04, 0.04, 0.04));
        this.setUniformFloat(`envIntensity`, 1);
        this.setUniformFloat(`normalScale`, 1);
        this.setUniformFloat(`roughness`, 1);
        this.setUniformFloat(`metallic`, 0);
        this.setUniformFloat(`ao`, 1);
        this.setUniformFloat(`roughness_min`, 0);
        this.setUniformFloat(`roughness_max`, 1);
        this.setUniformFloat(`metallic_min`, 0);
        this.setUniformFloat(`metallic_max`, 1);
        this.setUniformFloat(`emissiveIntensity`, 0);
        this.setUniformFloat(`alphaCutoff`, 0);
        this.setUniformFloat(`ior`, 1.5);
        this.setUniformFloat(`clearcoatFactor`, 0);
        this.setUniformFloat(`clearcoatRoughnessFactor`, 0);
        this.setUniformColor(`clearcoatColor`, new Color(1, 1, 1));
        this.setUniformFloat(`clearcoatWeight`, 0);
        this._MainTex = Engine3D.res.grayTexture;
        this._BumpMap = Engine3D.res.normalTexture;
        this._MaskTex = Engine3D.res.maskTexture;
      }
      set _MainTex(value) {
        this.setTexture("baseMap", value);
      }
      set _BumpMap(value) {
        this.setTexture("normalMap", value);
      }
      set _MaskTex(value) {
        this.setTexture("maskMap", value);
      }
      set _UVTransform(value) {
        this.setUniformVector4("transformUV1", value);
      }
      set _Metallic(value) {
        this.setUniformFloat("metallic", value);
      }
      set _Roughness(value) {
        this.setUniformFloat("roughness", value);
      }
      set _MainColor(value) {
        this.setUniformColor("baseColor", value);
      }
      set _AlphaCutoff(value) {
        this.setUniformFloat("alphaCutoff", value);
      }
      set _DoubleSidedEnable(value) {
        let subShader = this.getDefaultColorShader();
        subShader.shaderState.cullMode = value ? GPUCullMode.none : subShader.shaderState.cullMode;
      }
      set _SurfaceType(value) {
        let subShader = this.getDefaultColorShader();
        if (value == 0) {
          subShader.blendMode = BlendMode.NONE;
        } else {
          subShader.blendMode = BlendMode.ALPHA;
        }
      }
      set _AlphaCutoffEnable(value) {
        if (value == 0) {
          this.setDefine("USE_ALPHACUT", false);
        } else {
          this.setDefine("USE_ALPHACUT", true);
        }
      }
    };
    exports.LitShader = __decorateClass$3([
      RegisterShader
    ], exports.LitShader);

    class ComData {
      comName;
      data;
      static parser(bytesArray) {
        let comBuffer = bytesArray.readBytesArray();
        let comData = new ComData();
        comData.comName = comBuffer.readUTF();
        comData.data = [];
        let count = comBuffer.readInt32();
        for (let i = 0; i < count; i++) {
          let kv = new KV();
          kv.formBytes(comBuffer);
          comData.data.push(kv);
        }
        return comData;
      }
    }
    class PrefabNode {
      name;
      parentName;
      position;
      rotation;
      scale;
      comDatas;
      child;
      static parser(bytesArray) {
        let nodeBytes = bytesArray.readBytesArray();
        let prefabNode = new PrefabNode();
        prefabNode.name = nodeBytes.readUTF();
        prefabNode.parentName = nodeBytes.readUTF();
        prefabNode.position = nodeBytes.readVector3();
        prefabNode.rotation = nodeBytes.readQuaternion();
        prefabNode.scale = nodeBytes.readVector3();
        prefabNode.comDatas = [];
        prefabNode.child = [];
        let comCount = nodeBytes.readInt32();
        for (let i = 0; i < comCount; i++) {
          const comData = ComData.parser(nodeBytes);
          prefabNode.comDatas.push(comData);
        }
        let childCount = nodeBytes.readInt32();
        for (let i = 0; i < childCount; i++) {
          const childNodeData = PrefabNode.parser(nodeBytes);
          prefabNode.child.push(childNodeData);
        }
        return prefabNode;
      }
    }

    class PrefabParser extends ParserBase {
      static useWebp = true;
      static format = ParserFormat.BIN;
      avatarDic;
      nodeData;
      async parseBuffer(buffer) {
        this.avatarDic = {};
        let bytesStream = new BytesArray(buffer, 0);
        await PrefabTextureParser.parserTexture(bytesStream, this, this.loaderFunctions);
        PrefabAvatarParser.parser(bytesStream, this);
        PrefabMeshParser.parserMeshs(bytesStream, this);
        PrefabMaterialParser.parserMaterial(bytesStream, this);
        this.nodeData = this.parserPrefabNode(bytesStream);
        this.data = this.data = this.parserNodeTree(this.nodeData);
      }
      parserPrefabNode(bytesStream) {
        let rootNodeData = PrefabNode.parser(bytesStream);
        return rootNodeData;
      }
      parserNodeTree(nodeData) {
        let root = new exports.Object3D();
        root.localPosition = Vector3.serialize(nodeData.position);
        root.localQuaternion = Quaternion.serialize(nodeData.rotation);
        root.localScale = Vector3.serialize(nodeData.scale);
        root.name = nodeData.name;
        if (nodeData.comDatas) {
          for (let i = 0; i < nodeData.comDatas.length; i++) {
            const comData = nodeData.comDatas[i];
            let com = null;
            let comClass = GetComponentClass(comData.comName);
            if (comClass) {
              com = root.getOrAddComponent(comClass);
              for (let j = 0; j < comData.data.length; j++) {
                const kv = comData.data[j];
                if (kv.key in com) {
                  com[kv.key] = kv.getValue();
                }
              }
            }
          }
        }
        if (nodeData.child && nodeData.child.length > 0) {
          for (let j = 0; j < nodeData.child.length; j++) {
            let child = this.parserNodeTree(nodeData.child[j]);
            root.addChild(child);
          }
        }
        return root;
      }
      /**
       * Verify parsing validity
       * @param ret
       * @returns
       */
      verification() {
        if (this.data) {
          return true;
        }
        throw new Error("verify failed.");
      }
    }

    class PrefabStringUtil {
      static getNumber(st) {
        let v = parseFloat(st);
        return v;
      }
      static getInt(st) {
        let v = parseInt(st);
        return v;
      }
      static getBoolean(st) {
        let v = st == "true" ? true : false;
        return v;
      }
      static getNumberArray(st) {
        let v = st.replaceAll("[", "");
        v = v.replaceAll("]", "");
        let list = v.split(",");
        for (let i = 0; i < list.length; i++) {
          parseFloat(list[i]);
        }
        return v;
      }
      static getStringArray(st) {
        let v = st.replaceAll("[", "");
        v = v.replaceAll("]", "");
        let list = v.split(",");
        let ret = [];
        for (let i = 0; i < list.length; i++) {
          const element = list[i];
          ret.push(element);
        }
        return ret;
      }
      static getVector2(st) {
      }
      static getVector3(st) {
      }
      static getVector4(st) {
      }
      static getQuaternion(st) {
      }
      static getColor(st) {
      }
    }

    var __defProp$2 = Object.defineProperty;
    var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
    var __decorateClass$2 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$2(target, key, result);
      return result;
    };
    exports.LitHairShader = class LitHairShader extends Shader {
      constructor() {
        super();
        this.create_opPass();
        this.setDefine("USEC", true);
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefine("USE_HAIR", true);
        this.setDefine("USE_CUSTOMUNIFORM", true);
        this.setDefine("USE_HAIRCOLOR", true);
        this.setDefault();
        this.debug();
      }
      create_opPass() {
        ShaderLib.register("HairShader_op", Hair_shader_op);
        let colorShader = new RenderShaderPass("HairShader_op", "HairShader_op");
        this.addRenderPass(colorShader);
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        shaderState.blendMode = BlendMode.NONE;
        shaderState.cullMode = GPUCullMode.none;
        shaderState.writeMasks[0] = GPUColorWrite.ALL;
      }
      create_trPass() {
        ShaderLib.register("HairShader_tr", Hair_shader_tr);
        let colorShader = new RenderShaderPass("HairShader_tr", "HairShader_tr");
        this.addRenderPass(colorShader);
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        shaderState.depthWriteEnabled = false;
        shaderState.blendMode = BlendMode.NORMAL;
        shaderState.cullMode = GPUCullMode.none;
        shaderState.writeMasks[0] = GPUColorWrite.ALL;
        shaderState.writeMasks[1] = 0;
        shaderState.writeMasks[2] = 0;
        shaderState.writeMasks[3] = 0;
      }
      debug() {
      }
      setDefault() {
        this.setUniformFloat(`shadowBias`, 35e-5);
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor0`, new Color(3 / 255, 2 / 255, 2 / 255));
        this.setUniformColor(`baseColor1`, new Color(2 / 255, 2 / 255, 2 / 255));
        this.setUniformColor(`emissiveColor`, new Color(1, 1, 1));
        this.setUniformVector4(`materialF0`, new Vector4(0.04, 0.04, 0.04, 1));
        this.setUniformColor(`specularColor`, new Color(36 / 255, 36 / 255, 36 / 255));
        this.setUniformFloat(`envIntensity`, 1);
        this.setUniformFloat(`normalScale`, 1);
        this.setUniformFloat(`roughness`, 0.1);
        this.setUniformFloat(`metallic`, 0.3);
        this.setUniformFloat(`ao`, 1);
        this.setUniformFloat(`roughness_min`, 0);
        this.setUniformFloat(`roughness_max`, 1);
        this.setUniformFloat(`metallic_min`, 0);
        this.setUniformFloat(`metallic_max`, 1);
        this.setUniformFloat(`emissiveIntensity`, 0);
        this.setUniformFloat(`alphaCutoff`, 0.1);
        this.setUniformFloat(`ior`, 1.5);
        this.setUniformFloat(`backlit`, 0.3987);
        this.setUniformFloat(`area`, 0.0615);
      }
      set _MainTex(value) {
        this.setTexture("baseMap", value);
      }
      set _IDMap(value) {
        this.setTexture("idMap", value);
      }
      set _DepthMap(value) {
        this.setTexture("depthMap", value);
      }
      set _RootMap(value) {
        this.setTexture("rootMap", value);
      }
      set _AlphaMap(value) {
        this.setTexture("alphaMap", value);
      }
      set _UVTransform(value) {
        this.setUniformVector4("transformUV1", value);
      }
      set _Metallic(value) {
        this.setUniformFloat("metallic", value);
      }
      set _Roughness(value) {
        this.setUniformFloat("roughness", value);
      }
      set _HairColor0(value) {
        this.setUniformColor("baseColor0", value);
      }
      set _HairColor1(value) {
        this.setUniformColor("baseColor1", value);
      }
      set _SpecularColor(value) {
        this.setUniformColor("specularColor", value);
      }
      set _AlphaCutoff(value) {
        this.setUniformFloat("alphaCutoff", value);
      }
      set _BackLit(value) {
        this.setUniformFloat("backlit", value);
      }
      set _Area(value) {
        this.setUniformFloat("area", value);
      }
      set _DoubleSidedEnable(value) {
        let subShader = this.getSubShaders(PassType.COLOR)[0];
        subShader.shaderState.cullMode = value ? GPUCullMode.none : subShader.shaderState.cullMode;
      }
      set _SurfaceType(value) {
      }
      set _AlphaCutoffEnable(value) {
        if (value == 0) {
          this.setDefine("USE_ALPHACUT", false);
        } else {
          this.setDefine("USE_ALPHACUT", true);
        }
      }
    };
    exports.LitHairShader = __decorateClass$2([
      RegisterShader
    ], exports.LitHairShader);

    var __defProp$1 = Object.defineProperty;
    var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
    var __decorateClass$1 = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp$1(target, key, result);
      return result;
    };
    exports.UnLitShader = class UnLitShader extends Shader {
      constructor() {
        super();
        let colorShader = new RenderShaderPass("UnLit", "UnLit");
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        this.addRenderPass(colorShader);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = false;
        shaderState.castShadow = false;
        shaderState.receiveEnv = false;
        shaderState.acceptGI = false;
        shaderState.useLight = false;
        this.setDefine("USE_BRDF", true);
        this.setDefine("USE_AO_R", true);
        this.setDefine("USE_ROUGHNESS_G", true);
        this.setDefine("USE_METALLIC_B", true);
        this.setDefine("USE_ALPHA_A", true);
        this.setDefault();
      }
      setDefault() {
        this.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        this.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        this.setUniformColor(`baseColor`, new Color());
        this.setUniformFloat(`alphaCutoff`, 0);
      }
      set _MainTex(value) {
        this.setTexture("baseMap", value);
      }
      set _BumpMap(value) {
        this.setTexture("normalMap", value);
      }
      set _MaskTex(value) {
        this.setTexture("maskMap", value);
      }
      set _UVTransform(value) {
        this.setUniformVector4("transformUV1", value);
      }
      set _Metallic(value) {
        this.setUniformFloat("metallic", value);
      }
      set _Roughness(value) {
        this.setUniformFloat("roughness", value);
      }
      set _MainColor(value) {
        this.setUniformColor("baseColor", value);
      }
      set _AlphaCutoff(value) {
        this.setUniformFloat("alphaCutoff", value);
      }
      set _DoubleSidedEnable(value) {
        let defaultShader = this.getDefaultColorShader();
        defaultShader.shaderState.cullMode = value ? GPUCullMode.none : defaultShader.shaderState.cullMode;
      }
      set _SurfaceType(value) {
        let defaultShader = this.getDefaultColorShader();
        if (value == 0) {
          defaultShader.blendMode = BlendMode.NONE;
        } else {
          defaultShader.blendMode = BlendMode.ALPHA;
        }
      }
      set _AlphaCutoffEnable(value) {
        if (value == 0) {
          this.setDefine("USE_ALPHACUT", false);
        } else {
          this.setDefine("USE_ALPHACUT", true);
        }
      }
    };
    exports.UnLitShader = __decorateClass$1([
      RegisterShader
    ], exports.UnLitShader);

    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __decorateClass = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp(target, key, result);
      return result;
    };
    exports.APatch = class APatch extends ComponentBase {
      size;
      blockSize;
      walk;
      obs;
      colors;
      aPaths;
      onGraphic(view) {
        return;
      }
    };
    exports.APatch = __decorateClass([
      RegisterComponent(exports.APatch, "APatch")
    ], exports.APatch);

    class BlendShapeFrameData {
      weight;
      // public deltaVertices: Vector3[];
      // public deltaNormals: Vector3[];
      // public deltaTangents: Vector3[];
      deltaVertices;
      deltaNormals;
      deltaTangents;
      formBytes(byteArray) {
        let bytes = byteArray.readBytesArray();
        this.weight = bytes.readFloat32();
        let len = 0;
        len = bytes.readInt32();
        this.deltaVertices = bytes.readFloat32Array(len * 3);
        len = bytes.readInt32();
        this.deltaNormals = bytes.readFloat32Array(len * 3);
        len = bytes.readInt32();
        this.deltaTangents = bytes.readFloat32Array(len * 3);
      }
    }

    class TileSet {
      asset;
      extras;
      geometricError;
      properties;
      refine;
      root;
    }
    class TileSetRoot {
      boundingVolume;
      children;
      geometricError;
      transform;
    }
    class TileSetChild {
      boundingVolume;
      geometricError;
      refine;
      content;
      contents;
    }
    class TileSetChildContent {
      uri;
      group;
      metadata;
    }
    class TileSetChildContentMetaData {
      class;
      properties;
    }

    class TilesRenderer {
      group;
      _modelList;
      _tileSet;
      _rootPath;
      constructor() {
        this.group = new exports.Object3D();
      }
      async loadTileSet(rootPath, file) {
        this._modelList = [];
        this._rootPath = rootPath;
        let combinePath = rootPath + "/" + file;
        this._tileSet = await Engine3D.res.loadJSON(combinePath);
        if (this._tileSet.root.transform) {
          let rootMatrix = new Matrix4();
          for (let i = 0; i < 16; i++) {
            rootMatrix.rawData[i] = this._tileSet.root.transform[i];
          }
        }
        let adjustmentTransform = new Matrix4();
        const upAxis = this._tileSet.asset && this._tileSet.asset.gltfUpAxis || "y";
        switch (upAxis.toLowerCase()) {
          case "x":
            adjustmentTransform.makeRotationAxis(Vector3.Y_AXIS, -Math.PI / 2);
            break;
          case "y":
            adjustmentTransform.makeRotationAxis(Vector3.X_AXIS, Math.PI / 2);
            break;
          case "z":
            adjustmentTransform.identity();
            break;
        }
        let invertMatrix = adjustmentTransform.clone();
        invertMatrix.invert();
        this.applyTransform(this.group.transform, invertMatrix);
        for (let item of this._tileSet.root.children) {
          let uriList = [];
          if (item.content && item.content.uri) {
            uriList.push(item.content.uri);
          }
          if (item.contents) {
            for (let c of item.contents) {
              uriList.push(c.uri);
            }
          }
          for (let uriPath of uriList) {
            let url = this._rootPath + "/" + uriPath;
            let functions = {
              onProgress: (e) => this.onLoadProgress(e),
              onComplete: (e) => this.onComplete(e)
            };
            let tileObject3D;
            if (url.endsWith(".glb")) {
              tileObject3D = await Engine3D.res.loadGltf(url, functions);
              this.applyTransform(tileObject3D.transform, adjustmentTransform);
            } else if (url.endsWith("tileset.json")) {
              let childTilesetUrl = url.replace("/tileset.json", "");
              let tilesRenderer = new TilesRenderer();
              await tilesRenderer.loadTileSet(childTilesetUrl, "tileset.json");
              tileObject3D = tilesRenderer.group;
            } else if (url.endsWith(".i3dm")) {
              tileObject3D = await Engine3D.res.loadI3DM(url, functions, adjustmentTransform);
            } else if (url.endsWith(".b3dm")) {
              tileObject3D = await Engine3D.res.loadB3DM(url, functions, adjustmentTransform);
            }
            if (tileObject3D) {
              this._modelList.push(tileObject3D);
              this.group.addChild(tileObject3D);
            }
          }
        }
      }
      onLoadProgress(e) {
      }
      onComplete(e) {
      }
      applyTransform(transform, matrix) {
        let prs = matrix.decompose(Orientation3D.QUATERNION);
        transform.localRotQuat.copyFrom(prs[1]);
        transform.localRotQuat = transform.localRotQuat;
        transform.localPosition.copyFrom(prs[0]);
        transform.localPosition = transform.localPosition;
        transform.localScale.copyFrom(prs[2]);
        transform.localScale = transform.localScale;
      }
    }

    class ColorLitMaterial extends Material {
      static count = 0;
      /**
       * @constructor
       */
      constructor() {
        super();
        ShaderLib.register("ColorLitShader", ColorLitShader);
        this.shader = new Shader();
        let renderShader = new RenderShaderPass(`ColorLitShader`, `ColorLitShader`);
        renderShader.passType = PassType.COLOR;
        this.shader.addRenderPass(renderShader);
        renderShader.setDefine("USE_BRDF", true);
        renderShader.setShaderEntry(`VertMain`, `FragMain`);
        renderShader.setUniformColor(`baseColor`, new Color());
        renderShader.setUniformColor(`emissiveColor`, new Color());
        renderShader.setUniformFloat(`envIntensity`, 1);
        renderShader.setUniformFloat(`normalScale`, 1);
        renderShader.setUniformFloat(`roughness`, 0);
        renderShader.setUniformFloat(`metallic`, 0);
        renderShader.setUniformFloat(`ao`, 1);
        renderShader.setUniformFloat(`alphaCutoff`, 0);
        let shaderState = renderShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        renderShader.setTexture("normalMap", Engine3D.res.normalTexture);
        renderShader.setTexture("emissiveMap", Engine3D.res.blackTexture);
      }
      clone() {
        return null;
      }
      debug() {
      }
    }

    class GlassMaterial extends Material {
      /**
       * @constructor
       */
      constructor() {
        super();
        ShaderLib.register("GlassShader", GlassShader);
        this.shader = new Shader();
        let colorShader = new RenderShaderPass("GlassShader", "GlassShader");
        colorShader.passType = PassType.COLOR;
        colorShader.setDefine("USE_BRDF", true);
        colorShader.setShaderEntry(`VertMain`, `FragMain`);
        let shaderState = colorShader.shaderState;
        shaderState.acceptShadow = true;
        shaderState.castShadow = true;
        shaderState.receiveEnv = true;
        shaderState.acceptGI = true;
        shaderState.useLight = true;
        this.shader.setTexture("baseMap", Engine3D.res.whiteTexture);
        this.shader.setTexture("normalMap", Engine3D.res.normalTexture);
        this.shader.setTexture("emissiveMap", Engine3D.res.blackTexture);
      }
      // clone(): this {
      //     console.log(`clone material ${this.name}`);
      //     let ret = new GlassMaterial();
      //     ret.baseMap = this.baseMap;
      //     ret.normalMap = this.normalMap;
      //     ret.aoMap = this.aoMap;
      //     if (this.maskMap) ret.maskMap = this.maskMap;
      //     ret.emissiveMap = this.emissiveMap;
      //     this.uvTransform_1 && (ret.uvTransform_1 = new Vector4().copyFrom(this.uvTransform_1));
      //     this.uvTransform_2 && (ret.uvTransform_2 = new Vector4().copyFrom(this.uvTransform_2));
      //     ret.baseColor = this.baseColor.clone();
      //     ret.emissiveColor = this.emissiveColor.clone();
      //     this.materialF0 && (ret.materialF0 = new Vector4().copyFrom(this.materialF0));
      //     ret.envIntensity = this.envIntensity;
      //     ret.normalScale = this.normalScale;
      //     ret.roughness = this.roughness;
      //     ret.metallic = this.metallic;
      //     ret.ao = this.ao;
      //     ret.roughness_min = this.roughness_min;
      //     ret.roughness_max = this.roughness_max;
      //     ret.metallic_min = this.metallic_min;
      //     ret.metallic_max = this.metallic_max;
      //     ret.emissiveIntensity = this.emissiveIntensity;
      //     ret.alphaCutoff = this.alphaCutoff;
      //     ret.ior = this.ior;
      //     ret.clearcoatFactor = this.clearcoatFactor;
      //     ret.clearcoatRoughnessFactor = this.clearcoatRoughnessFactor;
      //     return ret as this;
      // }
    }

    class LambertMaterial extends Material {
      /**
       * @constructor
       */
      constructor() {
        super();
        let colorPass = new RenderShaderPass(`LambertShader`, `LambertShader`);
        colorPass.setShaderEntry(`VertMain`, `FragMain`);
        colorPass.passType = PassType.COLOR;
        colorPass.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        colorPass.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        colorPass.setUniformColor(`baseColor`, new Color(1, 1, 1, 1));
        colorPass.setUniformFloat(`alphaCutoff`, 0.5);
        let shaderState = colorPass.shaderState;
        shaderState.acceptShadow = false;
        shaderState.castShadow = false;
        shaderState.receiveEnv = false;
        shaderState.acceptGI = false;
        shaderState.useLight = false;
        let newShader = new Shader();
        newShader.addRenderPass(colorPass);
        this.shader = newShader;
        this.baseMap = Engine3D.res.grayTexture;
      }
      /**
       * set base color map texture
       */
      set baseMap(tex) {
        this.shader.setTexture(`baseMap`, tex);
      }
      /**
       * get base color map texture
       */
      get baseMap() {
        return this.shader.getTexture(`baseMap`);
      }
      /**
       * set base color (tint color)
       */
      set baseColor(color) {
        this.shader.setUniformColor(`baseColor`, color);
      }
      /**
       * get base color (tint color)
       */
      get baseColor() {
        return this.shader.getUniformColor("baseColor");
      }
      /**
       * set environment texture, usually referring to cubemap
       */
      set envMap(texture) {
      }
      /**
       * @internal
       * set shadow map
       */
      set shadowMap(texture) {
      }
    }

    function registerMaterial(name, cls) {
    }

    class PhysicMaterial extends Material {
      constructor() {
        super();
        this.init();
      }
      init() {
        let bdrflutTex = Engine3D.res.getTexture(`BRDFLUT`);
        this.brdfLUT = bdrflutTex;
        this.setDefault();
        this.baseMap = Engine3D.res.whiteTexture;
        this.normalMap = Engine3D.res.normalTexture;
        this.emissiveMap = Engine3D.res.blackTexture;
        this.alphaCutoff = 0.5;
      }
      // public get shader(): RenderShader {
      //     return this._shader;
      // }
      /**
       * Set the render shader default value
       */
      setDefault() {
        let colorPass = this.shader.getDefaultColorShader();
        colorPass.setUniformFloat(`shadowBias`, 35e-5);
        colorPass.setUniformVector4(`transformUV1`, new Vector4(0, 0, 1, 1));
        colorPass.setUniformVector4(`transformUV2`, new Vector4(0, 0, 1, 1));
        colorPass.setUniformColor(`baseColor`, new Color());
        colorPass.setUniformColor(`emissiveColor`, new Color(1, 1, 1));
        colorPass.setUniformVector4(`materialF0`, new Vector4(0.04, 0.04, 0.04, 1));
        colorPass.setUniformColor(`specularColor`, new Color(0.04, 0.04, 0.04));
        colorPass.setUniformFloat(`envIntensity`, 1);
        colorPass.setUniformFloat(`normalScale`, 1);
        colorPass.setUniformFloat(`roughness`, 1);
        colorPass.setUniformFloat(`metallic`, 0);
        colorPass.setUniformFloat(`ao`, 1);
        colorPass.setUniformFloat(`roughness_min`, 0);
        colorPass.setUniformFloat(`roughness_max`, 1);
        colorPass.setUniformFloat(`metallic_min`, 0);
        colorPass.setUniformFloat(`metallic_max`, 1);
        colorPass.setUniformFloat(`emissiveIntensity`, 0);
        colorPass.setUniformFloat(`alphaCutoff`, 0);
        colorPass.setUniformFloat(`ior`, 1.5);
        colorPass.setUniformFloat(`clearcoatFactor`, 0);
        colorPass.setUniformFloat(`clearcoatRoughnessFactor`, 0);
        colorPass.setUniformColor(`clearcoatColor`, new Color(1, 1, 1));
        colorPass.setUniformFloat(`clearcoatWeight`, 0);
      }
      get baseMap() {
        return this.shader.getDefaultColorShader().getTexture(`baseMap`);
      }
      set baseMap(value) {
        this.shader.getDefaultColorShader().setTexture(`baseMap`, value);
      }
      get baseColor() {
        return this.shader.getDefaultColorShader().getUniform(`baseColor`);
      }
      set baseColor(value) {
        this.shader.getDefaultColorShader().setUniformColor(`baseColor`, value);
      }
      get normalMap() {
        return this.shader.getDefaultColorShader().getTexture(`normalMap`);
      }
      set normalMap(value) {
        this.shader.getDefaultColorShader().setTexture(`normalMap`, value);
      }
      get doubleSide() {
        return this.shader.getDefaultColorShader().doubleSide;
      }
      set doubleSide(value) {
        this.shader.getDefaultColorShader().doubleSide = value;
      }
      get alphaCutoff() {
        return this.shader.getDefaultColorShader().shaderState.alphaCutoff;
      }
      set alphaCutoff(value) {
        this.shader.getDefaultColorShader().setDefine("USE_ALPHACUT", true);
        this.shader.getDefaultColorShader().shaderState.alphaCutoff = value;
        this.shader.getDefaultColorShader().setUniform(`alphaCutoff`, value);
      }
      get emissiveColor() {
        return this.shader.getDefaultColorShader().getUniform(`emissiveColor`);
      }
      set emissiveColor(value) {
        this.shader.getDefaultColorShader().setUniform(`emissiveColor`, value);
      }
      get emissiveIntensity() {
        return this.shader.getDefaultColorShader().getUniform(`emissiveIntensity`);
      }
      set emissiveIntensity(value) {
        this.shader.getDefaultColorShader().setUniform(`emissiveIntensity`, value);
      }
      /**
       * get transformUV1
       */
      get uvTransform_1() {
        return this.shader.getDefaultColorShader().uniforms[`transformUV1`].vector4;
      }
      /**
       * set transformUV1
       */
      set uvTransform_1(value) {
        this.shader.getDefaultColorShader().setUniform(`transformUV1`, value);
      }
      /**
       * get transformUV2
       */
      get uvTransform_2() {
        return this.shader.getDefaultColorShader().uniforms[`transformUV2`].vector4;
      }
      /**
       * set transformUV2
       */
      set uvTransform_2(value) {
        this.shader.getDefaultColorShader().setUniform(`transformUV2`, value);
      }
      get depthWriteEnabled() {
        return this.shader.getDefaultColorShader().shaderState.depthWriteEnabled;
      }
      set depthWriteEnabled(value) {
        this.shader.getDefaultColorShader().shaderState.depthWriteEnabled = value;
      }
      /**
       * get reflectivity
       */
      get materialF0() {
        return this.shader.getDefaultColorShader().uniforms[`materialF0`].vector4;
      }
      /**
       * set reflectivity
       */
      set materialF0(value) {
        this.shader.getDefaultColorShader().setUniform(`materialF0`, value);
      }
      /**
      * get specularColor
      */
      get specularColor() {
        return this.shader.getDefaultColorShader().uniforms[`specularColor`].color;
      }
      /**specularColor
       * set reflectivity
       */
      set specularColor(value) {
        this.shader.getDefaultColorShader().setUniform(`specularColor`, value);
      }
      /**
       * get roughness
       */
      get roughness() {
        return this.shader.getDefaultColorShader().uniforms[`roughness`].value;
      }
      /**
       * set roughness
       */
      set roughness(value) {
        this.shader.getDefaultColorShader().setUniform(`roughness`, value);
      }
      /**
       * get metallic
       */
      get metallic() {
        return this.shader.getDefaultColorShader().uniforms[`metallic`].value;
      }
      /**
       * set metallic
       */
      set metallic(value) {
        this.shader.getDefaultColorShader().setUniform(`metallic`, value);
      }
      /**
       * get Ambient Occlussion, dealing with the effect of ambient light on object occlusion
       */
      get ao() {
        return this.shader.getDefaultColorShader().uniforms[`ao`].value;
      }
      /**
       * set Ambient Occlussion, dealing with the effect of ambient light on object occlusion
       */
      set ao(value) {
        this.shader.getDefaultColorShader().setUniform(`ao`, value);
      }
      /**
       * get min metallic
       */
      get metallic_min() {
        return this.shader.getDefaultColorShader().uniforms[`metallic_min`].value;
      }
      /**
       * set min metallic
       */
      set metallic_min(value) {
        this.shader.getDefaultColorShader().setUniform(`metallic_min`, value);
      }
      /**
       * get max metallic
       */
      get metallic_max() {
        return this.shader.getDefaultColorShader().uniforms[`metallic_max`].value;
      }
      /**
       * set max metallic
       */
      set metallic_max(value) {
        this.shader.getDefaultColorShader().setUniform(`metallic_max`, value);
      }
      /**
       * get min roughness
       */
      get roughness_min() {
        return this.shader.getDefaultColorShader().uniforms[`roughness_min`].value;
      }
      /**
       * set min roughness
       */
      set roughness_min(value) {
        this.shader.getDefaultColorShader().setUniform(`roughness_min`, value);
      }
      /**
       * get max roughness
       */
      get roughness_max() {
        return this.shader.getDefaultColorShader().uniforms[`roughness_max`].value;
      }
      /**
       * set max roughness
       */
      set roughness_max(value) {
        this.shader.getDefaultColorShader().setUniform(`roughness_max`, value);
      }
      /**
       * Get the influence of Normal mapping on materials
       */
      get normalScale() {
        return this.shader.getDefaultColorShader().uniforms[`normalScale`].value;
      }
      /**
       * Set the influence of Normal mapping on materials
       */
      set normalScale(value) {
        this.shader.getDefaultColorShader().setUniform(`normalScale`, value);
      }
      /**
       * get Mask Map
       * R_chanel -> AoMap 
       * G_chanel -> Roughness
       * B_chanel -> Metallic
       * A_chanel -> C
       */
      get maskMap() {
        return this.shader.getDefaultColorShader().textures[`maskMap`];
      }
      /**
       * set Mask Map
       * R_chanel -> AoMap 
       * G_chanel -> Roughness
       * B_chanel -> Metallic
       * A_chanel -> C
       */
      set maskMap(value) {
        this.shader.getDefaultColorShader().setDefine(`USE_MR`, true);
        this.shader.getDefaultColorShader().setTexture(`maskMap`, value);
      }
      /**
       * set Ambient Occlussion Map, dealing with the effect of ambient light on object occlusion
       */
      set aoMap(value) {
        if (!value)
          return;
        this.shader.getDefaultColorShader().setTexture(`aoMap`, value);
        if (value != Engine3D.res.whiteTexture) {
          this.shader.getDefaultColorShader().setDefine(`USE_AOTEX`, true);
        }
      }
      /**
       * get Ambient Occlussion Map, dealing with the effect of ambient light on object occlusion
       */
      get aoMap() {
        return this.shader.getDefaultColorShader().textures[`aoMap`];
      }
      /**
       * set clearCoatRoughnessMap
       */
      set clearCoatRoughnessMap(value) {
        if (!value)
          return;
        console.log("USE_CLEARCOAT_ROUGHNESS");
        this.shader.getDefaultColorShader().setTexture(`clearCoatRoughnessMap`, value);
        this.shader.getDefaultColorShader().setDefine(`USE_CLEARCOAT_ROUGHNESS`, true);
      }
      /**
       * get clearCoatRoughnessMap
       */
      get clearCoatRoughnessMap() {
        return this.shader.getDefaultColorShader().textures[`clearCoatRoughnessMap`];
      }
      /**
       * get brdf query map
       */
      get brdfLUT() {
        return this.shader.getDefaultColorShader().textures[`brdfLUT`];
      }
      /**
       * set brdf query map
       */
      set brdfLUT(value) {
        this.shader.getDefaultColorShader().setTexture(`brdfLUT`, value);
        this.shader.getDefaultColorShader().setTexture(`brdflutMap`, value);
      }
      /**
       * get emissive map
       */
      get emissiveMap() {
        return this.shader.getDefaultColorShader().textures[`emissiveMap`];
      }
      /**
       * set emissive map
       */
      set emissiveMap(value) {
        this.shader.getDefaultColorShader().setTexture(`emissiveMap`, value);
      }
      /**
       * set intensity of environment light or color of sampled by texture
       */
      set envIntensity(value) {
        this.shader.getDefaultColorShader().setUniformFloat(`envIntensity`, value);
      }
      /**
       * get intensity of environment light or color of sampled by texture
       */
      get envIntensity() {
        return this.shader.getDefaultColorShader().uniforms[`envIntensity`].value;
      }
      /**
       * set factor of refractive
       */
      set ior(value) {
        this.shader.getDefaultColorShader().setUniformFloat(`ior`, value);
      }
      /**
       * get factor of refractive
       */
      get ior() {
        return this.shader.getDefaultColorShader().uniforms[`ior`].value;
      }
      /**
       * valid USE_CLEARCOAT define in shader
       */
      useCleanCoat() {
        this.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT", true);
      }
      /**
       * Set the factor of the clearcoat
       */
      set clearcoatFactor(value) {
        this.shader.getDefaultColorShader().setUniformFloat(`clearcoatFactor`, value);
        this.useCleanCoat();
      }
      /**
       * get the factor of the clearcoat
       */
      get clearcoatFactor() {
        return this.shader.getDefaultColorShader().uniforms[`clearcoatFactor`].value;
      }
      /**
       * set the factor of the clearcoat Roughness
       */
      set clearcoatRoughnessFactor(value) {
        this.shader.getDefaultColorShader().setUniformFloat(`clearcoatRoughnessFactor`, value);
        this.useCleanCoat();
      }
      /**
       * get the factor of the clearcoat Roughness
       */
      get clearcoatRoughnessFactor() {
        return this.shader.getDefaultColorShader().uniforms[`clearcoatRoughnessFactor`].value;
      }
      /**
       * set the weight of the clearcoat
       */
      set clearcoatWeight(value) {
        this.shader.getDefaultColorShader().setUniformFloat(`clearcoatWeight`, value);
        this.useCleanCoat();
      }
      /**
       * get the weight of the clearcoat
       */
      get clearcoatWeight() {
        return this.shader.getDefaultColorShader().uniforms[`clearcoatWeight`].value;
      }
      /**
       * get the color of the clearcoat
       */
      set clearcoatColor(value) {
        this.shader.getDefaultColorShader().setUniformColor(`clearcoatColor`, value);
        this.useCleanCoat();
      }
      /**
       * set the color of the clearcoat
       */
      get clearcoatColor() {
        return this.shader.getDefaultColorShader().uniforms[`clearcoatColor`].color;
      }
    }

    class UnLitMaterial extends Material {
      /**
       * @constructor
       */
      constructor() {
        super();
        this.shader = new exports.UnLitShader();
        this.baseMap = Engine3D.res.whiteTexture;
      }
      set baseMap(texture) {
        this.shader.setTexture(`baseMap`, texture);
      }
      get baseMap() {
        return this.shader.getTexture(`baseMap`);
      }
      /**
       * set base color (tint color)
       */
      set baseColor(color) {
        this.shader.setUniformColor(`baseColor`, color);
      }
      /**
       * get base color (tint color)
       */
      get baseColor() {
        return this.shader.getUniformColor("baseColor");
      }
      /**
       * set environment texture, usually referring to cubemap
       */
      set envMap(texture) {
      }
      /**
       * @internal
       * set shadow map
       */
      set shadowMap(texture) {
      }
    }

    class PropertyAnimationClip {
      clipName;
      loopTime;
      startTime;
      stopTime;
      sampleRate;
      useSkeletonPos;
      useSkeletonScale;
      positionCurves = /* @__PURE__ */ new Map();
      rotationCurves = /* @__PURE__ */ new Map();
      scaleCurves = /* @__PURE__ */ new Map();
      floatCurves = /* @__PURE__ */ new Map();
      formBytes(bytes) {
        this.clipName = bytes.readUTF();
        this.loopTime = bytes.readInt32() ? false : true;
        this.startTime = bytes.readFloat32();
        this.stopTime = bytes.readFloat32();
        this.sampleRate = bytes.readInt32();
        this.useSkeletonPos = bytes.readInt32() > 0;
        this.useSkeletonScale = bytes.readInt32() > 0;
        if (this.useSkeletonPos) {
          let positionCurvesCount = bytes.readInt32();
          for (let i = 0; i < positionCurvesCount; i++) {
            let curveData = new AnimationCurveT();
            curveData.formBytes(bytes);
            this.positionCurves.set(curveData.path, curveData);
          }
        }
        let rotationCurvesCount = bytes.readInt32();
        for (let i = 0; i < rotationCurvesCount; i++) {
          let curveData = new AnimationCurveT();
          curveData.formBytes(bytes);
          this.rotationCurves.set(curveData.path, curveData);
        }
        if (this.useSkeletonScale) {
          let scaleCurvesCount = bytes.readInt32();
          for (let i = 0; i < scaleCurvesCount; i++) {
            let curveData = new AnimationCurveT();
            curveData.formBytes(bytes);
            this.scaleCurves.set(curveData.path, curveData);
          }
        }
        let floatCurvesCount = bytes.readInt32();
        for (let i = 0; i < floatCurvesCount; i++) {
          let curveData = new AnimationCurveT();
          curveData.formBytes(bytes);
          this.floatCurves.set(curveData.attribute, curveData);
        }
      }
    }

    class AnimationCurveT {
      path;
      attribute;
      propertys;
      preInfinity;
      postInfinity;
      rotationOrder;
      m_curves;
      k = 0;
      _cacheValue;
      _kValue;
      constructor(k = 1) {
        this.k = k;
        this.m_curves = [];
        this.check();
      }
      check() {
        for (let i = 0; i < this.k; i++) {
          this.m_curves[i] ||= new AnimationCurve();
        }
        switch (this.k) {
          case 1:
            this._cacheValue = 0;
            break;
          case 2:
            this._cacheValue = new Vector2();
            break;
          case 3:
            this._cacheValue = new Vector3();
            break;
          case 4:
            this._cacheValue = new Vector4();
            break;
        }
      }
      /**
       * return this curve use total time
       */
      get totalTime() {
        return this.m_curves[0].totalTime;
      }
      /**
       * add keyFrame to curve keyframe last and calcTotalTime
       * @param keyFrame {@link Keyframe}  sea: one key frame data
       */
      addKeyFrame(keyFrame) {
        for (let i = 0; i < this.k; i++) {
          this.m_curves[i].addKeyFrame(keyFrame.getK(i));
        }
      }
      /**
       * remove keyframe from this curve
       * @param keyFrame {@link Keyframe} 
       */
      removeKeyFrame(keyFrame) {
        for (let i = 0; i < this.k; i++) {
          this.m_curves[i].removeKeyFrame(keyFrame.getK(i));
        }
      }
      /**
       * get caculate frames value 
       * @param time 
       * @returns 
       */
      getValue(time) {
        switch (this.k) {
          case 1:
            this._cacheValue = this.m_curves[0].getValue(time);
            break;
          case 2:
            this._cacheValue.x = this.m_curves[0].getValue(time);
            this._cacheValue.y = this.m_curves[1].getValue(time);
            break;
          case 3:
            this._cacheValue.x = this.m_curves[0].getValue(time);
            this._cacheValue.y = this.m_curves[1].getValue(time);
            this._cacheValue.z = this.m_curves[2].getValue(time);
            break;
          case 4:
            this._cacheValue.x = this.m_curves[0].getValue(time);
            this._cacheValue.y = this.m_curves[1].getValue(time);
            this._cacheValue.z = this.m_curves[2].getValue(time);
            this._cacheValue.w = this.m_curves[3].getValue(time);
            break;
        }
        return this._cacheValue;
      }
      /**
       * get has Keyframe list count
       * @returns  int 
       */
      getKeyCount() {
        return this.m_curves[0].getKeyCount();
      }
      /**
       * Get a Keyframe Data by Index
       * @param index must int 
       * @returns Keyframe {@link Keyframe}
       */
      getKey(index) {
        let list = [];
        for (let i = 0; i < this.k; i++) {
          list.push(this.m_curves[i].getKey(index));
        }
        return list;
      }
      formBytes(bytes) {
        this.path = bytes.readUTF();
        this.k = bytes.readInt32();
        this.check();
        this.attribute = bytes.readUTF();
        this.propertys = this.attribute.split(".");
        this.preInfinity = bytes.readInt32();
        this.postInfinity = bytes.readInt32();
        this.rotationOrder = bytes.readInt32();
        let curvesCount = bytes.readInt32();
        for (let i = 0; i < curvesCount; i++) {
          let keyframe = new KeyframeT(0);
          keyframe.formBytes(bytes);
          this.addKeyFrame(keyframe);
        }
      }
    }

    class Bezier2D {
      _points;
      _cacheValue;
      /**
       * instance bezier class
       */
      constructor(vec2Ds = []) {
        this.points = vec2Ds;
        this._cacheValue = new Vector2();
      }
      /**
       * get all bezier 2d points
       */
      get points() {
        return this._points;
      }
      /**
       * set bezier 2d point[x,y] list must great 4
       */
      set points(value) {
        this._points = value;
      }
      /**
       * get point2d at curve
       * @param v 0.0 ~ 1.0 
       * @returns return point2D at curve 
       */
      getValue(v) {
        if (v < 0)
          v = 0;
        if (v > 1)
          v = 1;
        let len = this.points.length - 1;
        let ci = Math.floor(len * v);
        let ni = ci + 1;
        let w = MathUtil.fract((len + 1) * v);
        if (ni >= len) {
          ni = ci;
          w = 0;
        }
        this._cacheValue.x = this.points[ci].x + (this.points[ni].x - this.points[ci].x) * w;
        this._cacheValue.y = this.points[ci].y + (this.points[ni].y - this.points[ci].y) * w;
        return this._cacheValue;
      }
      /**
       * caclute bezier curve points at line [ 0.0 , 1.0 ]
       * @param anchorpoints bezier anchor
       * @param pointsAmount point count 
       * @returns get a bezier curve [Bezier2D]
       */
      static createBezierPoints(anchorpoints, pointsAmount) {
        var bezier2d = new Bezier2D();
        for (var i = 0; i < pointsAmount; i++) {
          var point = Bezier2D.multiPointBezier(anchorpoints, i / pointsAmount);
          bezier2d.points.push(point);
        }
        return bezier2d;
      }
      static multiPointBezier(points, t) {
        var len = points.length;
        var x = 0, y = 0;
        var erxiangshi = function(start, end) {
          var cs = 1, bcs = 1;
          while (end > 0) {
            cs *= start;
            bcs *= end;
            start--;
            end--;
          }
          return cs / bcs;
        };
        for (var i = 0; i < len; i++) {
          var point = points[i];
          x += point.x * Math.pow(1 - t, len - 1 - i) * Math.pow(t, i) * erxiangshi(len - 1, i);
          y += point.y * Math.pow(1 - t, len - 1 - i) * Math.pow(t, i) * erxiangshi(len - 1, i);
        }
        return new Vector2(x, y);
      }
    }

    class Bezier3D {
      static tmp_points = [];
      /**
       * get cubic curve point value from t at bezier data 
       * @param t interval value
       * @param p0 start point
       * @param c1 left control point
       * @param c2 right control point
       * @param p3 end point
       * @returns cubic curve point
       */
      static calculateCubicBezierPoint(t, p0, c1, c2, p3) {
        if (t > 1)
          t = 1;
        if (t < 0)
          t = 0;
        let u = 1 - t;
        let uu = u * u;
        let uuu = u * u * u;
        let tt = t * t;
        let ttt = t * t * t;
        let p = p0.mul(uuu);
        let tp1 = c1.mul(3);
        tp1 = tp1.mul(t);
        tp1 = tp1.mul(uu);
        let tp2 = c2.mul(3);
        tp2 = tp2.mul(tt);
        tp2 = tp2.mul(u);
        let tp3 = p3.mul(ttt);
        p = p.add(tp1);
        p = p.add(tp2);
        p = p.add(tp3);
        return p;
      }
      /**
       * get curve point from three point bezier curve 
       * @param t interval value
       * @param p0 start point
       * @param c1 contrl point 
       * @param p1 end point
       * @returns get bezier point at curve 
       */
      static bezierPoint(t, p0, c1, p1) {
        if (t > 1)
          t = 1;
        if (t < 0)
          t = 0;
        let u = 1 - t;
        let uu = u * u;
        let tt = t * t;
        let pp0 = p0.mul(uu);
        let cc1 = c1.mul(2);
        cc1.scaleBy(u);
        cc1.scaleBy(t);
        let pp1 = p1.mul(tt);
        pp0 = pp0.add(cc1);
        pp0 = pp0.add(pp1);
        return pp0;
      }
      static calculateCubicBezierPoints(t, ps, skip) {
        if (t > 1)
          t = 1;
        if (t < 0)
          t = 0;
        let u = 1 - t;
        let uu = u * u;
        let uuu = u * u * u;
        let tt = t * t;
        let ttt = t * t * t;
        let p = ps[skip].mul(uuu);
        let tp1 = ps[skip + 1].mul(3);
        tp1 = tp1.mul(t);
        tp1 = tp1.mul(uu);
        let tp2 = ps[skip + 2].mul(3);
        tp2 = tp2.mul(tt);
        tp2 = tp2.mul(u);
        let tp3 = ps[skip + 3].mul(ttt);
        p = p.add(tp1);
        p = p.add(tp2);
        p = p.add(tp3);
        return p;
      }
      static bezierPathValue(t, points) {
        if (t > 1)
          t = 1;
        if (t < 0)
          t = 0;
        let count = points.length;
        let tmp_points = this.tmp_points;
        tmp_points.length = 0;
        for (let i = 1; i < count; ++i) {
          for (let j = 0; j < count - i; ++j) {
            if (i == 1) {
              let v = new Vector3();
              v.x = points[j].x * (1 - t) + points[j + 1].x * t;
              v.y = points[j].y * (1 - t) + points[j + 1].y * t;
              v.z = points[j].z * (1 - t) + points[j + 1].z * t;
              this.tmp_points.push(v);
              continue;
            }
            let v2 = new Vector3();
            v2.x = tmp_points[j].x * (1 - t) + tmp_points[j + 1].x * t;
            v2.y = tmp_points[j].y * (1 - t) + tmp_points[j + 1].y * t;
            v2.z = tmp_points[j].z * (1 - t) + tmp_points[j + 1].z * t;
            tmp_points.push(v2);
          }
        }
        return tmp_points[0];
      }
    }

    class BiMap extends Map {
      negtive;
      constructor(iterable) {
        super(iterable);
        this.negtive = /* @__PURE__ */ new Map();
        if (iterable) {
          for (let item of iterable) {
            this.negtive.set(item[1], item[0]);
          }
        }
      }
      delete(key) {
        if (this.has(key)) {
          let value = this.get(key);
          this.negtive.delete(value);
          return super.delete(key);
        }
        return false;
      }
      getKey(value) {
        return this.negtive.get(value);
      }
      deleteValue(value) {
        let k = this.negtive.get(value);
        k && this.delete(k);
        return this.negtive.delete(value);
      }
      set(key, value) {
        super.set(key, value);
        this.negtive.set(value, key);
        return this;
      }
      clear() {
        this.negtive.clear();
        super.clear();
      }
    }

    class CubicBezierCurve {
      controlVertices;
      /**
       * @constructor
       * @param cvs controller points
       */
      constructor(cvs) {
        this.setControlVertices(cvs);
      }
      /**
       * update controller points
       * @param cvs controller points
       */
      setControlVertices(cvs) {
        if (cvs.length == 4) {
          this.controlVertices = cvs.concat();
        }
      }
      /**
       * get position by calc from curve
       * @param t a position in range [0-1]
       * @returns Vector3
       */
      getPoint(t) {
        if (!(t >= 0 && t <= 1)) {
          return Vector3.ZERO;
        }
        let c = 1 - t;
        let bb0 = c * c * c;
        let bb1 = 3 * t * c * c;
        let bb2 = 3 * t * t * c;
        let bb3 = t * t * t;
        let point = this.controlVertices[0].mul(bb0).add(this.controlVertices[1].mul(bb1)).add(this.controlVertices[2].mul(bb2)).add(this.controlVertices[3].mul(bb3));
        return point;
      }
      /**
       * get tagent by calc from curve
       * @param t a position in range [0-1]
       * @returns tagent direction
       * See: http://bimixual.org/AnimationLibrary/beziertangents.html
       */
      getTangent(t) {
        if (!(t >= 0 && t <= 1)) {
          return Vector3.ZERO;
        }
        let controlVerts = this.controlVertices;
        let q0 = controlVerts[0].add(controlVerts[1].add(controlVerts[0]).mul(t));
        let q1 = controlVerts[1].add(controlVerts[2].add(controlVerts[1]).mul(t));
        let q2 = controlVerts[2].add(controlVerts[3].add(controlVerts[2]).mul(t));
        let r0 = q0.add(q1.subtract(q0).mul(t));
        let r1 = q1.add(q2.subtract(q1).mul(t));
        let tangent = r1.subtract(r0);
        return tangent;
      }
      /**
       * get adjacent coordinates
       * @param pos position
       * @param paramThreshold threshold value
       * @returns a position in range [0-1]
       */
      getClosestParam(pos, paramThreshold = 1e-6) {
        return this.getClosestParamRec(pos, 0, 1, paramThreshold);
      }
      /**
       * get adjacent coordinates by given range
       * @param pos position
       * @param beginT range from
       * @param endT range end
       * @param thresholdT threshold value
       * @returns 
       */
      getClosestParamRec(pos, beginT, endT, thresholdT) {
        let mid = (beginT + endT) / 2;
        if (endT - beginT < thresholdT) {
          return mid;
        }
        let paramA = (beginT + mid) / 2;
        let paramB = (mid + endT) / 2;
        let posA = this.getPoint(paramA);
        let posB = this.getPoint(paramB);
        let distASq = posA.subtract(pos).lengthSquared;
        let distBSq = posB.subtract(pos).lengthSquared;
        if (distASq < distBSq) {
          endT = mid;
        } else {
          beginT = mid;
        }
        return this.getClosestParamRec(pos, beginT, endT, thresholdT);
      }
    }

    var CubicBezierType = /* @__PURE__ */ ((CubicBezierType2) => {
      CubicBezierType2[CubicBezierType2["Open"] = 0] = "Open";
      CubicBezierType2[CubicBezierType2["Closed"] = 1] = "Closed";
      return CubicBezierType2;
    })(CubicBezierType || {});
    class CubicBezierPath {
      type = 0 /* Open */;
      numCurveSegments = 0;
      numControlVertices = 0;
      controlVertices = [];
      // The term 'knot' is another name for a point right on the path (an interpolated point). With this constructor the
      // knots are supplied and interpolated. knots.length (the number of knots) must be >= 2. Interior Cvs are generated
      // transparently and automatically.
      constructor(controlVertices, t = 0 /* Open */) {
        this.setControlVertices(controlVertices, t);
      }
      getPathType() {
        return this.type;
      }
      isClosed() {
        return this.type == 1 /* Closed */ ? true : false;
      }
      /**
       * @returns 
       */
      isValid() {
        return this.numCurveSegments > 0 ? true : false;
      }
      clear() {
        this.controlVertices.length = 0;
        this.type = 0 /* Open */;
        this.numCurveSegments = 0;
        this.numControlVertices = 0;
      }
      computeApproxLength() {
        if (!this.isValid())
          return 0;
        let numInterpolatedPoints = this.numCurveSegments + 1;
        if (numInterpolatedPoints < 2)
          return 0;
        let totalDist = 0;
        let controlVertices = this.controlVertices;
        for (let n = 1; n < numInterpolatedPoints; n++) {
          let a = controlVertices[(n - 1) * 3];
          let b = controlVertices[n * 3];
          totalDist += a.subtract(b).lengthSquared;
        }
        if (totalDist == 0)
          return 0;
        return totalDist;
      }
      computeApproxParamPerUnitLength() {
        let length = this.computeApproxLength();
        return this.numCurveSegments / length;
      }
      computeApproxNormParamPerUnitLength() {
        let length = this.computeApproxLength();
        return 1 / length;
      }
      interpolatePoints(knots, t) {
        let numKnots = knots.length;
        if (numKnots < 2)
          console.error("point count must great 1");
        this.clear();
        this.type = t;
        let controlVertices = this.controlVertices;
        switch (t) {
          case 0 /* Open */: {
            this.numCurveSegments = numKnots - 1;
            this.numControlVertices = 3 * numKnots - 2;
            controlVertices.length = this.numControlVertices;
            for (let n = 0; n < numKnots; n++)
              controlVertices[n * 3] = knots[n];
            let initialPoint = knots[1].subtract(knots[0]).mul(0.25);
            controlVertices[1] = knots[0].add(initialPoint);
            let finalPoint = knots[numKnots - 2].subtract(knots[numKnots - 1]).mul(0.25);
            controlVertices[this.numControlVertices - 2] = knots[numKnots - 1].add(finalPoint);
            for (let k = 1; k < this.numCurveSegments; k++) {
              let a = knots[k - 1].subtract(knots[k]);
              let b = knots[k + 1].subtract(knots[k]);
              let aLen = a.lengthSquared;
              let bLen = b.lengthSquared;
              if (aLen > 0 && bLen > 0) {
                let abLen = (aLen + bLen) / 8;
                let ab = b.div(bLen).subtract(a.div(aLen));
                ab.normalize();
                ab = ab.mul(abLen);
                controlVertices[k * 3 - 1] = knots[k].subtract(ab);
                controlVertices[k * 3 + 1] = knots[k].add(ab);
              } else {
                controlVertices[k * 3 - 1] = knots[k];
                controlVertices[k * 3 + 1] = knots[k];
              }
            }
            break;
          }
          case 1 /* Closed */: {
            this.numCurveSegments = numKnots;
            this.numControlVertices = 3 * numKnots + 1;
            controlVertices.length = this.numControlVertices;
            for (let n = 0; n < numKnots; n++)
              controlVertices[n * 3] = knots[n];
            controlVertices[this.numControlVertices - 1] = knots[0];
            for (let k = 1; k <= this.numCurveSegments; k++) {
              let modkm1 = k - 1;
              let modkp1 = (k + 1) % this.numCurveSegments;
              let modk = k % this.numCurveSegments;
              let a = knots[modkm1].subtract(knots[modk]);
              let b = knots[modkp1].subtract(knots[modk]);
              let aLen = a.lengthSquared;
              let bLen = b.lengthSquared;
              let mod3km1 = 3 * k - 1;
              let mod3kp1 = (3 * k + 1) % (this.numControlVertices - 1);
              if (aLen > 0 && bLen > 0) {
                let abLen = (aLen + bLen) / 8;
                let ab = b.div(bLen).subtract(a.div(aLen));
                ab.normalize();
                ab = ab.mul(abLen);
                controlVertices[mod3km1] = knots[modk].subtract(ab);
                controlVertices[mod3kp1] = knots[modk].add(ab);
              } else {
                controlVertices[mod3km1] = knots[modk];
                controlVertices[mod3kp1] = knots[modk];
              }
            }
            break;
          }
        }
      }
      // For a closed path the last CV must match the first.
      setControlVertices(cvs, t) {
        let numCVs = cvs.length;
        if (numCVs <= 0)
          return;
        if (t == 0 /* Open */ && numCVs < 4)
          return;
        if (t == 1 /* Closed */ && numCVs < 7)
          return;
        if (!((numCVs - 1) % 3 == 0))
          return;
        this.clear();
        this.type = t;
        this.numControlVertices = numCVs;
        this.numCurveSegments = (numCVs - 1) / 3;
        this.controlVertices = cvs;
      }
      // t E [0, numSegments]. If the type is closed, the number of segments is one more than the equivalent open path.
      getPoint(t) {
        if (this.type == 1 /* Closed */) {
          while (t < 0)
            t += this.numCurveSegments;
          while (t > this.numCurveSegments)
            t -= this.numCurveSegments;
        } else {
          t = MathUtil.clampf(t, 0, this.numCurveSegments);
        }
        if (!(t >= 0) && t <= this.numCurveSegments)
          return;
        let segment = Math.floor(t);
        if (segment >= this.numCurveSegments)
          segment = this.numCurveSegments - 1;
        let curveCVs = [];
        let controlVerts = this.controlVertices;
        curveCVs[0] = controlVerts[3 * segment + 0];
        curveCVs[1] = controlVerts[3 * segment + 1];
        curveCVs[2] = controlVerts[3 * segment + 2];
        curveCVs[3] = controlVerts[3 * segment + 3];
        let bc = new CubicBezierCurve(curveCVs);
        return bc.getPoint(t - segment);
      }
      // Does the same as GetPoint except that t is normalized to be E [0, 1] over all segments. The beginning of the curve
      // is at t = 0 and the end at t = 1. Closed paths allow a value bigger than 1 in which case they loop.
      getPointNorm(t) {
        return this.getPoint(t * this.numCurveSegments);
      }
      // Similar to GetPoint but returns the tangent at the specified point on the path. The tangent is not normalized.
      // The longer the tangent the 'more influence' it has pulling the path in that direction.
      getTangent(t) {
        if (this.type == 1 /* Closed */) {
          while (t < 0)
            t += this.numCurveSegments;
          while (t > this.numCurveSegments)
            t -= this.numCurveSegments;
        } else {
          t = MathUtil.clampf(t, 0, this.numCurveSegments);
        }
        if (!(t >= 0) && t <= this.numCurveSegments)
          return;
        let segment = Math.floor(t);
        if (segment >= this.numCurveSegments)
          segment = this.numCurveSegments - 1;
        let controlVerts = this.controlVertices;
        let curveCVs = [];
        curveCVs[0] = controlVerts[3 * segment + 0];
        curveCVs[1] = controlVerts[3 * segment + 1];
        curveCVs[2] = controlVerts[3 * segment + 2];
        curveCVs[3] = controlVerts[3 * segment + 3];
        let bc = new CubicBezierCurve(curveCVs);
        return bc.getTangent(t - segment);
      }
      getTangentNorm(t) {
        return this.getTangent(t * this.numCurveSegments);
      }
      // This function returns a single closest point. There may be more than one point on the path at the same distance.
      // Use ComputeApproxParamPerUnitLength to determine a good paramThreshold. eg. Say you want a 15cm threshold,
      // use: paramThreshold = ComputeApproxParamPerUnitLength() * 0.15f.
      computeClosestParam(pos, paramThreshold) {
        let minDistSq = Number.MAX_SAFE_INTEGER;
        let closestParam = 0;
        let curveCVs = [];
        let curve = new CubicBezierCurve(curveCVs);
        for (let startIndex = 0; startIndex < this.controlVertices.length - 1; startIndex += 3) {
          for (let i = 0; i < 4; i++)
            curveCVs[i] = this.controlVertices[startIndex + i];
          curve.setControlVertices(curveCVs);
          let curveClosestParam = curve.getClosestParam(pos, paramThreshold);
          let curvePos = curve.getPoint(curveClosestParam);
          let distSq = curvePos.subtract(pos).lengthSquared;
          if (distSq < minDistSq) {
            minDistSq = distSq;
            let startParam = startIndex / 3;
            closestParam = startParam + curveClosestParam;
          }
        }
        return closestParam;
      }
      // Same as above but returns a t value E [0, 1]. You'll need to use a paramThreshold like
      // ComputeApproxParamPerUnitLength() * 0.15f if you want a 15cm tolerance.
      computeClosestNormParam(pos, paramThreshold) {
        return this.computeClosestParam(pos, paramThreshold * this.numCurveSegments);
      }
    }

    class OrderMap extends Map {
      valueList;
      keyList;
      isChange = true;
      constructor(iterable, recordKey, recordValue) {
        super(iterable);
        if (recordKey)
          this.keyList = [];
        if (recordValue)
          this.valueList = [];
        if (iterable) {
          for (let item of iterable) {
            this.valueList?.push(item[1]);
            this.keyList?.push(item[0]);
          }
        }
      }
      delete(key) {
        if (this.has(key)) {
          let value = this.get(key);
          this.valueList && this.deleteValue(value);
          this.keyList && this.deleteKey(key);
          this.isChange = true;
          return super.delete(key);
        }
        return false;
      }
      deleteValue(value) {
        let index = this.valueList.indexOf(value);
        if (index >= 0) {
          this.valueList.splice(index, 1);
        }
        return this;
      }
      deleteKey(key) {
        let index = this.keyList.indexOf(key);
        if (index >= 0) {
          this.keyList.splice(index, 1);
        }
        return this;
      }
      set(key, value) {
        this.delete(key);
        this.keyList?.push(key);
        this.valueList?.push(value);
        super.set(key, value);
        this.isChange = true;
        return this;
      }
      clear() {
        if (this.valueList)
          this.valueList.length = 0;
        if (this.keyList)
          this.keyList.length = 0;
        this.isChange = true;
        super.clear();
      }
    }

    var ParticleSystemRandomnessIds = /* @__PURE__ */ ((ParticleSystemRandomnessIds2) => {
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemClampVelocityCurveId"] = 322376503] = "kParticleSystemClampVelocityCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemForceCurveId"] = 306581307] = "kParticleSystemForceCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemRotationCurveId"] = 1793934638] = "kParticleSystemRotationCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemRotationBySpeedCurveId"] = 3737431713] = "kParticleSystemRotationBySpeedCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemStartSpeedCurveId"] = 2527743459] = "kParticleSystemStartSpeedCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemSizeCurveId"] = 2368504881] = "kParticleSystemSizeCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemSizeBySpeedCurveId"] = 4085612399] = "kParticleSystemSizeBySpeedCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemVelocityCurveId"] = 3774601268] = "kParticleSystemVelocityCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemUVCurveId"] = 326370691] = "kParticleSystemUVCurveId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemColorGradientId"] = 1494990940] = "kParticleSystemColorGradientId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemColorByVelocityGradientId"] = 1089181156] = "kParticleSystemColorByVelocityGradientId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemMeshSelectionId"] = 3159510623] = "kParticleSystemMeshSelectionId";
      ParticleSystemRandomnessIds2[ParticleSystemRandomnessIds2["kParticleSystemUVRowSelectionId"] = 2941263940] = "kParticleSystemUVRowSelectionId";
      return ParticleSystemRandomnessIds2;
    })(ParticleSystemRandomnessIds || {});
    const kPI = 3.141592653589793;

    class Polynomials {
    }
    function cubicPolynomialRoot(p, q, r) {
      let rcp3 = 1 / 3;
      let half = 0.5;
      let po3 = p * rcp3;
      let po3_2 = po3 * po3;
      let po3_3 = po3_2 * po3;
      let b = po3_3 - po3 * q * half + r * half;
      let a = -po3_2 + q * rcp3;
      let a3 = a * a * a;
      let det = a3 + b * b;
      if (det >= 0) {
        let r0 = Math.sqrt(det) - b;
        r0 = r0 > 0 ? Math.pow(r0, rcp3) : -Math.pow(-r0, rcp3);
        return -po3 - a / r0 + r0;
      }
      let abs = Math.sqrt(-a3);
      let arg = Math.acos(-b / abs);
      abs = Math.pow(abs, rcp3);
      abs = abs - a / abs;
      arg = -po3 + abs * Math.cos(arg * rcp3);
      return arg;
    }
    function quadraticPolynomialRootsGeneric(a, b, c, out) {
      let eps = 1e-5;
      if (Math.abs(a) < eps) {
        if (Math.abs(b) > eps) {
          out.r0 = -c / b;
          return 1;
        } else {
          return 0;
        }
      }
      let disc = b * b - 4 * a * c;
      if (disc < 0) {
        return 0;
      }
      let halfRcpA = 0.5 / a;
      let sqrtDisc = Math.sqrt(disc);
      out.r0 = (sqrtDisc - b) * halfRcpA;
      out.r1 = (-sqrtDisc - b) * halfRcpA;
      return 2;
    }
    function cubicPolynomialRootsGeneric(roots, a, b, c, d) {
      let numRoots = 0;
      if (Math.abs(a) >= 1e-4) {
        let p = b / a;
        let q = c / a;
        let r = d / a;
        roots[0] = cubicPolynomialRoot(p, q, r);
        numRoots++;
        let la = a;
        let lb = b + a * roots[0];
        let lc = c + b * roots[0] + a * roots[0] * roots[0];
        numRoots += quadraticPolynomialRootsGeneric(la, lb, lc, { r0: roots[1], r1: roots[2] });
      } else {
        numRoots += quadraticPolynomialRootsGeneric(b, c, d, { r0: roots[1], r1: roots[2] });
      }
      return numRoots;
    }

    class Polynomial {
      coeff = [];
      static EvalSegment(t, coeff) {
        return t * (t * (t * coeff[0] + coeff[1]) + coeff[2]) + coeff[3];
      }
    }
    class PolynomialCurve {
      static kMaxNumSegments = 8;
      segments = [];
      integrationCache = [];
      doubleIntegrationCache = [];
      times = [];
      segmentCount;
      constructor() {
        this.segments[PolynomialCurve.kMaxNumSegments] = new Polynomial();
        this.integrationCache[PolynomialCurve.kMaxNumSegments] = 0;
        this.doubleIntegrationCache[PolynomialCurve.kMaxNumSegments] = 0;
        this.times[PolynomialCurve.kMaxNumSegments] = 0;
      }
      calculateMinMax(minmax, value) {
        minmax.x = Math.min(minmax.x, value);
        minmax.y = Math.max(minmax.y, value);
      }
      findMinMaxDoubleIntegrated() {
        let result = Vector2.ZERO.clone();
        let numSteps = 20;
        let delta = 1 / numSteps;
        let acc = delta;
        for (let i = 0; i < numSteps; i++) {
          this.calculateMinMax(result, this.evaluateDoubleIntegrated(acc));
          acc += delta;
        }
        return result;
      }
      // Find the maximum of the integrated curve (x: min, y: max)
      findMinMaxIntegrated() {
        let result = Vector2.ZERO.clone();
        let start = [];
        let end = [];
        for (let i = 0; i < this.segmentCount; i++) {
          let a = 4 * this.segments[i].coeff[0];
          let b = 3 * this.segments[i].coeff[1];
          let c = 2 * this.segments[i].coeff[2];
          let d = 1 * this.segments[i].coeff[3];
          let roots = [];
          let numRoots = cubicPolynomialRootsGeneric(roots, a, b, c, d);
          for (let r = 0; r < numRoots; r++) {
            let root = roots[r] + start[i];
            if (root >= start[i] && root < end[i]) {
              this.calculateMinMax(result, this.evaluateIntegrated(root));
            }
          }
          this.calculateMinMax(result, this.evaluateIntegrated(end[i]));
          this.times[i];
        }
        return result;
      }
      generateIntegrationCache(curve) {
        curve.integrationCache[0] = 0;
        let prevTimeValue0 = curve.times[0];
        let prevTimeValue1 = 0;
        for (let i = 1; i < curve.segmentCount; i++) {
          let coeff = curve.segments[i - 1].coeff;
          integrateSegment(coeff);
          let time = prevTimeValue0 - prevTimeValue1;
          curve.integrationCache[i] = curve.integrationCache[i - 1] + Polynomial.EvalSegment(time, coeff) * time;
          prevTimeValue1 = prevTimeValue0;
          prevTimeValue0 = curve.times[i];
        }
      }
      generateDoubleIntegrationCache(curve) {
        let sum = 0;
        let prevTimeValue = 0;
        for (let i = 0; i < curve.segmentCount; i++) {
          curve.doubleIntegrationCache[i] = sum;
          let time = curve.times[i] - prevTimeValue;
          time = Math.max(time, 0);
          sum += Polynomial.EvalSegment(time, curve.segments[i].coeff) * time * time + curve.integrationCache[i] * time;
          prevTimeValue = curve.times[i];
        }
      }
      // Integrates a velocity curve to be a position curve.
      // You have to call EvaluateIntegrated to evaluate the curve
      integrate() {
        this.generateIntegrationCache(this);
        for (let i = 0; i < this.segmentCount; i++) {
          integrateSegment(this.segments[i].coeff);
        }
      }
      // Integrates a velocity curve to be a position curve.
      // You have to call EvaluateDoubleIntegrated to evaluate the curve
      doubleIntegrate() {
        this.generateIntegrationCache(this);
        for (let i = 0; i < this.segmentCount; i++) {
          doubleIntegrateSegment(this.segments[i].coeff);
        }
        this.generateDoubleIntegrationCache(this);
      }
      // Evaluates if it is possible to represent animation curve as PolynomialCurve
      static isValidCurve(editorCurve) {
        let keyCount = editorCurve.getKeyCount();
        let segmentCount = keyCount - 1;
        if (editorCurve.getKey(0).time != 0) {
          segmentCount++;
        }
        if (editorCurve.getKey(keyCount - 1).time != 1) {
          segmentCount++;
        }
        return segmentCount <= PolynomialCurve.kMaxNumSegments;
      }
      evaluateDoubleIntegrated(t) {
        let prevTimeValue = 0;
        for (let i = 0; i < this.segmentCount; i++) {
          if (t <= this.times[i]) {
            let time = t - prevTimeValue;
            return this.doubleIntegrationCache[i] + this.integrationCache[i] * time + Polynomial.EvalSegment(time, this.segments[i].coeff) * time * time;
          }
          prevTimeValue = this.times[i];
        }
        return 1;
      }
      // Evaluate integrated Polynomial curve.
      // Example: position = EvaluateIntegrated (normalizedTime) * startEnergy
      // Use Integrate function to for example turn a velocity curve into a position curve.
      // Expects that t is in the 0...1 range.
      evaluateIntegrated(t) {
        let prevTimeValue = 0;
        for (let i = 0; i < this.segmentCount; i++) {
          if (t <= this.times[i]) {
            let time = t - prevTimeValue;
            return this.integrationCache[i] + Polynomial.EvalSegment(time, this.segments[i].coeff) * time;
          }
          prevTimeValue = this.times[i];
        }
        return 1;
      }
      // Evaluate the curve
      // extects that t is in the 0...1 range
      evaluate(t) {
        let prevTimeValue = 0;
        for (let i = 0; i < this.segmentCount; i++) {
          if (t <= this.times[i]) {
            return Polynomial.EvalSegment(t - prevTimeValue, this.segments[i].coeff);
          }
          prevTimeValue = this.times[i];
        }
        return 1;
      }
      buildCurve(editorCurve, scale) {
        let keyCount = editorCurve.getKeyCount();
        this.segmentCount = 1;
        let kMaxTime = 1.01;
        this.segments.length = 0;
        this.integrationCache.length = 0;
        this.doubleIntegrationCache.length = 0;
        this.times.length = 0;
        this.times[0] = kMaxTime;
        if (keyCount == 0) ; else if (keyCount == 1) {
          this.segments[0] = new Polynomial();
          this.segments[0].coeff[3] = editorCurve.getKey(0).value * scale;
        } else {
          this.segmentCount = keyCount - 1;
          let segmentOffset = 0;
          if (editorCurve.getKey(0).time != 0) {
            this.segments[0].coeff[3] = editorCurve.getKey(0).value;
            this.times[0] = editorCurve.getKey(0).time;
            segmentOffset = 1;
          }
          for (let i = 0; i < this.segmentCount; i++) {
            let cache;
            editorCurve.calculateCacheData(cache, i, i + 1, 0);
            this.segments[i + segmentOffset].coeff = cache.coeff.concat();
            this.times[i + segmentOffset] = editorCurve.getKey(i + 1).time;
          }
          this.segmentCount += segmentOffset;
          if (editorCurve.getKey(keyCount - 1).time != 1) {
            this.segments[this.segmentCount].coeff[3] = editorCurve.getKey(keyCount - 1).value;
            this.segmentCount++;
          }
          this.times[this.segmentCount - 1] = kMaxTime;
          for (let i = 0; i < this.segmentCount; i++) {
            this.segments[i].coeff[0] *= scale;
            this.segments[i].coeff[1] *= scale;
            this.segments[i].coeff[2] *= scale;
            this.segments[i].coeff[3] *= scale;
          }
        }
        return true;
      }
    }
    function doubleIntegrateSegment(coeff) {
      coeff[0] /= 20;
      coeff[1] /= 12;
      coeff[2] /= 6;
      coeff[3] /= 2;
    }
    function integrateSegment(coeff) {
      coeff[0] /= 4;
      coeff[1] /= 3;
      coeff[2] /= 2;
      coeff[3] /= 1;
    }

    var ParticleSystemCurveEvalMode = /* @__PURE__ */ ((ParticleSystemCurveEvalMode2) => {
      ParticleSystemCurveEvalMode2[ParticleSystemCurveEvalMode2["kEMScalar"] = 0] = "kEMScalar";
      ParticleSystemCurveEvalMode2[ParticleSystemCurveEvalMode2["kEMOptimized"] = 1] = "kEMOptimized";
      ParticleSystemCurveEvalMode2[ParticleSystemCurveEvalMode2["kEMOptimizedMinMax"] = 2] = "kEMOptimizedMinMax";
      ParticleSystemCurveEvalMode2[ParticleSystemCurveEvalMode2["kEMSlow"] = 3] = "kEMSlow";
      return ParticleSystemCurveEvalMode2;
    })(ParticleSystemCurveEvalMode || {});
    var MinMaxCurveState = /* @__PURE__ */ ((MinMaxCurveState2) => {
      MinMaxCurveState2[MinMaxCurveState2["kMMCScalar"] = 0] = "kMMCScalar";
      MinMaxCurveState2[MinMaxCurveState2["kMMCCurve"] = 1] = "kMMCCurve";
      MinMaxCurveState2[MinMaxCurveState2["kMMCTwoCurves"] = 2] = "kMMCTwoCurves";
      MinMaxCurveState2[MinMaxCurveState2["kMMCTwoConstants"] = 3] = "kMMCTwoConstants";
      return MinMaxCurveState2;
    })(MinMaxCurveState || {});
    class MinMaxAnimationCurves {
      // public SupportsProcedural ();
      max;
      min;
    }
    class MinMaxPolyCurves {
      max;
      min;
      integrate() {
        this.max.integrate();
        this.min.integrate();
      }
      doubleIntegrate() {
        this.max.doubleIntegrate();
        this.min.doubleIntegrate();
      }
      findMinMaxIntegrated() {
        return null;
      }
      findMinMaxDoubleIntegrated() {
        return null;
      }
    }
    class MinMaxCurve {
      minMaxState;
      // see enum MinMaxCurveState
      minCurve;
      maxCurve;
      _scalar = 1;
      // Since scalar is baked into the optimized curve we use the setter function to modify it.
      _minScalar;
      constructor(scalarValue = 1) {
        this._scalar = scalarValue;
        this.minMaxState = 0 /* kMMCScalar */;
        this.minCurve = new AnimationCurve();
        this.maxCurve = new AnimationCurve();
      }
      setScalar(value) {
        this._scalar = value;
      }
      getScalar() {
        return this._scalar;
      }
      static evaluateSlow(curve, t, factor) {
        let v = curve.maxCurve.getValue(t) * curve.getScalar();
        if (curve.minMaxState == 2 /* kMMCTwoCurves */) {
          return lerp(curve.minCurve.getValue(t) * curve.getScalar(), v, factor);
        } else
          return v;
      }
      static evaluate(curve, t, randomValue = 1) {
        if (curve.minMaxState == 0 /* kMMCScalar */) {
          return curve.getScalar();
        }
        let v = curve.maxCurve.getValue(t) * curve.getScalar();
        if (curve.minMaxState == 1 /* kMMCCurve */) {
          return lerp(curve.minCurve.getValue(t) * curve.getScalar(), v, randomValue);
        }
        if (curve.minMaxState == 3 /* kMMCTwoConstants */) {
          return lerp(curve._minScalar, curve._scalar, randomValue);
        }
        if (curve.minMaxState == 2 /* kMMCTwoCurves */) {
          return lerp(curve.minCurve.getValue(t) * curve.getScalar(), v, 1 * Math.random());
        }
        return this.evaluateSlow(curve, t, 1);
      }
      unSerialized(data) {
        this.minMaxState = data["minMaxState"];
        this._scalar = data["scalar"];
        this._minScalar = data["minScalar"];
        this.maxCurve.unSerialized(data["maxCurve"]);
        this.minCurve.unSerialized(data["minCurve"]);
      }
    }
    class ValueSpread {
      value = 0;
      mode = 0;
      spread = 0;
      speed = new MinMaxCurve();
      unSerialized(data) {
        this.value = data["value"];
        this.mode = data["mode"];
        this.spread = data["spread"];
        this.speed.unSerialized(data["speed"]);
      }
    }
    function curvesSupportProcedural(editorCurves, minMaxState) {
      let isValid = PolynomialCurve.isValidCurve(editorCurves.max);
      if (minMaxState != 2 /* kMMCTwoCurves */ && minMaxState != 3 /* kMMCTwoConstants */) {
        return isValid;
      } else {
        return isValid && PolynomialCurve.isValidCurve(editorCurves.min);
      }
    }
    function buildCurves(polyCurves, editorCurves, scalar, minMaxState) {
      polyCurves.max.buildCurve(editorCurves.max, scalar);
      if (minMaxState != 2 /* kMMCTwoCurves */ && minMaxState != 3 /* kMMCTwoConstants */) {
        polyCurves.min.buildCurve(editorCurves.max, scalar);
      } else {
        polyCurves.min.buildCurve(editorCurves.min, scalar);
      }
    }
    function calculateCurveRangesValue(minMaxValue, curve) {
      let keyCount = curve.getKeyCount();
      if (keyCount == 0) {
        return;
      }
      if (keyCount == 1) {
        calculateMinMax(minMaxValue, curve.getKey(0).value);
      } else {
        let segmentCount = keyCount - 1;
        calculateMinMax(minMaxValue, curve.getKey(0).value);
        for (let i = 0; i < segmentCount; i++) {
          let cache = new FrameCache();
          curve.calculateCacheData(cache, i, i + 1, 0);
          let a = 3 * cache.coeff[0];
          let b = 2 * cache.coeff[1];
          let c = 1 * cache.coeff[2];
          let start = curve.getKey(i).time;
          let end = curve.getKey(i + 1).time;
          let roots = [];
          let numRoots = quadraticPolynomialRootsGeneric(a, b, c, { r0: roots[0], r1: roots[1] });
          for (let r = 0; r < numRoots; r++) {
            if (roots[r] >= 0 && roots[r] + start < end) {
              calculateMinMax(minMaxValue, Polynomial.EvalSegment(roots[r], cache.coeff));
            }
          }
          calculateMinMax(minMaxValue, Polynomial.EvalSegment(end - start, cache.coeff));
        }
      }
    }
    function calculateMinMax(minmax, value) {
      minmax.x = Math.min(minmax.x, value);
      minmax.y = Math.max(minmax.y, value);
    }

    class Plane {
      /**
       * Center position of plane
       */
      point = new Vector3();
      /**
       * Plane normal vector
       */
      normal = Vector3.UP;
      /**
       * @internal
       */
      _tmpVecA = new Vector3();
      /**
       * Constructs a new plane object
       * @param pos Plane position
       * @param normal Plane normal quantity
       */
      constructor(pos, normal) {
        this.point = pos;
        this.normal = normal;
      }
      /**
       * Clones the current plane object
       * @returns New plane object
       */
      clone() {
        let plane = new Plane(this.point.clone(), this.normal.clone());
        return plane;
      }
      /**
       * Determine whether the plane intersects a line segment and calculate the intersection point
       * @param start Starting point of line segment
       * @param end End point of line segment
       * @param point Point of output intersection
       * @returns Returns whether it intersects
       */
      intersectsLine(start, end, point) {
        var d = -this.normal.dotProduct(this.point);
        var d0 = this.normal.dotProduct(start) + d;
        var d1 = this.normal.dotProduct(end) + d;
        var t = d0 / (d0 - d1);
        var intersects = t >= 0 && t <= 1;
        if (intersects && point) {
          point.lerp(start, end, t);
        }
        return intersects;
      }
      /**
       * Determine whether the plane intersects a ray and calculate the intersection point
       * @param ray Ray of input
       * @param outPoint Point of output intersection
       * @returns Returns whether it intersects
       */
      intersectsRay(ray, targetPoint) {
        targetPoint ||= this._tmpVecA;
        targetPoint.copy(this.point).subtract(ray.origin, targetPoint);
        var t = this.normal.dotProduct(targetPoint) / this.normal.dotProduct(ray.direction);
        var intersects = t >= 0;
        if (intersects) {
          targetPoint.copyFrom(ray.direction).multiplyScalar(t).add(ray.origin, targetPoint);
        }
        return intersects;
      }
    }

    class PlaneClassification {
      /**
      * @language zh_CN
      * 背面
      * @platform Web,Native
      */
      static BACK = 0;
      /**
      * @language zh_CN
      * 正面
      * @platform Web,Native
      */
      static FRONT = 1;
      /**
      * @language zh_CN
      * 在法线朝上的一面
      * @platform Web,Native
      */
      static IN = 0;
      /**
      * @language zh_CN
      * 在法线朝下的一面
      * @platform Web,Native
      */
      static OUT = 1;
      /**
      * @language zh_CN
      * 相交
      * @platform Web,Native
      */
      static INTERSECT = 2;
    }

    class Plane3D {
      /**
       * @language en_US
       * The A coefficient of this plane. (Also the x dimension of the plane normal)
       */
      /**
      * @language zh_CN
      * 平面中的a分量
      * @platform Web,Native
      */
      a;
      /**
       * @language en_US
       * The B coefficient of this plane. (Also the y dimension of the plane normal)
       */
      /**
      * @language zh_CN
      * 平面中的b分量
      * @platform Web,Native
      */
      b;
      /**
       * @language en_US
       * The C coefficient of this plane. (Also the z dimension of the plane normal)
       */
      /**
      * @language zh_CN
      * 平面中的c分量
      * @platform Web,Native
      */
      c;
      /**
       * @language en_US
       * The D coefficient of this plane. (Also the inverse dot product between normal and point)
       */
      /**
      * @language zh_CN
      * 平面中的d分量
      * @platform Web,Native
      */
      d;
      // indicates the alignment of the plane
      /**
       * @private
       */
      static ALIGN_ANY = 0;
      /**
       * @private
       */
      static ALIGN_XY_AXIS = 1;
      /**
       * @private
       */
      static ALIGN_YZ_AXIS = 2;
      /**
       * @private
       */
      static ALIGN_XZ_AXIS = 3;
      /**
       * @language en_US
       * Create a Plane3D with ABCD coefficients
       */
      /**
      * @language zh_CN
      * 创建一个平面实例
      * @param a
      * @param b
      * @param c
      * @param d
      * @platform Web,Native
      */
      constructor(a = 0, b = 0, c = 0, d = 0) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
      }
      /**
      * @language zh_CN
      * 填充平面的各分量的值
      * @param a
      * @param b
      * @param c
      * @param d
      * @platform Web,Native
      */
      setTo(a = 0, b = 0, c = 0, d = 0) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
      }
      /**
       * @language en_US
       * Fills this Plane3D with the coefficients from 3 points in 3d space.
       * @param p0 Vector3
       * @param p1 Vector3
       * @param p2 Vector3
       */
      /**
      * @language zh_CN
      * 由3个坐标来创建一个3d平面
      * @param p0 Vector3
      * @param p1 Vector3
      * @param p2 Vector3
      * @platform Web,Native
      */
      fromPoints(p0, p1, p2) {
        var d1x = p1.x - p0.x;
        var d1y = p1.y - p0.y;
        var d1z = p1.z - p0.z;
        var d2x = p2.x - p0.x;
        var d2y = p2.y - p0.y;
        var d2z = p2.z - p0.z;
        this.a = d1y * d2z - d1z * d2y;
        this.b = d1z * d2x - d1x * d2z;
        this.c = d1x * d2y - d1y * d2x;
        this.d = -(this.a * p0.x + this.b * p0.y + this.c * p0.z);
      }
      /**
       * @language en_US
       * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
       * @param normal Vector3
       * @param point  Vector3
       */
      /**
      * @language zh_CN
      * 由一条normal向量和一个坐标创建一个3d平面
      * @param normal Vector3
      * @param point  Vector3
      * @platform Web,Native
      */
      fromNormalAndPoint(normal, point) {
        this.a = normal.x;
        this.b = normal.y;
        this.c = normal.z;
        this.d = -(this.a * point.x + this.b * point.y + this.c * point.z);
      }
      /**
       * @language en_US
       * Normalize this Plane3D
       * @returns Plane3D This Plane3D.
       */
      /**
      * @language zh_CN
      * 单位化3d平面
      * @returns number 返回平面长度
      * @platform Web,Native
      */
      normalize() {
        var len = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
        if (len > 0) {
          var invLength = 1 / len;
          this.a *= invLength;
          this.b *= invLength;
          this.c *= invLength;
          this.d *= invLength;
        }
        return len;
      }
      /**
       * @language en_US
       * Returns the signed distance between this Plane3D and the point p.
       * @param p Vector3
       * @returns Number
       */
      /**
      * @language zh_CN
      * 计算3d平面到点p的距离
      * @param p Vector3
      * @returns number 返回计算后的距离
      * @platform Web,Native
      */
      distance(p) {
        return this.a * p.x + this.b * p.y + this.c * p.z + this.d;
      }
      /**
       * @language en_US
       * Classify a point against this Plane3D. (in front, back or intersecting)
       * @param p Vector3
       * @param epsilon
       * @returns PlaneClassification.FRONT在平面正面 
       * PlaneClassification.BACK在平面背面面 
       * PlaneClassification.INTERSECT在平面上
       */
      /**
      * @language zh_CN
      * 计算3d平面和点p的空间关系
      * @param p Vector3
      * @param epsilon 相对偏移值
      * @returns number int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
      * @platform Web,Native
      */
      classifyPoint(p, epsilon = 0.01) {
        var dis = this.distance(p);
        if (dis < -epsilon) {
          return PlaneClassification.BACK;
        } else if (dis > epsilon) {
          return PlaneClassification.FRONT;
        }
        return PlaneClassification.INTERSECT;
      }
      /**
      * @language zh_CN
      * 当前Plane3D以字符串形式返回
      * @returns string
      * @platform Web,Native
      */
      toString() {
        return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
      }
    }

    function uniform_real_distribution(min, max) {
      return Math.random() * max + Math.random() * min + (max - min) * Math.random();
    }
    function uniform_real_distribution2(min, max, rng) {
      let rd = rng * Math.random();
      return Math.random() * max * rd + Math.random() * min * rd + (max - min) * Math.random() * rd;
    }
    function normal_distribution(min, max, skew) {
      let u = 0, v = 0;
      while (u === 0)
        u = Math.random();
      while (v === 0)
        v = Math.random();
      let num = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      num = num / 10 + 0.5;
      if (num > 1 || num < 0)
        num = normal_distribution(min, max, skew);
      num = Math.pow(num, skew);
      num *= max - min;
      num += min;
      return num;
    }
    function FASTFLOOR(x) {
      return x > 0 ? Math.floor(x) : Math.floor(x) - 1;
    }
    let perm = [
      151,
      160,
      137,
      91,
      90,
      15,
      131,
      13,
      201,
      95,
      96,
      53,
      194,
      233,
      7,
      225,
      140,
      36,
      103,
      30,
      69,
      142,
      8,
      99,
      37,
      240,
      21,
      10,
      23,
      190,
      6,
      148,
      247,
      120,
      234,
      75,
      0,
      26,
      197,
      62,
      94,
      252,
      219,
      203,
      117,
      35,
      11,
      32,
      57,
      177,
      33,
      88,
      237,
      149,
      56,
      87,
      174,
      20,
      125,
      136,
      171,
      168,
      68,
      175,
      74,
      165,
      71,
      134,
      139,
      48,
      27,
      166,
      77,
      146,
      158,
      231,
      83,
      111,
      229,
      122,
      60,
      211,
      133,
      230,
      220,
      105,
      92,
      41,
      55,
      46,
      245,
      40,
      244,
      102,
      143,
      54,
      65,
      25,
      63,
      161,
      1,
      216,
      80,
      73,
      209,
      76,
      132,
      187,
      208,
      89,
      18,
      169,
      200,
      196,
      135,
      130,
      116,
      188,
      159,
      86,
      164,
      100,
      109,
      198,
      173,
      186,
      3,
      64,
      52,
      217,
      226,
      250,
      124,
      123,
      5,
      202,
      38,
      147,
      118,
      126,
      255,
      82,
      85,
      212,
      207,
      206,
      59,
      227,
      47,
      16,
      58,
      17,
      182,
      189,
      28,
      42,
      223,
      183,
      170,
      213,
      119,
      248,
      152,
      2,
      44,
      154,
      163,
      70,
      221,
      153,
      101,
      155,
      167,
      43,
      172,
      9,
      129,
      22,
      39,
      253,
      19,
      98,
      108,
      110,
      79,
      113,
      224,
      232,
      178,
      185,
      112,
      104,
      218,
      246,
      97,
      228,
      251,
      34,
      242,
      193,
      238,
      210,
      144,
      12,
      191,
      179,
      162,
      241,
      81,
      51,
      145,
      235,
      249,
      14,
      239,
      107,
      49,
      192,
      214,
      31,
      181,
      199,
      106,
      157,
      184,
      84,
      204,
      176,
      115,
      121,
      50,
      45,
      127,
      4,
      150,
      254,
      138,
      236,
      205,
      93,
      222,
      114,
      67,
      29,
      24,
      72,
      243,
      141,
      128,
      195,
      78,
      66,
      215,
      61,
      156,
      180,
      151,
      160,
      137,
      91,
      90,
      15,
      131,
      13,
      201,
      95,
      96,
      53,
      194,
      233,
      7,
      225,
      140,
      36,
      103,
      30,
      69,
      142,
      8,
      99,
      37,
      240,
      21,
      10,
      23,
      190,
      6,
      148,
      247,
      120,
      234,
      75,
      0,
      26,
      197,
      62,
      94,
      252,
      219,
      203,
      117,
      35,
      11,
      32,
      57,
      177,
      33,
      88,
      237,
      149,
      56,
      87,
      174,
      20,
      125,
      136,
      171,
      168,
      68,
      175,
      74,
      165,
      71,
      134,
      139,
      48,
      27,
      166,
      77,
      146,
      158,
      231,
      83,
      111,
      229,
      122,
      60,
      211,
      133,
      230,
      220,
      105,
      92,
      41,
      55,
      46,
      245,
      40,
      244,
      102,
      143,
      54,
      65,
      25,
      63,
      161,
      1,
      216,
      80,
      73,
      209,
      76,
      132,
      187,
      208,
      89,
      18,
      169,
      200,
      196,
      135,
      130,
      116,
      188,
      159,
      86,
      164,
      100,
      109,
      198,
      173,
      186,
      3,
      64,
      52,
      217,
      226,
      250,
      124,
      123,
      5,
      202,
      38,
      147,
      118,
      126,
      255,
      82,
      85,
      212,
      207,
      206,
      59,
      227,
      47,
      16,
      58,
      17,
      182,
      189,
      28,
      42,
      223,
      183,
      170,
      213,
      119,
      248,
      152,
      2,
      44,
      154,
      163,
      70,
      221,
      153,
      101,
      155,
      167,
      43,
      172,
      9,
      129,
      22,
      39,
      253,
      19,
      98,
      108,
      110,
      79,
      113,
      224,
      232,
      178,
      185,
      112,
      104,
      218,
      246,
      97,
      228,
      251,
      34,
      242,
      193,
      238,
      210,
      144,
      12,
      191,
      179,
      162,
      241,
      81,
      51,
      145,
      235,
      249,
      14,
      239,
      107,
      49,
      192,
      214,
      31,
      181,
      199,
      106,
      157,
      184,
      84,
      204,
      176,
      115,
      121,
      50,
      45,
      127,
      4,
      150,
      254,
      138,
      236,
      205,
      93,
      222,
      114,
      67,
      29,
      24,
      72,
      243,
      141,
      128,
      195,
      78,
      66,
      215,
      61,
      156,
      180
    ];
    function grad1(hash, x) {
      let h = hash & 15;
      let grad = 1 + (h & 7);
      if (h & 8)
        grad = -grad;
      return grad * x;
    }
    function grad2(hash, x, y) {
      let h = hash & 7;
      let u = h < 4 ? x : y;
      let v = h < 4 ? y : x;
      return (h & 1 ? -u : u) + (h & 2 ? -2 * v : 2 * v);
    }
    function grad3(hash, x, y, z) {
      let h = hash & 15;
      let u = h < 8 ? x : y;
      let v = h < 4 ? y : h == 12 || h == 14 ? x : z;
      return (h & 1 ? -u : u) + (h & 2 ? -v : v);
    }
    function grad4(hash, x, y, z, t) {
      let h = hash & 31;
      let u = h < 24 ? x : y;
      let v = h < 16 ? y : z;
      let w = h < 8 ? z : t;
      return (h & 1 ? -u : u) + (h & 2 ? -v : v) + (h & 4 ? -w : w);
    }
    let simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
    function snoise1(x) {
      let i0 = FASTFLOOR(x);
      let i1 = i0 + 1;
      let x0 = x - i0;
      let x1 = x0 - 1;
      let n0, n1;
      let t0 = 1 - x0 * x0;
      t0 *= t0;
      n0 = t0 * t0 * grad1(perm[i0 & 255], x0);
      let t1 = 1 - x1 * x1;
      t1 *= t1;
      n1 = t1 * t1 * grad1(perm[i1 & 255], x1);
      return 0.25 * (n0 + n1);
    }
    function snoise2(x, y) {
      const F2 = 0.366025403;
      const G2 = 0.211324865;
      let n0, n1, n2;
      let s = (x + y) * F2;
      let xs = x + s;
      let ys = y + s;
      let i = FASTFLOOR(xs);
      let j = FASTFLOOR(ys);
      let t = (i + j) * G2;
      let X0 = i - t;
      let Y0 = j - t;
      let x0 = x - X0;
      let y0 = y - Y0;
      let i1, j1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } else {
        i1 = 0;
        j1 = 1;
      }
      let x1 = x0 - i1 + G2;
      let y1 = y0 - j1 + G2;
      let x2 = x0 - 1 + 2 * G2;
      let y2 = y0 - 1 + 2 * G2;
      let ii = i & 255;
      let jj = j & 255;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0)
        n0 = 0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * grad2(perm[ii + perm[jj]], x0, y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0)
        n1 = 0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * grad2(perm[ii + i1 + perm[jj + j1]], x1, y1);
      }
      let t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 < 0)
        n2 = 0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * grad2(perm[ii + 1 + perm[jj + 1]], x2, y2);
      }
      return 40 * (n0 + n1 + n2);
    }
    function snoise3(x, y, z) {
      const F3 = 0.333333333;
      const G3 = 0.166666667;
      let n0, n1, n2, n3;
      let s = (x + y + z) * F3;
      let xs = x + s;
      let ys = y + s;
      let zs = z + s;
      let i = FASTFLOOR(xs);
      let j = FASTFLOOR(ys);
      let k = FASTFLOOR(zs);
      let t = (i + j + k) * G3;
      let X0 = i - t;
      let Y0 = j - t;
      let Z0 = k - t;
      let x0 = x - X0;
      let y0 = y - Y0;
      let z0 = z - Z0;
      let i1, j1, k1;
      let i2, j2, k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      let x1 = x0 - i1 + G3;
      let y1 = y0 - j1 + G3;
      let z1 = z0 - k1 + G3;
      let x2 = x0 - i2 + 2 * G3;
      let y2 = y0 - j2 + 2 * G3;
      let z2 = z0 - k2 + 2 * G3;
      let x3 = x0 - 1 + 3 * G3;
      let y3 = y0 - 1 + 3 * G3;
      let z3 = z0 - 1 + 3 * G3;
      let ii = i & 255;
      let jj = j & 255;
      let kk = k & 255;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0)
        n0 = 0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * grad3(perm[ii + perm[jj + perm[kk]]], x0, y0, z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0)
        n1 = 0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * grad3(perm[ii + i1 + perm[jj + j1 + perm[kk + k1]]], x1, y1, z1);
      }
      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0)
        n2 = 0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * grad3(perm[ii + i2 + perm[jj + j2 + perm[kk + k2]]], x2, y2, z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0)
        n3 = 0;
      else {
        t3 *= t3;
        n3 = t3 * t3 * grad3(perm[ii + 1 + perm[jj + 1 + perm[kk + 1]]], x3, y3, z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    }
    function snoise4(x, y, z, w) {
      const F4 = 0.309016994;
      const G4 = 0.138196601;
      let n0, n1, n2, n3, n4;
      let s = (x + y + z + w) * F4;
      let xs = x + s;
      let ys = y + s;
      let zs = z + s;
      let ws = w + s;
      let i = FASTFLOOR(xs);
      let j = FASTFLOOR(ys);
      let k = FASTFLOOR(zs);
      let l = FASTFLOOR(ws);
      let t = (i + j + k + l) * G4;
      let X0 = i - t;
      let Y0 = j - t;
      let Z0 = k - t;
      let W0 = l - t;
      let x0 = x - X0;
      let y0 = y - Y0;
      let z0 = z - Z0;
      let w0 = w - W0;
      let c1 = x0 > y0 ? 32 : 0;
      let c2 = x0 > z0 ? 16 : 0;
      let c3 = y0 > z0 ? 8 : 0;
      let c4 = x0 > w0 ? 4 : 0;
      let c5 = y0 > w0 ? 2 : 0;
      let c6 = z0 > w0 ? 1 : 0;
      let c = c1 + c2 + c3 + c4 + c5 + c6;
      let i1, j1, k1, l1;
      let i2, j2, k2, l2;
      let i3, j3, k3, l3;
      i1 = simplex[c][0] >= 3 ? 1 : 0;
      j1 = simplex[c][1] >= 3 ? 1 : 0;
      k1 = simplex[c][2] >= 3 ? 1 : 0;
      l1 = simplex[c][3] >= 3 ? 1 : 0;
      i2 = simplex[c][0] >= 2 ? 1 : 0;
      j2 = simplex[c][1] >= 2 ? 1 : 0;
      k2 = simplex[c][2] >= 2 ? 1 : 0;
      l2 = simplex[c][3] >= 2 ? 1 : 0;
      i3 = simplex[c][0] >= 1 ? 1 : 0;
      j3 = simplex[c][1] >= 1 ? 1 : 0;
      k3 = simplex[c][2] >= 1 ? 1 : 0;
      l3 = simplex[c][3] >= 1 ? 1 : 0;
      let x1 = x0 - i1 + G4;
      let y1 = y0 - j1 + G4;
      let z1 = z0 - k1 + G4;
      let w1 = w0 - l1 + G4;
      let x2 = x0 - i2 + 2 * G4;
      let y2 = y0 - j2 + 2 * G4;
      let z2 = z0 - k2 + 2 * G4;
      let w2 = w0 - l2 + 2 * G4;
      let x3 = x0 - i3 + 3 * G4;
      let y3 = y0 - j3 + 3 * G4;
      let z3 = z0 - k3 + 3 * G4;
      let w3 = w0 - l3 + 3 * G4;
      let x4 = x0 - 1 + 4 * G4;
      let y4 = y0 - 1 + 4 * G4;
      let z4 = z0 - 1 + 4 * G4;
      let w4 = w0 - 1 + 4 * G4;
      let ii = i & 255;
      let jj = j & 255;
      let kk = k & 255;
      let ll = l & 255;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0)
        n0 = 0;
      else {
        t0 *= t0;
        n0 = t0 * t0 * grad4(perm[ii + perm[jj + perm[kk + perm[ll]]]], x0, y0, z0, w0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0)
        n1 = 0;
      else {
        t1 *= t1;
        n1 = t1 * t1 * grad4(perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]], x1, y1, z1, w1);
      }
      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0)
        n2 = 0;
      else {
        t2 *= t2;
        n2 = t2 * t2 * grad4(perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]], x2, y2, z2, w2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0)
        n3 = 0;
      else {
        t3 *= t3;
        n3 = t3 * t3 * grad4(perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]], x3, y3, z3, w3);
      }
      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0)
        n4 = 0;
      else {
        t4 *= t4;
        n4 = t4 * t4 * grad4(perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]], x4, y4, z4, w4);
      }
      return 27 * (n0 + n1 + n2 + n3 + n4);
    }

    class UV extends Vector2 {
      static uv_0 = new UV();
      u = 0;
      v = 0;
      constructor(x = 0, y = 0) {
        super(x, y);
        this.u = x;
        this.v = y;
      }
      length() {
        return 0;
      }
      static getUVSheet(frame, countX, countY) {
        let f = Math.floor(frame % (countX * countY));
        let fx = Math.floor(f / countX);
        let fy = f % countX;
        return new Vector4(fx / countX, fy / countY, 1 / countX, 1 / countY);
      }
    }

    class KeyframeT {
      serializedVersion = "2";
      time;
      tangentMode = 0;
      weightedMode = 0;
      // public value: CurveValueType;
      // public inSlope: CurveValueType;
      // public outSlope: CurveValueType;
      // public inWeight: CurveValueType
      // public outWeight: CurveValueType
      propertyKeyFrame;
      constructor(time = 0) {
        this.time = time;
        this.propertyKeyFrame = {};
      }
      getK(k) {
        return this.propertyKeyFrame[k];
      }
      split(type, value, property) {
        switch (type) {
          case ValueEnumType.single:
            {
              let keyFrame = this.getKeyFrame(0);
              keyFrame[property] = value;
            }
            break;
          case ValueEnumType.float:
            {
              let keyFrame = this.getKeyFrame(0);
              keyFrame[property] = value;
            }
            break;
          case ValueEnumType.vector2:
            {
              let v = value;
              let x_kf = this.getKeyFrame(0);
              x_kf[property] = v.x;
              let y_kf = this.getKeyFrame(1);
              y_kf[property] = v.y;
            }
            break;
          case ValueEnumType.vector3:
            {
              let v = value;
              let x_kf = this.getKeyFrame(0);
              x_kf[property] = v.x;
              let y_kf = this.getKeyFrame(1);
              y_kf[property] = v.y;
              let z_kf = this.getKeyFrame(2);
              z_kf[property] = v.z;
            }
            break;
          case ValueEnumType.vector4:
            {
              let v = value;
              let x_kf = this.getKeyFrame(0);
              x_kf[property] = v.x;
              let y_kf = this.getKeyFrame(1);
              y_kf[property] = v.y;
              let z_kf = this.getKeyFrame(2);
              z_kf[property] = v.y;
              let w_kf = this.getKeyFrame(3);
              w_kf[property] = v.y;
            }
            break;
          case ValueEnumType.quaternion:
            {
              let v = value;
              let x_kf = this.getKeyFrame(0);
              x_kf[property] = v.x;
              let y_kf = this.getKeyFrame(1);
              y_kf[property] = v.y;
              let z_kf = this.getKeyFrame(2);
              z_kf[property] = v.z;
              let w_kf = this.getKeyFrame(3);
              w_kf[property] = v.w;
            }
            break;
        }
      }
      getKeyFrame(k) {
        let keyFrame = this.propertyKeyFrame[k];
        if (!keyFrame) {
          keyFrame = new Keyframe();
          keyFrame.time = this.time;
          keyFrame.tangentMode = this.tangentMode;
          keyFrame.weightedMode = this.weightedMode;
          this.propertyKeyFrame[k] = keyFrame;
        }
        return keyFrame;
      }
      formBytes(bytes) {
        this.time = bytes.readFloat32();
        {
          let { t, v } = ValueParser.parser(bytes);
          this.split(t, v, "value");
        }
        {
          let { t, v } = ValueParser.parser(bytes);
          this.split(t, v, "inSlope");
        }
        {
          let { t, v } = ValueParser.parser(bytes);
          this.split(t, v, "outSlope");
        }
        this.tangentMode = bytes.readInt32();
        this.weightedMode = bytes.readInt32();
        {
          let { t, v } = ValueParser.parser(bytes);
          this.split(t, v, "inWeight");
        }
        {
          let { t, v } = ValueParser.parser(bytes);
          this.split(t, v, "outWeight");
        }
      }
    }

    class ValueOp {
      static sub(v1, v2) {
        let t = v1.constructor.name;
        switch (t) {
          case `number`:
            return v1 - v2;
          case "Vector2": {
            let vv1 = v1;
            let vv2 = v2;
            return new Vector2(vv1.x - vv2.x, vv1.y - vv2.y);
          }
          case "Vector3": {
            let vv1 = v1;
            let vv2 = v2;
            return new Vector3(vv1.x - vv2.x, vv1.y - vv2.y, vv1.z - vv2.z);
          }
          case "Vector4": {
            let vv1 = v1;
            let vv2 = v2;
            return new Vector4(vv1.x - vv2.x, vv1.y - vv2.y, vv1.z - vv2.z, vv1.w - vv2.w);
          }
          case "Quaternion": {
            let vv1 = v1;
            let vv2 = v2;
            return new Quaternion(vv1.x - vv2.x, vv1.y - vv2.y, vv1.z - vv2.z, vv1.w - vv2.w);
          }
        }
      }
    }

    class DoubleArray {
      _keys = new Array();
      _values = new Array();
      getIndexByKey(key) {
        return this._keys.indexOf(key);
      }
      getValueByKey(key) {
        var index = this.getIndexByKey(key);
        if (index > -1) {
          return this._values[index];
        }
        return null;
      }
      put(key, value) {
        if (key == null)
          return null;
        var old = this.remove(key);
        this._keys.push(key);
        this._values.push(value);
        return old;
      }
      remove(key) {
        var index = this._keys.indexOf(key);
        var item;
        if (index > -1) {
          item = this._values[index];
          this._keys.splice(index, 1);
          this._values.splice(index, 1);
        }
        return item;
      }
      getValues() {
        return this._values;
      }
      getKeys() {
        return this._keys;
      }
      clear() {
        this._values.length = 0;
        this._keys.length = 0;
      }
    }

    class Navi3DMaskType {
      static WalkAble = 1;
    }

    class Navi3DConst {
      static SetConst(epsilon) {
        this.EPSILON = epsilon;
        this.POWER_EPSILON = epsilon * epsilon;
      }
      static EPSILON = 0.1;
      static POWER_EPSILON = this.EPSILON * this.EPSILON;
    }

    class Navi3DPoint extends Vector3 {
      static CALC_VECTOR3D1 = new Vector3();
      static CALC_VECTOR3D2 = new Vector3();
      static CALC_VECTOR3D3 = new Vector3();
      static CALC_VECTOR3D4 = new Vector3();
      static CALC_VECTOR3D5 = new Vector3();
      _pointId = 0;
      constructor(id, X, Y, Z) {
        super(X, Y, Z, 0);
        this._pointId = id;
      }
      get id() {
        return this._pointId;
      }
      static equalPoint(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z) < Navi3DConst.POWER_EPSILON;
      }
      static calcDistance(pt1, pt2) {
        Navi3DPoint.CALC_VECTOR3D3.setTo(pt1.x - pt2.x, pt1.y - pt2.y, pt1.z - pt2.z);
        return Navi3DPoint.CALC_VECTOR3D3.length;
      }
    }

    class Navi3DAstar {
      _openedList;
      _closedList;
      _endNode;
      _startNode;
      _triangleChannel;
      _navMesh;
      _findIndex = 0;
      constructor() {
        this._openedList = new Array();
        this._closedList = new Array();
      }
      findPath(navMesh, startTriangle, endTriangle) {
        this._findIndex++;
        this._navMesh = navMesh;
        this._startNode = startTriangle;
        this._endNode = endTriangle;
        this._openedList.length = 0;
        this._closedList.length = 0;
        if (this._startNode && this._endNode) {
          this._startNode.gg = 0;
          this._startNode.h = 0;
          this._startNode.f = 0;
          this._startNode.parent = null;
          return this.search();
        }
        return false;
      }
      search() {
        var node = this._startNode;
        var neibours = [];
        var test;
        while (node != this._endNode) {
          neibours = node.getNeibourTriangles(neibours, Navi3DMaskType.WalkAble, Navi3DMaskType.WalkAble);
          for (test of neibours) {
            if (test.closeId == this._findIndex)
              continue;
            if (test == node || !test.walkAble) {
              continue;
            }
            var g = node.gg + Navi3DPoint.calcDistance(test, node) * test.costMultiplier;
            var h = Navi3DPoint.calcDistance(test, this._endNode);
            var f = g + h;
            if (test.openId == this._findIndex) {
              if (test.f > f) {
                test.f = f;
                test.gg = g;
                test.h = h;
                test.parent = node;
              }
            } else {
              test.f = f;
              test.gg = g;
              test.h = h;
              test.parent = node;
              test.openId = this._findIndex;
              this._openedList.push(test);
            }
          }
          node.closeId = this._findIndex;
          this._closedList.push(node);
          if (this._openedList.length == 0) {
            return false;
          }
          this._openedList.sort(function(a, b) {
            return a.f - b.f;
          });
          node = this._openedList.shift();
        }
        this.buildPath();
        return true;
      }
      buildPath() {
        this._triangleChannel = [];
        var node = this._endNode;
        this._triangleChannel.push(node);
        while (node != this._startNode) {
          node = node.parent;
          this._triangleChannel.unshift(node);
        }
      }
      get channel() {
        return this._triangleChannel;
      }
    }

    class Navi3DPointFat extends Navi3DPoint {
      _ownerPoint;
      _ownerEdge;
      radius = 0;
      constructor(_point, _edge) {
        super(_point.id, 0, 0, 0);
        this._ownerEdge = _edge;
        this._ownerPoint = _point;
      }
      get ownerPoint() {
        return this._ownerPoint;
      }
      get ownerEdge() {
        return this._ownerEdge;
      }
      scalePoint(value = 0.7) {
        var point = new Navi3DPointFat(this._ownerPoint, this._ownerEdge);
        point.copyFrom(this);
        point.decrementBy(this._ownerPoint);
        point.scaleBy(value);
        point.radius = point.length;
        point.incrementBy(this._ownerPoint);
        return point;
      }
    }

    class Navi3DEdge {
      _edgeMask = 0;
      _edgeSize = 0;
      _pointA;
      _pointB;
      _triangleOwners;
      _centerPoint;
      _edgeDirA2B;
      crossPoint;
      fatPointA;
      fatPointB;
      static CALC_FAT_VECTOR = new Vector3();
      constructor(point0, point1) {
        this._pointA = point0;
        this._pointB = point1;
        if (point0.id >= point1.id) {
          throw new Error("edge point order error!!!");
        }
        this._triangleOwners = new Array();
        this._centerPoint = new Vector3();
        this._edgeMask = Navi3DMaskType.WalkAble;
        Navi3DPoint.CALC_VECTOR3D1.setTo(point0.x - point1.x, point0.y - point1.y, point0.z - point1.z);
        this._edgeSize = Navi3DPoint.CALC_VECTOR3D1.length;
        this._centerPoint.setTo((point0.x + point1.x) / 2, (point0.y + point1.y) / 2, (point0.z + point1.z) / 2);
      }
      get size() {
        return this._edgeSize;
      }
      get triangleOwners() {
        return this._triangleOwners;
      }
      get centerPoint() {
        return this._centerPoint;
      }
      initFatPoints(radius) {
        this._edgeDirA2B = this._pointB.subtract(this._pointA);
        this._edgeDirA2B.normalize();
        this.fatPointA = this.fatPointA || new Navi3DPointFat(this._pointA, this);
        this.fatPointB = this.fatPointB || new Navi3DPointFat(this._pointB, this);
        if (this.fatPointA.radius != radius) {
          Navi3DEdge.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B);
          Navi3DEdge.CALC_FAT_VECTOR.scaleBy(radius);
          Navi3DEdge.CALC_FAT_VECTOR.incrementBy(this._pointA);
          this.fatPointA.copyFrom(Navi3DEdge.CALC_FAT_VECTOR);
          this.fatPointA.radius = radius;
        }
        if (this.fatPointB.radius != radius) {
          Navi3DEdge.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B);
          Navi3DEdge.CALC_FAT_VECTOR.scaleBy(-radius);
          Navi3DEdge.CALC_FAT_VECTOR.incrementBy(this._pointB);
          this.fatPointB.copyFrom(Navi3DEdge.CALC_FAT_VECTOR);
          this.fatPointB.radius = radius;
        }
      }
      getFatPoint(pt) {
        if (pt == this._pointA)
          return this.fatPointA;
        return this.fatPointB;
      }
      getAnotherFatPoint(pt) {
        if (pt == this._pointA)
          return this.fatPointB;
        return this.fatPointA;
      }
      getAnotherPoint(pt) {
        if (pt == this._pointA)
          return this._pointB;
        return this._pointA;
      }
      containsPoint(pt) {
        if (Navi3DPoint.equalPoint(pt, this._pointA))
          return this._pointA;
        if (Navi3DPoint.equalPoint(pt, this._pointB))
          return this._pointB;
        return null;
      }
      addTriangleOwners(triangle) {
        if (triangle.edges.indexOf(this) == -1) {
          throw new Error("the edge is not belong triangle!!!");
        }
        if (this._triangleOwners.indexOf(triangle) == -1) {
          this._triangleOwners.push(triangle);
        }
      }
      getPublicPoint(edge) {
        if (this._pointA == edge._pointA || this._pointA == edge._pointB) {
          return this._pointA;
        } else if (this._pointB == edge._pointA || this._pointB == edge._pointB) {
          return this._pointB;
        }
        return null;
      }
      getEqualPoint(p) {
        if (Navi3DPoint.equalPoint(p, this._pointA))
          return this._pointA;
        if (Navi3DPoint.equalPoint(p, this._pointB))
          return this._pointB;
        return null;
      }
      get pointA() {
        return this._pointA;
      }
      get pointB() {
        return this._pointB;
      }
      get walkAble() {
        return (this._edgeMask & Navi3DMaskType.WalkAble) == Navi3DMaskType.WalkAble;
      }
      testMask(value) {
        return (this._edgeMask & value) == value;
      }
    }

    class Navi3DRouter {
      endPoint;
      curPoint;
      rayA;
      rayB;
      rayAPoint;
      rayBPoint;
      static RAY_1 = new Vector3();
      static RAY_2 = new Vector3();
      static TEST_RAY = new Vector3();
      static TEST_RAY_1 = new Vector3();
      static TEST_RAY_2 = new Vector3();
      static CALC_CROSS_POINT = new Vector3();
      static CALC_CROSS_TEST = new Vector3();
      cornerPoint;
      cornerEdge;
      continuePass(fromPt, endPt, fromEdge) {
        this.resetData();
        this.curPoint = fromPt;
        this.endPoint = endPt;
        this.cornerEdge = fromEdge;
      }
      passEdge(commonEdge, nextCommonEdge, targetPoint, lastEdge) {
        if (this.rayA == null || this.rayB == null) {
          this.rayA = Navi3DRouter.RAY_1;
          this.rayB = Navi3DRouter.RAY_2;
          this.rayAPoint = commonEdge.pointA;
          this.rayBPoint = commonEdge.pointB;
          this.rayA.setTo(this.rayAPoint.x - this.curPoint.x, 0, this.rayAPoint.z - this.curPoint.z);
          this.rayB.setTo(this.rayBPoint.x - this.curPoint.x, 0, this.rayBPoint.z - this.curPoint.z);
        }
        if (lastEdge) {
          return this.checkEndPoint(targetPoint);
        }
        Navi3DRouter.TEST_RAY.setTo(targetPoint.x - this.curPoint.x, 0, targetPoint.z - this.curPoint.z);
        if (this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) {
          if (!this.hasCrossPoint(nextCommonEdge.pointA, nextCommonEdge.pointB, this.rayAPoint, this.rayA)) {
            this.rayA.copyFrom(Navi3DRouter.TEST_RAY);
            if (targetPoint instanceof Navi3DPoint) {
              this.rayAPoint = targetPoint;
            } else {
              this.rayAPoint = null;
            }
          } else {
            this.rayB.copyFrom(Navi3DRouter.TEST_RAY);
            if (targetPoint instanceof Navi3DPoint) {
              this.rayBPoint = targetPoint;
            } else {
              this.rayBPoint = null;
            }
          }
          var anotherPoint = nextCommonEdge.getAnotherPoint(targetPoint);
          Navi3DRouter.TEST_RAY.setTo(anotherPoint.x - this.curPoint.x, 0, anotherPoint.z - this.curPoint.z);
          if (anotherPoint == this.rayAPoint || anotherPoint == this.rayBPoint || this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) {
            this.cornerEdge = nextCommonEdge;
          }
        } else {
          var needReturn;
          Navi3DRouter.TEST_RAY_1.copyFrom(nextCommonEdge.pointA);
          Navi3DRouter.TEST_RAY_1.decrementBy(this.curPoint);
          Navi3DRouter.TEST_RAY_2.copyFrom(nextCommonEdge.pointB);
          Navi3DRouter.TEST_RAY_2.decrementBy(this.curPoint);
          Navi3DRouter.TEST_RAY_1.y = 0;
          Navi3DRouter.TEST_RAY_2.y = 0;
          if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY_1, Navi3DRouter.TEST_RAY_2) || this.isPointAtCenter(this.rayB, Navi3DRouter.TEST_RAY_1, Navi3DRouter.TEST_RAY_2)) {
            needReturn = false;
          } else {
            needReturn = true;
          }
          if (needReturn) {
            if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY, this.rayB)) {
              this.cornerPoint = this.rayAPoint;
            } else {
              this.cornerPoint = this.rayBPoint;
            }
            this.cornerEdge.crossPoint = this.cornerPoint;
            return false;
          }
        }
        return true;
      }
      checkEndPoint(targetPoint) {
        Navi3DRouter.TEST_RAY.setTo(targetPoint.x - this.curPoint.x, 0, targetPoint.z - this.curPoint.z);
        if (this.isPointAtCenter(Navi3DRouter.TEST_RAY, this.rayA, this.rayB)) ; else {
          if (this.isPointAtCenter(this.rayA, Navi3DRouter.TEST_RAY, this.rayB)) {
            this.cornerPoint = this.rayAPoint;
          } else {
            this.cornerPoint = this.rayBPoint;
          }
          this.cornerEdge.crossPoint = this.cornerPoint;
          return false;
        }
        return true;
      }
      calcCrossEdge(_edge, linePoint, lineDirection) {
        return this.calcCrossPoint(_edge.fatPointA, _edge.fatPointB, linePoint, lineDirection);
      }
      calcCrossPoint(segmentPt1, segmentPt2, linePoint, lineDirection) {
        Navi3DRouter.CALC_CROSS_POINT.copyFrom(segmentPt2);
        Navi3DRouter.CALC_CROSS_POINT.decrementBy(segmentPt1);
        let distance = Navi3DRouter.CALC_CROSS_POINT.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_POINT.z;
        var scale = 0;
        if (distance != 0) {
          scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) / distance;
        }
        if (scale > 1) {
          scale = 1;
        } else if (scale < 0) {
          scale = 0;
        }
        Navi3DRouter.CALC_CROSS_POINT.scaleBy(scale);
        Navi3DRouter.CALC_CROSS_POINT.incrementBy(segmentPt1);
        return Navi3DRouter.CALC_CROSS_POINT.clone();
      }
      calcCrossPointOut(segmentPt1, segmentPt2, linePoint, lineDirection) {
        Navi3DRouter.CALC_CROSS_POINT.copyFrom(segmentPt2);
        Navi3DRouter.CALC_CROSS_POINT.decrementBy(segmentPt1);
        var scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) / (Navi3DRouter.CALC_CROSS_POINT.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_POINT.z);
        if (scale <= 1 && scale >= 0) {
          return null;
        }
        Navi3DRouter.CALC_CROSS_POINT.scaleBy(scale);
        Navi3DRouter.CALC_CROSS_POINT.incrementBy(segmentPt1);
        return Navi3DRouter.CALC_CROSS_POINT.clone();
      }
      hasCrossPoint(segmentPt1, segmentPt2, linePoint, lineDirection) {
        Navi3DRouter.CALC_CROSS_TEST.copyFrom(segmentPt2);
        Navi3DRouter.CALC_CROSS_TEST.decrementBy(segmentPt1);
        var scale = ((segmentPt1.z - linePoint.z) * lineDirection.x - (segmentPt1.x - linePoint.x) * lineDirection.z) / (Navi3DRouter.CALC_CROSS_TEST.x * lineDirection.z - lineDirection.x * Navi3DRouter.CALC_CROSS_TEST.z);
        return scale <= 1 && scale >= 0;
      }
      isPointAtCenter(point, vectorA, vectorB) {
        var cp1 = vectorA.crossProduct(point);
        if (cp1.length == 0 && point.length < vectorA.length) {
          return true;
        }
        var cp2 = vectorB.crossProduct(point);
        if (cp2.length == 0 && point.length < vectorB.length) {
          return true;
        }
        cp1.normalize();
        cp2.normalize();
        cp1.incrementBy(cp2);
        return cp1.length < 0.01;
      }
      resetData() {
        this.cornerEdge = null;
        this.cornerPoint = null;
        this.curPoint = null;
        this.rayA = this.rayB = null;
        this.rayAPoint = this.rayBPoint = null;
        Navi3DRouter.RAY_1.setTo(0, 0, 0);
        Navi3DRouter.RAY_2.setTo(0, 0, 0);
      }
    }

    class Navi3DFunnel {
      _aiRadius = 0;
      _router;
      _result;
      _tempPublicEdgeList = new Array();
      _tempSamePlaneList = new Array();
      static CROSS_TEST_DIRECTION = new Vector3();
      constructor() {
        this._router = new Navi3DRouter();
      }
      searchPath(startPt, endPt, triangleList, radius = 0) {
        if (radius <= 0)
          radius = 1;
        this._aiRadius = radius * 1.5;
        if (!this.searchEnable(startPt, endPt, triangleList))
          return false;
        this.search(startPt, endPt, triangleList);
        return true;
      }
      get path() {
        return this._result;
      }
      searchEnable(startPt, endPt, triangleList) {
        if (startPt == null || endPt == null || triangleList == null)
          return false;
        if (triangleList[0].plane.classifyPoint(startPt, Navi3DConst.EPSILON) != PlaneClassification.INTERSECT) {
          return false;
        }
        if (triangleList[triangleList.length - 1].plane.classifyPoint(endPt, Navi3DConst.EPSILON) != PlaneClassification.INTERSECT) {
          return false;
        }
        return true;
      }
      search(startPt, endPt, triangleList) {
        this._tempPublicEdgeList.length = 0;
        this._tempSamePlaneList.length = 0;
        var i = 0;
        var crossedEdgeCount = triangleList.length - 1;
        var tr;
        var curEdge;
        var pt;
        var plane;
        for (i = 0; i < crossedEdgeCount; i++) {
          curEdge = triangleList[i].getPublicEdge(triangleList[i + 1]);
          curEdge.crossPoint = null;
          curEdge.initFatPoints(this._aiRadius);
          this._tempPublicEdgeList.push(curEdge);
          tr = triangleList[i];
          plane = tr.plane;
          tr = triangleList[i + 1];
          pt = tr.getEdgeAgainstPoint(curEdge);
          this._tempSamePlaneList.push(plane.classifyPoint(pt, Navi3DConst.EPSILON) == PlaneClassification.INTERSECT);
        }
        this._router.continuePass(startPt, endPt, this._tempPublicEdgeList[0]);
        crossedEdgeCount = this._tempPublicEdgeList.length;
        var cornerPoint;
        var cornerEdge;
        var continuePass;
        var lastEdge;
        for (i = 0; i < crossedEdgeCount; i++) {
          curEdge = this._tempPublicEdgeList[i];
          tr = triangleList[i + 1];
          lastEdge = i == crossedEdgeCount - 1;
          if (lastEdge) {
            pt = endPt;
          } else {
            pt = tr.getEdgeAgainstPoint(curEdge);
          }
          continuePass = this._router.passEdge(curEdge, this._tempPublicEdgeList[i + 1], pt, lastEdge);
          if (!continuePass) {
            cornerPoint = this._router.cornerPoint;
            cornerEdge = this._router.cornerEdge;
            i = this._tempPublicEdgeList.indexOf(cornerEdge);
            this._router.continuePass(cornerPoint, endPt, this._tempPublicEdgeList[i + 1]);
          }
        }
        this.pushAllPathPoint2(startPt, endPt);
        if (this._result.length >= 3) {
          this.optimusTerminusFat();
          this.optimusByRadius();
        }
        let list = [];
        for (let point of this._result) {
          list.push(new Vector3().copyFrom(point));
        }
        this._result = list;
      }
      optimusTerminusFat() {
        var startFat;
        var endFat;
        var pt;
        pt = this._result[1];
        if (pt instanceof Navi3DPointFat) {
          startFat = pt;
        }
        pt = this._result[this._result.length - 2];
        if (pt instanceof Navi3DPointFat) {
          endFat = pt;
        }
        if (startFat) {
          this._result[1] = startFat.scalePoint();
        }
        if (endFat && startFat != endFat) {
          this._result[this._result.length - 2] = endFat.scalePoint();
        }
      }
      pushAllPathPoint2(startPt, endPt) {
        var crossedEdgeCount = this._tempPublicEdgeList.length;
        var curEdge;
        var curEdgeJ;
        this._result = new Array();
        this._result.push(startPt);
        var fromPoint = startPt;
        var toPoint;
        var fatPoint;
        var crossPoint;
        for (var i = 0; i < crossedEdgeCount; i++) {
          curEdge = this._tempPublicEdgeList[i];
          fatPoint = null;
          if (curEdge.crossPoint) {
            fatPoint = this.getFatPoint(curEdge, curEdge.crossPoint);
            if (fatPoint) {
              this._result.push(fatPoint);
            } else {
              this._result.push(curEdge.crossPoint);
            }
            fromPoint = curEdge.crossPoint;
          } else {
            curEdgeJ = null;
            toPoint = null;
            for (var j = i + 1; j < crossedEdgeCount; j++) {
              curEdgeJ = this._tempPublicEdgeList[j];
              toPoint = curEdgeJ.crossPoint;
              if (toPoint) {
                break;
              }
            }
            if (toPoint == null) {
              toPoint = endPt;
            }
            fatPoint = this.getFatPoint(curEdge, toPoint);
            if (fatPoint) {
              this._result.push(fatPoint);
            } else {
              if (toPoint == fromPoint) {
                crossPoint = toPoint.clone();
              } else {
                Navi3DFunnel.CROSS_TEST_DIRECTION.setTo(toPoint.x - fromPoint.x, 0, toPoint.z - fromPoint.z);
                crossPoint = this._router.calcCrossEdge(curEdge, fromPoint, Navi3DFunnel.CROSS_TEST_DIRECTION);
              }
              this._result.push(crossPoint);
            }
          }
        }
        this._result.push(endPt);
      }
      optimusByRadius() {
        var optimusResult = new Array();
        optimusResult.length = this._result.length;
        var count = this._result.length - 2;
        var pt0;
        var pt1;
        var pt2;
        var fatPt0;
        var fatPt1;
        var fatPt2;
        var edgePt0;
        var edgePt1;
        var edgePt2;
        var centerEdge;
        var checkEnable;
        var optimusPoint;
        var i;
        for (i = 0; i < count; i++) {
          edgePt0 = edgePt1 = edgePt2 = null;
          fatPt0 = fatPt1 = fatPt2 = null;
          checkEnable = false;
          optimusPoint = null;
          pt0 = this._result[i];
          pt1 = this._result[i + 1];
          pt2 = this._result[i + 2];
          if (pt0 instanceof Navi3DPointFat) {
            fatPt0 = pt0;
          }
          if (pt1 instanceof Navi3DPointFat) {
            fatPt1 = pt1;
          }
          if (pt2 instanceof Navi3DPointFat) {
            fatPt2 = pt2;
          }
          if (fatPt0) {
            edgePt0 = fatPt0.ownerPoint;
          }
          if (fatPt1) {
            edgePt1 = fatPt1.ownerPoint;
          }
          if (fatPt2) {
            edgePt2 = fatPt2.ownerPoint;
          }
          if (edgePt0 && edgePt1 && edgePt0 == edgePt1 && edgePt1 != edgePt2) {
            checkEnable = true;
          }
          if (edgePt2 && edgePt1 && edgePt2 == edgePt1 && edgePt0 != edgePt1) {
            checkEnable = true;
          }
          if (checkEnable) {
            Navi3DFunnel.CROSS_TEST_DIRECTION.copyFrom(pt0);
            Navi3DFunnel.CROSS_TEST_DIRECTION.decrementBy(pt2);
            centerEdge = fatPt1.ownerEdge;
            checkEnable = this._router.hasCrossPoint(centerEdge.pointA, centerEdge.pointB, pt2, Navi3DFunnel.CROSS_TEST_DIRECTION);
            if (checkEnable) {
              optimusPoint = this._router.calcCrossPointOut(edgePt1, pt1, pt2, Navi3DFunnel.CROSS_TEST_DIRECTION);
            }
            if (optimusPoint) {
              optimusResult[i + 1] = optimusPoint;
            }
          }
        }
      }
      getFatPoint(edge, target) {
        if (edge == null)
          return null;
        var fatPoint;
        if (target instanceof Navi3DPointFat) {
          fatPoint = target;
        }
        var edgePoint;
        if (fatPoint) {
          edgePoint = fatPoint.ownerPoint;
        } else {
          edgePoint = edge.getEqualPoint(target);
        }
        if (edgePoint == null)
          return null;
        fatPoint = edge.getFatPoint(edgePoint);
        return fatPoint;
      }
    }

    class Navi3DMergeVertex {
      vertex;
      indices;
      merge(geometry, threshould = 0.1) {
        let vertex = geometry.getAttribute(VertexAttributeName.position).data;
        this.makeOriginVertex(vertex);
        let sameVertexIndex = /* @__PURE__ */ new Map();
        let redirectionIndex = [];
        let mergePointCount = 0;
        for (let i = 0, c = this.vertex.length; i < c; i++) {
          let item = this.vertex[i];
          let samePointIndex = -1;
          sameVertexIndex.forEach((v, i2) => {
            let distance = Vector3.distance(v, item);
            if (distance < threshould) {
              samePointIndex = i2;
            }
          });
          if (samePointIndex > -1) {
            redirectionIndex[i] = samePointIndex;
            mergePointCount++;
          } else {
            sameVertexIndex.set(i, item);
            redirectionIndex[i] = i;
          }
        }
        console.log("mergePointCount：", mergePointCount);
        this.indices = [];
        let indices = geometry.getAttribute(VertexAttributeName.indices).data;
        for (const i of indices) {
          this.indices.push(redirectionIndex[i]);
        }
        return this;
      }
      parse(geometry) {
        let vertex = geometry.getAttribute(VertexAttributeName.position).data;
        this.makeOriginVertex(vertex);
        this.indices = [];
        let indices = geometry.getAttribute(VertexAttributeName.indices).data;
        for (const i of indices) {
          this.indices.push(i);
        }
        return this;
      }
      makeOriginVertex(source) {
        this.vertex = [];
        for (let i = 0, c = source.length / 3; i < c; i++) {
          let v = new Vector3(source[i * 3], source[i * 3 + 1], source[i * 3 + 2]);
          this.vertex.push(v);
        }
      }
    }

    class Navi3DTriangle extends Vector3 {
      _id = 0;
      _plane;
      _points = new Array();
      _edges = new Array();
      _neibourTriangles = new DoubleArray();
      _pointAgainstEdge = new DoubleArray();
      _edgeAgainstPoint = new DoubleArray();
      _mask = 0;
      _aabbBox;
      f = 0;
      gg = 0;
      h = 0;
      parent;
      costMultiplier = 1;
      openId = 0;
      closeId = 0;
      get aabb() {
        return this._aabbBox;
      }
      initAABB() {
        this._aabbBox = new QuadAABB();
        this._aabbBox.addPoint(this._points[0]);
        this._aabbBox.addPoint(this._points[1]);
        this._aabbBox.addPoint(this._points[2]);
      }
      calcGlobalQuadAABB() {
      }
      get isTriangle() {
        return true;
      }
      constructor(Id, edgeA, edgeB, edgeC) {
        super(0, 0, 0, 0);
        this._id = Id;
        this._mask = Navi3DMaskType.WalkAble;
        this._edges.push(edgeA, edgeB, edgeC);
        var edge;
        for (edge of this._edges) {
          if (this._points.indexOf(edge.pointA) == -1) {
            this._points.push(edge.pointA);
          }
          if (this._points.indexOf(edge.pointB) == -1) {
            this._points.push(edge.pointB);
          }
        }
        this.x = (this._points[0].x + this._points[1].x + this._points[2].x) / 3;
        this.y = (this._points[0].y + this._points[1].y + this._points[2].y) / 3;
        this.z = (this._points[0].z + this._points[1].z + this._points[2].z) / 3;
        this._plane = new Plane3D();
        this._plane.fromPoints(this._points[0], this._points[1], this._points[2]);
        this._plane.normalize();
        this.genarateAgainstData();
        this.initAABB();
      }
      genarateAgainstData() {
        var edge;
        var point;
        for (edge of this._edges) {
          for (point of this._points) {
            if (edge.pointA != point && edge.pointB != point) {
              this._edgeAgainstPoint.put(edge, point);
              this._pointAgainstEdge.put(point, edge);
            }
          }
        }
      }
      get id() {
        return this._id;
      }
      get plane() {
        return this._plane;
      }
      get points() {
        return this._points;
      }
      addNeibour(edge, triangle) {
        if (this._edges.indexOf(edge) >= 0) {
          this._neibourTriangles.put(edge, triangle);
        } else {
          throw new Error("the edge is not in triangle!!!");
        }
      }
      getNeibourTriangles(list = null, edgeMask = 1, triangleMask = 1) {
        list = list || new Array();
        list.length = 0;
        var neibour;
        var edge;
        var keys = this._neibourTriangles.getKeys();
        var obj;
        for (obj of keys) {
          edge = obj;
          if (edge.testMask(edgeMask)) {
            neibour = this._neibourTriangles.getValueByKey(edge);
            if (neibour.testMask(triangleMask)) {
              list.push(neibour);
            }
          }
        }
        return list;
      }
      getEdges(list = null, edgeMask = 1) {
        list = list || new Array();
        list.length = 0;
        var edge;
        for (edge of this._edges) {
          if (edge.testMask(edgeMask)) {
            list.push(edge);
          }
        }
        return list;
      }
      get walkAble() {
        return this.testMask(Navi3DMaskType.WalkAble);
      }
      get edges() {
        return this._edges;
      }
      testMask(value) {
        return (this._mask & value) == value;
      }
      getEdgeAgainstPoint(edge) {
        return this._edgeAgainstPoint.getValueByKey(edge);
      }
      getPointAgainstEdge(point) {
        return this._pointAgainstEdge.getValueByKey(point);
      }
      getPublicEdge(triangle) {
        if (triangle && triangle != this) {
          var keys = this._neibourTriangles.getKeys();
          var obj;
          for (obj of keys) {
            if (this._neibourTriangles.getValueByKey(obj) == triangle)
              return obj;
          }
        }
        return null;
      }
      loopPublicEdge(triangle) {
        var edgeA;
        var edgeB;
        if (triangle && triangle != this) {
          for (edgeA of this._edges) {
            for (edgeB of triangle._edges) {
              if (edgeA == edgeB)
                return edgeA;
            }
          }
        }
        return null;
      }
      randomPoint() {
        var pt0 = this._points[2].subtract(this._points[0]);
        {
          pt0.scaleBy(Math.random());
        }
        pt0.incrementBy(this._points[0]);
        var pt1 = this._points[1].subtract(pt0);
        {
          pt1.scaleBy(Math.random());
        }
        pt1.incrementBy(pt0);
        return pt1;
      }
    }

    class Navi3DMesh {
      _nav3dPoints;
      _nav3dEdges;
      _nav3dTriangles;
      _path;
      _edgesDict;
      _nav3dAstar;
      _nav3dFunnel;
      _terrainQuad;
      _triangleList;
      get edges() {
        return this._nav3dEdges;
      }
      get points() {
        return this._nav3dPoints;
      }
      get path() {
        return this._path;
      }
      get triangles() {
        return this._nav3dTriangles;
      }
      constructor(pointList, triangleIndexList) {
        this._nav3dPoints = new Array();
        this._nav3dEdges = new Array();
        this._nav3dTriangles = new Array();
        this._edgesDict = new DoubleArray();
        this.initPoints(pointList);
        this.initEdgesAndTriangles(triangleIndexList);
        this.createConnections();
        this._nav3dAstar = new Navi3DAstar();
        this._nav3dFunnel = new Navi3DFunnel();
        this._terrainQuad = new QuadRoot(8, 128);
        this._terrainQuad.createQuadTree(this._nav3dTriangles);
      }
      getTriangleAtPoint(point, threshold = 5) {
        return this._terrainQuad.getTriangleAtPoint(point, threshold);
      }
      findPath(startPt, endPt, aiRadius = 5) {
        this._path = null;
        this._triangleList = null;
        var startNode = this.getTriangleAtPoint(startPt, 10);
        var endNode = this.getTriangleAtPoint(endPt, 10);
        var success = this._nav3dAstar.findPath(this, startNode, endNode);
        if (success) {
          this._triangleList = this._nav3dAstar.channel;
          success = this._nav3dFunnel.searchPath(startPt, endPt, this._triangleList, aiRadius);
          this._path = this._nav3dFunnel.path;
          return success;
        }
        return false;
      }
      initPoints(pointList) {
        var point;
        var nevPoint;
        var count = pointList.length;
        for (var i = 0; i < count; i++) {
          point = pointList[i];
          nevPoint = new Navi3DPoint(i, point.x, point.y, point.z);
          this._nav3dPoints.push(nevPoint);
        }
      }
      initEdgesAndTriangles(triangleIndexList) {
        var indexOrderList;
        var edge0;
        var edge1;
        var edge2;
        var triangle;
        var count = triangleIndexList.length;
        for (var i = 0; i < count; i++) {
          indexOrderList = triangleIndexList[i];
          edge0 = this.tryCreateEdge(indexOrderList[0], indexOrderList[1]);
          edge1 = this.tryCreateEdge(indexOrderList[1], indexOrderList[2]);
          edge2 = this.tryCreateEdge(indexOrderList[2], indexOrderList[0]);
          if (edge0 == null || edge1 == null || edge2 == null)
            continue;
          triangle = new Navi3DTriangle(i, edge0, edge1, edge2);
          this._nav3dTriangles.push(triangle);
        }
      }
      tryCreateEdge(pointAId, pointBId) {
        if (pointAId == pointBId) {
          throw new Error("edge point index error!!!");
        }
        if (pointAId > pointBId) {
          var tempId = pointAId;
          pointAId = pointBId;
          pointBId = tempId;
        }
        var edge = this._edgesDict.getValueByKey(pointAId + "_" + pointBId);
        if (edge == null) {
          edge = new Navi3DEdge(this._nav3dPoints[pointAId], this._nav3dPoints[pointBId]);
          this._nav3dEdges.push(edge);
          this._edgesDict.put(pointAId + "_" + pointBId, edge);
        }
        return edge;
      }
      createConnections() {
        var triangleACount = this._nav3dTriangles.length;
        var triangleBCount = this._nav3dTriangles.length;
        var triangleA;
        var triangleB;
        var edge;
        var publicEdge;
        for (var i = 0; i < triangleACount; i++) {
          triangleA = this._nav3dTriangles[i];
          for (edge of triangleA.edges) {
            edge.addTriangleOwners(triangleA);
          }
          for (var j = 0; j < triangleBCount; j++) {
            triangleB = this._nav3dTriangles[j];
            if (triangleA == triangleB)
              continue;
            publicEdge = triangleA.loopPublicEdge(triangleB);
            if (publicEdge) {
              triangleA.addNeibour(publicEdge, triangleB);
              triangleB.addNeibour(publicEdge, triangleA);
            }
          }
        }
      }
    }

    class Navi3DPoint2D {
      x;
      y;
      setTo(X, Y) {
        this.x = X;
        this.y = Y;
      }
      equals(X, Y) {
        return X == this.x && Y == this.y;
      }
      equalPoint(pt) {
        return this.equals(pt.x, pt.y);
      }
      get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      clone() {
        var point = new Navi3DPoint2D();
        point.setTo(this.x, this.y);
        return point;
      }
      normalize() {
        var size = length;
        if (size == 0)
          return;
        this.setTo(this.x / size, this.y / size);
      }
    }

    class BoxGeometry extends GeometryBase {
      /**
       * box width
       */
      width;
      /**
       * box height
       */
      height;
      /**
       * box depth
       */
      depth;
      /**
       *
       * @constructor
       * @param width {number} box width, default value is 1
       * @param height {number} box height, default value is 1
       * @param depth {number} box depth, default value is 1
       */
      constructor(width = 1, height = 1, depth = 1) {
        super();
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.initVertex();
      }
      initVertex() {
        let halfW = this.width / 2;
        let halfH = this.height / 2;
        let halfD = this.depth / 2;
        this.bounds = new BoundingBox(Vector3.ZERO.clone(), new Vector3(this.width, this.height, this.depth));
        let position_arr = new Float32Array([
          //up
          -halfW,
          halfH,
          halfD,
          halfW,
          halfH,
          halfD,
          halfW,
          halfH,
          -halfD,
          -halfW,
          halfH,
          -halfD,
          -halfW,
          halfH,
          halfD,
          halfW,
          halfH,
          -halfD,
          //buttom
          halfW,
          -halfH,
          halfD,
          -halfW,
          -halfH,
          halfD,
          -halfW,
          -halfH,
          -halfD,
          halfW,
          -halfH,
          -halfD,
          halfW,
          -halfH,
          halfD,
          -halfW,
          -halfH,
          -halfD,
          //left
          -halfW,
          -halfH,
          halfD,
          -halfW,
          halfH,
          halfD,
          -halfW,
          halfH,
          -halfD,
          -halfW,
          -halfH,
          -halfD,
          -halfW,
          -halfH,
          halfD,
          -halfW,
          halfH,
          -halfD,
          //right
          halfW,
          halfH,
          halfD,
          halfW,
          -halfH,
          halfD,
          halfW,
          -halfH,
          -halfD,
          halfW,
          halfH,
          -halfD,
          halfW,
          halfH,
          halfD,
          halfW,
          -halfH,
          -halfD,
          //front
          halfW,
          halfH,
          halfD,
          -halfW,
          halfH,
          halfD,
          -halfW,
          -halfH,
          halfD,
          -halfW,
          -halfH,
          halfD,
          halfW,
          -halfH,
          halfD,
          halfW,
          halfH,
          halfD,
          //back
          halfW,
          -halfH,
          -halfD,
          -halfW,
          -halfH,
          -halfD,
          -halfW,
          halfH,
          -halfD,
          halfW,
          halfH,
          -halfD,
          halfW,
          -halfH,
          -halfD,
          -halfW,
          halfH,
          -halfD
        ]);
        let normal_arr = new Float32Array([
          //up
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          //buttom
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          //left
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          //right
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          //front
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          0,
          0,
          1,
          //back
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1,
          0,
          0,
          -1
        ]);
        let uv_arr = new Float32Array([1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0]);
        let indices_arr = [0, 2, 1, 3, 5, 4, 6, 8, 7, 9, 11, 10, 12, 14, 13, 15, 17, 16, 18, 20, 19, 21, 23, 22, 24, 26, 25, 27, 29, 28, 30, 32, 31, 33, 35, 34];
        let indicesData = new Uint16Array(indices_arr.reverse());
        this.setIndices(indicesData);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
      }
    }

    class CylinderGeometry extends GeometryBase {
      /**
       * The radius of the top of the cylinder
       */
      radiusTop;
      /**
       * The radius of the bottom of the cylinder
       */
      radiusBottom;
      /**
       * The height of the cylinder
       */
      height;
      /**
       * Number of segments around the side of the cylinder
       */
      radialSegments;
      /**
       * The number of segments along the height of the cylindrical side
       */
      heightSegments;
      /**
       * Indicate whether the bottom surface of the cone is open or capped. The default value is false, which means that the bottom surface is capped by default.
       */
      openEnded;
      /**
       * Starting angle of the first segment
       */
      thetaStart;
      /**
       * The center angle of the circular sector on the bottom of the cylinder, with a default value of 2 * PI, makes it a complete cylinder.
       */
      thetaLength;
      /**
       *
       * @constructor
       * @param radiusTop 
       * @param radiusBottom 
       * @param height 
       * @param radialSegments 
       * @param heightSegments 
       * @param openEnded 
       * @param thetaStart 
       * @param thetaLength
       */
      constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 8, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.radiusTop = radiusTop;
        this.radiusBottom = radiusBottom;
        this.height = height;
        this.radialSegments = radialSegments;
        this.heightSegments = heightSegments;
        this.openEnded = openEnded;
        this.thetaStart = thetaStart;
        this.thetaLength = thetaLength;
        this.instanceID = UUID();
        this.buildGeometry();
      }
      /**
       * @internal
       * @param start 
       * @param count 
       * @param index 
       */
      addGroup(start, count, index) {
        this.addSubGeometry({
          indexStart: start,
          indexCount: count,
          vertexStart: start,
          vertexCount: 0,
          firstStart: 0,
          index,
          topology: 0
        });
      }
      buildGeometry() {
        const that = this;
        this.radialSegments = Math.floor(this.radialSegments);
        this.heightSegments = Math.floor(this.heightSegments);
        const vertices = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        let index = 0;
        const indexArray = [];
        const halfHeight = this.height / 2;
        let groupStart = 0;
        generateTorso();
        if (this.openEnded === false) {
          if (this.radiusTop > 0)
            generateCap(true);
          if (this.radiusBottom > 0)
            generateCap(false);
        }
        let position_arr = new Float32Array(vertices);
        let normal_arr = new Float32Array(normals);
        let uv_arr = new Float32Array(uvs);
        let indices_arr = new Uint16Array(indices);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.setIndices(indices_arr);
        function generateTorso() {
          const normal = new Vector3();
          const vertex = new Vector3();
          let groupCount = 0;
          const slope = (that.radiusBottom - that.radiusTop) / that.height;
          for (let y = 0; y <= that.heightSegments; y++) {
            const indexRow = [];
            const v = y / that.heightSegments;
            const radius = v * (that.radiusBottom - that.radiusTop) + that.radiusTop;
            for (let x = 0; x <= that.radialSegments; x++) {
              const u = x / that.radialSegments;
              const theta = u * that.thetaLength + that.thetaStart;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              vertex.x = radius * sinTheta;
              vertex.y = -v * that.height + halfHeight;
              vertex.z = radius * cosTheta;
              vertices.push(vertex.x, vertex.y, vertex.z);
              normal.set(sinTheta, slope, cosTheta).normalize();
              normals.push(normal.x, normal.y, normal.z);
              uvs.push(u, 1 - v);
              indexRow.push(index++);
            }
            indexArray.push(indexRow);
          }
          for (let x = 0; x < that.radialSegments; x++) {
            for (let y = 0; y < that.heightSegments; y++) {
              const a = indexArray[y][x];
              const b = indexArray[y + 1][x];
              const c = indexArray[y + 1][x + 1];
              const d = indexArray[y][x + 1];
              indices.push(a, b, d);
              indices.push(b, c, d);
              groupCount += 6;
            }
          }
          that.addGroup(groupStart, groupCount, 0);
          groupStart += groupCount;
        }
        function generateCap(top) {
          const centerIndexStart = index;
          const uv = new Vector2();
          const vertex = new Vector3();
          let groupCount = 0;
          const radius = top === true ? that.radiusTop : that.radiusBottom;
          const sign = top === true ? 1 : -1;
          for (let x = 1; x <= that.radialSegments; x++) {
            vertices.push(0, halfHeight * sign, 0);
            normals.push(0, sign, 0);
            uvs.push(0.5, 0.5);
            index++;
          }
          const centerIndexEnd = index;
          for (let x = 0; x <= that.radialSegments; x++) {
            const u = x / that.radialSegments;
            const theta = u * that.thetaLength + that.thetaStart;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            vertex.x = radius * sinTheta;
            vertex.y = halfHeight * sign;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, sign, 0);
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign + 0.5;
            uvs.push(uv.x, uv.y);
            index++;
          }
          for (let x = 0; x < that.radialSegments; x++) {
            const c = centerIndexStart + x;
            const i = centerIndexEnd + x;
            if (top === true) {
              indices.push(i, i + 1, c);
            } else {
              indices.push(i + 1, i, c);
            }
            groupCount += 3;
          }
          that.addGroup(groupStart, groupCount, top === true ? 1 : 2);
          groupStart += groupCount;
        }
      }
    }

    class StripeGeometry extends GeometryBase {
      segments;
      /**
       *
       * @constructor
       * @param width Width of the plane
       * @param height Height of the plane
       * @param segmentW Number of width segments of a plane
       * @param segmentH Number of height segments of a plane
       * @param up Define the normal vector of a plane
       */
      constructor(segments) {
        super();
        this.segments = segments;
        this.buildGeometry();
      }
      buildGeometry() {
        this.bounds = new BoundingBox();
        let numIndices = (this.segments.length - 1) * 2 * 3;
        let vertexCount = this.segments.length * 2;
        let position_arr = new Float32Array(vertexCount * 3);
        let normal_arr = new Float32Array(vertexCount * 3);
        let uv_arr = new Float32Array(vertexCount * 2);
        let indices_arr = new Uint16Array(numIndices);
        let index = 0;
        for (let item of this.segments) {
          position_arr[index++] = item[0].x;
          position_arr[index++] = item[0].y;
          position_arr[index++] = item[0].z;
          position_arr[index++] = item[1].x;
          position_arr[index++] = item[1].y;
          position_arr[index++] = item[1].z;
        }
        index = 0;
        let offset = 0;
        while (index < numIndices) {
          indices_arr[index++] = 2 + offset;
          indices_arr[index++] = 1 + offset;
          indices_arr[index++] = 0 + offset;
          indices_arr[index++] = 1 + offset;
          indices_arr[index++] = 2 + offset;
          indices_arr[index++] = 3 + offset;
          offset += 2;
        }
        this.setIndices(indices_arr);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indices_arr.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
        this.computeNormals();
      }
    }

    class TorusGeometry extends GeometryBase {
      /**
       * Radius of torus
       */
      radius;
      /**
       * Pipe radius
       */
      tube;
      /**
       * Number of torus segments.
       */
      radialSegments;
      /**
       * Number of pipeline segments.
       */
      tubularSegments;
      /**
       *
       * @constructor
       * @param radius {number} Radius of torus, default value is 0.4
       * @param tube {number} Pipe radius, default value is 0.1.
       * @param radialSegments {number}Number of torus segments, default value is 32.
       * @param tubularSegments {number} Number of pipeline segments, defualt value is 32.
       */
      constructor(radius = 0.4, tube = 0.1, radialSegments = 32, tubularSegments = 32) {
        super();
        this.radius = radius;
        this.tube = tube;
        this.radialSegments = radialSegments;
        this.tubularSegments = tubularSegments;
        this.initVertex();
      }
      initVertex() {
        const arc = 2 * Math.PI;
        const radius = this.radius;
        const tube = this.tube;
        const radialSegments = this.radialSegments;
        const tubularSegments = this.tubularSegments;
        this.bounds = new BoundingBox(Vector3.ZERO.clone(), new Vector3(radius * 2, tube * 2, radius * 2));
        var vertexCount = (radialSegments + 1) * (tubularSegments + 1);
        let position_arr = new Float32Array(vertexCount * 3);
        let normal_arr = new Float32Array(vertexCount * 3);
        let uv_arr = new Float32Array(vertexCount * 2);
        let indicesData = new Uint16Array(radialSegments * tubularSegments * 2 * 3);
        let pi = 0;
        let ni = 0;
        let ui = 0;
        let triIndex = 0;
        for (let j = 0; j <= radialSegments; j++) {
          for (let i = 0; i <= tubularSegments; i++) {
            const u = i / tubularSegments;
            const v = j / radialSegments;
            const u1 = u * arc;
            const v1 = v * Math.PI * 2;
            position_arr[pi++] = (radius + tube * Math.cos(v1)) * Math.sin(u1);
            position_arr[pi++] = tube * Math.sin(v1);
            position_arr[pi++] = (radius + tube * Math.cos(v1)) * Math.cos(u1);
            normal_arr[ni++] = Math.sin(u1) * Math.cos(v1);
            normal_arr[ni++] = Math.sin(v1);
            normal_arr[ni++] = Math.cos(u1) * Math.cos(v1);
            uv_arr[ui++] = u;
            uv_arr[ui++] = v;
            if (i < tubularSegments && j < radialSegments) {
              const segment = tubularSegments + 1;
              const a = segment * j + i;
              const b = segment * (j + 1) + i;
              const c = segment * (j + 1) + i + 1;
              const d = segment * j + i + 1;
              indicesData[triIndex++] = a;
              indicesData[triIndex++] = d;
              indicesData[triIndex++] = b;
              indicesData[triIndex++] = d;
              indicesData[triIndex++] = c;
              indicesData[triIndex++] = b;
            }
          }
        }
        this.setIndices(indicesData);
        this.setAttribute(VertexAttributeName.position, position_arr);
        this.setAttribute(VertexAttributeName.normal, normal_arr);
        this.setAttribute(VertexAttributeName.uv, uv_arr);
        this.setAttribute(VertexAttributeName.TEXCOORD_1, uv_arr);
        this.addSubGeometry({
          indexStart: 0,
          indexCount: indicesData.length,
          vertexStart: 0,
          vertexCount: 0,
          firstStart: 0,
          index: 0,
          topology: 0
        });
      }
    }

    class DepthCubeTexture extends Texture {
      /**
       * texture width, default value is 4
       */
      width = 4;
      /**
       * texture height, default value is 4
       */
      height = 4;
      /**
       * depth or array layers, default value is 6
       */
      depthOrArrayLayers = 6;
      /**
       * GPUShaderStage
       */
      visibility = GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE;
      /**
       * @constructor
       */
      constructor(width, height) {
        super(width, height, 6);
        this.format = GPUTextureFormat.depth24plus;
        this.mipmapCount = 1;
        this.init();
      }
      internalCreateBindingLayoutDesc() {
        this.samplerBindingLayout.type = `non-filtering`;
        this.textureBindingLayout.sampleType = `unfilterable-float`;
        this.textureBindingLayout.viewDimension = "cube";
      }
      internalCreateTexture() {
        this.textureDescriptor = {
          format: `depth24plus`,
          size: { width: this.width, height: this.height, depthOrArrayLayers: 6 },
          dimension: "2d",
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING
        };
        this.gpuTexture = this.getGPUTexture();
      }
      internalCreateView() {
        this.viewDescriptor = {
          dimension: `cube`
        };
        this.view = this.getGPUView();
      }
      internalCreateSampler() {
        this.gpuSampler = webGPUContext.device.createSampler({});
        this.gpuSampler_comparison = webGPUContext.device.createSampler({
          compare: "less",
          label: "sampler_comparison"
        });
      }
    }

    class Float16ArrayTexture extends Texture {
      uint16Array;
      floatArray;
      _dataBuffer;
      /**
       * fill this texture by array of numbers;the format as [red0, green0, blue0, alpha0, red1, green1, blue1, alpha1...]
       * @param width assign the texture width
       * @param height assign the texture height
       * @param numbers color of each pixel
       * @param useMipmap  whether or not gen mipmap
       * @returns
       */
      create(width, height, numbers = null, mipmap = true) {
        if (numbers == null) {
          numbers = [];
          for (let i = 0, c = width * height * 4; i < c; i++) {
            numbers[i] = 0;
          }
        }
        this.updateTexture(width, height, numbers, mipmap);
        return this;
      }
      /**
       * validate the change of this texture
       */
      updateTexture(width, height, numbers, mipmap = true) {
        if (width != this.width || height != this.height) {
          this._dataBuffer && this._dataBuffer.destroy();
          this._dataBuffer = null;
          this.gpuTexture && this.gpuTexture.destroy();
          this.gpuTexture = null;
        }
        this.floatArray = numbers;
        let device = webGPUContext.device;
        const bytesPerRow = width * 4 * 2;
        this.format = GPUTextureFormat.rgba16float;
        this.mipmapCount = Math.floor(mipmap ? Math.log2(width) : 1);
        this.createTextureDescriptor(width, height, this.mipmapCount, this.format);
        if (!this.uint16Array || this.uint16Array.length != numbers.length) {
          this.uint16Array = new Uint16Array(numbers.length);
        }
        let uint16Array = this.uint16Array;
        for (let i = 0, c = uint16Array.length; i < c; i++) {
          uint16Array[i] = toHalfFloat(numbers[i]);
        }
        const textureDataBuffer = this._dataBuffer = device.createBuffer({
          size: uint16Array.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, uint16Array);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        if (!this.useMipmap) {
          this.samplerBindingLayout.type = `filtering`;
          this.textureBindingLayout.sampleType = `float`;
        }
        GPUContext.endCommandEncoder(commandEncoder);
        this.gpuSampler = device.createSampler(this);
        this.gpuTexture = this.getGPUTexture();
        if (this.mipmapCount > 1)
          TextureMipmapGenerator.webGPUGenerateMipmap(this);
      }
    }

    class Float32ArrayTexture extends Texture {
      /**
       * fill this texture by array of numbers;the format as [red0, green0, blue0, alpha0, red1, green1, blue1, alpha1...]
       * @param width assign the texture width
       * @param height assign the texture height
       * @param data color of each pixel
       * @param filtering set the sampler type to filtering, else it's non-filtering
       * @returns
       */
      create(width, height, data, filtering = true) {
        let device = webGPUContext.device;
        const bytesPerRow = width * 4 * 4;
        this.format = GPUTextureFormat.rgba32float;
        let mipmapCount = 1;
        this.createTextureDescriptor(width, height, mipmapCount, this.format);
        const textureDataBuffer = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, data);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        if (filtering) {
          this.samplerBindingLayout.type = `non-filtering`;
          this.textureBindingLayout.sampleType = `unfilterable-float`;
        }
        this.gpuSampler = device.createSampler({});
      }
      /**
       * fill this texture GPUBuffer
       * @param width assign the texture width
       * @param height assign the texture height
       * @param textureDataBuffer GPUBuffer
       * @returns
       */
      fromBuffer(width, height, textureDataBuffer) {
        let device = webGPUContext.device;
        const bytesPerRow = width * 4 * 4;
        this.format = GPUTextureFormat.rgba32float;
        this.mipmapCount = 1;
        this.createTextureDescriptor(width, height, this.mipmapCount, this.format);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        this.samplerBindingLayout.type = `non-filtering`;
        this.textureBindingLayout.sampleType = `unfilterable-float`;
        this.gpuSampler = device.createSampler({});
        return this;
      }
    }

    class SolidColorSky extends LDRTextureCube {
      _internalTexture;
      _minSize = 32;
      _skyColor;
      /**
       * create a cube texture, which filled by solid color.
       * @param color solid color
       * @returns
       */
      constructor(color) {
        super();
        this._skyColor = color;
        this._internalTexture = new Float16ArrayTexture();
        let numbers = [];
        Engine3D.res.fillColor(numbers, this._minSize, this._minSize, this.color.r, this.color.g, this.color.b, this.color.a);
        this._internalTexture.create(this._minSize, this._minSize, numbers, false);
        this.createFromTexture(this._minSize, this._internalTexture);
        return this;
      }
      changeColor(color) {
        this._skyColor = color;
        Engine3D.res.fillColor(this._internalTexture.floatArray, this._minSize, this._minSize, this.color.r, this.color.g, this.color.b, this.color.a);
        this._internalTexture.updateTexture(this._minSize, this._minSize, this._internalTexture.floatArray, false);
        this._faceData.uploadTexture(0, this._internalTexture);
        return this;
      }
      get color() {
        return this._skyColor;
      }
      /**
       * change solid color
       * @param value target color
       * @returns
       */
      set color(value) {
        this.changeColor(value);
      }
    }

    class Uint16Texture extends Texture {
      /**
       * create texture by number array, which format is uint8
       * @param width width of texture
       * @param height height of texture
       * @param data uint8 array
       * @param useMipmap whether or not gen mipmap
       * @returns
       */
      create(width, height, data, useMiamp = true) {
        let device = webGPUContext.device;
        const bytesPerRow = width * 4 * 4;
        this.format = GPUTextureFormat.rgba16float;
        this.mipmapCount = Math.floor(useMiamp ? Math.log2(width) : 1);
        this.createTextureDescriptor(width, height, this.mipmapCount, this.format);
        const textureDataBuffer = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC
        });
        device.queue.writeBuffer(textureDataBuffer, 0, data);
        const commandEncoder = GPUContext.beginCommandEncoder();
        commandEncoder.copyBufferToTexture(
          {
            buffer: textureDataBuffer,
            bytesPerRow
          },
          {
            texture: this.getGPUTexture()
          },
          {
            width,
            height,
            depthOrArrayLayers: 1
          }
        );
        GPUContext.endCommandEncoder(commandEncoder);
        this.minFilter = `nearest`;
        this.magFilter = `nearest`;
        this.mipmapFilter = `nearest`;
        this.samplerBindingLayout.type = `non-filtering`;
        this.textureBindingLayout.sampleType = `unfilterable-float`;
        this.minFilter = `linear`;
        this.magFilter = `linear`;
        this.mipmapFilter = `nearest`;
        this.samplerBindingLayout.type = `filtering`;
        this.textureBindingLayout.sampleType = `float`;
        this.gpuSampler = device.createSampler(this);
        if (this.mipmapCount > 1) {
          TextureMipmapGenerator.webGPUGenerateMipmap(this);
        }
      }
    }

    class AxisObject extends exports.Object3D {
      length = 100;
      thickness = 0.1;
      constructor(length, thickness = 0.1) {
        super();
        this.length = length;
        this.thickness = thickness;
        this.init();
      }
      init() {
        let xAx = new exports.Object3D();
        let yAx = new exports.Object3D();
        let zAx = new exports.Object3D();
        let cubeX = new BoxGeometry(2, 2, 2);
        let cubeY = new BoxGeometry(2, 2, 2);
        let cubeZ = new BoxGeometry(2, 2, 2);
        let matX = new UnLitMaterial();
        matX.baseColor = new Color(1, 0, 0);
        let matY = new UnLitMaterial();
        matY.baseColor = new Color(0, 1, 0);
        let matZ = new UnLitMaterial();
        matZ.baseColor = new Color(0, 0, 1);
        let mrx = xAx.addComponent(exports.MeshRenderer);
        let mry = yAx.addComponent(exports.MeshRenderer);
        let mrz = zAx.addComponent(exports.MeshRenderer);
        mrx.geometry = cubeX;
        mrx.material = matX;
        mrx.castShadow = false;
        mry.geometry = cubeY;
        mry.material = matY;
        mry.castShadow = false;
        mrz.geometry = cubeZ;
        mrz.material = matZ;
        mrz.castShadow = false;
        xAx.localScale = new Vector3(this.length, this.thickness, this.thickness);
        xAx.x = this.length;
        yAx.localScale = new Vector3(this.thickness, this.length, this.thickness);
        yAx.y = this.length;
        zAx.localScale = new Vector3(this.thickness, this.thickness, this.length);
        zAx.z = this.length;
        this.addChild(xAx);
        this.addChild(yAx);
        this.addChild(zAx);
      }
    }

    class KelvinUtil {
      /**
       * Convert color temperature to color object
       * @param color_temperature_Kelvin Color temperature value
       * @returns
       */
      static color_temperature_to_rgb(color_temperature_Kelvin) {
        if (color_temperature_Kelvin < 1e3) {
          color_temperature_Kelvin = 1e3;
        } else if (color_temperature_Kelvin > 4e4) {
          color_temperature_Kelvin = 4e4;
        }
        let tmp_internal = color_temperature_Kelvin / 100;
        let red = this.get_red(tmp_internal);
        let green = this.get_green(tmp_internal);
        let blue = this.get_blue(tmp_internal);
        return new Color(red / 255, green / 255, blue / 255, 1);
      }
      /**
       * Return red component [0-255]
       * @param temperature
       * @returns
       */
      static get_red(temperature) {
        if (temperature <= 66)
          return 255;
        let tmp_red = 329.698727446 * Math.pow(temperature - 60, -0.1332047592);
        return this.bound(tmp_red);
      }
      /**
       * Return green component [0-255]
       * @param temperature
       * @returns
       */
      static get_green(temperature) {
        let green = 0;
        if (temperature <= 66) {
          green = 99.4708025861 * Math.log(temperature) - 161.1195681661;
        } else {
          green = 288.1221695283 * Math.pow(temperature - 60, -0.0755148492);
        }
        return this.bound(green);
      }
      /**
       * Return blue component [0-255]
       * @param temperature
       * @returns
       */
      static get_blue(temperature) {
        let blue = 0;
        if (temperature >= 66) {
          return 255;
        }
        if (temperature <= 19) {
          return 0;
        }
        blue = 138.5177312231 * Math.log(temperature - 10) - 305.0447927307;
        return this.bound(blue);
      }
      /**
       * @internal
       * @param color_component
       * @param minimum
       * @param maximum
       * @returns
       */
      static bound(color_component, minimum = 0, maximum = 255) {
        let color_component_out = Math.max(color_component, minimum);
        return Math.min(color_component_out, maximum);
      }
    }

    class Object3DUtil {
      static boxGeo;
      static sphere;
      static material;
      static initHeap() {
        if (!this.boxGeo)
          this.boxGeo = new BoxGeometry();
        if (!this.sphere)
          this.sphere = new SphereGeometry(1, 35, 35);
        if (!this.material) {
          this.material = new LitMaterial();
        }
      }
      static get CubeMesh() {
        this.initHeap();
        return this.boxGeo;
      }
      static get SphereMesh() {
        this.initHeap();
        return this.sphere;
      }
      static GetCube() {
        this.initHeap();
        let obj = new exports.Object3D();
        let renderer = obj.addComponent(exports.MeshRenderer);
        renderer.geometry = this.boxGeo;
        renderer.material = this.material.clone();
        renderer.castShadow = true;
        return obj;
      }
      static GetSingleCube(sizeX, sizeY, sizeZ, r, g, b) {
        this.initHeap();
        let mat = new LitMaterial();
        mat.roughness = 0.5;
        mat.metallic = 0.1;
        mat.baseColor = new Color(r, g, b, 1);
        let obj = new exports.Object3D();
        let renderer = obj.addComponent(exports.MeshRenderer);
        renderer.castGI = true;
        renderer.geometry = new BoxGeometry(sizeX, sizeY, sizeZ);
        renderer.material = mat;
        return obj;
      }
      static GetSingleSphere(radius, r, g, b) {
        this.initHeap();
        let mat = new LitMaterial();
        mat.baseColor = new Color(r, g, b, 1);
        let obj = new exports.Object3D();
        let renderer = obj.addComponent(exports.MeshRenderer);
        renderer.castGI = true;
        renderer.geometry = new SphereGeometry(radius, 20, 20);
        renderer.material = mat;
        return obj;
      }
      static get Sphere() {
        this.initHeap();
        let obj = new exports.Object3D();
        let renderer = obj.addComponent(exports.MeshRenderer);
        renderer.geometry = this.sphere;
        renderer.material = this.material;
        return obj;
      }
      static GetSingleCube2(mat, size = 10) {
        this.initHeap();
        let obj = new exports.Object3D();
        let renderer = obj.addComponent(exports.MeshRenderer);
        renderer.castShadow = false;
        renderer.geometry = new BoxGeometry(size, size, size);
        renderer.material = mat;
        return obj;
      }
    }

    class StorageUtil {
      static localData;
      static load(dataTable) {
        let jsonData = localStorage.getItem(dataTable);
        if (jsonData) {
          this.localData = JSON.parse(jsonData);
        } else {
          this.localData = {};
          StorageUtil.save(dataTable, this.localData);
        }
        return this.localData;
      }
      static save(table, data) {
        let json = JSON.stringify(data);
        localStorage.setItem(table, json);
      }
    }

    class f32 extends Number {
    }
    class i32 extends Number {
    }
    class u32 extends Number {
    }

    class Vector3Struct extends Struct {
      x = 0;
      y = 0;
      z = 0;
      w = 0;
    }

    exports.AccelerateDecelerateInterpolator = AccelerateDecelerateInterpolator;
    exports.AccelerateInterpolator = AccelerateInterpolator;
    exports.AnimationCurve = AnimationCurve;
    exports.AnimationCurveT = AnimationCurveT;
    exports.AnimationMonitor = AnimationMonitor;
    exports.AnimatorEventKeyframe = AnimatorEventKeyframe;
    exports.AnticipateInterpolator = AnticipateInterpolator;
    exports.AnticipateOvershootInterpolator = AnticipateOvershootInterpolator;
    exports.ArrayHas = ArrayHas;
    exports.ArrayItemIndex = ArrayItemIndex;
    exports.AtlasParser = AtlasParser;
    exports.AtmosphericComponent = AtmosphericComponent;
    exports.AtmosphericScatteringSky = AtmosphericScatteringSky;
    exports.AtmosphericScatteringSkySetting = AtmosphericScatteringSkySetting;
    exports.AtmosphericScatteringSky_shader = AtmosphericScatteringSky_shader;
    exports.AttributeAnimCurve = AttributeAnimCurve;
    exports.AxisObject = AxisObject;
    exports.B3DMLoader = B3DMLoader;
    exports.B3DMLoaderBase = B3DMLoaderBase;
    exports.B3DMParseUtil = B3DMParseUtil;
    exports.B3DMParser = B3DMParser;
    exports.BLUR_CsShader = BLUR_CsShader;
    exports.BRDFLUT = BRDFLUT;
    exports.BRDFLUTGenerate = BRDFLUTGenerate;
    exports.BRDF_frag = BRDF_frag;
    exports.BatchTable = BatchTable;
    exports.Bezier2D = Bezier2D;
    exports.Bezier3D = Bezier3D;
    exports.BiMap = BiMap;
    exports.BillboardComponent = BillboardComponent;
    exports.BillboardType = BillboardType;
    exports.BitmapTexture2D = BitmapTexture2D;
    exports.BitmapTexture2DArray = BitmapTexture2DArray;
    exports.BitmapTextureCube = BitmapTextureCube;
    exports.Blend = Blend;
    exports.BlendFactor = BlendFactor;
    exports.BlendMode = BlendMode;
    exports.BlendShapeData = BlendShapeData;
    exports.BlendShapeFrameData = BlendShapeFrameData;
    exports.BlendShapePropertyData = BlendShapePropertyData;
    exports.BloomPost = BloomPost;
    exports.BlurEffectCreatorBlur_cs = BlurEffectCreatorBlur_cs;
    exports.BlurEffectCreatorSample_cs = BlurEffectCreatorSample_cs;
    exports.BlurTexture2DBufferCreator = BlurTexture2DBufferCreator;
    exports.BounceInterpolator = BounceInterpolator;
    exports.BoundUtil = BoundUtil;
    exports.BoundingBox = BoundingBox;
    exports.BoundingSphere = BoundingSphere;
    exports.BoxColliderShape = BoxColliderShape;
    exports.BoxGeometry = BoxGeometry;
    exports.BrdfLut_frag = BrdfLut_frag;
    exports.BsDF_frag = BsDF_frag;
    exports.BxDF_frag = BxDF_frag;
    exports.BxdfDebug_frag = BxdfDebug_frag;
    exports.BytesArray = BytesArray;
    exports.CEvent = CEvent;
    exports.CEventDispatcher = CEventDispatcher;
    exports.CEventListener = CEventListener;
    exports.CResizeEvent = CResizeEvent;
    exports.CSM = CSM;
    exports.Camera3D = Camera3D;
    exports.CameraControllerBase = CameraControllerBase;
    exports.CameraType = CameraType;
    exports.CameraUtil = CameraUtil;
    exports.CapsuleColliderShape = CapsuleColliderShape;
    exports.CastPointShadowMaterialPass = CastPointShadowMaterialPass;
    exports.CastShadowMaterialPass = CastShadowMaterialPass;
    exports.Clearcoat_frag = Clearcoat_frag;
    exports.ClusterBoundsSource_cs = ClusterBoundsSource_cs;
    exports.ClusterConfig = ClusterConfig;
    exports.ClusterDebug_frag = ClusterDebug_frag;
    exports.ClusterLight = ClusterLight;
    exports.ClusterLightingBuffer = ClusterLightingBuffer;
    exports.ClusterLightingRender = ClusterLightingRender;
    exports.ClusterLighting_cs = ClusterLighting_cs;
    exports.CollectInfo = CollectInfo;
    exports.ColliderComponent = ColliderComponent;
    exports.ColliderShape = ColliderShape;
    exports.ColliderShapeType = ColliderShapeType;
    exports.Color = Color;
    exports.ColorLitMaterial = ColorLitMaterial;
    exports.ColorLitShader = ColorLitShader;
    exports.ColorPassFragmentOutput = ColorPassFragmentOutput;
    exports.ColorPassRenderer = ColorPassRenderer;
    exports.ColorUtil = ColorUtil;
    exports.ComData = ComData;
    exports.Common_frag = Common_frag;
    exports.Common_vert = Common_vert;
    exports.ComponentBase = ComponentBase;
    exports.ComponentCollect = ComponentCollect;
    exports.ComputeGPUBuffer = ComputeGPUBuffer;
    exports.ComputeShader = ComputeShader;
    exports.CubeCamera = CubeCamera;
    exports.CubeMapFaceEnum = CubeMapFaceEnum;
    exports.CubeSky_Shader = CubeSky_Shader;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.CubicBezierPath = CubicBezierPath;
    exports.CubicBezierType = CubicBezierType;
    exports.CycleInterpolator = CycleInterpolator;
    exports.CylinderGeometry = CylinderGeometry;
    exports.DDGIIrradianceComputePass = DDGIIrradianceComputePass;
    exports.DDGIIrradianceGPUBufferReader = DDGIIrradianceGPUBufferReader;
    exports.DDGIIrradianceVolume = DDGIIrradianceVolume;
    exports.DDGIIrradiance_shader = DDGIIrradiance_shader;
    exports.DDGILightingPass = DDGILightingPass;
    exports.DDGILighting_shader = DDGILighting_shader;
    exports.DDGIMultiBouncePass = DDGIMultiBouncePass;
    exports.DDGIProbeRenderer = DDGIProbeRenderer;
    exports.DEGREES_TO_RADIANS = DEGREES_TO_RADIANS;
    exports.DecelerateInterpolator = DecelerateInterpolator;
    exports.Depth2DTextureArray = Depth2DTextureArray;
    exports.DepthCubeArrayTexture = DepthCubeArrayTexture;
    exports.DepthCubeTexture = DepthCubeTexture;
    exports.DepthMaterialPass = DepthMaterialPass;
    exports.DepthOfFieldPost = DepthOfFieldPost;
    exports.DepthOfView_cs = DepthOfView_cs;
    exports.DoubleArray = DoubleArray;
    exports.DrawInfo = DrawInfo;
    exports.DynamicDrawStruct = DynamicDrawStruct;
    exports.DynamicFaceRenderer = DynamicFaceRenderer;
    exports.EditorInspector = EditorInspector;
    exports.Engine3D = Engine3D;
    exports.Entity = Entity;
    exports.EntityBatchCollect = EntityBatchCollect;
    exports.EntityCollect = EntityCollect;
    exports.EnvMap_frag = EnvMap_frag;
    exports.ErpImage2CubeMap = ErpImage2CubeMap;
    exports.ErpImage2CubeMapCreateCube_cs = ErpImage2CubeMapCreateCube_cs;
    exports.ErpImage2CubeMapRgbe2rgba_cs = ErpImage2CubeMapRgbe2rgba_cs;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.FASTFLOOR = FASTFLOOR;
    exports.FXAAPost = FXAAPost;
    exports.FXAAShader = FXAAShader;
    exports.FaceMode = FaceMode;
    exports.FastMathShader = FastMathShader;
    exports.FeatureTable = FeatureTable;
    exports.FileLoader = FileLoader;
    exports.FirstPersonCameraController = FirstPersonCameraController;
    exports.Float16ArrayTexture = Float16ArrayTexture;
    exports.Float32ArrayTexture = Float32ArrayTexture;
    exports.Float32ArrayUtil = Float32ArrayUtil;
    exports.FlyCameraController = FlyCameraController;
    exports.FontChar = FontChar;
    exports.FontInfo = FontInfo;
    exports.FontPage = FontPage;
    exports.FontParser = FontParser;
    exports.ForwardRenderJob = ForwardRenderJob;
    exports.FragmentVarying = FragmentVarying;
    exports.FrameCache = FrameCache;
    exports.Frustum = Frustum;
    exports.FrustumCSM = FrustumCSM;
    exports.FrustumCulling_cs = FrustumCulling_cs;
    exports.FullQuad_vert_wgsl = FullQuad_vert_wgsl;
    exports.GBufferFrame = GBufferFrame;
    exports.GBufferPass = GBufferPass;
    exports.GBuffer_pass = GBuffer_pass;
    exports.GILighting = GILighting;
    exports.GIProbeMaterial = GIProbeMaterial;
    exports.GIProbeMaterialType = GIProbeMaterialType;
    exports.GIProbeShader = GIProbeShader;
    exports.GIRenderCompleteEvent = GIRenderCompleteEvent;
    exports.GIRenderStartEvent = GIRenderStartEvent;
    exports.GLBChunk = GLBChunk;
    exports.GLBHeader = GLBHeader;
    exports.GLBParser = GLBParser;
    exports.GLSLLexer = GLSLLexer;
    exports.GLSLLexerToken = GLSLLexerToken;
    exports.GLSLPreprocessor = GLSLPreprocessor;
    exports.GLSLSyntax = GLSLSyntax;
    exports.GLTFBinaryExtension = GLTFBinaryExtension;
    exports.GLTFParser = GLTFParser;
    exports.GLTFSubParser = GLTFSubParser;
    exports.GLTFSubParserCamera = GLTFSubParserCamera;
    exports.GLTFSubParserConverter = GLTFSubParserConverter;
    exports.GLTFSubParserMaterial = GLTFSubParserMaterial;
    exports.GLTFSubParserMesh = GLTFSubParserMesh;
    exports.GLTFSubParserSkeleton = GLTFSubParserSkeleton;
    exports.GLTFSubParserSkin = GLTFSubParserSkin;
    exports.GLTFType = GLTFType;
    exports.GLTF_Accessors = GLTF_Accessors;
    exports.GLTF_Info = GLTF_Info;
    exports.GLTF_Light = GLTF_Light;
    exports.GLTF_Mesh = GLTF_Mesh;
    exports.GLTF_Node = GLTF_Node;
    exports.GLTF_Primitives = GLTF_Primitives;
    exports.GLTF_Scene = GLTF_Scene;
    exports.GPUAddressMode = GPUAddressMode;
    exports.GPUBlendFactor = GPUBlendFactor;
    exports.GPUBufferBase = GPUBufferBase;
    exports.GPUBufferType = GPUBufferType;
    exports.GPUCompareFunction = GPUCompareFunction;
    exports.GPUContext = GPUContext;
    exports.GPUCullMode = GPUCullMode;
    exports.GPUFilterMode = GPUFilterMode;
    exports.GPUPrimitiveTopology = GPUPrimitiveTopology;
    exports.GPUTextureFormat = GPUTextureFormat;
    exports.GPUVertexFormat = GPUVertexFormat;
    exports.GPUVertexStepMode = GPUVertexStepMode;
    exports.GTAOPost = GTAOPost;
    exports.GTAO_cs = GTAO_cs;
    exports.GUIAtlasTexture = GUIAtlasTexture;
    exports.GUICanvas = GUICanvas;
    exports.GUIConfig = GUIConfig;
    exports.GUIGeometry = GUIGeometry;
    exports.GUIGeometryRebuild = GUIGeometryRebuild;
    exports.GUIMaterial = GUIMaterial;
    exports.GUIPick = GUIPick;
    exports.GUIPickHelper = GUIPickHelper;
    exports.GUIQuad = GUIQuad;
    exports.GUIQuadAttrEnum = GUIQuadAttrEnum;
    exports.GUIRenderer = GUIRenderer;
    exports.GUIShader = GUIShader;
    exports.GUISpace = GUISpace;
    exports.GUISprite = GUISprite;
    exports.GUITexture = GUITexture;
    exports.GenerayRandomDir = GenerayRandomDir;
    exports.GeoJsonParser = GeoJsonParser;
    exports.GeoJsonUtil = GeoJsonUtil;
    exports.GeoType = GeoType;
    exports.GeometryBase = GeometryBase;
    exports.GeometryIndicesBuffer = GeometryIndicesBuffer;
    exports.GeometryInfo = GeometryInfo;
    exports.GeometryUtil = GeometryUtil;
    exports.GeometryVertexBuffer = GeometryVertexBuffer;
    exports.GeometryVertexType = GeometryVertexType;
    exports.GetComponentClass = GetComponentClass;
    exports.GetCountInstanceID = GetCountInstanceID;
    exports.GetRepeat = GetRepeat;
    exports.GetShader = GetShader;
    exports.GlassMaterial = GlassMaterial;
    exports.GlassShader = GlassShader;
    exports.GlobalBindGroup = GlobalBindGroup;
    exports.GlobalBindGroupLayout = GlobalBindGroupLayout;
    exports.GlobalFog = GlobalFog;
    exports.GlobalFog_shader = GlobalFog_shader;
    exports.GlobalIlluminationComponent = GlobalIlluminationComponent;
    exports.GlobalUniform = GlobalUniform;
    exports.GlobalUniformGroup = GlobalUniformGroup;
    exports.GodRayPost = GodRayPost;
    exports.GodRay_cs = GodRay_cs;
    exports.Graphic3D = Graphic3D;
    exports.Graphic3DBatchRenderer = Graphic3DBatchRenderer;
    exports.Graphic3DFaceRenderer = Graphic3DFaceRenderer;
    exports.Graphic3DFillRenderer = Graphic3DFillRenderer;
    exports.Graphic3DFixedRenderMaterial = Graphic3DFixedRenderMaterial;
    exports.Graphic3DLineRenderer = Graphic3DLineRenderer;
    exports.Graphic3DMesh = Graphic3DMesh;
    exports.Graphic3DMeshRenderer = Graphic3DMeshRenderer;
    exports.Graphic3DRibbonRenderer = Graphic3DRibbonRenderer;
    exports.Graphic3DShader = Graphic3DShader;
    exports.GraphicFaceCompute3 = GraphicFaceCompute3;
    exports.GraphicLineCompute = GraphicLineCompute;
    exports.Graphics3DShape = Graphics3DShape;
    exports.HDRTexture = HDRTexture;
    exports.HDRTextureCube = HDRTextureCube;
    exports.Hair_frag = Hair_frag;
    exports.Hair_shader_op = Hair_shader_op;
    exports.Hair_shader_tr = Hair_shader_tr;
    exports.HaltonSeq = HaltonSeq;
    exports.Horizontal = Horizontal;
    exports.HoverCameraController = HoverCameraController;
    exports.I3DMLoader = I3DMLoader;
    exports.I3DMLoaderBase = I3DMLoaderBase;
    exports.I3DMParser = I3DMParser;
    exports.IBLEnvMapCreator = IBLEnvMapCreator;
    exports.IBLEnvMapCreator_cs = IBLEnvMapCreator_cs;
    exports.IESProfiles = IESProfiles;
    exports.IESProfiles_frag = IESProfiles_frag;
    exports.IKDTreeUserData = IKDTreeUserData;
    exports.ImageType = ImageType;
    exports.IndicesGPUBuffer = IndicesGPUBuffer;
    exports.Inline_vert = Inline_vert;
    exports.InputSystem = InputSystem;
    exports.InstanceDrawComponent = InstanceDrawComponent;
    exports.InstanceUniform = InstanceUniform;
    exports.InstancedMesh = InstancedMesh;
    exports.Interpolator = Interpolator;
    exports.InterpolatorEnum = InterpolatorEnum;
    exports.IrradianceDataReaderCompleteEvent = IrradianceDataReaderCompleteEvent;
    exports.IrradianceVolumeData_frag = IrradianceVolumeData_frag;
    exports.Irradiance_frag = Irradiance_frag;
    exports.IsEditorInspector = IsEditorInspector;
    exports.IsNonSerialize = IsNonSerialize;
    exports.Joint = Joint;
    exports.JointPose = JointPose;
    exports.JumperInterpolator = JumperInterpolator;
    exports.KDTreeEntity = KDTreeEntity;
    exports.KDTreeNode = KDTreeNode;
    exports.KDTreeRange = KDTreeRange;
    exports.KDTreeSpace = KDTreeSpace;
    exports.KDTreeUUID = KDTreeUUID;
    exports.KHR_draco_mesh_compression = KHR_draco_mesh_compression;
    exports.KHR_lights_punctual = KHR_lights_punctual;
    exports.KHR_materials_clearcoat = KHR_materials_clearcoat;
    exports.KHR_materials_emissive_strength = KHR_materials_emissive_strength;
    exports.KHR_materials_ior = KHR_materials_ior;
    exports.KHR_materials_sheen = KHR_materials_sheen;
    exports.KHR_materials_specular = KHR_materials_specular;
    exports.KHR_materials_transmission = KHR_materials_transmission;
    exports.KHR_materials_unlit = KHR_materials_unlit;
    exports.KHR_materials_variants = KHR_materials_variants;
    exports.KHR_materials_volume = KHR_materials_volume;
    exports.KHR_mesh_quantization = KHR_mesh_quantization;
    exports.KHR_texture_basisu = KHR_texture_basisu;
    exports.KHR_texture_transform = KHR_texture_transform;
    exports.KV = KV;
    exports.KelvinUtil = KelvinUtil;
    exports.KeyCode = KeyCode;
    exports.KeyEvent = KeyEvent;
    exports.Keyframe = Keyframe;
    exports.KeyframeT = KeyframeT;
    exports.LDRTextureCube = LDRTextureCube;
    exports.LUT_glsl = LUT_glsl;
    exports.LambertMaterial = LambertMaterial;
    exports.Lambert_shader = Lambert_shader;
    exports.LightBase = LightBase;
    exports.LightData = LightData;
    exports.LightEntries = LightEntries;
    exports.LightType = LightType;
    exports.LightingFunction_frag = LightingFunction_frag;
    exports.Line = Line;
    exports.LineCap = LineCap;
    exports.LineClassification = LineClassification;
    exports.LineJoin = LineJoin;
    exports.LinearInterpolator = LinearInterpolator;
    exports.LitMaterial = LitMaterial;
    exports.Lit_shader = Lit_shader;
    exports.LoaderBase = LoaderBase;
    exports.LoaderEvent = LoaderEvent;
    exports.LoaderManager = LoaderManager;
    exports.MAX_VALUE = MAX_VALUE;
    exports.MIN_VALUE = MIN_VALUE;
    exports.Material = Material;
    exports.MaterialDataUniformGPUBuffer = MaterialDataUniformGPUBuffer;
    exports.MaterialUniform = MaterialUniform;
    exports.MaterialUtilities = MaterialUtilities;
    exports.MathShader = MathShader;
    exports.MathUtil = MathUtil;
    exports.Matrix3 = Matrix3;
    exports.Matrix4 = Matrix4;
    exports.MatrixBindGroup = MatrixBindGroup;
    exports.MatrixDO = MatrixDO;
    exports.MatrixGPUBuffer = MatrixGPUBuffer;
    exports.MatrixShader = MatrixShader;
    exports.MemoryDO = MemoryDO;
    exports.MemoryInfo = MemoryInfo;
    exports.MergeRGBACreator = MergeRGBACreator;
    exports.MergeRGBA_cs = MergeRGBA_cs;
    exports.MeshColliderShape = MeshColliderShape;
    exports.MinMaxAnimationCurves = MinMaxAnimationCurves;
    exports.MinMaxCurve = MinMaxCurve;
    exports.MinMaxCurveState = MinMaxCurveState;
    exports.MinMaxPolyCurves = MinMaxPolyCurves;
    exports.MorePassParser = MorePassParser;
    exports.MorePassShader = MorePassShader;
    exports.MorphTargetBlender = MorphTargetBlender;
    exports.MorphTargetData = MorphTargetData;
    exports.MorphTargetFrame = MorphTargetFrame;
    exports.MorphTargetTransformKey = MorphTargetTransformKey;
    exports.MorphTarget_shader = MorphTarget_shader;
    exports.MouseCode = MouseCode;
    exports.MultiBouncePass_cs = MultiBouncePass_cs;
    exports.Navi3DAstar = Navi3DAstar;
    exports.Navi3DConst = Navi3DConst;
    exports.Navi3DEdge = Navi3DEdge;
    exports.Navi3DFunnel = Navi3DFunnel;
    exports.Navi3DMaskType = Navi3DMaskType;
    exports.Navi3DMergeVertex = Navi3DMergeVertex;
    exports.Navi3DMesh = Navi3DMesh;
    exports.Navi3DPoint = Navi3DPoint;
    exports.Navi3DPoint2D = Navi3DPoint2D;
    exports.Navi3DPointFat = Navi3DPointFat;
    exports.Navi3DRouter = Navi3DRouter;
    exports.Navi3DTriangle = Navi3DTriangle;
    exports.NonSerialize = NonSerialize;
    exports.NormalMap_frag = NormalMap_frag;
    exports.OAnimationEvent = OAnimationEvent;
    exports.OBJParser = OBJParser;
    exports.Object3DEvent = Object3DEvent;
    exports.Object3DUtil = Object3DUtil;
    exports.ObjectAnimClip = ObjectAnimClip;
    exports.OcclusionSystem = OcclusionSystem;
    exports.Octree = Octree;
    exports.OctreeEntity = OctreeEntity;
    exports.OrbitController = OrbitController;
    exports.OrderMap = OrderMap;
    exports.Orientation3D = Orientation3D;
    exports.OutLineBlendColor_cs = OutLineBlendColor_cs;
    exports.OutlineCalcOutline_cs = OutlineCalcOutline_cs;
    exports.OutlinePass = OutlinePass;
    exports.OutlinePost = OutlinePost;
    exports.OutlinePostData = OutlinePostData;
    exports.OutlinePostManager = OutlinePostManager;
    exports.OutlinePostSlot = OutlinePostSlot;
    exports.Outline_cs = Outline_cs;
    exports.OvershootInterpolator = OvershootInterpolator;
    exports.PBRLItShader = PBRLItShader;
    exports.PBRLitSSSShader = PBRLitSSSShader;
    exports.ParserBase = ParserBase;
    exports.ParserFormat = ParserFormat;
    exports.ParticleSystemCurveEvalMode = ParticleSystemCurveEvalMode;
    exports.ParticleSystemRandomnessIds = ParticleSystemRandomnessIds;
    exports.PassGenerate = PassGenerate;
    exports.PassShader = PassShader;
    exports.PassType = PassType;
    exports.PavementShader = PavementShader;
    exports.PhysicMaterial = PhysicMaterial;
    exports.PhysicMaterialUniform_frag = PhysicMaterialUniform_frag;
    exports.PickCompute = PickCompute;
    exports.PickFire = PickFire;
    exports.PickResult = PickResult;
    exports.Picker_cs = Picker_cs;
    exports.PingPong = PingPong;
    exports.PipelinePool = PipelinePool;
    exports.Plane = Plane;
    exports.Plane3D = Plane3D;
    exports.PlaneClassification = PlaneClassification;
    exports.PlaneGeometry = PlaneGeometry;
    exports.PointClassification = PointClassification;
    exports.PointLightShadowRenderer = PointLightShadowRenderer;
    exports.PointShadowCubeCamera = PointShadowCubeCamera;
    exports.PointShadowDebug = PointShadowDebug;
    exports.PointerEvent3D = PointerEvent3D;
    exports.Polynomial = Polynomial;
    exports.PolynomialCurve = PolynomialCurve;
    exports.Polynomials = Polynomials;
    exports.PoolNode = PoolNode;
    exports.PostBase = PostBase;
    exports.PostProcessingComponent = PostProcessingComponent;
    exports.PostRenderer = PostRenderer;
    exports.PreDepthPassRenderer = PreDepthPassRenderer;
    exports.PreIntegratedLut = PreIntegratedLut;
    exports.PreIntegratedLutCompute = PreIntegratedLutCompute;
    exports.PrefabAvatarData = PrefabAvatarData;
    exports.PrefabAvatarParser = PrefabAvatarParser;
    exports.PrefabBoneData = PrefabBoneData;
    exports.PrefabMaterialParser = PrefabMaterialParser;
    exports.PrefabMeshData = PrefabMeshData;
    exports.PrefabMeshParser = PrefabMeshParser;
    exports.PrefabNode = PrefabNode;
    exports.PrefabParser = PrefabParser;
    exports.PrefabStringUtil = PrefabStringUtil;
    exports.PrefabTextureData = PrefabTextureData;
    exports.PrefabTextureParser = PrefabTextureParser;
    exports.Preprocessor = Preprocessor;
    exports.Probe = Probe;
    exports.ProbeEntries = ProbeEntries;
    exports.ProbeGBufferFrame = ProbeGBufferFrame;
    exports.ProfilerUtil = ProfilerUtil;
    exports.PropertyAnimClip = PropertyAnimClip;
    exports.PropertyAnimTag = PropertyAnimTag;
    exports.PropertyAnimation = PropertyAnimation;
    exports.PropertyAnimationClip = PropertyAnimationClip;
    exports.PropertyAnimationEvent = PropertyAnimationEvent;
    exports.PropertyHelp = PropertyHelp;
    exports.QuadAABB = QuadAABB;
    exports.QuadGlsl_fs = QuadGlsl_fs;
    exports.QuadGlsl_vs = QuadGlsl_vs;
    exports.QuadRoot = QuadRoot;
    exports.QuadTree = QuadTree;
    exports.QuadTreeCell = QuadTreeCell;
    exports.Quad_depth2dArray_frag_wgsl = Quad_depth2dArray_frag_wgsl;
    exports.Quad_depth2d_frag_wgsl = Quad_depth2d_frag_wgsl;
    exports.Quad_depthCube_frag_wgsl = Quad_depthCube_frag_wgsl;
    exports.Quad_frag_wgsl = Quad_frag_wgsl;
    exports.Quad_vert_wgsl = Quad_vert_wgsl;
    exports.Quaternion = Quaternion;
    exports.RADIANS_TO_DEGREES = RADIANS_TO_DEGREES;
    exports.RGBEErrorCode = RGBEErrorCode;
    exports.RGBEHeader = RGBEHeader;
    exports.RGBEParser = RGBEParser;
    exports.RTDescriptor = RTDescriptor;
    exports.RTFrame = RTFrame;
    exports.RTResourceConfig = RTResourceConfig;
    exports.RTResourceMap = RTResourceMap;
    exports.Rand = Rand;
    exports.RandomSeed = RandomSeed;
    exports.Ray = Ray;
    exports.RayCastMeshDetail = RayCastMeshDetail;
    exports.Reader = Reader;
    exports.Rect = Rect;
    exports.Reference = Reference;
    exports.RegisterComponent = RegisterComponent;
    exports.RegisterShader = RegisterShader;
    exports.RenderContext = RenderContext;
    exports.RenderLayer = RenderLayer;
    exports.RenderLayerUtil = RenderLayerUtil;
    exports.RenderNode = RenderNode;
    exports.RenderShaderCollect = RenderShaderCollect;
    exports.RenderShaderCompute = RenderShaderCompute;
    exports.RenderShaderPass = RenderShaderPass;
    exports.RenderTexture = RenderTexture;
    exports.RendererBase = RendererBase;
    exports.RendererJob = RendererJob;
    exports.RendererMap = RendererMap;
    exports.RendererMask = RendererMask;
    exports.RendererMaskUtil = RendererMaskUtil;
    exports.RendererPassState = RendererPassState;
    exports.RepeatSE = RepeatSE;
    exports.Res = Res;
    exports.RibbonStruct = RibbonStruct;
    exports.SN_ArrayConstant = SN_ArrayConstant;
    exports.SN_BinaryOperation = SN_BinaryOperation;
    exports.SN_Break = SN_Break;
    exports.SN_CodeBlock = SN_CodeBlock;
    exports.SN_Constant = SN_Constant;
    exports.SN_Continue = SN_Continue;
    exports.SN_Declaration = SN_Declaration;
    exports.SN_Discard = SN_Discard;
    exports.SN_DoWhileLoop = SN_DoWhileLoop;
    exports.SN_Expression = SN_Expression;
    exports.SN_ForLoop = SN_ForLoop;
    exports.SN_Function = SN_Function;
    exports.SN_FunctionArgs = SN_FunctionArgs;
    exports.SN_FunctionCall = SN_FunctionCall;
    exports.SN_IFBranch = SN_IFBranch;
    exports.SN_Identifier = SN_Identifier;
    exports.SN_IndexOperation = SN_IndexOperation;
    exports.SN_Layout = SN_Layout;
    exports.SN_ParenExpression = SN_ParenExpression;
    exports.SN_Precision = SN_Precision;
    exports.SN_Return = SN_Return;
    exports.SN_SelectOperation = SN_SelectOperation;
    exports.SN_Struct = SN_Struct;
    exports.SN_TernaryOperation = SN_TernaryOperation;
    exports.SN_UnaryOperation = SN_UnaryOperation;
    exports.SN_WhileLoop = SN_WhileLoop;
    exports.SSAO_cs = SSAO_cs;
    exports.SSRPost = SSRPost;
    exports.SSR_BlendColor_cs = SSR_BlendColor_cs;
    exports.SSR_IS_Kernel = SSR_IS_Kernel;
    exports.SSR_IS_cs = SSR_IS_cs;
    exports.SSR_RayTrace_cs = SSR_RayTrace_cs;
    exports.Scene3D = Scene3D;
    exports.Shader = Shader;
    exports.ShaderAttributeInfo = ShaderAttributeInfo;
    exports.ShaderConverter = ShaderConverter;
    exports.ShaderConverterResult = ShaderConverterResult;
    exports.ShaderLib = ShaderLib;
    exports.ShaderPassBase = ShaderPassBase;
    exports.ShaderReflection = ShaderReflection;
    exports.ShaderStage = ShaderStage;
    exports.ShaderState = ShaderState;
    exports.ShaderUniformInfo = ShaderUniformInfo;
    exports.ShaderUtil = ShaderUtil;
    exports.ShadingInput = ShadingInput;
    exports.ShadowLightsCollect = ShadowLightsCollect;
    exports.ShadowMapPassRenderer = ShadowMapPassRenderer;
    exports.ShadowMapping_frag = ShadowMapping_frag;
    exports.ShapeInfo = ShapeInfo;
    exports.Skeleton = Skeleton;
    exports.SkeletonAnimationClip = SkeletonAnimationClip;
    exports.SkeletonAnimationClipState = SkeletonAnimationClipState;
    exports.SkeletonAnimationCompute = SkeletonAnimationCompute;
    exports.SkeletonAnimation_shader = SkeletonAnimation_shader;
    exports.SkeletonBlendComputeArgs = SkeletonBlendComputeArgs;
    exports.SkeletonPose = SkeletonPose;
    exports.SkeletonTransformComputeArgs = SkeletonTransformComputeArgs;
    exports.SkyGBufferPass = SkyGBufferPass;
    exports.SkyGBuffer_pass = SkyGBuffer_pass;
    exports.SkyMaterial = SkyMaterial;
    exports.SkyRenderer = SkyRenderer;
    exports.Sky_glsl_fs = Sky_glsl_fs;
    exports.Sky_glsl_vs = Sky_glsl_vs;
    exports.SolidColorSky = SolidColorSky;
    exports.SphereColliderShape = SphereColliderShape;
    exports.SphereGeometry = SphereGeometry;
    exports.StatementNode = StatementNode;
    exports.StorageGPUBuffer = StorageGPUBuffer;
    exports.StorageUtil = StorageUtil;
    exports.StringUtil = StringUtil;
    exports.StripeGeometry = StripeGeometry;
    exports.Struct = Struct;
    exports.StructStorageGPUBuffer = StructStorageGPUBuffer;
    exports.SubGeometry = SubGeometry;
    exports.TAACopyTex_cs = TAACopyTex_cs;
    exports.TAAPost = TAAPost;
    exports.TAASharpTex_cs = TAASharpTex_cs;
    exports.TAA_cs = TAA_cs;
    exports.TextAnchor = TextAnchor;
    exports.TextFieldLayout = TextFieldLayout;
    exports.TextFieldLine = TextFieldLine;
    exports.Texture = Texture;
    exports.TextureCube = TextureCube;
    exports.TextureCubeFaceData = TextureCubeFaceData;
    exports.TextureCubeStdCreator = TextureCubeStdCreator;
    exports.TextureCubeUtils = TextureCubeUtils;
    exports.TextureMipmapCompute = TextureMipmapCompute;
    exports.TextureMipmapGenerator = TextureMipmapGenerator;
    exports.ThirdPersonCameraController = ThirdPersonCameraController;
    exports.TileSet = TileSet;
    exports.TileSetChild = TileSetChild;
    exports.TileSetChildContent = TileSetChildContent;
    exports.TileSetChildContentMetaData = TileSetChildContentMetaData;
    exports.TileSetRoot = TileSetRoot;
    exports.TilesRenderer = TilesRenderer;
    exports.Time = Time;
    exports.TokenType = TokenType;
    exports.TorusGeometry = TorusGeometry;
    exports.TouchData = TouchData;
    exports.TrailGeometry = TrailGeometry;
    exports.Transform = Transform;
    exports.TranslatorContext = TranslatorContext;
    exports.TriGeometry = TriGeometry;
    exports.Triangle = Triangle;
    exports.UIButton = UIButton;
    exports.UIButtonTransition = UIButtonTransition;
    exports.UIComponentBase = UIComponentBase;
    exports.UIEvent = UIEvent;
    exports.UIImage = UIImage;
    exports.UIImageGroup = UIImageGroup;
    exports.UIInteractive = UIInteractive;
    exports.UIInteractiveStyle = UIInteractiveStyle;
    exports.UIPanel = UIPanel;
    exports.UIRenderAble = UIRenderAble;
    exports.UIShadow = UIShadow;
    exports.UITextField = UITextField;
    exports.UITransform = UITransform;
    exports.UUID = UUID;
    exports.UV = UV;
    exports.Uint16Texture = Uint16Texture;
    exports.Uint8ArrayTexture = Uint8ArrayTexture;
    exports.UnLit = UnLit;
    exports.UnLitMaterial = UnLitMaterial;
    exports.UnLitMaterialUniform_frag = UnLitMaterialUniform_frag;
    exports.UnLitTexArrayMaterial = UnLitTexArrayMaterial;
    exports.UnLitTextureArray = UnLitTextureArray;
    exports.UnLit_frag = UnLit_frag;
    exports.UniformGPUBuffer = UniformGPUBuffer;
    exports.UniformNode = UniformNode;
    exports.UniformType = UniformType;
    exports.ValueEnumType = ValueEnumType;
    exports.ValueOp = ValueOp;
    exports.ValueParser = ValueParser;
    exports.ValueSpread = ValueSpread;
    exports.Vector2 = Vector2;
    exports.Vector3 = Vector3;
    exports.Vector3Ex = Vector3Ex;
    exports.Vector3Struct = Vector3Struct;
    exports.Vector4 = Vector4;
    exports.VertexAttribute = VertexAttribute;
    exports.VertexAttributeIndexShader = VertexAttributeIndexShader;
    exports.VertexAttributeName = VertexAttributeName;
    exports.VertexAttributeSize = VertexAttributeSize;
    exports.VertexAttributeStride = VertexAttributeStride;
    exports.VertexAttributes = VertexAttributes;
    exports.VertexBufferLayout = VertexBufferLayout;
    exports.VertexFormat = VertexFormat;
    exports.VertexGPUBuffer = VertexGPUBuffer;
    exports.Vertical = Vertical;
    exports.VideoUniform_frag = VideoUniform_frag;
    exports.View3D = View3D;
    exports.ViewPanel = ViewPanel;
    exports.ViewQuad = ViewQuad;
    exports.VirtualTexture = VirtualTexture;
    exports.WGSLTranslator = WGSLTranslator;
    exports.WebGPUDescriptorCreator = WebGPUDescriptorCreator;
    exports.WorldMatrixUniform = WorldMatrixUniform;
    exports.WorldPanel = WorldPanel;
    exports.WrapMode = WrapMode;
    exports.WrapTimeMode = WrapTimeMode;
    exports.ZCullingCompute = ZCullingCompute;
    exports.ZPassShader_cs = ZPassShader_cs;
    exports.ZPassShader_fs = ZPassShader_fs;
    exports.ZPassShader_vs = ZPassShader_vs;
    exports.ZSorterUtil = ZSorterUtil;
    exports.append = append;
    exports.arrayToString = arrayToString;
    exports.blendComponent = blendComponent;
    exports.buildCurves = buildCurves;
    exports.calculateCurveRangesValue = calculateCurveRangesValue;
    exports.calculateMinMax = calculateMinMax;
    exports.castPointShadowMap_vert = castPointShadowMap_vert;
    exports.clamp = clamp;
    exports.clampRepeat = clampRepeat;
    exports.compute_skeleton_blend = compute_skeleton_blend;
    exports.compute_skeleton_transform = compute_skeleton_transform;
    exports.cos = cos;
    exports.crossProduct = crossProduct;
    exports.cubicPolynomialRoot = cubicPolynomialRoot;
    exports.cubicPolynomialRootsGeneric = cubicPolynomialRootsGeneric;
    exports.curvesSupportProcedural = curvesSupportProcedural;
    exports.deg2Rad = deg2Rad;
    exports.directionShadowCastMap_frag = directionShadowCastMap_frag;
    exports.dot = dot;
    exports.doubleIntegrateSegment = doubleIntegrateSegment;
    exports.downSample = downSample;
    exports.f32 = f32;
    exports.fastInvSqrt = fastInvSqrt;
    exports.floorfToIntPos = floorfToIntPos;
    exports.fonts = fonts;
    exports.generateRandom = generateRandom;
    exports.generateRandom3 = generateRandom3;
    exports.getFloatFromInt = getFloatFromInt;
    exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
    exports.getGLTypeFromTypedArrayType = getGLTypeFromTypedArrayType;
    exports.getGlobalRandomSeed = getGlobalRandomSeed;
    exports.getTypedArray = getTypedArray;
    exports.getTypedArrayTypeFromGLType = getTypedArrayTypeFromGLType;
    exports.grad1 = grad1;
    exports.grad2 = grad2;
    exports.grad3 = grad3;
    exports.grad4 = grad4;
    exports.graphicDynamicCompute = graphicDynamicCompute;
    exports.graphicFaceCompute = graphicFaceCompute;
    exports.graphicFaceCompute2 = graphicFaceCompute2;
    exports.graphicTrailCompute = graphicTrailCompute;
    exports.i32 = i32;
    exports.integrateSegment = integrateSegment;
    exports.irradianceDataReader = irradianceDataReader;
    exports.kPI = kPI;
    exports.lerp = lerp;
    exports.lerpByte = lerpByte;
    exports.lerpColor = lerpColor;
    exports.lerpVector3 = lerpVector3;
    exports.magnitude = magnitude;
    exports.makeAloneSprite = makeAloneSprite;
    exports.makeGUISprite = makeGUISprite;
    exports.makeMatrix44 = makeMatrix44;
    exports.matrixMultiply = matrixMultiply;
    exports.matrixRotate = matrixRotate;
    exports.matrixRotateY = matrixRotateY;
    exports.mergeFunctions = mergeFunctions;
    exports.multiplyMatrices4x4REF = multiplyMatrices4x4REF;
    exports.normal_distribution = normal_distribution;
    exports.normalizeFast = normalizeFast;
    exports.normalizeSafe = normalizeSafe;
    exports.normalizedToByte = normalizedToByte;
    exports.normalizedToWord = normalizedToWord;
    exports.outlinePostData = outlinePostData;
    exports.outlinePostManager = outlinePostManager;
    exports.perm = perm;
    exports.post = post;
    exports.quadraticPolynomialRootsGeneric = quadraticPolynomialRootsGeneric;
    exports.rad2Deg = rad2Deg;
    exports.random01 = random01;
    exports.randomBarycentricCoord = randomBarycentricCoord;
    exports.randomPointBetweenEllipsoid = randomPointBetweenEllipsoid;
    exports.randomPointBetweenSphere = randomPointBetweenSphere;
    exports.randomPointInsideCube = randomPointInsideCube;
    exports.randomPointInsideEllipsoid = randomPointInsideEllipsoid;
    exports.randomPointInsideUnitCircle = randomPointInsideUnitCircle;
    exports.randomPointInsideUnitSphere = randomPointInsideUnitSphere;
    exports.randomQuaternion = randomQuaternion;
    exports.randomQuaternionUniformDistribution = randomQuaternionUniformDistribution;
    exports.randomUnitVector = randomUnitVector;
    exports.randomUnitVector2 = randomUnitVector2;
    exports.rangedRandomFloat = rangedRandomFloat;
    exports.rangedRandomInt = rangedRandomInt;
    exports.readMagicBytes = readMagicBytes;
    exports.registerMaterial = registerMaterial;
    exports.repeat = repeat;
    exports.rotMatrix = rotMatrix;
    exports.rotateVectorByQuat = rotateVectorByQuat;
    exports.roundfToIntPos = roundfToIntPos;
    exports.scale = scale;
    exports.shadowCastMap_frag = shadowCastMap_frag;
    exports.shadowCastMap_vert = shadowCastMap_vert;
    exports.simplex = simplex;
    exports.sin = sin;
    exports.snoise1 = snoise1;
    exports.snoise2 = snoise2;
    exports.snoise3 = snoise3;
    exports.snoise4 = snoise4;
    exports.sqrMagnitude = sqrMagnitude;
    exports.sqrtImpl = sqrtImpl;
    exports.stencilStateFace = stencilStateFace;
    exports.swap = swap;
    exports.threshold = threshold;
    exports.toHalfFloat = toHalfFloat;
    exports.u32 = u32;
    exports.uniform_real_distribution = uniform_real_distribution;
    exports.uniform_real_distribution2 = uniform_real_distribution2;
    exports.upSample = upSample;
    exports.webGPUContext = webGPUContext;
    exports.zSorterUtil = zSorterUtil;

    Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

}));
