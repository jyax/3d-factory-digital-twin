"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  WeakRef: true,
  Int64: true,
  Helpers: true,
  Logger: true,
  ConstTableRef: true,
  TableRef: true,
  Obj: true,
  Transaction: true,
  ObjectStore: true,
  Timestamp: true,
  Geospatial: true,
  ObjLink: true,
  KeyPathMapping: true,
  Query: true,
  SortDescriptor: true,
  TableView: true,
  Results: true,
  Realm: true,
  RealmCoordinator: true,
  ObjectNotifier: true,
  NotificationToken: true,
  IndexSet: true,
  Collection: true,
  List: true,
  Set: true,
  Dictionary: true,
  GoogleAuthCode: true,
  GoogleIdToken: true,
  AppCredentials: true,
  SyncUserSubscriptionToken: true,
  SyncUser: true,
  UserProfile: true,
  AppSubscriptionToken: true,
  App: true,
  WatchStream: true,
  PushClient: true,
  UsernamePasswordProviderClient: true,
  UserApiKeyProviderClient: true,
  LoggerFactory: true,
  SyncManager: true,
  ThreadSafeReference: true,
  AsyncOpenTask: true,
  SyncSession: true,
  SslVerifyCallback: true,
  SyncSubscriptionSet: true,
  MutableSyncSubscriptionSet: true,
  Scheduler: true,
  GenericNetworkTransport: true,
  JsPlatformHelpers: true,
  WeakSyncSession: true
};
exports.WeakSyncSession = exports.WeakRef = exports.WatchStream = exports.UsernamePasswordProviderClient = exports.UserProfile = exports.UserApiKeyProviderClient = exports.Transaction = exports.Timestamp = exports.ThreadSafeReference = exports.TableView = exports.TableRef = exports.SyncUserSubscriptionToken = exports.SyncUser = exports.SyncSubscriptionSet = exports.SyncSession = exports.SyncManager = exports.SslVerifyCallback = exports.SortDescriptor = exports.Set = exports.Scheduler = exports.Results = exports.RealmCoordinator = exports.Realm = exports.Query = exports.PushClient = exports.ObjectStore = exports.ObjectNotifier = exports.ObjLink = exports.Obj = exports.NotificationToken = exports.MutableSyncSubscriptionSet = exports.LoggerFactory = exports.Logger = exports.List = exports.KeyPathMapping = exports.JsPlatformHelpers = exports.Int64 = exports.IndexSet = exports.Helpers = exports.GoogleIdToken = exports.GoogleAuthCode = exports.Geospatial = exports.GenericNetworkTransport = exports.Dictionary = exports.ConstTableRef = exports.Collection = exports.AsyncOpenTask = exports.AppSubscriptionToken = exports.AppCredentials = exports.App = void 0;
var _bson = require("bson");
var _core = require("../dist/core");
Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _core[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _core[key];
    }
  });
});
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2024 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////

/* eslint-disable @typescript-eslint/no-var-requires */
/* global global, require */
const nativeModule = require("#realm.node");
if (!nativeModule) {
  throw new Error("Could not find the Realm binary. Please consult our troubleshooting guide: https://www.mongodb.com/docs/realm-sdks/js/latest/#md:troubleshooting-missing-binary");
}

// We know that node always has real WeakRefs so just use them.
const WeakRef = exports.WeakRef = global.WeakRef;
const NativeBigIntSupport = Object.freeze({
  add(a, b) {
    return a + b;
  },
  equals(a, b) {
    return a == b;
  },
  // using == rather than === to support number and string RHS!
  isInt(a) {
    return typeof a === "bigint";
  },
  numToInt(a) {
    return BigInt(a);
  },
  strToInt(a) {
    return BigInt(a);
  },
  intToNum(a) {
    return Number(a);
  }
});
const Int64 = exports.Int64 = NativeBigIntSupport; // Node always supports BigInt

// Copied from lib/utils.js.
// TODO consider importing instead.
// Might be slightly faster to make dedicated wrapper for 1 and 2 argument forms, but unlikely to be worth it.
function _promisify(nullAllowed, func) {
  return new Promise((resolve, reject) => {
    func((...cbargs) => {
      // Any errors in this function should flow into the Promise chain, rather than out to the caller,
      // since callers of async callbacks aren't expecting exceptions.
      try {
        if (cbargs.length < 1 || cbargs.length > 2) throw Error("invalid cbargs length " + cbargs.length);
        let error = cbargs[cbargs.length - 1];
        if (error) {
          reject(error);
        } else if (cbargs.length == 2) {
          const result = cbargs[0];
          if (!nullAllowed && (result === null || result === undefined)) {
            throw new Error("Unexpected null or undefined successful result");
          }
          resolve(result);
        } else {
          resolve();
        }
      } catch (err) {
        reject(err);
      }
    });
  });
}
const _Helpers_Symbol = Symbol("Realm.Helpers.external_pointer");
const _native_Helpers_get_table = nativeModule.Helpers_get_table;
const _native_Helpers_get_keypath_mapping = nativeModule.Helpers_get_keypath_mapping;
const _native_Helpers_results_append_query = nativeModule.Helpers_results_append_query;
const _native_Helpers_make_object_notifier = nativeModule.Helpers_make_object_notifier;
const _native_Helpers_set_binding_context = nativeModule.Helpers_set_binding_context;
const _native_Helpers_get_or_create_object_with_primary_key = nativeModule.Helpers_get_or_create_object_with_primary_key;
const _native_Helpers_make_network_transport = nativeModule.Helpers_make_network_transport;
const _native_Helpers_delete_data_for_object = nativeModule.Helpers_delete_data_for_object;
const _native_Helpers_base64_decode = nativeModule.Helpers_base64_decode;
const _native_Helpers_make_logger_factory = nativeModule.Helpers_make_logger_factory;
const _native_Helpers_make_logger = nativeModule.Helpers_make_logger;
const _native_Helpers_simulate_sync_error = nativeModule.Helpers_simulate_sync_error;
const _native_Helpers_consume_thread_safe_reference_to_shared_realm = nativeModule.Helpers_consume_thread_safe_reference_to_shared_realm;
const _native_Helpers_file_exists = nativeModule.Helpers_file_exists;
const _native_Helpers_erase_subscription = nativeModule.Helpers_erase_subscription;
const _native_Helpers_get_results_description = nativeModule.Helpers_get_results_description;
const _native_Helpers_feed_buffer = nativeModule.Helpers_feed_buffer;
const _native_Helpers_make_ssl_verify_callback = nativeModule.Helpers_make_ssl_verify_callback;
class Helpers {
  constructor(ptr) {
    this[_Helpers_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Helpers)) throw new TypeError("Expected a Helpers");
    const out = self[_Helpers_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Helpers");
    return out;
  }
  static getTable(r, key) {
    return _native_Helpers_get_table(r, key);
  }
  static getKeypathMapping(r) {
    return _native_Helpers_get_keypath_mapping(r);
  }
  static resultsAppendQuery(results, query) {
    return _native_Helpers_results_append_query(results, query);
  }
  static makeObjectNotifier(r, o) {
    return _native_Helpers_make_object_notifier(r, o);
  }
  static setBindingContext(r, methods) {
    return _native_Helpers_set_binding_context(r, methods);
  }
  static getOrCreateObjectWithPrimaryKey(t, pk) {
    return _native_Helpers_get_or_create_object_with_primary_key(t, pk);
  }
  static makeNetworkTransport(runRequest) {
    return _native_Helpers_make_network_transport(runRequest);
  }
  static deleteDataForObject(realm, object_type) {
    return _native_Helpers_delete_data_for_object(realm, object_type);
  }
  static base64Decode(input) {
    return _native_Helpers_base64_decode(input);
  }
  static makeLoggerFactory(log) {
    return _native_Helpers_make_logger_factory(log);
  }
  static makeLogger(log) {
    return _native_Helpers_make_logger(log);
  }
  static simulateSyncError(session, code, message, type, is_fatal) {
    return _native_Helpers_simulate_sync_error(session, code, message, type, is_fatal);
  }
  static consumeThreadSafeReferenceToSharedRealm(tsr) {
    return _native_Helpers_consume_thread_safe_reference_to_shared_realm(tsr);
  }
  static fileExists(path) {
    return _native_Helpers_file_exists(path);
  }
  static eraseSubscription(subs, sub_to_remove) {
    return _native_Helpers_erase_subscription(subs, sub_to_remove);
  }
  static getResultsDescription(results) {
    return _native_Helpers_get_results_description(results);
  }
  static feedBuffer(ws, buffer) {
    return _native_Helpers_feed_buffer(ws, buffer);
  }
  static makeSslVerifyCallback(callback) {
    return _native_Helpers_make_ssl_verify_callback(callback);
  }
}
exports.Helpers = Helpers;
const _Logger_Symbol = Symbol("Realm.Logger.external_pointer");
const _native_Logger_set_default_logger = nativeModule.Logger_set_default_logger;
const _native_Logger_set_default_level_threshold = nativeModule.Logger_set_default_level_threshold;
class Logger {
  constructor(ptr) {
    this[_Logger_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Logger)) throw new TypeError("Expected a Logger");
    const out = self[_Logger_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Logger");
    return out;
  }
  static setDefaultLogger(logger) {
    return _native_Logger_set_default_logger(logger);
  }
  static setDefaultLevelThreshold(level) {
    return _native_Logger_set_default_level_threshold(level);
  }
}
exports.Logger = Logger;
const _ConstTableRef_Symbol = Symbol("Realm.ConstTableRef.external_pointer");
const _native_ConstTableRef_get_column_type = nativeModule.ConstTableRef_get_column_type;
const _native_ConstTableRef_get_link_target = nativeModule.ConstTableRef_get_link_target;
const _native_ConstTableRef_get_object = nativeModule.ConstTableRef_get_object;
const _native_ConstTableRef_try_get_object = nativeModule.ConstTableRef_try_get_object;
const _native_ConstTableRef_query = nativeModule.ConstTableRef_query;
const _native_ConstTableRef_find_primary_key = nativeModule.ConstTableRef_find_primary_key;
const _native_ConstTableRef_get_key = nativeModule.ConstTableRef_get_key;
const _native_ConstTableRef_Symbol_iterator = nativeModule.ConstTableRef_Symbol_iterator;
class ConstTableRef {
  constructor(ptr) {
    this[_ConstTableRef_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ConstTableRef)) throw new TypeError("Expected a ConstTableRef");
    const out = self[_ConstTableRef_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ConstTableRef");
    return out;
  }
  getColumnType(column) {
    return _native_ConstTableRef_get_column_type(this[_ConstTableRef_Symbol], column);
  }
  getLinkTarget(column) {
    return _native_ConstTableRef_get_link_target(this[_ConstTableRef_Symbol], column);
  }
  getObject(key) {
    return _native_ConstTableRef_get_object(this[_ConstTableRef_Symbol], key);
  }
  tryGetObject(key) {
    return _native_ConstTableRef_try_get_object(this[_ConstTableRef_Symbol], key);
  }
  query(query_string, args, mapping) {
    return _native_ConstTableRef_query(this[_ConstTableRef_Symbol], query_string, args, mapping);
  }
  findPrimaryKey(pk) {
    return _native_ConstTableRef_find_primary_key(this[_ConstTableRef_Symbol], pk);
  }
  get key() {
    return _native_ConstTableRef_get_key(this[_ConstTableRef_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_ConstTableRef_Symbol_iterator(this[_ConstTableRef_Symbol]);
  }
}
exports.ConstTableRef = ConstTableRef;
const _native_TableRef_create_object = nativeModule.TableRef_create_object;
const _native_TableRef_remove_object = nativeModule.TableRef_remove_object;
const _native_TableRef_get_link_target = nativeModule.TableRef_get_link_target;
const _native_TableRef_clear = nativeModule.TableRef_clear;
const _native_TableRef_get_primary_key_column = nativeModule.TableRef_get_primary_key_column;
class TableRef extends ConstTableRef {
  static _extract(self) {
    if (!(self instanceof TableRef)) throw new TypeError("Expected a TableRef");
    const out = self[_ConstTableRef_Symbol];
    if (!out) throw new TypeError("received an improperly constructed TableRef");
    return out;
  }
  createObject() {
    return _native_TableRef_create_object(this[_ConstTableRef_Symbol]);
  }
  removeObject(key) {
    return _native_TableRef_remove_object(this[_ConstTableRef_Symbol], key);
  }
  getLinkTarget(column) {
    return _native_TableRef_get_link_target(this[_ConstTableRef_Symbol], column);
  }
  clear() {
    return _native_TableRef_clear(this[_ConstTableRef_Symbol]);
  }
  getPrimaryKeyColumn() {
    return _native_TableRef_get_primary_key_column(this[_ConstTableRef_Symbol]);
  }
}
exports.TableRef = TableRef;
const _Obj_Symbol = Symbol("Realm.Obj.external_pointer");
const _native_Obj_get_any = nativeModule.Obj_get_any;
const _native_Obj_set_any = nativeModule.Obj_set_any;
const _native_Obj_get_linked_object = nativeModule.Obj_get_linked_object;
const _native_Obj_get_backlink_count = nativeModule.Obj_get_backlink_count;
const _native_Obj_get_backlink_view = nativeModule.Obj_get_backlink_view;
const _native_Obj_create_and_set_linked_object = nativeModule.Obj_create_and_set_linked_object;
const _native_Obj_is_valid = nativeModule.Obj_is_valid;
const _native_Obj_get_table = nativeModule.Obj_get_table;
const _native_Obj_get_key = nativeModule.Obj_get_key;
class Obj {
  constructor(ptr) {
    this[_Obj_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Obj)) throw new TypeError("Expected a Obj");
    const out = self[_Obj_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Obj");
    return out;
  }
  getAny(column) {
    return _native_Obj_get_any(this[_Obj_Symbol], column);
  }
  setAny(column, value) {
    return _native_Obj_set_any(this[_Obj_Symbol], column, value);
  }
  getLinkedObject(column) {
    return _native_Obj_get_linked_object(this[_Obj_Symbol], column);
  }
  getBacklinkCount() {
    return _native_Obj_get_backlink_count(this[_Obj_Symbol]);
  }
  getBacklinkView(src_table, src_col_key) {
    return _native_Obj_get_backlink_view(this[_Obj_Symbol], src_table, src_col_key);
  }
  createAndSetLinkedObject(column) {
    return _native_Obj_create_and_set_linked_object(this[_Obj_Symbol], column);
  }
  get isValid() {
    return _native_Obj_is_valid(this[_Obj_Symbol]);
  }
  get table() {
    return _native_Obj_get_table(this[_Obj_Symbol]);
  }
  get key() {
    return _native_Obj_get_key(this[_Obj_Symbol]);
  }
}
exports.Obj = Obj;
const _Transaction_Symbol = Symbol("Realm.Transaction.external_pointer");
class Transaction {
  constructor(ptr) {
    this[_Transaction_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Transaction)) throw new TypeError("Expected a Transaction");
    const out = self[_Transaction_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Transaction");
    return out;
  }
}
exports.Transaction = Transaction;
const _ObjectStore_Symbol = Symbol("Realm.ObjectStore.external_pointer");
class ObjectStore {
  constructor(ptr) {
    this[_ObjectStore_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjectStore)) throw new TypeError("Expected a ObjectStore");
    const out = self[_ObjectStore_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjectStore");
    return out;
  }
}
exports.ObjectStore = ObjectStore;
const _Timestamp_Symbol = Symbol("Realm.Timestamp.external_pointer");
const _native_Timestamp_make = nativeModule.Timestamp_make;
const _native_Timestamp_get_seconds = nativeModule.Timestamp_get_seconds;
const _native_Timestamp_get_nanoseconds = nativeModule.Timestamp_get_nanoseconds;
class Timestamp {
  constructor(ptr) {
    this[_Timestamp_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Timestamp)) throw new TypeError("Expected a Timestamp");
    const out = self[_Timestamp_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Timestamp");
    return out;
  }
  static make(seconds, nanoseconds) {
    return _native_Timestamp_make(seconds, nanoseconds);
  }
  get seconds() {
    return _native_Timestamp_get_seconds(this[_Timestamp_Symbol]);
  }
  get nanoseconds() {
    return _native_Timestamp_get_nanoseconds(this[_Timestamp_Symbol]);
  }
}
exports.Timestamp = Timestamp;
const _Geospatial_Symbol = Symbol("Realm.Geospatial.external_pointer");
const _native_Geospatial_make_from_circle = nativeModule.Geospatial_make_from_circle;
const _native_Geospatial_make_from_box = nativeModule.Geospatial_make_from_box;
const _native_Geospatial_make_from_polygon = nativeModule.Geospatial_make_from_polygon;
class Geospatial {
  constructor(ptr) {
    this[_Geospatial_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Geospatial)) throw new TypeError("Expected a Geospatial");
    const out = self[_Geospatial_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Geospatial");
    return out;
  }
  static makeFromCircle(circle) {
    return _native_Geospatial_make_from_circle(circle);
  }
  static makeFromBox(box) {
    return _native_Geospatial_make_from_box(box);
  }
  static makeFromPolygon(polygon) {
    return _native_Geospatial_make_from_polygon(polygon);
  }
}
exports.Geospatial = Geospatial;
const _ObjLink_Symbol = Symbol("Realm.ObjLink.external_pointer");
const _native_ObjLink_get_table_key = nativeModule.ObjLink_get_table_key;
const _native_ObjLink_get_obj_key = nativeModule.ObjLink_get_obj_key;
class ObjLink {
  constructor(ptr) {
    this[_ObjLink_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjLink)) throw new TypeError("Expected a ObjLink");
    const out = self[_ObjLink_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjLink");
    return out;
  }
  get tableKey() {
    return _native_ObjLink_get_table_key(this[_ObjLink_Symbol]);
  }
  get objKey() {
    return _native_ObjLink_get_obj_key(this[_ObjLink_Symbol]);
  }
}
exports.ObjLink = ObjLink;
const _KeyPathMapping_Symbol = Symbol("Realm.KeyPathMapping.external_pointer");
class KeyPathMapping {
  constructor(ptr) {
    this[_KeyPathMapping_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof KeyPathMapping)) throw new TypeError("Expected a KeyPathMapping");
    const out = self[_KeyPathMapping_Symbol];
    if (!out) throw new TypeError("received an improperly constructed KeyPathMapping");
    return out;
  }
}
exports.KeyPathMapping = KeyPathMapping;
const _Query_Symbol = Symbol("Realm.Query.external_pointer");
const _native_Query_get_table = nativeModule.Query_get_table;
const _native_Query_get_description = nativeModule.Query_get_description;
class Query {
  constructor(ptr) {
    this[_Query_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Query)) throw new TypeError("Expected a Query");
    const out = self[_Query_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Query");
    return out;
  }
  get table() {
    return _native_Query_get_table(this[_Query_Symbol]);
  }
  get description() {
    return _native_Query_get_description(this[_Query_Symbol]);
  }
}
exports.Query = Query;
const _SortDescriptor_Symbol = Symbol("Realm.SortDescriptor.external_pointer");
class SortDescriptor {
  constructor(ptr) {
    this[_SortDescriptor_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SortDescriptor)) throw new TypeError("Expected a SortDescriptor");
    const out = self[_SortDescriptor_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SortDescriptor");
    return out;
  }
}
exports.SortDescriptor = SortDescriptor;
const _TableView_Symbol = Symbol("Realm.TableView.external_pointer");
class TableView {
  constructor(ptr) {
    this[_TableView_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof TableView)) throw new TypeError("Expected a TableView");
    const out = self[_TableView_Symbol];
    if (!out) throw new TypeError("received an improperly constructed TableView");
    return out;
  }
}
exports.TableView = TableView;
const _Results_Symbol = Symbol("Realm.Results.external_pointer");
const _native_Results_size = nativeModule.Results_size;
const _native_Results_index_of = nativeModule.Results_index_of;
const _native_Results_index_of_obj = nativeModule.Results_index_of_obj;
const _native_Results_get_obj = nativeModule.Results_get_obj;
const _native_Results_get_any = nativeModule.Results_get_any;
const _native_Results_sort_by_names = nativeModule.Results_sort_by_names;
const _native_Results_snapshot = nativeModule.Results_snapshot;
const _native_Results_max = nativeModule.Results_max;
const _native_Results_min = nativeModule.Results_min;
const _native_Results_average = nativeModule.Results_average;
const _native_Results_sum = nativeModule.Results_sum;
const _native_Results_clear = nativeModule.Results_clear;
const _native_Results_add_notification_callback = nativeModule.Results_add_notification_callback;
const _native_Results_from_table = nativeModule.Results_from_table;
const _native_Results_from_table_view = nativeModule.Results_from_table_view;
const _native_Results_is_valid = nativeModule.Results_is_valid;
const _native_Results_get_query = nativeModule.Results_get_query;
const _native_Results_get_object_type = nativeModule.Results_get_object_type;
const _native_Results_get_type = nativeModule.Results_get_type;
class Results {
  constructor(ptr) {
    this[_Results_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Results)) throw new TypeError("Expected a Results");
    const out = self[_Results_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Results");
    return out;
  }
  size() {
    return _native_Results_size(this[_Results_Symbol]);
  }
  indexOf(value) {
    return _native_Results_index_of(this[_Results_Symbol], value);
  }
  indexOfObj(obj) {
    return _native_Results_index_of_obj(this[_Results_Symbol], obj);
  }
  getObj(index) {
    return _native_Results_get_obj(this[_Results_Symbol], index);
  }
  getAny(index) {
    return _native_Results_get_any(this[_Results_Symbol], index);
  }
  sortByNames(order) {
    return _native_Results_sort_by_names(this[_Results_Symbol], order);
  }
  snapshot() {
    return _native_Results_snapshot(this[_Results_Symbol]);
  }
  max(column) {
    return _native_Results_max(this[_Results_Symbol], column);
  }
  min(column) {
    return _native_Results_min(this[_Results_Symbol], column);
  }
  average(column) {
    return _native_Results_average(this[_Results_Symbol], column);
  }
  sum(column) {
    return _native_Results_sum(this[_Results_Symbol], column);
  }
  clear() {
    return _native_Results_clear(this[_Results_Symbol]);
  }
  addNotificationCallback(cb, keyPaths) {
    return _native_Results_add_notification_callback(this[_Results_Symbol], cb, keyPaths);
  }
  static fromTable(r, table) {
    return _native_Results_from_table(r, table);
  }
  static fromTableView(r, table) {
    return _native_Results_from_table_view(r, table);
  }
  get isValid() {
    return _native_Results_is_valid(this[_Results_Symbol]);
  }
  get query() {
    return _native_Results_get_query(this[_Results_Symbol]);
  }
  get objectType() {
    return _native_Results_get_object_type(this[_Results_Symbol]);
  }
  get type() {
    return _native_Results_get_type(this[_Results_Symbol]);
  }
}
exports.Results = Results;
const _Realm_Symbol = Symbol("Realm.Realm.external_pointer");
const _native_Realm_begin_transaction = nativeModule.Realm_begin_transaction;
const _native_Realm_commit_transaction = nativeModule.Realm_commit_transaction;
const _native_Realm_cancel_transaction = nativeModule.Realm_cancel_transaction;
const _native_Realm_update_schema = nativeModule.Realm_update_schema;
const _native_Realm_compact = nativeModule.Realm_compact;
const _native_Realm_convert = nativeModule.Realm_convert;
const _native_Realm_verify_open = nativeModule.Realm_verify_open;
const _native_Realm_create_key_path_array = nativeModule.Realm_create_key_path_array;
const _native_Realm_close = nativeModule.Realm_close;
const _native_Realm_get_shared_realm = nativeModule.Realm_get_shared_realm;
const _native_Realm_get_synchronized_realm = nativeModule.Realm_get_synchronized_realm;
const _native_Realm_get_schema_version = nativeModule.Realm_get_schema_version;
const _native_Realm_config = nativeModule.Realm_config;
const _native_Realm_schema = nativeModule.Realm_schema;
const _native_Realm_schema_version = nativeModule.Realm_schema_version;
const _native_Realm_is_in_transaction = nativeModule.Realm_is_in_transaction;
const _native_Realm_is_in_migration = nativeModule.Realm_is_in_migration;
const _native_Realm_is_empty = nativeModule.Realm_is_empty;
const _native_Realm_is_closed = nativeModule.Realm_is_closed;
const _native_Realm_sync_session = nativeModule.Realm_sync_session;
const _native_Realm_get_latest_subscription_set = nativeModule.Realm_get_latest_subscription_set;
const _native_Realm_DOLLAR_addr = nativeModule.Realm_DOLLAR_addr;
const _native_Realm_DOLLAR_resetSharedPtr = nativeModule.Realm_DOLLAR_resetSharedPtr;
class Realm {
  constructor(ptr) {
    this[_Realm_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Realm)) throw new TypeError("Expected a Realm");
    const out = self[_Realm_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Realm");
    return out;
  }
  beginTransaction() {
    return _native_Realm_begin_transaction(this[_Realm_Symbol]);
  }
  commitTransaction() {
    return _native_Realm_commit_transaction(this[_Realm_Symbol]);
  }
  cancelTransaction() {
    return _native_Realm_cancel_transaction(this[_Realm_Symbol]);
  }
  updateSchema(schema, version, migration_function, initialization_function, in_transaction) {
    return _native_Realm_update_schema(this[_Realm_Symbol], schema, version, migration_function, initialization_function, in_transaction);
  }
  compact() {
    return _native_Realm_compact(this[_Realm_Symbol]);
  }
  convert(config) {
    return _native_Realm_convert(this[_Realm_Symbol], config);
  }
  verifyOpen() {
    return _native_Realm_verify_open(this[_Realm_Symbol]);
  }
  createKeyPathArray(table_name, key_paths) {
    return _native_Realm_create_key_path_array(this[_Realm_Symbol], table_name, key_paths);
  }
  close() {
    return _native_Realm_close(this[_Realm_Symbol]);
  }
  static getSharedRealm(config) {
    return _native_Realm_get_shared_realm(config);
  }
  static getSynchronizedRealm(config) {
    return _native_Realm_get_synchronized_realm(config);
  }
  static getSchemaVersion(config) {
    return _native_Realm_get_schema_version(config);
  }
  get config() {
    return _native_Realm_config(this[_Realm_Symbol]);
  }
  get schema() {
    return _native_Realm_schema(this[_Realm_Symbol]);
  }
  get schemaVersion() {
    return _native_Realm_schema_version(this[_Realm_Symbol]);
  }
  get isInTransaction() {
    return _native_Realm_is_in_transaction(this[_Realm_Symbol]);
  }
  get isInMigration() {
    return _native_Realm_is_in_migration(this[_Realm_Symbol]);
  }
  get isEmpty() {
    return _native_Realm_is_empty(this[_Realm_Symbol]);
  }
  get isClosed() {
    return _native_Realm_is_closed(this[_Realm_Symbol]);
  }
  get syncSession() {
    return _native_Realm_sync_session(this[_Realm_Symbol]);
  }
  get latestSubscriptionSet() {
    return _native_Realm_get_latest_subscription_set(this[_Realm_Symbol]);
  }
  get $addr() {
    return _native_Realm_DOLLAR_addr(this[_Realm_Symbol]);
  }
  $resetSharedPtr() {
    return _native_Realm_DOLLAR_resetSharedPtr(this[_Realm_Symbol]);
  }
}
exports.Realm = Realm;
const _RealmCoordinator_Symbol = Symbol("Realm.RealmCoordinator.external_pointer");
const _native_RealmCoordinator_clear_all_caches = nativeModule.RealmCoordinator_clear_all_caches;
class RealmCoordinator {
  constructor(ptr) {
    this[_RealmCoordinator_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof RealmCoordinator)) throw new TypeError("Expected a RealmCoordinator");
    const out = self[_RealmCoordinator_Symbol];
    if (!out) throw new TypeError("received an improperly constructed RealmCoordinator");
    return out;
  }
  static clearAllCaches() {
    return _native_RealmCoordinator_clear_all_caches();
  }
}
exports.RealmCoordinator = RealmCoordinator;
const _ObjectNotifier_Symbol = Symbol("Realm.ObjectNotifier.external_pointer");
const _native_ObjectNotifier_add_callback = nativeModule.ObjectNotifier_add_callback;
class ObjectNotifier {
  constructor(ptr) {
    this[_ObjectNotifier_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjectNotifier)) throw new TypeError("Expected a ObjectNotifier");
    const out = self[_ObjectNotifier_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjectNotifier");
    return out;
  }
  addCallback(cb, keyPaths) {
    return _native_ObjectNotifier_add_callback(this[_ObjectNotifier_Symbol], cb, keyPaths);
  }
}
exports.ObjectNotifier = ObjectNotifier;
const _NotificationToken_Symbol = Symbol("Realm.NotificationToken.external_pointer");
const _native_NotificationToken_unregister = nativeModule.NotificationToken_unregister;
const _native_NotificationToken_for_object = nativeModule.NotificationToken_for_object;
class NotificationToken {
  constructor(ptr) {
    this[_NotificationToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof NotificationToken)) throw new TypeError("Expected a NotificationToken");
    const out = self[_NotificationToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed NotificationToken");
    return out;
  }
  unregister() {
    return _native_NotificationToken_unregister(this[_NotificationToken_Symbol]);
  }
  static forObject(notifier, token) {
    return _native_NotificationToken_for_object(notifier, token);
  }
}
exports.NotificationToken = NotificationToken;
const _IndexSet_Symbol = Symbol("Realm.IndexSet.external_pointer");
const _native_IndexSet_Symbol_iterator = nativeModule.IndexSet_Symbol_iterator;
class IndexSet {
  constructor(ptr) {
    this[_IndexSet_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof IndexSet)) throw new TypeError("Expected a IndexSet");
    const out = self[_IndexSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed IndexSet");
    return out;
  }
  [Symbol.iterator]() {
    return _native_IndexSet_Symbol_iterator(this[_IndexSet_Symbol]);
  }
}
exports.IndexSet = IndexSet;
const _Collection_Symbol = Symbol("Realm.Collection.external_pointer");
const _native_Collection_get_any = nativeModule.Collection_get_any;
const _native_Collection_as_results = nativeModule.Collection_as_results;
const _native_Collection_get_object_schema = nativeModule.Collection_get_object_schema;
const _native_Collection_size = nativeModule.Collection_size;
const _native_Collection_is_valid = nativeModule.Collection_is_valid;
class Collection {
  constructor(ptr) {
    this[_Collection_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Collection)) throw new TypeError("Expected a Collection");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Collection");
    return out;
  }
  getAny(ndx) {
    return _native_Collection_get_any(this[_Collection_Symbol], ndx);
  }
  asResults() {
    return _native_Collection_as_results(this[_Collection_Symbol]);
  }
  get objectSchema() {
    return _native_Collection_get_object_schema(this[_Collection_Symbol]);
  }
  get size() {
    return _native_Collection_size(this[_Collection_Symbol]);
  }
  get isValid() {
    return _native_Collection_is_valid(this[_Collection_Symbol]);
  }
}
exports.Collection = Collection;
const _native_List_move = nativeModule.List_move;
const _native_List_remove = nativeModule.List_remove;
const _native_List_remove_all = nativeModule.List_remove_all;
const _native_List_swap = nativeModule.List_swap;
const _native_List_delete_all = nativeModule.List_delete_all;
const _native_List_insert_any = nativeModule.List_insert_any;
const _native_List_insert_embedded = nativeModule.List_insert_embedded;
const _native_List_set_any = nativeModule.List_set_any;
const _native_List_set_embedded = nativeModule.List_set_embedded;
const _native_List_make = nativeModule.List_make;
class List extends Collection {
  static _extract(self) {
    if (!(self instanceof List)) throw new TypeError("Expected a List");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed List");
    return out;
  }
  move(source_ndx, dest_ndx) {
    return _native_List_move(this[_Collection_Symbol], source_ndx, dest_ndx);
  }
  remove(ndx) {
    return _native_List_remove(this[_Collection_Symbol], ndx);
  }
  removeAll() {
    return _native_List_remove_all(this[_Collection_Symbol]);
  }
  swap(ndx1, ndx2) {
    return _native_List_swap(this[_Collection_Symbol], ndx1, ndx2);
  }
  deleteAll() {
    return _native_List_delete_all(this[_Collection_Symbol]);
  }
  insertAny(list_ndx, value) {
    return _native_List_insert_any(this[_Collection_Symbol], list_ndx, value);
  }
  insertEmbedded(ndx) {
    return _native_List_insert_embedded(this[_Collection_Symbol], ndx);
  }
  setAny(list_ndx, value) {
    return _native_List_set_any(this[_Collection_Symbol], list_ndx, value);
  }
  setEmbedded(list_ndx) {
    return _native_List_set_embedded(this[_Collection_Symbol], list_ndx);
  }
  static make(r, parent, col) {
    return _native_List_make(r, parent, col);
  }
}
exports.List = List;
const _native_Set_insert_any = nativeModule.Set_insert_any;
const _native_Set_remove_any = nativeModule.Set_remove_any;
const _native_Set_remove_all = nativeModule.Set_remove_all;
const _native_Set_delete_all = nativeModule.Set_delete_all;
const _native_Set_make = nativeModule.Set_make;
class Set extends Collection {
  static _extract(self) {
    if (!(self instanceof Set)) throw new TypeError("Expected a Set");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Set");
    return out;
  }
  insertAny(val) {
    return _native_Set_insert_any(this[_Collection_Symbol], val);
  }
  removeAny(val) {
    return _native_Set_remove_any(this[_Collection_Symbol], val);
  }
  removeAll() {
    return _native_Set_remove_all(this[_Collection_Symbol]);
  }
  deleteAll() {
    return _native_Set_delete_all(this[_Collection_Symbol]);
  }
  static make(r, parent, col) {
    return _native_Set_make(r, parent, col);
  }
}
exports.Set = Set;
const _native_Dictionary_contains = nativeModule.Dictionary_contains;
const _native_Dictionary_add_key_based_notification_callback = nativeModule.Dictionary_add_key_based_notification_callback;
const _native_Dictionary_insert_any = nativeModule.Dictionary_insert_any;
const _native_Dictionary_insert_embedded = nativeModule.Dictionary_insert_embedded;
const _native_Dictionary_try_get_any = nativeModule.Dictionary_try_get_any;
const _native_Dictionary_remove_all = nativeModule.Dictionary_remove_all;
const _native_Dictionary_try_erase = nativeModule.Dictionary_try_erase;
const _native_Dictionary_make = nativeModule.Dictionary_make;
const _native_Dictionary_get_keys = nativeModule.Dictionary_get_keys;
const _native_Dictionary_get_values = nativeModule.Dictionary_get_values;
const _native_Dictionary_Symbol_iterator = nativeModule.Dictionary_Symbol_iterator;
class Dictionary extends Collection {
  static _extract(self) {
    if (!(self instanceof Dictionary)) throw new TypeError("Expected a Dictionary");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Dictionary");
    return out;
  }
  contains(key) {
    return _native_Dictionary_contains(this[_Collection_Symbol], key);
  }
  addKeyBasedNotificationCallback(cb, keyPaths) {
    return _native_Dictionary_add_key_based_notification_callback(this[_Collection_Symbol], cb, keyPaths);
  }
  insertAny(key, value) {
    return _native_Dictionary_insert_any(this[_Collection_Symbol], key, value);
  }
  insertEmbedded(key) {
    return _native_Dictionary_insert_embedded(this[_Collection_Symbol], key);
  }
  tryGetAny(key) {
    return _native_Dictionary_try_get_any(this[_Collection_Symbol], key);
  }
  removeAll() {
    return _native_Dictionary_remove_all(this[_Collection_Symbol]);
  }
  tryErase(key) {
    return _native_Dictionary_try_erase(this[_Collection_Symbol], key);
  }
  static make(r, parent, col) {
    return _native_Dictionary_make(r, parent, col);
  }
  get keys() {
    return _native_Dictionary_get_keys(this[_Collection_Symbol]);
  }
  get values() {
    return _native_Dictionary_get_values(this[_Collection_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_Dictionary_Symbol_iterator(this[_Collection_Symbol]);
  }
}
exports.Dictionary = Dictionary;
const _GoogleAuthCode_Symbol = Symbol("Realm.GoogleAuthCode.external_pointer");
const _native_GoogleAuthCode_make = nativeModule.GoogleAuthCode_make;
class GoogleAuthCode {
  constructor(ptr) {
    this[_GoogleAuthCode_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GoogleAuthCode)) throw new TypeError("Expected a GoogleAuthCode");
    const out = self[_GoogleAuthCode_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GoogleAuthCode");
    return out;
  }
  static make(code) {
    return _native_GoogleAuthCode_make(code);
  }
}
exports.GoogleAuthCode = GoogleAuthCode;
const _GoogleIdToken_Symbol = Symbol("Realm.GoogleIdToken.external_pointer");
const _native_GoogleIdToken_make = nativeModule.GoogleIdToken_make;
class GoogleIdToken {
  constructor(ptr) {
    this[_GoogleIdToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GoogleIdToken)) throw new TypeError("Expected a GoogleIdToken");
    const out = self[_GoogleIdToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GoogleIdToken");
    return out;
  }
  static make(token) {
    return _native_GoogleIdToken_make(token);
  }
}
exports.GoogleIdToken = GoogleIdToken;
const _AppCredentials_Symbol = Symbol("Realm.AppCredentials.external_pointer");
const _native_AppCredentials_facebook = nativeModule.AppCredentials_facebook;
const _native_AppCredentials_anonymous = nativeModule.AppCredentials_anonymous;
const _native_AppCredentials_apple = nativeModule.AppCredentials_apple;
const _native_AppCredentials_google_auth = nativeModule.AppCredentials_google_auth;
const _native_AppCredentials_google_id = nativeModule.AppCredentials_google_id;
const _native_AppCredentials_custom = nativeModule.AppCredentials_custom;
const _native_AppCredentials_username_password = nativeModule.AppCredentials_username_password;
const _native_AppCredentials_function = nativeModule.AppCredentials_function;
const _native_AppCredentials_api_key = nativeModule.AppCredentials_api_key;
class AppCredentials {
  constructor(ptr) {
    this[_AppCredentials_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AppCredentials)) throw new TypeError("Expected a AppCredentials");
    const out = self[_AppCredentials_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AppCredentials");
    return out;
  }
  static facebook(access_token) {
    return _native_AppCredentials_facebook(access_token);
  }
  static anonymous(reuse_anonymous_credentials) {
    return _native_AppCredentials_anonymous(reuse_anonymous_credentials);
  }
  static apple(id_token) {
    return _native_AppCredentials_apple(id_token);
  }
  static googleAuth(id_token) {
    return _native_AppCredentials_google_auth(id_token);
  }
  static googleId(id_token) {
    return _native_AppCredentials_google_id(id_token);
  }
  static custom(token) {
    return _native_AppCredentials_custom(token);
  }
  static usernamePassword(username, password) {
    return _native_AppCredentials_username_password(username, password);
  }
  static function(serialized_payload) {
    return _native_AppCredentials_function(serialized_payload);
  }
  static apiKey(api_key) {
    return _native_AppCredentials_api_key(api_key);
  }
}
exports.AppCredentials = AppCredentials;
const _SyncUserSubscriptionToken_Symbol = Symbol("Realm.SyncUserSubscriptionToken.external_pointer");
class SyncUserSubscriptionToken {
  constructor(ptr) {
    this[_SyncUserSubscriptionToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncUserSubscriptionToken)) throw new TypeError("Expected a SyncUserSubscriptionToken");
    const out = self[_SyncUserSubscriptionToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncUserSubscriptionToken");
    return out;
  }
}
exports.SyncUserSubscriptionToken = SyncUserSubscriptionToken;
const _SyncUser_Symbol = Symbol("Realm.SyncUser.external_pointer");
const _native_SyncUser_session_for_on_disk_path = nativeModule.SyncUser_session_for_on_disk_path;
const _native_SyncUser_subscribe = nativeModule.SyncUser_subscribe;
const _native_SyncUser_unsubscribe = nativeModule.SyncUser_unsubscribe;
const _native_SyncUser_all_sessions = nativeModule.SyncUser_all_sessions;
const _native_SyncUser_is_logged_in = nativeModule.SyncUser_is_logged_in;
const _native_SyncUser_identity = nativeModule.SyncUser_identity;
const _native_SyncUser_access_token = nativeModule.SyncUser_access_token;
const _native_SyncUser_refresh_token = nativeModule.SyncUser_refresh_token;
const _native_SyncUser_device_id = nativeModule.SyncUser_device_id;
const _native_SyncUser_user_profile = nativeModule.SyncUser_user_profile;
const _native_SyncUser_identities = nativeModule.SyncUser_identities;
const _native_SyncUser_custom_data = nativeModule.SyncUser_custom_data;
const _native_SyncUser_sync_manager = nativeModule.SyncUser_sync_manager;
const _native_SyncUser_state = nativeModule.SyncUser_state;
class SyncUser {
  constructor(ptr) {
    this[_SyncUser_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncUser)) throw new TypeError("Expected a SyncUser");
    const out = self[_SyncUser_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncUser");
    return out;
  }
  sessionForOnDiskPath(path) {
    return _native_SyncUser_session_for_on_disk_path(this[_SyncUser_Symbol], path);
  }
  subscribe(observer) {
    return _native_SyncUser_subscribe(this[_SyncUser_Symbol], observer);
  }
  unsubscribe(token) {
    return _native_SyncUser_unsubscribe(this[_SyncUser_Symbol], token);
  }
  get allSessions() {
    return _native_SyncUser_all_sessions(this[_SyncUser_Symbol]);
  }
  get isLoggedIn() {
    return _native_SyncUser_is_logged_in(this[_SyncUser_Symbol]);
  }
  get identity() {
    return _native_SyncUser_identity(this[_SyncUser_Symbol]);
  }
  get accessToken() {
    return _native_SyncUser_access_token(this[_SyncUser_Symbol]);
  }
  get refreshToken() {
    return _native_SyncUser_refresh_token(this[_SyncUser_Symbol]);
  }
  get deviceId() {
    return _native_SyncUser_device_id(this[_SyncUser_Symbol]);
  }
  get userProfile() {
    return _native_SyncUser_user_profile(this[_SyncUser_Symbol]);
  }
  get identities() {
    return _native_SyncUser_identities(this[_SyncUser_Symbol]);
  }
  get customData() {
    return _native_SyncUser_custom_data(this[_SyncUser_Symbol]);
  }
  get syncManager() {
    return _native_SyncUser_sync_manager(this[_SyncUser_Symbol]);
  }
  get state() {
    return _native_SyncUser_state(this[_SyncUser_Symbol]);
  }
}
exports.SyncUser = SyncUser;
const _UserProfile_Symbol = Symbol("Realm.UserProfile.external_pointer");
const _native_UserProfile_data = nativeModule.UserProfile_data;
class UserProfile {
  constructor(ptr) {
    this[_UserProfile_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UserProfile)) throw new TypeError("Expected a UserProfile");
    const out = self[_UserProfile_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UserProfile");
    return out;
  }
  data() {
    return _native_UserProfile_data(this[_UserProfile_Symbol]);
  }
}
exports.UserProfile = UserProfile;
const _AppSubscriptionToken_Symbol = Symbol("Realm.AppSubscriptionToken.external_pointer");
class AppSubscriptionToken {
  constructor(ptr) {
    this[_AppSubscriptionToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AppSubscriptionToken)) throw new TypeError("Expected a AppSubscriptionToken");
    const out = self[_AppSubscriptionToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AppSubscriptionToken");
    return out;
  }
}
exports.AppSubscriptionToken = AppSubscriptionToken;
const _App_Symbol = Symbol("Realm.App.external_pointer");
const _native_App_log_in_with_credentials = nativeModule.App_log_in_with_credentials;
const _native_App_log_out_user = nativeModule.App_log_out_user;
const _native_App_refresh_custom_data = nativeModule.App_refresh_custom_data;
const _native_App_link_user = nativeModule.App_link_user;
const _native_App_switch_user = nativeModule.App_switch_user;
const _native_App_remove_user = nativeModule.App_remove_user;
const _native_App_delete_user = nativeModule.App_delete_user;
const _native_App_usernamePasswordProviderClient = nativeModule.App_usernamePasswordProviderClient;
const _native_App_userAPIKeyProviderClient = nativeModule.App_userAPIKeyProviderClient;
const _native_App_push_notification_client = nativeModule.App_push_notification_client;
const _native_App_subscribe = nativeModule.App_subscribe;
const _native_App_unsubscribe = nativeModule.App_unsubscribe;
const _native_App_call_function = nativeModule.App_call_function;
const _native_App_make_streaming_request = nativeModule.App_make_streaming_request;
const _native_App_get_app = nativeModule.App_get_app;
const _native_App_clear_cached_apps = nativeModule.App_clear_cached_apps;
const _native_App_config = nativeModule.App_config;
const _native_App_current_user = nativeModule.App_current_user;
const _native_App_all_users = nativeModule.App_all_users;
const _native_App_sync_manager = nativeModule.App_sync_manager;
class App {
  constructor(ptr) {
    this[_App_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof App)) throw new TypeError("Expected a App");
    const out = self[_App_Symbol];
    if (!out) throw new TypeError("received an improperly constructed App");
    return out;
  }
  logInWithCredentials(credentials) {
    return _promisify(false, _cb => _native_App_log_in_with_credentials(this[_App_Symbol], credentials, _cb));
  }
  logOutUser(user) {
    return _promisify(false, _cb => _native_App_log_out_user(this[_App_Symbol], user, _cb));
  }
  refreshCustomData(user) {
    return _promisify(false, _cb => _native_App_refresh_custom_data(this[_App_Symbol], user, _cb));
  }
  linkUser(user, credentials) {
    return _promisify(false, _cb => _native_App_link_user(this[_App_Symbol], user, credentials, _cb));
  }
  switchUser(user) {
    return _native_App_switch_user(this[_App_Symbol], user);
  }
  removeUser(user) {
    return _promisify(false, _cb => _native_App_remove_user(this[_App_Symbol], user, _cb));
  }
  deleteUser(user) {
    return _promisify(false, _cb => _native_App_delete_user(this[_App_Symbol], user, _cb));
  }
  usernamePasswordProviderClient() {
    return _native_App_usernamePasswordProviderClient(this[_App_Symbol]);
  }
  userApiKeyProviderClient() {
    return _native_App_userAPIKeyProviderClient(this[_App_Symbol]);
  }
  pushNotificationClient(service_name) {
    return _native_App_push_notification_client(this[_App_Symbol], service_name);
  }
  subscribe(observer) {
    return _native_App_subscribe(this[_App_Symbol], observer);
  }
  unsubscribe(token) {
    return _native_App_unsubscribe(this[_App_Symbol], token);
  }
  callFunction(user, name, args, service_name) {
    return _promisify(true, _cb => _native_App_call_function(this[_App_Symbol], user, name, args, service_name, _cb));
  }
  makeStreamingRequest(user, name, args, service_name) {
    return _native_App_make_streaming_request(this[_App_Symbol], user, name, args, service_name);
  }
  static getApp(mode, config, sync_client_config) {
    return _native_App_get_app(mode, config, sync_client_config);
  }
  static clearCachedApps() {
    return _native_App_clear_cached_apps();
  }
  get config() {
    return _native_App_config(this[_App_Symbol]);
  }
  get currentUser() {
    return _native_App_current_user(this[_App_Symbol]);
  }
  get allUsers() {
    return _native_App_all_users(this[_App_Symbol]);
  }
  get syncManager() {
    return _native_App_sync_manager(this[_App_Symbol]);
  }
}
exports.App = App;
const _WatchStream_Symbol = Symbol("Realm.WatchStream.external_pointer");
const _native_WatchStream_next_event = nativeModule.WatchStream_next_event;
const _native_WatchStream_make = nativeModule.WatchStream_make;
const _native_WatchStream_state = nativeModule.WatchStream_state;
const _native_WatchStream_error = nativeModule.WatchStream_error;
class WatchStream {
  constructor(ptr) {
    this[_WatchStream_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof WatchStream)) throw new TypeError("Expected a WatchStream");
    const out = self[_WatchStream_Symbol];
    if (!out) throw new TypeError("received an improperly constructed WatchStream");
    return out;
  }
  nextEvent() {
    return _native_WatchStream_next_event(this[_WatchStream_Symbol]);
  }
  static make() {
    return _native_WatchStream_make();
  }
  get state() {
    return _native_WatchStream_state(this[_WatchStream_Symbol]);
  }
  get error() {
    return _native_WatchStream_error(this[_WatchStream_Symbol]);
  }
}
exports.WatchStream = WatchStream;
const _PushClient_Symbol = Symbol("Realm.PushClient.external_pointer");
const _native_PushClient_register_device = nativeModule.PushClient_register_device;
const _native_PushClient_deregister_device = nativeModule.PushClient_deregister_device;
class PushClient {
  constructor(ptr) {
    this[_PushClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof PushClient)) throw new TypeError("Expected a PushClient");
    const out = self[_PushClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed PushClient");
    return out;
  }
  registerDevice(registration_token, sync_user) {
    return _promisify(false, _cb => _native_PushClient_register_device(this[_PushClient_Symbol], registration_token, sync_user, _cb));
  }
  deregisterDevice(sync_user) {
    return _promisify(false, _cb => _native_PushClient_deregister_device(this[_PushClient_Symbol], sync_user, _cb));
  }
}
exports.PushClient = PushClient;
const _UsernamePasswordProviderClient_Symbol = Symbol("Realm.UsernamePasswordProviderClient.external_pointer");
const _native_UsernamePasswordProviderClient_register_email = nativeModule.UsernamePasswordProviderClient_register_email;
const _native_UsernamePasswordProviderClient_retry_custom_confirmation = nativeModule.UsernamePasswordProviderClient_retry_custom_confirmation;
const _native_UsernamePasswordProviderClient_confirm_user = nativeModule.UsernamePasswordProviderClient_confirm_user;
const _native_UsernamePasswordProviderClient_resend_confirmation_email = nativeModule.UsernamePasswordProviderClient_resend_confirmation_email;
const _native_UsernamePasswordProviderClient_reset_password = nativeModule.UsernamePasswordProviderClient_reset_password;
const _native_UsernamePasswordProviderClient_send_reset_password_email = nativeModule.UsernamePasswordProviderClient_send_reset_password_email;
const _native_UsernamePasswordProviderClient_call_reset_password_function = nativeModule.UsernamePasswordProviderClient_call_reset_password_function;
class UsernamePasswordProviderClient {
  constructor(ptr) {
    this[_UsernamePasswordProviderClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UsernamePasswordProviderClient)) throw new TypeError("Expected a UsernamePasswordProviderClient");
    const out = self[_UsernamePasswordProviderClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UsernamePasswordProviderClient");
    return out;
  }
  registerEmail(email, password) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_register_email(this[_UsernamePasswordProviderClient_Symbol], email, password, _cb));
  }
  retryCustomConfirmation(email) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_retry_custom_confirmation(this[_UsernamePasswordProviderClient_Symbol], email, _cb));
  }
  confirmUser(token, token_id) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_confirm_user(this[_UsernamePasswordProviderClient_Symbol], token, token_id, _cb));
  }
  resendConfirmationEmail(email) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_resend_confirmation_email(this[_UsernamePasswordProviderClient_Symbol], email, _cb));
  }
  resetPassword(password, token, token_id) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_reset_password(this[_UsernamePasswordProviderClient_Symbol], password, token, token_id, _cb));
  }
  sendResetPasswordEmail(email) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_send_reset_password_email(this[_UsernamePasswordProviderClient_Symbol], email, _cb));
  }
  callResetPasswordFunction(email, password, args) {
    return _promisify(false, _cb => _native_UsernamePasswordProviderClient_call_reset_password_function(this[_UsernamePasswordProviderClient_Symbol], email, password, args, _cb));
  }
}
exports.UsernamePasswordProviderClient = UsernamePasswordProviderClient;
const _UserApiKeyProviderClient_Symbol = Symbol("Realm.UserApiKeyProviderClient.external_pointer");
const _native_UserAPIKeyProviderClient_create_api_key = nativeModule.UserAPIKeyProviderClient_create_api_key;
const _native_UserAPIKeyProviderClient_fetch_api_key = nativeModule.UserAPIKeyProviderClient_fetch_api_key;
const _native_UserAPIKeyProviderClient_fetch_api_keys = nativeModule.UserAPIKeyProviderClient_fetch_api_keys;
const _native_UserAPIKeyProviderClient_delete_api_key = nativeModule.UserAPIKeyProviderClient_delete_api_key;
const _native_UserAPIKeyProviderClient_enable_api_key = nativeModule.UserAPIKeyProviderClient_enable_api_key;
const _native_UserAPIKeyProviderClient_disable_api_key = nativeModule.UserAPIKeyProviderClient_disable_api_key;
class UserApiKeyProviderClient {
  constructor(ptr) {
    this[_UserApiKeyProviderClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UserApiKeyProviderClient)) throw new TypeError("Expected a UserApiKeyProviderClient");
    const out = self[_UserApiKeyProviderClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UserApiKeyProviderClient");
    return out;
  }
  createApiKey(name, user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_create_api_key(this[_UserApiKeyProviderClient_Symbol], name, user, _cb));
  }
  fetchApiKey(id, user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_fetch_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb));
  }
  fetchApiKeys(user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_fetch_api_keys(this[_UserApiKeyProviderClient_Symbol], user, _cb));
  }
  deleteApiKey(id, user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_delete_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb));
  }
  enableApiKey(id, user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_enable_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb));
  }
  disableApiKey(id, user) {
    return _promisify(false, _cb => _native_UserAPIKeyProviderClient_disable_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb));
  }
}
exports.UserApiKeyProviderClient = UserApiKeyProviderClient;
const _LoggerFactory_Symbol = Symbol("Realm.LoggerFactory.external_pointer");
class LoggerFactory {
  constructor(ptr) {
    this[_LoggerFactory_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof LoggerFactory)) throw new TypeError("Expected a LoggerFactory");
    const out = self[_LoggerFactory_Symbol];
    if (!out) throw new TypeError("received an improperly constructed LoggerFactory");
    return out;
  }
}
exports.LoggerFactory = LoggerFactory;
const _SyncManager_Symbol = Symbol("Realm.SyncManager.external_pointer");
const _native_SyncManager_immediately_run_file_actions = nativeModule.SyncManager_immediately_run_file_actions;
const _native_SyncManager_set_session_multiplexing = nativeModule.SyncManager_set_session_multiplexing;
const _native_SyncManager_set_log_level = nativeModule.SyncManager_set_log_level;
const _native_SyncManager_set_logger_factory = nativeModule.SyncManager_set_logger_factory;
const _native_SyncManager_set_user_agent = nativeModule.SyncManager_set_user_agent;
const _native_SyncManager_reconnect = nativeModule.SyncManager_reconnect;
const _native_SyncManager_path_for_realm = nativeModule.SyncManager_path_for_realm;
const _native_SyncManager_has_existing_sessions = nativeModule.SyncManager_has_existing_sessions;
class SyncManager {
  constructor(ptr) {
    this[_SyncManager_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncManager)) throw new TypeError("Expected a SyncManager");
    const out = self[_SyncManager_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncManager");
    return out;
  }
  immediatelyRunFileActions(original_name) {
    return _native_SyncManager_immediately_run_file_actions(this[_SyncManager_Symbol], original_name);
  }
  setSessionMultiplexing(allowed) {
    return _native_SyncManager_set_session_multiplexing(this[_SyncManager_Symbol], allowed);
  }
  setLogLevel(level) {
    return _native_SyncManager_set_log_level(this[_SyncManager_Symbol], level);
  }
  setLoggerFactory(factory) {
    return _native_SyncManager_set_logger_factory(this[_SyncManager_Symbol], factory);
  }
  setUserAgent(user_agent) {
    return _native_SyncManager_set_user_agent(this[_SyncManager_Symbol], user_agent);
  }
  reconnect() {
    return _native_SyncManager_reconnect(this[_SyncManager_Symbol]);
  }
  pathForRealm(config, custom_file_name) {
    return _native_SyncManager_path_for_realm(this[_SyncManager_Symbol], config, custom_file_name);
  }
  get hasExistingSessions() {
    return _native_SyncManager_has_existing_sessions(this[_SyncManager_Symbol]);
  }
}
exports.SyncManager = SyncManager;
const _ThreadSafeReference_Symbol = Symbol("Realm.ThreadSafeReference.external_pointer");
class ThreadSafeReference {
  constructor(ptr) {
    this[_ThreadSafeReference_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ThreadSafeReference)) throw new TypeError("Expected a ThreadSafeReference");
    const out = self[_ThreadSafeReference_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ThreadSafeReference");
    return out;
  }
}
exports.ThreadSafeReference = ThreadSafeReference;
const _AsyncOpenTask_Symbol = Symbol("Realm.AsyncOpenTask.external_pointer");
const _native_AsyncOpenTask_start = nativeModule.AsyncOpenTask_start;
const _native_AsyncOpenTask_cancel = nativeModule.AsyncOpenTask_cancel;
const _native_AsyncOpenTask_register_download_progress_notifier = nativeModule.AsyncOpenTask_register_download_progress_notifier;
const _native_AsyncOpenTask_DOLLAR_resetSharedPtr = nativeModule.AsyncOpenTask_DOLLAR_resetSharedPtr;
class AsyncOpenTask {
  constructor(ptr) {
    this[_AsyncOpenTask_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AsyncOpenTask)) throw new TypeError("Expected a AsyncOpenTask");
    const out = self[_AsyncOpenTask_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AsyncOpenTask");
    return out;
  }
  start() {
    return _promisify(false, _cb => _native_AsyncOpenTask_start(this[_AsyncOpenTask_Symbol], _cb));
  }
  cancel() {
    return _native_AsyncOpenTask_cancel(this[_AsyncOpenTask_Symbol]);
  }
  registerDownloadProgressNotifier(callback) {
    return _native_AsyncOpenTask_register_download_progress_notifier(this[_AsyncOpenTask_Symbol], callback);
  }
  $resetSharedPtr() {
    return _native_AsyncOpenTask_DOLLAR_resetSharedPtr(this[_AsyncOpenTask_Symbol]);
  }
}
exports.AsyncOpenTask = AsyncOpenTask;
const _SyncSession_Symbol = Symbol("Realm.SyncSession.external_pointer");
const _native_SyncSession_wait_for_upload_completion = nativeModule.SyncSession_wait_for_upload_completion;
const _native_SyncSession_wait_for_download_completion = nativeModule.SyncSession_wait_for_download_completion;
const _native_SyncSession_register_progress_notifier = nativeModule.SyncSession_register_progress_notifier;
const _native_SyncSession_unregister_progress_notifier = nativeModule.SyncSession_unregister_progress_notifier;
const _native_SyncSession_register_connection_change_callback = nativeModule.SyncSession_register_connection_change_callback;
const _native_SyncSession_unregister_connection_change_callback = nativeModule.SyncSession_unregister_connection_change_callback;
const _native_SyncSession_revive_if_needed = nativeModule.SyncSession_revive_if_needed;
const _native_SyncSession_handle_reconnect = nativeModule.SyncSession_handle_reconnect;
const _native_SyncSession_force_close = nativeModule.SyncSession_force_close;
const _native_SyncSession_state = nativeModule.SyncSession_state;
const _native_SyncSession_connection_state = nativeModule.SyncSession_connection_state;
const _native_SyncSession_user = nativeModule.SyncSession_user;
const _native_SyncSession_config = nativeModule.SyncSession_config;
const _native_SyncSession_full_realm_url = nativeModule.SyncSession_full_realm_url;
const _native_SyncSession_DOLLAR_resetSharedPtr = nativeModule.SyncSession_DOLLAR_resetSharedPtr;
class SyncSession {
  constructor(ptr) {
    this[_SyncSession_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncSession)) throw new TypeError("Expected a SyncSession");
    const out = self[_SyncSession_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncSession");
    return out;
  }
  waitForUploadCompletion() {
    return _promisify(false, _cb => _native_SyncSession_wait_for_upload_completion(this[_SyncSession_Symbol], _cb));
  }
  waitForDownloadCompletion() {
    return _promisify(false, _cb => _native_SyncSession_wait_for_download_completion(this[_SyncSession_Symbol], _cb));
  }
  registerProgressNotifier(callback, direction, is_streaming) {
    return _native_SyncSession_register_progress_notifier(this[_SyncSession_Symbol], callback, direction, is_streaming);
  }
  unregisterProgressNotifier(token) {
    return _native_SyncSession_unregister_progress_notifier(this[_SyncSession_Symbol], token);
  }
  registerConnectionChangeCallback(callback) {
    return _native_SyncSession_register_connection_change_callback(this[_SyncSession_Symbol], callback);
  }
  unregisterConnectionChangeCallback(token) {
    return _native_SyncSession_unregister_connection_change_callback(this[_SyncSession_Symbol], token);
  }
  reviveIfNeeded() {
    return _native_SyncSession_revive_if_needed(this[_SyncSession_Symbol]);
  }
  handleReconnect() {
    return _native_SyncSession_handle_reconnect(this[_SyncSession_Symbol]);
  }
  forceClose() {
    return _native_SyncSession_force_close(this[_SyncSession_Symbol]);
  }
  get state() {
    return _native_SyncSession_state(this[_SyncSession_Symbol]);
  }
  get connectionState() {
    return _native_SyncSession_connection_state(this[_SyncSession_Symbol]);
  }
  get user() {
    return _native_SyncSession_user(this[_SyncSession_Symbol]);
  }
  get config() {
    return _native_SyncSession_config(this[_SyncSession_Symbol]);
  }
  get fullRealmUrl() {
    return _native_SyncSession_full_realm_url(this[_SyncSession_Symbol]);
  }
  $resetSharedPtr() {
    return _native_SyncSession_DOLLAR_resetSharedPtr(this[_SyncSession_Symbol]);
  }
}
exports.SyncSession = SyncSession;
const _SslVerifyCallback_Symbol = Symbol("Realm.SslVerifyCallback.external_pointer");
class SslVerifyCallback {
  constructor(ptr) {
    this[_SslVerifyCallback_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SslVerifyCallback)) throw new TypeError("Expected a SslVerifyCallback");
    const out = self[_SslVerifyCallback_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SslVerifyCallback");
    return out;
  }
}
exports.SslVerifyCallback = SslVerifyCallback;
const _SyncSubscriptionSet_Symbol = Symbol("Realm.SyncSubscriptionSet.external_pointer");
const _native_SyncSubscriptionSet_make_mutable_copy = nativeModule.SyncSubscriptionSet_make_mutable_copy;
const _native_SyncSubscriptionSet_get_state_change_notification = nativeModule.SyncSubscriptionSet_get_state_change_notification;
const _native_SyncSubscriptionSet_find_by_name = nativeModule.SyncSubscriptionSet_find_by_name;
const _native_SyncSubscriptionSet_find_by_query = nativeModule.SyncSubscriptionSet_find_by_query;
const _native_SyncSubscriptionSet_refresh = nativeModule.SyncSubscriptionSet_refresh;
const _native_SyncSubscriptionSet_version = nativeModule.SyncSubscriptionSet_version;
const _native_SyncSubscriptionSet_state = nativeModule.SyncSubscriptionSet_state;
const _native_SyncSubscriptionSet_error_str = nativeModule.SyncSubscriptionSet_error_str;
const _native_SyncSubscriptionSet_size = nativeModule.SyncSubscriptionSet_size;
const _native_SyncSubscriptionSet_Symbol_iterator = nativeModule.SyncSubscriptionSet_Symbol_iterator;
class SyncSubscriptionSet {
  constructor(ptr) {
    this[_SyncSubscriptionSet_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncSubscriptionSet)) throw new TypeError("Expected a SyncSubscriptionSet");
    const out = self[_SyncSubscriptionSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncSubscriptionSet");
    return out;
  }
  makeMutableCopy() {
    return _native_SyncSubscriptionSet_make_mutable_copy(this[_SyncSubscriptionSet_Symbol]);
  }
  getStateChangeNotification(notify_when) {
    return _promisify(false, _cb => _native_SyncSubscriptionSet_get_state_change_notification(this[_SyncSubscriptionSet_Symbol], notify_when, _cb));
  }
  findByName(name) {
    return _native_SyncSubscriptionSet_find_by_name(this[_SyncSubscriptionSet_Symbol], name);
  }
  findByQuery(query) {
    return _native_SyncSubscriptionSet_find_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }
  refresh() {
    return _native_SyncSubscriptionSet_refresh(this[_SyncSubscriptionSet_Symbol]);
  }
  get version() {
    return _native_SyncSubscriptionSet_version(this[_SyncSubscriptionSet_Symbol]);
  }
  get state() {
    return _native_SyncSubscriptionSet_state(this[_SyncSubscriptionSet_Symbol]);
  }
  get errorStr() {
    return _native_SyncSubscriptionSet_error_str(this[_SyncSubscriptionSet_Symbol]);
  }
  get size() {
    return _native_SyncSubscriptionSet_size(this[_SyncSubscriptionSet_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_SyncSubscriptionSet_Symbol_iterator(this[_SyncSubscriptionSet_Symbol]);
  }
}
exports.SyncSubscriptionSet = SyncSubscriptionSet;
const _native_MutableSyncSubscriptionSet_clear = nativeModule.MutableSyncSubscriptionSet_clear;
const _native_MutableSyncSubscriptionSet_insert_or_assign_by_name = nativeModule.MutableSyncSubscriptionSet_insert_or_assign_by_name;
const _native_MutableSyncSubscriptionSet_insert_or_assign_by_query = nativeModule.MutableSyncSubscriptionSet_insert_or_assign_by_query;
const _native_MutableSyncSubscriptionSet_erase_by_name = nativeModule.MutableSyncSubscriptionSet_erase_by_name;
const _native_MutableSyncSubscriptionSet_erase_by_query = nativeModule.MutableSyncSubscriptionSet_erase_by_query;
const _native_MutableSyncSubscriptionSet_commit = nativeModule.MutableSyncSubscriptionSet_commit;
class MutableSyncSubscriptionSet extends SyncSubscriptionSet {
  static _extract(self) {
    if (!(self instanceof MutableSyncSubscriptionSet)) throw new TypeError("Expected a MutableSyncSubscriptionSet");
    const out = self[_SyncSubscriptionSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed MutableSyncSubscriptionSet");
    return out;
  }
  clear() {
    return _native_MutableSyncSubscriptionSet_clear(this[_SyncSubscriptionSet_Symbol]);
  }
  insertOrAssignByName(name, query) {
    return _native_MutableSyncSubscriptionSet_insert_or_assign_by_name(this[_SyncSubscriptionSet_Symbol], name, query);
  }
  insertOrAssignByQuery(query) {
    return _native_MutableSyncSubscriptionSet_insert_or_assign_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }
  eraseByName(name) {
    return _native_MutableSyncSubscriptionSet_erase_by_name(this[_SyncSubscriptionSet_Symbol], name);
  }
  eraseByQuery(query) {
    return _native_MutableSyncSubscriptionSet_erase_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }
  commit() {
    return _native_MutableSyncSubscriptionSet_commit(this[_SyncSubscriptionSet_Symbol]);
  }
}
exports.MutableSyncSubscriptionSet = MutableSyncSubscriptionSet;
const _Scheduler_Symbol = Symbol("Realm.Scheduler.external_pointer");
class Scheduler {
  constructor(ptr) {
    this[_Scheduler_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Scheduler)) throw new TypeError("Expected a Scheduler");
    const out = self[_Scheduler_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Scheduler");
    return out;
  }
}
exports.Scheduler = Scheduler;
const _GenericNetworkTransport_Symbol = Symbol("Realm.GenericNetworkTransport.external_pointer");
class GenericNetworkTransport {
  constructor(ptr) {
    this[_GenericNetworkTransport_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GenericNetworkTransport)) throw new TypeError("Expected a GenericNetworkTransport");
    const out = self[_GenericNetworkTransport_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GenericNetworkTransport");
    return out;
  }
}
exports.GenericNetworkTransport = GenericNetworkTransport;
const _JsPlatformHelpers_Symbol = Symbol("Realm.JsPlatformHelpers.external_pointer");
const _native_JsPlatformHelpers_set_default_realm_file_directory = nativeModule.JsPlatformHelpers_set_default_realm_file_directory;
const _native_JsPlatformHelpers_default_realm_file_directory = nativeModule.JsPlatformHelpers_default_realm_file_directory;
const _native_JsPlatformHelpers_ensure_directory_exists_for_file = nativeModule.JsPlatformHelpers_ensure_directory_exists_for_file;
const _native_JsPlatformHelpers_copy_bundled_realm_files = nativeModule.JsPlatformHelpers_copy_bundled_realm_files;
const _native_JsPlatformHelpers_remove_realm_files_from_directory = nativeModule.JsPlatformHelpers_remove_realm_files_from_directory;
const _native_JsPlatformHelpers_remove_file = nativeModule.JsPlatformHelpers_remove_file;
const _native_JsPlatformHelpers_remove_directory = nativeModule.JsPlatformHelpers_remove_directory;
const _native_JsPlatformHelpers_get_cpu_arch = nativeModule.JsPlatformHelpers_get_cpu_arch;
class JsPlatformHelpers {
  constructor(ptr) {
    this[_JsPlatformHelpers_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof JsPlatformHelpers)) throw new TypeError("Expected a JsPlatformHelpers");
    const out = self[_JsPlatformHelpers_Symbol];
    if (!out) throw new TypeError("received an improperly constructed JsPlatformHelpers");
    return out;
  }
  static setDefaultRealmFileDirectory(dir) {
    return _native_JsPlatformHelpers_set_default_realm_file_directory(dir);
  }
  static defaultRealmFileDirectory() {
    return _native_JsPlatformHelpers_default_realm_file_directory();
  }
  static ensureDirectoryExistsForFile(file) {
    return _native_JsPlatformHelpers_ensure_directory_exists_for_file(file);
  }
  static copyBundledRealmFiles() {
    return _native_JsPlatformHelpers_copy_bundled_realm_files();
  }
  static removeRealmFilesFromDirectory(directory) {
    return _native_JsPlatformHelpers_remove_realm_files_from_directory(directory);
  }
  static removeFile(path) {
    return _native_JsPlatformHelpers_remove_file(path);
  }
  static removeDirectory(path) {
    return _native_JsPlatformHelpers_remove_directory(path);
  }
  static getCpuArch() {
    return _native_JsPlatformHelpers_get_cpu_arch();
  }
}
exports.JsPlatformHelpers = JsPlatformHelpers;
const _WeakSyncSession_Symbol = Symbol("Realm.WeakSyncSession.external_pointer");
const _native_WeakSyncSession_raw_dereference = nativeModule.WeakSyncSession_raw_dereference;
const _native_WeakSyncSession_weak_copy_of = nativeModule.WeakSyncSession_weak_copy_of;
class WeakSyncSession {
  constructor(ptr) {
    this[_WeakSyncSession_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof WeakSyncSession)) throw new TypeError("Expected a WeakSyncSession");
    const out = self[_WeakSyncSession_Symbol];
    if (!out) throw new TypeError("received an improperly constructed WeakSyncSession");
    return out;
  }
  rawDereference() {
    return _native_WeakSyncSession_raw_dereference(this[_WeakSyncSession_Symbol]);
  }
  static weakCopyOf(shared) {
    return _native_WeakSyncSession_weak_copy_of(shared);
  }
}
exports.WeakSyncSession = WeakSyncSession;
nativeModule.injectInjectables({
  Long: _bson.Long,
  ArrayBuffer,
  Float: _core.Float,
  Status: _core.Status,
  ObjectId: _bson.ObjectId,
  UUID: _bson.UUID,
  Decimal128: _bson.Decimal128,
  EJSON_parse: _bson.EJSON.parse,
  EJSON_stringify: _bson.EJSON.stringify,
  Helpers,
  Logger,
  ConstTableRef,
  TableRef,
  Obj,
  Transaction,
  ObjectStore,
  Timestamp,
  Geospatial,
  ObjLink,
  KeyPathMapping,
  Query,
  SortDescriptor,
  TableView,
  Results,
  Realm,
  RealmCoordinator,
  ObjectNotifier,
  NotificationToken,
  IndexSet,
  Collection,
  List,
  Set,
  Dictionary,
  GoogleAuthCode,
  GoogleIdToken,
  AppCredentials,
  SyncUserSubscriptionToken,
  SyncUser,
  UserProfile,
  AppSubscriptionToken,
  App,
  WatchStream,
  PushClient,
  UsernamePasswordProviderClient,
  UserApiKeyProviderClient,
  LoggerFactory,
  SyncManager,
  ThreadSafeReference,
  AsyncOpenTask,
  SyncSession,
  SslVerifyCallback,
  SyncSubscriptionSet,
  MutableSyncSubscriptionSet,
  Scheduler,
  GenericNetworkTransport,
  JsPlatformHelpers,
  WeakSyncSession
});