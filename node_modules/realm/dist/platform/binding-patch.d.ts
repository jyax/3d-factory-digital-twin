import { fetch } from "@realm/fetch";
/** @internal */
import type * as binding from "../../binding/generated/native";
type Binding = typeof binding;
/** @internal */
declare module "../../binding/generated/native" {
    /** @internal */
    interface IndexSet {
        asIndexes(): Iterator<number>;
    }
    interface Timestamp {
        toDate(): Date;
    }
    namespace Timestamp {
        function fromDate(d: Date): binding.Timestamp;
    }
    interface SyncSession {
        /** Returns a WeakSyncSession and releases the strong reference held by this SyncSession */
        weaken(): WeakSyncSession;
    }
    interface WeakSyncSession {
        /**
         * Similar to WeakRef.deref(), but takes a callback so that the strong reference can be
         * automatically released when the callback exists (either by returning or throwing).
         * It is not legal to hold on to the SyncSession after this returns because its
         * strong reference will have been deleted.
         */
        withDeref<Ret = void>(callback: (shared: SyncSession | null) => Ret): Ret;
    }
    class InvalidObjKey extends TypeError {
        constructor(input: string);
    }
    function stringToObjKey(input: string): binding.ObjKey;
    function isEmptyObjKey(objKey: binding.ObjKey): boolean;
    function toFetchArgs(request: binding.Request): Parameters<typeof fetch>;
}
/**
 * Applies SDK level patches to the binding.
 * This should only be called after the binding has been injected.
 * @internal
 */
export declare function applyPatch(binding: Binding): void;
export {};
