"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.miToRadians = exports.kmToRadians = exports.polygonToBindingGeospatial = exports.boxToBindingGeospatial = exports.circleToBindingGeospatial = void 0;
const internal_1 = require("./internal");
/** @internal */
function circleToBindingGeospatial(circle) {
    return internal_1.binding.Geospatial.makeFromCircle({
        center: toBindingGeoPoint(circle.center),
        radiusRadians: circle.distance,
    });
}
exports.circleToBindingGeospatial = circleToBindingGeospatial;
/** @internal */
function boxToBindingGeospatial(box) {
    return internal_1.binding.Geospatial.makeFromBox({
        lo: toBindingGeoPoint(box.bottomLeft),
        hi: toBindingGeoPoint(box.topRight),
    });
}
exports.boxToBindingGeospatial = boxToBindingGeospatial;
/** @internal */
function polygonToBindingGeospatial(polygon) {
    let points;
    if ("type" in polygon) {
        points = toBindingGeoPointArray(polygon.coordinates);
    }
    else {
        points = toBindingGeoPointArray([polygon.outerRing].concat(polygon.holes ?? []));
    }
    return internal_1.binding.Geospatial.makeFromPolygon({
        points,
    });
}
exports.polygonToBindingGeospatial = polygonToBindingGeospatial;
function toBindingGeoPoint(p) {
    if (Array.isArray(p)) {
        return { longitude: p[0], latitude: p[1], altitude: p[2] };
    }
    else if ("type" in p) {
        return { longitude: p.coordinates[0], latitude: p.coordinates[1], altitude: p.coordinates[2] };
    }
    else {
        return p;
    }
}
function toBindingGeoPointArray(arr) {
    return arr.map((ring) => ring.map((p) => toBindingGeoPoint(p)));
}
const earthRadiusKm = 6378.1;
const earthRadiusMi = 3963.16760121; //earthRadiusKm / 1.609344 (km/mi)
/**
 * Converts the input kilometer value in radians.
 * @param km - The kilometers to convert.
 * @returns The corresponding number of radians.
 */
function kmToRadians(km) {
    return km / earthRadiusKm;
}
exports.kmToRadians = kmToRadians;
/**
 * Converts the input miles value in radians.
 * @param mi - The miles to convert.
 * @returns The corresponding number of radians.
 */
function miToRadians(mi) {
    return mi / earthRadiusMi;
}
exports.miToRadians = miToRadians;
//# sourceMappingURL=GeoSpatial.js.map