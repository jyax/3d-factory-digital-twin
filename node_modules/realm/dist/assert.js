"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = void 0;
const internal_1 = require("./internal");
/**
 * Expects the condition to be truthy
 * @throws an {@link Error} If the condition is not truthy. Throws either the {@link err} given as param if it's an {@link Error},
 * an {@link AssertionError} wrapping {@link err} if it's a string or undefined, or uses the result of invoking {@link err} if it's a function.
 * @param condition The condition that must be truthy to avoid throwing.
 * @param err Optional message or error to throw.
 * Or a function producing this, which is useful to avoid computing the error message in case it's not needed.
 * @internal
 */
function assert(condition, err) {
    if (!condition) {
        // Call any function to generate the error lazily
        err = typeof err === "function" ? err() : err;
        if (err instanceof Error) {
            throw err;
        }
        else if (typeof err === "string" || typeof err === "undefined") {
            throw new internal_1.AssertionError(err);
        }
        else {
            throw new Error("Expected err to be an Err, string, undefined or a function returning either.");
        }
    }
}
exports.assert = assert;
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.instanceOf = (value, constructor, target) => {
    assert(value instanceof constructor, () => new internal_1.TypeAssertionError(`an instance of ${constructor.name}`, value, target));
};
assert.string = (value, target) => {
    assert(typeof value === "string", () => new internal_1.TypeAssertionError("a string", value, target));
};
assert.number = (value, target) => {
    assert(typeof value === "number", () => new internal_1.TypeAssertionError("a number", value, target));
};
assert.numericString = (value, target) => {
    assert.string(value);
    assert(/^-?\d+$/.test(value), () => new internal_1.TypeAssertionError("a numeric string", value, target));
};
assert.boolean = (value, target) => {
    assert(typeof value === "boolean", () => new internal_1.TypeAssertionError("a boolean", value, target));
};
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.function = (value, target) => {
    assert(typeof value === "function", () => new internal_1.TypeAssertionError("a function", value, target));
};
assert.symbol = (value, target) => {
    assert(typeof value === "symbol", () => new internal_1.TypeAssertionError("a symbol", value, target));
};
assert.object = (value, target, { allowArrays } = { allowArrays: true }) => {
    assert(typeof value === "object" && value !== null && (allowArrays || !Array.isArray(value)), () => new internal_1.TypeAssertionError("an object", value, target));
};
assert.undefined = (value, target) => {
    assert(typeof value === "undefined", () => new internal_1.TypeAssertionError("undefined", value, target));
};
assert.null = (value, target) => {
    assert(value === null, () => new internal_1.TypeAssertionError("null", value, target));
};
assert.array = (value, target) => {
    assert(Array.isArray(value), () => new internal_1.TypeAssertionError("an array", value, target));
};
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.extends = (value, constructor, target) => {
    assert.function(value, target);
    assert(value.prototype instanceof constructor, () => new internal_1.TypeAssertionError(`a class extending ${constructor.name}`, value, target));
};
assert.iterable = (value, target) => {
    assert.object(value, target);
    assert(Symbol.iterator in value, () => new internal_1.TypeAssertionError("iterable", value, target));
};
// * Use arg type `value: never` rather than `value: unknown` to get a compile time
//   error when e.g. not including if-checks for all enum values.
// * Use return type `never` rather than `asserts value is never` to remove the
//   need for callers to explicitly throw (i.e. `throw assert.never()`) as a way
//   for TS to detect unreachable code.
assert.never = (value, target) => {
    throw new internal_1.TypeAssertionError("never", value, target);
};
// SDK specific
assert.primaryKey = (value, target) => {
    assert(value === null ||
        typeof value === "number" ||
        typeof value === "string" ||
        value instanceof internal_1.BSON.UUID ||
        value instanceof internal_1.BSON.ObjectId, () => new internal_1.TypeAssertionError("a primary key", value, target));
};
assert.open = (realm) => {
    assert(!realm.isClosed, "Cannot access realm that has been closed.");
};
assert.inTransaction = (realm, message = "Cannot modify managed objects outside of a write transaction.") => {
    assert.open(realm);
    assert(realm.isInTransaction, message);
};
assert.outTransaction = (realm, message = "Expected realm to be outside of a write transaction") => {
    assert.open(realm);
    assert(!realm.isInTransaction, message);
};
assert.isValid = (obj, message = "Accessing object which has been invalidated or deleted") => {
    assert(obj.isValid, message);
};
assert.isSameRealm = (realm1, realm2, message = "Expected the Realms to be the same") => {
    assert(realm1.$addr == realm2.$addr, message);
};
//# sourceMappingURL=assert.js.map