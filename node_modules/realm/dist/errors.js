"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompensatingWriteError = exports.ClientResetError = exports.SyncError = exports.fromBindingSyncError = exports.PropertySchemaParseError = exports.ObjectSchemaParseError = exports.SchemaParseError = exports.TimeoutError = exports.IllegalConstructorError = exports.TypeAssertionError = exports.AssertionError = void 0;
const internal_1 = require("./internal");
class AssertionError extends Error {
    /** @internal */
    constructor(message = "Assertion failed!") {
        super(message);
    }
}
exports.AssertionError = AssertionError;
class TypeAssertionError extends AssertionError {
    expected;
    value;
    /** @internal */
    static deriveType(value) {
        if (typeof value === "object") {
            if (value === null) {
                return "null";
            }
            else {
                const name = value.constructor.name;
                if (name === "Object") {
                    return "an object";
                }
                else if (name === "Array") {
                    return "an array";
                }
                else {
                    return "an instance of " + name;
                }
            }
        }
        else if (typeof value === "undefined") {
            return typeof value;
        }
        else if (typeof value === "function") {
            return `a function or class named ${value.name}`;
        }
        else {
            return "a " + typeof value;
        }
    }
    /**
     * Get an error message for when the target's value is of
     * the wrong type. Single quotes are added around the target
     * string if it does not already contain one.
     * @internal
     */
    static message(expected, value, target) {
        const actual = TypeAssertionError.deriveType(value);
        if (target) {
            target = target.includes("'") ? target : `'${target}'`;
        }
        else {
            target = "value";
        }
        return `Expected ${target} to be ${expected}, got ${actual}`;
    }
    /** @internal */
    constructor(/** @internal */ expected, /** @internal */ value, target) {
        super(TypeAssertionError.message(expected, value, target));
        this.expected = expected;
        this.value = value;
    }
    /** @internal */
    rename(name) {
        this.message = TypeAssertionError.message(this.expected, this.value, name);
    }
}
exports.TypeAssertionError = TypeAssertionError;
class IllegalConstructorError extends Error {
    constructor(type) {
        super(`Illegal constructor: ${type} objects are read from managed objects only.`);
    }
}
exports.IllegalConstructorError = IllegalConstructorError;
class TimeoutError extends Error {
    constructor(message) {
        super(`Timed out: ${message}`);
    }
}
exports.TimeoutError = TimeoutError;
class SchemaParseError extends Error {
    /** @internal */
    constructor(message) {
        super(message);
    }
}
exports.SchemaParseError = SchemaParseError;
class ObjectSchemaParseError extends SchemaParseError {
    objectName;
    /** @internal */
    constructor(message, info) {
        const displayName = info.objectName ? `object '${info.objectName}'` : "unnamed object";
        super(`Invalid schema for ${displayName}: ${message}`);
        this.objectName = info.objectName;
    }
}
exports.ObjectSchemaParseError = ObjectSchemaParseError;
class PropertySchemaParseError extends SchemaParseError {
    objectName;
    propertyName;
    /** @internal */
    constructor(message, info) {
        super(`Invalid type declaration for property '${info.propertyName}' on '${info.objectName}': ${message}`);
        this.objectName = info.objectName;
        this.propertyName = info.propertyName;
    }
}
exports.PropertySchemaParseError = PropertySchemaParseError;
/** @internal */
function fromBindingSyncError(error) {
    if (error.compensatingWritesInfo.length > 0) {
        return new CompensatingWriteError(error);
    }
    else if (error.isClientResetRequested) {
        return new ClientResetError(error);
    }
    else {
        return new SyncError(error);
    }
}
exports.fromBindingSyncError = fromBindingSyncError;
/**
 * An class describing a sync error.
 */
class SyncError extends Error {
    name = "SyncError";
    isOk;
    /**
     * The error code that represents this error.
     */
    code;
    /**
     * The category of this error.
     * @deprecated
     */
    category;
    reason;
    /**
     * The URL to the associated server log, if available. The string will be empty
     * if the sync error is not initiated by the server.
     */
    logUrl;
    /**
     * A record of extra user information associated with this error.
     */
    userInfo;
    /**
     * @deprecated Check the error message instead.
     */
    isFatal;
    /** @internal */
    constructor(error) {
        super(error.simpleMessage);
        this.message = error.simpleMessage;
        this.isOk = error.status.isOk;
        if (!error.status.isOk) {
            this.reason = error.status.reason;
            this.code = error.status.code;
        }
        this.category = "UNKNOWN";
        this.logUrl = error.logUrl;
        this.userInfo = error.userInfo;
        this.isFatal = error.isFatal;
    }
}
exports.SyncError = SyncError;
const RECOVERY_FILE_PATH_KEY = "RECOVERY_FILE_PATH";
/**
 * @deprecated Use the another {@link ClientResetMode} than {@link ClientResetMode.Manual}.
 * @see https://github.com/realm/realm-js/blob/main/CHANGELOG.md#1110-2022-11-01
 * @see https://github.com/realm/realm-js/issues/4135
 */
class ClientResetError extends SyncError {
    name = "ClientReset";
    config;
    /** @internal */
    constructor(error) {
        super(error);
        this.config = {
            path: error.userInfo[RECOVERY_FILE_PATH_KEY],
            readOnly: true,
        };
    }
}
exports.ClientResetError = ClientResetError;
/**
 * An error class that indicates that one or more object changes have been reverted by the server.
 * This can happen when the client creates/updates objects that do not match any subscription, or performs writes on
 * an object it didn't have permission to access.
 */
class CompensatingWriteError extends SyncError {
    /**
     * The array of information about each object that caused the compensating write.
     */
    writes = [];
    /** @internal */
    constructor(error) {
        super(error);
        for (const { objectName, primaryKey, reason } of error.compensatingWritesInfo) {
            internal_1.assert.primaryKey(primaryKey);
            this.writes.push({ objectName, reason, primaryKey });
        }
    }
}
exports.CompensatingWriteError = CompensatingWriteError;
//# sourceMappingURL=errors.js.map