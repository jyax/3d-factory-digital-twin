"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBindingRealmSchema = exports.fromBindingPropertySchema = exports.fromBindingObjectSchema = exports.getTypeName = void 0;
const internal_1 = require("../internal");
const TYPE_MAPPINGS = {
    [0 /* BindingPropertyType.Int */]: "int",
    [1 /* BindingPropertyType.Bool */]: "bool",
    [2 /* BindingPropertyType.String */]: "string",
    [3 /* BindingPropertyType.Data */]: "data",
    [4 /* BindingPropertyType.Date */]: "date",
    [5 /* BindingPropertyType.Float */]: "float",
    [6 /* BindingPropertyType.Double */]: "double",
    [9 /* BindingPropertyType.Mixed */]: "mixed",
    [10 /* BindingPropertyType.ObjectId */]: "objectId",
    [11 /* BindingPropertyType.Decimal */]: "decimal128",
    [12 /* BindingPropertyType.Uuid */]: "uuid",
    [128 /* BindingPropertyType.Array */]: "list",
    [256 /* BindingPropertyType.Set */]: "set",
    [512 /* BindingPropertyType.Dictionary */]: "dictionary",
    [8 /* BindingPropertyType.LinkingObjects */]: "linkingObjects",
    [7 /* BindingPropertyType.Object */]: "object",
    // These have no direct
    [64 /* BindingPropertyType.Nullable */]: null,
    //
    [896 /* BindingPropertyType.Collection */]: null,
    [960 /* BindingPropertyType.Flags */]: null,
};
/**
 * Get the string representation of a property type's base type (not including flags)
 * @internal
 */
function getTypeName(type, objectType) {
    const baseType = type & ~960 /* BindingPropertyType.Flags */;
    if (type & 128 /* BindingPropertyType.Array */) {
        if (baseType === 7 /* BindingPropertyType.Object */) {
            return `list<${objectType}>`;
        }
        else {
            return `list<${getTypeName(baseType, objectType)}>`;
        }
    }
    else if (type & 256 /* BindingPropertyType.Set */) {
        return `set<${getTypeName(baseType, objectType)}>`;
    }
    else if (type & 512 /* BindingPropertyType.Dictionary */) {
        return `dictionary<${getTypeName(baseType, objectType)}>`;
    }
    else if (baseType === 7 /* BindingPropertyType.Object */ && objectType) {
        internal_1.assert.string(objectType, "objectType");
        return `<${objectType}>`;
    }
    else {
        const result = TYPE_MAPPINGS[baseType];
        (0, internal_1.assert)(result, `Unexpected type ${type}`);
        return result;
    }
}
exports.getTypeName = getTypeName;
const COLLECTION_TYPES = [128 /* BindingPropertyType.Array */, 256 /* BindingPropertyType.Set */, 512 /* BindingPropertyType.Dictionary */];
/**
 * Implements https://github.com/realm/realm-js/blob/v11/src/js_schema.hpp#L433-L478
 * @internal
 */
function fromBindingObjectSchema({ name, computedProperties, persistedProperties, primaryKey, tableType, }) {
    const properties = [...computedProperties, ...persistedProperties];
    const result = {
        ctor: undefined,
        name,
        properties: Object.fromEntries(properties.map((property) => [property.publicName || property.name, fromBindingPropertySchema(property)])),
        embedded: tableType === 1 /* TableType.Embedded */,
        asymmetric: tableType === 2 /* TableType.TopLevelAsymmetric */,
    };
    // The primary key from the binding is an empty string when not set
    if (primaryKey) {
        result.primaryKey = primaryKey;
    }
    return result;
}
exports.fromBindingObjectSchema = fromBindingObjectSchema;
/**
 * Implements https://github.com/realm/realm-js/blob/v11/src/js_schema.hpp#L480-L530
 * @internal
 */
function fromBindingPropertySchema(propertySchema) {
    const { name, isIndexed, isFulltextIndexed, publicName } = propertySchema;
    const result = {
        name,
        indexed: isFulltextIndexed ? "full-text" : isIndexed,
        mapTo: name,
        ...fromBindingPropertyTypeName(propertySchema),
    };
    if (publicName) {
        result.name = publicName;
    }
    return result;
}
exports.fromBindingPropertySchema = fromBindingPropertySchema;
/** @internal */
function fromBindingPropertyTypeName(propertySchema) {
    const { type, objectType, linkOriginPropertyName } = propertySchema;
    const itemType = type & ~896 /* BindingPropertyType.Collection */;
    if (type & 64 /* BindingPropertyType.Nullable */) {
        const item = fromBindingPropertyTypeName({ ...propertySchema, type: type & ~64 /* BindingPropertyType.Nullable */ });
        return { ...item, optional: true };
    }
    if (itemType === 8 /* BindingPropertyType.LinkingObjects */) {
        (0, internal_1.assert)(type & 128 /* BindingPropertyType.Array */);
        internal_1.assert.string(linkOriginPropertyName, "linkOriginPropertyName");
        return {
            type: "linkingObjects",
            optional: false,
            objectType,
            property: linkOriginPropertyName,
        };
    }
    for (const collectionType of COLLECTION_TYPES) {
        if (type & collectionType) {
            const item = fromBindingPropertyTypeName({ ...propertySchema, type: itemType });
            return {
                type: TYPE_MAPPINGS[collectionType],
                objectType: item.type === "object" ? item.objectType : item.type,
                optional: item.type === "object" ? false : item.optional,
            };
        }
    }
    if (type === 7 /* BindingPropertyType.Object */) {
        if (!objectType) {
            throw new Error("Expected property with 'object' type to declare an objectType");
        }
        // TODO: Decide if this change is reasonable
        return { type: "object", objectType, optional: true }; // Implicitly nullable
    }
    else if (type === 8 /* BindingPropertyType.LinkingObjects */) {
        if (!objectType) {
            throw new Error("Expected property with 'object' type to declare an objectType");
        }
        return { type: "linkingObjects", objectType, optional: false };
    }
    const mappedType = TYPE_MAPPINGS[type];
    if (mappedType) {
        return { type: mappedType, optional: false };
    }
    else {
        throw new Error(`Unexpected type '${type}'`);
    }
}
/** @internal */
function fromBindingRealmSchema(schema) {
    return schema.map(fromBindingObjectSchema);
}
exports.fromBindingRealmSchema = fromBindingRealmSchema;
//# sourceMappingURL=from-binding.js.map