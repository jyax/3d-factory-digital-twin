import { RealmObject, Results, Subscription } from "../internal";
/**
 * Enum representing the state of a {@link SubscriptionSet}.
 */
export declare enum SubscriptionSetState {
    /**
     * The subscription update has been persisted locally, but the server hasn't
     * yet returned all the data that matched the updated subscription queries.
     */
    Pending = "pending",
    /**
     * The server has acknowledged the subscription and sent all the data that
     * matched the subscription queries at the time the SubscriptionSet was
     * updated. The server is now in steady-state synchronization mode where it
     * will stream updates as they come.
     */
    Complete = "complete",
    /**
     * The server has returned an error and synchronization is paused for this
     * Realm. To view the actual error, use `Subscriptions.error`.
     *
     * You can still use {@link SubscriptionSet.update} to update the subscriptions,
     * and if the new update doesn't trigger an error, synchronization will be restarted.
     */
    Error = "error",
    /**
     * The SubscriptionSet has been superseded by an updated one. This typically means
     * that someone has called {@link SubscriptionSet.update} on a different instance
     * of the {@link SubscriptionSet}. You should not use a superseded SubscriptionSet,
     * and instead obtain a new instance from {@link Realm.subscriptions}.
     */
    Superseded = "superseded"
}
/**
 * @deprecated Will be removed in v13.0.0. Please use {@link SubscriptionSetState}.
 */
export declare enum SubscriptionsState {
    /**
     * The subscription update has been persisted locally, but the server hasn't
     * yet returned all the data that matched the updated subscription queries.
     */
    Pending = "pending",
    /**
     * The server has acknowledged the subscription and sent all the data that
     * matched the subscription queries at the time the SubscriptionSet was
     * updated. The server is now in steady-state synchronization mode where it
     * will stream updates as they come.
     */
    Complete = "complete",
    /**
     * The server has returned an error and synchronization is paused for this
     * Realm. To view the actual error, use `Subscriptions.error`.
     *
     * You can still use {@link SubscriptionSet.update} to update the subscriptions,
     * and if the new update doesn't trigger an error, synchronization will be restarted.
     */
    Error = "error",
    /**
     * The SubscriptionSet has been superseded by an updated one. This typically means
     * that someone has called {@link SubscriptionSet.update} on a different instance
     * of the {@link SubscriptionSet}. You should not use a superseded SubscriptionSet,
     * and instead obtain a new instance from {@link Realm.subscriptions}.
     */
    Superseded = "superseded"
}
/**
 * Class representing the common functionality for the {@link SubscriptionSet} and
 * {@link MutableSubscriptionSet} classes.
 *
 * SubscriptionSets can only be modified inside a {@link SubscriptionSet.update} callback.
 *
 * The SubscriptionSet is an iterable; thus, the contained {@link Subscription}s can be
 * accessed in `for-of` loops or spread into an `Array` for access to the ECMAScript
 * Array API, e.g. `[...realm.subscriptions][0]`.
 */
export declare abstract class BaseSubscriptionSet {
    /**
     * Whether there are no subscriptions in the set.
     * @returns `true` if there are no subscriptions in the set, `false` otherwise.
     */
    get isEmpty(): boolean;
    /**
     * The version of the SubscriptionSet. This is incremented every time a
     * {@link SubscriptionSet.update} is applied.
     * @returns The version of the {@link SubscriptionSet}.
     */
    get version(): number;
    /**
     * @returns The state of the SubscriptionSet.
     */
    get state(): SubscriptionSetState;
    /**
     * If `state` is {@link SubscriptionSetState.Error}, this will be a string representing
     * why the {@link SubscriptionSet} is in an error state. It will be `null` if there is no error.
     * @returns A string representing the error, or `null` if there is no error.
     */
    get error(): string | null;
    /**
     * @returns The number of subscriptions in the set.
     */
    get length(): number;
    /**
     * Find a subscription by name.
     * @param name - The name to search for.
     * @returns The named subscription, or `null` if the subscription is not found.
     */
    findByName(name: string): Subscription | null;
    /**
     * Find a subscription by query. Will match both named and unnamed subscriptions.
     * @param query - The query to search for, represented as a {@link Results} instance,
     *  e.g. `Realm.objects("Cat").filtered("age > 10")`.
     * @returns The subscription with the specified query, or `null` if the subscription is not found.
     */
    findByQuery<Subscription>(query: Results<Subscription & RealmObject<Subscription>>): Subscription | null;
    /**
     * Makes the subscription set iterable.
     * @returns Iterable of each value in the set.
     * @example
     * for (const subscription of subscriptions) {
     *   // ...
     * }
     */
    [Symbol.iterator](): IterableIterator<Subscription>;
}
//# sourceMappingURL=BaseSubscriptionSet.d.ts.map