"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBCollection = void 0;
const internal_1 = require("../internal");
/**
 * A remote collection of documents in a MongoDB database.
 */
class MongoDBCollection {
    user;
    serviceName;
    databaseName;
    collectionName;
    functions;
    /** @internal */
    constructor(
    /** @internal */ user, serviceName, databaseName, collectionName) {
        this.user = user;
        this.serviceName = serviceName;
        this.databaseName = databaseName;
        this.collectionName = collectionName;
        this.functions = (0, internal_1.createFactory)(user, serviceName);
    }
    /**
     * The name of the collection.
     */
    get name() {
        return this.collectionName;
    }
    /**
     * Finds the documents which match the provided query.
     * @param filter - An optional filter applied to narrow down the results.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found documents.
     */
    find(filter = {}, options = {}) {
        return this.functions.find({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            project: options.projection,
            sort: options.sort,
            limit: options.limit,
        });
    }
    /**
     * Finds a document which matches the provided filter.
     * @param filter - A filter applied to narrow down the result.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document.
     */
    findOne(filter = {}, options = {}) {
        return this.functions.findOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            project: options.projection,
            sort: options.sort,
        });
    }
    /**
     * Finds a document which matches the provided query and performs the desired update to individual fields.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document before applying the update.
     */
    findOneAndUpdate(filter, update, options = {}) {
        return this.functions.findOneAndUpdate({
            database: this.databaseName,
            collection: this.name,
            filter,
            update,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /**
     * Finds a document which matches the provided filter and replaces it with a new document.
     * @param filter - A filter applied to narrow down the result.
     * @param replacement - The new replacing document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document found before replacement.
     */
    findOneAndReplace(filter, replacement, options = {}) {
        return this.functions.findOneAndReplace({
            database: this.databaseName,
            collection: this.name,
            filter: filter,
            update: replacement,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /**
     * Finds a document which matches the provided filter and deletes it
     * @param filter - A filter applied to narrow down the result.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document before deletion.
     */
    findOneAndDelete(filter = {}, options = {}) {
        return this.functions.findOneAndDelete({
            database: this.databaseName,
            collection: this.name,
            filter,
            sort: options.sort,
            projection: options.projection,
        });
    }
    /**
     * Runs an aggregation framework pipeline against this collection.
     * @param pipeline - An array of aggregation pipeline stages.
     * @returns A promise that resolves to the aggregation result.
     */
    aggregate(pipeline) {
        return this.functions.aggregate({
            database: this.databaseName,
            collection: this.name,
            pipeline,
        });
    }
    /**
     * Counts the number of documents in this collection matching the provided filter.
     *
     * Note: When calling this without a filter, you may receive inaccurate document counts
     * as it returns results based on the collection's metadata, which may result in an
     * approximate count. In particular:
     *  - On a sharded cluster, the resulting count will not correctly filter out
     *    {@link https://www.mongodb.com/docs/manual/reference/glossary/#std-term-orphaned-document orphaned documents}.
     *  - After an unclean shutdown or file copy based initial sync, the count may be incorrect.
     * @param filter - An optional filter applied to narrow down the results.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the number of documents matching the filter.
     */
    count(filter = {}, options = {}) {
        return this.functions.count({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            limit: options.limit,
        });
    }
    /**
     * Inserts a single document into the collection.
     * Note: If the document is missing an _id, one will be generated for it by the server.
     * @param document - The document to insert.
     * @returns A promise that resolves an object containing the inserted object ID (`insertedId`).
     */
    insertOne(document) {
        return this.functions.insertOne({
            database: this.databaseName,
            collection: this.name,
            document,
        });
    }
    /**
     * Inserts an array of documents into the collection.
     * If any values are missing identifiers, they will be generated by the server.
     * @param documents - The array of documents to insert.
     * @returns A promise that resolves to an object containing an array of IDs inserted (`insertedIds`).
     */
    insertMany(documents) {
        return this.functions.insertMany({
            database: this.databaseName,
            collection: this.name,
            documents,
        });
    }
    /**
     * Deletes a single matching document from the collection.
     * @param filter - A filter applied to narrow down the result.
     * @returns A promise that resolves to an object containing the number of deleted documents (`deletedCount`).
     */
    deleteOne(filter = {}) {
        return this.functions.deleteOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
        });
    }
    /**
     * Deletes multiple documents.
     * @param filter - A filter applied to narrow down the result. If omitted, it defaults
     *  to `{}` which deletes all documents in the collection.
     * @returns A promise that resolves to an object containing the number of deleted documents (`deletedCount`).
     */
    deleteMany(filter = {}) {
        return this.functions.deleteMany({
            database: this.databaseName,
            collection: this.name,
            query: filter,
        });
    }
    /**
     * Updates a single document matching the provided filter in this collection.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to an object containing:
     * ```
     * {
     *  matchedCount: number;
     *  modifiedCount: number;
     *  upsertedId: IdType | undefined;
     * }
     * ```
     */
    updateOne(filter, update, options = {}) {
        return this.functions.updateOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            update,
            upsert: options.upsert,
            arrayFilters: options.arrayFilters,
        });
    }
    /**
     * Updates multiple documents matching the provided filter in this collection.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the documents.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to an object containing:
     * ```
     * {
     *  matchedCount: number;
     *  modifiedCount: number;
     *  upsertedId: IdType | undefined;
     * }
     * ```
     */
    updateMany(filter, update, options = {}) {
        return this.functions.updateMany({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            update,
            upsert: options.upsert,
            arrayFilters: options.arrayFilters,
        });
    }
    async *watch({ ids, filter, } = {}) {
        const iterator = await this.user.callFunctionStreaming("watch", this.serviceName, {
            database: this.databaseName,
            collection: this.collectionName,
            ids,
            filter,
        });
        const watchStream = internal_1.binding.WatchStream.make();
        for await (const chunk of iterator) {
            if (!chunk)
                continue;
            // TODO: Remove `toArrayBuffer()` once https://jira.mongodb.org/browse/RJS-2124 gets solved
            const buffer = (0, internal_1.toArrayBuffer)(chunk);
            internal_1.binding.Helpers.feedBuffer(watchStream, buffer);
            while (watchStream.state === 1 /* binding.WatchStreamState.HaveEvent */) {
                yield watchStream.nextEvent();
            }
            if (watchStream.state === 2 /* binding.WatchStreamState.HaveError */) {
                throw watchStream.error;
            }
        }
    }
}
exports.MongoDBCollection = MongoDBCollection;
//# sourceMappingURL=MongoDBCollection.js.map