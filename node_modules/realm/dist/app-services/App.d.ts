import type { AnyFetch } from "@realm/fetch";
import { AnyUser, Credentials, DefaultFunctionsFactory, DefaultObject, EmailPasswordAuth, User, binding } from "../internal";
export type AnyApp = App<any, any>;
/**
 * Persistence modes for metadata.
 */
export declare enum MetadataMode {
    /**
     * Persist {@link User} objects, but do not encrypt them.
     */
    NoEncryption = "noEncryption",
    /**
     * Persist {@link User} objects in an encrypted store.
     */
    Encryption = "encryption",
    /**
     * Do not persist {@link User} objects.
     */
    NoMetadata = "noMetadata"
}
/**
 * Configuration for how to handle the `App`'s metadata.
 */
export type Metadata = {
    /**
     * The different modes for storing meta data in Realm Apps.
     * @since 12.2.0
     */
    mode: MetadataMode;
    /**
     * The 512-bit (64-byte) encryption key used to encrypt and decrypt meta data in Realm Apps.
     * This will not change the encryption key for individual Realms. This should still be set in
     * {@link BaseConfiguration.encryptionKey} when opening the Realm.
     * @since 12.2.0
     */
    encryptionKey?: ArrayBuffer;
};
/** @internal */
export declare function fromBindingMetadataModeToMetaDataMode(arg: binding.MetadataMode): MetadataMode;
/**
 * This describes the options used to create a Realm App instance.
 */
export type AppConfiguration = {
    /**
     * The Realm App ID
     * @since v10.0.0
     */
    id: string;
    /**
     * An optional URL to use as a prefix when sending requests to the Atlas App Services server.
     * @since v10.0.0
     */
    baseUrl?: string;
    /**
     * This describes the local app, sent to the server when a user authenticates.
     * Specifying this will enable the server to respond differently to specific versions of specific apps.
     * @since v10.0.0
     */
    app?: LocalAppConfiguration;
    /**
     * The timeout for requests (in milliseconds)
     * @since v10.0.0
     */
    timeout?: number;
    /**
     * Use the same underlying connection towards the server across multiple sync sessions.
     * This uses less resources on the server and provides a small increase in speed when opening subsequent synced Realms.
     * @default true
     */
    multiplexSessions?: boolean;
    /**
     * Specify where synced Realms and metadata is stored. If not specified, the current work directory is used.
     * @since v11.7.0
     */
    baseFilePath?: string;
    /**
     * Specify how meta data should be stored.
     * @since 12.2.0
     */
    metadata?: Metadata;
    /**
     * Overrides the fetch function used to perform network requests.
     */
    fetch?: AnyFetch;
};
/**
 * This describes the local app, sent to the server when a user authenticates.
 */
export type LocalAppConfiguration = {
    /**
     * The name / ID of the local app.
     * Note: This should be the name or a bundle ID of your app, not the Atlas App Services application.
     */
    name?: string;
    /**
     * The version of the local app.
     */
    version?: string;
};
export type AppChangeCallback = () => void;
/**
 * The class represents an Atlas App Services Application.
 *
 * ```js
 * const app = new App({ id: "my-app-qwert" });
 * ```
 */
export declare class App<FunctionsFactoryType extends DefaultFunctionsFactory = DefaultFunctionsFactory, CustomDataType extends DefaultObject = DefaultObject> {
    private static appById;
    private static appByUserId;
    /**
     * Get or create a singleton Realm App from an ID.
     * Calling this function multiple times with the same ID will return the same instance.
     * @deprecated Use {@link App.get}.
     * @param id - The Realm App ID visible from the Atlas App Services UI or a configuration.
     * @returns The Realm App instance.
     */
    static getApp(id: string): App;
    /**
     * Get or create a singleton Realm App from an ID.
     * Calling this function multiple times with the same ID will return the same instance.
     * @param id - The Realm App ID visible from the Atlas App Services UI or a configuration.
     * @returns The Realm App instance.
     */
    static get(id: string): App;
    /** @internal */
    static deviceInfo: binding.DeviceInfo;
    /** @internal */
    static userAgent: string;
    /** @internal */
    static getAppByUser(userInternal: binding.SyncUser): App;
    /** @internal */
    static setAppByUser(userInternal: binding.SyncUser, currentApp: AnyApp): void;
    /** @internal */
    internal: binding.App;
    private listeners;
    /**
     * Constructs a new {@link App} instance, used to connect to an Atlas App Services App.
     * @param id - A string app ID.
     * @throws an {@link Error} If no {@link id} is provided.
     */
    constructor(id: string);
    /**
     * Constructs a new {@link App} instance, used to connect to an Atlas App Services App.
     * @param config - The configuration of the app.
     * @throws an {@link Error} If no {@link AppConfiguration.id | app id} is provided.
     */
    constructor(config: AppConfiguration);
    /**
     * @returns The app ID.
     */
    get id(): string;
    /**
     * Log in a user.
     * @param credentials - A credentials object describing the type of authentication provider and its parameters.
     * @returns A promise that resolves to the logged in {@link User}.
     * @throws An {@link Error} if the login failed.
     */
    logIn(credentials: Credentials): Promise<User<FunctionsFactoryType, CustomDataType>>;
    /**
     * Perform operations related to the email/password auth provider.
     * @returns An instance of the email password authentication provider.
     */
    get emailPasswordAuth(): EmailPasswordAuth;
    /**
     * The last user to log in or being switched to.
     * @returns A {@link User} object representing the currently logged in user. If no user is logged in, `null` is returned.
     */
    get currentUser(): User<FunctionsFactoryType, CustomDataType> | null;
    /**
     * All users that have logged into the device and have not been removed.
     * @returns A mapping from user ID to user.
     */
    get allUsers(): Readonly<Record<string, User<FunctionsFactoryType, CustomDataType>>>;
    /**
     * Switches the current user to the one specified in {@link user}.
     * @throws an {@link Error} if the new user is logged out or removed.
     * @param user - The user to switch to.
     */
    switchUser(user: AnyUser): void;
    /**
     * Logs out and removes a user from the client.
     * @returns A promise that resolves once the user has been logged out and removed from the app.
     */
    removeUser(user: AnyUser): Promise<void>;
    /**
     * Delete the user.
     * NOTE: This irrecoverably deletes the user from the device as well as the server!
     * @returns A promise that resolves once the user has been deleted.
     */
    deleteUser(user: AnyUser): Promise<void>;
    /**
     * Adds a listener that will be fired on various user events.
     * This includes login, logout, switching users, linking users and refreshing custom data.
     * @param callback - A callback function that will be called when the event occurs.
     */
    addListener(callback: AppChangeCallback): void;
    /**
     * Removes an event listener previously added via {@link App.addListener}.
     * @param callback - The callback to remove.
     */
    removeListener(callback: AppChangeCallback): void;
    /**
     * Removes all event listeners previously added via {@link App.addListener}.
     */
    removeAllListeners(): void;
}
import * as internal from "../internal";
export declare namespace App {
    /**
     * All credentials available for authentication.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/
     */
    type Credentials = internal.Credentials;
    export import Sync = internal.Sync;
}
