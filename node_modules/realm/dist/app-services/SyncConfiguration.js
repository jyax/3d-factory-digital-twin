"use strict";
////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSyncConfiguration = exports.toBindingSyncConfig = exports.ProxyType = exports.ClientResetMode = exports.SessionStopPolicy = exports.OpenRealmTimeOutBehavior = exports.OpenRealmBehaviorType = void 0;
const bson_1 = require("bson");
const internal_1 = require("../internal");
var OpenRealmBehaviorType;
(function (OpenRealmBehaviorType) {
    OpenRealmBehaviorType["DownloadBeforeOpen"] = "downloadBeforeOpen";
    OpenRealmBehaviorType["OpenImmediately"] = "openImmediately";
})(OpenRealmBehaviorType = exports.OpenRealmBehaviorType || (exports.OpenRealmBehaviorType = {}));
var OpenRealmTimeOutBehavior;
(function (OpenRealmTimeOutBehavior) {
    OpenRealmTimeOutBehavior["OpenLocalRealm"] = "openLocalRealm";
    OpenRealmTimeOutBehavior["ThrowException"] = "throwException";
})(OpenRealmTimeOutBehavior = exports.OpenRealmTimeOutBehavior || (exports.OpenRealmTimeOutBehavior = {}));
var SessionStopPolicy;
(function (SessionStopPolicy) {
    SessionStopPolicy["AfterUpload"] = "after-upload";
    SessionStopPolicy["Immediately"] = "immediately";
    SessionStopPolicy["Never"] = "never";
})(SessionStopPolicy = exports.SessionStopPolicy || (exports.SessionStopPolicy = {}));
/**
 */
var ClientResetMode;
(function (ClientResetMode) {
    /** @deprecated See {@link Realm.App.Sync.initiateClientReset} */
    ClientResetMode["Manual"] = "manual";
    /**
     * Download a fresh copy from the server.
     */
    ClientResetMode["DiscardUnsyncedChanges"] = "discardUnsyncedChanges";
    /**
     * Merged remote and local, unsynced changes.
     */
    ClientResetMode["RecoverUnsyncedChanges"] = "recoverUnsyncedChanges";
    /**
     * Download a fresh copy from the server if recovery of unsynced changes is not possible.
     */
    ClientResetMode["RecoverOrDiscardUnsyncedChanges"] = "recoverOrDiscardUnsyncedChanges";
})(ClientResetMode = exports.ClientResetMode || (exports.ClientResetMode = {}));
var ProxyType;
(function (ProxyType) {
    ProxyType["HTTP"] = "http";
    ProxyType["HTTPS"] = "https";
})(ProxyType = exports.ProxyType || (exports.ProxyType = {}));
/** @internal */
function toBindingSyncConfig(config) {
    const { user, flexible, partitionValue, onError, _sessionStopPolicy, customHttpHeaders, ssl, clientReset, cancelWaitsOnNonFatalError, proxyConfig, } = config;
    return {
        user: user.internal,
        partitionValue: flexible ? undefined : bson_1.EJSON.stringify(partitionValue),
        flxSyncRequested: !!flexible,
        stopPolicy: _sessionStopPolicy
            ? (0, internal_1.toBindingStopPolicy)(_sessionStopPolicy)
            : 2 /* binding.SyncSessionStopPolicy.AfterChangesUploaded */,
        customHttpHeaders,
        clientValidateSsl: ssl?.validate,
        sslTrustCertificatePath: ssl?.certificatePath,
        sslVerifyCallback: ssl?.validateCertificates
            ? internal_1.binding.Helpers.makeSslVerifyCallback(toSSLVerifyCallbackWithListArguments(ssl.validateCertificates))
            : undefined,
        ...parseClientResetConfig(clientReset, onError),
        cancelWaitsOnNonfatalError: cancelWaitsOnNonFatalError,
        proxyConfig: proxyConfig ? parseSyncProxyConfig(proxyConfig) : internal_1.syncProxyConfig.create(),
    };
}
exports.toBindingSyncConfig = toBindingSyncConfig;
/** @internal */
function toSSLVerifyCallbackWithListArguments(verifyCallback) {
    return (serverAddress, serverPort, pemCertificate, preverifyOk, depth) => verifyCallback({ serverAddress, serverPort, pemCertificate, acceptedByOpenSSL: !!preverifyOk, depth });
}
/** @internal */
function parseClientResetConfig(clientReset, onError) {
    if (!clientReset) {
        return {
            clientResyncMode: 2 /* binding.ClientResetMode.Recover */,
            notifyBeforeClientReset: undefined,
            notifyAfterClientReset: undefined,
            errorHandler: onError ? (0, internal_1.toBindingErrorHandler)(onError) : undefined,
        };
    }
    switch (clientReset.mode) {
        case ClientResetMode.Manual: {
            return parseManual(clientReset, onError);
        }
        case ClientResetMode.DiscardUnsyncedChanges: {
            return {
                ...parseDiscardUnsyncedChanges(clientReset),
                errorHandler: onError ? (0, internal_1.toBindingErrorHandler)(onError) : undefined,
            };
        }
        case ClientResetMode.RecoverUnsyncedChanges: {
            return {
                ...parseRecoverUnsyncedChanges(clientReset),
                errorHandler: onError ? (0, internal_1.toBindingErrorHandler)(onError) : undefined,
            };
        }
        case ClientResetMode.RecoverOrDiscardUnsyncedChanges: {
            return {
                ...parseRecoverOrDiscardUnsyncedChanges(clientReset),
                errorHandler: onError ? (0, internal_1.toBindingErrorHandler)(onError) : undefined,
            };
        }
    }
}
/** @internal */
function parseManual(clientReset, onError) {
    return {
        clientResyncMode: (0, internal_1.toBindingClientResetMode)(clientReset.mode),
        errorHandler: (0, internal_1.toBindingErrorHandlerWithOnManual)(onError, clientReset.onManual),
    };
}
/** @internal */
function parseDiscardUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: (0, internal_1.toBindingClientResetMode)(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? (0, internal_1.toBindingNotifyBeforeClientReset)(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter ? (0, internal_1.toBindingNotifyAfterClientReset)(clientReset.onAfter) : undefined,
    };
}
/** @internal */
function parseRecoverUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: (0, internal_1.toBindingClientResetMode)(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? (0, internal_1.toBindingNotifyBeforeClientReset)(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter
            ? (0, internal_1.toBindingNotifyAfterClientResetWithFallback)(clientReset.onAfter, clientReset.onFallback)
            : undefined,
    };
}
/** @internal */
function parseRecoverOrDiscardUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: (0, internal_1.toBindingClientResetMode)(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? (0, internal_1.toBindingNotifyBeforeClientReset)(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter
            ? (0, internal_1.toBindingNotifyAfterClientResetWithFallback)(clientReset.onAfter, clientReset.onFallback)
            : undefined,
    };
}
/** @internal */
function parseProxyType(proxyType) {
    switch (proxyType) {
        case ProxyType.HTTP:
            return 0 /* binding.ProxyType.Http */;
        case ProxyType.HTTPS:
            return 1 /* binding.ProxyType.Https */;
    }
}
/** @internal */
function parseSyncProxyConfig(syncProxyConfig) {
    return {
        ...syncProxyConfig,
        type: parseProxyType(syncProxyConfig.type),
    };
}
/**
 * Validate the fields of a user-provided realm sync configuration.
 * @internal
 */
function validateSyncConfiguration(config) {
    internal_1.assert.object(config, "'sync' on realm configuration", { allowArrays: false });
    const { user, newRealmFileBehavior, existingRealmFileBehavior, onError, customHttpHeaders, ssl, clientReset, flexible, cancelWaitOnNonFatalError: cancelWaitsOnNonFatalError, } = config;
    internal_1.assert.instanceOf(user, internal_1.User, "'user' on realm sync configuration");
    if (cancelWaitsOnNonFatalError !== undefined) {
        internal_1.assert.boolean(cancelWaitsOnNonFatalError, "'cancelWaitOnNonFatalError' on sync configuration");
    }
    if (newRealmFileBehavior !== undefined) {
        validateOpenRealmBehaviorConfiguration(newRealmFileBehavior, "newRealmFileBehavior");
    }
    if (existingRealmFileBehavior !== undefined) {
        validateOpenRealmBehaviorConfiguration(existingRealmFileBehavior, "existingRealmFileBehavior");
    }
    if (onError !== undefined) {
        internal_1.assert.function(onError, "'onError' on realm sync configuration");
    }
    if (customHttpHeaders !== undefined) {
        internal_1.assert.object(customHttpHeaders, "'customHttpHeaders' on realm sync configuration", { allowArrays: false });
        for (const key in customHttpHeaders) {
            internal_1.assert.string(customHttpHeaders[key], "all property values of 'customHttpHeaders' on realm sync configuration");
        }
    }
    if (ssl !== undefined) {
        validateSSLConfiguration(ssl);
    }
    if (clientReset !== undefined) {
        validateClientResetConfiguration(clientReset);
    }
    // Assume the user intends to use Flexible Sync for all truthy values provided.
    if (flexible) {
        validateFlexibleSyncConfiguration(config);
    }
    else {
        validatePartitionSyncConfiguration(config);
    }
}
exports.validateSyncConfiguration = validateSyncConfiguration;
/**
 * Validate the fields of a user-provided open realm behavior configuration.
 */
function validateOpenRealmBehaviorConfiguration(config, target) {
    internal_1.assert.object(config, `'${target}' on realm sync configuration`, { allowArrays: false });
    (0, internal_1.assert)(config.type === OpenRealmBehaviorType.DownloadBeforeOpen || config.type === OpenRealmBehaviorType.OpenImmediately, `'${target}.type' on realm sync configuration must be either '${OpenRealmBehaviorType.DownloadBeforeOpen}' or '${OpenRealmBehaviorType.OpenImmediately}'.`);
    if (config.timeOut !== undefined) {
        internal_1.assert.number(config.timeOut, `'${target}.timeOut' on realm sync configuration`);
    }
    if (config.timeOutBehavior !== undefined) {
        (0, internal_1.assert)(config.timeOutBehavior === OpenRealmTimeOutBehavior.OpenLocalRealm ||
            config.timeOutBehavior === OpenRealmTimeOutBehavior.ThrowException, `'${target}.timeOutBehavior' on realm sync configuration must be either '${OpenRealmTimeOutBehavior.OpenLocalRealm}' or '${OpenRealmTimeOutBehavior.ThrowException}'.`);
    }
}
/**
 * Validate the fields of a user-provided SSL configuration.
 */
function validateSSLConfiguration(config) {
    internal_1.assert.object(config, "'ssl' on realm sync configuration");
    if (config.validate !== undefined) {
        internal_1.assert.boolean(config.validate, "'ssl.validate' on realm sync configuration");
    }
    if (config.certificatePath !== undefined) {
        internal_1.assert.string(config.certificatePath, "'ssl.certificatePath' on realm sync configuration");
    }
    if (config.validateCertificates !== undefined) {
        internal_1.assert.function(config.validateCertificates, "'ssl.validateCertificates' on realm sync configuration");
    }
}
/**
 * Validate the fields of a user-provided client reset configuration.
 */
function validateClientResetConfiguration(config) {
    internal_1.assert.object(config, "'clientReset' on realm sync configuration", { allowArrays: false });
    const modes = Object.values(ClientResetMode);
    (0, internal_1.assert)(modes.includes(config.mode), `'clientReset' on realm sync configuration must be one of the following: '${modes.join("', '")}'`);
    if (config.onManual !== undefined) {
        internal_1.assert.function(config.onManual, "'clientReset.onManual' on realm sync configuration");
    }
    if (config.onAfter !== undefined) {
        internal_1.assert.function(config.onAfter, "'clientReset.onAfter' on realm sync configuration");
    }
    if (config.onBefore !== undefined) {
        internal_1.assert.function(config.onBefore, "'clientReset.onBefore' on realm sync configuration");
    }
    if (config.onFallback !== undefined) {
        internal_1.assert.function(config.onFallback, "'clientReset.onFallback' on realm sync configuration");
    }
}
/**
 * Validate the fields of a user-provided realm flexible sync configuration.
 */
function validateFlexibleSyncConfiguration(config) {
    const { flexible, partitionValue, initialSubscriptions } = config;
    (0, internal_1.assert)(flexible === true, "'flexible' must always be true for realms using flexible sync. To enable partition-based sync, remove 'flexible' and specify 'partitionValue'.");
    if (initialSubscriptions !== undefined) {
        internal_1.assert.object(initialSubscriptions, "'initialSubscriptions' on realm sync configuration", { allowArrays: false });
        internal_1.assert.function(initialSubscriptions.update, "'initialSubscriptions.update' on realm sync configuration");
        if (initialSubscriptions.rerunOnOpen !== undefined) {
            internal_1.assert.boolean(initialSubscriptions.rerunOnOpen, "'initialSubscriptions.rerunOnOpen' on realm sync configuration");
        }
    }
    (0, internal_1.assert)(partitionValue === undefined, "'partitionValue' cannot be specified when flexible sync is enabled. To enable partition-based sync, remove 'flexible' and specify 'partitionValue'.");
}
/**
 * Validate the fields of a user-provided realm partition sync configuration.
 */
function validatePartitionSyncConfiguration(config) {
    const { flexible, partitionValue, initialSubscriptions } = config;
    validatePartitionValue(partitionValue);
    // We only allow `flexible` to be `true` (for Flexible Sync) or `undefined` (for Partition Sync).
    // `{ flexible: false }` is not allowed because TypeScript cannot discriminate that type correctly
    // with `strictNullChecks` disabled, and there is no real use case for `{ flexible: false }`.
    (0, internal_1.assert)(flexible === undefined, "'flexible' can only be specified to enable flexible sync. To enable flexible sync, remove 'partitionValue' and set 'flexible' to true.");
    (0, internal_1.assert)(initialSubscriptions === undefined, "'initialSubscriptions' can only be specified when flexible sync is enabled. To enable flexible sync, remove 'partitionValue' and set 'flexible' to true.");
}
/**
 * Validate the user-provided partition value of a realm sync configuration.
 */
function validatePartitionValue(value) {
    if (typeof value === "number") {
        (0, internal_1.assert)(Number.isSafeInteger(value), `Expected 'partitionValue' on realm sync configuration to be an integer, got ${value}.`);
    }
    else {
        (0, internal_1.assert)(typeof value === "string" || value instanceof bson_1.ObjectId || value instanceof bson_1.UUID || value === null, `Expected 'partitionValue' on realm sync configuration to be an integer, string, ObjectId, UUID, or null, got ${internal_1.TypeAssertionError.deriveType(value)}.`);
    }
}
//# sourceMappingURL=SyncConfiguration.js.map