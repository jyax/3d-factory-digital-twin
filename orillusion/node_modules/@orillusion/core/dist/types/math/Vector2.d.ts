/***
 * Vector 2D
 * @group Math
 */
export declare class Vector2 {
    /**
     * @internal
     */
    static HELP_0: Vector2;
    /**
     * @internal
     */
    static HELP_1: Vector2;
    /**
     * @internal
     */
    static HELP_2: Vector2;
    static readonly ZERO: Vector2;
    static readonly SAFE_MAX: Vector2;
    static readonly SAFE_MIN: Vector2;
    /**
     * The x component of the vector, the default value is 0.
    */
    x: number;
    /**
     * The y component of the vector, the default value is 0.
     */
    y: number;
    /**
     * Create a new Vector2.
     * @param x The x component of the vector, which defaults to 0.
     * @param y The y component of the vector, which defaults to 0.
     */
    constructor(x?: number, y?: number);
    /**
     * Returns the Angle, in radians, between two vectors.
     * @param a Vector a
     * @param b Vector b
     * @returns result
     */
    static getAngle(a: Vector2, b: Vector2): number;
    /**
     * Computes linear interpolation between two vectors.
     * @param from starting vector
     * @param to The vector in which you interpolate
     * @param t
     */
    static slerp(from: Vector2, to: Vector2, t: number): Vector2;
    /**
     * Linear interpolation between two vectors.
     * @param from starting vector
     * @param to  The vector in which you interpolate
     * @param t
     * @returns
     */
    static lerp(from: Vector2, to: Vector2, t: number): Vector2;
    /**
     * Sets the x and y components of this vector.
     * @param x The x component of the vector, which defaults to 0.
     * @param y The y component of the vector, which defaults to 0.
     */
    set(x?: number, y?: number): this;
    /**
     * Calculate the distance between this vector and the incoming vector.
     * @param a Target vector
     * @returns
     */
    distance(a: Vector2): number;
    /**
     * Add the vectors.
     * @param a
     * @param target
     * @returns
     */
    add(a: Vector2, target?: Vector2): Vector2;
    /**
     * Vector subtraction
     * @param a
     * @param target
     *
     */
    sub(a: Vector2, target?: Vector2): Vector2;
    /**
     * Let's multiply the x and y values of this vector times v.
     * @param v
     */
    scale(v: number): this;
    /**
     * Let's multiply the x and y values of this vector by a.
     * @param a
     * @param target
     * @returns
     */
    multiply(a: number, target?: Vector2): Vector2;
    /**
     * Let's multiply the x and y values of this vector by a.
     * @param a
     * @param target
     * @returns
     */
    multiplyScaler(a: number): this;
    /**
     * We're going to divide the x and y values of this vector by v.
     * @param v
     * @param target
     * @returns
     */
    divide(v: number, target?: Vector2): Vector2;
    /**
     * Vector inversion
     * @param target
     * @returns
     */
    neg(target?: Vector2): Vector2;
    abs(): number;
    /**
     * Length of vector
     * @returns
     */
    length(): number;
    /**
     * Returns the Angle, in radians, between the current vector and the target vector.
     * @param target Target vector
     * @returns
     */
    getAngle(target: Vector2): number;
    unt(target?: Vector2): Vector2;
    angleTo(v: Vector2): number;
    /**
     * Whether two vectors are equal
     * @param a Vector of comparison
     * @returns
     */
    equals(a: Vector2): boolean;
    pal(a: Vector2): number;
    /**
     * Returns a new vector that has the same x and y as the current vector.
     * @returns
     */
    clone(): Vector2;
    /**
     * Copy the x and y properties of the source vector to this vector
     * @param v Source vector
     * @returns
     */
    copyFrom(v: Vector2): Vector2;
    /**
     * Take the dot product of two vectors.
     * @param value Target vector
     * @returns
     */
    dot(value: Vector2): number;
    /**
     * Convert this vector to a unit vector.
     */
    normalize(): this;
    /**
     * Add two vectors
     * @param otherVector Additive vector
     * @returns
     */
    addInPlace(otherVector: Vector2): this;
    /**
     * Add the scalar to the x and y of this vector.
     * @param s Additive scalar
     * @returns
     */
    addScalar(s: number): this;
    /**
     *
     * @param minVal Component will be limited to the minimum value of
     * @param maxVal The component will be limited to the maximum value of
     * @returns
     */
    clampScalar(minVal: number, maxVal: number): this;
}
